- en: Rust on the Web with WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust extends far beyond its system programming domain and can be made to run
    on the web as well. In this chapter, we'll explore one such technology for doing
    this, called WebAssembly. We'll go into the details of what exactly WebAssembly
    is, and how Rust can be made to run alongside JavaScript using this technology.Being
    able to run on web browsers unlocks a domain that enables Rust to be used by a
    much larger audience, that is, the community of web developers, and enables them
    to leverage the performance of a systems language in their applications. Later
    in this chapter, we'll explore the tools and libraries that offer WebAssembly
    support, and build a live markdown editor that invokes an API implemented in Rust
    for rendering markdown documents to an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the following topics
  prefs: []
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goals of WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can WebAssembly be used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tale of Rust and WebAssembly and available crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a WebAssembly-based web application in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is WebAssembly?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Be curious. Read widely. Try new things. I think a lot of what people call
    intelligence boils down to curiosity."                                       
                                                                               – Aaron
    Swartz'
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is a suite of technologies and specifications that allows native
    code to run on the web by compiling down to a low-level programming language called
    **wasm**. From a usability perspective, it's a set of technologies that allows
    programs written in other non-web programming languages to run on web browsers.
    From a technical standpoint, WebAssembly is a virtual machine specification with
    a binary, load-time-efficient **Instruction Set Architecture (ISA)**. Okay, that's
    jargon overload. Let's simplify this definition a bit. As we know, a compiler
    is a complex program that turns code written in a human-readable programming language
    into machine code consisting of zeroes and ones. However, this translation happens
    in a multi-step process. It does this in several phases of compilation where,
    in the end, it gets compiled to the assembly language that's specific to the machine.
    Following that, the machine-specific assembler encodes it to the machine code
    by following the rules specified in the ISA for the target machine. Here, the
    compiler is targeting a real machine. However, it doesn't always have to be a
    real machine. It can also be a virtual machine (VM) executing its own virtual
    instruction set on top of a real machine. One example of virtual machines are
    video game emulators such as the Gameboy emulator that runs on normal computers
    and emulates the Gameboy hardware. A WebAssembly virtual machine is similar to
    that! Here, the browser engine implements the WebAssembly virtual machine, which
    enables us to run wasm code alongside JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: An instruction set architecture or ISA defines how a computer executes instructions
    and what sort of operations it supports at the lowest level. This ISA doesn't
    have to always be for a real physical machine; it can also be defined for a virtual
    machine. Wasm is the ISA for WebAssembly virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: The past 5 years of increasing dependence on the web and its diverse range of
    applications has resulted in developers trying hard to transpile their code to
    JavaScript. This is because JavaScript is the most popular and is the only cross-platform
    technology on the web. One project, called `asm.js`, from Mozilla (a faster-typed
    subset of JavaScript) was the first effort to make the web more efficient and
    fast enough to meet growing demands. From `asm.js` and its founding principles
    and learned lessons, WebAssembly was born.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is a joint effort from the browser committee bodies of various major
    companies, namely Mozilla, Google, Apple, and Microsoft. Since early 2018, it
    has seen a tremendous rise in popularity as a compilation target for a wide variety
    of languages, ranging from *C++* using the Emscripten toolchain, Rust using LLVM/Emscripten,
    TypeScript using AssemblyScript, and many others. As of 2019, all major browsers
    implement a WebAssembly virtual machine in their web browser engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly has the name assembly in it, as it''s a low-level programming language
    similar to assembly instructions. It has a limited set of primitive types, which
    makes the language simple to parse and run. It supports the following types natively:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i32**: 32-bit integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**i64**: 64-bit integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**f32**: 32-bit floating point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**f64**: 64-bit floating point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's less of a programming language that you will write daily, like JavaScript,
    but more of a compilation target for compilers. The WebAssembly platform and the
    ecosystem is currently focused on running this technology on the web, but it's
    not limited to the web in any way. If a platform implements the WebAssembly virtual
    machine specification as a program, a wasm program will be able to run on that
    virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: To support WebAssembly on any platform, a virtual machine needs to be implemented
    in the language that is supported by the platform. This is just like JVM's platform-agnostic
    code—write once, run faster, safe anywhere! But it's primary target, as of now,
    is the browser. Most web browsers come with a JavaScript parser that can parse
    `.js` files in their browser engines to enable all sorts of interactivity for
    the user. To allow the web to interpret wasm files too, these engines implement
    the WebAssembly VM within them, allowing browsers to interpret and run wasm code
    alongside JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: A stark difference between parsing JavaScript and parsing WebAssembly code is
    that wasm code is an order of magnitude faster to parse because of its compact
    representation. Most of the initial page-load time on dynamic websites is spent
    on parsing JavaScript code, and using WebAssembly can provide a huge boost in
    performance for these websites. The goal of WebAssembly, however, is not to replace
    JavaScript, but to be a helping hand for JavaScript when performance matters.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly''s language comes in two formats, as per the specification, which
    is defined at [https://webassembly.org/](https://webassembly.org/): the human-readable
    text format, `.wat`, which is suitable for viewing and debugging WebAssembly code
    before its final deployment, and the compact, low-level machine format called
    **wasm**. The `.wasm` format is the one that''s interpreted and executed by the
    WebAssembly VM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A WebAssembly program starts with a module. Within a module, you can define
    variables, functions, constants, and so on. Wasm programs are written as s-expressions.
    S-expressions are a concise way to represent programs via a nested sequence of
    parenthesis-delimited blocks. For instance, a single `(1)` is an s-expression
    that returns the value `1`. Every s-expression in WebAssembly returns a value.
    Let''s take a look at a very minimal WebAssembly program in the readable `.wat`
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `wat` code, we have a parent s-expression block `(module)`
    that contains other nested s-expressions. Inside `module`, we have sections called
    `table`, `memory`, and `export`, and a `func` definition called `$one`, which
    returns an `i32`. We won't be going into the details of them, as that would digress
    us too far.
  prefs: []
  type: TYPE_NORMAL
- en: The important point to mention about wasm programs is that they are very efficient
    in their representation and can be sent and parsed much faster in browsers than
    JavaScript. Having said that, WebAssembly was designed with a focused set of goals
    and not to be a general-purpose programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Design goals of WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebAssembly''s design is the result of a joint collaboration between major
    browser vendors. Together, they aim to shape its design with the following goals
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be as safe and universal as JavaScript**: The web platform is an unsafe environment
    and having untrusted code run is detrimental to the safety of users on the web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run as quickly as native code**: Because the language is quite compact, WebAssembly
    can be loaded faster than JavaScript code and can be interpreted five times faster
    than JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provide consistent, predictable performance**: Being statically typed, and
    with very minimal analysis happening at runtime, WebAssembly is able to provide
    consistent performance on the web, whereas JavaScript falls short because of its
    dynamic nature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow code reuse between web and native**: A lot of existing code bases in
    C/C++, Rust, and other languages can now be reused and run on the web after compilation
    to WebAssembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though WebAssembly modules can be written by hand, it is not advisable to do
    so, as the code is hard to maintain and is not human-friendly. It is a pretty
    low-level language and, as a result, creating complex applications using raw wasm
    code can be challenging and time-consuming. Instead, it is often compiled to,
    or generated from, a variety of languages. Let's look at the available tools that
    we can use to explore the details of how WebAssembly programs are written and
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Trying it out online
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss how WebAssembly is used as a compilation target across different
    language ecosystems, we can explore it online without requiring any kind of setup
    on our machine. Some tools that can be used to do this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WebAssembly Studio**: The folks at Mozilla have created a really handy tool
    to try out WebAssembly in a quick way, and it''s hosted at [https://webassembly.studio](https://webassembly.studio).
    Using this tool, we can experiment and prototype ideas in WebAssembly really quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wasm Fiddle**: This is another handy tool for trying out wasm code online,
    and can be found at [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other tools online and community resources for you to explore, all
    of which you can find at [https://github.com/mbasso/awesome-wasm](https://github.com/mbasso/awesome-wasm).
  prefs: []
  type: TYPE_NORMAL
- en: Ways to generate WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several compiler toolchain projects that can help developers compile
    their code from any language to wasm. Compiling native code has huge implications
    for the web. It means that most major performance-intensive code can now be run
    on the web. For instance, C++ code can be compiled to wasm using the emscripten
    LLVM backend. The emscripten project takes in the LLVM IR generated by the C++
    compiler and converts it into WebAssembly modules in wasm format. There are also
    projects such as AssemblyScript, which convert TypeScript code into WebAssembly
    using another emscripten-like tool, called binaryen. Rust also supports emitting
    WebAssembly code by default using LLVM''s native WebAssembly backend. Compiling
    to wasm with Rust is very simple. First, we need to add the wasm by running the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is done, we can compile any Rust program to wasm by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is the bare minimum that's needed to create a wasm file from a Rust crate,
    but it's a lot of hand holding from there. Fortunately, there are amazing projects
    being developed around the wasm and Rust ecosystem that allow for more higher-level,
    intuitive interaction with JavaScript and Rust, and vice versa. We'll explore
    one such project, called wasm-bindgen, and build a real-world web application
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: Rust and WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ecosystem around Rust and WebAssembly is hurtling at quite a fast pace and
    it'll take time before the community agrees on a set of tools for building practical
    applications. Fortunately, some tools and libraries are emerging that give us
    a picture of what to expect as developers when building applications for the web
    in Rust using WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll explore a crate from the community called `wasm-bindgen`*.*
    This crate is pretty much a work in progress, as the WebAssembly specification
    itself is a work in progress, but nonetheless, it is quite feature-rich to explore
    what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Wasm-bindgen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`wasm-bindgen` is a crate that was developed by the rust-wasm team on GitHub.
    It allows Rust code to call JavaScript code and vice versa. Based on this library,
    other higher-level libraries have been built, such as the `web-sys` crate and
    the `js-sys` crate.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript by itself is what is defined by the ECMA standard, but the standard
    does not specify how it works on the web. JavaScript can support many hosts and
    the web happens to be one of them. The `web-sys` crate gives access to all of
    the JavaScript APIs on the web, that is, DOM APIs such as `Window`, `Navigator`,
    `EventListener`, and so on. The `js-sys` crate provides all of the base JavaScript
    objects that are specified in the ECMA standard specification, that is, functions,
    objects, numbers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Since WebAssembly only supports numeric types, the `wasm-bindgen` crate generates
    shims to allow you to use native Rust types in JavaScript. For example, a struct
    in Rust is represented as an object on the JavaScript side, while a `Promise`
    object can be accessed as a `Future` on the Rust side. It does all of this by
    using the `#[wasm-bindgen]` attribute macro over function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore `wasm-bindgen` and how it interacts with JavaScript, we''ll build
    something practical. We''ll build a live markdown editor app that will allow you
    to write markdown and view the rendered HTML page. Before we start, though, we
    need to install the wasm-bindgen-cli tool that will generate shims for us, allowing
    us to conveniently use the exposed Rust functions from our library. We can install
    it by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create a new project by running `cargo new livemd` with the following
    contents in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have named our library `livemd`. Our library is of the `cdylib` type and
    is exposing a C interface because WebAssembly accepts a widely targetable dynamic
    C library interface, which most languages can compile to. Next, we''ll also create
    a `run.sh` script at our directory root that will let us build and run our project
    and rerun it every time we change any of our code using `cargo-watch`. Here''s
    the content of the `run.sh` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the implementation of the the markdown conversion code in `lib.rs`,
    in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our `livemd` crate exposes a single function named `pars`, which takes in the
    markdown text from the `textarea` tag on the web page (yet to be created) and
    returns the compiled HTML string by invoking the `markdown_to_html` function from
    the `comrak` crate. As you may have noticed, the `parse` method is annotated with
    the `#[wasm_bindgen]` attribute. This macro generates code for all kinds of lower-level
    conversions, and is required to expose this function to JavaScript. Using this
    attribute, we don't have to care about what kind of strings our parse method will
    take. Strings from JavaScript are different than strings in Rust. The `#[wasm_bindgen]`
    attribute handles this difference and the low-level details of converting the
    string from the JavaScript side before accepting it as a `&amp;str` type for us.
    At the time of writing this book, there are some types that `wasm-bindgen` cannot
    convert, such as references and type definitions with lifetime annotation on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to generate the wasm file for this crate. But before we do that,
    let''s set up our app. In the same directory, we''ll create a directory named
    `app/` and initialize our project by running `yarn init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c8e0591-081b-467a-bc5f-dd78dfcb232e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`yarn init` creates our `package.json` file. Apart from the usual fields, we''ll
    specify `scripts` and `dev-dependencies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using webpack to spin up our development web server. Webpack is a
    module bundler. A module bundler takes multiple JavaScript source files and bundles
    them into a single file, possibly minifying it for consumption on the web. To
    configure webpack so that we can bundle our JavaScript and wasm-generated code,
    we''ll create a webpack config file in a file named `webpack.config.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the same `app/` directory, we''ll create three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.html`: This contains the UI of the app:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have declared a `<textarea>` HTML element with an ID of `editor`. This will
    be shown on the left, and is where you can write your markdown. Next, we have
    a `<div>` element with an ID of `preview`, which will show the live rendered HTML
    content.
  prefs: []
  type: TYPE_NORMAL
- en: '`style.css`: To make our app look nice, this file provides the basic styling
    for rendering the live editor and preview panes in the app:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`index.js`: This file provides the glue code between our UI and our `livemd`
    crate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code imports the `livemd` module, which returns a `Promise` instance.
    We then chain on the value that's produced by this promise by calling the `then`
    method, which takes an anonymous function, `(livemd) => {}`. This function receives
    the wasm module (we named it `livemd`). Within this method, we get the `editor`
    and `preview` HTML elements by their IDs. We then create a function called `markdownToHtml`,
    which takes the text from the `editor` element from its property `value` and passes
    it to the `parse` method from the livemd wasm module. This returns rendered HTML
    text as a string. We then set the `innerHTML` property of the `preview` element
    to this text. Next, to provide live feedback for any updates made by the user
    on any text changes in the `editor` element, we need to invoke this function.
    We can use the `onInput` event handler for this. To the editor element, we call
    the `addEventListener` method with the `"input"` event and pass this function
    as the handler. Finally, we invoke `markdownToHtml` to kick off the parsing and
    rendering of the text.
  prefs: []
  type: TYPE_NORMAL
- en: That's it—we have created our first web application that uses Rust under the
    hood and runs WebAssembly alongside JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: This isn''t an efficient implementation and there are lot of improvements
    that can be made. However, since we are learning about the tools here, it''s okay
    for demonstration purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to compile our crate into WebAsssembly code, that is, as a `wasm`
    file, and generate a bundled JavaScript file. We have a script set up already,
    called `run.sh`. Here''s the output on running our `run.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4213403-fe51-4b07-be87-6b012e27b065.png)'
  prefs: []
  type: TYPE_IMG
- en: The `run.sh` script first builds the `livemd` crate by running `cargo build
    --target wasm32-unknown-unknown`. Next, it invokes the `wasm-bindgen` tool, which
    optimizes our `wasm` file and outputs it in the `app/` directory. Then, we run
    `yarn install` in our app directory, followed by `yarn run serve`, which starts
    our development server using the `webpack-dev-server` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you face errors while running wasm-bindgen cli command, try updating the
    wasm-bindgen dependency in livemd/Cargo.toml by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to install the yarn package manager for hosting the web page on
    localhost. This can be done by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From webpack''s output, our development server is running at `http://localhost:8080`.
    Let''s head over to our web browser and go to this address. Here''s the output
    on my browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79393ad6-760c-4b95-b8ea-06a23fbeb810.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have our text in markdown format on the left-hand pane and
    it gets rendered on the right in real time as HTML. Under the hood, every bit
    of text we type on the left-hand side of this page gets converted into HTML text,
    which is generated by the `livemd` wasm module that we created.
  prefs: []
  type: TYPE_NORMAL
- en: We can also publish our `livemd` crate as an npm package. The wasm-pack project
    at [https://github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)
    provides all kinds of orchestration that's needed to build and ship npm modules
    written in Rust that have been compiled to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Other WebAssembly projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the `wasm-bindgen` crate and friends, there are other emerging frameworks
    and projects in the Rust community that are worth exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wasm-bindgen is not the only project that aims to create amazing development
    experiences. Some other projects in the Rust ecosystem are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stdweb**: This crate aims to provide a high-level, Rust-based API for accessing
    DOM APIs over the web.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yew**: This is a complete frontend web application building framework that
    allows you to write web applications in Rust that can access Web APIs and compile
    them into wasm so that they can be run on the web. It is inspired by the Elm and
    ReactJS projects. It also encapsulates actor-based message passing concurrency
    via web workers on the web. Yew uses the `stdweb` crate internally to access DOM
    APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nebutlet**: This is a micro-kernel that can execute WebAssembly programs
    without any kind of system call interface, which is usually the norm in most operating
    system implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wasmi**: This is a wasm virtual machine that''s implemented in Rust, but
    it isn''t related to the wasm VM in browser engines. The project was initiated
    by Parity, an Ethereum-based start-up, which is more suited to running WebAssembly
    applications on many platforms. The project is hosted at [https://github.com/paritytech/wasmi](https://github.com/paritytech/wasmi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other languages also have technologies that target WebAssembly, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Life**: Life is a WebAssembly VM that''s implemented in Golang for running
    high performance, decentralized applications securely. The project resides at
    [https://github.com/perlin-network/life](https://github.com/perlin-network/life).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AssemblyScript**: This is a TypeScript-to-WebAssembly compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wagon**: Wagon is a WebAssembly interpreter in Golang.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly will have a huge impact on how web developers build their applications,
    allowing them to gain a lot of performance gains with little effort. It will allow
    for diversity in terms of application developers, thus allowing them to write
    web applications in their native language without worrying about learning other
    frameworks. WebAssembly is not meant to replace Javascript, but to serve as a
    high-performance language for running complex web applications on the web. The
    WebAssembly standard is constantly evolving and has a lot of exciting possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about how Rust can compile down to wasm code and
    the available tooling that helps ship Rust code on the web. If you want to learn
    more about WebAssembly, head over to the excellent documentation at: [https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn a bit about GUI development and how to build
    desktop applications with Rust.
  prefs: []
  type: TYPE_NORMAL
