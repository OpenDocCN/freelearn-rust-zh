<html><head></head><body>
        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding FTP</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This chapter is all about asynchronous programming in Rust. In order to show you how it works, we'll write an FTP server. However, to make it as easy as possible for you to understand, we'll break the subject down into the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Presenting the FTP protocol</li>
<li class="calibre11">Implementing a synchronous FTP server</li>
<li class="calibre11">Presenting asynchronous programmation in Rust</li>
<li class="calibre11"><span> Asynchronously i</span>mplementing the FTP server</li>
</ul>
<p class="calibre3">These steps are all important in order to make you feel confident in Rust asynchronous <span>programming</span>.</p>
<p class="calibre3">Now, let's start by talking a bit about the FTP protocol!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">File transfer protocol</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The <strong class="calibre5">f</strong><strong class="calibre5">ile transfer protocol</strong> (<strong class="calibre5">FTP</strong>) was created in 1971. Its final RFC is 959. I<span>f you're </span>curious, you can read more about it at  <a href="https://tools.ietf.org/html/rfc959" class="calibre13">https://tools.ietf.org/html/rfc959</a>.</p>
<p class="calibre3">Being an old protocol, a few commands don't have clear specifications, so some alternative specifications (that are more or less official) have been written in order to fill those blanks. We'll go back to them when writing the server.</p>
<p class="calibre3">Another important point to note is that FTP uses TCP connections.</p>
<p class="calibre3">Now that we've quickly introduced you to FTP, let's see how it works.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to FTP</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">A client connects to a server and then sends commands to the server. Each command receives an answer from the server with either a success or failure.</p>
<p class="calibre3">For example, the client will send the <kbd class="calibre14">PWD</kbd> command to the server:</p>
<pre class="calibre22">=&gt; PWD\r\n
&lt;= 257 "/"\r\n</pre>
<p class="calibre3">Here, the server answered <kbd class="calibre14">257</kbd> (which literally means <em class="calibre21">pathname created</em>) and then gave the current working directory the client is in (which is <kbd class="calibre14">"/"</kbd>, in this case).</p>
<p class="calibre3">As you can see, every command ended with <kbd class="calibre14">""</kbd>. This is another standard in FTP—every command has to end with <kbd class="calibre14">""</kbd>. In case you don't know, <kbd class="calibre14">""</kbd> stands for carriage return and <kbd class="calibre14">""</kbd> stands for the backline.</p>
<p class="calibre3">Another thing to note—the answer from the server <em class="calibre21">always</em> contains a string before the <kbd class="calibre14">""</kbd>. Consider the following example:</p>
<pre class="calibre22">=&gt; NOOP\r\n
&lt;= 250 Doing nothing\r\n</pre>
<p class="calibre3">If the client's command doesn't require a precise output (except for the returned code), it's all up to the server. It's generally just a small sentence giving more information about what the server did (or what failed). On another server, the <kbd class="calibre14">NOOP</kbd> command could have given the following:</p>
<pre class="calibre22">=&gt; NOOP\r\n
&lt;= 250 42 is life\r\n</pre>
<p class="calibre3">Lastly, FTP works with two channels:</p>
<ul class="calibre10">
<li class="calibre11">The first channel is used to send small commands, such as updating a status</li>
<li class="calibre11">The second channel is used to send a large amount of data, such as a file transfer or even listing a directory</li>
</ul>
<p class="calibre3">A funny thing about this second channel is that it's up to the client to decide whether the server connects to the client or vice versa. But in almost every case, the client asks the server to connect to him for a second time, and the server picks a port and they're good to go.</p>
<p class="calibre3">We can now say that we're done with a quick introduction to FTP. If it still doesn't seem perfectly clear at this point, no need to worry: it'll become more obvious as we go through the implementation of the server.</p>
<p class="calibre3">So, let's start with a synchronous server implementation.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing simple chunks of commands</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's start slowly by first creating a very simple server that sends <kbd class="calibre14">"hello"</kbd> to a new client and then closes the connection:</p>
<pre class="calibre22">use std::net::TcpListener;
use std::io::Write;

fn main() {
    let listener = TcpListener::bind("0.0.0.0:1234").expect("Couldn't bind this <br class="calibre6"/>    address...");

    println!("Waiting for clients to connect...");
    for stream in listener.incoming() {
        Ok(stream) =&gt; {
            println!("New client!);
            if let Err(_) = stream.write(b"hello") {
                println!("Failed to send hello... :'(");
            }
        }
        _ =&gt; {
            println!("A client tried to connect...")
        }
    }
}</pre>
<p class="calibre3">Pretty easy, right? As usual, let's explain what the code does:</p>
<pre class="calibre22">let listener = TcpListener::bind("0.0.0.0:1234").expect("Couldn't bind this address...");</pre>
<p class="calibre3">For those who don't know much about the network, the preceding line of code is the most important for any server</p>
<p class="calibre3">It tries to <em class="calibre21">book</em> the port for your server only. If another software is using it, then the <span><kbd class="calibre14">bind</kbd></span> call will fail. The given string represents the address and port we want to <em class="calibre21">book</em>. The argument works as follows: <kbd class="calibre14">[IP]:[PORT]</kbd>. Here, we entered <kbd class="calibre14">0.0.0.0:1234</kbd>, which means that we want the port <span><kbd class="calibre14">1234</kbd></span> on the address <kbd class="calibre14">0.0.0.0</kbd>.</p>
<p class="calibre3">It might sound strange to allow a server to pick an IP address to use, but it's actually not the case. You can only choose between <kbd class="calibre14">localhost</kbd> (alias <kbd class="calibre14">127.0.0.1</kbd>) and <kbd class="calibre14">0.0.0.0</kbd>. The only difference between those two is that <kbd class="calibre14">0.0.0.0</kbd> allows other computers to connect to your own (if the port can be accessed from outside through the box provided by your internet access provider), whereas <kbd class="calibre14">127.0.0.1</kbd> can only be accessed from the computer it has been started on. But enough with network explanations—this isn't the point of this book, so let's move on!</p>
<p class="calibre3">The only other code that requires explanation is the following:</p>
<pre class="calibre22">for stream in listener.incoming() {</pre>
<p class="calibre3">The <span><kbd class="calibre14">incoming</kbd></span> method call allows us to iterate infinitely on newly received connections by returning an iterator. Then, the <span><kbd class="calibre14">for</kbd></span> loop just calls the <span><kbd class="calibre14">next</kbd></span> method of the iterator.</p>
<p class="calibre3">That's it for this small code sample. Now it's time to improve all this!</p>
<p class="calibre3">It'd be nice to handle every client separately and not close the connection as soon as we receive a new connection, wouldn't it? So, let's just update the previous code a bit:</p>
<pre class="calibre22">use std::net::{TcpListener, TcpStream};
use std::thread;

fn handle_client(mut stream: TcpStream) {
    println!("new client connected!");
    // put client code handling here
}

fn main() {
    let listener = TcpListener::bind("0.0.0.0:1234").expect("Couldn't bind this <br class="calibre6"/>    address...");

    println!("Waiting for clients to connect...");
    for stream in listener.incoming() {
        Ok(stream) =&gt; {
            thread::spawn(move || {
                handle_client(stream);
            });
        }
        _ =&gt; {
            println!("A client tried to connect...")
        }
    }
}</pre>
<p class="calibre3">Every time a new client connects to the server, we spawn a new thread and send the client's socket into it. This way, we can now handle every client on its own.</p>
<p class="calibre3">Now that we can get new clients connected, it's time to actually start implementing the FTP part of our server.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Starting with basics</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Of course, since we need to read and write on sockets, having to do that again and again in every function wouldn't be very efficient. Therefore, we'll start by implementing functions to do that. For now, we won't handle errors <em class="calibre21">nicely</em> (yes, <span><kbd class="calibre14">unwrap</kbd></span> is evil).</p>
<p class="calibre3">Let's start with the <kbd class="calibre14">write</kbd> function:</p>
<pre class="calibre22">use use std::net::TcpStream;
use std::io::Write;

fn send_cmd(stream: &amp;mut TcpStream, code: ResultCode, message: &amp;str) {
    let msg = if message.is_empty() { CommandNotImplemented = 502,
        format!("{}\r\n", code as u32)
    } else {
        format!("{} {}\r\n", code as u32, message)
    };
    println!("&lt;==== {}", msg);
    write!(stream, "{}", msg).unwrap()
}</pre>
<p class="calibre3">OK, there's nothing fancy nor difficult to understand here. However, take a look at this:</p>
<ul class="calibre10">
<li class="calibre11">Every message ends with <kbd class="calibre14">""</kbd> in FTP</li>
<li class="calibre11">Every message has to be followed by a whitespace if you want to add parameters or information.</li>
</ul>
<p class="calibre3">This also works in the exact same way when a client sends us a command.</p>
<p class="calibre3">What? Did I forget to provide you the <span><kbd class="calibre14">ResultCode</kbd></span> type? Indeed, you're absolutely right. Here it is:</p>
<pre class="calibre22">#[derive(Debug, Clone, Copy)]
#[repr(u32)]
#[allow(dead_code)]
enum ResultCode {
    RestartMarkerReply = 110,
    ServiceReadInXXXMinutes = 120,
    DataConnectionAlreadyOpen = 125,
    FileStatusOk = 150,
    Ok = 200,
    CommandNotImplementedSuperfluousAtThisSite = 202,
    SystemStatus = 211,
    DirectoryStatus = 212,
    FileStatus = 213,
    HelpMessage = 214,
    SystemType = 215,
    ServiceReadyForNewUser = 220,
    ServiceClosingControlConnection = 221,
    DataConnectionOpen = 225,
    ClosingDataConnection = 226,
    EnteringPassiveMode = 227,
    UserLoggedIn = 230,
    RequestedFileActionOkay = 250,
    PATHNAMECreated = 257,
    UserNameOkayNeedPassword = 331,
    NeedAccountForLogin = 332,
    RequestedFileActionPendingFurtherInformation = 350,
    ServiceNotAvailable = 421,
    CantOpenDataConnection = 425,
    ConnectionClosed = 426,
    FileBusy = 450,
    LocalErrorInProcessing = 451,
    InsufficientStorageSpace = 452,
    UnknownCommand = 500,
    InvalidParameterOrArgument = 501,
    CommandNotImplemented = 502,
    BadSequenceOfCommands = 503,
    CommandNotImplementedForThatParameter = 504,
    NotLoggedIn = 530,
    NeedAccountForStoringFiles = 532,
    FileNotFound = 550,
    PageTypeUnknown = 551,
    ExceededStorageAllocation = 552,
    FileNameNotAllowed = 553,
}</pre>
<p class="calibre3">Yep, not very beautiful... This is the exact representation of all FTP code types (errors, information, warnings, and so on). We can't do much better here; we have to rewrite all code so that we can understand it when we receive it and are able to give the correct code corresponding to the clients' commands.</p>
<p class="calibre3">Now, I suppose, you can guess what's coming next. The <kbd class="calibre14"><span>enum </span><span>Command</span></kbd> of course! This time, we'll fulfill it while we move forward on to the implementation of the commands:</p>
<pre class="calibre22">use std::io;
use std::str;

#[derive(Clone, Copy, Debug)]
enum Command {
    Auth,
    Unknown(String),
}

impl AsRef&lt;str&gt; for Command {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match *self {
            Command::Auth =&gt; "AUTH",
            Command::Unknown(_) =&gt; "UNKN",
        }
    }
}

impl Command {
    pub fn new(input: Vec&lt;u8&gt;) -&gt; io::Result&lt;Self&gt; {
        let mut iter = input.split(|&amp;byte| byte == b' ');
        let mut command = iter.next().expect("command in <br class="calibre6"/>         input").to_vec();
        to_uppercase(&amp;mut command);
        let data = iter.next();
        let command =
            match command.as_slice() {
             b"AUTH" =&gt; Command::Auth,
             s =&gt; Command::Unknown(str::from_utf8(s).unwrap_or("").to_owned()),
            };
        Ok(command)
    }
}</pre>
<p class="calibre3">OK, let's get through this code:</p>
<pre class="calibre22">enum Command {
    Auth,
    Unknown(String),
}</pre>
<p class="calibre3">Every time we add a new command handling, we'll have to add a new variant to this <kbd class="calibre14">enum</kbd>. In case the command doesn't exist (or we haven't implemented it yet), <span><kbd class="calibre14">Unknown</kbd></span> will be returned with the command name. If the command is taking arguments, it'll be added just like we saw for <span><kbd class="calibre14">Unknown</kbd></span>. Let's take <span><kbd class="calibre14">Cwd</kbd></span> as an example:</p>
<pre class="calibre22">enum Command {
    Auth,
    Cwd(PathBuf),
    Unknown(String),
}</pre>
<p class="calibre3">As you can see, <span><kbd class="calibre14">Cwd</kbd></span> contains a <span><kbd class="calibre14">PathBuf</kbd></span>. <span><kbd class="calibre14">Cwd</kbd></span> stands for <strong class="calibre5">change working directory</strong> and takes the path of the directory that the client wants to go to.</p>
<p class="calibre3">Of course, you'd need to update <span><kbd class="calibre14">as_ref</kbd></span> by adding the following line to the <span><kbd class="calibre14">match</kbd></span> block:</p>
<pre class="calibre22">Command::Cwd(_) =&gt; "CWD",</pre>
<p class="calibre3">And you'd need to update the <span><kbd class="calibre14">new</kbd></span> method implementation by adding the following line into the <span><kbd class="calibre14">match</kbd></span> block:</p>
<pre class="calibre22">b"CWD" =&gt; Command::Cwd(data.map(|bytes| Path::new(str::from_utf8(bytes).unwrap()).to_path_buf()).unwrap()),</pre>
<p class="calibre3">Now let's explain the <span><kbd class="calibre14">AsRef</kbd></span> trait implementation. It's very convenient when you want to write a generic function. Take a look at the following example:</p>
<pre class="calibre22">fn foo&lt;S: AsRef&lt;str&gt;&gt;(f: S) {
    println!("{}", f.as_ref());
}</pre>
<p class="calibre3">Thanks to this trait, as long as the type implements it, we can call <span><kbd class="calibre14">as_ref</kbd></span> on it. It's very useful in our case when sending messages to the client since we can just take a type implementing <span><kbd class="calibre14">AsRef</kbd></span>.</p>
<p class="calibre3">Now let's talk about the <span><kbd class="calibre14">new</kbd></span> method of the <span><kbd class="calibre14">Command</kbd></span> type:</p>
<pre class="calibre22">pub fn new(input: Vec&lt;u8&gt;) -&gt; io::Result&lt;Self&gt; {
    let mut iter = input.split(|&amp;byte| byte == b' ');
    let mut command = iter.next().expect("command in input").to_vec();
    to_uppercase(&amp;mut command);
    let data = iter.next();
    let command =
        match command.as_slice() {
         b"AUTH" =&gt; Command::Auth,
         s =&gt; Command::Unknown(str::from_utf8(s).unwrap_or("").to_owned()),
        };
    Ok(command)
}</pre>
<p class="calibre3">The point here is to convert the message received from the client. We need to do two things:</p>
<ul class="calibre10">
<li class="calibre11">Get the command</li>
<li class="calibre11">Get the command's arguments (if any)</li>
</ul>
<p class="calibre3">First, we create an iterator to split our vector, so we can separate the command from the arguments:</p>
<pre class="calibre22">let mut iter = input.split(|&amp;byte| byte == b' ');</pre>
<p class="calibre3">Then, we get the command:</p>
<pre class="calibre22">let mut command = iter.next().expect("command in input").to_vec();</pre>
<p class="calibre3">At this point, <span><kbd class="calibre14">command</kbd></span> is a <span><kbd class="calibre14">Vec&lt;u8&gt;</kbd></span>. To then make the matching easier (because nothing in the RFC of the FTP talks about the fact that commands should be in uppercase or that <kbd class="calibre14">auth</kbd> is the same as <kbd class="calibre14">AUTH</kbd> or even <kbd class="calibre14">AuTh</kbd>), we call the <span><kbd class="calibre14">uppercase</kbd></span> function, which looks like this:</p>
<pre class="calibre22">fn to_uppercase(data: &amp;mut [u8]) {
    for byte in data {
        if *byte &gt;= 'a' as u8 &amp;&amp; *byte &lt;= 'z' as u8 {
            *byte -= 32;
        }
    }
}</pre>
<p class="calibre3">Next, we get the arguments by calling <span><kbd class="calibre14">next</kbd></span> on the iterator <span><kbd class="calibre14">iter</kbd></span>:</p>
<pre class="calibre22">let data = iter.next();</pre>
<p class="calibre3">If there are no arguments, no problem! We'll just get <span><kbd class="calibre14">None</kbd></span>.</p>
<p class="calibre3">Finally, we match the commands:</p>
<pre class="calibre22">match command.as_slice() {
    b"AUTH" =&gt; Command::Auth,
    s =&gt; Command::Unknown(str::from_utf8(s).unwrap_or("").to_owned()),
}</pre>
<p class="calibre3">To do so, we convert our <span><kbd class="calibre14">Vec&lt;u8&gt;&gt;</kbd></span> into a <span><kbd class="calibre14">&amp;[u8]</kbd></span> (a slice of <span><kbd class="calibre14">u8</kbd></span>). To also convert a <span><kbd class="calibre14">&amp;str</kbd></span> (such as <kbd class="calibre14">AUTH</kbd>) into a <span><kbd class="calibre14">&amp;[u8]</kbd></span>, we use the <span><kbd class="calibre14">b</kbd></span> operator (which is more like saying to the compiler, <em class="calibre21">Hey! Don't worry, just say it's a slice and not a</em> <span><kbd class="calibre14">&amp;str</kbd></span><em class="calibre21">!</em>) to allow the matching.</p>
<p class="calibre3">And we're good! We can now write the function to actually read the data from the client:</p>
<pre class="calibre22">fn read_all_message(stream: &amp;mut TcpStream) -&gt; Vec&lt;u8&gt; {
    let buf = &amp;mut [0; 1];
    let mut out = Vec::with_capacity(100);

    loop {
        match stream.read(buf) {
            Ok(received) if received &gt; 0 =&gt; {
                if out.is_empty() &amp;&amp; buf[0] == b' ' {
                    continue
                }
                out.push(buf[0]);
            }
            _ =&gt; return Vec::new(),
        }
        let len = out.len();
        if len &gt; 1 &amp;&amp; out[len - 2] == b'\r' &amp;&amp; out[len - 1] == <br class="calibre6"/>         b'\n' {
            out.pop();
            out.pop();
            return out;
        }
    }
}</pre>
<p class="calibre3">Here, we read one byte at a time (and it's not a very efficient way to do so; we'll go back on this function later) and return when we get <kbd class="calibre14">""</kbd>. We have just added a little <em class="calibre21">security</em> by removing any whitespaces that would come before the command (so as long as we don't have any data in our vector, we won't add any whitespace).</p>
<p class="calibre3">If there is any error, we return an empty vector and stop the reading of the client input.</p>
<p class="calibre3">Like I said earlier, reading byte by byte isn't efficient, but is simpler to demonstrate how it works. So, for now, let's stick to this. This will be done completely differently once the asynchronous programming kicks in.</p>
<p class="calibre3">So, now that we can read and write FTP inputs it's time to actually start the implementation of the commands!</p>
<p class="calibre3">Let's start by creating a new structure:</p>
<pre class="calibre22">#[allow(dead_code)]
struct Client {
    cwd: PathBuf,
    stream: TcpStream,
    name: Option&lt;String&gt;,
}</pre>
<p class="calibre3">Here are some quick explanations for the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><span><kbd class="calibre14">cwd</kbd></span> stands for the current working directory</li>
<li class="calibre11"><span><kbd class="calibre14">stream</kbd></span> is the client's socket</li>
<li class="calibre11"><span><kbd class="calibre14">name</kbd></span> is the username you got from user authentication (which doesn't really matter, as we won't handle authentication in the first steps)</li>
</ul>
<p class="calibre3">Now it's time to update the <span><kbd class="calibre14">handle_client</kbd></span> function:</p>
<pre class="calibre22">fn handle_client(mut stream: TcpStream) {
    println!("new client connected!");
    send_cmd(&amp;mut stream, ResultCode::ServiceReadyForNewUser, "Welcome to this FTP <br class="calibre6"/>    server!");
    let client = Client::new(stream);
    loop {
        let data = read_all_message(&amp;mut client.stream);
        if data.is_empty() {
            println!("client disconnected...");
            break;
        }
        client.handle_cmd(command::new(data));
    }
}</pre>
<p class="calibre3">When a new client connects to the server, we send<span> them a message to inform them that the server is ready</span>. Then we create a new <span><kbd class="calibre14">Client</kbd></span> instance, listen on the client socket, and handle its commands. Simple, right?</p>
<p class="calibre3">Two things are missing from this code:</p>
<ul class="calibre10">
<li class="calibre11">The <span><kbd class="calibre14">Client::new</kbd></span> method</li>
<li class="calibre11">The <span><kbd class="calibre14">Client::handle_cmd</kbd></span> method</li>
</ul>
<p class="calibre3">Let's start with the first one:</p>
<pre class="calibre22">impl Client {
    fn new(stream: TcpStream) -&gt; Client {
        Client {
            cwd: PathBuf::from("/"),
            stream: stream,
            name: None,
        }
    }
}</pre>
<p class="calibre3">Nothing fancy here; the current path is <kbd class="calibre14">"/"</kbd> (it corresponds to the root of the server, not to the root of the filesystem!). We have set the client's stream, and the name hasn't been defined yet.</p>
<p class="calibre3">Now let's see the <span><kbd class="calibre14">Client::handle_cmd</kbd></span> method (needless to say, it'll be the core of this FTP server):</p>
<pre class="calibre22">fn handle_cmd(&amp;mut self, cmd: Command) {
    println!("====&gt; {:?}", cmd);
    match cmd {
        Command::Auth =&gt; send_cmd(&amp;mut self.stream, <br class="calibre6"/>        ResultCode::CommandNotImplemented,
                                  "Not implemented"),
        Command::Unknown(s) =&gt; send_cmd(&amp;mut self.stream, <br class="calibre6"/>         ResultCode::UnknownCommand,
                                        "Not implemented"),
    }
}</pre>
<p class="calibre3">And that's it! Ok, so that's not really <em class="calibre21">it</em>. We still have a lot to add. But my point is, we now only have to add other commands here to make it all work.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Commands implementation</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In the previous code, we only handled one command; any other command will receive an <kbd class="calibre14">unknown command</kbd> answer from the server. Also, our <span><kbd class="calibre14">Auth</kbd></span> implementation says it's not implemented. So, to sum this up, we handle one command that answers that it's not implemented. Crazy, right? For the <span><kbd class="calibre14">Auth</kbd></span> command, we'll look at this later.</p>
<p class="calibre3">Now let's implement some commands <em class="calibre21">for real</em>. Let's start with a simple one: <span><kbd class="calibre14">Syst</kbd></span>. This is supposed to return which system this FTP server is running on. For some reason, we won't answer that, and we'll just send back an answer-nothing usable.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the SYST command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">First, let's add a new entry into the <span><kbd class="calibre14">Command</kbd></span> enum (I won't do this every time, but the steps will remain the same):</p>
<pre class="calibre22">enum Command {
    Auth,
    Syst,
    Unknown(String),
}</pre>
<p class="calibre3">Then, let's update the <span><kbd class="calibre14">as_ref</kbd></span> implementation:</p>
<pre class="calibre22">impl AsRef&lt;str&gt; for Command {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match *self {
            Command::Auth =&gt; "AUTH",
            Command::Syst =&gt; "SYST",
            Command::Unknown(_) =&gt; "UNKN",
        }
    }
}</pre>
<p class="calibre3">Finally, let's update the <span><kbd class="calibre14">Command::new</kbd></span> method:</p>
<pre class="calibre22">impl Command {
    pub fn new(input: Vec&lt;u8&gt;) -&gt; io::Result&lt;Self&gt; {
        let mut iter = input.split(|&amp;byte| byte == b' ');
        let mut command = iter.next().expect("command in <br class="calibre6"/>         input").to_vec();
        to_uppercase(&amp;mut command);
        let data = iter.next();
        let command =
            match command.as_slice() {
                b"AUTH" =&gt; Command::Auth,
                b"SYST" =&gt; Command::Syst,
                s =&gt; <br class="calibre6"/>                Command::Unknown(str::from_utf8(s).unwrap_or("").to_owned()),
            };
        Ok(command)
    }
}</pre>
<p class="calibre3">That's it! Like I said earlier, just remember those three steps every time you add a new command and everything should be fine.</p>
<p class="calibre3">Now let's implement the command:</p>
<pre class="calibre22">fn handle_cmd(&amp;mut self, cmd: Command) {
    println!("====&gt; {:?}", cmd);
    match cmd {
        Command::Auth =&gt; send_cmd(&amp;mut self.stream, <br class="calibre6"/>        ResultCode::CommandNotImplemented,
                                  "Not implemented"),
        Command::Syst =&gt; send_cmd(&amp;mut self.stream, ResultCode::Ok, "I won't tell"),
        Command::Unknown(s) =&gt; send_cmd(&amp;mut self.stream, <br class="calibre6"/>        ResultCode::UnknownCommand,
                                        "Not implemented"),
    }
}</pre>
<p class="calibre3">And that's it! We implemented a new command (which doesn't do much, but that isn't the point)!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the USER command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Since we have a <span><kbd class="calibre14">name</kbd></span> in our <span><kbd class="calibre14">Client</kbd></span> structure, it'd be nice to have some use for it, right? So, as the title says, let's implement the <span><kbd class="calibre14">USER</kbd></span> command. Since this command takes an argument, I'll go through the command implementation steps once again, so you'll have an example of a command taking a parameter.</p>
<p class="calibre3">First, let's update the <kbd class="calibre14"><span>enum </span><span>Command</span></kbd>:</p>
<pre class="calibre22">enum Command {
    Auth,
    Syst,
    User(String),
    Unknown(String),
}</pre>
<p class="calibre3">Then, we update the <span><kbd class="calibre14">as_ref</kbd></span> implementation:</p>
<pre class="calibre22">impl AsRef&lt;str&gt; for Command {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match *self {
            Command::Auth =&gt; "AUTH",
            Command::Syst =&gt; "SYST",
            Command::User =&gt; "USER",
            Command::Unknown(_) =&gt; "UNKN",
        }
    }
}</pre>
<p class="calibre3">Finally, we update the <span><kbd class="calibre14">Command::new</kbd></span> method:</p>
<pre class="calibre22">impl Command {
    pub fn new(input: Vec&lt;u8&gt;) -&gt; io::Result&lt;Self&gt; {
        let mut iter = input.split(|&amp;byte| byte == b' ');
        let mut command = iter.next().expect("command in input").to_vec();
        to_uppercase(&amp;mut command);
        let data = iter.next();
        let command =
            match command.as_slice() {
                b"AUTH" =&gt; Command::Auth,
                b"SYST" =&gt; Command::Syst,
                b"USER" =&gt; Command::User(data.map(|bytes| <br class="calibre6"/>                String::from_utf8(bytes.to_vec()).expect("cannot<br class="calibre6"/>                 convert bytes to String")).unwrap_or_default()),
                s =&gt; Command::Unknown(str::from_utf8(s).unwrap_or("").to_owned()),
            };
        Ok(command)
    }
}</pre>
<p class="calibre3">Phew, all done! Now we just need to implement the function (which is quite simple, I promise):</p>
<pre class="calibre22">fn handle_cmd(&amp;mut self, cmd: Command) {
    println!("====&gt; {:?}", cmd);
    match cmd {
        Command::Auth =&gt; send_cmd(&amp;mut self.stream, <br class="calibre6"/>         ResultCode::CommandNotImplemented,
                                  "Not implemented"),
        Command::Syst =&gt; send_cmd(&amp;mut self.stream, ResultCode::Ok, <br class="calibre6"/>        "I won't tell"),
        Command::User(username) =&gt; {
            if username.is_empty() {
                send_cmd(&amp;mut self.stream, ResultCode::InvalidParameterOrArgument,
                         "Invalid username")
            } else {
                self.name = username.to_owned();
                send_cmd(&amp;mut self.stream, ResultCode::UserLoggedIn,
                         &amp;format!("Welcome {}!", username)),
            }
        }
        Command::Unknown(s) =&gt; send_cmd(&amp;mut self.stream,  <br class="calibre6"/>        ResultCode::UnknownCommand,
                                        "Not implemented"),
    }
}</pre>
<p class="calibre3">Here's a little explanation just in case you need it; if we receive an empty username (or no username at all), we consider this as an invalid parameter and return <span><kbd class="calibre14">InvalidParameterOrArgument</kbd></span>. Otherwise, everything is fine and we return <span><kbd class="calibre14">UserLoggedIn</kbd></span>.</p>
<p class="calibre3">If you're wondering why we didn't return <span><kbd class="calibre14">ResultCode::Ok</kbd></span>, it's because the RFC states as such. Once again, every command, what it does, and what it should return is described there. If you feel lost, don't hesitate to read it again!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the NOOP command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This topic is quite a simple one. <span><kbd class="calibre14">NOOP</kbd></span> stands for no operation. It takes no argument and does nothing. Just because I'm a nice person, here's the code for the <span><kbd class="calibre14">NOOP</kbd></span> command in the <span><kbd class="calibre14">Client::handle_cmd</kbd></span> method:</p>
<pre class="calibre22">Command::NoOp =&gt; send_cmd(&amp;mut self.stream, ResultCode::Ok, "Doing nothing..."),</pre>
<p class="calibre3">Yes, I know, you're amazed by such wonderful code. But don't worry, you'll able to write something as good as this when you grow older!</p>
<p class="calibre3">It's now time to implement the next command!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the PWD command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This command is very simple as well. <span><kbd class="calibre14">PWD</kbd></span> stands for print working directory. Once again, it's not the one from your system but the one from your server (so again, <kbd class="calibre14">"/"</kbd> corresponds to the folder where you started the server).</p>
<p class="calibre3">The command doesn't take any argument, so there's no need to show you everything again. Let's just focus on the command handling:</p>
<pre class="calibre22">Command::Pwd =&gt; {
    let msg = format!("{}", self.cwd.to_str().unwrap_or(""));
    if !msg.is_empty() {
        let message = format!("\"/{}\" ", msg);
        send_cmd(&amp;mut self.stream, ResultCode::PATHNAMECreated,<br class="calibre6"/>         &amp;format!("\"/{}\" ", <br class="calibre6"/>         msg))
    } else {
        send_cmd(&amp;mut self.stream, ResultCode::FileNotFound, "No <br class="calibre6"/>         such file or directory")
    }
}</pre>
<p class="calibre3">Nothing complicated; we try to display the path, and if we fail, we return an error. The only strange thing is that if everything goes fine, we have to return <kbd class="calibre14">PATHNAMECreated</kbd>. This RFC is really strange...</p>
<p class="calibre3">Sorry, this was the last <em class="calibre21">simple</em> command. Now we'll go deeper into the FTP and its strange RFC. The following command is just a nice introduction to what's coming next. (I hope I didn't scare you!)</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the TYPE command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">For now, we'll have an implementation of the <span><kbd class="calibre14">TYPE</kbd></span> command that does nothing. We'll come back to it in the following chapters. However, a bit of explanation will come in handy, I assume.</p>
<p class="calibre3"><span><kbd class="calibre14">TYPE</kbd></span> stands for the representation type. When you're transferring data over the data connection (which is different from the command connection, which is the only one we've been using until now), you can transfer data differently.</p>
<p class="calibre3">By default, the transfer type is ASCII (the main difference is that all <kbd class="calibre14">""</kbd> have to be transformed into <kbd class="calibre14">""</kbd>). We'll use the image one (where you send data as you have it) to make our lives easier.</p>
<p class="calibre3">Once again, we'll go back to this implementation in later chapters.</p>
<p class="calibre3">For now, let's just add a <span><kbd class="calibre14">Type</kbd></span> command that doesn't take any argument:</p>
<pre class="calibre22">Command::Type =&gt; send_cmd(&amp;mut self.stream, ResultCode::Ok, "Transfer type changed successfully"),</pre>
<p class="calibre3">OK, we're lying a bit, but we'll have to deal with it for the moment.</p>
<p class="calibre3">We're almost at the end of the basics, but there's one last command to implement before you can try accessing the server using an FTP client.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the LIST command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The <span><kbd class="calibre14">LIST</kbd></span> command returns a list of the current files and folders of the current folder or at the given parameter path. This is already very difficult itself because you need to check that the <em class="calibre21">final</em> path is accessible to the user (for example, if you receive <kbd class="calibre14">foo/../../</kbd> when you're at <kbd class="calibre14">"/"</kbd>, there's an issue). But that's not all! When you're transferring the files and folders list, there is no official way to format it! Fun, right? Luckily, most of the FTP clients follow some kind of non-official RFC for this case, and we'll use it.</p>
<p class="calibre3">In addition to all of this, this command is the first one that we'll implement that uses the data connection. This requires you to add another command: <span><kbd class="calibre14">PASV</kbd></span>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the PASV command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To be able to make this command work, we need to add a few new fields in our <span><kbd class="calibre14">Client</kbd></span> struct:</p>
<pre class="calibre22">struct Client {
    cwd: PathBuf,
    stream: TcpStream,
    name: Option&lt;String&gt;,
    data_writer: Option&lt;TcpStream&gt;,
}</pre>
<p class="calibre3">We now need to update the <span><kbd class="calibre14">Client::new</kbd></span> method as well:</p>
<pre class="calibre22">fn new(stream: TcpStream) -&gt; Client {
    Client {
        cwd: PathBuf::from("/"),
        stream: stream,
        name: None,
        data_writer: None,
    }
}</pre>
<p class="calibre3">The <span><kbd class="calibre14">PASV</kbd></span> command doesn't take arguments, so I'll let you add it to the structures and everything. Let's focus on the interesting part:</p>
<pre class="calibre22">// Adding some new imports:
use std::net::{IpAddr, Ipv4Addr, SocketAddr};

Command::Pasv =&gt; {
    if self.data_writer.is_some() {
        send_cmd(&amp;mut self.stream, ResultCode::DataConnectionAlreadyOpen, "Already <br class="calibre6"/>        listening...")
    } else {
        let port = 43210;
        send_cmd(&amp;mut self.stream, ResultCode::EnteringPassiveMode,
           &amp;format!("127,0,0,1,{},{}", port &gt;&gt; 8, port &amp; 0xFF));
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0,<br class="calibre6"/>         0, 1)), port);
        let listener = TcpListener::bind(&amp;addr).unwrap();
        match listener.incoming().next() {
            Some(Ok(client)) =&gt; {
                self.data_writer = Some(client);
            }
            _ =&gt; {
                send_cmd(&amp;mut self.stream, ResultCode::ServiceNotAvailable, "issues  <br class="calibre6"/>                happen...");
            }
        }
    }
}</pre>
<p class="calibre3">Phew... Let's explain all this:</p>
<pre class="calibre22">if self.data_writer.is_some() {
    send_cmd(&amp;mut self.stream, ResultCode::DataConnectionAlreadyOpen, "Already listening...")
}</pre>
<p class="calibre3">If we already have a data connection with this client, there's no need to open a new one, so we don't do anything else:</p>
<pre class="calibre22">let port: u16 = 43210;
send_cmd(&amp;mut self.stream, ResultCode::EnteringPassiveMode,
         &amp;format!("127,0,0,1,{},{}", port &gt;&gt; 8, port &amp; 0xFF));</pre>
<p class="calibre3">This part is a bit more tricky. First, we pick a port (the best way would be to check if the port is available first; we'll do this in later chapters). Then, we have to tell the client <em class="calibre21">where</em> it should connect to.</p>
<p class="calibre3">This is where things get a bit more complicated. We have to transfer the address as follows:</p>
<pre class="calibre22">ip1,ip2,ip3,ip4,port1,port2</pre>
<p class="calibre3">Every <span><kbd class="calibre14">ip</kbd></span> part has to be 8-bits long (so 1-byte long), whereas, each <span><kbd class="calibre14">port</kbd></span> part has to be 16-bits long (so, 2 bytes). The first part is easy; we just print localhost. However, the second part requires you to perform some binary operation.</p>
<p class="calibre3">To get the first byte only is simple; we just have to move 8 bits to the right. To sum this up, take a look at this:</p>
<pre class="calibre22">1010 1010 1111 1111</pre>
<p class="calibre3">This is our <span><kbd class="calibre14">u16</kbd></span>. We now shift 8 bits to the right:</p>
<pre class="calibre22">0000 0000 1010 1010</pre>
<p class="calibre3">Tadaa!</p>
<p class="calibre3">For the second part, we could move 8 bits to the left and then 8 bits to the right, or we could just use the <span><kbd class="calibre14">and</kbd></span> binary operator. Here's a little scheme to explain this:</p>
<pre class="calibre22">1 &amp; 1 == 1
1 &amp; 0 == 0</pre>
<p class="calibre3">Now let's take a nice binary to the hexadecimal converter and check the result:</p>
<pre class="calibre22">0000 0000 1111 1111 == 0xFF</pre>
<p class="calibre3">Now if we perform this operation, we get the following:</p>
<pre class="calibre23">1111 1111 1010 1010 &amp; 0xFF
=&gt;
0000 0000 1010 1010</pre>
<p class="calibre3">Now we have the last 8 bits only. Great! The last part of the command handling is very easy:</p>
<pre class="calibre22">let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);
let listener = TcpListener::bind(&amp;addr).unwrap();
match listener.incoming().next() {
    Some(Ok(client)) =&gt; {
        self.data_writer = Some(client);
    }
    _ =&gt; {
        send_cmd(&amp;mut self.stream, ResultCode::ServiceNotAvailable, "issues <br class="calibre6"/>        happen...");
    }
}</pre>
<p class="calibre3">We bind the address and port, wait for a client to connect, and then assign it to our data writer. There's nothing problematic in this.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Back to the LIST command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Now that we can handle a data connection, let's implement the <span><kbd class="calibre14">LIST</kbd></span>! For now, let's implement it without parameters (once again, we'll see in later chapters how to handle the <span><kbd class="calibre14">LIST</kbd></span> parameter). As usual, I'll let you add everything where it's needed and we'll just focus on the command handling:</p>
<pre class="calibre22">Command::List =&gt; {
    if let Some(ref mut data_writer) = self.data_writer {
        let mut tmp = PathBuf::from(".");
        send_cmd(&amp;mut self.stream, ResultCode::DataConnectionAlreadyOpen,
                 "Starting to list directory...");
        let mut out = String::new();
        for entry in read_dir(tmp).unwrap() {
            for entry in dir {
                if let Ok(entry) = entry {
                    add_file_info(entry.path(), &amp;mut out);
                }
            }
            send_data(data_writer, &amp;out)
        }
    } else {
        send_cmd(&amp;mut self.stream, ResultCode::ConnectionClosed, <br class="calibre6"/>         "No opened data connection");
    }
    if self.data_writer.is_some() {
        self.data_writer = None;
        send_cmd(&amp;mut self.stream, ResultCode::ClosingDataConnection, "Transfer <br class="calibre6"/>        done");
    }
}</pre>
<p class="calibre3">There's nothing complicated here either too. Once the transfer is over, we close the client socket and move on. What remains to be added are the <span><kbd class="calibre14">send_data</kbd></span> and the <span><kbd class="calibre14">add_file_info</kbd></span> functions. Let's start with the first one:</p>
<pre class="calibre22">fn send_data(stream: &amp;mut TcpStream, s: &amp;str) {
    write!(stream, "{}", s).unwrap();
}</pre>
<p class="calibre3">Easy, there's no error handling, so it just stands on one line. Now let's see the <span><kbd class="calibre14">add_file_info</kbd></span> function:</p>
<pre class="calibre22">fn add_file_info(path: PathBuf, out: &amp;mut String) {
    let extra = if path.is_dir() { "/" } else { "" };
    let is_dir = if path.is_dir() { "d" } else { "-" };

    let meta = match ::std::fs::metadata(&amp;path) {
        Ok(meta) =&gt; meta,
        _ =&gt; return,
    };
    let (time, file_size) = get_file_info(&amp;meta);
    let path = match path.to_str() {
        Some(path) =&gt; match path.split("/").last() {
            Some(path) =&gt; path,
            _ =&gt; return,
        },
        _ =&gt; return,
    };
    let rights = if meta.permissions().readonly() {
        "r--r--r--"
    } else {
        "rw-rw-rw-"
    };
    let file_str = format!("{is_dir}{rights} {links} {owner} {group} {size} {month} <br class="calibre6"/>    {day} {hour}:{min} {path}{extra}\r\n",
                           is_dir=is_dir,
                           rights=rights,
                           links=1, // number of links
                           owner="anonymous", // owner name
                           group="anonymous", // group name
                           size=file_size,
                           month=MONTHS[time.tm_mon as usize],
                           day=time.tm_mday,
                           hour=time.tm_hour,
                           min=time.tm_min,
                           path=path,
                           extra=extra);
    out.push_str(&amp;file_str);
    println!("==&gt; {:?}", &amp;file_str);
}</pre>
<p class="calibre3">To make this code work, you'll also need the following:</p>
<pre class="calibre22">#[macro_use]
extern crate cfg_if;

cfg_if! {
    if #[cfg(windows)] {
        fn get_file_info(meta: &amp;Metadata) -&gt; (time::Tm, u64) {
            use std::os::windows::prelude::*;
            (time::at(time::Timespec::new(meta.last_write_time())), <br class="calibre6"/>             meta.file_size())
        }
    } else {
        fn get_file_info(meta: &amp;Metadata) -&gt; (time::Tm, u64) {
            use std::os::unix::prelude::*;
            (time::at(time::Timespec::new(meta.mtime(), 0)),<br class="calibre6"/>             meta.size())
        }
    }
}</pre>
<p class="calibre3">Don't forget to add <span><kbd class="calibre14">cfg_if</kbd></span> in your <span><kbd class="calibre14">Cargo.toml</kbd></span>:</p>
<pre class="calibre22">cfg-if = "0.1.2"</pre>
<p class="calibre3"><span><kbd class="calibre14">cfg-if</kbd></span> is really good at help you do conditional compilation in a more easily readable way. A point to note about the <span><kbd class="calibre14">get_file_info</kbd></span> function now—this is one of the rare things that can't be performed in the same way on all systems.</p>
<p class="calibre3">Here, Windows has its own version and Unix has another. However, the two functions take the same argument (the import), and one function call changes. Let's go back to the <span><kbd class="calibre14">add_file_info</kbd></span> function now:</p>
<p class="calibre3">I suppose you recognized the output of the <span><kbd class="calibre14">ls</kbd></span> command, right? Apparently, the non-official RFC is working as follows:</p>
<pre class="calibre22">dr--r--r-- 1 me me 1024 Jan 7 12:42 foo/
-rw-rw-rw- 1 me me 4 Mar 3 23:42 some_file</pre>
<p class="calibre3">First, <kbd class="calibre14">d</kbd> if it's a directory or <kbd class="calibre14">-</kbd> if it isn't. Then, the rights (just like on Unix platforms):</p>
<pre class="calibre22">[rwx][rwx][rwx]</pre>
<p class="calibre3">The first <span><kbd class="calibre14">rwx</kbd></span> is for the owner, the second is about the group, and the last one is about everyone. Here, <span><kbd class="calibre14">r</kbd></span> stands for read access, <span><kbd class="calibre14">w</kbd></span> stands for write access, and <span><kbd class="calibre14">x</kbd></span> stands for execution access.</p>
<p class="calibre3">The rest seems explicit enough on its own, so there's no need to explain it.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the CWD command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The <span><kbd class="calibre14">CWD</kbd></span> command allows the user to change its current folder location. However, it's far from easy to do.</p>
<p class="calibre3">Before going into the implementation of this command, we'll need to discuss a potential security issue: paths.</p>
<p class="calibre3">Imagine the user is at the <kbd class="calibre14">"/"</kbd> location (which will corresponds to, say, <kbd class="calibre14">/home/someone/somewhere</kbd>) and requests <kbd class="calibre14">foo/../../</kbd>. If we just accept the path and move the user to this location, it'll end up at <kbd class="calibre14">/home/someone</kbd>. This means that the users could access all of your computer without issue. You see the problem now?</p>
<p class="calibre3">Luckily for us, <span><kbd class="calibre14">Rust</kbd></span> has a nice method on <span><kbd class="calibre14">Path</kbd></span> that allows us to fix this huge security issue. I'm talking about <span><kbd class="calibre14">Path::canonicalize</kbd></span> (which is an alias of the <span><kbd class="calibre14">fs::canonicalize</kbd></span> function).</p>
<p class="calibre3">So, what does this function do? Let's take an example:</p>
<pre class="calibre22">let path = Path::new("/foo/test/../bar.rs");
assert_eq!(path.canonicalize().unwrap(), PathBuf::from("/foo/bar.rs"));</pre>
<p class="calibre3">As you can see, it interprets the path, normalizes everything (<kbd class="calibre14">..</kbd> removes the folder component), and resolves symbolic links as well. Quite magical, right?</p>
<p class="calibre3">Of course, all good things have a downside, and so does <span><kbd class="calibre14">canonicalize</kbd></span>.: it can only work on <em class="calibre21">real</em> paths. If a part of the path doesn't exist, the function will just fail. It's pretty easy to get through it when you know it, but it can sound surprising at first.</p>
<p class="calibre3">So, how do we fix this? Well, we need to play with a real path. So first, we need to append the user's server path to the real server path (the one it has on the computer). Once this is done, we just append the path requested by the user and call <span><kbd class="calibre14">canonicalize</kbd></span>.</p>
<p class="calibre3">That's not very complicated, but is a bit annoying to play with at first. Don't worry, though, the code is coming!</p>
<p class="calibre3">If you wonder why we're not just using the <span><kbd class="calibre14">chroot</kbd></span> function (which would solve all problems), remember that this FTP server is supposed to work on every platform.</p>
<p class="calibre3">So first, let's add a new command entry to the <kbd class="calibre14"><span>enum </span><span>Command</span></kbd> :</p>
<pre class="calibre22">Cwd(PathBuf),</pre>
<p class="calibre3">Good, now let's add it to the <span><kbd class="calibre14">Command::new</kbd></span> method matching:</p>
<pre class="calibre22">b"CWD" =&gt; Command::Cwd(data.map(|bytes| Path::new(str::from_utf8(bytes).unwrap()).to_path_buf()).unwrap()),</pre>
<p class="calibre3">Perfect! I'll let you add it into the <span><kbd class="calibre14">AsRef</kbd></span> implementation as well. Now it's time to go into the <em class="calibre21">real</em> implementation:</p>
<pre class="calibre22">Command::Cwd(directory) =&gt; self.cwd(directory),</pre>
<p class="calibre3">For once, to make our life easier, we'll create a new method in our <span><kbd class="calibre14">Client</kbd></span>, so all the code from the <span><kbd class="calibre14">CWD</kbd></span> command won't fill the <kbd class="calibre14">enum</kbd>:</p>
<pre class="calibre22">fn complete_path(&amp;self, path: PathBuf, server_root: &amp;PathBuf) -&gt; Result&lt;PathBuf, io::Error&gt; {
    let directory = server_root.join(if path.has_root() {
        path.iter().skip(1).collect()
    } else {
        path
    });
    let dir = directory.canonicalize();
    if let Ok(ref dir) = dir {
        if !dir.starts_with(&amp;server_root) {
            return Err(io::ErrorKind::PermissionDenied.into());
        }
    }
    dir
}

fn cwd(mut self, directory: PathBuf) {
    let server_root = env::current_dir().unwrap();
    let path = self.cwd.join(&amp;directory);
    if let Ok(dir) = self.complete_path(path, &amp;server_root) {
        if let Ok(prefix) = dir.strip_prefix(&amp;server_root)
                               .map(|p| p.to_path_buf()) {
            self.cwd = prefix.to_path_buf();
            send_cmd(&amp;mut self.stream, ResultCode::Ok,
                     &amp;format!("Directory changed to \"{}\"", directory.display()));
            return
        }
    }
    send_cmd(&amp;mut self.stream, ResultCode::FileNotFound, "No such file or directory");
}</pre>
<p class="calibre3">OK, that's a lot of code. Let's now go through the execution flow:</p>
<pre class="calibre22">let server_root = env::current_dir().unwrap();</pre>
<p class="calibre3">For now, you can't set which folder the server is running on; it'll be changed later on:</p>
<pre class="calibre22">let path = self.cwd.join(&amp;directory);</pre>
<p class="calibre3">First, we join the requested directory to the current directory of the user:</p>
<pre class="calibre22">if let Ok(dir) = self.complete_path(path, &amp;server_root) {</pre>
<p class="calibre3">Things start to get funny in here. The whole canonicalization process is in there.</p>
<p class="calibre3">Now let's append the user path to the (real) server path:</p>
<pre class="calibre22">let directory = server_root.join(if path.has_root() {
    path.iter().skip(1).collect()
} else {
    path
});</pre>
<p class="calibre3">So, if the path is an absolute one (starting with <kbd class="calibre14">"/"</kbd> on Unix or a prefix on Windows such as <kbd class="calibre14">c:</kbd>), we need to remove the first component of the path, otherwise, we just append it.</p>
<p class="calibre3">We now have a full and potentially existent path. Let's canonicalize it:</p>
<pre class="calibre22">let dir = directory.canonicalize();</pre>
<p class="calibre3">Now we have one more thing to check—if the path doesn't start with the server root, then it means that the user tried to cheat on us and tried to access non-accessible folders. Here is how we do it:</p>
<pre class="calibre22">if let Ok(ref dir) = dir {
    if !dir.starts_with(&amp;server_root) {
        return Err(io::ErrorKind::PermissionDenied.into());
    }
}</pre>
<p class="calibre3">In the case that <span><kbd class="calibre14">canonicalize</kbd></span> returned an error, there's no need to check if it did (since it's already an error). If it succeeded but doesn't start with <span><kbd class="calibre14">server_root</kbd></span>, then we return an error.</p>
<p class="calibre3">That's it for this function. Now, we'll return the result to the caller and can go back to the <span><kbd class="calibre14">cwd</kbd></span> method:</p>
<pre class="calibre22">if let Ok(dir) = self.complete_path(path, &amp;server_root) {
    if let Ok(prefix) = dir.strip_prefix(&amp;server_root)
                           .map(|p| p.to_path_buf()) {
        // ...
    }
}</pre>
<p class="calibre3">Once we get the full directory path and have confirmed it was okay, we need to remove the <span><kbd class="calibre14">server_root</kbd></span> prefix to get the path from our server root:</p>
<pre class="calibre22">self.cwd = prefix.to_path_buf();
send_cmd(&amp;mut self.stream, ResultCode::Ok,
         &amp;format!("Directory changed to \"{}\"", directory.display()));
return</pre>
<p class="calibre3">Finally, once this is done, we can just set the path to the user and send back a message that the command succeeded (and return to avoid sending back that we failed!).</p>
<p class="calibre3">If anything goes wrong, we send back the following:</p>
<pre class="calibre22">send_cmd(&amp;mut self.stream, ResultCode::FileNotFound, "No such file or directory");</pre>
<p class="calibre3">That's it for this command! You now know how to avoid a security issue by checking received paths provided by the clients.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the CDUP command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3"><span><kbd class="calibre14">CDUP</kbd></span> is used to go up to the parent directory. In comparison to the <span><kbd class="calibre14">CWD</kbd></span> command implementation, it'll be a piece of cake! The <span><kbd class="calibre14">CDUP</kbd></span> command doesn't take arguments, so I'll let you add it to <kbd class="calibre14">enums</kbd>. Now, let's focus on the command implementation:</p>
<pre class="calibre22">Command::CdUp =&gt; {
    if let Some(path) = self.cwd.parent().map(Path::to_path_buf) {
        self.cwd = path;
    }
    send_cmd(&amp;mut self.stream, ResultCode::Ok, "Done");
}</pre>
<p class="calibre3">And that's it. There's need to check if the parent folder exists, as it does. And if we're already at the root, then there's no need to do anything. Isn't it wonderful?</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Full implementation of the LIST command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Now that we know how to play with paths nicely, it'd be a shame not fully implement the <span><kbd class="calibre14">LIST</kbd></span> command, right?</p>
<p class="calibre3">To complete it, you'll need to update the <span><kbd class="calibre14">Command::List</kbd></span> variant in order to make it accept <span><kbd class="calibre14">PathBuf</kbd></span> as an argument.</p>
<p class="calibre3">So, we currently have the following code:</p>
<pre class="calibre22">Command::List =&gt; {
    if let Some(ref mut data_writer) = self.data_writer {
        let mut tmp = PathBuf::from(".");
        send_cmd(&amp;mut self.stream, ResultCode::DataConnectionAlreadyOpen,
                 "Starting to list directory...");
        let mut out = String::new();
        for entry in read_dir(tmp).unwrap() {
            for entry in dir {
                if let Ok(entry) = entry {
                    add_file_info(entry.path(), &amp;mut out);
                }
            }
            send_data(data_writer, &amp;out)
        }
    } else {
        send_cmd(&amp;mut self.stream, ResultCode::ConnectionClosed, "No opened data  <br class="calibre6"/>         connection");
    }
    if self.data_writer.is_some() {
        self.data_writer = None;
        send_cmd(&amp;mut self.stream, ResultCode::ClosingDataConnection, "Transfer <br class="calibre6"/>         done");
    }
}</pre>
<p class="calibre3">Let's update it as follows:</p>
<pre class="calibre22">Command::List(path) =&gt; {
    if let Some(ref mut data_writer) = self.data_writer {
        let server_root = env::current_dir().unwrap();
        let path = self.cwd.join(path.unwrap_or_default());
        let directory = PathBuf::from(&amp;path);
        if let Ok(path) = self.complete_path(directory, <br class="calibre6"/>         &amp;server_root) {
            send_cmd(&amp;mut self.stream, <br class="calibre6"/>             ResultCode::DataConnectionAlreadyOpen,<br class="calibre6"/>             "Starting to list directory...");
            let mut out = String::new();
            for entry in read_dir(path).unwrap() {
                for entry in dir {
                    if let Ok(entry) = entry {
                        add_file_info(entry.path(), &amp;mut out);
                    }
                }
                send_data(data_writer, &amp;out)
            }
        } else {
            send_cmd(&amp;mut self.stream, ResultCode::InvalidParameterOrArgument,
                     "No such file or directory...");
        }
    } else {
        send_cmd(&amp;mut self.stream, ResultCode::ConnectionClosed, <br class="calibre6"/>        "No opened data connection");
    }
    if self.data_writer.is_some() {
        self.data_writer = None;
        send_cmd(&amp;mut self.stream,<br class="calibre6"/>         ResultCode::ClosingDataConnection, "Transfer done");
    }
}</pre>
<p class="calibre3">To put it simply, we just added the following line:</p>
<pre class="calibre22">let path = self.cwd.join(path.unwrap_or_default());
let directory = PathBuf::from(&amp;path);
if let Ok(path) = self.complete_path(directory, &amp;server_root) {
    // ...
} else {
    send_cmd(&amp;mut self.stream, ResultCode::InvalidParameterOrArgument,
             "No such file or directory...");
}</pre>
<p class="calibre3">Thanks to the <span><kbd class="calibre14">Client::complete_path</kbd></span> method, things were pretty easy with the path manipulation. So, what happens if the given path is a file? We don't check such a case but we should! Let's replace the following lines:</p>
<pre class="calibre22">for entry in read_dir(path).unwrap() {
    for entry in dir {
        if let Ok(entry) = entry {
            add_file_info(entry.path(), &amp;mut out);
        }
    }
    send_data(data_writer, &amp;out)
}</pre>
<p class="calibre3">With:</p>
<pre class="calibre22">if path.is_dir() {
    for entry in read_dir(path).unwrap() {
        for entry in dir {
            if let Ok(entry) = entry {
                add_file_info(entry.path(), &amp;mut out);
            }
        }
        send_data(data_writer, &amp;out)
    }
} else {
    add_file_info(path, &amp;mut out);
}</pre>
<p class="calibre3">And that's it! Luckily for us, we did things correctly the first time, so <em class="calibre21">it just works</em>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the MKD command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The <span><kbd class="calibre14">MKD</kbd></span> stands for make directory (yes, exactly like the Unix command but shorter). Just like <span><kbd class="calibre14">LIST</kbd></span> and <span><kbd class="calibre14">CWD</kbd></span>, it takes <span><kbd class="calibre14">PathBuf</kbd></span> as an argument. I'll let you handle the other adds as usual and focus on the command implementation:</p>
<pre class="calibre22">Command::Mkd(path) =&gt; self.mkd(path),</pre>
<p class="calibre3">Just like last time, we'll create a new method:</p>
<pre class="calibre22">use std::fs::create_dir;

fn mkd(&amp;self, path: PathBuf) {
    let server_root = env::current_dir().unwrap();
    let path = self.cwd.join(&amp;path);
    if let Some(parent) = path.parent().map(|p| p.to_path_buf()) {
        if let Ok(mut dir) = self.complete_path(parent,<br class="calibre6"/>         &amp;server_root) {
            if dir.is_dir() {
                if let Some(filename) = path.file_name().map(|p| <br class="calibre6"/>                 p.to_os_string()) {
                    dir.push(filename);
                    if create_dir(dir).is_ok() {
                        send_cmd(&amp;mut self.stream,<br class="calibre6"/>                         ResultCode::PATHNAMECreated,
                          "Folder successfully created!");
                        return
                    }
                }
            }
        }
    }
    send_cmd(&amp;mut self.stream, ResultCode::FileNotFound,
             "Couldn't create folder");
}</pre>
<p class="calibre3">Once again, a few things have to be done before even actually trying to make the directory.</p>
<p class="calibre3">First, we need to check whether all the elements of the given path are folders (well, only the last one in fact since otherwise, the <span><kbd class="calibre14">Client::complete_path</kbd></span> method will fail otherwise).</p>
<p class="calibre3">Then we need to once again, canonicalize this path (by calling the <span><kbd class="calibre14">Client::complete_path</kbd></span> method). Finally, we push the filename to the received path.</p>
<p class="calibre3">The main difference here is that we don't strip the <span><kbd class="calibre14">server_root</kbd></span> path from the path returned by <span><kbd class="calibre14">Client::complete_path</kbd></span>.</p>
<p class="calibre3">Once all of this is done, we can try to create the folder by using the <span><kbd class="calibre14">create_dir</kbd></span> function. If it goes well, we then return <span><kbd class="calibre14">ResultCode::PATHNAMECreated</kbd></span> (and for once it makes sense!).</p>
<p class="calibre3">If any error occurs at any level, we just send that the path was incorrect.</p>
<p class="calibre3">That's it for this command!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing the RMD command</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Now that we can create folders, it'd be nice to be able to remove them, right? That's what <span><kbd class="calibre14">RMD</kbd></span> (which stands for <em class="calibre21">remove directory</em>) is supposed to do!</p>
<p class="calibre3">Just like <span><kbd class="calibre14">MKD</kbd></span> (and the others), <span><kbd class="calibre14">RMD</kbd></span> takes <span><kbd class="calibre14">PathBuf</kbd></span> as an argument. Once again, and as usual, I'll let you handle the <span><kbd class="calibre14">Command</kbd></span> part so we can focus on the command implementation:</p>
<pre class="calibre22">Command::Rmd(path) =&gt; self.rmd(path),</pre>
<p class="calibre3">Yep, it's a new method once again. It becomes a habit at this point I suppose?</p>
<pre class="calibre22">use std::fs::remove_dir_all;

fn rmd(&amp;self, path: PathBuf) {
    let server_root = env::current_dir().unwrap();
    if let Ok(path) = self.complete_path(path, &amp;server_root) {
        if remove_dir_all(path).is_ok() {
            send_cmd(&amp;mut self.stream, <br class="calibre6"/>                     ResultCode::RequestedFileActionOkay,
                     "Folder successfully removed!");
            return
        }
    }
    send_cmd(&amp;mut self.stream, ResultCode::FileNotFound, <br class="calibre6"/>      "Couldn't remove folder!");
}</pre>
<p class="calibre3">And that's it! This is even easier than <span><kbd class="calibre14">MKD</kbd></span> since we don't need to check if the last potential parent is a folder. Once we have confirmed that the path was an authorized one, we can just remove it.</p>
<p class="calibre3">With all these commands, I think we can say that we have a very fine base to build upon in order to make a complete FTP server.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Testing it</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">You now have a (very) basic FTP server implementation. You can connect to the server and list the files and folders in the current folder.</p>
<p class="calibre3">Start it with  <span><kbd class="calibre14">cargo run</kbd></span> and give it a try! I recommend that you use <span><kbd class="calibre14">FileZilla</kbd></span>. This is a great FTP client. Connect to <span><kbd class="calibre14">localhost</kbd></span> on the port <span><kbd class="calibre14">1234</kbd></span> and use the <span><kbd class="calibre14">anonymous</kbd></span> username (or none), and you should be able to have a bit of fun already:</p>
<div class="mce-root"><img src="../images/00042.jpeg" class="calibre70"/></div>
<div class="mce-root1"><em class="calibre21">Figure 8.1</em></div>
<p class="calibre3">Information on the file transfers and additional commands will be covered in later chapters.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In this chapter, we looked at the basics of the FTP. We now have a simple (synchronous) server implementation, and you should have a good idea about how all of this is working. We also looked at a potential security issue and how to fix it.</p>
<p class="calibre3">The following chapters will introduce you to asynchronous programming in Rust. Thanks to this chapter, it'll go a lot quicker on the FTP RFC side so we can focus on the asynchronous part.</p>
<p class="calibre3"/>


            </article>

            
        </section>
    </body></html>