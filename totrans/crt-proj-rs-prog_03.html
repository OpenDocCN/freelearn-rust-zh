<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Creating a REST Web Service
                </header>
            
            <article>
                
<p><span>Historically, a lot of technologies have been developed and used to create a client-server system. In recent decades, though, all client-server architectures tend to be web-based—that is, based on the <strong>HyperText Transfer Protocol</strong> (<strong>HTTP</strong>). HTTP is based on the <strong>Transfer Control Protocol</strong> (<strong>TCP</strong>) and the <strong>Internet Protocol</strong> (<strong>IP</strong>). In particular, two web-based architectures have become popular—the <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) and <strong>Representational State Transfer</strong> (<strong>REST</strong>).</span></p>
<p><span>While SOAP is an actual protocol, REST is only a collection of <em>principles</em>. The web services adhering to the REST principles are said to be RESTful. </span>In this chapter, we'll see how to build RESTful services using the popular Actix web framework.</p>
<p>Any web service (REST web services included) can be used by any web client—that is, any program that can send HTTP requests over a TCP/IP network. The most typical web clients are web pages running in a web browser, and containing JavaScript code. Any program written in any programming language and running in any operating system implementing the TCP/IP protocols can act as a web client.</p>
<p>The web servers are also known as the <strong>backend</strong>, while the web client is known as the <strong>frontend</strong>.</p>
<p><span>The following topics will be covered in this chapter:</span></p>
<ul>
<li>The REST architecture</li>
<li>Building a stub of a web service using the Actix web framework and implementing the REST principles</li>
<li>Building a complete web service capable of uploading files, downloading files, and deleting files on client request</li>
<li>Handling an inner state as a memory database or a pool of connections to a <span>database</span></li>
<li>Using <strong>JavaScript Object Notation</strong> (<span><strong>JSON</strong>) format to </span>send data to clients</li>
</ul>
<h1 id="uuid-3c89db45-7431-441a-971a-99d458d0afac">Technical requirements</h1>
<p><span>To easily understand this chapter, you should have beginner knowledge of HTTP. The required concepts are as follows:</span></p>
<ul>
<li><strong>Uniform Resource Identifiers</strong> (<strong>URIs</strong>)</li>
<li>Methods (such as <kbd>GET</kbd>)</li>
<li>Headers</li>
<li>Body</li>
<li><span>Content type (such as <kbd>plain/text</kbd>)</span></li>
<li>Status code (such as <kbd>Not Found=404</kbd>)</li>
</ul>
<p style="color: black"><span>Before starting the projects in this chapter, a generic </span><span>HTTP client should be installed on your computer. </span><span>The tool used in the examples is the command-line tool <strong>curl</strong>, freely available for many operating systems. The official download page is</span><span> </span><a href="https://curl.haxx.se/download.html">https://curl.haxx.se/download.html</a><span>. In particular, the page for Microsoft Windows is </span><a href="https://curl.haxx.se/windows/">https://curl.haxx.se/windows/</a><span>.</span></p>
<p style="color: black">Alternatively, you can use one of the several good, free<span> </span><span>web-browser utilities, such as Advanced REST Client for Chrome, or RESTED and RESTer for Firefox.</span></p>
<p>The complete source code for this chapter is in the <kbd>Chapter03</kbd> folder of the repository, located at <a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers</a>.</p>
<h1 id="uuid-5d87e8e9-6eff-4b58-acb6-8c5e7d6a6e8f">The REST architecture</h1>
<p><span>The REST architecture is strongly based on the HTTP protocol but does not require any specific kind of data format, and so it can transmit data in several formats such as plain text, JSON, <strong>Extensible Markup Language</strong> (<strong>XML</strong>), or binary (encoded as Base64).</span></p>
<p>Many web resources describe what the REST architectural paradigm is. One such can be found at <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">https://en.wikipedia.org/wiki/Representational_state_transfer</a>.</p>
<p>However, the concept of the REST architecture is quite simple. It is the purest extension of the ideas behind the <strong>World Wide Web</strong> (<strong>WWW</strong>) project.</p>
<p>The WWW project was born in 1989 as a global library of <strong>hypertexts</strong>. A hypertext is a document that contains links to other documents so that, by clicking repeatedly on the links, you can see many documents by using only your mouse. Such documents are scattered over the internet and are identified by a unique description, the <strong>Uniform Resource Locator</strong> (<strong>URL</strong>). The protocol to share such documents is HTTP, and the documents are written in <strong>HyperText Markup Language</strong> (<strong>HTML</strong>). A document can embed images, referenced by URL addresses too.</p>
<p>The HTTP protocol allows you to download pages to your document viewer (the web browser), but also to upload new documents to be shared with other people. You can also replace existing documents with a new version, or delete existing documents.</p>
<p>If the concept of a <em>document</em> or <em>file</em> is replaced by that of <em>named data</em>, or a <em>resource</em>, you get the concept of REST. Any interaction with a RESTful server is a manipulation of a piece of data, referencing it by its name. Of course, such data can be a disk file, but it can also be a set of records in a database that is identified by a query, or even a variable kept in memory.</p>
<p>A peculiar aspect of RESTful servers is the absence of server-side client sessions. As with any hypertext server, <span>RESTful servers do not store the fact that a client has logged in. If there is some data associated with a session, such as the current user or the previously visited pages, that data belongs only to the client side. As a consequence, any time the client needs access to privileged services, or to user-specific data, the request must contain the credentials of the user.</span></p>
<p>To improve performance, the server can store session information in a cache, but that should be transparent. The server (except for its performance) should behave as if it doesn't keep any session information.</p>
<h1 id="uuid-1aae13ac-3c74-4321-93d8-6170bda11277">Project overview</h1>
<p>We are going to build several projects, introducing new features in every project. Let's look at each one, as follows:</p>
<ul>
<li>The first project will build a stub of a service that should allow any client to upload, download, or delete files from the server. This project shows how to create a REST <strong>application programming interface</strong> (<strong>API</strong>), but it does no useful work.</li>
<li>The second project will implement the API described in the previous project. It will build a service that actually allows any client to upload, download, or delete files from the server filesystem.</li>
<li>The third project will build a service that allows clients to add key-value records to a memory database residing in the server process, and to recall some predefined queries built into the server. The result of such queries will be sent back to the client in plain text format.</li>
<li>The fourth project will be similar to the third one, but the results will be encoded in JSON format.</li>
</ul>
<p>Our source code is small, but it includes the Actix web crate, which in turn includes around 200 crates, and so the first build of any project will take around 10 minutes. Following any changes to the application code, a build will take from 12 to 30 seconds.</p>
<p>The Actix web crate has been chosen as it is the most feature-full, reliable, high-performance, and well-documented server-side web application framework for Rust.</p>
<p>This framework <span>is not limited to RESTful services, as it </span>can be used to build different kinds of server-side web software. It is an extension of the Actix net framework, which is a framework designed to implement different kinds of network services.</p>
<h1 id="uuid-54dc32ca-83a9-4c8b-b7bb-62e0ff6c7811">Essential background theory and context</h1>
<p>Previously, we said that a RESTful service is based on the HTTP protocol. This is a rather complex protocol, but its most important parts are quite simple. Here is a simplified version of it.</p>
<p>The protocol is based on a pair of messages. First, the client sends a request to the server, and after the server receives this request, it replies by sending a response to the client. Both messages are in <strong>American Standard Code for Information Interchange</strong> (<strong>ASCII</strong>) text, and so they are easily manipulated.</p>
<p>The HTTP protocol is usually based on the TCP/IP protocol, which guarantees that these messages arrive at the addressed process.</p>
<p>Let's see a typical HTTP request message, as follows:</p>
<pre>GET /users/susan/index.html HTTP/1.1<br/>Host: www.acme.com<br/>Accept: image/png, image/jpeg, */*<br/>Accept-Language: en-us<br/>User-Agent: <span>Mozilla/5.0</span><br/><br/></pre>
<p>This message contains six lines because there is an empty line at the end.</p>
<p>The first line begins with the word <kbd>GET</kbd>. This word is the <em>method</em> that specifies which operation is requested. Then, there is a Unix-style <em>path</em> of a resource, and then the version of the protocol (here, it is <kbd>1.1</kbd>).</p>
<p>Then, there are four lines containing rather simple attributes. These attributes are name <strong>headers</strong>. There are many possible optional headers.</p>
<p>What follows the first empty line is the <em>body</em>. Here, the body is empty. The body is used to send raw data—even a lot of data.</p>
<p class="mce-root">So, any request from the HTTP protocol sends <span>a command name (the method)</span> to a specific server, followed by an identifier of a resource (the path). Then, there are a few attributes (one per line), then an empty line, and, finally, the possible raw data (the body).</p>
<p>The most important methods are detailed as follows:</p>
<ul>
<li class="mce-root"><kbd>GET</kbd>: This requests a resource to be downloaded from the server (typically an HTML file or an image file, but also any data). The path specifies where the resource should be read.</li>
<li class="mce-root"><kbd>POST</kbd>: This<span> sends some data to the server that the server should consider as new. The path specifies where to add this data. If the path identifies any existing data, the server should return an error code. The contents of the data to post are in the body section.</span></li>
<li class="mce-root"><kbd>PUT</kbd>: This is similar to the <kbd>POST</kbd> command, but it is meant to replace existing data.</li>
<li class="mce-root"><kbd>DELETE</kbd>: This requests the resource <span>to be removed </span>specified by the path. It has an empty body.</li>
</ul>
<p class="mce-root">Here is a typical HTTP response message:</p>
<pre>HTTP/1.1 200 OK<br/>Date: Wed, 15 Apr 2020 14:03:39 GMT<br/>Server: Apache/2.2.14<br/>Accept-Ranges: bytes<br/>Content-Length: 42<br/>Connection: close<br/>Content-Type: text/html<br/> <br/>&lt;html&gt;&lt;body&gt;&lt;p&gt;Some text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre>
<p class="mce-root">The first line of any response message begins with the protocol version, followed by the status code both in text format and in numeric format. Success is represented by <kbd>200 OK</kbd>.</p>
<p class="mce-root">Then, there are several headers—six, in this example—then an empty line, and then the body, which may be empty. In this case, the body contains some HTML code.</p>
<p>You can find more information regarding the HTTP protocol at: <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol</a><span>.</span></p>
<h1 id="uuid-f66eb5c9-26cd-4f49-bc91-297677c72b40">Building a stub of a REST web service</h1>
<p>The typical example of a REST service is a web service designed <span>for uploading and downloading text files. As it would be too complex to understand,</span> first we will look at a simpler project, the <kbd>file_transfer_stub</kbd> project, which mimics this service without actually doing anything on the filesystem.</p>
<p>You will see how an API of a RESTless web service <span>is structured</span>, without being overwhelmed by the details regarding the implementation of the commands.</p>
<p>In the next section, this example will be completed with the needed implementation, to obtain a working file-managing web app.</p>
<h2 id="uuid-4e674ad7-7c8a-40f0-9be1-195cffff41de">Running and testing the service</h2>
<p>To run this service, it is enough to type the command<span> </span><kbd>cargo run</kbd> in a console. After building the program, it will print <kbd>Listening at address 127.0.0.1:8080 ...</kbd>, and it will remain listening for incoming requests.</p>
<p>To test it, we need a web client. You can use a browser extension if you prefer, but in this chapter, the curl command-line utility will be used.</p>
<p class="mce-root"><span>The</span><span> </span><kbd>file_transfer_stub</kbd><span> service and the <kbd>file_transfer</kbd> service (we'll see them in the next section)</span> have the same API, containing the following four commands:</p>
<ol>
<li class="mce-root">Download a file with a specified name.</li>
<li class="mce-root">Upload a file with a specified name and specified contents.</li>
<li class="mce-root">Upload a file with a specified name prefix and specified contents, obtaining the complete name as a response.</li>
<li class="mce-root">Delete a file with a specified name.</li>
</ol>
<h2 id="uuid-b48e5bd6-b5ab-4010-aa5a-1c97788c4be6" class="mce-root">Getting a resource using the GET method</h2>
<p><span>To download a resource in the REST architecture,</span><span> the <kbd>GET</kbd> method should be used. For these commands, the URL should specify the name of the file to download. No additional data should be passed, and the response should contain the contents of the file and the status code, which can be <kbd>200</kbd>, <kbd>404</kbd>, or <kbd>500</kbd>:</span></p>
<ol>
<li>Type the following command into a console:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X GET http://localhost:8080/datafile.txt</strong></pre>
<ol start="2">
<li>In that console, the following mock line should be printed, and then the prompt should appear immediately:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Contents of the file.</strong></pre>
<ol start="3">
<li>Meanwhile, on the other console, the following line should be printed:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Downloading file "datafile.txt" ... Downloaded file "datafile.txt"</strong></pre>
<p style="padding-left: 60px">This command mimics the request to download the<span> </span><kbd>datafile.txt</kbd><span> file </span>from the filesystem of the server.</p>
<ol start="4">
<li>The <kbd>GET</kbd> method is the default one for curl, and hence you can simply type the following:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl http://localhost:8080/datafile.txt</strong></pre>
<ol start="5">
<li>In addition, you can redirect the output to any file by typing the following:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl http://localhost:8080/datafile.txt &gt;localfile.txt</strong></pre>
<p><span>So, we have now seen how our web service can be used by curl to download a remote file, to print it on the console, or to save it in a local file.</span></p>
<h2 id="uuid-5eebefe7-948c-48f3-bf72-e98bf016ca44" class="mce-root">Sending a named resource to the server using the PUT method</h2>
<p class="mce-root"><span>To upload a resource in the REST architecture, either the <kbd>PUT</kbd> or <kbd>POST</kbd> methods should be used. </span>The <kbd>PUT</kbd> method is used when the client knows <em>where</em> the resource should be stored, in essence, what will be its <em>identifying key</em>. If there is already a resource that has this key, that resource will be replaced by the newly uploaded resource:</p>
<ol>
<li class="mce-root">Type the following command into a console:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X PUT http://localhost:8080/datafile.txt -d "File contents."</strong></pre>
<ol start="2">
<li>In that console, the prompt should appear immediately. Meanwhile, on the other console, the following line should be printed:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Uploading file "datafile.txt" ... Uploaded file "datafile.txt"</strong></pre>
<p style="padding-left: 60px" class="mce-root">This command mimics the request to send a file to the server, with the client specifying the name of that resource, so that if a resource with that name already exists, it is overwritten.</p>
<ol start="3">
<li>You can use <em>curl</em> to send the data contained in a specified local file in the following way:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X PUT http://localhost:8080/datafile.txt -d @localfile.txt</strong></pre>
<div class="packt_tip">Here, the <kbd>curl</kbd> command has an additional argument, <kbd>-d</kbd>, which allows us to specify the data we want to send to the server. If it is followed by an <kbd>@</kbd> symbol, the text following this symbol is used as the path of the uploaded file.</div>
<p class="mce-root">For these commands, the URI should specify the name of the file to upload and also the contents of the file, and the response should contain only the status code, which can be <kbd>200</kbd>, <kbd>201</kbd> (Created), or <kbd>500</kbd>. The difference between <kbd>200</kbd> and <kbd>201</kbd> is that in the first case, an existing file is overwritten, and in the second case, a new file is created.</p>
<p><span>So, we have now learned how our web service can be used by curl to upload a string into a remote file, while also specifying the name of the file.</span></p>
<h2 id="uuid-58c69914-348a-4a4a-9fe0-694609848f15" class="mce-root">Sending a new resource to the server using the POST method</h2>
<p><span>In the REST architecture, </span><span>the <kbd>POST</kbd> method is the one to use when it is the responsibility of the service to generate an identifier key for the new resource. Thus, the request does not have to specify it. The client can specify a pattern or prefix for the identifier, though. As the key is automatically generated and unique, there cannot be another resource that has the same key. The generated key should be returned to the client, though, because otherwise, it cannot reference that resource afterward:</span></p>
<ol>
<li>To upload a file with an unknown name, type the following command into the <span>console</span>:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X POST http://localhost:8080/data -d "File contents."</strong></pre>
<ol start="2">
<li>In that console, the text <kbd>data17.txt</kbd> should be printed, and then the prompt should appear. This text is the simulated name of the file, received from the server. Meanwhile, on the other console, the following line should be printed:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Uploading file "data*.txt" ... Uploaded file "data17.txt"</strong></pre>
<p class="mce-root">This command represents the request to send a file to the server, with the server specifying a new unique name for that resource so that no other resource will be overwritten.</p>
<p class="mce-root">For this command, the URI should not specify the full name of the file to upload, but only a prefix; of course, the request should also contain the contents of the file. The response should contain the complete name of the newly created file and the status code. In this case, the status code can only be <kbd>201</kbd> or <kbd>500</kbd>, because the possibility of a file already existing is ruled out.</p>
<p><span>We have now learned how our web service can be used by curl to upload a string into a new remote file, leaving the task of inventing a new name for that file to the server. We have also seen that the generated filename is sent back as a response.</span></p>
<h2 id="uuid-0c0677ff-43fa-4606-89c2-03f75a425e6b">Deleting a resource using the DELETE method</h2>
<p><span>In the REST architecture, to delete a resource, the <kbd>DELETE</kbd> method should be used:</span></p>
<ol>
<li>Type the following command into a console (don't worry—no file will be deleted!):</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X DELETE http://localhost:8080/datafile.txt</strong></pre>
<ol start="2">
<li>After typing that command, the prompt should appear immediately. Meanwhile, in the server console, the following line should be printed:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Deleting file "datafile.txt" ... Deleted file "datafile.txt"</strong></pre>
<p class="mce-root">This command represents the request to delete a file from the filesystem of the server. <span>For such a command, the URL should specify the name of the file to delete. No additional data needs to be passed, and the only response is the status code, which can be <kbd>200</kbd>, <kbd>404</kbd>, or <kbd>500</kbd>. </span><span>So, we have seen how our web service can be used by <em>curl</em> to delete a remote file.</span></p>
<p class="mce-root">As a summary, the possible status codes of this service are as follows:</p>
<ul>
<li class="mce-root"><kbd>200</kbd>: OK</li>
<li class="mce-root"><kbd>201</kbd>: Created</li>
<li class="mce-root"><kbd>404</kbd>: Not Found</li>
<li class="mce-root"><kbd>500</kbd>: Internal Server Error</li>
</ul>
<p class="mce-root">Also, the four commands of our API are as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Method</strong></td>
<td><strong>URI</strong></td>
<td><strong>Request data format</strong></td>
<td><strong>Response data format</strong></td>
<td><strong>Status codes</strong></td>
</tr>
<tr>
<td><kbd>GET</kbd></td>
<td><kbd><span>/{filename}</span></kbd></td>
<td>---</td>
<td>text/plain</td>
<td><kbd>200</kbd>, <kbd>404</kbd>, <kbd>500</kbd></td>
</tr>
<tr>
<td><kbd>PUT</kbd></td>
<td><kbd><span>/{filename}</span></kbd></td>
<td><span>text/plain</span></td>
<td>---</td>
<td><kbd>200</kbd>, <kbd>201</kbd>, <kbd>500</kbd></td>
</tr>
<tr>
<td><kbd>POST</kbd></td>
<td><span><kbd>/{filename</kbd> prefix}</span></td>
<td><span>text/plain</span></td>
<td><span>text/plain</span></td>
<td><kbd>201</kbd>, <kbd>500</kbd></td>
</tr>
<tr>
<td><kbd><span>DELETE</span></kbd></td>
<td><kbd><span>/{filename}</span></kbd></td>
<td>---</td>
<td>---</td>
<td><span><kbd>200</kbd>, <kbd>404</kbd>, <kbd>500</kbd></span></td>
</tr>
</tbody>
</table>
<h2 id="uuid-1fe0019e-92bc-4d29-b27f-46b3982a52ba" class="mce-root">Sending an invalid command</h2>
<p>Let's see the behavior of the server when an invalid command is received:</p>
<ol>
<li>Type the following command into a console:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X GET http://localhost:8080/a/b</strong></pre>
<ol start="2">
<li>In that console, the prompt should appear immediately. Meanwhile, in the other console, the following line should be printed:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Invalid URI: "/a/b"</strong></pre>
<p class="mce-root">This command represents the request to get the <kbd>/a/b</kbd> resource from the server, but, as our API does not permit this method of specifying a resource, the service rejects the request.</p>
<h2 id="uuid-e8d572a3-2606-4795-83b5-c5aaa80829a3" class="mce-root">Examining the code</h2>
<p class="mce-root">The <kbd>main</kbd> function contains the following statements:</p>
<pre class="mce-root">HttpServer::new(|| ... )<br/>.bind(server_address)?<br/>.run()</pre>
<p>The first line creates an instance of an HTTP server. Here, the body of the closure is omitted.</p>
<p>The second line binds the server to an IP endpoint, which is a pair composed of an IP address and an IP port, and returns an error if such a binding fails.</p>
<p>The third line puts the current thread in listening mode on that endpoint. It blocks the thread, waiting for incoming TCP connection requests.</p>
<p class="mce-root">The argument of the <kbd>HttpServer::new</kbd> call is a closure, shown here:</p>
<pre class="mce-root">App::new()<br/>    .service(<br/>        web::resource("/{filename}")<br/>            .route(web::delete().to(delete_file))<br/>            .route(web::get().to(download_file))<br/>            .route(web::put().to(upload_specified_file))<br/>            .route(web::post().to(upload_new_file)),<br/>     )<br/>     .default_service(web::route().to(invalid_resource))</pre>
<p class="mce-root">In this closure, a new web app is created, and then one call to the<span> </span><kbd>service</kbd> function is applied to it. Such a function contains a call to the<span> </span><kbd>resource</kbd><span> </span>function, which returns an object on which four calls to the<span> </span><kbd>route</kbd><span> </span>function are applied. Lastly, a call to the<span> </span><kbd>default_service</kbd> function is applied to the application object.</p>
<p class="mce-root">This complex statement implements a mechanism to decide which function to call based on the path and method of the HTTP request. In web programming parlance, such a kind of mechanism is named <strong>routing</strong>.</p>
<p class="mce-root">The request routing first performs pattern matching between the address URI and one or several patterns. In this case, there is only one pattern, <kbd>/{filename}</kbd>, which describes a URI that has an initial slash and then a word. The word is associated with the <kbd>filename</kbd> name.</p>
<p class="mce-root"><span>The four calls to the</span> <kbd>route</kbd> <span>method proceed with the routing, based on the HTTP method (<kbd>DELETE</kbd>, <kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>). There is a specific function for every possible HTTP method, followed by a call to the <kbd>to</kbd> function that has a handling function as an argument.</span></p>
<p class="mce-root">Such calls to <kbd>route</kbd> mean that the following applies:</p>
<ul>
<li class="mce-root">If the request method of the current HTTP command is<span> </span><kbd>DELETE</kbd>, then such a request should be handled by going to the<span> </span><kbd>delete_file</kbd> function.</li>
<li class="mce-root">If the request method of the current HTTP command is<span> </span><kbd>GET</kbd>, then such a request should be handled by going to the<span> </span><kbd>download_file</kbd> function.</li>
<li class="mce-root">If the request method of the current HTTP command is<span> </span><kbd>PUT</kbd>, then such a request should be handled by going to the<span> </span><kbd>upload_specified_file</kbd> function.</li>
<li class="mce-root">If the request method of the current HTTP command is<span> </span><kbd>POST</kbd>, then such a request should be handled by going to the<span> </span><kbd>upload_new_file</kbd> function.</li>
</ul>
<p><span>Such four handling functions, named <strong>handlers</strong>, must of course be implemented </span>in the current scope. In actuality, they are defined, albeit interleaved with<span> </span><kbd>TODO</kbd><span> </span>comments, recalling what is missing to have a working application instead of a stub. Nevertheless, such handlers contain much functionality.</p>
<p>Such a routing mechanism can be read in English, in this way—for example, for a <kbd>DELETE</kbd> command:</p>
<div class="packt_quote">Create a <kbd>service</kbd> to manage the <kbd>web::resource</kbd> named <kbd>/{filename}</kbd>, to <kbd>route</kbd> a <kbd>delete</kbd> command to the <kbd>delete_file</kbd> handler.</div>
<p><span>After all of the patterns, there is the call to the</span><span> </span><kbd>default_service</kbd><span> function </span><span>that represents a catch-all pattern, typically to handle invalid URIs, such as </span><kbd>/a/b</kbd><span> </span><span>in the previous example.</span></p>
<p class="mce-root">The argument of the catch-all statement—that is, <kbd>web::route().to(invalid_resource)</kbd>, causes the routing to the <kbd>invalid_resource</kbd> function. You can read it as follows:</p>
<div class="mce-root packt_quote">For this <kbd>web</kbd> command, <kbd>route</kbd> it to the <kbd>invalid_resource</kbd> function.</div>
<p class="mce-root"><span>Now, let's see the handlers, starting with the simplest one, as follows:</span></p>
<pre class="mce-root">fn invalid_resource(req: HttpRequest) -&gt; impl Responder {<br/>    println!("Invalid URI: \"{}\"", req.uri());<br/>    HttpResponse::NotFound()<br/>}</pre>
<p class="mce-root">This function receives an <kbd>HttpRequest</kbd> object and returns something implementing the <kbd>Responder</kbd> trait. It means that it processes an HTTP request, and returns something that can be converted to an HTTP response.</p>
<p class="mce-root">This function is quite simple because it does so little. It prints the URI to the console and returns a <em>Not Found</em> HTTP status code.</p>
<p class="mce-root">The other four handlers get a different argument, though. It is the following: <kbd>info: Path&lt;(String,)&gt;</kbd>. Such an argument contains a description of the path matched before, with the <kbd>filename</kbd> argument put into a single-value tuple, inside a <kbd>Path</kbd> object. This is because such handlers do not need the whole HTTP request, but they need the parsed argument of the path.</p>
<p>Notice that we have one handler receiving an argument of the<span> </span><kbd>HttpRequest</kbd><span> type, and the others receiving an argument of the <kbd>Path&lt;(String,)&gt;</kbd> type. </span>This syntax is possible because the <kbd>to</kbd> function, called in the <kbd>main</kbd> function, expects as an argument a generic function, whose arguments can be of several different types.</p>
<p class="mce-root">All four handlers begin with the following statement:</p>
<pre class="mce-root">let filename = &amp;info.0;</pre>
<p>Such a statement extracts a reference to the first (and only) field of the tuple containing the parameters resulting from the pattern matching of the path. This works as long as the path contained exactly one parameter. The <kbd>/a/b</kbd> path cannot be matched with the pattern, because it has two parameters. Also, the <kbd>/</kbd> path cannot be matched, because it has no parameters. Such cases end in the <em>catch-all</em> pattern.</p>
<p class="mce-root">Now, let's examine the <kbd>delete_file</kbd> function <span>specifically.</span> It continues with the following lines:</p>
<pre>print!("Deleting file \"{}\" ... ", filename);<br/>flush_stdout();<br/><br/>// TODO: Delete the file.<br/><br/>println!("Deleted file \"{}\"", filename);<br/>HttpResponse::Ok()</pre>
<p class="mce-root">It has two informational printing statements, and it ends returning a success value. In the middle, the actual statement to delete the file is still missing. The call to the <kbd>flush_stdout</kbd> function is needed to emit the text on the console immediately.</p>
<p class="mce-root">The <kbd>download_file</kbd> function is similar, but, as it has to send back the contents of the file, it has a more complex response, as illustrated in the following code snippet:</p>
<pre class="mce-root">HttpResponse::Ok().content_type("text/plain").body(contents)</pre>
<p class="mce-root">The object returned by the call to <kbd>Ok()</kbd> is decorated, first by calling <kbd>content_type</kbd> and setting <kbd>text/plain</kbd> as the type of the returned body, and then by calling <kbd>body</kbd> and setting the contents of the file as the body of the response.</p>
<p class="mce-root">The <kbd>upload_specified_file</kbd> function is quite simple, as its two main jobs are missing: getting <span>the text to put in the file</span> from the body of the request, and saving that text into the file, as illustrated in the following code block:</p>
<pre>print!("Uploading file \"{}\" ... ", filename);<br/>flush_stdout();<br/><br/>// TODO: Get from the client the contents to write into the file.<br/>let _contents = "Contents of the file.\n".to_string();<br/><br/>// TODO: Create the file and write the contents into it.<br/><br/>println!("Uploaded file \"{}\"", filename);<br/>HttpResponse::Ok()</pre>
<p class="mce-root">The <kbd>upload_new_file</kbd> function is similar, but it should have another step that is still missing: to generate a unique filename for the file to save, as illustrated in the following code block:</p>
<pre>print!("Uploading file \"{}*.txt\" ... ", filename_prefix);<br/>flush_stdout();<br/><br/>// TODO: Get from the client the contents to write into the file.<br/>let _contents = "Contents of the file.\n".to_string();<br/><br/>// TODO: Generate new filename and create that file.<br/>let file_id = 17;<br/><br/>let filename = format!("{}{}.txt", filename_prefix, file_id);<br/><br/>// TODO: Write the contents into the file.<br/><br/>println!("Uploaded file \"{}\"", filename);<br/>HttpResponse::Ok().content_type("text/plain").body(filename)</pre>
<p>So, we have examined all of the Rust code of the stub of the web service. In the next section, we'll look at the complete implementation of this service.</p>
<h1 id="uuid-217a0454-0055-4aec-961f-bb721ef982f7" class="mce-root">Building a complete web service</h1>
<p class="mce-root">The <kbd>file_transfer</kbd> project completes the <kbd>file_transfer_stub</kbd> project, by filling in the missing features.</p>
<p class="mce-root">The features were omitted in the previous project for the following reasons:</p>
<ul>
<li class="mce-root">To have a very simple service that <span>actually</span> does not really access the filesystem</li>
<li class="mce-root">To have only synchronous processing</li>
<li class="mce-root">To ignore any kind of failure, and keep the code simple</li>
</ul>
<p class="mce-root">Here, these restrictions have been removed. First of all, let's see what happens if you compile and run the <kbd>file_transfer</kbd> project, and then test it using the same commands as in the previous section.</p>
<h2 id="uuid-976e02a1-cf13-443f-bef4-9f5909b14b51" class="mce-root">Downloading a file</h2>
<p>Let's try the following steps on how to download a file:</p>
<ol>
<li>Type the following command into the console:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>curl -X GET http://localhost:8080/datafile.txt</strong></pre>
<ol start="2">
<li>If the download is successful, the server prints the following line to the console:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>Downloading file "datafile.txt" ... Downloaded file "datafile.txt"</strong></pre>
<div class="mce-root packt_infobox"><span>In the console of the client, </span><span>curl prints </span><span>the contents of that file.</span></div>
<p class="mce-root">In the case of an error, the service prints the following:</p>
<pre class="mce-root"><strong>Downloading file "datafile.txt" ... Failed to read file "datafile.txt": No such file or directory (os error 2)</strong></pre>
<p>We have now seen how our web service can be used by curl to download a file. In the next sections, we'll learn how our web service can perform other operations on remote files.</p>
<h2 id="uuid-6f4f5388-29ef-4dd0-bc43-3fd5ae2bb544" class="mce-root">Uploading a string to a specified file</h2>
<p>Here is the command to upload a string into a remote file with a specified name:</p>
<pre class="mce-root"><strong>curl -X PUT http://localhost:8080/datafile.txt -d "File contents."</strong></pre>
<p>If the upload is successful, the server prints the following to the console:</p>
<pre class="mce-root"><strong>Uploading file "datafile.txt" ... Uploaded file "datafile.txt"</strong></pre>
<p><span>If the file already existed, it is overwritten. If it didn't exist, it is created.</span></p>
<p>In the case of an error, the web service prints the following line:</p>
<pre class="mce-root"><strong>Uploading file "datafile.txt" ... Failed to create file "datafile.txt"</strong></pre>
<p class="mce-root">Alternatively, it prints the following line:</p>
<pre class="mce-root"><strong>Uploading file "datafile.txt" ... Failed to write file "datafile.txt"</strong></pre>
<p><span>This is how our web service can be used by curl to upload a string into a remote file while specifying the name of the file.</span></p>
<h2 id="uuid-d0927c80-d30c-4164-98f6-93ec382a05f3" class="mce-root">Uploading a string to a new file</h2>
<p>Here is the command to upload a string into a remote file with a name chosen by the server:</p>
<pre class="mce-root"><strong>curl -X POST http://localhost:8080/data -d "File contents."</strong></pre>
<p>If the upload is successful, the server prints to the console <span>something similar to the following</span>:</p>
<pre class="mce-root"><strong>Uploading file "data*.txt" ... Uploaded file "data917.txt"</strong></pre>
<p>This output shows that the name of the file contains a pseudo-random number— for this example, this is <kbd>917</kbd>, but you'll probably see some other number.</p>
<p>In the console of the client, curl prints the name of that new file, as the server has sent it back to the client.</p>
<p>In the case of an error, the server prints the following line:</p>
<pre class="mce-root"><strong>Uploading file "data*.txt" ... Failed to create new file with prefix "data", after 100 attempts.</strong></pre>
<p class="mce-root">Alternatively, it prints the following line:</p>
<pre class="mce-root"><strong>Uploading file "data*.txt" ... Failed to write file "data917.txt"</strong></pre>
<p><span>This is how our web service can be used by curl to upload a string into a new remote file, leaving the task of inventing a new name for that file to the server. The curl tool receives this new name as a response.</span></p>
<h2 id="uuid-e5581575-4bc3-4d4c-8ffc-44e6b1acdf71" class="mce-root">Deleting a file</h2>
<p>Here is the command to delete a remote file:</p>
<pre class="mce-root"><strong>curl -X DELETE http://localhost:8080/datafile.txt</strong></pre>
<p>If the deletion is successful, the server prints the following line to the console:</p>
<pre class="mce-root"><strong>Deleting file "datafile.txt" ... Deleted file "datafile.txt"</strong></pre>
<p class="mce-root">Otherwise, it prints this:</p>
<pre class="mce-root"><strong>Deleting file "datafile.txt" ... Failed to delete file "datafile.txt": No such file or directory (os error 2)</strong></pre>
<p><span>This is how our web service can be used by curl to delete a remote file.</span></p>
<h2 id="uuid-899e7253-c76d-44d0-a9b4-c17b26b3ac7a" class="mce-root">Examining the code</h2>
<p class="mce-root">Let's now examine the differences between this program and the one described in the previous section. The <kbd>Cargo.toml</kbd> file contains two new dependencies, as illustrated in the following code snippet:</p>
<pre class="mce-root">futures = "0.1"<br/>rand = "0.6"</pre>
<p class="mce-root">The <kbd>futures</kbd> crate is needed for asynchronous operations, and the <kbd>rand</kbd> crate is needed for randomly generating the unique names of the uploaded files.</p>
<p class="mce-root">Many new data types have been imported from the external crates, as can be seen in the following code block:</p>
<pre class="mce-root">use actix_web::Error;<br/>use futures::{<br/>    future::{ok, Future},<br/>    Stream,<br/>};<br/>use rand::prelude::*;<br/>use std::fs::{File, OpenOptions};</pre>
<p>The main function has just two changes, as follows:</p>
<pre>.route(web::put().to_async(upload_specified_file))<br/>.route(web::post().to_async(upload_new_file)),</pre>
<p>Here, two calls to the <kbd>to</kbd> function have been replaced by calls to the <kbd>to_async</kbd> function. While the <kbd>to</kbd> function is <em>synchronous</em> (that is, it keeps the current thread busy until that function is completed), the <kbd>to_async</kbd><span> function is <em>asynchronous</em> (that is, it can be postponed until the expected events have happened).</span></p>
<p><span>This change was required by the nature of upload requests. Such requests can send large files (several megabytes), and the TCP/IP protocol sends such files split into small packets. If the server, when it receives the first packet, just waits for the arrival of all the packets, it can waste a lot of time. Even with multithreading, if many users upload files concurrently, the system will dedicate as many threads as possible to handle such uploads, and this is rather inefficient. A more performant solution is asynchronous processing.</span></p>
<p>The<span> </span><kbd>to_async</kbd><span> function, though, cannot receive as an argument a synchronous handler. It must receive a function that returns a value having the <kbd>impl Future&lt;Item = HttpResponse, Error = Error&gt;</kbd> type, instead of the <kbd>impl Responder</kbd> type, returned by synchronous handlers. </span>This is actually the type returned by the two upload handlers: <kbd>upload_specified_file</kbd> and <kbd>upload_new_file</kbd>.</p>
<p><span>The object returned is of an abstract type, but it must implement the <kbd>Future</kbd> trait. </span><span>The concept of a <em>future</em>, used also in C++ since 2011, is similar to JavaScript </span><em>promises</em><span>. It represents a value that will be available in the future, and in the meantime, the current thread can handle some other events.</span></p>
<p class="mce-root">Futures are<span> implemented as </span><span>asynchronous closures, meaning that these closures are put in a queue </span>in an internal futures list, and not run immediately. When <span>no other task is running in the current thread, the future at the top of the queue is removed from the queue and executed.</span></p>
<p class="mce-root"><span>If two futures are chained, the failure of the first chain causes the second future to be destroyed. Otherwise, if the first future of the chain succeeds, the second future has the opportunity to run</span>.</p>
<p>Going back to the two upload functions, <span>another change for</span> their signature is the fact that they now get two arguments. In addition to the argument of the <kbd>Path&lt;(String,)&gt;</kbd> type, containing the filename, there is an argument of the <kbd>Payload</kbd> type. Remember that the contents can arrive piece-wise, and so such a <kbd>Payload</kbd> argument does not contain the text of the file, but it is an object <span>to get the contents of the uploaded file asynchronously.</span></p>
<p>Its use is somewhat complex.</p>
<p>First, for both upload handlers, there is the following code:</p>
<pre>payload<br/>    .map_err(Error::from)<br/>    .fold(web::BytesMut::new(), move |mut body, chunk| {<br/>        body.extend_from_slice(&amp;chunk);<br/>        Ok::&lt;_, Error&gt;(body)<br/>    })<br/>    .and_then(move |contents| {</pre>
<p>The call to <kbd>map_err</kbd> is required to convert the error type.</p>
<p>The call to <kbd>fold</kbd> receives from the network one chunk of data at a time and uses it to extend an object of the <kbd>BytesMut</kbd> type. Such a type implements a kind of extensible buffer.</p>
<p>The call to <kbd>and_then</kbd> chains another future to the current one. It receives a closure that will be called when the processing of <kbd>fold</kbd> will be finished. Such a closure receives all the uploaded contents as an argument. This is a way to chain two futures—any closure invoked in this way is executed asynchronously, after the previous one is finished.</p>
<p>The contents of the closure simply write the received contents into a file with the specified name. This operation is synchronous.</p>
<p>The last line of the closure is <kbd>ok(HttpResponse::Ok().finish())</kbd>. This is the way to return from a future. Notice the lowercase <kbd>ok</kbd>.</p>
<p>The <kbd>upload_new_file</kbd> function is similar to the previous one, in terms of the web programming concepts. It is more complex, just because of the following:</p>
<ul>
<li class="mce-root">Instead of having a complete filename, only a prefix is provided, and the rest must be generated as a pseudo-random number.</li>
<li class="mce-root">The resulting filename must be sent to the client.</li>
</ul>
<p class="mce-root">The algorithm to generate a unique filename is the following:</p>
<ol>
<li class="mce-root">A three-digit pseudo-random number is generated, and it is concatenated to the prefix.</li>
<li class="mce-root">The name obtained is used to create a file; this avoids overwriting an existing file with that name.</li>
<li class="mce-root">If a collision happens, another number is generated until a new file is created, or until 100 failed attempts have been tried.</li>
</ol>
<p class="mce-root">Of course, this assumes that the number of <span>uploaded files</span> will <span>always </span>be significantly less than 1,000.</p>
<p>Other changes have been made to consider the chance of failure. </p>
<p class="mce-root">The final part of the <kbd>delete_file</kbd> function now looks like this:</p>
<pre class="mce-root">match std::fs::remove_file(&amp;filename) {<br/>    Ok(_) =&gt; {<br/>        println!("Deleted file \"{}\"", filename);<br/>        HttpResponse::Ok()<br/>    }<br/>    Err(error) =&gt; {<br/>        println!("Failed to delete file \"{}\": {}", filename, error);<br/>        HttpResponse::NotFound()<br/>    }<br/>}</pre>
<p class="mce-root">This code handles the case of a failure in the deletion of the file. Notice that <span>in the case of an error,</span> instead of returning the success status code <kbd>HttpResponse::Ok()</kbd> representing the number <kbd>200</kbd>, a <kbd>HttpResponse::NotFound()</kbd> failure code is returned, representing the number <kbd>404</kbd>.</p>
<p class="mce-root">The <kbd>download_file</kbd> function now contains a local function to read <span>the whole contents of a file </span>into a string, as follows:</p>
<pre class="mce-root">fn read_file_contents(filename: &amp;str) -&gt; std::io::Result&lt;String&gt; {<br/>    use std::io::Read;<br/>    let mut contents = String::new();<br/>    File::open(filename)?.read_to_string(&amp;mut contents)?;<br/>    Ok(contents)<br/>}</pre>
<p class="mce-root">The function ends with some code to handle the possible failure of the function, as follows:</p>
<pre class="mce-root">match read_file_contents(&amp;filename) {<br/>    Ok(contents) =&gt; {<br/>        println!("Downloaded file \"{}\"", filename);<br/>        HttpResponse::Ok().content_type("text/plain").body(contents)<br/>    }<br/>    Err(error) =&gt; {<br/>        println!("Failed to read file \"{}\": {}", filename, error);<br/>        HttpResponse::NotFound().finish()<br/>    }<br/>}</pre>
<h1 id="uuid-298c8d6c-b51d-4dcf-b8ba-c272323cdeb9" class="mce-root">Building a stateful server</h1>
<p class="mce-root">The web app of the <kbd>file_transfer_stub</kbd> <span>project </span>was completely stateless, meaning that every operation had the same behavior independently of the previous operations. Other ways to explain this are that no data was kept from one command to the next, or that it computed pure functions <span>only</span>.</p>
<p class="mce-root">The web app of the <kbd>file_transfer</kbd> project had a state, but that state was confined to the filesystem. Such a state was the content of the data files. Nevertheless, the application itself was still stateless. No variable survived from one request handling to another request handling.</p>
<p class="mce-root">The REST principles are usually interpreted as prescribing that any API <em>must be stateless</em>. That is a misnomer because REST services <em>can</em> have a state, but they <em>must behave as if they were stateless</em>. To be stateless means that, except for the filesystem and the database, no information survives in the server from one request handling to another request handling. To behave as if stateless means that any sequence of requests should obtain the same results even if the server is terminated and restarted between one request and a successive one.</p>
<p>Clearly, if the server is terminated, its state is lost. So, to behave as stateless means that the behavior should be the same even if the state is reset. So, what is the purpose of the possible server state? It is to store information that <span>can be obtained again with any request, but that </span>would be costly to do so. This is the concept of caching.</p>
<p class="mce-root">Usually, any REST web server has an internal state. The typical information stored in this state is a pool of connections to the database. A pool is initially empty, and when the first handler must connect to the database, it searches the pool for an available connection. If it finds one, it uses it. Otherwise, a new connection is created and added to the pool. A pool is a shared state that must be passed to any request handler.</p>
<p class="mce-root">In the projects of the previous sections, the request handlers were pure functions; they had no possibility of sharing a common state. In the <kbd>memory_db</kbd> project, we'll see how we can have a shared state <span>in the Actix web</span> framework that is passed to any request handler.</p>
<p class="mce-root">This web app represents access to a very simple database. Instead of performing actual access to a database, which would require further installations in your computer, it simply invokes some functions exported by the <kbd>data_access</kbd> module, defined in the <kbd>src/data_access.rs</kbd> file, that keep the database in memory.</p>
<p>A memory database is a state that is <span>shared by all the request handlers</span>. In a more realistic app, a state would contain only one or more connections to an external database.</p>
<h2 id="uuid-f89df9d6-fbd6-4c41-bd90-86c51e980b8a">How to have a stateful server</h2>
<p>To have a state in an Actix service, a struct must be declared, and any data that should be part of the state should be a field of that struct.</p>
<p>At the beginning of the <kbd>main.rs</kbd> file, there is the following code:</p>
<div>
<pre><span>struct AppState {<br/>    db: db_access::DbConnection,<br/>}<br/></span></pre></div>
<p>In the state of our web app, we need only one field, but other fields can be added.</p>
<p>The <kbd>DbConnection</kbd><span> </span>type declared in the<span> </span><kbd>db_access</kbd><span> </span>module represents the state of our web app. <span>In the</span> <kbd>main</kbd> <span>function, just before creating the server, there is the following statement that instantiates the <kbd>AppState</kbd>, and then properly encapsulates it:</span></p>
<pre>let db_conn = web::Data::new(Mutex::new(AppState {<br/>    db: db_access::DbConnection::new(),<br/>}));</pre>
<p><span>The state is shared by all the requests, and the Actix web framework uses several threads to handle the requests, and so the state must be thread-safe</span><span>. The typical way of declaring a thread-safe object in Rust is to encapsulate it in a <kbd>Mutex</kbd> object. This object is then encapsulated in a <kbd>Data</kbd> object.</span></p>
<p>To ensure that such a state is passed to any handler, the following line must be added before calling the <kbd>service</kbd> functions:</p>
<pre>.register_data(db_conn.clone())</pre>
<p>Here, the <kbd>db_conn</kbd> object is cloned (cheaply, as it is a smart pointer), and it is registered into the app.</p>
<p><span>The effect of this registration is that it is now possible to add another type of argument to the request handlers (both synchronous and asynchronous), as follows</span><span>:</span></p>
<pre>state: web::Data&lt;Mutex&lt;AppState&gt;&gt;</pre>
<p>Such an argument can be used in statements like this:</p>
<pre>let db_conn = &amp;mut state.lock().unwrap().db</pre>
<p>Here, the state is locked to prevent concurrent access by other requests, and its <kbd>db</kbd> field is accessed.</p>
<h2 id="uuid-ed66d1f7-53ee-4323-9038-39bb709d2542">The API of this service</h2>
<p>The rest of the code in this app is not particularly surprising. The API is clear from the names used in the <kbd>main</kbd> function, as illustrated in the following code block:</p>
<pre>.service(<br/>    web::resource("/persons/ids")<br/>        .route(web::get().to(get_all_persons_ids)))<br/>.service(<br/>    web::resource("/person/name_by_id/{id}")<br/>        .route(web::get().to(get_person_name_by_id)),<br/>)<br/>.service(<br/>    web::resource("/persons")<br/>        .route(web::get().to(get_persons)))<br/>.service(<br/>    web::resource("/person/{name}")<br/>        .route(web::post().to(insert_person)))<br/>.default_service(<br/>    web::route().to(invalid_resource))</pre>
<p><span>Notice that the first three patterns use the <kbd>GET</kbd> method, and so they</span> <em>query</em> <span>the database. The last one uses the <kbd>POST</kbd> method, and so it inserts new records into the database.</span></p>
<p>Notice also the following <span>lexical conventions.</span></p>
<p>The path of the URI for the first and third <span>patterns</span> begins with the plural word <kbd>persons</kbd>, which means that zero, one, or several items will be managed by this request and that any such item represents a person. Instead, the <span>path of the URI for the second and fourth patterns begins with the singular word <kbd>person</kbd>, and this means that no more than one item will be managed by this request. </span></p>
<p>The first pattern ends with the plural word <kbd>ids</kbd>, and so several items regarding the <kbd>id</kbd> will be handled. It has no condition, and so all the IDs are requested. The second pattern contains the word <kbd>name_by_id</kbd>, followed by an <kbd>id</kbd> parameter, and so it is a request of the <kbd>name</kbd> database column for all the records for which the <kbd>id</kbd> column has the value specified.</p>
<p>Even in the case of any doubt, the name of the handling functions or comments should make <span>the behavior of the service</span> clear, without having to read the code of the handlers. When looking at the implementation of the handlers, notice that they either return nothing at all or simple text.</p>
<h2 id="uuid-ad939357-d0e4-4028-bb91-0c235829e405">Testing the service</h2>
<p>Let's test the service with some curl operations.</p>
<p>First of all, we should populate the database that is initially empty. Remember that, being only in memory, it is empty any time you start the service.</p>
<p>After starting the program, type the following commands:</p>
<pre><strong>curl -X POST http://localhost:8080/person/John</strong><br/><strong>curl -X POST http://localhost:8080/person/Jonathan</strong><br/><strong>curl -X POST http://localhost:8080/person/Mary%20Jane</strong></pre>
<p>After the first command, a number <kbd>1</kbd> should be printed to the console. After the second command, <kbd>2</kbd> should be printed, and after the third command, <kbd>3</kbd> should be printed. They are the IDs of the inserted names of people.</p>
<p>Now, type the following command:</p>
<pre><strong>curl -X GET http://localhost:8080/persons/ids</strong></pre>
<p>It should print the following: <kbd>1, 2, 3</kbd>. This is the set of all the IDs in the database.</p>
<p>Now, type the following command:</p>
<pre><strong>curl -X GET http://localhost:8080/person/name_by_id/3</strong></pre>
<p>It should print the following: <kbd>Mary Jane</kbd>. This is the name of the unique person for which the <kbd>id</kbd> is equal to <kbd>3</kbd>. Notice that the input sequence <kbd>%20</kbd> has been decoded into a blank.</p>
<p>Now, type the following command:</p>
<pre><strong>curl -X GET http://localhost:8080/persons?partial_name=an</strong></pre>
<p><span>It should print the following: </span><kbd>2: Jonathan; 3: Mary Jane</kbd>. This is the set of all the people for which the <kbd>name</kbd> column contains the <kbd>an</kbd> substring.</p>
<h2 id="uuid-b42d7cd2-69c5-4d1d-870a-4621a0e04da4">Implementing the database</h2>
<p><span>The whole database implementation </span><span>is kept in the <kbd>db_access.rs</kbd> source file. </span></p>
<p>The implementation of the database is quite simple. It is a <kbd>DbConnection</kbd> type, containing <kbd>Vec&lt;Person&gt;</kbd>, where<span> </span><kbd>Person</kbd><span> </span>is a struct of two fields—<kbd>id</kbd><span> </span>and<span> </span><kbd>name</kbd>.</p>
<p>The methods of <kbd>DbConnection</kbd> are described as follows:</p>
<ul>
<li><kbd>new</kbd>: This creates a new database.</li>
<li><kbd>get_all_persons_ids(&amp;self) -&gt; impl Iterator&lt;Item = u32&gt; + '_</kbd>: This returns an iterator that provides all the IDs contained in the database. The lifetime of such an iterator must be no more than that of the database itself.</li>
<li><kbd>get_person_name_by_id(&amp;self, id: u32) -&gt; Option&lt;String&gt;</kbd>: This returns the name of the unique person having the specified ID if there is one, or zero if there isn't one.</li>
<li><kbd>get_persons_id_and_name_by_partial_name&lt;'a&gt;(&amp;'a self, subname: &amp;'a str) -&gt; impl Iterator&lt;Item = (u32, String)&gt; + 'a</kbd>: This returns an iterator that provides the ID and the name of all the people whose name contains the specified string. <span>The lifetime of such an iterator </span>must be no more than that of the database itself, and also no more than that of the specified string.</li>
<li><kbd>insert_person(&amp;mut self, name: &amp;str) -&gt; u32</kbd>: This adds a record to the database, containing a generated ID and the specified <kbd>name</kbd>. This returns the generated ID.</li>
</ul>
<h2 id="uuid-b4ca7d19-d788-4a7e-993f-5e740880117e">Handling queries</h2>
<p>The request handlers, contained in the <kbd>main.rs</kbd> file, get arguments of several types, as follows:</p>
<ul>
<li><kbd>web::Data&lt;Mutex&lt;AppState&gt;&gt;</kbd>: As described previously, this is used to access the shared app state.</li>
<li><kbd>Path&lt;(String,)&gt;</kbd>: As described in the previous sections, this is used to access the path of the request.</li>
<li><kbd>HttpRequest</kbd>: As described in the previous sections, this is used to access general request information.</li>
</ul>
<div class="packt_tip">But also, the request handlers get the <kbd>web::Query&lt;Filter&gt;</kbd> argument to access the optional arguments of the request.</div>
<p>The <kbd>get_persons</kbd> handler has a query argument—it is a generic argument, whose parameter is the <kbd>Filter</kbd> type. Such a type is defined as follows:</p>
<pre>#[derive(Deserialize)]<br/>pub struct Filter {<br/>    partial_name: Option&lt;String&gt;,<br/>}</pre>
<p>This definition allows requests such as <kbd>http://localhost:8080/persons?partial_name=an</kbd>. In this request, the path is just <kbd>/persons</kbd>, while <kbd>?partial_name=an</kbd> <span>is the so-called query. In this case, it contains just one argument whose key is <kbd>partial_name</kbd>, and whose value is <kbd>an</kbd>. It is a string and it is optional. This is exactly what is described by the <kbd>Filter</kbd> struct.</span></p>
<p>In addition, such a type is deserializable, as such an object must be read by the request through serialization.</p>
<p>The <kbd>get_persons</kbd> function accesses the query through the following expression:</p>
<pre>&amp;query.partial_name.clone().unwrap_or_else(|| "".to_string()),</pre>
<p>The <kbd>partial_name</kbd> field is cloned to get a string. If it is nonexistent, it is taken as an empty string.</p>
<h1 id="uuid-84eeda37-634b-4f9f-86a1-9543a6005edd">Returning JSON data</h1>
<p>The previous section returned data in plain text. This is<span> unusual in a web service and </span>rarely satisfactory. Usually, web services return data in JSON, XML, or another structured format. The <kbd>json_db</kbd> project is identical to the <kbd>memory_db</kbd> project, except for its returning data in the JSON format.</p>
<p>First of all, let's see what happens when the same curl commands from the previous section are executed on it, as follows:</p>
<ul>
<li>The insertions have the same behavior because they just printed a number.</li>
<li>The first query should print the following: <kbd>[1,2,3]</kbd><span>. The three numbers are in an array, and so they are enclosed in brackets.</span></li>
<li>The second query should print the following: <kbd>"Mary Jane"</kbd><span>. The name is a string, and so it is enclosed in quotation marks.</span></li>
<li>The third query should print the following: <kbd>[[2,"Jonathan"],[3,"Mary Jane"]]</kbd><span>. </span><span>The sequence of persons is an array of two records, and each of them is an array of two values, which are a number and a string.</span></li>
</ul>
<p>Now, let's see the differences in the code of this project with respect to the previous one.</p>
<p>In the <kbd>Cargo.toml</kbd> file, one dependency has been added, as follows:</p>
<pre>serde_json = "1.0"</pre>
<p>This is needed to serialize the data in JSON format.</p>
<p>In the <kbd>main.rs</kbd> file, the <kbd>get_all_persons_ids</kbd><span> function (instead of returning simply a string) has the following code:</span></p>
<pre>HttpResponse::Ok()<br/>    .content_type("application/json")<br/>    .body(<br/>        json!(db_conn.get_all_persons_ids().collect::&lt;Vec&lt;_&gt;&gt;())<br/>        .to_string())</pre>
<p>First, a response with a status code <kbd>Ok</kbd> is created; then, its content type is set to <kbd>application/json</kbd>, to let the client know how to interpret the data it will receive; and lastly, its body is set, using the <kbd>json</kbd> macro taken from the <kbd>serde_json</kbd> crate. This macro takes an expression—in this case, with type, <kbd>Vec&lt;Person&gt;</kbd>—and returns a <kbd>serde_json::Value</kbd> value. Now, we need a string, and so <kbd>to_string()</kbd> is called. Notice that the <kbd>json!</kbd> macro requires its argument to implement the <kbd>Serialize</kbd> trait or to be convertible into a string.</p>
<p>The <kbd>get_person_name_by_id</kbd><span>, </span><kbd>get_persons</kbd><span>, and</span> <kbd>insert_person</kbd> <span>functions have similar changes. The</span> <kbd>main</kbd> <span>function has no changes. </span>The <kbd>db_access.rs</kbd> files are identical<span>.</span></p>
<h1 id="uuid-0ca25b8c-ed86-48c9-bd8b-e0765970a70f">Summary</h1>
<p>We have learned about a few features of the Actix web framework. It is a really complex framework that covers most needs of the backend web developer, and it is still in active development.</p>
<p>Particularly, i<span>n the</span> <kbd>file_transfer_stub</kbd> <span>project, we learned how to create an API of a RESTful service. </span><span>In the</span> <kbd>file_transfer</kbd> <span>project</span>, we discussed how to implement the operations of our web service. <span>In the</span> <kbd>memory_db</kbd><span> project, we went through how to manage an inner state, in particular, one containing a database connection. </span><span>In the </span><kbd>json_db</kbd><span> project, we have seen how to send a response in JSON format.</span></p>
<p>In the next chapter, we will be learning how to create a full server-side web application.</p>
<h1 id="uuid-6b1dec9c-0e52-4254-b5b6-2aac566ba56b">Questions</h1>
<ol>
<li class="mce-root">According to the REST principles, what are the meanings of the <kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, and <kbd>DELETE</kbd> HTTP methods?</li>
<li>Which command-line tool can be used to test a web service?</li>
<li>How can a request handler retrieve the value of <span>URI </span>parameters?</li>
<li>How can the content type of an HTTP response<span> be specified</span>?</li>
<li>How <span>can </span>a unique file name be generated?</li>
<li>Why do services that have a stateless API need to manage a state?</li>
<li>Why must the state of a service be encapsulated in a <kbd>Data</kbd> and a <kbd>Mutex</kbd> object?</li>
<li>Why may asynchronous processing be useful in a web service?</li>
<li>What is the purpose of the<span> </span><kbd>and_then</kbd><span><span> </span>function of futures?</span></li>
<li>Which crates are useful to compose an HTTP response in JSON format?</li>
</ol>
<h1 id="uuid-10232751-a61e-44e7-8521-40d31ed2c911">Further reading</h1>
<p>To learn more about the Actix framework, view the official documentation at <a href="https://actix.rs/docs/">https://actix.rs/docs/</a>, and view official examples at <a href="https://github.com/actix/examples/">https://github.com/actix/examples/</a>.</p>


            </article>

            
        </section>
    </body></html>