- en: Introducing and Installing Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is a fairly new addition to the ever-growing number of programming languages
    available to developers. If you've never used Rust, but come from pretty much
    any procedural language (such as C or Pascal) or are used to shell scripting,
    then you should very quickly feel right at home when using Rust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting to grips with Rust is simple enough, and in this chapter we will cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rust with rustup
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the installation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the IDEs available
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation using Cargo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Rust
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most languages, Rust is available for a wide number of platforms. It
    would be impossible to go through installing the compiler on every variant of
    every operating system. Fortunately, there's an official method of installing
    Rust, and even though the details may differ slightly, the process is almost the
    same on all platforms. Therefore, this book will cover installing Rust using rustup
    on Fedora 27.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[https://rustup.rs](https://rustup.rs) always contains up-to-date instructions
    on how to get going on all platforms. On Linux and macOS, it will look something
    like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: On Windows, this text is replaced by a link to `rustup-init.exe`, which is an
    executable that installs and sets up rustup on Windows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Installing rustup on Linux
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the suggested command that is shown at [https://rustup.rs](https://rustup.rs/).
    Run this command in a Terminal. The script suggests some defaults and asks you
    to confirm them. This is roughly what it should look like after completing the
    whole script:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Note that this script attempts to set up rustup for your user by editing your
    `.profile` and `.bash_profile` files. If you are using a custom setup, such as
    another shell, you may need to add the `source $HOME/.cargo/env` command manually.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing this script, you can verify that it worked by logging off and
    on from your Terminal and verifying that the tools are in your path:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: gcc prerequisites
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build any software that links against external libraries, you will need a
    C compiler and development versions of any libraries you may be linking against.
    To ensure that things work properly, install the compiler using the standard method
    for your operating system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In Fedora, this would be done using the `dnf` tool:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are unsure whether you have gcc installed, type the following command
    in a terminal window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If gcc is installed, you''ll see something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Testing your installation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a command-prompt window and type this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If everything was installed correctly, you will see something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Integrated Development Environment
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effectively code Rust, you will need at least some sort of text editor. All
    popular editors are properly supported, so if your favorite is Vim, Emacs, or
    any of the others, you will find a high-quality Rust extension there. The website
    [https://areweideyet.com/](https://areweideyet.com/) should give a current view
    of how things are.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地编写Rust，你至少需要某种文本编辑器。所有流行的编辑器都得到了适当的支持，所以如果你的首选是Vim、Emacs或其他任何一种，你都会在那里找到一个高质量的Rust扩展。网站[https://areweideyet.com/](https://areweideyet.com/)应该会提供当前的情况。
- en: We will cover the lightweight IDE from Microsoft, **Visual Studio Code**, and
    its most current Rust extension, called simply **Rust**. This IDE should work
    fairly well in all the different desktop environments. Installation instructions
    and packages for several platforms are available at Visual Studio Code's main
    site, [https://code.visualstudio.com](https://code.visualstudio.com/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍来自微软的轻量级IDE，**Visual Studio Code**及其最新的Rust扩展，简单地称为**Rust**。这个IDE应该在不同桌面环境中都能很好地工作。安装说明和多个平台的包可在Visual
    Studio Code的主站点[https://code.visualstudio.com](https://code.visualstudio.com/)找到。
- en: 'Open up Visual Studio Code and go to the Command Palette, either by the View
    menu or by the keyboard shortcut *Ctrl* + *Shift* + *P* (which may differ between
    platforms). Type in `install extension` to look for the proper command, and then
    select Install Extensions:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio Code并转到命令面板，可以通过视图菜单或通过键盘快捷键*Ctrl* + *Shift* + *P*（可能在不同的平台上有所不同）。输入`install
    extension`以查找正确的命令，然后选择安装扩展：
- en: '![](img/00010.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: 'After selecting this, type `rust` into the next field to look for the Rust
    extension. At the time of writing, the most recent one is made by **kalitaalexey**:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择此选项后，在下一个字段中输入`rust`以查找Rust扩展。在撰写本文时，最新版本是由**kalitaalexey**制作的：
- en: '![](img/00011.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00011.jpeg)'
- en: You can install Rust right away by pressing Install; alternatively, click on
    the list item itself to show information about the extension first. After installing
    it, reload the editor. The Rust extension is now installed and ready to use!
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过按安装按钮立即安装Rust；或者，点击列表项本身以首先显示有关扩展的信息。安装后，重新加载编辑器。Rust扩展现在已安装并准备好使用！
- en: Your first Rust project
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Rust项目
- en: 'Your first Rust project is not going to be particularly amazing. If anything,
    it''s going to serve four purposes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个Rust项目可能不会特别出色。如果有的话，它将服务于以下四个目的：
- en: Showing the structure of a Rust project
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示Rust项目的结构
- en: Showing how to create a project by hand
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何手动创建项目
- en: Showing how to create a project using the Rust Cargo script
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何使用Rust Cargo脚本创建项目
- en: Compiling and executing the program
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和执行程序
- en: Structure of a Rust project
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust项目的结构
- en: 'A Rust project (irrespective of the platform you are developing on) will have
    the following structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你在哪个平台上开发，Rust项目都将具有以下结构：
- en: '![](img/00012.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00012.jpeg)'
- en: 'The preceding screenshot shows the structure of the simplest Rust project,
    and as such can be replicated using the following commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了最简单的Rust项目的结构，因此可以使用以下命令进行复制：
- en: '| **OS X/Linux** | **Windows (from the command prompt)** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **OS X/Linux** | **Windows（从命令提示符）** |'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The `echo $null >> filename` command creates an empty file without the need
    to start Notepad; save the file and exit.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo $null >> filename`命令可以在不启动记事本的情况下创建一个空文件；保存文件并退出。'
- en: 'The `Cargo.toml` file is the Rust equivalent of a **Makefile**. When the `.toml`
    file is created by hand, it should be edited to contain something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml`文件是Rust的**Makefile**等效物。当手动创建`.toml`文件时，应将其编辑为包含类似以下内容：'
- en: '![](img/00013.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00013.jpeg)'
- en: 'The structure of a Rust project can expand to include documentation as well
    as the build structure, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Rust项目的结构可以扩展，包括文档以及构建结构，如下所示：
- en: '![](img/00014.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00014.jpeg)'
- en: Automating things
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化
- en: While there is nothing wrong with creating a Rust project by hand, Rust does
    come with a very handy utility called **Cargo**. Cargo can be used not only to
    automate the setting up of a project, but also to compile and execute Rust code.
    Cargo can be used to create the parts required for a library instead of an executable,
    and can also generate application documentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动创建Rust项目没有错，但Rust确实附带了一个非常方便的实用工具，称为**Cargo**。Cargo不仅可以自动化项目的设置，还可以编译和执行Rust代码。Cargo可以用来创建库所需的组件，而不是可执行文件，还可以生成应用程序文档。
- en: Creating a binary package using Cargo
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo创建二进制包
- en: As with any other script, Cargo works (by default) on the current working directory.
    (For example, while writing this chapter, my working directory for the example
    code is `~/Developer/Rust/chapter0` on the Mac and Linux boxes, and `J:\Developer\Rust\Chapter0`
    on the Windows 10 machine.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他脚本一样，Cargo 默认在当前工作目录上工作。（例如，在编写本章时，我的示例代码的工作目录在 Mac 和 Linux 系统上为 `~/Developer/Rust/chapter0`，在
    Windows 10 系统上为 `J:\Developer\Rust\Chapter0`。）
- en: 'In its simplest form, Cargo can generate the correct file structure like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，Cargo 可以生成正确的文件结构，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding command tells Cargo to create a new structure called `demo_app_name`,
    and that it is to be a binary. If you remove `-bin`, it creates a structure called,
    which is going to be a library (or more accurately, something other than a binary).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令告诉 Cargo 创建一个名为 `demo_app_name` 的新结构，并且它应该是一个二进制文件。如果您移除 `-bin`，它将创建一个名为的结构，这将是一个库（或者更准确地说，是除了二进制文件之外的东西）。
- en: If you don't wish to use the root (say you want to create a library within your
    binary framework), then instead of `demo_app_name`, you append the structure before
    the name relating to your working directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用根目录（比如说您想在您的二进制框架内创建一个库），那么在 `demo_app_name` 之前，您应该附加与您的工作目录相关的结构。
- en: 'In the small example I gave earlier, if I wanted to create a library within
    my binary structure, I would use the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前给出的简单示例中，如果我想在我的二进制结构中创建一个库，我会使用以下命令：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That will create a structure like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建如下结构：
- en: '![](img/00015.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: The `Cargo.toml` file requires no editing (at this stage), as it contains the
    information we had to enter manually when we created the project by hand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cargo.toml` 文件在此阶段无需编辑，因为它包含了我们在手动创建项目时必须手动输入的信息。'
- en: Cargo has a number of directory separator *translators*. This means that the
    preceding example can be used on OS X, Linux, and Windows without an issue; Cargo
    has converted the `/` to `\` for Windows.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 有多个目录分隔符“翻译器”。这意味着前面的示例可以在 OS X、Linux 和 Windows 上使用而不会出现问题；Cargo 已经将 `/`
    转换为 `\` 以适应 Windows。
- en: Using Cargo to build and run an application
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cargo 构建和运行应用程序
- en: As we are all able to create directory structures, Cargo is then able to build
    and execute our source code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们都能创建目录结构，因此 Cargo 能够构建和执行我们的源代码。
- en: 'If you look at the source code that comes with this chapter, you will find
    a directory called `app_name`. To build this package using Cargo, type the following
    from a Terminal (or command on Windows) window:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看本章附带源代码，您将找到一个名为 `app_name` 的目录。要使用 Cargo 构建此包，请在终端（或 Windows 上的命令）窗口中输入以下内容：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will build the source code; finally you will be informed that the compilation
    has been successful:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建源代码；最后，您将被告知编译已成功完成：
- en: '![](img/00016.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: 'Next, we can use Cargo to execute the binary as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 Cargo 如下执行二进制文件：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If everything has worked, you will see something like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将看到以下内容：
- en: '![](img/00017.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: 'As with any sort of utility, it''s possible to "daisy-chain" the build and
    execution into one line, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何一种工具一样，可以将构建和执行“链式连接”到一行中，如下所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may be wondering why the first operation performed was to move into the
    application structure rather than just type `cargo build`. This is because Cargo
    is looking for the `Cargo.toml` file (remember, this acts as a build script).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么第一个操作是移动到应用程序结构而不是直接输入 `cargo build`。这是因为 Cargo 正在寻找 `Cargo.toml` 文件（记住，这充当构建脚本）。
- en: Cleaning your source tree with Cargo
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cargo 清理源代码树
- en: When the Rust compiler compiles the source files, it generates something known
    as an object file. The object file takes the source file (which we can read and
    understand) and compiles this into a form that can be joined with other libraries
    to create a binary.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Rust 编译器编译源文件时，它会生成一个称为对象文件的东西。对象文件将源文件（我们可以阅读和理解）编译成可以与其他库连接以创建二进制的形式。
- en: This is a good idea, as it cuts down on compilation time; if a source file has
    not been changed, there is no need to recompile the file, as the object file will
    be the same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好主意，因为它可以减少编译时间；如果源文件没有更改，就没有必要重新编译文件，因为对象文件将是相同的。
- en: Sometimes, the object file becomes out of date, or code in another object file
    causes a panic due to conflicts. In this case, it is not uncommon to "clean" the
    build. This removes the object files, and the compiler then has to recompile all
    the source files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，目标文件会过时，或者另一个目标文件中的代码由于冲突导致恐慌。在这种情况下，清理构建是很常见的。这会删除目标文件，然后编译器必须重新编译所有源文件。
- en: Also, it should always be performed prior to creating a release build.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它应该在创建发布构建之前始终执行。
- en: 'The standard Unix `make` program performs this with the `clean` command (`make
    clean`). Cargo performs the clean operation in a way similar to the `make` utility
    in Unix:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Unix `make`程序使用`clean`命令（`make clean`）执行此操作。Cargo以类似于Unix中的`make`实用程序的方式执行清理操作：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A comparison of the directories shows what happens when using the preceding
    Cargo command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 比较目录显示了使用前面的Cargo命令会发生什么：
- en: '![](img/00018.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: The entire target directory structure has simply been removed (the preceding
    screenshot was from a Mac, hence the `dSYM` and `plist` files. These do not exist
    on Linux and Windows).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 整个目标目录结构已经被简单地删除（前面的截图来自Mac，因此有`dSYM`和`plist`文件。这些在Linux和Windows上不存在）。
- en: Creating documentation using Cargo
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo创建文档
- en: 'As with other languages, Rust is able to create documentation based on meta
    tags with the source files. Take the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言一样，Rust能够根据源文件的元标签创建文档。以下是一个示例：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: /// print_multiply(3, 5);
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: /// print_multiply(3, 5);
- en: ///
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: /// [PRE12]
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE12]
- en: The comments preceded by `///` will be converted into documentation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以`///`开头注释将被转换为文档。
- en: 'The documentation can be created in one of two ways: via Cargo or by using
    the **rustdoc** program.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以通过两种方式之一创建：通过Cargo或使用**rustdoc**程序。
- en: rustdoc versus Cargo
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rustdoc与Cargo
- en: As with the other operations provided by Cargo, when documentation is created,
    it acts as a wrapper for rustdoc. The only difference is that with rustdoc you
    have to specify the directory that the source file sits in. Cargo acts dumb in
    this case, and creates the documentation for all source files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与Cargo提供的其他操作一样，当创建文档时，它充当rustdoc的包装器。唯一的区别是，使用rustdoc时，你必须指定源文件所在的目录。在这种情况下，Cargo表现得比较笨拙，并为所有源文件创建文档。
- en: 'In its simplest form, the rustdoc command is used as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，rustdoc命令的使用方法如下：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Cargo does have the advantage of creating the doc structure within the `root`
    folder, whereas rustdoc creates the structure within the target (which is removed
    with `cargo clean`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo确实有优势，可以在`root`文件夹内创建文档结构，而rustdoc则在目标文件夹内创建结构（使用`cargo clean`删除）。
- en: Using Cargo to help with your unit testing
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo帮助进行单元测试
- en: Hopefully, unit testing is not something you will be unfamiliar with. A unit
    test is a test that operates on a specific function or method rather than an entire
    class or namespace. It ensures that the function operates correctly on the data
    it is presented with.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 希望单元测试不是你陌生的东西。单元测试是一种针对特定函数或方法而不是整个类或命名空间的测试。它确保函数在其呈现的数据上正确运行。
- en: 'Unit tests within Rust are very simple to create (two examples are given in
    the `assert_unittest` and `unittest` directories). The following has been taken
    from the `unittest` example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中的单元测试非常简单创建（在`assert_unittest`和`unittest`目录中给出了两个示例）。以下是从`unittest`示例中摘录的：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When this is built and executed, you may be surprised by the following result:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建并执行时，你可能会对以下结果感到惊讶：
- en: '![](img/00019.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: The reason why this unit test has passed despite *2 x 3* not being *5* is because
    the unit test is not testing the result of the operation, but that the operation
    itself is working. It is very important that this distinction is understood from
    an early stage to prevent confusion later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管乘法`2 x 3`不等于`5`，但这个单元测试仍然通过的原因是单元测试不是测试操作的结果，而是测试操作本身是否工作。从早期阶段理解这种区别非常重要，以防止以后产生混淆。
- en: 'We have hit a limitation of unit testing: if we are not testing the data but
    the operation, how can we know that the result itself is correct?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了单元测试的限制：如果我们不是测试数据而是测试操作，我们如何知道操作的结果本身是正确的？
- en: Assert yourself!
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坚定自我！
- en: 'Unit testing provides the developer with a number of methods called assertion
    methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试为开发者提供了一系列称为断言方法的方法：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Is there anything Cargo can't do?
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo能做什么？
- en: 'For a Rust developer, Cargo is an amazing utility. In addition to these common
    facilities, it also has other commands, which are listed in the table that follows.
    All commands follow this form:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Rust 开发者来说，Cargo 是一个惊人的实用工具。除了这些常用功能外，它还有其他命令，如下表所示。所有命令都遵循以下形式：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| **Command** | **What it does** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **执行的操作** |'
- en: '|'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| This command fetches the dependencies of a package from the network. If a
    lockfile is available, this command will ensure that all of the Git dependencies
    and/or registry dependencies are downloaded and locally available. The network
    is never called after a `cargo fetch` unless the lockfile changes.If the lockfile
    is not available, then this is the equivalent of `cargo generate-lockfile`. A
    lockfile is generated and all the dependencies are also updated. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 此命令从网络中获取软件包的依赖项。如果可用锁文件，此命令将确保所有 Git 依赖项和/或注册表依赖项都已下载并本地可用。在锁文件更改之前，`cargo
    fetch` 之后永远不会调用网络。如果锁文件不可用，则此操作相当于 `cargo generate-lockfile`。将生成锁文件，并更新所有依赖项。
    |'
- en: '|'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| This command generates the lockfile for a project. The lockfile is typically
    generated when `cargo build` is issued (you will see it as `Cargo.lockfile` in
    the directory structure). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 此命令为项目生成锁文件。锁文件通常在发出 `cargo build` 命令时生成（你将在目录结构中看到它作为 `Cargo.lockfile`）。
    |'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| This command checks out a Git repository. You will need to use it in the
    following form:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '| 此命令检出 Git 仓库。你需要使用以下形式：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| This command locates a package. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 此命令定位软件包。 |'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| This command saves an API token from the registry locally. The call is in
    the following form:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| 此命令将注册表中的 API 令牌保存到本地。调用形式如下：'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| This command manages the owners of a crate on the registry. This allows the
    ownership of a crate (a crate is a Rust library) to be altered (`--add LOGIN`
    or `-remove LOGIN`) as well as adding tokens to the crate.This command will modify
    the owners for a package on the specified registry (or the default). Note that
    the owners of a package can upload new versions, yank old versions, and also modify
    the set of owners, so be cautious! |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 此命令管理注册表上软件包的所有者。这允许更改软件包的所有权（软件包是一个 Rust 库），以及向软件包添加令牌。此命令将修改指定注册表（或默认注册表）上软件包的所有者。请注意，软件包的所有者可以上传新版本、撤回旧版本，还可以修改所有者集合，因此请谨慎操作！
    |'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| This command assembles the local package into a distributable tarball. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 此命令将本地软件包组装成可分发的 tarball。 |'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| This command prints a fully qualified package specification. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 此命令打印一个完全限定的软件包规范。 |'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| This command uploads a package to the registry. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 此命令将软件包上传到注册表。 |'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| This command reads the manifest file (`.toml`). |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 此命令读取清单文件（`.toml`）。 |'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| This command compiles the complete package.The specified target for the current
    package will be compiled along with all of its dependencies. The specified options
    will all be passed to the final compiler invocation, not any of the dependencies.
    Note that the compiler will still unconditionally receive arguments such as `-L`,
    `--extern`, and `--crate-type`, and the specified options will simply be added
    to the compiler invocation.This command requires that only one target is being
    compiled. If more than one target is available for the current package, the filters
    `--lib`, `--bin`, and so on—must be used to select which target is compiled. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 此命令编译完整软件包。当前软件包指定的目标将与所有依赖项一起编译。指定的选项将全部传递给最终的编译器调用，而不是任何依赖项。请注意，编译器仍将无条件接收如
    `-L`、`--extern` 和 `--crate-type` 等参数，而指定的选项将简单地添加到编译器调用中。此命令要求只编译一个目标。如果当前软件包有多个目标可用，则必须使用
    `--lib`、`--bin` 等过滤器来选择要编译的目标。 |'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| This command searches for packages at [https://crates.io/](https://crates.io/).
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 此命令在 [https://crates.io/](https://crates.io/) 搜索软件包。 |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| This command updates dependencies as recorded in the local lockfile.Typical
    options are:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '| 此命令根据本地锁文件中记录的依赖项更新依赖项。典型选项包括：'
- en: '`--package SPEC` (package to update)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--package SPEC` (要更新的软件包)'
- en: '`--aggressive` (forcibly update all dependencies of `<name>` as well)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--aggressive` (强制更新 `<name>` 的所有依赖项)'
- en: '`--precise PRECISE` (update a single dependency to exactly `PRECISE`)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--precise PRECISE` (更新单个依赖项到精确的 `PRECISE`)'
- en: This command requires that a `Cargo.lock` file already exists as generated by
    `cargo build` or related commands.If a package spec name (`SPEC`) is given, then
    a conservative update of the lockfile will be performed. This means that only
    the dependency specified by `SPEC` will be updated. Its transitive dependencies
    will be updated only if `SPEC` cannot be updated without updating the dependencies.
    All other dependencies will remain locked at their currently recorded versions.If
    `PRECISE` is specified, then `--aggressive` must not also be specified. The argument
    `PRECISE` is a string representing a precise revision that the package being updated
    should be updated to. For example, if the package comes from a Git repository,
    then `PRECISE` would be the exact revision that the repository should be updated
    to.If `SPEC` is not given, then all the dependencies will be re-resolved and updated.
    |
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令要求已存在一个 `Cargo.lock` 文件，该文件由 `cargo build` 或相关命令生成。如果给出了包规范名称（`SPEC`），则将执行保守的锁文件更新。这意味着只有由
    `SPEC` 指定的依赖项将被更新。如果必须更新依赖项才能更新 `SPEC`，则其传递依赖项也将被更新。所有其他依赖项将保持锁定在其当前记录的版本。如果指定了
    `PRECISE`，则不得同时指定 `--aggressive`。`PRECISE` 是一个字符串，表示正在更新的包应该更新到的精确修订版本。例如，如果包来自
    Git 仓库，则 `PRECISE` 将是仓库应该更新到的确切修订版本。如果没有给出 `SPEC`，则将重新解析所有依赖项并更新。 |
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| This command ensures that the project is correctly created. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 此命令确保项目被正确创建。 |'
- en: '|'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| This command shows the version of Cargo. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 此命令显示 Cargo 的版本。 |'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This command removes a pushed crate from the index.The `yank` command removes
    a previously pushed crate version from the server''s index. This command does
    not delete any data, and the crate will still be available for download via the
    registry''s download link.Note that existing crates locked to a yanked version
    will still be able to download the yanked version to use it. Cargo will, however,
    not allow any new crates to be locked to any yanked version. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 此命令从索引中移除已推送的 crate。`yank` 命令从服务器的索引中移除之前推送的 crate 版本。此命令不会删除任何数据，crate 仍然可以通过注册表的下载链接进行下载。请注意，已锁定到已移除版本的现有
    crate 仍然可以下载已移除的版本以供使用。然而，Cargo 不会允许任何新的 crate 锁定到任何已移除的版本。 |'
- en: As you can now appreciate, the Cargo utility script is extremely powerful and
    flexible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在所欣赏的，Cargo 工具脚本非常强大且灵活。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have a fully working installation of Rust, and are ready for the get-go.
    We've explained how to set up a project, both manually and via the Cargo utility,
    and you should already have an appreciation of how useful Cargo is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经安装了一个完整的 Rust 环境，并准备开始使用。我们已经解释了如何手动和通过 Cargo 工具设置项目，你应该已经对 Cargo 的有用性有了认识。
- en: 'In the next chapter, we''ll be looking at the foundation of any language: **variables**.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨任何语言的基础：**变量**。
