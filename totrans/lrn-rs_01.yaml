- en: Introducing and Installing Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is a fairly new addition to the ever-growing number of programming languages
    available to developers. If you've never used Rust, but come from pretty much
    any procedural language (such as C or Pascal) or are used to shell scripting,
    then you should very quickly feel right at home when using Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting to grips with Rust is simple enough, and in this chapter we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rust with rustup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the IDEs available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation using Cargo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most languages, Rust is available for a wide number of platforms. It
    would be impossible to go through installing the compiler on every variant of
    every operating system. Fortunately, there's an official method of installing
    Rust, and even though the details may differ slightly, the process is almost the
    same on all platforms. Therefore, this book will cover installing Rust using rustup
    on Fedora 27.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://rustup.rs](https://rustup.rs) always contains up-to-date instructions
    on how to get going on all platforms. On Linux and macOS, it will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On Windows, this text is replaced by a link to `rustup-init.exe`, which is an
    executable that installs and sets up rustup on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Installing rustup on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the suggested command that is shown at [https://rustup.rs](https://rustup.rs/).
    Run this command in a Terminal. The script suggests some defaults and asks you
    to confirm them. This is roughly what it should look like after completing the
    whole script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that this script attempts to set up rustup for your user by editing your
    `.profile` and `.bash_profile` files. If you are using a custom setup, such as
    another shell, you may need to add the `source $HOME/.cargo/env` command manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing this script, you can verify that it worked by logging off and
    on from your Terminal and verifying that the tools are in your path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: gcc prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build any software that links against external libraries, you will need a
    C compiler and development versions of any libraries you may be linking against.
    To ensure that things work properly, install the compiler using the standard method
    for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Fedora, this would be done using the `dnf` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are unsure whether you have gcc installed, type the following command
    in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If gcc is installed, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing your installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a command-prompt window and type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything was installed correctly, you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Integrated Development Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To effectively code Rust, you will need at least some sort of text editor. All
    popular editors are properly supported, so if your favorite is Vim, Emacs, or
    any of the others, you will find a high-quality Rust extension there. The website
    [https://areweideyet.com/](https://areweideyet.com/) should give a current view
    of how things are.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the lightweight IDE from Microsoft, **Visual Studio Code**, and
    its most current Rust extension, called simply **Rust**. This IDE should work
    fairly well in all the different desktop environments. Installation instructions
    and packages for several platforms are available at Visual Studio Code's main
    site, [https://code.visualstudio.com](https://code.visualstudio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up Visual Studio Code and go to the Command Palette, either by the View
    menu or by the keyboard shortcut *Ctrl* + *Shift* + *P* (which may differ between
    platforms). Type in `install extension` to look for the proper command, and then
    select Install Extensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After selecting this, type `rust` into the next field to look for the Rust
    extension. At the time of writing, the most recent one is made by **kalitaalexey**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can install Rust right away by pressing Install; alternatively, click on
    the list item itself to show information about the extension first. After installing
    it, reload the editor. The Rust extension is now installed and ready to use!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your first Rust project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your first Rust project is not going to be particularly amazing. If anything,
    it''s going to serve four purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing the structure of a Rust project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing how to create a project by hand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing how to create a project using the Rust Cargo script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and executing the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure of a Rust project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Rust project (irrespective of the platform you are developing on) will have
    the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the structure of the simplest Rust project,
    and as such can be replicated using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **OS X/Linux** | **Windows (from the command prompt)** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The `echo $null >> filename` command creates an empty file without the need
    to start Notepad; save the file and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Cargo.toml` file is the Rust equivalent of a **Makefile**. When the `.toml`
    file is created by hand, it should be edited to contain something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The structure of a Rust project can expand to include documentation as well
    as the build structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Automating things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there is nothing wrong with creating a Rust project by hand, Rust does
    come with a very handy utility called **Cargo**. Cargo can be used not only to
    automate the setting up of a project, but also to compile and execute Rust code.
    Cargo can be used to create the parts required for a library instead of an executable,
    and can also generate application documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a binary package using Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any other script, Cargo works (by default) on the current working directory.
    (For example, while writing this chapter, my working directory for the example
    code is `~/Developer/Rust/chapter0` on the Mac and Linux boxes, and `J:\Developer\Rust\Chapter0`
    on the Windows 10 machine.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, Cargo can generate the correct file structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command tells Cargo to create a new structure called `demo_app_name`,
    and that it is to be a binary. If you remove `-bin`, it creates a structure called,
    which is going to be a library (or more accurately, something other than a binary).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't wish to use the root (say you want to create a library within your
    binary framework), then instead of `demo_app_name`, you append the structure before
    the name relating to your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the small example I gave earlier, if I wanted to create a library within
    my binary structure, I would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That will create a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `Cargo.toml` file requires no editing (at this stage), as it contains the
    information we had to enter manually when we created the project by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo has a number of directory separator *translators*. This means that the
    preceding example can be used on OS X, Linux, and Windows without an issue; Cargo
    has converted the `/` to `\` for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cargo to build and run an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are all able to create directory structures, Cargo is then able to build
    and execute our source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the source code that comes with this chapter, you will find
    a directory called `app_name`. To build this package using Cargo, type the following
    from a Terminal (or command on Windows) window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will build the source code; finally you will be informed that the compilation
    has been successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can use Cargo to execute the binary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything has worked, you will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As with any sort of utility, it''s possible to "daisy-chain" the build and
    execution into one line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering why the first operation performed was to move into the
    application structure rather than just type `cargo build`. This is because Cargo
    is looking for the `Cargo.toml` file (remember, this acts as a build script).
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning your source tree with Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the Rust compiler compiles the source files, it generates something known
    as an object file. The object file takes the source file (which we can read and
    understand) and compiles this into a form that can be joined with other libraries
    to create a binary.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good idea, as it cuts down on compilation time; if a source file has
    not been changed, there is no need to recompile the file, as the object file will
    be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the object file becomes out of date, or code in another object file
    causes a panic due to conflicts. In this case, it is not uncommon to "clean" the
    build. This removes the object files, and the compiler then has to recompile all
    the source files.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it should always be performed prior to creating a release build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard Unix `make` program performs this with the `clean` command (`make
    clean`). Cargo performs the clean operation in a way similar to the `make` utility
    in Unix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A comparison of the directories shows what happens when using the preceding
    Cargo command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The entire target directory structure has simply been removed (the preceding
    screenshot was from a Mac, hence the `dSYM` and `plist` files. These do not exist
    on Linux and Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Creating documentation using Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with other languages, Rust is able to create documentation based on meta
    tags with the source files. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: /// print_multiply(3, 5);
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: /// [PRE12]
  prefs: []
  type: TYPE_NORMAL
- en: The comments preceded by `///` will be converted into documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation can be created in one of two ways: via Cargo or by using
    the **rustdoc** program.'
  prefs: []
  type: TYPE_NORMAL
- en: rustdoc versus Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the other operations provided by Cargo, when documentation is created,
    it acts as a wrapper for rustdoc. The only difference is that with rustdoc you
    have to specify the directory that the source file sits in. Cargo acts dumb in
    this case, and creates the documentation for all source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, the rustdoc command is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Cargo does have the advantage of creating the doc structure within the `root`
    folder, whereas rustdoc creates the structure within the target (which is removed
    with `cargo clean`).
  prefs: []
  type: TYPE_NORMAL
- en: Using Cargo to help with your unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, unit testing is not something you will be unfamiliar with. A unit
    test is a test that operates on a specific function or method rather than an entire
    class or namespace. It ensures that the function operates correctly on the data
    it is presented with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests within Rust are very simple to create (two examples are given in
    the `assert_unittest` and `unittest` directories). The following has been taken
    from the `unittest` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is built and executed, you may be surprised by the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The reason why this unit test has passed despite *2 x 3* not being *5* is because
    the unit test is not testing the result of the operation, but that the operation
    itself is working. It is very important that this distinction is understood from
    an early stage to prevent confusion later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have hit a limitation of unit testing: if we are not testing the data but
    the operation, how can we know that the result itself is correct?'
  prefs: []
  type: TYPE_NORMAL
- en: Assert yourself!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing provides the developer with a number of methods called assertion
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Is there anything Cargo can't do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a Rust developer, Cargo is an amazing utility. In addition to these common
    facilities, it also has other commands, which are listed in the table that follows.
    All commands follow this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| **Command** | **What it does** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| This command fetches the dependencies of a package from the network. If a
    lockfile is available, this command will ensure that all of the Git dependencies
    and/or registry dependencies are downloaded and locally available. The network
    is never called after a `cargo fetch` unless the lockfile changes.If the lockfile
    is not available, then this is the equivalent of `cargo generate-lockfile`. A
    lockfile is generated and all the dependencies are also updated. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| This command generates the lockfile for a project. The lockfile is typically
    generated when `cargo build` is issued (you will see it as `Cargo.lockfile` in
    the directory structure). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This command checks out a Git repository. You will need to use it in the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| This command locates a package. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| This command saves an API token from the registry locally. The call is in
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| This command manages the owners of a crate on the registry. This allows the
    ownership of a crate (a crate is a Rust library) to be altered (`--add LOGIN`
    or `-remove LOGIN`) as well as adding tokens to the crate.This command will modify
    the owners for a package on the specified registry (or the default). Note that
    the owners of a package can upload new versions, yank old versions, and also modify
    the set of owners, so be cautious! |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| This command assembles the local package into a distributable tarball. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| This command prints a fully qualified package specification. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| This command uploads a package to the registry. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| This command reads the manifest file (`.toml`). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| This command compiles the complete package.The specified target for the current
    package will be compiled along with all of its dependencies. The specified options
    will all be passed to the final compiler invocation, not any of the dependencies.
    Note that the compiler will still unconditionally receive arguments such as `-L`,
    `--extern`, and `--crate-type`, and the specified options will simply be added
    to the compiler invocation.This command requires that only one target is being
    compiled. If more than one target is available for the current package, the filters
    `--lib`, `--bin`, and so on—must be used to select which target is compiled. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| This command searches for packages at [https://crates.io/](https://crates.io/).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| This command updates dependencies as recorded in the local lockfile.Typical
    options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--package SPEC` (package to update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--aggressive` (forcibly update all dependencies of `<name>` as well)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--precise PRECISE` (update a single dependency to exactly `PRECISE`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command requires that a `Cargo.lock` file already exists as generated by
    `cargo build` or related commands.If a package spec name (`SPEC`) is given, then
    a conservative update of the lockfile will be performed. This means that only
    the dependency specified by `SPEC` will be updated. Its transitive dependencies
    will be updated only if `SPEC` cannot be updated without updating the dependencies.
    All other dependencies will remain locked at their currently recorded versions.If
    `PRECISE` is specified, then `--aggressive` must not also be specified. The argument
    `PRECISE` is a string representing a precise revision that the package being updated
    should be updated to. For example, if the package comes from a Git repository,
    then `PRECISE` would be the exact revision that the repository should be updated
    to.If `SPEC` is not given, then all the dependencies will be re-resolved and updated.
    |
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| This command ensures that the project is correctly created. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| This command shows the version of Cargo. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| This command removes a pushed crate from the index.The `yank` command removes
    a previously pushed crate version from the server''s index. This command does
    not delete any data, and the crate will still be available for download via the
    registry''s download link.Note that existing crates locked to a yanked version
    will still be able to download the yanked version to use it. Cargo will, however,
    not allow any new crates to be locked to any yanked version. |'
  prefs: []
  type: TYPE_TB
- en: As you can now appreciate, the Cargo utility script is extremely powerful and
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a fully working installation of Rust, and are ready for the get-go.
    We've explained how to set up a project, both manually and via the Cargo utility,
    and you should already have an appreciation of how useful Cargo is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll be looking at the foundation of any language: **variables**.'
  prefs: []
  type: TYPE_NORMAL
