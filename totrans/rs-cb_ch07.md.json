["```rs\n        //-- #########################\n        //-- Task: Building your first macro in Rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        // This is a simple macro named `say_hello`.\n        macro_rules! Welcome_RustBook {\n          () => (\n          // The macro will expand into the contents of this block.\n          println!(\"Welcome to Rust Cookbook!\");\n          )\n        }\n\n```", "```rs\n        fn main() {\n          // This call will expand into`println!(\"Hello\");`\n          Welcome_RustBook!()\n        }\n\n```", "```rs\nmacro_rules! macro_name { ... }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implement matching\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        macro_rules! Check_Val {\n          (x => $e:expr) => (println!(\"mode X: {}\", $e));\n          (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n        }\n\n```", "```rs\n        fn main() {\n          Check_Val!(y => 3);\n        }\n\n```", "```rs\n( $( $x:expr ),* ) => { ... };\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing common macros in rust\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        fn main() {\n\n          // Creating a vector \n          let v = vec![1, 2, 3, 4, 5];\n          print!(\"Vector :- {:?}\", v);\n\n          // Macros used for testing\n          assert!(true);\n          assert_eq!(5, 3 + 2);\n\n          // assert!(5 < 3);\n          // assert_eq!(5, 3);\n\n          // Gives a message to panic\n          // panic!(\"oh no!\");\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing designator\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        macro_rules! create_function {\n          ($func_name:ident) => (\n            fn $func_name() {\n              // The `stringify!` macro converts an `ident`\n              into a string.\n              println!(\"You called {:?}()\",\n              stringify!($func_name))\n            }\n          )\n        }\n\n```", "```rs\n        create_function!(foo);\n        create_function!(bar);\n\n```", "```rs\n        macro_rules! print_result {\n          ($expression:expr) => (\n          println!(\"{:?} = {:?}\",\n          stringify!($expression),\n          $expression)\n          )\n        }\n\n```", "```rs\n        fn main() {\n          foo();\n          bar();\n\n          print_result!(1u32 + 1);\n\n          // Recall that blocks are expressions too!\n          print_result!({\n          let x = 1u32;\n\n          x * x + 2 * x - 1\n          });\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        macro_rules! test {\n\n          ($left:expr; and $right:expr) => (\n          println!(\"{:?} and {:?} is {:?}\",\n          stringify!($left),\n          stringify!($right),\n          $left && $right)\n          );\n\n          ($left:expr; or $right:expr) => (\n          println!(\"{:?} or {:?} is {:?}\",\n          stringify!($left),\n          stringify!($right),\n          $left || $right)\n          );\n        }\n\n```", "```rs\n        fn main() {\n          test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);\n          test!(true; or false);\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing repeat\n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        macro_rules! find_min {\n          // Base case:\n          ($x:expr) => ($x);\n          // `$x` followed by at least one `$y,`\n          ($x:expr, $($y:expr),+) => (\n          // Call `find_min!` on the tail `$y`\n          std::cmp::min($x, find_min!($($y),+))\n          )\n        }\n\n```", "```rs\n        fn main() {\n          println!(\"{}\", find_min!(1u32));\n          println!(\"{}\", find_min!(1u32 + 2 , 2u32));\n          println!(\"{}\", find_min!(5u32, 2u32 * 3, 4u32));\n        }\n\n```", "```rs\n        //-- #########################\n        //-- Task: Implementing \n        //-- Author: Vigneshwer.D\n        //-- Version: 1.0.0\n        //-- Date: 26 March 17\n        //-- #########################\n\n```", "```rs\n        use std::ops::{Add, Mul, Sub};\n\n```", "```rs\n        macro_rules! assert_equal_len {\n          ($a:ident, $b: ident, $func:ident, $op:tt) => (\n          assert!($a.len() == $b.len(),\n          \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n          stringify!($func),\n          ($a.len(),),\n          stringify!($op),\n          ($b.len(),));\n          )\n        }\n\n```", "```rs\n        macro_rules! op {\n          ($func:ident, $bound:ident, $op:tt, $method:ident) => (\n          fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys:\n          &Vec<T>) {\n            assert_equal_len!(xs, ys, $func, $op);\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n            *x = $bound::$method(*x, *y);\n            // *x = x.$method(*y);\n            }\n          }\n          )\n        }\n\n```", "```rs\n        op!(add_assign, Add, +=, add);\n        op!(mul_assign, Mul, *=, mul);\n        op!(sub_assign, Sub, -=, sub);\n\n```", "```rs\n        use std::iter;\n        macro_rules! test {\n          ($func: ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n              for size in 0usize..10 {\n                let mut x: Vec<_> =\n                iter::repeat($x).take(size).collect();\n                let y: Vec<_> = iter::repeat($y).take(size).collect();\n                let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                super::$func(&mut x, &y);\n\n                assert_eq!(x, z);\n                }\n              }\n            }\n          }\n\n          // Test `add_assign`, `mul_assign` and `sub_assign`\n          test!(add_assign, 1u32, 2u32, 3u32);\n          test!(mul_assign, 2u32, 3u32, 6u32);\n          test!(sub_assign, 3u32, 2u32, 1u32);\n        }\n\n```"]