- en: Creating Your Own Rust Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now roughly half-way through the book and, rather than just continuing,
    this chapter has a number of tasks for you to attempt. Having a go at them will
    help reinforce what we have covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: In order to complete these, you will need to create the code as a full project
    using Cargo, as shown in [Chapter 1](part0021.html#K0RQ0-a5175cb437d742a9aed0ea574000ee2d),
    *Introducing and Installing Rust*. If you get stuck, possible solutions are included
    in the source code directory.
  prefs: []
  type: TYPE_NORMAL
- en: Project 1 - let's start with some math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing of data is very important, and knowing how to produce a straight-line
    relationship is often of great importance. You will need to construct a couple
    of functions that will work out something known as a linear regression analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a brief list of requirements for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: Data will come from two vectors and will be floating point numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answers will only be stored in main and displayed from there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two vectors must have the same number of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supplied data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data required for this project is in the `Chapter 6` folder, `Projects/MathsData.txt`.
    The content of the file should be used within the application (copy and paste).
    If the data sets do not have the same number of elements, remove elements from
    the end of the set with the larger number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the math required:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The equation of a straight line**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The equation is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y = mx + c*, where *m* is the gradient and *c* is the intercept on the y axis'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gradient of the regression line**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The equation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '&gt;![](img/00034.jpeg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This may look hairy but it''s quite simple, so long as the following rule is
    remembered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg) is not equal to ![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, what is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg) means that it is the sum of x² while ![](img/00036.jpeg) is
    the sum of x squared. Let''s consider the following code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To save time at this point, it is worth performing the following calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*xy* for each set, followed by ∑*xy* for each'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∑*x*, ∑*y*, ∑*x²*, (∑x)², ![](img/00038.jpeg) (the average of *x*), ;![](img/00039.jpeg) (the
    average of the *y* values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data is needed for the regression gradient and intercepts on the *y* value.
    After that is performed, it is simply a case of plugging in the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ∑y = 5.8907, ∑x = 5, ∑x² = 7.5, (∑x)² = 25, n = 4, ∑xy = 8.8528
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Moreover, none of the math from here on in is any harder than that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting the intercepts**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already have the formula for the intercept on the *y* axis (*c*) by the
    equation, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Again, using the same data as earlier, the numbers slot in and give an answer
    of -0.0167.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is the intercept on y; however, we want the intercept on the x axis
    as well. To do this, we can say that we want to know the value of x when y = 0\.
    The equation of the straight line is *y = mx + c*; therefore, to get *x* by itself,
    the equation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Simple!
  prefs: []
  type: TYPE_NORMAL
- en: '**Deviation must be known**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two more factors to be considered with the regression analysis-the
    standard deviation (better known as the error in the line) and the *r²* value
    (the correlation coefficient; in other words, how good a straight line the line
    really is).
  prefs: []
  type: TYPE_NORMAL
- en: The two equations are a tad more difficult than before, but not by much.
  prefs: []
  type: TYPE_NORMAL
- en: First off, some more calculations will cover the standard deviation and the
    r² calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the standard deviation, we will need to know *(y[expt] - y[calc])²*. This
    can be done in line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: y[expt] is the value from your experiment, y[calc] can be read as mx + c (all
    three are known). Therefore, if we just plug in the numbers then square the result,
    we end up with (y[expt] - y[calc])². These numbers are then added together to
    give ∑(y[expt] - y[calc])².
  prefs: []
  type: TYPE_NORMAL
- en: In the r² calculation, we will need to calculate ![](img/00043.jpeg) and then
    sum the results. This is easy, as are the parts in the denominator.
  prefs: []
  type: TYPE_NORMAL
- en: However, wait a second; there is a common item in both the deviation and r²
    calculation, namely raising to the power ½. This is actually just another way
    of saying a square root.
  prefs: []
  type: TYPE_NORMAL
- en: It is now just a case of plugging in the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Application output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application has to output the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of elements in each vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number of elements in vector are not the same, output the value(s) removed
    and from which vector is removed from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The equation of the straight line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepts on the X and Y axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard deviation on the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The r² value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project 2 - some text manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A palindrome is a word that is spelled the same backwards as it is forward.
    For example, the word *madam* is a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a brief list of requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The application takes a line of text from the keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should fail if the line is blank or contains a non-alphabet character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any text entered should be converted to either lower- or upper-case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The word should be tested in a separate function to see if it is a palindrome.
    If it is, the function should return true; otherwise it should return false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calling function should output whether the inputted text is (or not) a palindrome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The palindrome function should be recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Project 3 – area and volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project should help consolidate both testing and documentation for your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have a simple web service running on a server somewhere. It exists as a
    test bed for users to send data and receive it back. The service is expecting
    three strings to be entered, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Username (string, non-null, must be more than 6 characters, no spaces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password (string, non-null, must be more than 8 characters, no spaces, must
    have 1 capital, 1 number)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command string is a comma-separated list containing details of whether it
    is to be a volume or area calculation, the type of shape, and the parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Shape types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Type** | **Shape** | **Type** | **Shape** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Circle/Sphere | 3 | Pentagon |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Triangle/Pyramid | 4 | Octagon |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Rectangle/Box | 5 | User-defined |'
  prefs: []
  type: TYPE_TB
- en: Volume or area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the command string, area is given by true with the volume being false.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This shape is up to you. It should be a shape is not currently on the list.
  prefs: []
  type: TYPE_NORMAL
- en: Formulae for calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should use the following formulae for the calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Shape | Area | Volume |'
  prefs: []
  type: TYPE_TB
- en: '| Circle/sphere(r = radius) | *A = Πr²* | *V = 4/3Πr³* |'
  prefs: []
  type: TYPE_TB
- en: '| Triangle/Pyramid(b = base, h = height, l = length, w = width) | *A = 1/2bh*
    | ![](img/00044.jpeg) |'
  prefs: []
  type: TYPE_TB
- en: '| Rectangle/Box(l = length, h = height, b = width) | *A = lh* | *V = lbh* |'
  prefs: []
  type: TYPE_TB
- en: '| Pentagon(a = side length, h = height) | ![](img/00045.jpeg) | ![](img/00046.jpeg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Octagon(a and s = side length, h = height) | ![](img/00047.jpeg) | ![](img/00048.jpeg)
    |'
  prefs: []
  type: TYPE_TB
- en: Testing criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following testing criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command line**: When testing the parameter data, any values as **0** should
    cause the first test to fail. For the second test, **0** should be replaced with
    a floating point value of your choice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The command line must come in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For example, true, 1, 3.1, 33.12, 4.3 is valid; whereas, false, 1, 12 will fail.
    (It requires two values to be passed in.)
  prefs: []
  type: TYPE_NORMAL
- en: A command line such as false, 1, 12.1, 13.5, 1.4, 0 will not fail as anything
    in the parameter list past the required number of parameters for the calculation
    can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: If the command fails, the output should always be -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Username and password**: The username and passwords have to meet the criteria
    set out at the start of the puzzle. If they fail, the output should be either
    Username failed or Password failed. No other reasons are required.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Auto-documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation should be generated for each function with the entry and exit
    parameter clearly stated.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions (regex)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Rust does come with Regex as its own crate, you are encouraged to create
    your own method to test string inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with all other examples, this should all be via the standard terminal entry
    and exit points (read keyboard and monitor). I would suggest three prompts: *username*,
    *password*, and *command line* as, after each input, it will be simpler to test
    the input submitted and respond appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: Project 4 – memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, you are to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reserve a 1024-byte block of memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill that block of memory with random characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array, which is also 1,024 bytes in size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the memory block into the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a string that is limited to 1,024 bytes and is set using the `capacity`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the memory block into the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you may be wondering why we have three identical blocks of memory.
    The simple reason is that you will now create a piece of code that will rotate
    each member in turn 3 times using a simple left-bit rotation and then 3 times
    to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise rotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bitwise rotation is performed in Rust using the `<<` and `>>` operators.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have a variable called `x` that is rotated 3 to the left,
    we will write `x << 3` with 3 to the right being `x >> 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Say we have *x = 01101001*, `x << 3` will be 01001000 and `x >> 3` will be 00001101.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation caveat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can simply have `x << 3`, what we need for this puzzle is to perform
    a single rotation 3 times, (so it is actually `x << 1`, `x << 1`, `x << 1`).
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not expected that the values you started off with will be the values you
    ended up with (if you shift too far, the empty spaces in the byte are filled with
    0's). You should be able to find how many bytes have a value of 0\. You should
    display this at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trying these four different types of programming challenge should have helped
    firm up the knowledge you have gained from the first half of the book. In the
    next half, we'll be covering more advanced topics and will continue to explore
    the strength and flexibility that Rust can provide.
  prefs: []
  type: TYPE_NORMAL
