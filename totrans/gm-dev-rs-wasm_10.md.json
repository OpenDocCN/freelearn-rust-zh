["```rs\n<body>\n  <div id=\"ui\" style=\"position: absolute\"></div>\n  <canvas id=\"canvas\" tabindex=\"0\" height=\"600\" width=\"600\">\n    Your browser does not support the Canvas.\n  </canvas>\n  <script src=\"img/index.js\"></script>\n</body>\n</html>\n```", "```rs\n<div id=\"ui\" style=\"position: absolute\">\n  <button>New Game</button>\n</div>\n```", "```rs\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n    <title>My Rust + Webpack project!</title>\n<link rel=\"stylesheet\" href=\"styles.css\" type=\"text/css\" \n      media=\"screen\">\n</head>\n```", "```rs\n#ui {\n    position: absolute;\n}\n```", "```rs\n@font-face {\n  font-family: 'Ken Future';\n  src: url('kenney_future_narrow-webfont.woff2');\n}\n```", "```rs\nbutton {\n    font-family: 'Ken Future';\n}\n```", "```rs\nbutton {\n    font-family: 'Ken Future';\n    background: -72px -60px url('Button.svg');\n}\n```", "```rs\nbutton {\n    font-family: 'Ken Future';\n    background: -72px -60px url('Button.svg');\n    border: none;\n    width: 82px;\n    height: 33px;\n}\n```", "```rs\nbutton:hover {\n    background: -158px -60px url('Button.svg');\n}\n```", "```rs\nbutton:active {\n    background: -244px -60px url('Button.svg');\n}\n```", "```rs\nbutton {\n    font-family: 'Ken Future';\n    background: -72px -60px url('Button.svg');\n    border: none;\n    width: 82px;\n    height: 33px;\n    transform: scale(1.8);\n}\n```", "```rs\nbutton {\n    font-family: 'Ken Future';\n    background: -72px -60px url('Button.svg');\n    border: none;\n    width: 82px;\n    height: 33px;\n    transform: scale(1.8) translate(150px, 100px);\n}\n```", "```rs\nlet ui = document.getElementById(\"ui\");\nui.insertAdjacentHTML(\"afterbegin\", \"<button>New Game</button>\");\n```", "```rs\npub fn draw_ui(html: &str) -> Result<()> {\n    document()\n        .and_then(|doc| {\n            doc.get_element_by_id(\"ui\")\n                .ok_or_else(|| anyhow!(\"UI element not found\"))\n        })\n        .and_then(|ui| {\n            ui.insert_adjacent_html(\"afterbegin\", html)\n                .map_err(|err| anyhow!(\"Could not insert \n                    html {:#?}\", err))\n        })\n}\n```", "```rs\nlet ui = document.getElementById(\"ui\");\nlet firstChild = ui.firstChild;\nui.removeChild(firstChild);\n```", "```rs\npub fn hide_ui() -> Result<()> {\n    let ui = document().and_then(|doc| {\n        doc.get_element_by_id(\"ui\")\n            .ok_or_else(|| anyhow!(\"UI element not found\"))\n    })?;\n    if let Some(child) = ui.first_child() {\n        ui.remove_child(&child)\n            .map(|_removed_child| ())\n            .map_err(|err| anyhow!(\"Failed to remove child \n                {:#?}\", err))\n    } else {\n        Ok(())\n    }\n}\n```", "```rs\npub fn draw_ui(html: &str) -> Result<()> {\n    find_ui()?\n        .insert_adjacent_html(\"afterbegin\", html)\n        .map_err(|err| anyhow!(\"Could not insert html \n            {:#?}\", err))\n}\npub fn hide_ui() -> Result<()> {\n    let ui = find_ui()?;\n    if let Some(child) = ui.first_child() {\n        ui.remove_child(&child)\n            .map(|_removed_child| ())\n            .map_err(|err| anyhow!(\"Failed to remove child \n                {:#?}\", err))\n    } else {\n        Ok(())\n    }\n}\nfn find_ui() -> Result<Element> {\n    document().and_then(|doc| {\n        doc.get_element_by_id(\"ui\")\n            .ok_or_else(|| anyhow!(\"UI element not found\"))\n    })\n}\n```", "```rs\npub fn add_click_handler(elem: HtmlElement) -> UnboundedReceiver<()> {\n    let (click_sender, click_receiver) = unbounded();\n    click_receiver\n}\n```", "```rs\npub fn add_click_handler(elem: HtmlElement) -> \n    UnboundedReceiver<()> {\n    let (mut click_sender, click_receiver) = unbounded();\n    let on_click = browser::closure_wrap(Box::new(move || {\n        click_sender.start_send(());\n    }) as Box<dyn FnMut()>);\n    click_receiver\n}\n```", "```rs\npub fn add_click_handler(elem: HtmlElement) -> UnboundedReceiver<()> {\n    let (mut click_sender, click_receiver) = unbounded();\n    let on_click = browser::closure_wrap(Box::new(move || {\n        click_sender.start_send(());\n    }) as Box<dyn FnMut()>);\n    elem.set_onclick(Some(on_click.as_ref().unchecked_ref()));\n    on_click.forget();\n    click_receiver\n}\n```", "```rs\n    impl RedHatBoyState<Running> {\n        ...\n        pub fn jump(self) -> RedHatBoyState<Jumping> {\n            RedHatBoyState {\n                context: self\n                    .context\n                    .reset_frame()\n                    .set_vertical_velocity(JUMP_SPEED)\n                    .play_jump_sound(),\n                _state: Jumping {},\n            }\n        }\n```", "```rs\npub enum WalkTheDog {\n    Loading,\n    Loaded(Walk),\n}\n```", "```rs\nstruct WalkTheDogGame {\n    machine: Option<WalkTheDogStateMachine>\n}\n```", "```rs\nlet mut keystate = KeyState::new();\n*g.borrow_mut() = Some(browser::create_raf_closure(move |perf: f64| {\n    process_input(&mut keystate, &mut keyevent_receiver);\n    game_loop.accumulated_delta += (perf – \n        game_loop.last_frame) as f32;\n    while game_loop.accumulated_delta > FRAME_SIZE {\n        game.update(&keystate);\n        game_loop.accumulated_delta -= FRAME_SIZE;\n    }\n```", "```rs\nerror[E0507]: cannot move out of `*game`, as `game` is a captured variable in an `FnMut` closure\n```", "```rs\nenumWalkTheDogGame {\n    Loading,\n    Loaded(Walk),\n    Walking(Walk),\n    GameOver(Walk)\n}\n```", "```rs\npub enum WalkTheDog {\n    Loading,\n    Loaded(Walk),\n}\n```", "```rs\npub struct WalkTheDog {\n    machine: Option<WalkTheDogStateMachine>,\n}\n```", "```rs\nenum WalkTheDogStateMachine {\n    Ready(WalkTheDogState<Ready>),\n    Walking(WalkTheDogState<Walking>),\n    GameOver(WalkTheDogState<GameOver>),\n}\n```", "```rs\nstruct WalkTheDogState<T> {\n    _state: T,\n    walk: Walk,\n}\nstruct Ready;\nstruct Walking;\nstruct GameOver;\n```", "```rs\nimpl WalkTheDog {\n    pub fn new() -> Self {\n        WalkTheDog::Loading {}\n    }\n}\n```", "```rs\nimpl WalkTheDog {\n    pub fn new() -> Self {\n        WalkTheDog { machine: None }\n    }\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self.machine {\n            None => {\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self.machine {\n            ...\n            Some(_) => Err(anyhow!(\"Error: Game is already  \n                initialized!\")),\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self.machine {\n            None => {\n                ...\n                let timeline = \n                    rightmost(&starting_obstacles);\n                let machine = WalkTheDogStateMachine\n                    ::Ready(WalkTheDogState {\n                    _state: Ready,\n                    walk: Walk {\n                        boy: rhb,\n                        backgrounds: [\n                            Image::new(background.clone(), \n                                Point { x: 0, y: 0 }),\n                            Image::new(\n                                background,\n                                Point {\n                                    x: background_width,\n                                    y: 0,\n                                },\n                            ),\n                        ],\n                        obstacles: starting_obstacles,\n                        obstacle_sheet: sprite_sheet,\n                        stone,\n                        timeline,\n                    },\n                });\n                ...\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self.machine {\n            None => {\n                ...\n                 Ok(Box::new(WalkTheDog {\n                    machine: Some(machine),\n                }))\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let Some(machine) = self.machine {\n            ...\n```", "```rs\nerror[E0507]: cannot move out of `self.machine.0` which is behind a mutable reference\n   -->src/game.rs:676:32\n    |\n676 |         if let Some(machine) = self.machine {\n    |                     -------    ^^^^^^^^^^^^ help: consider borrowing here: `&self.machine`\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState)\n        if let Some(machine) = &mut self.machine {\n            match machine {\n                WalkTheDogStateMachine::Ready(state) => {\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    fn start_running(&mut self) -> WalkTheDogState<Walking> {\n        self.run_right();\n        WalkTheDogState {\n            _state: Walking,\n            walk: self.walk,\n        }\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let Some(machine) = self.machine.take() {\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let Some(machine) = self.machine.take() {\n            ...\n        }\n        assert!(self.machine.is_some());\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let Some(machine) = self.machine.take() {\n            self.machine.replace(machine.update(keystate));\n            if keystate.is_pressed(\"ArrowRight\") {\n```", "```rs\nimpl WalkTheDogStateMachine {\n    fn update(self, keystate: &KeyState) -> Self {\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let Some(machine) = self.machine.take() {\n            self.machine.replace(machine.update(keystate));\n        }\n        assert!(self.machine.is_some());\n    }\n```", "```rs\nimpl WalkTheDogStateMachine {\n    fn update(self, keystate: &KeyState) -> Self {\n        match self {\n            WalkTheDogStateMachine::Ready(state) \n                =>state.update(keystate).into(),\n            WalkTheDogStateMachine::Walking(state) \n                =>state.update(keystate).into(),\n            WalkTheDogStateMachine::GameOver(state) \n               =>state.update().into(),\n        }\n    }\n}\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    fn update(self, keystate: &KeyState) -> \n        WalkTheDogState<Ready> {\n        self\n    }\n}\nimpl WalkTheDogState<Walking> {\n    fn update(self, keystate: &KeyState) -> \n        WalkTheDogState<Walking> {\n        self\n    }\n}\nimpl WalkTheDogState<GameOver> {\n    fn update(self) -> WalkTheDogState<GameOver> {\n        self\n    }\n}\n```", "```rs\nimpl From<WalkTheDogState<Ready>> for WalkTheDogStateMachine {\n    fn from(state: WalkTheDogState<Ready>) -> Self {\n        WalkTheDogStateMachine::Ready(state)\n    }\n}\nimpl From<WalkTheDogState<Walking>> for WalkTheDogStateMachine {\n    fn from(state: WalkTheDogState<Walking>) -> Self {\n        WalkTheDogStateMachine::Walking(state)\n    }\n}\nimpl From<WalkTheDogState<GameOver>> for WalkTheDogStateMachine {\n    fn from(state: WalkTheDogState<GameOver>) -> Self {\n        WalkTheDogStateMachine::GameOver(state)\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            if keystate.is_pressed(\"ArrowRight\") {\n                walk.boy.run_right();\n            }\n            if keystate.is_pressed(\"Space\") {\n                walk.boy.jump();\n            }\n            if keystate.is_pressed(\"ArrowDown\") {\n                walk.boy.slide();\n            }\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    fn update(self, keystate: &KeyState) -> ReadyEndState {\n        if keystate.is_pressed(\"ArrowRight\") {\n            ReadyEndState::Complete(self.start_running())\n        } else {\n            ReadyEndState::Continue(self)\n        }\n    }\n}\n```", "```rs\nenum ReadyEndState {\n    Complete(WalkTheDogState<Walking>),\n    Continue(WalkTheDogState<Ready>),\n}\nimpl From<ReadyEndState> for WalkTheDogStateMachine {\n    fn from(state: ReadyEndState) -> Self {\n        match state {\n            ReadyEndState::Complete(walking) => \n                walking.into(),\n            ReadyEndState::Continue(ready) => ready.into(),\n        }\n    }\n}\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    ...\n    fn start_running(mut self) -> WalkTheDogState<Walking> {\n        self.run_right();\n        WalkTheDogState {\n            _state: Walking,\n            walk: self.walk,\n        }\n    }\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    ...\n    fn run_right(&mut self) {\n        self.walk.boy.run_right();\n    }\n}\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        renderer.clear(&Rect::new(Point { x: 0, y: 0 }, \n            600, 600));\n        if let Some(machine) = &self.machine {\n            machine.draw(renderer);\n        }\n    }\n}\n```", "```rs\nimpl WalkTheDogStateMachine {\n    ...\n    fn draw(&self, renderer: &Renderer) {\n        match self {\n            WalkTheDogStateMachine::Ready(state) => \n                state.draw(renderer),\n            WalkTheDogStateMachine::Walking(state) => \n                state.draw(renderer),\n            WalkTheDogStateMachine::GameOver(state) => \n                state.draw(renderer),\n        }\n    }\n}\n```", "```rs\nimpl<T> WalkTheDogState<T> {\n    fn draw(&self, renderer: &Renderer) {\n        self.walk.draw(renderer);\n    }\n}\n```", "```rs\nimpl Walk {\n    fn draw(&self, renderer: &Renderer) {\n        self.backgrounds.iter().for_each(|background| {\n            background.draw(renderer);\n        });\n        self.boy.draw(renderer);\n        self.obstacles.iter().for_each(|obstacle| {\n            obstacle.draw(renderer);\n        });\n    }\n    ...\n}\n```", "```rs\n                let machine = WalkTheDogStateMachine\n                    ::Ready(WalkTheDogState {\n                    _state: Ready,\n                    walk: Walk {\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    fn new(walk: Walk) -> WalkTheDogState<Ready> {\n        WalkTheDogState {\n            _state: Ready,\n            walk,\n        }\n    }\n    ...\n```", "```rs\nimpl WalkTheDogStateMachine {\n    fn new(walk: Walk) -> Self {\n        WalkTheDogStateMachine\n            ::Ready(WalkTheDogState::new(walk))\n    }\n    ...\n```", "```rs\nimpl Game for WalkTheDog {\n    async fn initialize(&self) -> Result<Box<dyn Game>> {\n        match self.machine {\n            None => {\n                ...\n                let machine = WalkTheDogStateMachine\n                    ::new(Walk {\n                    boy: rhb,\n                    ...\n```", "```rs\nimpl Game for WalkTheDog {\n    ...\n    fn update(&mut self, keystate: &KeyState) {\n        if let WalkTheDog::Loaded(walk) = self {\n            ...\n            if keystate.is_pressed(\"ArrowDown\") {\n                walk.boy.slide();\n            }\n            walk.boy.update();\n            ...\n```", "```rs\nimpl WalkTheDogState<Ready> {\n    fn update(mut self, keystate: &KeyState) -> \n        ReadyEndState {\n        self.walk.boy.update();\n        if keystate.is_pressed(\"ArrowRight\") {\n            ReadyEndState::Complete(self.start_running())\n        } else {\n            ReadyEndState::Continue(self)\n        }\n}\n...\n```", "```rs\nimpl WalkTheDogState<Walking> {\n    ...\n    fn update(mut self, keystate: &KeyState) -> \n        WalkTheDogState<Walking> {\n        if keystate.is_pressed(\"Space\") {\n            self.walk.boy.jump();\n        }\n        ...\n        if self.walk.timeline < TIMELINE_MINIMUM {\n            self.walk.generate_next_segment();\n        } else {\n            self.walk.timeline += walking_speed;\n        }\n        self\n    }\n}\n```", "```rs\nimpl WalkTheDogState<Walking> {\n    ...\n    fn update(mut self, keystate: &KeyState) -> \n        WalkingEndState {\n        ...\n        if self.walk.timeline < TIMELINE_MINIMUM {\n            self.walk.generate_next_segment()\n        } else {\n            self.walk.timeline += walking_speed;\n        }\n        if self.walk.knocked_out() {\n            WalkingEndState::Complete(self.end_game())\n        } else {\n            WalkingEndState::Continue(self)\n        }\n    }\n}\n```", "```rs\nimpl Walk {\n    fn knocked_out(&self) -> bool {\n        self.boy.knocked_out()\n    }\n    ...\n}\nimpl RedHatBoy {\n    ...\n    fn knocked_out(&self) -> bool {\n        self.state_machine.knocked_out()\n    }\n    ...\n}\nimpl RedHatBoyStateMachine {\n    ...\n    fn knocked_out(&self) -> bool {\n        matches!(self, RedHatBoyStateMachine\n            ::KnockedOut(_))\n    }\n}\n```", "```rs\nimpl WalkTheDogState<Walking> {\n    fn end_game(self) -> WalkTheDogState<GameOver> {\n        WalkTheDogState {\n            _state: GameOver,\n            walk: self.walk,\n        }\n    }\n    ...\n```", "```rs\nimpl WalkTheDogState<Walking> {\n    fn end_game(self) -> WalkTheDogState<GameOver> {\n        browser::draw_ui(\"<button>New Game</button>\");        \n        WalkTheDogState {\n            _state: GameOver,\n            walk: self.walk,\n        }\n    }\n    ...\n```", "```rs\npub fn find_html_element_by_id(id: &str) -> Result<HtmlElement> {\n    document()\n        .and_then(|doc| {\n            doc.get_element_by_id(id)\n                .ok_or_else(|| anyhow!(\"Element with \n                    id {} not found\", id))\n        })\n        .and_then(|element| {\n            element\n                .dyn_into::<HtmlElement>()\n                .map_err(|err| anyhow!(\"Could not cast \n                    into HtmlElement {:#?}\", err))\n        })\n}\n```", "```rs\nimpl WalkTheDogState<Walking> {\n    fn end_game(self) -> WalkTheDogState<GameOver> {\n        let receiver = browser::draw_ui(\"<button id='new_game'>New Game</button>\")\n            .and_then(|_unit| browser::\n                find_html_element_by_id(\"new_game\"))\n            .map(|element| engine::\n                add_click_handler(element))\n            .unwrap();\n        WalkTheDogState {\n            _state: GameOver,\n            walk: self.walk,\n        }\n    }\n```", "```rs\nstruct GameOver {\n    new_game_event: UnboundedReceiver<()>,\n}\n```", "```rs\nimpl WalkTheDogState<Walking> {\n    fn end_game(self) -> WalkTheDogState<GameOver> {\n        let receiver = browser::draw_ui(\"<button \nid='new_game'>New Game</button>\")\n            .and_then(|_unit| browser::\n                find_html_element_by_id(\"new_game\"))\n            .map(|element| engine::\n                add_click_handler(element))\n            .unwrap();\n        WalkTheDogState {\n            _state: GameOver {\n                new_game_event: receiver,\n            },\n            walk: self.walk,\n        }\n    }\n```", "```rs\nimpl WalkTheDogState<GameOver> {\n    fn update(mut self) -> GameOverEndState {\n        if self._state.new_game_pressed() {\n            GameOverEndState::Complete(self.new_game())\n        } else {\n            GameOverEndState::Continue(self)\n        }\n    }\n}\nimpl GameOver {\n    fn new_game_pressed(&mut self) -> bool {\n        matches!(self.new_game_event.try_next(), \n            Ok(Some(())))       \n    }\n}\n```", "```rs\nimpl WalkTheDogState<GameOver> {\n    ...\n    fn new_game(self) -> WalkTheDogState<Ready> {\n        browser::hide_ui();\n        WalkTheDogState {\n            _state: Ready,\n            walk: self.walk,\n        }\n    }\n}\n```", "```rs\nimpl Walk {\n    fn reset(walk: Self) -> Self {\n        let starting_obstacles =\n            stone_and_platform(walk.stone.clone(), \n                walk.obstacle_sheet.clone(), 0);\n        let timeline = rightmost(&starting_obstacles);\n        Walk {\n            boy: walk.boy,\n            backgrounds: walk.backgrounds,\n            obstacles: starting_obstacles,\n            obstacle_sheet: walk.obstacle_sheet,\n            stone: walk.stone,\n            timeline,\n        }\n    }\n    ...\n}\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn reset(boy: Self) -> Self {\n        RedHatBoy::new(\n            boy.sprite_sheet,\n            boy.image,\n            boy.state_machine.context().audio.clone(),\n            boy.state_machine.context().jump_sound.clone(),\n        )\n    }\n```", "```rs\nimpl Walk {\n    ...\n    fn reset(walk: Self) -> Self {\n        ...\n        Walk {\n            boy: RedHatBoy::reset(walk.boy),\n            ...\n        }\n    }\n}\n```", "```rs\nimpl WalkTheDogState<GameOver> {\n    ...\n    fn new_game(self) -> WalkTheDogState<Ready> {\n        browser::hide_ui();\n        WalkTheDogState {\n            _state: Ready,\n            walk: Walk::reset(self.walk),\n        }\n    }\n}\n```", "```rs\npub fn hide_ui() -> Result<()> {\n    let ui = find_ui()?;\n    if let Some(child) = ui.first_child() {\n        ui.remove_child(&child)\n            .map(|_removed_child| ())\n            .map_err(|err| anyhow!(\"Failed to remove \n                child {:#?}\", err))\n            .and_then(|_unit| {\n                canvas()?\n                    .focus()\n                    .map_err(|err| anyhow!(\"Could not \nset focus to canvas! \n                            {:#?}\", err))\n            })\n    } else {\n        Ok(())\n    }\n}\n```", "```rs\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>My Rust + Webpack project!</title>\n  <link rel=\"stylesheet\" href=\"styles.css\" type=\"text/css\" \n      media=\n  \"screen\">\n  <link rel=\"preload\" as=\"image\" href=\"Button.svg\">\n  <link rel=\"preload\" as=\"font\" href=\n  \"kenney_future_narrow-webfont.woff2\">\n</head>\n```"]