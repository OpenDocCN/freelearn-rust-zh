["```rs\n    curl\n    ```", "```rs\n    apt install curl\n    ```", "```rs\n    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n    ```", "```rs\n    ...\n    1) Proceed with installation (default)\n    2) Customize installation\n    3) Cancel installation\n    >\n    ```", "```rs\n    source $HOME/.cargo/env\n    ```", "```rs\n    rustup toolchain install stable\n    ```", "```rs\nrustup toolchain install nightly\n```", "```rs\nrustup default stable\nrustup component add clippy\n```", "```rs\nrustup update\n```", "```rs\nrustup self update\n```", "```rs\n    fn main() { \n        println!(\"Hello World!\");\n    }\n    ```", "```rs\n    rustc main.rs\n    ```", "```rs\n    ./main\n    ```", "```rs\n    fn main() {}\n    ```", "```rs\n    use std::io;\n    fn main() {\n        println!(\"Input the string you want to encrypt:\");\n        let mut user_input = String::new();\n        io::stdin()\n            .read_line(&mut user_input)\n            .expect(\"Cannot read input\");\n        println!(\"Your encrypted string: {}\", user_input);\n    }\n    ```", "```rs\n    pub trait Encryptable {\n        fn encrypt(&self) -> String;\n    }\n    ```", "```rs\n    pub mod encryptor;\n    ```", "```rs\n    pub mod rot13;\n    ```", "```rs\n    pub struct Rot13(pub String);\n    impl super::Encryptable for Rot13 {}\n    ```", "```rs\n    > rustc main.rs \n    error[E0046]: not all trait items implemented, missing: `encrypt`\n     --> encryptor/rot13.rs:3:1\n      |\n    3 | impl super::Encryptable for Rot13 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing \n      `encrypt` in implementation\n    | \n     ::: encryptor/mod.rs:6:5\n      |\n    6 |     fn encrypt(&self) -> String;\n      |     ----------------------------------------------\n      ------ `encrypt` from trait\n    error: aborting due to previous error\n    For more information about this error, try `rustc --explain E0046`.\n    ```", "```rs\n    impl super::Encryptable for Rot13 {\n        fn encrypt(&self) -> String {\n        }\n    }\n    ```", "```rs\n    fn encrypt(&self) -> String {\n        let mut new_string = String::new();\n        let len = self.0.len();\n        for i in 0..len {\n            if (self.0[i] >= 'a' && self.0[i] < 'n') || \n            (self.0[i] >= 'A' && self.0[i] < 'N') {\n                new_string.push((self.0[i] as u8 + 13) as \n                char);\n            } else if (self.0[i] >= 'n' && self.0[i] < \n            'z') || (self.0[i] >= 'N' && self.0[i] < 'Z') \n            {\n                new_string.push((self.0[i] as u8 - 13) as \n                char);\n            } else {\n                new_string.push(self.0[i]);\n            }\n        } \n        new_string\n    }\n    ```", "```rs\n    fn encrypt(&self) -> String {\n        let mut new_string = String::new();\n        for ch in self.0.chars() {\n            if (ch >= 'a' && ch < 'n') || (ch >= 'A' &&\n            ch < 'N') {\n                new_string.push((ch as u8 + 13) as char);\n            } else if (ch >= 'n' && ch < 'z') || (ch >= \n            'N' && ch < 'Z') {\n                new_string.push((ch as u8 - 13) as char);\n            } else {\n                new_string.push(ch);\n            }\n        }\n        new_string\n    }\n    ```", "```rs\n    fn encrypt(&self) -> Result<String, Box<dyn Error>> {\n        self.0\n            .chars()\n            .map(|ch| {\n                if (ch >= 'a' && ch < 'n') || (ch >= 'A' \n                && ch < 'N') {\n                    (ch as u8 + 13) as char\n                } else if (ch >= 'n' && ch < 'z') || (\n                ch >= 'N' && ch < 'Z') {\n                    (ch as u8 - 13) as char\n                } else {\n                    ch\n                }\n            })\n            .collect()\n    }\n    ```", "```rs\n    fn encrypt(&self) -> String {\n        self.0\n            .chars()\n            .map(|ch| match ch {\n                'a'..='m' | 'A'..='M' => (ch as u8 + 13) \n                as char,\n                'n'..='z' | 'N'..='Z' => (ch as u8 - 13) \n                as char,\n                _ => ch,\n            })\n            .collect()\n    }\n    ```", "```rs\n    fn main() {\n        ...\n        io::stdin()\n        .read_line(&mut user_input)\n        .expect(\"Cannot read input\");\n        println!(\n            \"Your encrypted string: {}\",\n            encryptor::rot13::Rot13(user_input).encrypt()\n        );\n    }\n    ```", "```rs\n    use encryptor::Encryptable;\n    ```", "```rs\n    > ./main\n    Input the string you want to encrypt:\n    asdf123\n    Your encrypted string: nfqs123\n    > ./main\n    Input the string you want to encrypt:\n    nfqs123\n    Your encrypted string: asdf123\n    ```", "```rs\ncp -r 02ComplexProgram  03Packages\ncd 03Packages\ncargo init . --name our_package\n```", "```rs\n[package]\n```", "```rs\nname = \"our_package\"\n```", "```rs\nversion = \"0.1.0\"\n```", "```rs\nedition = \"2021\"\n```", "```rs\n# See more keys and their definitions at\n```", "```rs\nhttps://doc.rust-lang.org/cargo/reference/manifest.html\n```", "```rs\n[dependencies]\n```", "```rs\n[[bin]]\n```", "```rs\nname = \"our_package\"\n```", "```rs\npath = \"main.rs\"\n```", "```rs\n    [lib]\n    name = \"our_package\"\n    path = \"src/lib.rs\"\n    ```", "```rs\n    pub mod encryptor;\n    ```", "```rs\n    use our_package::encryptor::{rot13, Encryptable};\n    use std::io;\n    fn main() {\n        ...\n        println!(\n            \"Your encrypted string: {}\",\n            rot13::Rot13(user_input).encrypt()\n        );\n    }\n    ```", "```rs\n    > cargo check\n    Checking our_package v0.1.0 \n        (/Users/karuna/Chapter01/03Packages)\n    Finished dev [unoptimized + debuginfo] target(s) \n        in 1.01s\n    ```", "```rs\n    $ cargo build\n    Compiling our_package v0.1.0 \n       (/Users/karuna/Chapter01/03Packages)\n    Finished dev [unoptimized + debuginfo] target(s) \n        in 5.09s\n    ```", "```rs\n./target/debug/our_package\n```", "```rs\n        pub trait Cipher {\n            fn original_string(&self) -> String;\n            fn encrypted_string(&self) -> String;\n        }\n        ```", "```rs\n    impl super::Cipher for Rot13 {\n        fn original_string(&self) -> String {\n            String::from(&self.0)\n        }\n        fn encrypted_string(&self) -> String {\n            self.0\n                .chars()\n                .map(|ch| match ch {\n                    'a'..='m' | 'A'..='M' => (ch as u8 + \n                    13) as char,\n                    'n'..='z' | 'N'..='Z' => (ch as u8 – \n                    13) as char,\n                    _ => ch,\n                })\n                .collect()\n        }\n    }\n    ```", "```rs\n    use our_package::cipher::{rot13, Cipher};\n    …\n    fn main() {\n        …\n        println!(\n            \"Your encrypted string: {}\",\n            rot13::Rot13(user_input).encrypted_string()\n        );\n    }\n    ```", "```rs\n    rsa = \"0.5.0\"\n    rand = \"0.8.4\"\n    base64 = \"0.13.0\"\n    ```", "```rs\npub trait Cipher {\n    fn original_string(&self) -> Result<String, \n    Box<dyn Error>>;\n    fn encrypted_string(&self) -> Result<String, \n    Box<dyn Error>>;\n}\n```", "```rs\n    use std::error::Error;\n    pub struct Rot13(pub String);\n    impl super::Cipher for Rot13 {\n        fn original_string(&self) -> Result<String, \n        Box<dyn Error>> {\n            Ok(String::from(&self.0))\n        }\n    fn encrypted_string(&self) -> Result<String, \n        Box<dyn Error>> {\n            Ok(self\n                .0\n                ...\n                .collect())\n        }\n    }\n    ```", "```rs\n    pub mod rsa;\n    ```", "```rs\n    use std::error::Error;\n    pub struct Rsa {\n        data: String,\n    }\n    impl Rsa {\n        pub fn new(input: String) -> Result<Self, Box<\n        dyn Error>> {\n            unimplemented!();\n        }\n    }\n    impl super::Cipher for Rsa {\n        fn original_string(&self) -> Result<String, ()> {\n           unimplemented!();\n        }\n        fn encrypted_string(&self) -> Result<String, ()> {\n            Ok(String::from(&self.data))\n        }\n    }\n    ```", "```rs\n    use rand::rngs::OsRng;\n    use rsa::{PaddingScheme, PublicKey, RsaPrivateKey};\n    use std::error::Error;\n    const KEY_SIZE: usize = 2048;\n    pub struct Rsa {\n        data: String,\n        private_key: RsaPrivateKey,\n    }\n    impl Rsa {\n         pub fn new(input: String) -> Result<Self, Box<\n        dyn Error>> {\n            let mut rng = OsRng;\n            let private_key = RsaPrivateKey::new(&mut rng, \n            KEY_SIZE)?;\n            let public_key = private_key.to_public_key();\n            let input_bytes = input.as_bytes();\n            let encrypted_data =\n                public_key.encrypt(&mut rng, PaddingScheme\n                ::new_pkcs1v15_encrypt(), input_bytes)?;\n            let encoded_data = \n            base64::encode(encrypted_data);\n            Ok(Self {\n                data: encoded_data,\n                private_key,\n            })\n        }\n    }\n    ```", "```rs\n    fn original_string(&self) -> Result<String, Box<dyn Error>> {\n        let decoded_data = base64::decode(&self.data)?;\n        let decrypted_data = self\n            .private_key\n            .decrypt(PaddingScheme::\n            new_pkcs1v15_encrypt(), &decoded_data)?;\n        Ok(String::from_utf8(decrypted_data)?)\n    }\n    ```", "```rs\n    fn main() {\n        ...\n        println!(\n            \"Your encrypted string: {}\",\n            rot13::Rot13(user_input).encrypted_\n            string().unwrap()\n        );\n        println!(\"Input the string you want to encrypt:\");\n        let mut user_input = String::new();\n        io::stdin()\n            .read_line(&mut user_input)\n            .expect(\"Cannot read input\");\n        let encrypted_input = rsa::Rsa::new(\n        user_input).expect(\"\");\n        let encrypted_string = encrypted_input.encrypted_\n        string().expect(\"\");\n        println!(\"Your encrypted string: {}\", \n        encrypted_string);\n        let decrypted_string = encrypted_input\n        .original_string().expect(\"\");\n        println!(\"Your original string: {}\", \n        decrypted_string);\n    }\n    ```", "```rs\n$ cargo run\n   Compiling cfg-if v1.0.0\n   Compiling subtle v2.4.1\n   Compiling const-oid v0.6.0\n   Compiling ppv-lite86 v0.2.10\n   ...\nCompiling our_package v0.1.0 \n   (/Users/karuna//Chapter01/04Crates)\nFinished dev [unoptimized + debuginfo] target(s) \n    in 3.17s\n     Running `target/debug/our_package`\nInput the string you want to encrypt:\nfirst\nYour encrypted string: svefg\nInput the string you want to encrypt:\nsecond\nYour encrypted string: lhhb9RvG9zI75U2VC3FxvfUujw0cVqqZFgPXhNixQTF7RoVBEJh2inn7sEefDB7eNlQcf09lD2nULfgc2mK55ZE+UUcYzbMDu45oTaPiDPog4L6FRVpbQR27bkOj9Bq1KS+QAvRtxtTbTa1L5/OigZbqBc2QOm2yHLCimMPeZKhLBtK2whhtzIDM8l5AYTBg+rA688ZfB7ZI4FSRm4/h22kNzSPo1DECI04ZBprAq4hWHxEKRwtn5TkRLhClGFLSYKkY7Ajjr3EOf4QfkUvFFhZ0qRDndPI5c9RecavofVLxECrYfv5ygYRmW3B1cJn4vcBhVKfQF0JQ+vs+FuTUpw==\nYour original string: second\n```"]