- en: Chapter 1. Starting with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust is a programming language that is developed by Mozilla Research and backed
    up by a big open source community. Its development started in 2006 by language
    designer Graydon Hoare. Mozilla began sponsoring it in 2009, and it was first
    presented officially in 2010\. The work on it went through a lot of iterations,
    culminating on May 15 2015 with the first stable production version 1.0.0, which
    was made by the Rust Project Developers who consisted of the Rust team at Mozilla
    and an open source community of over 900 contributors. Rust is based on clear
    and solid principles. It is a systems programming language, equaling C and C++
    in its capabilities. It rivals idiomatic C++ in speed, but it lets you work in
    a much safer way by forbidding the use of code that could cause program crashes
    due to memory problems. Moreover, Rust has the built-in functionality necessary
    for concurrent execution on multicore machines; it makes concurrent programming
    memory safe without garbage collection—it is the only language that does this.
    Rust also eliminates the corruption of shared data through concurrent access,
    also known as data races.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will present you with the main reasons why Rust's popularity and
    adoption are steadily increasing. Then, we'll set up a working Rust development
    environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The trifecta of Rust: safety, speed, and concurrency'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rust compiler – `rustc`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our first program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Cargo
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of Rust
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mozilla is the company that is known for its mission to develop tools for and
    drive the evolution of the Web based on open standards, most notably through its
    flagship browser Firefox. Every browser today, including Firefox, is written in
    C++ by using some 12,900,992 lines of code for Firefox and 4,490,488 lines of
    code for Chrome. This enables programs to be fast, but it is inherently unsafe
    because the memory manipulations allowed by C and C++ are not checked for validity.
    If the code is written without the utmost programming discipline on the part of
    the developers, then program crashes, memory leaks, segmentation faults, buffer
    overflows, and null pointers can occur at program execution. Some of these can
    result in serious security vulnerabilities, which are all too well-known in existing
    browsers. Rust is designed from the ground up to avoid these kinds of problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other side of the programming-language spectrum, we have Haskell, which
    is widely known to be a very safe and reliable language, but with very little
    or no control of the level of memory allocation and other hardware resources.
    We can plot different languages along this control—safety axis, and it seems that
    when a language is safer, it loses low-level control; the inverse is also true:
    a language that gives more control over resources provides much less safety, shown
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![The advantages of Rust](img/image00168.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Rust 的优势](img/image00168.jpeg)'
- en: 'Rust ([http://www.rust-lang.org/](http://www.rust-lang.org/)) is made to overcome
    this dilemma by providing the following features:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Rust ([http://www.rust-lang.org/](http://www.rust-lang.org/)) 是为了克服这一困境而设计的，它提供了以下特性：
- en: High safety through its strong type system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其强大的类型系统实现高安全性
- en: Deep but safe control over low-level resources (as much as C/C++) so that it
    runs close to the hardware
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对底层资源进行深入但安全的控制（与 C/C++ 相当），以便其运行接近硬件
- en: 'Rust lets you specify exactly how your values should be laid out in memory
    and how that memory should be managed; this is why it works well at both ends
    of the control and safety line. This is the unique selling point of Rust: it breaks
    the safety-control dichotomy that, before Rust, existed in programming languages.
    With Rust, control and safety can be achieved together without losing performance.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许你精确指定你的值在内存中的布局方式以及如何管理这些内存；这就是为什么它在控制和安全性的两端都表现得很好。这是 Rust 的独特卖点：它打破了在
    Rust 之前存在于编程语言中的安全-控制二分法。使用 Rust，可以在不牺牲性能的情况下同时实现控制和安全性。
- en: 'Rust can accomplish both these goals without a garbage collector, in contrast
    to most modern languages such as Java, C#, Python, Ruby, Go; in fact Rust doesn''t
    even have a garbage collector yet (though one is planned). Rust is a compiled
    language: the strict safety rules are enforced by the compiler so that they do
    not cause runtime overhead. As a consequence, Rust can work with minimal runtime
    or even no runtime at all; so, it can be used for real time or embedded projects,
    and it can easily integrate with other languages or projects.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数现代语言（如 Java、C#、Python、Ruby、Go）不同，Rust 可以在不使用垃圾回收器的情况下实现这两个目标；实际上，Rust 甚至还没有垃圾回收器（尽管计划中有一个）。Rust
    是一种编译型语言：严格的 safety 规则由编译器强制执行，因此不会造成运行时开销。因此，Rust 可以使用最少的运行时，甚至完全没有运行时；因此，它可以用于实时或嵌入式项目，并且可以轻松地与其他语言或项目集成。
- en: Rust is meant for developers and projects where not only performance and low-level
    optimizations are important, but where there is also a need for a safe and stable
    execution environment. Moreover, Rust adds a lot of high-level functional programming
    techniques within the language so that it feels like a low-level and a high-level
    language at the same time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 旨在为那些不仅重视性能和底层优化，而且还需要一个安全且稳定的执行环境的开发者和项目而设计。此外，Rust 在语言内部添加了许多高级函数式编程技术，因此它既感觉像是一种底层语言，又像是一种高级语言。
- en: The trifecta of Rust – safety, speed, and concurrency
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的三合一优势——安全性、速度和并发性
- en: Rust is not a revolutionary language with new cutting-edge features, but it
    incorporates a lot of proven techniques from older languages while massively improving
    upon the design of C++ in matters of safe programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不是一个具有新尖端特性的革命性语言，但它从旧语言中吸收了许多经过验证的技术，同时在安全编程方面对 C++ 的设计进行了大量改进。
- en: The Rust developers designed Rust to be a general-purpose and multi-paradigm
    language. Like C++, it is an imperative, structured, and object-oriented language.
    Besides this, it inherits a lot from functional languages and also incorporates
    advanced techniques for concurrent programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 开发者设计 Rust 成为一个通用和多范式的语言。像 C++ 一样，它是一种命令式、结构化和面向对象的语言。除此之外，它还从函数式语言中继承了许多东西，并且还融合了并发编程的高级技术。
- en: In Rust, the typing of variables is static (because Rust is compiled) and strong.
    However, unlike Java or C++, the developer is not forced to indicate the types
    for everything as the Rust compiler is able to infer the types in many cases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，变量的类型是静态的（因为 Rust 是编译型语言）且强类型。然而，与 Java 或 C++ 不同，开发者不需要强制为所有内容指定类型，因为
    Rust 编译器能够在许多情况下推断出类型。
- en: C and C++ are known to be haunted by a series of problems that often lead to
    program crashes or memory leaks which are notoriously difficult to debug and solve.
    Think about dangling pointers, buffer overflows, null pointers, segmentation faults,
    data races, and so on. The Rust compiler (called `rustc`) is very intelligent
    and can detect all these problems while compiling your code, thereby guaranteeing
    memory safety during execution. This is done by the compiler by retaining complete
    control over memory layout, without needing the runtime burden of garbage collection
    (see [Chapter 6](part0056.xhtml#aid-1LCVG2 "Chapter 6. Pointers and Memory Safety"),
    *Pointers and Memory Safety*). In addition, its safety also implies much less
    possibilities for security breaches.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Rust compiles native code like Go and Julia. However, in contrast to these two,
    Rust doesn't need runtime with garbage collection. In this respect, it also differs
    from Java JVM and the languages that run on the JVM, such as Scala and Clojure.
    Most other popular modern languages such as .NET with C# and F#, JavaScript, Python,
    Ruby, Dart, and so on, all need a virtual machine and garbage collection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: As one of its mechanisms for concurrency, Rust adopts the well-known actor model
    from Erlang. Lightweight processes called threads perform work in parallel. They
    do not share heap memory but communicate data through channels, and data races
    are eliminated by the type system (see [Chapter 8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency
    and Parallelism"), *Concurrency and Parallelism*). These primitives make it easy
    for programmers to leverage the power of many CPU cores that are available on
    current and future computing platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The `rustc` compiler is completely self hosted, which means that it is written
    in Rust and can compile itself by using a previous version. It uses the LLVM compiler
    framework as its backend (for more information on LLVM compiler framework, go
    to [http://en.wikipedia.org/wiki/LLVM](http://en.wikipedia.org/wiki/LLVM)) and
    produces natively executable code that runs blazingly fast because it compiles
    to the same low-level code as C++ (To see an example of its speed, go to [http://benchmarksgame.alioth.debian.org/u64q/rust.php](http://benchmarksgame.alioth.debian.org/u64q/rust.php).).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust is designed to be as portable as C++ and run on widely used hardware and
    software platforms; at present, it runs on Linux, Mac OS X, Windows, FreeBSD,
    Android, and iOS. It can call C''s code as simply and efficiently as C can call
    its own code, and conversely, C can also call Rust code (see [Chapter 9](part0069.xhtml#aid-21PMQ1
    "Chapter 9. Programming at the Boundaries"), *Programming at the Boundaries*).
    The following is the logo of Rust:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![The trifecta of Rust – safety, speed, and concurrency](img/image00169.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Other Rust characteristics that will be discussed in more detail in later chapters
    are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Its variables are immutable by default (see [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types*)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums (see [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring Data
    and Matching Patterns"), *Structuring Data and Matching Patterns*)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching (see [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring
    Data and Matching Patterns"), *Structuring Data and Matching Patterns*)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics (see [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing
    Code with Higher-order Functions and Parametrization"), *Generalizing Code with
    Higher-order Functions and Parametrization*)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions and closures (see [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface system called traits (see [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hygienic macro system (see [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Organizing
    Code and Macros"), *Organizing Code and Macros*)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero-cost abstractions, which means that Rust has higher-language constructs,
    but these do not have an impact on performance
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, Rust gives you ultimate power over memory allocation as well
    as removing many security and stability problems that are commonly associated
    with native languages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with other languages
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamic languages such as Ruby or Python give you the initial coding speed,
    but you pay the price later when you have to write more tests, runtime crashes,
    or even production outages. The Rust compiler forces you to get a lot of things
    right at compile-time, which is the least expensive place to identify and fix
    bugs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Rust's object orientation is not that explicit or evolved as common object-oriented
    languages such as Java, C#, and Python as it doesn't have classes. Compared with
    Go, Rust gives you more control over memory and resources, so lets you code on
    a lower level. Go also works with a garbage collector, and it has no generics
    or a mechanism to prevent data races between its goroutines that are used in concurrency.
    Julia is focused on numerical computing performance; it works with a JIT compiler
    and doesn't give you that low-level control that Rust gives.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Using Rust
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is clear from the previous sections that Rust can be used in projects that
    normally use C or C++. Indeed, many regard Rust as a successor or a replacement
    of C and C++. Although Rust is designed to be a systems language, it has a broad
    range of possible applications due to its richness of constructs, making it an
    ideal candidate for applications that fall into one or all of the following categories:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Client applications, such as browsers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-latency, high-performance systems, such as device drivers, games, and signal
    processing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly distributed and concurrent systems, such as server applications
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time and critical systems, such as operating systems or kernels
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded systems (that require a very minimal runtime footprint) or a resource-constrained
    environment, such as a Raspberry Pi, Arduino, or robotics
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools or services that can't support the long warm-up delays that are common
    in **Just In Time** (**JIT**) compiler systems and need instantaneous startup
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web frameworks
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large-scale, high-performance, resource intensive, and complex software systems
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust is especially suited when code quality is important, that is for:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Modestly-sized or larger developer teams
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code for long-running production use
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code with a longer lifetime that requires regular maintenance and refactoring
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code for which you would normally write a lot of unit tests to safeguard it
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even before the appearance of Rust 1.0, two companies already use it in production:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: OpenDNS ([http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/](http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/))
    is a middleware tool for blocking malware and malicious domains
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skylight ([https://www.skylight.io/](https://www.skylight.io/)) from the company
    Tilde ([http://www.tilde.io/](http://www.tilde.io/)) is a tool for monitoring
    the execution of Rails apps.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servo
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mozilla uses Rust as the language for writing Servo, its new web browser engine
    that is designed for parallelism and safety ([https://github.com/servo/servo](https://github.com/servo/servo)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Due to the design of Rust's compiler, many kinds of browser security bugs are
    prevented automatically. In 2013, Samsung got involved, porting Servo to Android
    and ARM processors. Servo itself is an open source project with more than 200
    contributors. It is under heavy development, and among other things, it has already
    implemented its own CSS3 and HTML5 parser in Rust. It passed the web compatibility
    browser test ACID2 in March 2014 ([http://en.wikipedia.org/wiki/Acid2/](http://en.wikipedia.org/wiki/Acid2/)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rust
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust compiler and tools can be downloaded from [http://www.rust-lang.org/install.html](http://www.rust-lang.org/install.html)
    in the binary (that is, executable) form. The platform comes for the three major
    operating systems (Linux 2.6.18 or a later version, OS X 10.7 or a later version,
    and Windows 7, Windows 8, and Windows Server 2008 R2) in both the 32- and 64-bit
    formats, and it is delivered as an installer or in an archive format. You should
    use the current official stable release 1.0 when you engage in professional work
    with Rust. If you would like to investigate or use the latest developments, install
    the nightly build version.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: For Windows, double-click on the `.exe` installer to install the Rust binaries
    and dependencies. Adding Rust's directory to the search path for executables is
    an optional part of the installation, so make sure that this option is selected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux and Mac OS X, the simplest way is to run the following command in
    your shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Verify the correctness of the installation by showing Rust's version with `rustc
    –V` or `rustc - -version`, which produces an output like `rustc 1.0.0-beta (9854143cb
    2015-04-02) (built 2015-04-02)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Rust can be uninstalled by running `C:\Rust\unins001.exe` on Windows or `/usr/local/lib/rustlib/uninstall.sh`
    on Linux.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Rust has also been ported to Android OS on ARM processors and iOS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: A bare metal stack called zinc for running Rust in embedded environments can
    be found at [http://zinc.rs/](http://zinc.rs/). However, at this moment, only
    the ARM architecture is supported by it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The source code resides on GitHub ([https://github.com/rust-lang/rust/](https://github.com/rust-lang/rust/))
    and if you want to build Rust from source, we refer you to [https://github.com/rust-lang/rust#building-from-source](https://github.com/rust-lang/rust#building-from-source).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler – rustc
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rust installation directory containing `rustc` can be found on your machine
    in the following folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, at `C:\Program Files\Rust 1.0\bin` or a folder of your choice
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux or Mac OS X, it can be found by navigating to `/usr/local/bin`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Rust home folder was added to the search path for executables, `rustc`
    can be run from any command-line window. The Rust libraries can be found in the
    `rustlib` subfolder of the `bin` directory on Windows, or in `/usr/local/lib/rustlib`
    on Linux. Its HTML documentation can be found at `C:\Rust\share\doc\rust\html`
    on Windows or `/usr/local/share/doc/html` on Linux.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rustc` command has the following format: `rustc [options] input`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The options are one letter directives for the compiler after a dash, such as
    `-g` or `-W`, or words prefixed by a double dash, such as `- -test` or `- -no-analysis`.
    All the options with some explanation are shown when invoking `rustc -h`. In the
    next section, we will verify our installation by compiling and running our first
    Rust program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Our first program
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started by showing a welcome message to the players of our game:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite text editor (such as notepad or gedit) for a new file and
    type in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the file as `welcome.rs`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rs` is the standard extension of Rust code files. Source file names may not
    contain spaces; if they contain more than one word, use an underscore `_` as a
    separator; for example, `start_game.rs`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, compile it to native code on the command line with the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This produces an executable program `welcome.exe` on Windows or `welcome` on
    Linux.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run this program with `welcome` or `./welcome` to get the following output:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output executable gets its name from the source file. If you want to give
    the executable another name, such as `start`, compile it with the `-o output_name`
    option:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `rustc –O` command produces a native code that is optimized for execution
    speed (which is equivalent to `rustc -C opt-level=2`; the most optimized code
    is generated for `rustc –C opt-level = 3`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running are separate, consecutive steps, contrary to dynamic languages
    such as Ruby or Python where these are performed in one step.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain the code a bit to you. If you have already worked in a C/Java/C#
    like environment, this code will seem quite familiar. As in most languages, execution
    of the code starts in a `main()` function, which is mandatory in an executable
    program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In a larger project with many source files, the file containing the `main()`
    function would be called `main.rs` by convention.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `main()` is a function declaration because it is preceded by
    the keyword `fn`, which is short and elegant like most Rust keywords. `()` after
    main denotes the parameter list, which is empty here. The function's code is placed
    in a code block, which is surrounded by curly braces (`{ }`) where the opening
    brace is put by convention on the same line as the function declaration, but it
    is separated by one space. The closing brace appears after the code here, right
    beneath `fn`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Our program has only one line, which is indented by four spaces to improve readability
    (Rust is not whitespace sensitive). This line prints the string, "Welcome to the
    Game!". Rust recognizes this as a string because it is surrounded by double quotes
    (`" "`). This string was given as an argument to the `println!` macro (`!` indicates
    that it is a macro and not a function). The code line ends with a semicolon (`;`),
    as most, but not all, code lines in Rust do (see [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercises:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Write, compile, and execute a Rust program `name.rs` that prints out your name.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the smallest possible program in Rust in terms of code size?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `println!` macro has some nice formatting capabilities and at the same time
    checks when compiling whether the type of variables is correct for the applied
    formatting (see [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using Variables
    and Types"), *Using Variables and Types*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Working with Cargo
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo is Rust's package and dependency manager, and it is similar to Bundler,
    npm, pub, or pip for other languages. Although you can write Rust programs without
    it, Cargo is nearly indispensable for any large project; it works the same whether
    you work on a Windows, Linux, or a Mac OS X system. The installation procedure
    from the previous section includes the Cargo tool, so Rust is shipped with tooling
    included.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo does the following things for you:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: It makes a tidy folder structure and some templates for your project with the
    `cargo new` command
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It compiles (builds) your code by using the `cargo build` command
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs your project by using `cargo run`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your project contains unit tests, it can execute them for you by using `cargo
    test`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your project depends on packages, it will download them and build these packages
    according to the needs of your code by using `cargo update`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll introduce how to use Cargo now, and we''ll come back to it later, but
    you can find more info here: [http://doc.crates.io/guide.html](http://doc.crates.io/guide.html).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s remake our first project `welcomec` using Cargo by performing the following
    steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new project `welcomec` using the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `––bin` option tells Cargo that we want to make an executable program (a
    binary). This creates the following directory structure:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Working with Cargo](img/image00170.jpeg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: A folder with the same name as the project is created; in this folder, you can
    put all kinds of general information such as a `License` file, a `README` file,
    and so on. In addition, a `src` subfolder is created that contains a template
    source file named `main.rs`. (This contains the same code as our `welcome.rs`
    file, but it prints out the string "Hello world!".)
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The file `Cargo.toml` (with capital C) is the configuration file or manifest
    of your project; it contains all the metadata that Cargo needs to compile your
    project. It follows the so-called TOML format (for more details about this format,
    go to [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml))
    and contains the following text with information about our project:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This file is editable, so other sections can be added. For example, you can
    add a section to tell Cargo that we want a binary with the name welcome:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can build our project (no matter how many source files it contains) using
    the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives us the following output (on Linux):'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the following folder structure is produced:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Working with Cargo](img/image00171.jpeg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The directory target contains the executable `welcome`.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To execute this program, run the following command:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This produces the following output:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Step 2 has also produced a file named `Cargo.lock`; this is used by Cargo to
    keep track of dependencies in your application. At the moment, the application
    only contains:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The same file format is used to lock down the versions of libraries or packages
    that your project depends on. If your project is built in the future when updated
    versions of the libraries are available, Cargo will make sure that only the versions
    recorded in `Cargo.lock` are used so that your project is not built with an incompatible
    version of a library. This ensures a repeatable build process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Make, build, and run a project `name` that prints out your name with Cargo.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The website at [https://crates.io/](https://crates.io/) is the central repository
    for Rust packages or crates (as they are called) and contained 1700 crates as
    of the end of March 2015\. You can search for crates using specific terms or browse
    them alphabetically or according to the number of downloads:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Cargo](img/image00172.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: The developer tools
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Rust is a systems programming language, the only thing that you need is
    a good text editor (but not a word processor!) for writing the source code, and
    everything else can be done by commands in a terminal session. However, some developers
    appreciate the functionalities offered by more fully fledged text editors which
    are specifically for programming or IDE's (short for integrated development environments).
    Rust is still young but a lot of possibilities have already come up on this front
    although some of them need to be updated in the latest Rust version.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Rust plugins exist for a host of text editors, such as Atom, Brackets, BBEdit,
    Emacs, Geany, GEdit, Kate, TextMate, Textadept, Vim, NEdit, Notepad++, and SublimeText.
    Most Rust developers work with Vim or Emacs. These come with a syntax highlighting,
    and code completion tool called racer; go to [https://github.com/phildawes/racer](https://github.com/phildawes/racer).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Using Sublime Text
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The plugins for the popular Sublime Text editor ([http://www.sublimetext.com/3](http://www.sublimetext.com/3))
    are particularly pleasant to work with, and they don't get in your way. After
    you have installed Sublime Text (you might want to get a registered version),
    you must also install the Package Control package. (For instructions on how to
    do this, go to [https://packagecontrol.io/installation](https://packagecontrol.io/installation)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to install the Sublime Text Rust plugin, open the palette in Sublime
    Text (*Ctrl* + *Shift* + *P* or *cmd* + *Shift* + *P* on Mac OS X) and select
    **Package Control** | **Install Package**. Then, select **Rust** from the list,
    you will see something like the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Sublime Text](img/image00173.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'Sublime Text is a very comprehensive text editor, which includes color schemes.
    The Rust plugin provides syntax highlighting and auto-completion. Type one or
    more letters, choose an option from the list that appears with an arrow key and
    press *Tab* to insert the code snippet, or simply select a list-option through
    a mouse click. To compile and execute Rust code, follow these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Mark **Tools** | **Build System** | **Rust** in the menu.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you can compile a source file by pressing *Ctrl* + *B*. Warnings or errors
    will appear in the lower pane; if everything is okay, a message similar to **[Finished
    in 0.6s]** will appear.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you can run the program by pressing *Ctrl* + *Shift* + *B*; again the
    output will appear beneath the code. Alternatively, you can use the menu items:
    **Tools** | **Build** and **Tools** | **Run**.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A SublimeLinter plugin exists that provides an interface to rustc, which is
    called `SublimeLinter-contrib-rustc`. It does additional checks on your code for
    stylistic or programming errors. You can install it, as explained earlier, through
    Package Control and then use it from the menu **Tools** | **SublimeLinter**. (For
    more details, go to [https://github.com/oschwald/SublimeLinter-contrib-rustc](https://github.com/oschwald/SublimeLinter-contrib-rustc).)
    There is also a code completion tool called *racer*; you can find the information
    on how to install it at [https://packagecontrol.io/packages/RustAutoComplete](https://packagecontrol.io/packages/RustAutoComplete).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*RustDT* ([http://rustdt.github.io/](http://rustdt.github.io/)) is a new and
    promising Rust IDE based on Eclipse. On top of all the editing functionality offered
    by Eclipse, it is project-based using Cargo. Moreover it has code completion and
    debugging functionality (using the GDB debugger).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plugins such as the following ones for IDEs at different states
    of completion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The *RustyCage* plugin ([https://github.com/reidarsollid/RustyCage](https://github.com/reidarsollid/RustyCage))
    for Eclipse
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *idea-rust* plugin ([http://plugins.jetbrains.com/plugin/7438](http://plugins.jetbrains.com/plugin/7438))
    for IntelliJ
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *rust-netbeans* plugin ([https://github.com/azazar/rust-netbeans](https://github.com/azazar/rust-netbeans))
    for NetBeans
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *VisualRust* plugin (*https://github.com/PistonDevelopers/VisualRust*) for
    Visual Studio
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can test out the Rust code even without local installation with the Rust
    Play Pen: [http://play.rust-lang.org/](http://play.rust-lang.org/). Here you can
    edit or paste your code, and evaluate it.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The *rusti* is an interactive shell or **Read-Evaluate-Print-Loop** (**REPL**)
    that is being developed for Rust; this is common for dynamic languages, but it
    is remarkable for a statically compiled language. You can find it at [https://github.com/murarth/rusti](https://github.com/murarth/rusti).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave you an overview of Rust's characteristics, where Rust
    can be applied, and compared it to other languages. We made our first program,
    demonstrated how to build a project with Cargo, and gave you choices to make a
    more complete development environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look at variables and types and explore the important
    concept of mutability.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
