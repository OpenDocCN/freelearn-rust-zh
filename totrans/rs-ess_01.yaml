- en: Chapter 1. Starting with Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 从 Rust 开始
- en: Rust is a programming language that is developed by Mozilla Research and backed
    up by a big open source community. Its development started in 2006 by language
    designer Graydon Hoare. Mozilla began sponsoring it in 2009, and it was first
    presented officially in 2010\. The work on it went through a lot of iterations,
    culminating on May 15 2015 with the first stable production version 1.0.0, which
    was made by the Rust Project Developers who consisted of the Rust team at Mozilla
    and an open source community of over 900 contributors. Rust is based on clear
    and solid principles. It is a systems programming language, equaling C and C++
    in its capabilities. It rivals idiomatic C++ in speed, but it lets you work in
    a much safer way by forbidding the use of code that could cause program crashes
    due to memory problems. Moreover, Rust has the built-in functionality necessary
    for concurrent execution on multicore machines; it makes concurrent programming
    memory safe without garbage collection—it is the only language that does this.
    Rust also eliminates the corruption of shared data through concurrent access,
    also known as data races.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是由 Mozilla 研究室开发并由一个庞大的开源社区支持的一种编程语言。它的开发始于 2006 年，由语言设计者 Graydon Hoare
    开始。Mozilla 从 2009 年开始赞助它，并于 2010 年首次正式推出。该项目经过多次迭代，最终在 2015 年 5 月 15 日推出了第一个稳定的生产版本
    1.0.0，由 Rust 项目开发者制作，包括 Mozilla 的 Rust 团队和超过 900 名贡献者的开源社区。Rust 基于清晰和稳固的原则。它是一种系统编程语言，在能力上与
    C 和 C++ 相当。它在速度上与惯用的 C++ 相当，但它通过禁止使用可能导致程序因内存问题而崩溃的代码，让您以更安全的方式工作。此外，Rust 具有在多核机器上执行并发操作所需的内置功能；它通过垃圾回收使并发编程内存安全——这是唯一能做到这一点的语言。Rust
    还消除了通过并发访问导致的共享数据损坏，也称为数据竞争。
- en: This chapter will present you with the main reasons why Rust's popularity and
    adoption are steadily increasing. Then, we'll set up a working Rust development
    environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示 Rust 流行度和采用率稳步增长的主要原因。然后，我们将设置一个可工作的 Rust 开发环境。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The advantages of Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 的优势
- en: 'The trifecta of Rust: safety, speed, and concurrency'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 的三合一优势：安全性、速度和并发性
- en: Using Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust
- en: Installing Rust
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Rust
- en: The Rust compiler – `rustc`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust 编译器 – `rustc`
- en: Building our first program
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的第一个程序
- en: Working with Cargo
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cargo 进行工作
- en: Developer tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者工具
- en: The advantages of Rust
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的优势
- en: Mozilla is the company that is known for its mission to develop tools for and
    drive the evolution of the Web based on open standards, most notably through its
    flagship browser Firefox. Every browser today, including Firefox, is written in
    C++ by using some 12,900,992 lines of code for Firefox and 4,490,488 lines of
    code for Chrome. This enables programs to be fast, but it is inherently unsafe
    because the memory manipulations allowed by C and C++ are not checked for validity.
    If the code is written without the utmost programming discipline on the part of
    the developers, then program crashes, memory leaks, segmentation faults, buffer
    overflows, and null pointers can occur at program execution. Some of these can
    result in serious security vulnerabilities, which are all too well-known in existing
    browsers. Rust is designed from the ground up to avoid these kinds of problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 是一家以其使命为基础的公司，致力于开发基于开放标准的工具并推动 Web 的进化，最著名的是通过其旗舰浏览器 Firefox。如今，包括
    Firefox 在内的每个浏览器都是用 C++ 编写的，Firefox 使用了约 12,900,992 行代码，Chrome 使用了约 4,490,488
    行代码。这使得程序运行速度快，但本质上是不安全的，因为 C 和 C++ 允许的内存操作没有经过有效性检查。如果代码编写时开发者没有最严格的编程纪律，那么程序在执行时可能会出现崩溃、内存泄漏、段错误、缓冲区溢出和空指针等问题。其中一些可能导致严重的安全漏洞，这在现有的浏览器中是众所周知的。Rust
    从一开始就被设计用来避免这些问题。
- en: 'On the other side of the programming-language spectrum, we have Haskell, which
    is widely known to be a very safe and reliable language, but with very little
    or no control of the level of memory allocation and other hardware resources.
    We can plot different languages along this control—safety axis, and it seems that
    when a language is safer, it loses low-level control; the inverse is also true:
    a language that gives more control over resources provides much less safety, shown
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言谱系的另一端，我们有 Haskell，它广为人知是一个非常安全和可靠的语言，但几乎或完全没有对内存分配和其他硬件资源的控制。我们可以沿着这个控制-安全性轴绘制不同的语言，似乎当一种语言更安全时，它会失去底层控制；反之亦然：提供更多资源控制的语言提供的安全性更少，如下所示：
- en: '![The advantages of Rust](img/image00168.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Rust 的优势](img/image00168.jpeg)'
- en: 'Rust ([http://www.rust-lang.org/](http://www.rust-lang.org/)) is made to overcome
    this dilemma by providing the following features:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Rust ([http://www.rust-lang.org/](http://www.rust-lang.org/)) 是为了克服这一困境而设计的，它提供了以下特性：
- en: High safety through its strong type system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其强大的类型系统实现高安全性
- en: Deep but safe control over low-level resources (as much as C/C++) so that it
    runs close to the hardware
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对底层资源进行深入但安全的控制（与 C/C++ 相当），以便其运行接近硬件
- en: 'Rust lets you specify exactly how your values should be laid out in memory
    and how that memory should be managed; this is why it works well at both ends
    of the control and safety line. This is the unique selling point of Rust: it breaks
    the safety-control dichotomy that, before Rust, existed in programming languages.
    With Rust, control and safety can be achieved together without losing performance.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许你精确指定你的值在内存中的布局方式以及如何管理这些内存；这就是为什么它在控制和安全性的两端都表现得很好。这是 Rust 的独特卖点：它打破了在
    Rust 之前存在于编程语言中的安全-控制二分法。使用 Rust，可以在不牺牲性能的情况下同时实现控制和安全性。
- en: 'Rust can accomplish both these goals without a garbage collector, in contrast
    to most modern languages such as Java, C#, Python, Ruby, Go; in fact Rust doesn''t
    even have a garbage collector yet (though one is planned). Rust is a compiled
    language: the strict safety rules are enforced by the compiler so that they do
    not cause runtime overhead. As a consequence, Rust can work with minimal runtime
    or even no runtime at all; so, it can be used for real time or embedded projects,
    and it can easily integrate with other languages or projects.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数现代语言（如 Java、C#、Python、Ruby、Go）不同，Rust 可以在不使用垃圾回收器的情况下实现这两个目标；实际上，Rust 甚至还没有垃圾回收器（尽管计划中有一个）。Rust
    是一种编译型语言：严格的 safety 规则由编译器强制执行，因此不会造成运行时开销。因此，Rust 可以使用最少的运行时，甚至完全没有运行时；因此，它可以用于实时或嵌入式项目，并且可以轻松地与其他语言或项目集成。
- en: Rust is meant for developers and projects where not only performance and low-level
    optimizations are important, but where there is also a need for a safe and stable
    execution environment. Moreover, Rust adds a lot of high-level functional programming
    techniques within the language so that it feels like a low-level and a high-level
    language at the same time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 旨在为那些不仅重视性能和底层优化，而且还需要一个安全且稳定的执行环境的开发者和项目而设计。此外，Rust 在语言内部添加了许多高级函数式编程技术，因此它既感觉像是一种底层语言，又像是一种高级语言。
- en: The trifecta of Rust – safety, speed, and concurrency
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 的三合一优势——安全性、速度和并发性
- en: Rust is not a revolutionary language with new cutting-edge features, but it
    incorporates a lot of proven techniques from older languages while massively improving
    upon the design of C++ in matters of safe programming.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不是一个具有新尖端特性的革命性语言，但它从旧语言中吸收了许多经过验证的技术，同时在安全编程方面对 C++ 的设计进行了大量改进。
- en: The Rust developers designed Rust to be a general-purpose and multi-paradigm
    language. Like C++, it is an imperative, structured, and object-oriented language.
    Besides this, it inherits a lot from functional languages and also incorporates
    advanced techniques for concurrent programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 开发者设计 Rust 成为一个通用和多范式的语言。像 C++ 一样，它是一种命令式、结构化和面向对象的语言。除此之外，它还从函数式语言中继承了许多东西，并且还融合了并发编程的高级技术。
- en: In Rust, the typing of variables is static (because Rust is compiled) and strong.
    However, unlike Java or C++, the developer is not forced to indicate the types
    for everything as the Rust compiler is able to infer the types in many cases.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，变量的类型是静态的（因为 Rust 是编译型语言）且强类型。然而，与 Java 或 C++ 不同，开发者不需要强制为所有内容指定类型，因为
    Rust 编译器能够在许多情况下推断出类型。
- en: C and C++ are known to be haunted by a series of problems that often lead to
    program crashes or memory leaks which are notoriously difficult to debug and solve.
    Think about dangling pointers, buffer overflows, null pointers, segmentation faults,
    data races, and so on. The Rust compiler (called `rustc`) is very intelligent
    and can detect all these problems while compiling your code, thereby guaranteeing
    memory safety during execution. This is done by the compiler by retaining complete
    control over memory layout, without needing the runtime burden of garbage collection
    (see [Chapter 6](part0056.xhtml#aid-1LCVG2 "Chapter 6. Pointers and Memory Safety"),
    *Pointers and Memory Safety*). In addition, its safety also implies much less
    possibilities for security breaches.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 被认为是受一系列问题的困扰，这些问题经常导致程序崩溃或内存泄漏，这些问题的调试和解决特别困难。想想悬垂指针、缓冲区溢出、空指针、段错误、数据竞争等等。Rust
    编译器（称为 `rustc`）非常智能，可以在编译你的代码时检测到所有这些问题，从而在执行期间保证内存安全。这是通过编译器通过保留对内存布局的完全控制来实现的，无需运行时垃圾回收的负担（见
    [第 6 章](part0056.xhtml#aid-1LCVG2 "第 6 章。指针与内存安全")，*指针与内存安全*）。此外，其安全性还意味着更少的潜在安全漏洞。
- en: Rust compiles native code like Go and Julia. However, in contrast to these two,
    Rust doesn't need runtime with garbage collection. In this respect, it also differs
    from Java JVM and the languages that run on the JVM, such as Scala and Clojure.
    Most other popular modern languages such as .NET with C# and F#, JavaScript, Python,
    Ruby, Dart, and so on, all need a virtual machine and garbage collection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译原生代码的方式类似于 Go 和 Julia。然而，与这两种语言相比，Rust 不需要带有垃圾回收的运行时。在这方面，它也不同于 Java
    JVM 和在 JVM 上运行的语言，如 Scala 和 Clojure。大多数其他流行的现代语言，如 .NET 中的 C# 和 F#、JavaScript、Python、Ruby、Dart
    等等，都需要虚拟机和垃圾回收。
- en: As one of its mechanisms for concurrency, Rust adopts the well-known actor model
    from Erlang. Lightweight processes called threads perform work in parallel. They
    do not share heap memory but communicate data through channels, and data races
    are eliminated by the type system (see [Chapter 8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency
    and Parallelism"), *Concurrency and Parallelism*). These primitives make it easy
    for programmers to leverage the power of many CPU cores that are available on
    current and future computing platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其并发机制之一，Rust 采用了来自 Erlang 的知名 actor 模型。轻量级进程称为线程，并行执行工作。它们不共享堆内存，而是通过通道进行数据通信，并通过类型系统消除数据竞争（见
    [第 8 章](part0065.xhtml#aid-1TVKI2 "第 8 章。并发与并行")，*并发与并行*）。这些原语使得程序员能够利用当前和未来计算平台上可用的多个
    CPU 核心的强大功能。
- en: The `rustc` compiler is completely self hosted, which means that it is written
    in Rust and can compile itself by using a previous version. It uses the LLVM compiler
    framework as its backend (for more information on LLVM compiler framework, go
    to [http://en.wikipedia.org/wiki/LLVM](http://en.wikipedia.org/wiki/LLVM)) and
    produces natively executable code that runs blazingly fast because it compiles
    to the same low-level code as C++ (To see an example of its speed, go to [http://benchmarksgame.alioth.debian.org/u64q/rust.php](http://benchmarksgame.alioth.debian.org/u64q/rust.php).).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc` 编译器是完全自托管的，这意味着它是用 Rust 编写的，并且可以使用之前的版本来编译自身。它使用 LLVM 编译器框架作为其后端（有关
    LLVM 编译器框架的更多信息，请访问 [http://en.wikipedia.org/wiki/LLVM](http://en.wikipedia.org/wiki/LLVM)）并生成原生可执行代码，运行速度极快，因为它编译成与
    C++ 相同的低级代码（要查看其速度示例，请访问 [http://benchmarksgame.alioth.debian.org/u64q/rust.php](http://benchmarksgame.alioth.debian.org/u64q/rust.php)）。'
- en: 'Rust is designed to be as portable as C++ and run on widely used hardware and
    software platforms; at present, it runs on Linux, Mac OS X, Windows, FreeBSD,
    Android, and iOS. It can call C''s code as simply and efficiently as C can call
    its own code, and conversely, C can also call Rust code (see [Chapter 9](part0069.xhtml#aid-21PMQ1
    "Chapter 9. Programming at the Boundaries"), *Programming at the Boundaries*).
    The following is the logo of Rust:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 被设计成与 C++ 一样可移植，并能在广泛使用的硬件和软件平台上运行；目前，它可以在 Linux、Mac OS X、Windows、FreeBSD、Android
    和 iOS 上运行。它可以像 C 一样简单高效地调用 C 的代码，反之亦然，C 也可以调用 Rust 代码（见 [第 9 章](part0069.xhtml#aid-21PMQ1
    "第 9 章。边界编程")，*边界编程*）。以下是 Rust 的标志：
- en: '![The trifecta of Rust – safety, speed, and concurrency](img/image00169.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Rust 的三合一——安全性、速度和并发](img/image00169.jpeg)'
- en: 'Other Rust characteristics that will be discussed in more detail in later chapters
    are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中将更详细讨论的其他 Rust 特性如下：
- en: Its variables are immutable by default (see [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types*)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的变量默认是不可变的（参见[第 2 章](part0023.xhtml#aid-LTSU1 "第 2 章。使用变量和类型")，*使用变量和类型*）
- en: Enums (see [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring Data
    and Matching Patterns"), *Structuring Data and Matching Patterns*)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举（参见[第 4 章](part0038.xhtml#aid-147LC2 "第 4 章。结构化数据和匹配模式")，*结构化数据和匹配模式*）
- en: Pattern matching (see [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring
    Data and Matching Patterns"), *Structuring Data and Matching Patterns*)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配（参见[第 4 章](part0038.xhtml#aid-147LC2 "第 4 章。结构化数据和匹配模式")，*结构化数据和匹配模式*）
- en: Generics (see [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing
    Code with Higher-order Functions and Parametrization"), *Generalizing Code with
    Higher-order Functions and Parametrization*)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型（参见[第 5 章](part0046.xhtml#aid-1BRPS1 "第 5 章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码*）
- en: Higher-order functions and closures (see [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数和闭包（参见[第 5 章](part0046.xhtml#aid-1BRPS1 "第 5 章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码*）
- en: The interface system called traits (see [Chapter 5](part0046.xhtml#aid-1BRPS1
    "Chapter 5. Generalizing Code with Higher-order Functions and Parametrization"),
    *Generalizing Code with Higher-order Functions and Parametrization*)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语 traits 的接口系统（参见[第 5 章](part0046.xhtml#aid-1BRPS1 "第 5 章。使用高阶函数和参数化泛化代码")，*使用高阶函数和参数化泛化代码*）
- en: A hygienic macro system (see [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Organizing
    Code and Macros"), *Organizing Code and Macros*)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种卫生宏系统（参见[第 7 章](part0062.xhtml#aid-1R42S2 "第 7 章。组织代码和宏")，*组织代码和宏*）
- en: Zero-cost abstractions, which means that Rust has higher-language constructs,
    but these do not have an impact on performance
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零成本抽象，这意味着 Rust 具有高级语言结构，但这些结构不会对性能产生影响
- en: In conclusion, Rust gives you ultimate power over memory allocation as well
    as removing many security and stability problems that are commonly associated
    with native languages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Rust 让你能够对内存分配拥有终极控制权，同时消除了与本地语言通常相关的大量安全和稳定性问题。
- en: Comparison with other languages
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他语言的比较
- en: Dynamic languages such as Ruby or Python give you the initial coding speed,
    but you pay the price later when you have to write more tests, runtime crashes,
    or even production outages. The Rust compiler forces you to get a lot of things
    right at compile-time, which is the least expensive place to identify and fix
    bugs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 动态语言，如 Ruby 或 Python，可以提供初始的编码速度，但当你需要编写更多测试、运行时崩溃或甚至生产中断电时，你将付出代价。Rust 编译器迫使你在编译时正确处理很多事情，这是识别和修复错误成本最低的地方。
- en: Rust's object orientation is not that explicit or evolved as common object-oriented
    languages such as Java, C#, and Python as it doesn't have classes. Compared with
    Go, Rust gives you more control over memory and resources, so lets you code on
    a lower level. Go also works with a garbage collector, and it has no generics
    or a mechanism to prevent data races between its goroutines that are used in concurrency.
    Julia is focused on numerical computing performance; it works with a JIT compiler
    and doesn't give you that low-level control that Rust gives.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的面向对象特性不如 Java、C# 和 Python 等常见面向对象语言那样明确或成熟，因为它没有类。与 Go 相比，Rust 给你更多的内存和资源控制，因此让你能够在更低的级别上进行编码。Go
    也使用垃圾回收器，并且它没有泛型或防止其并发使用的 goroutines 之间数据竞争的机制。Julia 专注于数值计算性能；它与 JIT 编译器一起工作，并且不提供
    Rust 提供的那种低级别控制。
- en: Using Rust
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust
- en: 'It is clear from the previous sections that Rust can be used in projects that
    normally use C or C++. Indeed, many regard Rust as a successor or a replacement
    of C and C++. Although Rust is designed to be a systems language, it has a broad
    range of possible applications due to its richness of constructs, making it an
    ideal candidate for applications that fall into one or all of the following categories:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节中可以清楚地看出，Rust 可以用于通常使用 C 或 C++ 的项目中。事实上，许多人认为 Rust 是 C 和 C++ 的继任者或替代品。尽管
    Rust 被设计成一种系统语言，但由于其丰富的结构，它具有广泛的应用范围，使其成为以下类别之一或所有类别的理想候选：
- en: Client applications, such as browsers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端应用程序，如浏览器
- en: Low-latency, high-performance systems, such as device drivers, games, and signal
    processing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低延迟、高性能的系统，例如设备驱动程序、游戏和信号处理
- en: Highly distributed and concurrent systems, such as server applications
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度分布式和并发系统，例如服务器应用程序
- en: Real-time and critical systems, such as operating systems or kernels
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时和关键系统，例如操作系统或内核
- en: Embedded systems (that require a very minimal runtime footprint) or a resource-constrained
    environment, such as a Raspberry Pi, Arduino, or robotics
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式系统（需要非常小的运行时占用）或资源受限的环境，例如 Raspberry Pi、Arduino 或机器人
- en: Tools or services that can't support the long warm-up delays that are common
    in **Just In Time** (**JIT**) compiler systems and need instantaneous startup
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法支持在 **即时编译** (**JIT**) 系统中常见的长时间预热延迟的工具或服务，需要即时启动
- en: Web frameworks
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络框架
- en: Large-scale, high-performance, resource intensive, and complex software systems
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大规模、高性能、资源密集和复杂的软件系统
- en: 'Rust is especially suited when code quality is important, that is for:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 特别适合代码质量至关重要的场合，即：
- en: Modestly-sized or larger developer teams
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模适中或更大的开发者团队
- en: Code for long-running production use
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期运行的生产代码
- en: Code with a longer lifetime that requires regular maintenance and refactoring
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要定期维护和重构的具有较长生命周期的代码
- en: Code for which you would normally write a lot of unit tests to safeguard it
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你通常需要编写大量单元测试来保障其安全的代码
- en: 'Even before the appearance of Rust 1.0, two companies already use it in production:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 Rust 1.0 版本发布之前，已有两家公司已经开始在生产环境中使用它：
- en: OpenDNS ([http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/](http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/))
    is a middleware tool for blocking malware and malicious domains
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenDNS ([http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/](http://labs.opendns.com/2013/10/04/zeromq-helping-us-block-malicious-domains/))
    是一个用于阻止恶意软件和恶意域的中间件工具
- en: Skylight ([https://www.skylight.io/](https://www.skylight.io/)) from the company
    Tilde ([http://www.tilde.io/](http://www.tilde.io/)) is a tool for monitoring
    the execution of Rails apps.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Tilde ([http://www.tilde.io/](http://www.tilde.io/)) 公司的 Skylight ([https://www.skylight.io/](https://www.skylight.io/))
    是一个用于监控 Rails 应用程序执行的工具。
- en: Servo
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Servo
- en: Mozilla uses Rust as the language for writing Servo, its new web browser engine
    that is designed for parallelism and safety ([https://github.com/servo/servo](https://github.com/servo/servo)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 使用 Rust 作为其新网络浏览器引擎 Servo 的编程语言，该引擎旨在实现并行性和安全性（[https://github.com/servo/servo](https://github.com/servo/servo)）。
- en: Due to the design of Rust's compiler, many kinds of browser security bugs are
    prevented automatically. In 2013, Samsung got involved, porting Servo to Android
    and ARM processors. Servo itself is an open source project with more than 200
    contributors. It is under heavy development, and among other things, it has already
    implemented its own CSS3 and HTML5 parser in Rust. It passed the web compatibility
    browser test ACID2 in March 2014 ([http://en.wikipedia.org/wiki/Acid2/](http://en.wikipedia.org/wiki/Acid2/)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Rust 编译器的设计，许多种类的浏览器安全漏洞被自动预防。2013年，三星公司介入，将 Servo 移植到 Android 和 ARM 处理器上。Servo
    本身是一个拥有超过200位贡献者的开源项目。它正在积极开发中，并且已经实现了自己的 CSS3 和 HTML5 解析器，使用 Rust 编写。它在2014年3月通过了
    ACID2 网络兼容性浏览器测试（[http://en.wikipedia.org/wiki/Acid2/](http://en.wikipedia.org/wiki/Acid2/))）。
- en: Installing Rust
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rust
- en: The Rust compiler and tools can be downloaded from [http://www.rust-lang.org/install.html](http://www.rust-lang.org/install.html)
    in the binary (that is, executable) form. The platform comes for the three major
    operating systems (Linux 2.6.18 or a later version, OS X 10.7 or a later version,
    and Windows 7, Windows 8, and Windows Server 2008 R2) in both the 32- and 64-bit
    formats, and it is delivered as an installer or in an archive format. You should
    use the current official stable release 1.0 when you engage in professional work
    with Rust. If you would like to investigate or use the latest developments, install
    the nightly build version.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器和工具可以从 [http://www.rust-lang.org/install.html](http://www.rust-lang.org/install.html)
    以二进制（即可执行）形式下载。该平台适用于三大主流操作系统（Linux 2.6.18或更高版本、OS X 10.7或更高版本以及 Windows 7、Windows
    8 和 Windows Server 2008 R2），提供32位和64位格式，并以安装程序或存档格式提供。当你使用 Rust 进行专业工作时，应使用当前官方稳定版本
    1.0。如果你想要调查或使用最新发展，请安装夜间构建版本。
- en: For Windows, double-click on the `.exe` installer to install the Rust binaries
    and dependencies. Adding Rust's directory to the search path for executables is
    an optional part of the installation, so make sure that this option is selected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，双击`.exe`安装程序来安装Rust的二进制文件和依赖项。将Rust的目录添加到可执行文件的搜索路径是安装过程中的一个可选部分，因此请确保已选择此选项。
- en: 'For Linux and Mac OS X, the simplest way is to run the following command in
    your shell:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux和Mac OS X，最简单的方法是在您的shell中运行以下命令：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Verify the correctness of the installation by showing Rust's version with `rustc
    –V` or `rustc - -version`, which produces an output like `rustc 1.0.0-beta (9854143cb
    2015-04-02) (built 2015-04-02)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`rustc –V`或`rustc - -version`来显示Rust的版本，以验证安装的正确性，这将产生类似`rustc 1.0.0-beta
    (9854143cb 2015-04-02) (built 2015-04-02)`的输出。
- en: Rust can be uninstalled by running `C:\Rust\unins001.exe` on Windows or `/usr/local/lib/rustlib/uninstall.sh`
    on Linux.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，可以通过运行`C:\Rust\unins001.exe`来卸载Rust，或在Linux上运行`/usr/local/lib/rustlib/uninstall.sh`。
- en: Rust has also been ported to Android OS on ARM processors and iOS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也已移植到基于ARM处理器的Android操作系统和iOS。
- en: A bare metal stack called zinc for running Rust in embedded environments can
    be found at [http://zinc.rs/](http://zinc.rs/). However, at this moment, only
    the ARM architecture is supported by it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为zinc的裸机栈，用于在嵌入式环境中运行Rust，可以在[http://zinc.rs/](http://zinc.rs/)找到。然而，目前它只支持ARM架构。
- en: The source code resides on GitHub ([https://github.com/rust-lang/rust/](https://github.com/rust-lang/rust/))
    and if you want to build Rust from source, we refer you to [https://github.com/rust-lang/rust#building-from-source](https://github.com/rust-lang/rust#building-from-source).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码位于GitHub上([https://github.com/rust-lang/rust/](https://github.com/rust-lang/rust/))，如果您想从源代码构建Rust，我们建议您参考[https://github.com/rust-lang/rust#building-from-source](https://github.com/rust-lang/rust#building-from-source)。
- en: The Rust compiler – rustc
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust编译器 – rustc
- en: 'The Rust installation directory containing `rustc` can be found on your machine
    in the following folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Rust安装目录中包含`rustc`的文件夹可以在您的机器上的以下位置找到：
- en: In Windows, at `C:\Program Files\Rust 1.0\bin` or a folder of your choice
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，在`C:\Program Files\Rust 1.0\bin`或您选择的文件夹中
- en: On Linux or Mac OS X, it can be found by navigating to `/usr/local/bin`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux或Mac OS X上，可以通过导航到`/usr/local/bin`来找到。
- en: If the Rust home folder was added to the search path for executables, `rustc`
    can be run from any command-line window. The Rust libraries can be found in the
    `rustlib` subfolder of the `bin` directory on Windows, or in `/usr/local/lib/rustlib`
    on Linux. Its HTML documentation can be found at `C:\Rust\share\doc\rust\html`
    on Windows or `/usr/local/share/doc/html` on Linux.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将Rust的主文件夹添加到可执行文件的搜索路径中，则可以从任何命令行窗口运行`rustc`。Rust库可以在Windows上`bin`目录的`rustlib`子目录中找到，或在Linux上的`/usr/local/lib/rustlib`中。其HTML文档可以在Windows上的`C:\Rust\share\doc\rust\html`或Linux上的`/usr/local/share/doc/html`找到。
- en: 'The `rustc` command has the following format: `rustc [options] input`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc`命令的格式如下：`rustc [选项] 输入`。'
- en: The options are one letter directives for the compiler after a dash, such as
    `-g` or `-W`, or words prefixed by a double dash, such as `- -test` or `- -no-analysis`.
    All the options with some explanation are shown when invoking `rustc -h`. In the
    next section, we will verify our installation by compiling and running our first
    Rust program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是编译器后面的单个字母指令，例如`-g`或`-W`，或者以双横线为前缀的单词，例如`- -test`或`- -no-analysis`。在调用`rustc
    -h`时，将显示所有带有解释的选项。在下一节中，我们将通过编译和运行我们的第一个Rust程序来验证我们的安装。
- en: Our first program
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一款程序
- en: 'Let''s get started by showing a welcome message to the players of our game:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的游戏玩家显示欢迎信息开始：
- en: 'Open your favorite text editor (such as notepad or gedit) for a new file and
    type in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的文本编辑器（如记事本或gedit）创建一个新文件，并输入以下代码：
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the file as `welcome.rs`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为`welcome.rs`。
- en: '`rs` is the standard extension of Rust code files. Source file names may not
    contain spaces; if they contain more than one word, use an underscore `_` as a
    separator; for example, `start_game.rs`.'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rs`是Rust代码文件的标准扩展名。源文件名不得包含空格；如果包含多个单词，请使用下划线`_`作为分隔符；例如，`start_game.rs`。'
- en: 'Then, compile it to native code on the command line with the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令在命令行上将其编译为本地代码：
- en: '[PRE2]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This produces an executable program `welcome.exe` on Windows or `welcome` on
    Linux.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在Windows上产生一个名为`welcome.exe`的可执行程序，或在Linux上产生名为`welcome`的程序。
- en: 'Run this program with `welcome` or `./welcome` to get the following output:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`welcome`或`./welcome`运行此程序，以获取以下输出：
- en: '[PRE3]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output executable gets its name from the source file. If you want to give
    the executable another name, such as `start`, compile it with the `-o output_name`
    option:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可执行文件的名字来自源文件。如果你想给可执行文件另一个名字，比如 `start`，可以用 `-o output_name` 选项编译它：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `rustc –O` command produces a native code that is optimized for execution
    speed (which is equivalent to `rustc -C opt-level=2`; the most optimized code
    is generated for `rustc –C opt-level = 3`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`rustc –O` 命令生成针对执行速度优化的本地代码（这相当于 `rustc -C opt-level=2`；最优化代码是在 `rustc –C
    opt-level = 3` 时生成的）。'
- en: Compiling and running are separate, consecutive steps, contrary to dynamic languages
    such as Ruby or Python where these are performed in one step.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行是分开的、连续的步骤，这与 Ruby 或 Python 等动态语言不同，在这些语言中这些步骤是在一个步骤中完成的。
- en: Let's explain the code a bit to you. If you have already worked in a C/Java/C#
    like environment, this code will seem quite familiar. As in most languages, execution
    of the code starts in a `main()` function, which is mandatory in an executable
    program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下这段代码。如果你已经在 C/Java/C# 等环境中工作过，这段代码看起来会很熟悉。就像大多数语言一样，代码的执行从 `main()`
    函数开始，在可执行程序中这是强制性的。
- en: In a larger project with many source files, the file containing the `main()`
    function would be called `main.rs` by convention.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个包含许多源文件的大型项目中，包含 `main()` 函数的文件按照惯例会被命名为 `main.rs`。
- en: We can see that `main()` is a function declaration because it is preceded by
    the keyword `fn`, which is short and elegant like most Rust keywords. `()` after
    main denotes the parameter list, which is empty here. The function's code is placed
    in a code block, which is surrounded by curly braces (`{ }`) where the opening
    brace is put by convention on the same line as the function declaration, but it
    is separated by one space. The closing brace appears after the code here, right
    beneath `fn`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `main()` 是一个函数声明，因为它前面有关键字 `fn`，这就像大多数 Rust 关键字一样简短而优雅。`main()` 后面的 `()`
    表示参数列表，这里为空。函数的代码放置在代码块中，代码块由花括号 (`{ }`) 包围，其中开括号按照惯例放在与函数声明相同的行上，但与函数声明之间有一个空格。闭括号出现在这里的代码之后，紧接在
    `fn` 下方。
- en: Our program has only one line, which is indented by four spaces to improve readability
    (Rust is not whitespace sensitive). This line prints the string, "Welcome to the
    Game!". Rust recognizes this as a string because it is surrounded by double quotes
    (`" "`). This string was given as an argument to the `println!` macro (`!` indicates
    that it is a macro and not a function). The code line ends with a semicolon (`;`),
    as most, but not all, code lines in Rust do (see [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序只有一行，缩进四个空格以提高可读性（Rust 不对空白敏感）。这一行打印字符串 "欢迎来到游戏！"。Rust 将其识别为字符串，因为它被双引号
    (`" "`）包围。这个字符串被作为 `println!` 宏的参数传递（`!` 表示这是一个宏而不是函数）。代码行以分号 (`;`）结尾，就像 Rust
    中的大多数代码行一样（参见[第 2 章](part0023.xhtml#aid-LTSU1 "第 2 章。使用变量和类型")，*使用变量和类型*）。
- en: 'Perform the following exercises:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: Write, compile, and execute a Rust program `name.rs` that prints out your name.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写、编译并执行一个名为 `name.rs` 的 Rust 程序，该程序打印出你的名字。
- en: What is the smallest possible program in Rust in terms of code size?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中，就代码大小而言，最小的可能程序是什么？
- en: The `println!` macro has some nice formatting capabilities and at the same time
    checks when compiling whether the type of variables is correct for the applied
    formatting (see [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using Variables
    and Types"), *Using Variables and Types*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 宏有一些很好的格式化功能，同时它在编译时检查变量的类型是否适用于应用的格式化（参见[第 2 章](part0023.xhtml#aid-LTSU1
    "第 2 章。使用变量和类型")，*使用变量和类型*）。'
- en: Working with Cargo
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cargo
- en: Cargo is Rust's package and dependency manager, and it is similar to Bundler,
    npm, pub, or pip for other languages. Although you can write Rust programs without
    it, Cargo is nearly indispensable for any large project; it works the same whether
    you work on a Windows, Linux, or a Mac OS X system. The installation procedure
    from the previous section includes the Cargo tool, so Rust is shipped with tooling
    included.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 是 Rust 的包和依赖管理器，它类似于其他语言的 Bundler、npm、pub 或 pip。尽管你可以不使用 Cargo 编写 Rust
    程序，但对于任何大型项目来说，Cargo 几乎是必不可少的；无论你在 Windows、Linux 还是 Mac OS X 系统上工作，Cargo 都能正常工作。上一节的安装过程包括了
    Cargo 工具，因此 Rust 随工具一起提供。
- en: 'Cargo does the following things for you:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 为你做了以下事情：
- en: It makes a tidy folder structure and some templates for your project with the
    `cargo new` command
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cargo new`命令为你的项目创建一个整洁的文件夹结构和一些模板：
- en: It compiles (builds) your code by using the `cargo build` command
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cargo build`命令编译（构建）你的代码：
- en: It runs your project by using `cargo run`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过使用`cargo run`运行你的项目：
- en: If your project contains unit tests, it can execute them for you by using `cargo
    test`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目包含单元测试，它可以使用`cargo test`为你执行它们：
- en: If your project depends on packages, it will download them and build these packages
    according to the needs of your code by using `cargo update`
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目依赖于包，它将下载它们，并使用`cargo update`根据你的代码需求构建这些包：
- en: 'We''ll introduce how to use Cargo now, and we''ll come back to it later, but
    you can find more info here: [http://doc.crates.io/guide.html](http://doc.crates.io/guide.html).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍如何使用Cargo，稍后我们会回到这个话题，但你可以在这里找到更多信息：[http://doc.crates.io/guide.html](http://doc.crates.io/guide.html)。
- en: 'Let''s remake our first project `welcomec` using Cargo by performing the following
    steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤使用Cargo重新制作我们的第一个项目`welcomec`：
- en: 'Start a new project `welcomec` using the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动一个新的项目`welcomec`：
- en: '[PRE5]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `––bin` option tells Cargo that we want to make an executable program (a
    binary). This creates the following directory structure:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`--bin`选项告诉Cargo我们想要制作一个可执行程序（二进制文件）。这创建了以下目录结构：'
- en: '![Working with Cargo](img/image00170.jpeg)'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![与Cargo一起工作](img/image00170.jpeg)'
- en: A folder with the same name as the project is created; in this folder, you can
    put all kinds of general information such as a `License` file, a `README` file,
    and so on. In addition, a `src` subfolder is created that contains a template
    source file named `main.rs`. (This contains the same code as our `welcome.rs`
    file, but it prints out the string "Hello world!".)
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建了一个与项目同名的文件夹；在这个文件夹中，你可以放置各种通用信息，例如`License`文件、`README`文件等。此外，还创建了一个名为`src`的子文件夹，其中包含一个名为`main.rs`的模板源文件。（这包含与我们的`welcome.rs`文件相同的代码，但它会打印出字符串"Hello
    world!"）
- en: 'The file `Cargo.toml` (with capital C) is the configuration file or manifest
    of your project; it contains all the metadata that Cargo needs to compile your
    project. It follows the so-called TOML format (for more details about this format,
    go to [https://github.com/toml-lang/toml](https://github.com/toml-lang/toml))
    and contains the following text with information about our project:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件`Cargo.toml`（首字母大写C）是项目的配置文件或清单；它包含Cargo编译项目所需的所有元数据。它遵循所谓的TOML格式（有关此格式的更多详细信息，请访问[https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)）并包含有关我们项目的以下文本：
- en: '[PRE6]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This file is editable, so other sections can be added. For example, you can
    add a section to tell Cargo that we want a binary with the name welcome:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件是可编辑的，因此可以添加其他部分。例如，你可以添加一个部分来告诉Cargo我们想要一个名为welcome的二进制文件：
- en: '[PRE7]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can build our project (no matter how many source files it contains) using
    the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令构建我们的项目（无论它包含多少源文件）：
- en: '[PRE8]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives us the following output (on Linux):'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们以下输出（在Linux上）：
- en: '[PRE9]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, the following folder structure is produced:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，产生了以下文件夹结构：
- en: '![Working with Cargo](img/image00171.jpeg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![与Cargo一起工作](img/image00171.jpeg)'
- en: The directory target contains the executable `welcome`.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目录`target`包含可执行文件`welcome`。
- en: 'To execute this program, run the following command:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行此程序，请运行以下命令：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This produces the following output:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Step 2 has also produced a file named `Cargo.lock`; this is used by Cargo to
    keep track of dependencies in your application. At the moment, the application
    only contains:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步还产生了一个名为`Cargo.lock`的文件；这个文件被Cargo用来跟踪应用程序中的依赖关系。目前，应用程序只包含：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The same file format is used to lock down the versions of libraries or packages
    that your project depends on. If your project is built in the future when updated
    versions of the libraries are available, Cargo will make sure that only the versions
    recorded in `Cargo.lock` are used so that your project is not built with an incompatible
    version of a library. This ensures a repeatable build process.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的文件格式锁定你的项目所依赖的库或包的版本。如果你的项目在将来构建时可用更新版本的库，Cargo将确保只使用记录在`Cargo.lock`中的版本，这样你的项目就不会使用与库不兼容的版本构建。这确保了可重复的构建过程。
- en: 'Perform the following exercise:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: Make, build, and run a project `name` that prints out your name with Cargo.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cargo制作、构建并运行一个名为`name`的项目，该项目会打印出你的名字。
- en: 'The website at [https://crates.io/](https://crates.io/) is the central repository
    for Rust packages or crates (as they are called) and contained 1700 crates as
    of the end of March 2015\. You can search for crates using specific terms or browse
    them alphabetically or according to the number of downloads:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://crates.io/](https://crates.io/)网站是Rust包或crate（它们被称为）的中心仓库，截至2015年3月底，包含1700个crate。你可以使用特定术语搜索crate，或者按字母顺序或下载量浏览它们：'
- en: '![Working with Cargo](img/image00172.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![使用Cargo](img/image00172.jpeg)'
- en: The developer tools
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者工具
- en: Since Rust is a systems programming language, the only thing that you need is
    a good text editor (but not a word processor!) for writing the source code, and
    everything else can be done by commands in a terminal session. However, some developers
    appreciate the functionalities offered by more fully fledged text editors which
    are specifically for programming or IDE's (short for integrated development environments).
    Rust is still young but a lot of possibilities have already come up on this front
    although some of them need to be updated in the latest Rust version.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Rust是一种系统编程语言，你唯一需要的是一款好的文本编辑器（但不是文字处理器！）来编写源代码，其余所有事情都可以通过终端会话中的命令来完成。然而，一些开发者欣赏那些专为编程或IDE（集成开发环境）设计的更全面的文本编辑器提供的功能。尽管一些功能需要更新到最新的Rust版本，但Rust仍然很年轻，在这一领域已经出现了很多可能性。
- en: Rust plugins exist for a host of text editors, such as Atom, Brackets, BBEdit,
    Emacs, Geany, GEdit, Kate, TextMate, Textadept, Vim, NEdit, Notepad++, and SublimeText.
    Most Rust developers work with Vim or Emacs. These come with a syntax highlighting,
    and code completion tool called racer; go to [https://github.com/phildawes/racer](https://github.com/phildawes/racer).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Rust插件适用于众多文本编辑器，例如Atom、Brackets、BBEdit、Emacs、Geany、GEdit、Kate、TextMate、Textadept、Vim、NEdit、Notepad++和SublimeText。大多数Rust开发者使用Vim或Emacs。这些编辑器自带语法高亮和代码补全工具racer；请访问[https://github.com/phildawes/racer](https://github.com/phildawes/racer)。
- en: Using Sublime Text
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sublime Text
- en: The plugins for the popular Sublime Text editor ([http://www.sublimetext.com/3](http://www.sublimetext.com/3))
    are particularly pleasant to work with, and they don't get in your way. After
    you have installed Sublime Text (you might want to get a registered version),
    you must also install the Package Control package. (For instructions on how to
    do this, go to [https://packagecontrol.io/installation](https://packagecontrol.io/installation)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于流行的Sublime Text编辑器（[http://www.sublimetext.com/3](http://www.sublimetext.com/3)）的插件特别易于使用，并且不会妨碍你。安装Sublime
    Text（你可能想要获取一个注册版本）后，你还必须安装Package Control包。（有关如何操作的说明，请访问[https://packagecontrol.io/installation](https://packagecontrol.io/installation)）。
- en: 'Then, to install the Sublime Text Rust plugin, open the palette in Sublime
    Text (*Ctrl* + *Shift* + *P* or *cmd* + *Shift* + *P* on Mac OS X) and select
    **Package Control** | **Install Package**. Then, select **Rust** from the list,
    you will see something like the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要安装Sublime Text的Rust插件，在Sublime Text中打开调色板（*Ctrl* + *Shift* + *P*或在Mac OS
    X上为*cmd* + *Shift* + *P*）并选择**Package Control** | **Install Package**。然后，从列表中选择**Rust**，你将看到如下截图：
- en: '![Using Sublime Text](img/image00173.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用Sublime Text](img/image00173.jpeg)'
- en: 'Sublime Text is a very comprehensive text editor, which includes color schemes.
    The Rust plugin provides syntax highlighting and auto-completion. Type one or
    more letters, choose an option from the list that appears with an arrow key and
    press *Tab* to insert the code snippet, or simply select a list-option through
    a mouse click. To compile and execute Rust code, follow these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Sublime Text是一个非常全面的文本编辑器，它包括配色方案。Rust插件提供语法高亮和自动补全。输入一个或多个字母，使用箭头键从出现的列表中选择一个选项，然后按*Tab*键插入代码片段，或者通过鼠标点击简单地选择列表选项。要编译和执行Rust代码，请按照以下步骤操作：
- en: Mark **Tools** | **Build System** | **Rust** in the menu.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中标记**工具** | **构建系统** | **Rust**。
- en: Then, you can compile a source file by pressing *Ctrl* + *B*. Warnings or errors
    will appear in the lower pane; if everything is okay, a message similar to **[Finished
    in 0.6s]** will appear.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过按*Ctrl* + *B*来编译源文件。警告或错误将出现在下方的面板中；如果一切正常，将出现类似于**[完成耗时0.6秒]**的消息。
- en: 'Then, you can run the program by pressing *Ctrl* + *Shift* + *B*; again the
    output will appear beneath the code. Alternatively, you can use the menu items:
    **Tools** | **Build** and **Tools** | **Run**.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过按*Ctrl* + *Shift* + *B*来运行程序；输出将再次出现在代码下方。或者，你可以使用菜单项：**工具** | **构建**和**工具**
    | **运行**。
- en: A SublimeLinter plugin exists that provides an interface to rustc, which is
    called `SublimeLinter-contrib-rustc`. It does additional checks on your code for
    stylistic or programming errors. You can install it, as explained earlier, through
    Package Control and then use it from the menu **Tools** | **SublimeLinter**. (For
    more details, go to [https://github.com/oschwald/SublimeLinter-contrib-rustc](https://github.com/oschwald/SublimeLinter-contrib-rustc).)
    There is also a code completion tool called *racer*; you can find the information
    on how to install it at [https://packagecontrol.io/packages/RustAutoComplete](https://packagecontrol.io/packages/RustAutoComplete).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个 SublimeLinter 插件，它提供了一个到 rustc 的接口，称为 `SublimeLinter-contrib-rustc`。它对您的代码进行额外的检查，以发现风格或编程错误。您可以通过
    Package Control 如前所述安装它，然后从菜单 **工具** | **SublimeLinter** 使用它。（有关更多详细信息，请访问 [https://github.com/oschwald/SublimeLinter-contrib-rustc](https://github.com/oschwald/SublimeLinter-contrib-rustc)。）还有一个名为
    *racer* 的代码补全工具；您可以在 [https://packagecontrol.io/packages/RustAutoComplete](https://packagecontrol.io/packages/RustAutoComplete)
    上找到如何安装它的信息。
- en: Other tools
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他工具
- en: '*RustDT* ([http://rustdt.github.io/](http://rustdt.github.io/)) is a new and
    promising Rust IDE based on Eclipse. On top of all the editing functionality offered
    by Eclipse, it is project-based using Cargo. Moreover it has code completion and
    debugging functionality (using the GDB debugger).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*RustDT* ([http://rustdt.github.io/](http://rustdt.github.io/)) 是一个基于 Eclipse
    的新兴且有潜力的 Rust IDE。除了 Eclipse 提供的所有编辑功能外，它还基于 Cargo 进行项目开发。此外，它还具有代码补全和调试功能（使用
    GDB 调试器）。'
- en: 'There are also plugins such as the following ones for IDEs at different states
    of completion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有以下这些插件，用于不同完成状态的 IDE：
- en: The *RustyCage* plugin ([https://github.com/reidarsollid/RustyCage](https://github.com/reidarsollid/RustyCage))
    for Eclipse
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RustyCage* 插件 ([https://github.com/reidarsollid/RustyCage](https://github.com/reidarsollid/RustyCage))
    用于 Eclipse'
- en: The *idea-rust* plugin ([http://plugins.jetbrains.com/plugin/7438](http://plugins.jetbrains.com/plugin/7438))
    for IntelliJ
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*idea-rust* 插件 ([http://plugins.jetbrains.com/plugin/7438](http://plugins.jetbrains.com/plugin/7438))
    用于 IntelliJ'
- en: The *rust-netbeans* plugin ([https://github.com/azazar/rust-netbeans](https://github.com/azazar/rust-netbeans))
    for NetBeans
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*rust-netbeans* 插件 ([https://github.com/azazar/rust-netbeans](https://github.com/azazar/rust-netbeans))
    用于 NetBeans'
- en: The *VisualRust* plugin (*https://github.com/PistonDevelopers/VisualRust*) for
    Visual Studio
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VisualRust* 插件 (*https://github.com/PistonDevelopers/VisualRust*) 用于 Visual
    Studio'
- en: 'You can test out the Rust code even without local installation with the Rust
    Play Pen: [http://play.rust-lang.org/](http://play.rust-lang.org/). Here you can
    edit or paste your code, and evaluate it.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至无需本地安装即可测试 Rust 代码，使用 Rust Play Pen：[http://play.rust-lang.org/](http://play.rust-lang.org/)。在这里，您可以编辑或粘贴代码，并对其进行评估。
- en: The *rusti* is an interactive shell or **Read-Evaluate-Print-Loop** (**REPL**)
    that is being developed for Rust; this is common for dynamic languages, but it
    is remarkable for a statically compiled language. You can find it at [https://github.com/murarth/rusti](https://github.com/murarth/rusti).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*rusti* 是一个交互式外壳或 **读取-评估-打印-循环** (**REPL**)，它正在为 Rust 开发；这对于动态语言来说是常见的，但对于静态编译语言来说则非常引人注目。您可以在
    [https://github.com/murarth/rusti](https://github.com/murarth/rusti) 找到它。'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gave you an overview of Rust's characteristics, where Rust
    can be applied, and compared it to other languages. We made our first program,
    demonstrated how to build a project with Cargo, and gave you choices to make a
    more complete development environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为您概述了 Rust 的特性，Rust 的应用场景，并将其与其他语言进行了比较。我们编写了第一个程序，演示了如何使用 Cargo 构建项目，并为您提供了构建更完整开发环境的选择。
- en: In the next chapter, we look at variables and types and explore the important
    concept of mutability.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨变量和类型，并探讨可变性的重要概念。
