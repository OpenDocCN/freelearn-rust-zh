- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Processing HTTP Requests
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 请求
- en: Up to this point, we have utilized the Actix Web framework to serve basic views.
    However, this can only get us so far when it comes to extracting data from the
    request and passing data back to the user. In this chapter, we will fuse code
    from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039)*, Designing Your Web Application
    in Rust*, and [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP
    Requests*, to build server views that process to-do items. We will then explore
    **JSON serialization** for extracting data and returning it to make our views
    more user friendly. We will also extract data from the header with middleware
    before it hits the view. We will explore the concepts around data serialization
    and extracting data from requests by building out the create, edit, and delete
    to-do item endpoints for our to-do application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经利用 Actix Web 框架来提供基本视图。然而，当涉及到从请求中提取数据并将数据返回给用户时，这只能让我们走这么远。在本章中，我们将融合来自
    [*第 2 章*](B18722_02.xhtml#_idTextAnchor039)*，在 Rust 中设计您的 Web 应用程序* 和 [*第 3 章*](B18722_03.xhtml#_idTextAnchor059)*，*处理
    HTTP 请求* 的代码，以构建处理待办事项的服务器视图。然后我们将探索 **JSON 序列化** 以提取数据并将其返回，使我们的视图更加用户友好。我们还将使用中间件在数据到达视图之前从头部提取数据。我们将通过构建待办应用程序的创建、编辑和删除待办事项端点来探索围绕数据序列化和从请求中提取数据的概念。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Getting to know the initial setup for fusing code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解融合代码的初始设置
- en: Passing parameters into views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数传递到视图中
- en: Using macros for JSON serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏进行 JSON 序列化
- en: Extracting data from views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从视图中提取数据
- en: Once you have finished this chapter, you will be able to build a basic Rust
    server that can send and receive data in the URL, in the body using JSON, and
    in the header of the HTTP request. This is essentially a fully functioning API
    Rust server without a proper database for data storage, the ability to authenticate
    users, or the ability to display content in the browser. However, these concepts
    will be covered in the next three chapters. You are on the home run for having
    a fully working Rust server that is up and running. Let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成本章，您将能够构建一个基本的 Rust 服务器，该服务器可以在 URL 中发送和接收数据，在 JSON 主体中，以及在 HTTP 请求的头部。这本质上是一个完全功能的
    API Rust 服务器，没有用于数据存储的数据库，没有用户认证的能力，也没有在浏览器中显示内容的能力。然而，这些概念将在接下来的三个章节中介绍。您已经拥有一个完全工作的
    Rust 服务器，它正在运行。让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we need to download and install **Postman**. We will need
    Postman to make API requests to our server. You can download it from [https://www.postman.com/downloads/](https://www.postman.com/downloads/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要下载并安装 **Postman**。我们将需要 Postman 来向我们的服务器发送 API 请求。您可以从 [https://www.postman.com/downloads/](https://www.postman.com/downloads/)
    下载它。
- en: We will also be building on the server code we created in the previous chapter,
    which can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将基于上一章中创建的服务器代码进行构建，该代码可在 [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app)
    找到。
- en: 'You can find the full source code that will be used in this chapter here: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章将使用的完整源代码：[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04)。
- en: Managing views code will be the basis of this chapter, and we will add features
    to this code base. We will be fusing this with the to-do module that we wrote
    in [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039), *Designing Your Web Application
    in Rust*, which can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 管理视图代码将是本章的基础，我们将向此代码库添加功能。我们将将其与我们在[*第 2 章*](B18722_02.xhtml#_idTextAnchor039)，*使用
    Rust 设计您的 Web 应用程序*中编写的 to-do 模块融合，该模块可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs)找到。
- en: Getting to know the initial setup for fusing code
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解融合代码的初始设置
- en: 'In this section, we will cover the initial setup of two fusing pieces of code
    we built in [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039), *Designing Your Web
    Application in Rust*, and [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling
    HTTP Requests*. This fusion will give us the following structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们在[*第 2 章*](B18722_02.xhtml#_idTextAnchor039)，*使用 Rust 设计您的 Web 应用程序*和[*第
    3 章*](B18722_03.xhtml#_idTextAnchor059)，*处理 HTTP 请求*中构建的两个融合代码片段的初始设置。这种融合将给我们以下结构：
- en: '![Figure 4.1 – Structure of our app and its modules](img/Figure_4.1_B18722.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 我们的应用及其模块的结构](img/Figure_4.1_B18722.jpg)'
- en: Figure 4.1 – Structure of our app and its modules
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 我们的应用及其模块的结构
- en: 'Here, we will register all the modules in the main file and then pull all these
    modules into the views to be used. We are essentially swapping the command-line
    interface from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039), *Designing Your
    Web Application in Rust*, with web views. Combining these modules gives us the
    following files in the code base:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将注册主文件中的所有模块，然后将所有这些模块拉入要使用的视图。我们实际上是在将[*第 2 章*](B18722_02.xhtml#_idTextAnchor039)，*使用
    Rust 设计您的 Web 应用程序*中的命令行界面与网页视图相结合。结合这些模块，代码库中给出了以下文件：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are then bolting our `to_do` module into the same directory of our `main.rs`
    file. If you built the `to_do` module when reading [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039),
    *Designing Your Web Application in Rust*, your `to_do` module should have the
    following structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`to_do`模块绑定到与我们的`main.rs`文件相同的目录中。如果你在阅读[*第 2 章*](B18722_02.xhtml#_idTextAnchor039)，*使用
    Rust 设计您的 Web 应用程序*时构建了`to_do`模块，那么你的`to_do`模块应该具有以下结构：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So now, our bolt on the `views` module from the previous chapter should contain
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们从上一章的`views`模块中添加的bolt应该包含以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The full structure, with all the code, can be found in the following GitHub
    repo:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码的完整结构可以在以下 GitHub 仓库中找到：
- en: '[https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup](https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup](https://github.com/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup)'
- en: )
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Now that we have added modules from previous chapters to our project, we can
    bind them together in our program. To do this, we must create a new `src/main.rs`
    file. First, we must import the modules that we built and define a basic server
    using the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将上一章的模块添加到我们的项目中，我们可以在程序中将它们绑定在一起。为此，我们必须创建一个新的`src/main.rs`文件。首先，我们必须导入我们构建的模块，并使用以下代码定义一个基本的服务器：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we defined the modules and then our server. Because the
    server is utilizing `views_factory`, we will not have to alter this file for the
    rest of this chapter. Instead, we will chain our factory functions that will be
    called in the `views_factory` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了模块，然后是我们的服务器。因为服务器正在使用`views_factory`，所以我们不需要在本章的其余部分修改此文件。相反，我们将链式调用在`views_factory`函数中调用的工厂函数。
- en: 'At this point, we can sit back and appreciate the dividends of all the hard
    work that we did in the previous chapters. The isolation of principles and well-defined
    modules have enabled us to slot our logic from our command-line program into our
    server interface with minimal effort. Now, all we have to do is connect it to
    our `views` module, and pass parameters into those views. Before we move on to
    the next section, however, there is some minor housekeeping we must do to ensure
    that our server can run. First, our dependencies in the `Cargo.toml` file have
    the following requirements:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以坐下来欣赏我们在前几章中所做所有艰苦工作的回报。原则的隔离和定义良好的模块使我们能够以最小的努力将我们的逻辑从命令行程序插入到我们的服务器接口中。现在，我们只需要将其连接到我们的
    `views` 模块，并将参数传递到这些视图中。然而，在我们进入下一节之前，我们必须做一些小的整理工作，以确保我们的服务器可以运行。首先，我们的 `Cargo.toml`
    文件中的依赖项有以下要求：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can then do a `cargo run` command, showing that our login and logout views
    work in our browser. With this done, we can start working on passing parameters
    into views.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行 `cargo run` 命令，这表明我们的登录和注销视图在我们的浏览器中工作。完成这些后，我们可以开始着手将参数传递到视图中。
- en: Passing parameters into views
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将参数传递到视图中
- en: 'In this section, we will cover the initial setup of fusing two modules to create
    a to-do item and store it through a view. To do this, we will have to pass in
    the title of the to-do item into our `create` view that creates a to-do item.
    We can pass data into a view using the following routes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍将两个模块融合以创建待办事项并通过视图存储的初始设置。为此，我们必须将待办事项的标题传递到创建待办事项的 `create` 视图中。我们可以使用以下路由将数据传递到视图中：
- en: '**URL**: Data and parameters can be passed inside the URL of the request. This
    is generally used in simple cases as it is easy to implement.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：数据和参数可以存储在请求的 URL 中。这通常用于简单情况，因为它易于实现。'
- en: '**body**: Data can be stored under different fields in the request body. This
    is used for more complex data structures and bigger payloads.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**body**：数据可以存储在请求体中的不同字段下。这用于更复杂的数据结构和更大的有效载荷。'
- en: '**header**: Data can be stored under different fields in the request header.
    This is used to store metadata about the request being sent. We also store the
    authentication data of the request in the header.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**header**：数据可以存储在请求头中的不同字段下。这用于存储正在发送的请求的元数据。我们还在头部存储了请求的认证数据。'
- en: 'We will cover all these approaches throughout our project, but for now, we
    will pass our data using the URL method as this is the easiest introduction method.
    First, we will create the structure for our to-do views with the following layout:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个项目中涵盖所有这些方法，但到目前为止，我们将使用 URL 方法传递我们的数据，因为这是最简单的介绍方法。首先，我们将使用以下布局创建我们的待办视图结构：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that we have put our `to-do` views in their own `views` module next
    to the `to_do` module. We will keep stacking our views in this way so that we
    can slot them in and out of our server and slot them into other projects if needed.
    For now, creating a to-do item will take the following form:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们将 `to-do` 视图放在与 `to_do` 模块相邻的 `views` 模块中。我们将继续以这种方式堆叠我们的视图，以便我们可以将它们插入和从我们的服务器中取出，如果需要，还可以将它们插入到其他项目中。现在，创建待办事项将采取以下形式：
- en: '![Figure 4.2 – Process of creating a to-do item](img/Figure_4.2_B18722.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 创建待办事项的过程](img/Figure_4.2_B18722.jpg)'
- en: Figure 4.2 – Process of creating a to-do item
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 创建待办事项的过程
- en: 'To carry out the process demonstrated in *Figure 4**.2*, we need to perform
    the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 *图 4**.2 中展示的过程，我们需要执行以下步骤：
- en: Load the current state of the to-do item list.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载待办事项列表的当前状态。
- en: Get the title of the new to-do item from the URL.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 URL 获取新待办事项的标题。
- en: Pass the title and the status `pending` through `to_do_factory`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `to_do_factory` 传递标题和状态 `pending`。
- en: Pass the result of the previous step along with the string `create` and the
    state into the process module interface.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一步的结果、字符串 `create` 和状态传递到进程模块接口。
- en: Return a string to the user to signal that the process has finished.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户返回一个字符串以表示过程已完成。
- en: 'We can carry out these steps defined previously in the `views/to_do/create.rs`
    file. First of all, we must import what we need with the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `views/to_do/create.rs` 文件中执行之前定义的这些步骤。首先，我们必须使用以下代码导入我们需要的：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will use `serde_json::value::Value` and `serde_json::Map` to define what
    type of data we are reading from the `state.json` file and to extract the title
    from the URL using the `HttpRequest` struct. We will then import what we need
    from our other modules to enable us to create an item, read the state file, and
    process the input. Our view can be defined through the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`serde_json::value::Value`和`serde_json::Map`来定义我们从`state.json`文件中读取的数据类型，并使用`HttpRequest`结构体从URL中提取标题。然后我们将从我们的其他模块中导入我们需要的内容，以便我们能够创建一个项目、读取状态文件和处理输入。我们的视图可以通过以下代码定义：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to remember that this is an `async` function because it is a view that
    our server is processing. We can also see that our `title` is extracted from `HttpRequest`
    by using the `match_info` function. We must directly unwrap it because if there
    is no title in the URL, then we do not want to continue with the process of making
    an item and then converting the extracted title to `String`. We then need to pass
    a reference of this to our `to_do_factory` to create an `ItemTypes` `enum`. We
    then pass our `enum` with a command and a reference to the current state of our
    application into our `process_input` function, which, as we remember, will go
    through a series of steps to work out how to handle the state based on the command
    and item type passed in. There is a lot going on here, but it must be noted none
    of the logic around how to process the item is in this view. This is called the
    separation of concerns of code orthogonality. Code orthogonality refers to the
    following mathematical concept:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住这是一个`async`函数，因为它是我们服务器正在处理的视图。我们还可以看到我们的`title`是通过使用`match_info`函数从`HttpRequest`中提取的。我们必须直接解包它，因为如果URL中没有标题，我们不想继续进行创建项目和将提取的标题转换为`String`的过程。然后我们需要将这个引用传递给我们的`to_do_factory`以创建一个`ItemTypes`枚举。然后我们将我们的枚举与一个命令和当前应用程序状态的引用传递给我们的`process_input`函数，正如我们记得的那样，它将经过一系列步骤来确定如何根据传入的命令和项目类型处理状态。这里有很多事情在进行，但必须注意的是，与如何处理项目相关的所有逻辑都不在这个视图中。这被称为代码正交性的关注点分离。代码正交性指的是以下数学概念：
- en: '![Figure 4.3 – Mathematical concept of orthogonality ](img/Figure_4.3_B18722.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 正交性的数学概念](img/Figure_4.3_B18722.jpg)'
- en: Figure 4.3 – Mathematical concept of orthogonality
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 正交性的数学概念
- en: 'We can see in *Figure 4**.3* that if a vector is orthogonal to another vector
    then it is said to have no projection onto another vector. In physics, if the
    vectors are forces, these vectors do not have any effect on each other. Now, this
    cannot be completely true in programming: if we delete the code in our `processes`
    module, it will affect the `create` view as we must reference it. However, the
    logic of `processes` should not be defined in the `create` view. This is partly
    because we must use `processes` elsewhere, but this is not the entire story. When
    we look at the `create` view, we can see the logic around creating a pending item
    in relation to the rest of the application. This makes it easy for developers
    to know exactly what’s going on. They are not getting lost in details that are
    not relevant to the five steps we specified earlier in this section to create
    a to-do item. If the developer wants to explore the logic around the saving of
    the item, they can investigate the file that defines this.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图4**.3中看到，如果一个向量与另一个向量正交，那么它就没有在另一个向量上的投影。在物理学中，如果这些向量是力，那么这些向量之间没有任何影响。现在，这在编程中不能完全正确：如果我们删除`processes`模块中的代码，它将影响`create`视图，因为我们必须引用它。然而，`processes`的逻辑不应该定义在`create`视图中。这部分的理由是我们必须在其他地方使用`processes`，但这不是全部原因。当我们查看`create`视图时，我们可以看到与创建挂起项目相关的逻辑与整个应用程序的其他部分。这使得开发者能够确切地知道正在发生什么。他们不会迷失在与此节中早些时候指定的创建待办事项的五步法无关的细节中。如果开发者想要探索保存项目周围的逻辑，他们可以调查定义此逻辑的文件。
- en: 'We must now make the views in our `to_do` module available to the outside.
    We can do this by creating a to-do views factory function in the `views/to_do/mod.rs`
    file with the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须使`to_do`模块中的视图对外可用。我们可以通过在`views/to_do/mod.rs`文件中创建一个待办视图工厂函数来实现，以下代码如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we can see that we do not make the `create` view public
    but we do use it in our factory to define the view. We also define the title being
    passed into the URL with the `/{title}` tag. Now that our item views are functional,
    we need to plug `to_do_views_factory` into our application in the `views/mod.rs`
    file with the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们没有使`create`视图公开，但我们确实在工厂中使用它来定义视图。我们还使用`/{title}`标签定义传递到URL中的标题。现在我们的项目视图已经功能正常，我们需要在`views/mod.rs`文件中将`to_do_views_factory`连接到我们的应用程序，以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we can see that we have defined the module, imported
    the factory, and then passed the application configuration. With this done, our
    application is ready to run and create to-do items. When our application is running,
    we can create the item with the following URL:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们已经定义了模块，导入了工厂，然后传递了应用程序配置。完成这些后，我们的应用程序就准备好运行并创建待办事项了。当我们的应用程序运行时，我们可以使用以下URL创建项目：
- en: '![Figure 4.4 – View to create a to-do item ](img/Figure_4.4_B18722.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 创建待办事项的视图](img/Figure_4.4_B18722.jpg)'
- en: Figure 4.4 – View to create a to-do item
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 创建待办事项的视图
- en: 'If we look at the console, we will see the following printout:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看控制台，我们将看到以下输出：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we look at the `state.json` file in the root, we will get the following
    data:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看根目录中的`state.json`文件，我们将得到以下数据：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that our process to create a to-do item worked! Our application takes
    in a title from the URL, creates a pending to-do item, and saves it in our JSON
    file. While this is a milestone, it must be noted that a JSON file is not the
    best solution for data storage. It will do for now, however, as we will configure
    a proper database in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence
    with PostgreSQL*. We can also see `%20` in the URL, which denotes a space. We
    can see that this space translates to the console printout and the saving of the
    data to the JSON file, and this space is also in the view displayed in the browser.
    What we have done is take in a to-do item title via the URL, print it out to the
    terminal, display it in the browser, and save it in a JSON file. We have essentially
    performed the basis for a web application as we can display data to a user and
    store it in a file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们创建待办事项的过程是成功的！我们的应用程序从URL中获取标题，创建一个待办事项，并将其保存在我们的JSON文件中。虽然这是一个里程碑，但必须指出，JSON文件并不是数据存储的最佳解决方案。然而，现在我们可以，因为我们将在[*第6章*](B18722_06.xhtml#_idTextAnchor127)“使用PostgreSQL的数据持久性”中配置一个合适的数据库。我们还可以看到URL中的`%20`，它表示一个空格。我们可以看到，这个空格在控制台输出和将数据保存到JSON文件中时都会出现，并且这个空格也在浏览器中显示的视图中。我们所做的是通过URL获取待办事项标题，将其打印到终端，在浏览器中显示，并将其保存到JSON文件中。我们实际上已经完成了构建一个Web应用程序的基础，因为我们可以向用户显示数据并将其存储在文件中。
- en: The `GET` method works for us, but it is not the most appropriate method for
    creating a to-do item. `GET` methods can be cached, bookmarked, kept in the browser’s
    history, and have restrictions in terms of their length. Bookmarking, storing
    them in browser history, or caching them doesn’t just present security issues;
    it also increases the risk of the user accidentally making the same call again.
    Because of this, it is not a good idea to alter data with a `GET` request. To
    protect against this, we can use a `POST` request, which does not cache, does
    not end up in browser history, and cannot be bookmarked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法对我们来说适用，但它并不是创建待办事项的最合适方法。`GET`方法可以被缓存、书签、保存在浏览器历史记录中，并且在其长度方面有限制。将它们书签、保存在浏览器历史记录中或缓存它们不仅会带来安全问题；它还增加了用户意外再次发出相同请求的风险。因此，使用`GET`请求更改数据不是一个好主意。为了防止这种情况，我们可以使用`POST`请求，它不会缓存，不会出现在浏览器历史记录中，也不能被书签。'
- en: 'Because of the reasons we laid out, we will now turn our `create` view into
    a `POST` request. Remember our comments on code orthogonality. What defines how
    the routes of our views are processed is kept in our factory in the `views/to_do/mod.rs`
    file with the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们列举的原因，我们现在将`create`视图转换为`POST`请求。记住我们对代码正交性的评论。定义我们的视图路由如何处理的是在我们的`views/to_do/mod.rs`文件中的工厂。以下代码：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we can see that we have merely changed the `get` to
    `post` in the import and the `route` definition. If we try and create a new to-do
    item using the previous approach, we get the following outcome:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们只是在导入和`route`定义中将`get`更改为`post`。如果我们尝试使用之前的方法创建一个新的待办事项，我们会得到以下结果：
- en: '![Figure 4.5 – Blocked method ](img/Figure_4.5_B18722.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 被阻止的方法](img/Figure_4.5_B18722.jpg)'
- en: Figure 4.5 – Blocked method
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 被阻止的方法
- en: 'In *Figure 4**.5*, we can see that the page cannot be found. This might be
    confusing as the error is a 404-error stating that the page can’t be found. The
    URL is still defined, but the `GET` method is no longer allowed for this URL.
    With this in mind, we can make a `POST` call using the following Postman configuration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图4**.5中，我们可以看到页面无法找到。这可能会让人困惑，因为错误是一个404错误，表示页面找不到。URL仍然定义，但不再允许对这个URL使用`GET`方法。考虑到这一点，我们可以使用以下Postman配置进行`POST`调用：
- en: '![Figure 4.6 – Postman post method for creating an item ](img/Figure_4.6_B18722.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 使用Postman的POST方法创建项目](img/Figure_4.6_B18722.jpg)'
- en: Figure 4.6 – Postman post method for creating an item
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 使用Postman的POST方法创建项目
- en: 'In *Figure 4**.6*, we can see that our URL is still working with just a different
    method—the `POST` method. We can inspect our state file, finding the following
    data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图4**.6中，我们可以看到我们的URL仍然有效，只是使用了不同的方法——`POST`方法。我们可以检查我们的状态文件，找到以下数据：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that changing the allowed method for the `create` view did not affect
    the way in which we create or store to-do items. Looking back at *Figure 4**.6*,
    we can also see that we get a status code of `200`, which is `OK`. This already
    tells us that the creation has happened. Because of this, we do not have to return
    anything as the status is `OK`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，更改`create`视图允许的方法并没有影响我们创建或存储待办事项的方式。回顾**图4**.6，我们还可以看到我们得到了状态码`200`，这是`OK`。这已经告诉我们创建已经发生。因此，我们不需要返回任何内容，因为状态是`OK`。
- en: 'Looking back at what we get when we try and send a `GET` request to our `create`
    view, we get a `views/to_do/mod.rs` file with the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾当我们尝试向我们的`create`视图发送`GET`请求时得到的结果，我们得到了一个包含以下代码的`views/to_do/mod.rs`文件：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that this works if we put our URL in our browser, which results in
    creating a pending to-do item. We also have the option to put a different function
    in our `get` route with the same URL if needed. This gives us flexibility on how
    to use and reuse our URLs. However, considering the differences that we covered
    between the `GET` and `POST` methods, it is sensible to just have a `POST` method
    for our `create` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将URL放入浏览器，我们可以看到这会创建一个挂起的待办事项。如果需要，我们还可以在我们的`get`路由中使用不同的函数与相同的URL。这给了我们在如何使用和重用URL方面的灵活性。然而，考虑到我们之前提到的`GET`和`POST`方法之间的差异，只为我们的`create`函数提供一个`POST`方法是有意义的。
- en: We have now done all that we need to when it comes to creating our to-do item.
    However, in other views, we will have to return structured data to present the
    current state of our to-do items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了创建待办事项所需的所有工作。然而，在其他视图中，我们必须返回结构化数据来展示当前待办事项的状态。
- en: So far, we have passed data into our application using a URL, which is the most
    basic way in which we can pass data. However, we cannot pass structured data using
    a URL. For instance, if we wanted to send a hashmap or a list, a URL is just not
    able to house such structures. This is where we need to pass data to our application
    in the body of the request using JSON, which we will cover in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用URL将数据传递到我们的应用程序中，这是我们可以传递数据的最基本方式。然而，我们无法使用URL传递结构化数据。例如，如果我们想发送一个哈希表或列表，URL根本无法容纳这样的结构。这就是我们需要在请求体中使用JSON将数据传递给应用程序的地方，我们将在下一节中介绍。
- en: Using macros for JSON serialization
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏进行JSON序列化
- en: 'When it comes to serializing data and returning it to the client, we can achieve
    this quickly with minimal code using the JSON from the `Actix-web` crate. We can
    demonstrate this by creating a `GET` view that returns all our to-do items in
    the `views/to_do/get.rs` file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到序列化数据并将其返回给客户端时，我们可以使用`Actix-web` crate中的JSON快速实现这一点。我们可以通过在`views/to_do/get.rs`文件中创建一个返回所有待办事项的`GET`视图来演示这一点：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we can see that we are merely reading the JSON from the JSON file and
    then returning the values from this wrapped in the `web::Json` function. It might
    make sense to just return `Map<String, Value>` from the JSON file directly, as
    it is a `String` and `Value`. However, the type of `Map<String, Value>` does not
    implement the `Responder` trait. We could update the function to return the state
    directly with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到我们只是从JSON文件中读取JSON，然后使用`web::Json`函数返回这些值。直接从JSON文件返回`Map<String, Value>`可能更有意义，因为它是`String`和`Value`。然而，`Map<String,
    Value>`的类型没有实现`Responder`特质。我们可以通过以下代码更新函数，直接返回状态：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, this will not work because the `get().to()` function in the `views/to_do/mod.rs`
    file needs to accept a struct that has implemented the `Responder` trait. We can
    now plug in our `get` view in the `views/to_do/mod.rs` file with the following
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会工作，因为 `views/to_do/mod.rs` 文件中的 `get().to()` 函数需要接受一个实现了 `Responder` 特性的结构体。我们现在可以在
    `views/to_do/mod.rs` 文件中插入我们的 `get` 视图，以下代码：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running the URL `http://127.0.0.1:8000/item/get` gives us the following JSON
    data in the response body:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 URL `http://127.0.0.1:8000/item/get` 会给我们响应体中的以下 JSON 数据：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have some structured data that we can present to the frontend. While
    this essentially gets the job done, it is not too helpful. For instance, we would
    like to have two different lists for *pending* and *done*. We could also add timestamps
    telling users when the to-do item was created or edited. Simply returning the
    titles and the statuses of the to-do items will not enable us to scale complexity
    when needed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一些结构化的数据可以呈现给前端。虽然这本质上完成了工作，但并不太有帮助。例如，我们希望有两个不同的列表，一个是 *pending*，另一个是
    *done*。我们还可以添加时间戳，告诉用户待办项是在何时创建或编辑的。仅仅返回待办项的标题和状态将无法使我们能够按需扩展复杂性。
- en: Building our own serialization struct
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的自定义序列化结构体
- en: 'To have more control over the type of data that we are going to return to the
    user, we are going to have to build our own serialization structs. Our serialization
    struct is going to present two lists, one for completed items and another for
    pending items. The lists will be populated with objects consisting of a title
    and a status. If we recall from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039),
    *Designing Your Web Application in Rust*, our `pending` and `Done` item structs
    are inherited via composition from a `Base` struct. Therefore, we must access
    the title and the status from the `Base` struct. However, our `Base` struct is
    not accessible to the public. We will have to make it accessible so that we can
    serialize the attributes for each to-do item:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对将要返回给用户的类型数据有更多的控制，我们将不得不构建我们自己的序列化结构体。我们的序列化结构体将展示两个列表，一个用于已完成的项目，另一个用于待办项目。列表将被填充具有标题和状态的对象。如果我们回想一下
    [*第 2 章*](B18722_02.xhtml#_idTextAnchor039)，*在 Rust 中设计您的 Web 应用程序*，我们的 `pending`
    和 `Done` 项目结构体是通过组合从 `Base` 结构体继承的。因此，我们必须从 `Base` 结构体中访问标题和状态。然而，我们的 `Base` 结构体对公众不可访问。我们必须使其可访问，以便我们可以序列化每个待办项的属性：
- en: '![Figure 4.7 – Relationship that our to-do structs have with our interfaces
    ](img/Figure_4.7_B18722.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 我们的待办结构体与接口之间的关系](img/Figure_4.7_B18722.jpg)'
- en: Figure 4.7 – Relationship that our to-do structs have with our interfaces
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 我们的待办结构体与接口之间的关系
- en: 'Looking at *Figure 4**.7*, we can see that the `TaskStatus enum` is the root
    of the dependency. We need to be able to serialize this `enum` before we can serialize
    our to-do items. We can use the `serde` crate for this. In order to do this, we
    must update our dependencies in the `Cargo.toml` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *图 4.7*，我们可以看到 `TaskStatus` 枚举是依赖关系的根。在我们能够序列化待办项之前，我们需要能够序列化这个 `enum`。我们可以使用
    `serde` 包来完成这个任务。为了做到这一点，我们必须更新 `Cargo.toml` 文件中的依赖项：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see that we have added the `features = ["derive"]`. This will enable
    us to decorate our structs with `serde` traits. We can now look at how we defined
    our `enum` in the `src/to_do/enums.rs` file with the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们添加了 `features = ["derive"]`。这将使我们能够用 `serde` 特性装饰我们的结构体。我们现在可以查看我们如何在
    `src/to_do/enums.rs` 文件中定义我们的 `enum`，以下代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we can see that we have two fields named `DONE` and
    `PENDING`; however, they are essentially their own types. How can we serialize
    this as a JSON value? There is a clue in the `stringify` function. However, this
    is not the full picture. Remember, the return values of our server views need
    to implement traits. We can implement a `serde` trait for our `TaskStatus` `enum`
    by initially importing the traits that we need in the `src/to_do/enums.rs` file
    with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们有两个名为 `DONE` 和 `PENDING` 的字段；然而，它们本质上是其自身的类型。我们如何将其序列化为 JSON
    值？在 `stringify` 函数中有一个线索。然而，这并不是全部。记住，我们服务器视图的返回值需要实现特性行为。我们可以通过在 `src/to_do/enums.rs`
    文件中首先导入我们需要的特性行为来实现 `serde` 特性，以下代码：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now have everything we need to implement the `Serialize` trait so we can
    customize how the structs that we write can be serialized in the following section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了实现 `Serialize` 特性的所有必要条件，因此我们可以在下一节中自定义我们编写的结构体如何被序列化。
- en: Implementing the Serialize trait
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 Serialize 特性
- en: '`Serialize` is the trait that we will implement, and `Serializer` is a data
    formatter that can serialize any data format that is supported by `serde`. We
    can then implement a `Serialize` trait for our `TaskStatus` `enum` with the following
    code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Serialize`是我们将要实现的特质，`Serializer`是一个数据格式化器，可以序列化`serde`支持的任何数据格式。然后我们可以使用以下代码为我们的`TaskStatus`
    `enum`实现`Serialize`特质：'
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a standard approach that is defined in the `serde` documents. In the
    preceding code, we can see a `serialize` function has been defined. The `serialize`
    function gets called when serializing our `TaskStatus` `enum`. We also notice
    that the type of notation for `serializer` is `S`. We then use a `where` statement
    defining `S` as `Serializer`. This may seem counterintuitive, so we can take a
    step back from our application to explore it. The following code blocks are not
    needed to complete our application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在`serde`文档中定义的标准方法。在前面的代码中，我们可以看到一个名为`serialize`的函数已经被定义。当序列化我们的`TaskStatus`
    `enum`时，会调用`serialize`函数。我们还注意到`serializer`的类型表示法为`S`。然后我们使用一个`where`语句将`S`定义为`Serializer`。这看起来可能有些反直觉，因此我们可以从我们的应用程序中退一步来探索它。以下代码块不是完成我们的应用程序所必需的。
- en: 'Let us define some basic structs as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些基本的结构体如下：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we can see that we implement the `Debug` trait for both
    the `TwoDposition` and `ThreeDposition` structs. We can then define functions
    that print a debug statement for each `struct` with the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们为`TwoDposition`和`ThreeDposition`结构体实现了`Debug`特质。然后我们可以定义函数，使用以下代码为每个`struct`打印调试语句：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, we can see that this does not scale well. We would be writing a function
    for everything that implements it. Instead, we can use a `where` statement so
    we can pass both of our structs into it as they implement the `Debug` trait. First,
    we must import the trait with the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以看到这并不具有良好的可扩展性。我们将会为每个实现它的东西编写一个函数。相反，我们可以使用一个`where`语句，这样我们就可以将两个结构体都传递给它，因为它们实现了`Debug`特质。首先，我们必须使用以下代码导入特质：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then define our flexible function with the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码定义我们的灵活函数：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'What is happening here is that our function is generic in terms of the type
    of variable that we are passing into the function. We then take a reference to
    a value of the type `S`. This means that `S` can be any type if it implements
    the `Debug` trait. If we try and pass in a `struct` that does not implement the
    `Debug` trait, the compiler will refuse to compile. So, what is happening when
    we compile? Run the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，我们的函数在传递给函数的变量的类型上是泛型的。然后我们获取类型`S`的值的引用。这意味着如果`S`实现了`Debug`特质，它可以是任何类型。如果我们尝试传递一个没有实现`Debug`特质的`struct`，编译器将拒绝编译。那么，编译时发生了什么？运行以下代码：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will get the following printout:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下打印输出：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding output makes sense as this is the result of printing when invoking
    the debug trait. However, they are two different functions that are created when
    the compiler is compiling. Our compiler compiled the following two functions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出是有意义的，因为这是调用debug特质时的打印结果。然而，它们是编译器编译时创建的两个不同的函数。我们的编译器编译了以下两个函数：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is not breaking what we know in terms of how Rust works; however, it does
    make our code more scalable. There are more advantages to using a `where` statement;
    for instance, we could specify what traits we need in an iterator with the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有打破我们对Rust工作方式的了解；然而，它确实使我们的代码更具可扩展性。使用`where`语句还有更多优点；例如，我们可以使用以下代码指定迭代器中需要的特质：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, we can see that we are accepting an iterator and that
    the items in the iterator need to implement the `Debug` trait. However, if we
    keep exploring the implementation of traits, we can lose focus of our main goal
    in this book: web programming in Rust.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们接受了一个迭代器，并且迭代器中的项需要实现`Debug`特质。然而，如果我们继续探索特质的实现，我们可能会失去本书的主要目标：使用Rust进行Web编程。
- en: 'With the knowledge of using the `where` statement to implement traits, we can
    look back at our implementation of the `Serialize` trait in the `TaskStatus` `enum`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解使用`where`语句实现特质的用法，我们可以回顾一下在`TaskStatus` `enum`中实现`Serialize`特质的代码：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that we merely call the `stringify` function and wrap it in an `Ok`
    result. We only want the status as a `String` as we are slotting it into a bigger
    body of data. If it was a struct with fields, then we could write the `serialize`
    function as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们只是调用了`stringify`函数，并将其包裹在`Ok`结果中。我们只想将状态作为一个`String`放入更大的数据体中。如果它是一个有字段的`struct`，那么我们可以将`serialize`函数编写如下：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, our serializer is the struct called `"TaskStatus"` with
    the number of fields being one. We then attributed the result of the `stringify`
    function to the `status` field. Doing this essentially gives us the following
    structure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的序列化器是一个名为`"TaskStatus"`的`struct`，它有一个字段。然后我们将`stringify`函数的结果分配给了`status`字段。这样做本质上给我们以下结构：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: However, we will not utilize the `serialize_struct` approach for our current
    exercise as we will need the status to be inserted into a bigger body to be returned.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会在我们的当前练习中使用`serialize_struct`方法，因为我们需要将状态插入到一个更大的返回体中。
- en: Integrating serialization structs into our application code
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将序列化`struct`集成到我们的应用程序代码中
- en: 'Now that we have enabled our `TaskStatus` `enum` to be serialized, we can look
    back at *Figure 4**.7* and see that our `Base` struct is next to be serialized.
    We can also see that the `Base` struct is the key to JSON serialization, but it
    is currently not public, so we need to make it public. This can be done by changing
    the declaration of the base module in the `to_do/structs/mod.rs` file from `mod
    base;` to `pub mod base;`. Now that the `Base` struct is directly available outside
    of the module, we can build our own `json_serialization` module in the `src` directory
    with the following structure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使我们的`TaskStatus` `enum`能够被序列化，我们可以回顾*图4**.7*，看到我们的`Base` `struct`是下一个要序列化的。我们还可以看到`Base`
    `struct`是JSON序列化的关键，但它目前不是公共的，所以我们需要将其设置为公共。这可以通过将`to_do/structs/mod.rs`文件中的基础模块声明从`mod
    base;`更改为`pub mod base;`来实现。现在`Base` `struct`可以直接在模块外部使用，我们可以在`src`目录中构建自己的`json_serialization`模块，其结构如下：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will define what we will return to the viewer when the `get` view is called
    in the `src/json_serialization/to_do_items.rs` file with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`src/json_serialization/to_do_items.rs`文件中定义当调用`get`视图时将返回给查看者的内容，以下代码：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, all we have done is define a standard public struct’s
    parameters. We then used the `derive` macro to implement the `Serialize` trait.
    This enables the struct’s attributes to be serialized to JSON with the name of
    the attribute as the key. For instance, if the `ToDoItems` struct had a `done_item_count`
    of one, then the JSON body would denote it as `"done_item_count": 1`. We can see
    that this is easier than the manual serialization that we did for our `TaskStatus`
    `enum` earlier. This is because the format of our fields is straightforward. If
    we do not need any extra logic during the serialization, decorating our `ToDoItems`
    with the `Serialize` trait is the easiest approach, which will result in fewer
    errors.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，我们所做的一切只是定义了一个标准的公共`struct`参数。然后我们使用`derive`宏实现了`Serialize`特性。这使得`struct`的属性可以以属性名为键序列化为JSON。例如，如果`ToDoItems``struct`有一个`done_item_count`字段为1，那么JSON体将表示为`"done_item_count":
    1`。我们可以看到，这比我们之前为`TaskStatus` `enum`所做的手动序列化要简单。这是因为我们字段的格式很简单。如果我们不需要在序列化过程中进行任何额外的逻辑，用`Serialize`特性装饰`ToDoItems`是最简单的方法，这将导致错误更少。'
- en: Now that serialization is defined, we must consider the processing of the data.
    It would not be scalable if we must sort the data and count it before calling
    the `struct`. This would add unnecessary code into the view that processes data
    for serialization as opposed to the logic belonging to the view in question. It
    would also enable duplicate code. There is only going to be one way we sort, count,
    and serialize the data. If other views are needed to return the list of items,
    then we would have to duplicate the code again.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在序列化已经被定义，我们必须考虑数据的处理。如果我们必须在调用`struct`之前对数据进行排序和计数，这将无法扩展。这将会在处理序列化数据的视图中添加不必要的代码，而不是属于该视图逻辑的代码。这也会导致代码重复。我们只有一种方式来排序、计数和序列化数据。如果需要其他视图来返回项目列表，那么我们可能需要再次复制代码。
- en: 'Considering this, it makes sense to build a constructor for the struct where
    we ingest a vector of to-do items, sort them into the right attributes, and then
    count them. We can define the constructor with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，为`struct`构建一个构造函数是有意义的，在这个构造函数中，我们接收一个待办事项的向量，将它们排序到正确的属性中，然后进行计数。我们可以用以下代码定义构造函数：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, we can see that our constructor takes in a vector of
    to-do items that we will have loaded from our JSON file. Inside our constructor,
    we must carry out the following steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的构造函数接受一个待办事项向量，这是我们已从JSON文件中加载的。在我们的构造函数内部，我们必须执行以下步骤：
- en: Sort the items into two vectors, one for pending items, and the other for complete
    items.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目分类到两个向量中，一个用于待办事项，另一个用于已完成事项。
- en: 'We will merely loop through the vector of items appending to different vectors
    depending on the item type with the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地遍历项目向量，根据项目类型将它们追加到不同的向量中，以下代码展示了如何操作：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Count the total number of pending and complete items.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算待办和已完成事项的总数。
- en: 'For the next step, we can then call the `len` function on each vector. The
    `len` function returns `usize`, which is a pointer-sized unsigned integer type.
    Because of this, we can cast it as `i8` with the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，我们可以在每个向量上调用`len`函数。`len`函数返回`usize`，它是一个指针大小的无符号整数类型。正因为如此，我们可以用以下代码将其转换为`i8`：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now have all the data that we need for constructing and returning the struct,
    which can be defined using the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建和返回结构体所需的所有数据，这可以通过以下代码定义：
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now our constructor is done.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的构造函数已经完成。
- en: 'We can now build our struct using this function. All we must do is plug it
    into our application so that we can pass it into our application. In the `json_serialization/mod.rs`
    file, we can make it public with the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个函数构建我们的结构体。我们唯一需要做的就是将其插入到我们的应用程序中，以便我们可以将其传递到应用程序中。在`json_serialization/mod.rs`文件中，我们可以用以下代码将其公开：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now declare our module in the `src/main.rs` file with the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`src/main.rs`文件中声明我们的模块，以下代码展示了如何操作：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also must ensure that our `base` module is public in the `src/to_do/structs/mod.rs`
    file. We are going to be serializing the | struct when returning data which can
    be achieved in the `src/to_do/structs/base.rs` file with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保我们的`base`模块在`src/to_do/structs/mod.rs`文件中是公开的。当我们返回数据时，我们将序列化|结构体，这可以在`src/to_do/structs/base.rs`文件中通过以下代码实现：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To utilize our struct, we must define it in our `GET` view in our `views/to_do/get.rs`
    file and return it with the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用我们的结构体，我们必须在我们的`views/to_do/get.rs`文件中的`GET`视图中定义它，并使用以下代码返回它：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code is another example of a moment where everything clicks together.
    We use our `read_file` interface to get the state from the JSON file. We can then
    loop through the map converting the item type into a string and feed it into our
    `to_do_factory` interface. Once we have the constructed item from the factory,
    we append it to a vector and feed that vector into our JSON serialization struct.
    After hitting the `get` view, we receive the following JSON body:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是另一个所有事情都突然变得清晰的例子。我们使用`read_file`接口从JSON文件中获取状态。然后我们可以遍历映射，将项目类型转换为字符串，并将其输入到我们的`to_do_factory`接口中。一旦我们从工厂中构建了项目，我们就将其追加到一个向量中，并将该向量输入到我们的JSON序列化结构体中。在点击`get`视图后，我们收到以下JSON正文：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We now have a well-structured response that we can expand on and edit. The development
    of applications never stops so if you were going to continue to maintain this
    application you will be adding features to this return JSON body. We will soon
    move onto other views. However, before we do this, we must acknowledge that we
    will be returning the full list of items with counts every time we make an API
    call. Therefore, we must package this response in a function for every function;
    otherwise, we will be writing the same code that we wrote in the `get` view for
    every other view. In the next section, we will cover how we can package our to-do
    items so that they can be returned in multiple views.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个结构良好的响应，我们可以在此基础上进行扩展和编辑。应用程序的开发永远不会停止，所以如果你打算继续维护这个应用程序，你将向这个返回的JSON体中添加功能。我们很快将转向其他视图。然而，在我们这样做之前，我们必须承认，每次我们进行API调用时，我们都会返回包含计数的完整项目列表。因此，我们必须在每个函数中包装这个响应；否则，我们将为每个视图重写我们在`get`视图中编写的相同代码。在下一节中，我们将介绍如何包装我们的待办事项，以便它们可以在多个视图中返回。
- en: Packaging our custom serialized struct to be returned to users
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的自定义序列化结构体打包以返回给用户
- en: 'Now, our `GET` view returns an implementation of the `Responder` trait. This
    means that if our `ToDoItems` struct also implements this, it can be directly
    returned in a view. We can do this in our `json_serialization/to_do_items.rs`
    file. First, we must import the following structs and traits:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `GET` 视图返回 `Responder` 特质的实现。这意味着如果我们的 `ToDoItems` 结构体也实现了这个特质，它可以直接在视图中返回。我们可以在
    `json_serialization/to_do_items.rs` 文件中这样做。首先，我们必须导入以下结构体和特质：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can see from the `actix_web` crate that we have imported a range of structs
    and traits that will enable us to build an HTTP response. We can now implement
    the `get` view code in a `get_state` function for the `ToDoItems` struct with
    the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `actix_web` 包中，我们可以看到我们导入了大量结构体和特质，这将使我们能够构建 HTTP 响应。现在，我们可以用以下代码在 `ToDoItems`
    结构体的 `get_state` 函数中实现 `get` 视图代码：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding code enables us to get all the to-do items from our JSON file
    with just one line of code. We must enable our `ToDoItems` struct to be returned
    in a view by implementing the `Responder` trait with the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使我们能够仅用一行代码从我们的 JSON 文件中获取所有待办事项。我们必须通过以下代码实现 `Responder` 特质来使我们的 `ToDoItems`
    结构体能够在视图中返回：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding code, what we have essentially done is serialize our `ToDoItems`
    struct using the `serde_json` crate, and then returned an HTTP response with the
    `ToDoItems` struct at the body. The `respond_to` function will be called when
    our `ToDoItems` struct is being returned in a view. Now this is where it gets
    really cool. We can rewrite our `views/to_do/get.rs` file with the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们本质上使用 `serde_json` 包序列化了 `ToDoItems` 结构体，然后返回了一个包含 `ToDoItems` 结构体的
    HTTP 响应。当我们的 `ToDoItems` 结构体在视图中返回时，将调用 `respond_to` 函数。现在，事情变得非常有趣。我们可以用以下代码重写我们的
    `views/to_do/get.rs` 文件：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That is it! If we run our application now, we will get the same response as
    we had before. With this, we can see how traits can abstract code for our views.
    Now that we have created the `get` view, we must work on building other views
    that create, edit, and delete. To do this, we are going to move on to our next
    section, which is extracting data from our views.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！如果我们现在运行我们的应用程序，我们将得到与之前相同的响应。有了这个，我们可以看到特质如何为我们的视图抽象代码。现在我们已经创建了 `get`
    视图，我们必须着手构建其他创建、编辑和删除的视图。为此，我们将继续到下一个部分，即从我们的视图中提取数据。
- en: Extracting data from views
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从视图中提取数据
- en: 'In this section, we are going to explore extracting data from our HTTP requests
    from the header and body. We are then going to use these methods to edit, delete
    to-do items, and intercept requests before they are fully loaded with middleware.
    We will go one step at a time. For now, let us extract data from the body of the
    HTTP request to edit a to-do item. When it comes to accepting data in JSON format,
    we should do what we have been doing throughout the book, separating this code
    from the view. If we think about it, we just need to send in the item that we
    are editing. However, we can also use this same schema for deleting. We can define
    our schema in our `json_serialization/to_do_item.rs` file with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索从我们的 HTTP 请求的头部和体中提取数据。然后，我们将使用这些方法来编辑、删除待办事项，并在请求完全加载之前通过中间件拦截请求。我们将一步一步来。现在，让我们从
    HTTP 请求的体中提取数据来编辑待办事项。当涉及到接受 JSON 格式的数据时，我们应该像本书中一直做的那样，将此代码与视图分离。如果我们仔细想想，我们只需要发送我们正在编辑的项目。然而，我们也可以使用相同的模式来删除。我们可以在
    `json_serialization/to_do_item.rs` 文件中用以下代码定义我们的模式：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding code, we have merely stated which type of data we need for
    each field as we cannot pass enums through JSON; only strings can be passed. The
    deserialization from JSON is enabled by decorating the `ToDoItem` struct with
    the `Deserialize` trait macro. We must remember to make the `ToDoItem` struct
    available to the rest of the application, so our `json_serialization/mod.rs` file
    should look like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们仅仅声明了每个字段所需的数据类型，因为我们不能通过 JSON 传递枚举；只能传递字符串。通过使用 `Deserialize` 特质宏装饰
    `ToDoItem` 结构体，我们启用了从 JSON 的反序列化。我们必须记住使 `ToDoItem` 结构体对整个应用程序可用，所以我们的 `json_serialization/mod.rs`
    文件应该看起来像以下这样：
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that our item extraction is done, we can move on to our `edit` view. In
    our `views/to_do/edit.rs` file we can import what we need with the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了项目提取，我们可以继续到我们的 `edit` 视图。在我们的 `views/to_do/edit.rs` 文件中，我们可以用以下代码导入所需的内容：
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding code, we can see that we need to import the standard serialization
    and web structs needed for a view. We also import the structs `ToDoItem` and `ToDoItems`
    for ingesting data and returning the entire state of the application. We can then
    import our `process_input` function that processes the input with a command. At
    this point, looking at the imports, can you think of the steps needed to perform
    our edit? Have a think before moving forward. The path is like what we did with
    a `get` view; however, we must update the state with the new updated item. We
    must also remember that our `process_input` function will edit the to-do item
    if the `edit` command is passed in.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到，我们需要导入用于视图的标准序列化和web结构。我们还导入了`ToDoItem`和`ToDoItems`结构，用于摄取数据和返回应用程序的整个状态。然后我们可以导入我们的`process_input`函数，该函数使用命令处理输入。在这个阶段，查看导入项，你能想到执行编辑所需的步骤吗？在继续之前先思考一下。路径就像我们处理`get`视图时做的那样；然而，我们必须用新的更新项目更新状态。我们还必须记住，如果传递了`edit`命令，我们的`process_input`函数将编辑待办事项。
- en: 'After thinking it through, remember, there are many ways to solve a problem.
    If your steps solve the problem, then do not feel bad if it is different from
    the steps laid out. You may also produce a better solution. Our `edit` view involves
    the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 深思熟虑后，请记住，解决问题有许多方法。如果你的步骤解决了问题，那么即使它与设定的步骤不同，也不要感到难过。你可能还会提出一个更好的解决方案。我们的`编辑`视图包括以下步骤：
- en: Get the state of the entire application for the to-do items.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取整个应用程序中待办事项的状态。
- en: Check to see if the item is there, returning a `not found` response if it is
    not.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查项目是否存在，如果不存在则返回一个`未找到`响应。
- en: Pass the data through the `to_do_factory` factory to construct the existing
    data from the state to an item that we can manipulate.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据通过`to_do_factory`工厂传递，以从状态构建现有数据到一个我们可以操作的项目。
- en: Check that the status being put in is not the same as the existing status.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认即将设置的状态与现有状态不同。
- en: Pass the existing item into the `process_input` function with an `edit` command
    so it is saved to the JSON state file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有项目传递给带有`edit`命令的`process_input`函数，以便将其保存到JSON状态文件中。
- en: Get the state of the application and return it.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应用程序的状态并返回它。
- en: With these steps in mind, we can concrete our knowledge of extracting JSON from
    the body of the request and process it for editing in the next subsection.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤的指导下，我们可以具体化从请求体中提取JSON并用于编辑的知识。
- en: Extracting JSON from the body of a request
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从请求体中提取JSON
- en: 'Now that we have the imports done and the outline defined, we can define the
    outline of our view with the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了导入和概述的定义，我们可以使用以下代码定义视图的概述：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code, we can see that our `ToDoItem` struct is wrapped in
    the `web::Json` struct. This means that the parameter `to_do_item` will be extracted
    from the body of the request, serialized, and constructed as the `ToDoItem` struct.
    So, inside our view, our `to_do_item` is a `ToDoItem` struct. Thus, inside our
    view, we can load our state with the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到，我们的`ToDoItem`结构被`web::Json`结构包裹。这意味着参数`to_do_item`将从请求体中提取，序列化，并构建为`ToDoItem`结构。因此，在我们的视图中，我们的`to_do_item`是一个`ToDoItem`结构。因此，在我们的视图中，我们可以使用以下代码加载我们的状态：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can then extract the item data from our state with the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码从我们的状态中提取项目数据：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding code, we can see that we can construct the status from the
    data or return a `not found` HTTP response if it is not found. We then need to
    construct the item struct with the existing data using the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到，我们可以从数据中构建状态，或者在未找到时返回一个`未找到`的HTTP响应。然后我们需要使用以下代码使用现有数据构建项目结构：
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding code, we can see why our factory is coming in handy. Now,
    we need to compare the new and existing status for the item. There is no point
    altering the status if the desired status is the same as the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到为什么我们的工厂派上用场。现在，我们需要比较项目和现有状态的新旧状态。如果期望的状态与以下代码相同，那么改变状态就没有意义：
- en: '[PRE61]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Therefore, we need to check the current status and if it is the same as the
    desired status, we merely return an `Ok` HTTP response state. We do this because
    the frontend client might be out of sync. In the next chapter, we will be writing
    the frontend code and we will see that the items will be cached and rendered.
    If, let’s say, another tab is open with our application or we have updated our
    to-do application on another device such as a phone, then the client making this
    request might be out of sync. We do not want to execute a command based on an
    out-of-sync frontend. We then need to process the input by making an edit and
    then returning the state with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要检查当前状态，如果它与期望的状态相同，我们只需返回一个`Ok` HTTP响应状态。我们这样做是因为前端客户端可能已经不同步。在下一章中，我们将编写前端代码，我们将看到项目将被缓存并渲染。如果我们假设另一个标签页中打开了我们的应用程序，或者我们在手机等其他设备上更新了我们的待办事项应用程序，那么发起这个请求的客户端可能已经不同步。我们不希望根据一个不同步的前端执行命令。然后我们需要通过编辑输入并返回以下代码的状态来处理输入：
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code should work but right now, it will not. This is because
    we need to clone our `TaskStatus` enum and our `TaskStatus` does not implement
    the `Clone` trait. This can be updated in our `src/to_do/enums.rs` file with the
    following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该能正常工作，但现在却不行。这是因为我们需要克隆我们的`TaskStatus`枚举，而我们的`TaskStatus`没有实现`Clone`特质。这可以通过在`src/to_do/enums.rs`文件中使用以下代码进行更新：
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We must then ensure that the `edit` view is available and defined in the `to-do`
    view factory. So, in the `src/views/to_do/mod.rs` file, our factory should look
    like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保`edit`视图在`to-do`视图工厂中可用且已定义。因此，在`src/views/to_do/mod.rs`文件中，我们的工厂应该看起来像以下这样：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can see that our view factory is scaling nicely. We can also stand back
    and appreciate that all our views for to-do items are defined nicely in one isolated
    page meaning we can simply look at the preceding code and still know that we need
    a `delete` view. We can now run our application and make a request in Postman
    with the following configuration:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的视图工厂运行得很好。我们还可以退后一步，欣赏到所有我们的待办事项视图都定义在一个隔离的页面上，这意味着我们可以简单地查看前面的代码，并知道我们还需要一个`delete`视图。我们现在可以运行我们的应用程序，并在
    Postman 中使用以下配置发起请求：
- en: '![Figure 4.8 – Edit request with Postman ](img/Figure_4.8_B18722.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 使用 Postman 编辑请求](img/Figure_4.8_B18722.jpg)'
- en: Figure 4.8 – Edit request with Postman
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 使用 Postman 编辑请求
- en: 'We can see in *Figure 4**.8* that we are switching our washing task to `"DONE"`.
    We have put this data in the body as raw with the format to be JSON. If we make
    this call to the `edit` endpoint, we will get the following response:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4.8*中，我们可以看到我们将洗衣任务切换到了`"DONE"`状态。我们将这些数据以原始格式放入了正文，格式为 JSON。如果我们向`edit`端点发起这个调用，我们将得到以下响应：
- en: '[PRE65]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code, we can see that the done items list is now populated
    and that the counts have been altered. If we continue to make the same call, we
    will get the same response as we will be editing the `washing` item to `done`
    when it already has a done status. We will have to switch the status of `washing`
    back to `pending` or change the title in our call to get a different updated state.
    If we do not include `title` and `status` in the body of our call, then we will
    get a bad request response instantly, because the `ToDoItem` struct is expecting
    those two fields.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到完成项列表现在已经被填充，计数已经被更改。如果我们继续发起相同的调用，我们将得到相同的响应，因为我们正在将`washing`项编辑为已完成的`done`状态，而它已经处于完成状态。我们将不得不将`washing`的状态切换回`pending`，或者更改我们调用中的标题以获取不同的更新状态。如果我们不在我们调用的正文中包含`title`和`status`，那么我们将立即得到一个错误的请求响应，因为`ToDoItem`结构体期望这两个字段。
- en: Now that we have locked down the process of receiving and returning JSON data
    in the URL parameters and body, we are nearly done. However, we have one more
    important method to cover that’s used for data extraction – the header. Headers
    are used to store meta information such as security credentials.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将接收和返回 URL 参数和正文中的 JSON 数据的过程锁定，我们几乎完成了。然而，我们还有一个重要的方法需要介绍，它是用于数据提取的 –
    头部。头部用于存储元信息，例如安全凭证。
- en: Extracting data from the header in requests
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从请求中提取头部数据
- en: If we needed to authorize a range of requests; it would not be scalable to put
    them in all our JSON structs. We also must acknowledge that the request body could
    be large, especially if the requester is being malicious. Therefore, it makes
    sense to access the security credentials before passing the request through to
    the view. This can be done by intercepting the request through what is commonly
    known as middleware. Once we’ve intercepted the request, we can access the security
    credentials, check them, and then process the view.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要授权一系列请求；将它们全部放入我们的 JSON 结构体中是不可扩展的。我们还必须承认请求体可能很大，特别是如果请求者是恶意的话。因此，在将请求传递到视图之前访问安全凭证是有意义的。这可以通过拦截请求，通常称为中间件来实现。一旦我们拦截了请求，我们就可以访问安全凭证，检查它们，然后处理视图。
- en: 'In the previous edition of this book, we manually developed our middleware
    for our authentication. However, this is not scalable in terms of code management
    and does not allow flexibility. However, it is important to cover manually configuring
    your own middleware to have a better understanding of how the server constructors
    work giving you the flexibility of processing requests. To intercept our requests,
    we need to add the `actix-service` crate. With this installation, our `Cargo.toml`
    file dependencies should look like the following definitions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前一版中，我们手动开发了我们的中间件用于认证。然而，这在代码管理方面不可扩展，并且不允许灵活性。然而，了解如何手动配置自己的中间件以更好地理解服务器构造函数的工作方式，并赋予我们处理请求的灵活性是很重要的。为了拦截我们的请求，我们需要添加
    `actix-service` 包。通过这个安装，我们的 `Cargo.toml` 文件依赖项应该看起来像以下定义：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can update our `src/main.rs` file. First, our imports should look like
    the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的 `src/main.rs` 文件。首先，我们的导入应该如下所示：
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that all the imports are done, we can define our server construction with
    the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有导入都已完成，我们可以定义我们的服务器构造函数，如下所示：
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we can see that the `wrap_fn` enables us to interact
    with the request (`req`). The service routing (`srv`) can be called when we need
    it to pass the request. We must note that calling the routing service is a future
    that we then wait to finish in an `async` code block returning the result. This
    is middleware. We can manipulate our request, inspect it, and reroute or return
    it before calling the routing service to process the HTTP request in one of our
    views. For us, we are just printing out the debug of the request, which looks
    like the following printout:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到 `wrap_fn` 允许我们与请求（`req`）进行交互。当需要传递请求时，可以调用服务路由（`srv`）。我们必须注意，调用路由服务是一个未来，我们随后在
    `async` 代码块中等待其完成，并返回结果。这是中间件。我们可以操纵我们的请求，检查它，并在调用路由服务处理 HTTP 请求之前重新路由或返回它。对我们来说，我们只是打印出请求的调试信息，如下所示：
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can see that we have a lot of data to work with. But this is as far as we
    will go with our homemade middleware. We will now investigate extracting data
    from headers using traits.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有大量的数据可以处理。但这就是我们自制的中间件所能达到的。现在，我们将研究如何使用特质从头部提取数据。
- en: Simplifying header extraction with traits
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特质简化头部提取
- en: 'Before we do this, we will have to install the futures crate, adding the following
    to the dependencies section of the `Cargo.toml` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们必须安装 futures 包，将以下内容添加到 `Cargo.toml` 文件的依赖项部分：
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will now create an `src/jwt.rs` file to house our `src/jwt.rs` file with
    the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个名为 `src/jwt.rs` 的文件来存放我们的 `src/jwt.rs` 文件，并包含以下代码：
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Payload` struct houses the requests raw data stream. We then have the
    `FromRequest` trait which is what we are going to implement to extract the data
    before it hits the view. We then use the `Ready` and `ok` from futures to wrap
    the result of our data extraction to create a future that is immediately ready
    with a success value, which is the value from our header extraction. Now that
    we have imported what we need, we can define our JWT struct with the following
    code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Payload` 结构体包含了请求的原始数据流。然后我们有 `FromRequest` 特质，这是我们将要实现以在数据到达视图之前提取数据的特质。然后我们使用
    futures 的 `Ready` 和 `ok` 来包装数据提取的结果，创建一个立即准备好并带有成功值的未来，这个值就是我们的头部提取值。现在我们已经导入了所需的内容，我们可以使用以下代码定义我们的
    JWT 结构体：'
- en: '[PRE72]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For now, we are only going to have a message but, in the future, we will be
    adding fields like the ID of the user. With this struct, we can implement the
    `FromRequest` trait with the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只有一个消息，但在未来，我们将添加用户 ID 等字段。有了这个结构体，我们可以使用以下代码实现 `FromRequest` 特质：
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can deduce that the `from_request` function gets called before the view
    is loaded. We are extracting the header, which is why we have no interest in the
    payload. So, we mark the parameter with `_`. We need to define the `Future` type,
    which is a ready future housing a result that can either be our `JwToken` struct
    or an error. Inside the `from_request` function, we can extract the data from
    the header with the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推断出，在视图加载之前，`from_request` 函数被调用。我们正在提取标题，这就是为什么我们对有效载荷不感兴趣。因此，我们用 `_` 标记该参数。我们需要定义
    `Future` 类型，它是一个包含结果的就绪未来，这个结果可以是我们的 `JwToken` 结构体或一个错误。在 `from_request` 函数内部，我们可以使用以下代码从标题中提取数据：
- en: '[PRE74]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the preceding code, we can see that for this chapter we just look for the
    `token` key and if it is there, we return the `JwToken` struct with the message.
    If not, we will return the `JwToken` struct with nothing found. As this chapter
    focuses on data, this is where we stop, but in [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149),
    *Managing User Sessions*, we will revisit this function and explore concepts such
    as throwing errors and returning requests before they hit the view with unauthorized
    codes. For now, we must make our `JwToken` struct accessible by defining it in
    our `src/main.rs` file with the following line of code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到，对于本章，我们只查找 `token` 键，如果它存在，我们就返回带有消息的 `JwToken` 结构体。如果没有，我们将返回不带任何内容的
    `JwToken` 结构体。由于本章侧重于数据，所以我们在这里停止，但在 [*第 7 章*](B18722_07.xhtml#_idTextAnchor149)
    *管理用户会话* 中，我们将重新审视这个函数，并探讨诸如抛出错误和返回带有未经授权代码的请求等概念。现在，我们必须通过在 `src/main.rs` 文件中定义以下行代码来使我们的
    `JwToken` 结构体可访问：
- en: '[PRE75]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now that we have gone through the hassle of implementing a trait, using it
    is going to be compact and simple. Let us revisit our `edit` view in our `views/to_do/edit.rs`
    file, import our `JwToken` struct, add our `JwToken` struct to our parameters
    in the `edit` view, and print out the message as seen in the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经费尽周折地实现了特质，使用它将会紧凑且简单。让我们回顾一下 `views/to_do/edit.rs` 文件中的 `edit` 视图，导入我们的
    `JwToken` 结构体，将 `JwToken` 结构体添加到 `edit` 视图的参数中，并打印出以下代码中的消息：
- en: '[PRE76]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Clearly, we do not want to edit the rest of the view but as we can deduce from
    the preceding code, the `token` parameter is the constructed `JwToken` struct
    that has been extracted from the HTTP request and is ready for use just like the
    `ToDoItem` struct. If we make the same edit HTTP call now after running the server,
    we will see that the HTTP request is printed out, but we also get the following
    response:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不想编辑视图的其余部分，但正如我们可以从前面的代码中推断出的，`token` 参数是构造的 `JwToken` 结构体，它已经从 HTTP 请求中提取出来，并且可以像
    `ToDoItem` 结构体一样使用。如果我们现在在运行服务器后进行相同的编辑 HTTP 调用，我们会看到 HTTP 请求被打印出来，但我们也会得到以下响应：
- en: '[PRE77]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It looks like it is working, as we haven’t added anything to the header yet.
    We can add a token into our header with the Postman setup defined in the following
    figure:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它正在正常工作，因为我们还没有在标题中添加任何内容。我们可以使用以下图中定义的 Postman 设置将令牌添加到我们的标题中：
- en: '![Figure 4.9 – Edit request in Postman with header ](img/Figure_4.9_B18722.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – Postman 中的带有标题的编辑请求](img/Figure_4.9_B18722.jpg)'
- en: Figure 4.9 – Edit request in Postman with header
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – Postman 中的带有标题的编辑请求
- en: 'If we send the request again, we get the following printout:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次发送请求，我们会得到以下输出：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That’s it! We can pass data through headers. What’s more, adding and taking
    them away from views is as easy as defining them in the parameters and removing
    them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们可以通过标题传递数据。更重要的是，在视图中添加和移除它们就像在参数中定义它们并移除它们一样简单。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have put all of what we have learned in the previous chapters
    to good use. We fused the logic from the to-do item factory, which loads and saves
    to-do items from a JSON file, and looked at the to-do item process logic by using
    the basic views from `Actix-web`. With this, we have been able to see how the
    isolated modules click together. We will keep reaping the benefits of this approach
    in the next few chapters as we rip out the JSON file that loads and saves a database.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将之前章节中学到的所有知识都付诸实践。我们将待办事项工厂的逻辑融合进来，该工厂从 JSON 文件中加载和保存待办事项，并使用 `Actix-web`
    的基本视图来查看待办事项的处理逻辑。通过这种方式，我们能够看到隔离的模块是如何协同工作的。在接下来的几章中，我们将继续从这个方法中获益，当我们移除加载和保存数据库的
    JSON 文件时。
- en: We also managed to utilize the `serde` crate to serialize complex data structures.
    This allows our users to get the full state update returned to them when they
    make an edit. We also built on our knowledge of futures, `async` blocks, and closures
    to intercept requests before they reached the view. Now, we can see that the power
    of Rust is enabling us to do some highly customizable things to our server, without
    us having to dig deep into the framework.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还成功地利用了 `serde` 包来序列化复杂的数据结构。这允许我们的用户在编辑时获得完整的州更新返回。我们还基于我们对未来、`async` 块和闭包的知识来拦截请求，在它们到达视图之前。现在，我们可以看到
    Rust 的力量使我们能够对我们的服务器进行高度自定义，而无需深入框架。
- en: Thus, Rust has a strong future in web development. Despite its infancy, we can
    get things up and running with little to no code. With a few more lines of code
    and a closure, we are building our own middleware. Our JSON serialization structs
    were made possible with just one line of code, and the traits provided by `Actix`
    enabled us to merely define the parameter in the view function, thus enabling
    the view to automatically extract the data from the body and serialize it into
    the struct. This scalable, powerful, and standardized way of passing data is more
    concise than many high-level languages. We can now fully interact with and inspect
    every part of the HTTP request.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Rust 在 Web 开发中有着光明的未来。尽管它还处于起步阶段，但我们可以用很少或没有代码来启动和运行。通过几行代码和一个闭包，我们正在构建自己的中间件。我们的
    JSON 序列化 `struct` 只需要一行代码就能实现，`Actix` 提供的特性能使我们只需在视图函数中定义参数，从而使得视图能够自动从体中提取数据并将其序列化到
    `struct` 中。这种可扩展、强大且标准化的数据传递方式比许多高级语言更简洁。我们现在可以完全交互和检查 HTTP 请求的每个部分。
- en: Now that we are processing and returning well-structured data to the user, we
    can start displaying it in an interactive way for our user to point and click
    when editing, creating, and deleting to-do items.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在处理和向用户返回结构良好的数据，我们可以开始以交互式方式显示它，让用户在编辑、创建和删除待办事项时可以点击。
- en: In the next chapter, we will be serving HTML, CSS, and JavaScript from the `Actix-web`
    server. This will enable us to see and interact with to-do items via a graphical
    user interface, with the JavaScript making API calls to the endpoints we defined
    in this chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从 `Actix-web` 服务器中提供 HTML、CSS 和 JavaScript。这将使我们能够通过图形用户界面查看和交互待办事项，JavaScript
    将对我们在本章中定义的端点进行 API 调用。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a `GET` and `POST` request?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 请求和 `POST` 请求之间的区别是什么？'
- en: Why would we have middleware when we check credentials?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在检查凭证时会有中间件？
- en: How do you enable a custom `struct` to be directly returned in a view?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使自定义的 `struct` 能够在视图中直接返回？
- en: How do you enact middleware for the server?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何为服务器实现中间件？
- en: How do you enable a custom `struct` to serialize data into the view?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使自定义 `struct` 将数据序列化到视图中？
- en: Answers
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A `GET` request can be cached and there are limits to the types and amount of
    data that can be sent. A `POST` request has a body, which enables more data to
    be transferred. Also, it cannot be cached.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 请求可以被缓存，并且对可以发送的数据类型和数量有限制。`POST` 请求有一个体，这允许传输更多的数据。此外，它不能被缓存。'
- en: We use middleware to open the header and check the credentials before sending
    the request to the desired view. This gives us an opportunity to prevent the body
    from being loaded by returning an `auth` error before loading the view preventing
    the potentially malicious body.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用中间件在发送请求到目标视图之前打开头部并检查凭证。这给了我们一个机会，在加载视图之前返回一个 `auth` 错误，从而防止加载可能有害的体。
- en: For the struct to be directly returned, we will have to implement the `Responder`
    trait. During this implementation, we will have to define the `responded_to` function
    that accepts the HTTP request struct. The `responded_to` will be fired when the
    struct is returned.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使 `struct` 能够直接返回，我们必须实现 `Responder` 特性。在实现过程中，我们必须定义 `responded_to` 函数，该函数接受
    HTTP 请求 `struct`。当 `struct` 返回时，`responded_to` 将被触发。
- en: In order to enact middleware, we enact the `wrap_fn` function on the `App` struct.
    In the `wrap_fn` function, we pass a closure that accepts the service request
    and routing structs.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现中间件，我们在 `App` 结构体上实现 `wrap_fn` 函数。在 `wrap_fn` 函数中，我们传递一个闭包，该闭包接受服务请求和路由结构体。
- en: 'We decorate the struct with the `#[derive(Deserialize)]` macro. Once we have
    done this, we define the parameter type to be wrapped in a JSON struct: `parameter:
    web::Json<ToDoItem>`.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们使用`#[derive(Deserialize)]`宏来装饰结构体。一旦完成这个操作，我们定义要包裹在JSON结构体中的参数类型：`parameter:
    web::Json<ToDoItem>`。'
