- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing HTTP Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have utilized the Actix Web framework to serve basic views.
    However, this can only get us so far when it comes to extracting data from the
    request and passing data back to the user. In this chapter, we will fuse code
    from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039)*, Designing Your Web Application
    in Rust*, and [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP
    Requests*, to build server views that process to-do items. We will then explore
    **JSON serialization** for extracting data and returning it to make our views
    more user friendly. We will also extract data from the header with middleware
    before it hits the view. We will explore the concepts around data serialization
    and extracting data from requests by building out the create, edit, and delete
    to-do item endpoints for our to-do application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the initial setup for fusing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing parameters into views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using macros for JSON serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have finished this chapter, you will be able to build a basic Rust
    server that can send and receive data in the URL, in the body using JSON, and
    in the header of the HTTP request. This is essentially a fully functioning API
    Rust server without a proper database for data storage, the ability to authenticate
    users, or the ability to display content in the browser. However, these concepts
    will be covered in the next three chapters. You are on the home run for having
    a fully working Rust server that is up and running. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we need to download and install **Postman**. We will need
    Postman to make API requests to our server. You can download it from [https://www.postman.com/downloads/](https://www.postman.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: We will also be building on the server code we created in the previous chapter,
    which can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter03/managing_views_using_the_actix_web_framework/web_app).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full source code that will be used in this chapter here: [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing views code will be the basis of this chapter, and we will add features
    to this code base. We will be fusing this with the to-do module that we wrote
    in [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039), *Designing Your Web Application
    in Rust*, which can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02/processing_traits_and_structs).
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the initial setup for fusing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover the initial setup of two fusing pieces of code
    we built in [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039), *Designing Your Web
    Application in Rust*, and [*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling
    HTTP Requests*. This fusion will give us the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Structure of our app and its modules](img/Figure_4.1_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Structure of our app and its modules
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will register all the modules in the main file and then pull all these
    modules into the views to be used. We are essentially swapping the command-line
    interface from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039), *Designing Your
    Web Application in Rust*, with web views. Combining these modules gives us the
    following files in the code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We are then bolting our `to_do` module into the same directory of our `main.rs`
    file. If you built the `to_do` module when reading [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039),
    *Designing Your Web Application in Rust*, your `to_do` module should have the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, our bolt on the `views` module from the previous chapter should contain
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The full structure, with all the code, can be found in the following GitHub
    repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup](https://github/PacktPublishing/Rust-for-Web-Developers/tree/master/chapter04/getting_to_know_the_initial_setup'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added modules from previous chapters to our project, we can
    bind them together in our program. To do this, we must create a new `src/main.rs`
    file. First, we must import the modules that we built and define a basic server
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the modules and then our server. Because the
    server is utilizing `views_factory`, we will not have to alter this file for the
    rest of this chapter. Instead, we will chain our factory functions that will be
    called in the `views_factory` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can sit back and appreciate the dividends of all the hard
    work that we did in the previous chapters. The isolation of principles and well-defined
    modules have enabled us to slot our logic from our command-line program into our
    server interface with minimal effort. Now, all we have to do is connect it to
    our `views` module, and pass parameters into those views. Before we move on to
    the next section, however, there is some minor housekeeping we must do to ensure
    that our server can run. First, our dependencies in the `Cargo.toml` file have
    the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can then do a `cargo run` command, showing that our login and logout views
    work in our browser. With this done, we can start working on passing parameters
    into views.
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters into views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover the initial setup of fusing two modules to create
    a to-do item and store it through a view. To do this, we will have to pass in
    the title of the to-do item into our `create` view that creates a to-do item.
    We can pass data into a view using the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: Data and parameters can be passed inside the URL of the request. This
    is generally used in simple cases as it is easy to implement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**body**: Data can be stored under different fields in the request body. This
    is used for more complex data structures and bigger payloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**header**: Data can be stored under different fields in the request header.
    This is used to store metadata about the request being sent. We also store the
    authentication data of the request in the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will cover all these approaches throughout our project, but for now, we
    will pass our data using the URL method as this is the easiest introduction method.
    First, we will create the structure for our to-do views with the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have put our `to-do` views in their own `views` module next
    to the `to_do` module. We will keep stacking our views in this way so that we
    can slot them in and out of our server and slot them into other projects if needed.
    For now, creating a to-do item will take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Process of creating a to-do item](img/Figure_4.2_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Process of creating a to-do item
  prefs: []
  type: TYPE_NORMAL
- en: 'To carry out the process demonstrated in *Figure 4**.2*, we need to perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the current state of the to-do item list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the title of the new to-do item from the URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the title and the status `pending` through `to_do_factory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the result of the previous step along with the string `create` and the
    state into the process module interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a string to the user to signal that the process has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can carry out these steps defined previously in the `views/to_do/create.rs`
    file. First of all, we must import what we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `serde_json::value::Value` and `serde_json::Map` to define what
    type of data we are reading from the `state.json` file and to extract the title
    from the URL using the `HttpRequest` struct. We will then import what we need
    from our other modules to enable us to create an item, read the state file, and
    process the input. Our view can be defined through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to remember that this is an `async` function because it is a view that
    our server is processing. We can also see that our `title` is extracted from `HttpRequest`
    by using the `match_info` function. We must directly unwrap it because if there
    is no title in the URL, then we do not want to continue with the process of making
    an item and then converting the extracted title to `String`. We then need to pass
    a reference of this to our `to_do_factory` to create an `ItemTypes` `enum`. We
    then pass our `enum` with a command and a reference to the current state of our
    application into our `process_input` function, which, as we remember, will go
    through a series of steps to work out how to handle the state based on the command
    and item type passed in. There is a lot going on here, but it must be noted none
    of the logic around how to process the item is in this view. This is called the
    separation of concerns of code orthogonality. Code orthogonality refers to the
    following mathematical concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Mathematical concept of orthogonality ](img/Figure_4.3_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Mathematical concept of orthogonality
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in *Figure 4**.3* that if a vector is orthogonal to another vector
    then it is said to have no projection onto another vector. In physics, if the
    vectors are forces, these vectors do not have any effect on each other. Now, this
    cannot be completely true in programming: if we delete the code in our `processes`
    module, it will affect the `create` view as we must reference it. However, the
    logic of `processes` should not be defined in the `create` view. This is partly
    because we must use `processes` elsewhere, but this is not the entire story. When
    we look at the `create` view, we can see the logic around creating a pending item
    in relation to the rest of the application. This makes it easy for developers
    to know exactly what’s going on. They are not getting lost in details that are
    not relevant to the five steps we specified earlier in this section to create
    a to-do item. If the developer wants to explore the logic around the saving of
    the item, they can investigate the file that defines this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must now make the views in our `to_do` module available to the outside.
    We can do this by creating a to-do views factory function in the `views/to_do/mod.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we do not make the `create` view public
    but we do use it in our factory to define the view. We also define the title being
    passed into the URL with the `/{title}` tag. Now that our item views are functional,
    we need to plug `to_do_views_factory` into our application in the `views/mod.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have defined the module, imported
    the factory, and then passed the application configuration. With this done, our
    application is ready to run and create to-do items. When our application is running,
    we can create the item with the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – View to create a to-do item ](img/Figure_4.4_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – View to create a to-do item
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the console, we will see the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the `state.json` file in the root, we will get the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our process to create a to-do item worked! Our application takes
    in a title from the URL, creates a pending to-do item, and saves it in our JSON
    file. While this is a milestone, it must be noted that a JSON file is not the
    best solution for data storage. It will do for now, however, as we will configure
    a proper database in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence
    with PostgreSQL*. We can also see `%20` in the URL, which denotes a space. We
    can see that this space translates to the console printout and the saving of the
    data to the JSON file, and this space is also in the view displayed in the browser.
    What we have done is take in a to-do item title via the URL, print it out to the
    terminal, display it in the browser, and save it in a JSON file. We have essentially
    performed the basis for a web application as we can display data to a user and
    store it in a file.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` method works for us, but it is not the most appropriate method for
    creating a to-do item. `GET` methods can be cached, bookmarked, kept in the browser’s
    history, and have restrictions in terms of their length. Bookmarking, storing
    them in browser history, or caching them doesn’t just present security issues;
    it also increases the risk of the user accidentally making the same call again.
    Because of this, it is not a good idea to alter data with a `GET` request. To
    protect against this, we can use a `POST` request, which does not cache, does
    not end up in browser history, and cannot be bookmarked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the reasons we laid out, we will now turn our `create` view into
    a `POST` request. Remember our comments on code orthogonality. What defines how
    the routes of our views are processed is kept in our factory in the `views/to_do/mod.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have merely changed the `get` to
    `post` in the import and the `route` definition. If we try and create a new to-do
    item using the previous approach, we get the following outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Blocked method ](img/Figure_4.5_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Blocked method
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.5*, we can see that the page cannot be found. This might be
    confusing as the error is a 404-error stating that the page can’t be found. The
    URL is still defined, but the `GET` method is no longer allowed for this URL.
    With this in mind, we can make a `POST` call using the following Postman configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Postman post method for creating an item ](img/Figure_4.6_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Postman post method for creating an item
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.6*, we can see that our URL is still working with just a different
    method—the `POST` method. We can inspect our state file, finding the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that changing the allowed method for the `create` view did not affect
    the way in which we create or store to-do items. Looking back at *Figure 4**.6*,
    we can also see that we get a status code of `200`, which is `OK`. This already
    tells us that the creation has happened. Because of this, we do not have to return
    anything as the status is `OK`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at what we get when we try and send a `GET` request to our `create`
    view, we get a `views/to_do/mod.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this works if we put our URL in our browser, which results in
    creating a pending to-do item. We also have the option to put a different function
    in our `get` route with the same URL if needed. This gives us flexibility on how
    to use and reuse our URLs. However, considering the differences that we covered
    between the `GET` and `POST` methods, it is sensible to just have a `POST` method
    for our `create` function.
  prefs: []
  type: TYPE_NORMAL
- en: We have now done all that we need to when it comes to creating our to-do item.
    However, in other views, we will have to return structured data to present the
    current state of our to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have passed data into our application using a URL, which is the most
    basic way in which we can pass data. However, we cannot pass structured data using
    a URL. For instance, if we wanted to send a hashmap or a list, a URL is just not
    able to house such structures. This is where we need to pass data to our application
    in the body of the request using JSON, which we will cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using macros for JSON serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to serializing data and returning it to the client, we can achieve
    this quickly with minimal code using the JSON from the `Actix-web` crate. We can
    demonstrate this by creating a `GET` view that returns all our to-do items in
    the `views/to_do/get.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we are merely reading the JSON from the JSON file and
    then returning the values from this wrapped in the `web::Json` function. It might
    make sense to just return `Map<String, Value>` from the JSON file directly, as
    it is a `String` and `Value`. However, the type of `Map<String, Value>` does not
    implement the `Responder` trait. We could update the function to return the state
    directly with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will not work because the `get().to()` function in the `views/to_do/mod.rs`
    file needs to accept a struct that has implemented the `Responder` trait. We can
    now plug in our `get` view in the `views/to_do/mod.rs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the URL `http://127.0.0.1:8000/item/get` gives us the following JSON
    data in the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have some structured data that we can present to the frontend. While
    this essentially gets the job done, it is not too helpful. For instance, we would
    like to have two different lists for *pending* and *done*. We could also add timestamps
    telling users when the to-do item was created or edited. Simply returning the
    titles and the statuses of the to-do items will not enable us to scale complexity
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Building our own serialization struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To have more control over the type of data that we are going to return to the
    user, we are going to have to build our own serialization structs. Our serialization
    struct is going to present two lists, one for completed items and another for
    pending items. The lists will be populated with objects consisting of a title
    and a status. If we recall from [*Chapter 2*](B18722_02.xhtml#_idTextAnchor039),
    *Designing Your Web Application in Rust*, our `pending` and `Done` item structs
    are inherited via composition from a `Base` struct. Therefore, we must access
    the title and the status from the `Base` struct. However, our `Base` struct is
    not accessible to the public. We will have to make it accessible so that we can
    serialize the attributes for each to-do item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Relationship that our to-do structs have with our interfaces
    ](img/Figure_4.7_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Relationship that our to-do structs have with our interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at *Figure 4**.7*, we can see that the `TaskStatus enum` is the root
    of the dependency. We need to be able to serialize this `enum` before we can serialize
    our to-do items. We can use the `serde` crate for this. In order to do this, we
    must update our dependencies in the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we have added the `features = ["derive"]`. This will enable
    us to decorate our structs with `serde` traits. We can now look at how we defined
    our `enum` in the `src/to_do/enums.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have two fields named `DONE` and
    `PENDING`; however, they are essentially their own types. How can we serialize
    this as a JSON value? There is a clue in the `stringify` function. However, this
    is not the full picture. Remember, the return values of our server views need
    to implement traits. We can implement a `serde` trait for our `TaskStatus` `enum`
    by initially importing the traits that we need in the `src/to_do/enums.rs` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We now have everything we need to implement the `Serialize` trait so we can
    customize how the structs that we write can be serialized in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Serialize trait
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Serialize` is the trait that we will implement, and `Serializer` is a data
    formatter that can serialize any data format that is supported by `serde`. We
    can then implement a `Serialize` trait for our `TaskStatus` `enum` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard approach that is defined in the `serde` documents. In the
    preceding code, we can see a `serialize` function has been defined. The `serialize`
    function gets called when serializing our `TaskStatus` `enum`. We also notice
    that the type of notation for `serializer` is `S`. We then use a `where` statement
    defining `S` as `Serializer`. This may seem counterintuitive, so we can take a
    step back from our application to explore it. The following code blocks are not
    needed to complete our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us define some basic structs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we implement the `Debug` trait for both
    the `TwoDposition` and `ThreeDposition` structs. We can then define functions
    that print a debug statement for each `struct` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can see that this does not scale well. We would be writing a function
    for everything that implements it. Instead, we can use a `where` statement so
    we can pass both of our structs into it as they implement the `Debug` trait. First,
    we must import the trait with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define our flexible function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'What is happening here is that our function is generic in terms of the type
    of variable that we are passing into the function. We then take a reference to
    a value of the type `S`. This means that `S` can be any type if it implements
    the `Debug` trait. If we try and pass in a `struct` that does not implement the
    `Debug` trait, the compiler will refuse to compile. So, what is happening when
    we compile? Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output makes sense as this is the result of printing when invoking
    the debug trait. However, they are two different functions that are created when
    the compiler is compiling. Our compiler compiled the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not breaking what we know in terms of how Rust works; however, it does
    make our code more scalable. There are more advantages to using a `where` statement;
    for instance, we could specify what traits we need in an iterator with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we are accepting an iterator and that
    the items in the iterator need to implement the `Debug` trait. However, if we
    keep exploring the implementation of traits, we can lose focus of our main goal
    in this book: web programming in Rust.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the knowledge of using the `where` statement to implement traits, we can
    look back at our implementation of the `Serialize` trait in the `TaskStatus` `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we merely call the `stringify` function and wrap it in an `Ok`
    result. We only want the status as a `String` as we are slotting it into a bigger
    body of data. If it was a struct with fields, then we could write the `serialize`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, our serializer is the struct called `"TaskStatus"` with
    the number of fields being one. We then attributed the result of the `stringify`
    function to the `status` field. Doing this essentially gives us the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: However, we will not utilize the `serialize_struct` approach for our current
    exercise as we will need the status to be inserted into a bigger body to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating serialization structs into our application code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have enabled our `TaskStatus` `enum` to be serialized, we can look
    back at *Figure 4**.7* and see that our `Base` struct is next to be serialized.
    We can also see that the `Base` struct is the key to JSON serialization, but it
    is currently not public, so we need to make it public. This can be done by changing
    the declaration of the base module in the `to_do/structs/mod.rs` file from `mod
    base;` to `pub mod base;`. Now that the `Base` struct is directly available outside
    of the module, we can build our own `json_serialization` module in the `src` directory
    with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define what we will return to the viewer when the `get` view is called
    in the `src/json_serialization/to_do_items.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, all we have done is define a standard public struct’s
    parameters. We then used the `derive` macro to implement the `Serialize` trait.
    This enables the struct’s attributes to be serialized to JSON with the name of
    the attribute as the key. For instance, if the `ToDoItems` struct had a `done_item_count`
    of one, then the JSON body would denote it as `"done_item_count": 1`. We can see
    that this is easier than the manual serialization that we did for our `TaskStatus`
    `enum` earlier. This is because the format of our fields is straightforward. If
    we do not need any extra logic during the serialization, decorating our `ToDoItems`
    with the `Serialize` trait is the easiest approach, which will result in fewer
    errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that serialization is defined, we must consider the processing of the data.
    It would not be scalable if we must sort the data and count it before calling
    the `struct`. This would add unnecessary code into the view that processes data
    for serialization as opposed to the logic belonging to the view in question. It
    would also enable duplicate code. There is only going to be one way we sort, count,
    and serialize the data. If other views are needed to return the list of items,
    then we would have to duplicate the code again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering this, it makes sense to build a constructor for the struct where
    we ingest a vector of to-do items, sort them into the right attributes, and then
    count them. We can define the constructor with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that our constructor takes in a vector of
    to-do items that we will have loaded from our JSON file. Inside our constructor,
    we must carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the items into two vectors, one for pending items, and the other for complete
    items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will merely loop through the vector of items appending to different vectors
    depending on the item type with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Count the total number of pending and complete items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the next step, we can then call the `len` function on each vector. The
    `len` function returns `usize`, which is a pointer-sized unsigned integer type.
    Because of this, we can cast it as `i8` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all the data that we need for constructing and returning the struct,
    which can be defined using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now our constructor is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now build our struct using this function. All we must do is plug it
    into our application so that we can pass it into our application. In the `json_serialization/mod.rs`
    file, we can make it public with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now declare our module in the `src/main.rs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We also must ensure that our `base` module is public in the `src/to_do/structs/mod.rs`
    file. We are going to be serializing the | struct when returning data which can
    be achieved in the `src/to_do/structs/base.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To utilize our struct, we must define it in our `GET` view in our `views/to_do/get.rs`
    file and return it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is another example of a moment where everything clicks together.
    We use our `read_file` interface to get the state from the JSON file. We can then
    loop through the map converting the item type into a string and feed it into our
    `to_do_factory` interface. Once we have the constructed item from the factory,
    we append it to a vector and feed that vector into our JSON serialization struct.
    After hitting the `get` view, we receive the following JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We now have a well-structured response that we can expand on and edit. The development
    of applications never stops so if you were going to continue to maintain this
    application you will be adding features to this return JSON body. We will soon
    move onto other views. However, before we do this, we must acknowledge that we
    will be returning the full list of items with counts every time we make an API
    call. Therefore, we must package this response in a function for every function;
    otherwise, we will be writing the same code that we wrote in the `get` view for
    every other view. In the next section, we will cover how we can package our to-do
    items so that they can be returned in multiple views.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging our custom serialized struct to be returned to users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, our `GET` view returns an implementation of the `Responder` trait. This
    means that if our `ToDoItems` struct also implements this, it can be directly
    returned in a view. We can do this in our `json_serialization/to_do_items.rs`
    file. First, we must import the following structs and traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the `actix_web` crate that we have imported a range of structs
    and traits that will enable us to build an HTTP response. We can now implement
    the `get` view code in a `get_state` function for the `ToDoItems` struct with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code enables us to get all the to-do items from our JSON file
    with just one line of code. We must enable our `ToDoItems` struct to be returned
    in a view by implementing the `Responder` trait with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, what we have essentially done is serialize our `ToDoItems`
    struct using the `serde_json` crate, and then returned an HTTP response with the
    `ToDoItems` struct at the body. The `respond_to` function will be called when
    our `ToDoItems` struct is being returned in a view. Now this is where it gets
    really cool. We can rewrite our `views/to_do/get.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: That is it! If we run our application now, we will get the same response as
    we had before. With this, we can see how traits can abstract code for our views.
    Now that we have created the `get` view, we must work on building other views
    that create, edit, and delete. To do this, we are going to move on to our next
    section, which is extracting data from our views.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data from views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to explore extracting data from our HTTP requests
    from the header and body. We are then going to use these methods to edit, delete
    to-do items, and intercept requests before they are fully loaded with middleware.
    We will go one step at a time. For now, let us extract data from the body of the
    HTTP request to edit a to-do item. When it comes to accepting data in JSON format,
    we should do what we have been doing throughout the book, separating this code
    from the view. If we think about it, we just need to send in the item that we
    are editing. However, we can also use this same schema for deleting. We can define
    our schema in our `json_serialization/to_do_item.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have merely stated which type of data we need for
    each field as we cannot pass enums through JSON; only strings can be passed. The
    deserialization from JSON is enabled by decorating the `ToDoItem` struct with
    the `Deserialize` trait macro. We must remember to make the `ToDoItem` struct
    available to the rest of the application, so our `json_serialization/mod.rs` file
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our item extraction is done, we can move on to our `edit` view. In
    our `views/to_do/edit.rs` file we can import what we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that we need to import the standard serialization
    and web structs needed for a view. We also import the structs `ToDoItem` and `ToDoItems`
    for ingesting data and returning the entire state of the application. We can then
    import our `process_input` function that processes the input with a command. At
    this point, looking at the imports, can you think of the steps needed to perform
    our edit? Have a think before moving forward. The path is like what we did with
    a `get` view; however, we must update the state with the new updated item. We
    must also remember that our `process_input` function will edit the to-do item
    if the `edit` command is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'After thinking it through, remember, there are many ways to solve a problem.
    If your steps solve the problem, then do not feel bad if it is different from
    the steps laid out. You may also produce a better solution. Our `edit` view involves
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the state of the entire application for the to-do items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check to see if the item is there, returning a `not found` response if it is
    not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the data through the `to_do_factory` factory to construct the existing
    data from the state to an item that we can manipulate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the status being put in is not the same as the existing status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the existing item into the `process_input` function with an `edit` command
    so it is saved to the JSON state file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the state of the application and return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these steps in mind, we can concrete our knowledge of extracting JSON from
    the body of the request and process it for editing in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting JSON from the body of a request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the imports done and the outline defined, we can define the
    outline of our view with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that our `ToDoItem` struct is wrapped in
    the `web::Json` struct. This means that the parameter `to_do_item` will be extracted
    from the body of the request, serialized, and constructed as the `ToDoItem` struct.
    So, inside our view, our `to_do_item` is a `ToDoItem` struct. Thus, inside our
    view, we can load our state with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then extract the item data from our state with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we can construct the status from the
    data or return a `not found` HTTP response if it is not found. We then need to
    construct the item struct with the existing data using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see why our factory is coming in handy. Now,
    we need to compare the new and existing status for the item. There is no point
    altering the status if the desired status is the same as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, we need to check the current status and if it is the same as the
    desired status, we merely return an `Ok` HTTP response state. We do this because
    the frontend client might be out of sync. In the next chapter, we will be writing
    the frontend code and we will see that the items will be cached and rendered.
    If, let’s say, another tab is open with our application or we have updated our
    to-do application on another device such as a phone, then the client making this
    request might be out of sync. We do not want to execute a command based on an
    out-of-sync frontend. We then need to process the input by making an edit and
    then returning the state with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should work but right now, it will not. This is because
    we need to clone our `TaskStatus` enum and our `TaskStatus` does not implement
    the `Clone` trait. This can be updated in our `src/to_do/enums.rs` file with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We must then ensure that the `edit` view is available and defined in the `to-do`
    view factory. So, in the `src/views/to_do/mod.rs` file, our factory should look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that our view factory is scaling nicely. We can also stand back
    and appreciate that all our views for to-do items are defined nicely in one isolated
    page meaning we can simply look at the preceding code and still know that we need
    a `delete` view. We can now run our application and make a request in Postman
    with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Edit request with Postman ](img/Figure_4.8_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Edit request with Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in *Figure 4**.8* that we are switching our washing task to `"DONE"`.
    We have put this data in the body as raw with the format to be JSON. If we make
    this call to the `edit` endpoint, we will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that the done items list is now populated
    and that the counts have been altered. If we continue to make the same call, we
    will get the same response as we will be editing the `washing` item to `done`
    when it already has a done status. We will have to switch the status of `washing`
    back to `pending` or change the title in our call to get a different updated state.
    If we do not include `title` and `status` in the body of our call, then we will
    get a bad request response instantly, because the `ToDoItem` struct is expecting
    those two fields.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have locked down the process of receiving and returning JSON data
    in the URL parameters and body, we are nearly done. However, we have one more
    important method to cover that’s used for data extraction – the header. Headers
    are used to store meta information such as security credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data from the header in requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we needed to authorize a range of requests; it would not be scalable to put
    them in all our JSON structs. We also must acknowledge that the request body could
    be large, especially if the requester is being malicious. Therefore, it makes
    sense to access the security credentials before passing the request through to
    the view. This can be done by intercepting the request through what is commonly
    known as middleware. Once we’ve intercepted the request, we can access the security
    credentials, check them, and then process the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous edition of this book, we manually developed our middleware
    for our authentication. However, this is not scalable in terms of code management
    and does not allow flexibility. However, it is important to cover manually configuring
    your own middleware to have a better understanding of how the server constructors
    work giving you the flexibility of processing requests. To intercept our requests,
    we need to add the `actix-service` crate. With this installation, our `Cargo.toml`
    file dependencies should look like the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can update our `src/main.rs` file. First, our imports should look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the imports are done, we can define our server construction with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that the `wrap_fn` enables us to interact
    with the request (`req`). The service routing (`srv`) can be called when we need
    it to pass the request. We must note that calling the routing service is a future
    that we then wait to finish in an `async` code block returning the result. This
    is middleware. We can manipulate our request, inspect it, and reroute or return
    it before calling the routing service to process the HTTP request in one of our
    views. For us, we are just printing out the debug of the request, which looks
    like the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have a lot of data to work with. But this is as far as we
    will go with our homemade middleware. We will now investigate extracting data
    from headers using traits.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying header extraction with traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we do this, we will have to install the futures crate, adding the following
    to the dependencies section of the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create an `src/jwt.rs` file to house our `src/jwt.rs` file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Payload` struct houses the requests raw data stream. We then have the
    `FromRequest` trait which is what we are going to implement to extract the data
    before it hits the view. We then use the `Ready` and `ok` from futures to wrap
    the result of our data extraction to create a future that is immediately ready
    with a success value, which is the value from our header extraction. Now that
    we have imported what we need, we can define our JWT struct with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we are only going to have a message but, in the future, we will be
    adding fields like the ID of the user. With this struct, we can implement the
    `FromRequest` trait with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can deduce that the `from_request` function gets called before the view
    is loaded. We are extracting the header, which is why we have no interest in the
    payload. So, we mark the parameter with `_`. We need to define the `Future` type,
    which is a ready future housing a result that can either be our `JwToken` struct
    or an error. Inside the `from_request` function, we can extract the data from
    the header with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that for this chapter we just look for the
    `token` key and if it is there, we return the `JwToken` struct with the message.
    If not, we will return the `JwToken` struct with nothing found. As this chapter
    focuses on data, this is where we stop, but in [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149),
    *Managing User Sessions*, we will revisit this function and explore concepts such
    as throwing errors and returning requests before they hit the view with unauthorized
    codes. For now, we must make our `JwToken` struct accessible by defining it in
    our `src/main.rs` file with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have gone through the hassle of implementing a trait, using it
    is going to be compact and simple. Let us revisit our `edit` view in our `views/to_do/edit.rs`
    file, import our `JwToken` struct, add our `JwToken` struct to our parameters
    in the `edit` view, and print out the message as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, we do not want to edit the rest of the view but as we can deduce from
    the preceding code, the `token` parameter is the constructed `JwToken` struct
    that has been extracted from the HTTP request and is ready for use just like the
    `ToDoItem` struct. If we make the same edit HTTP call now after running the server,
    we will see that the HTTP request is printed out, but we also get the following
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like it is working, as we haven’t added anything to the header yet.
    We can add a token into our header with the Postman setup defined in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Edit request in Postman with header ](img/Figure_4.9_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Edit request in Postman with header
  prefs: []
  type: TYPE_NORMAL
- en: 'If we send the request again, we get the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! We can pass data through headers. What’s more, adding and taking
    them away from views is as easy as defining them in the parameters and removing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have put all of what we have learned in the previous chapters
    to good use. We fused the logic from the to-do item factory, which loads and saves
    to-do items from a JSON file, and looked at the to-do item process logic by using
    the basic views from `Actix-web`. With this, we have been able to see how the
    isolated modules click together. We will keep reaping the benefits of this approach
    in the next few chapters as we rip out the JSON file that loads and saves a database.
  prefs: []
  type: TYPE_NORMAL
- en: We also managed to utilize the `serde` crate to serialize complex data structures.
    This allows our users to get the full state update returned to them when they
    make an edit. We also built on our knowledge of futures, `async` blocks, and closures
    to intercept requests before they reached the view. Now, we can see that the power
    of Rust is enabling us to do some highly customizable things to our server, without
    us having to dig deep into the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, Rust has a strong future in web development. Despite its infancy, we can
    get things up and running with little to no code. With a few more lines of code
    and a closure, we are building our own middleware. Our JSON serialization structs
    were made possible with just one line of code, and the traits provided by `Actix`
    enabled us to merely define the parameter in the view function, thus enabling
    the view to automatically extract the data from the body and serialize it into
    the struct. This scalable, powerful, and standardized way of passing data is more
    concise than many high-level languages. We can now fully interact with and inspect
    every part of the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are processing and returning well-structured data to the user, we
    can start displaying it in an interactive way for our user to point and click
    when editing, creating, and deleting to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be serving HTML, CSS, and JavaScript from the `Actix-web`
    server. This will enable us to see and interact with to-do items via a graphical
    user interface, with the JavaScript making API calls to the endpoints we defined
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a `GET` and `POST` request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we have middleware when we check credentials?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you enable a custom `struct` to be directly returned in a view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you enact middleware for the server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you enable a custom `struct` to serialize data into the view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `GET` request can be cached and there are limits to the types and amount of
    data that can be sent. A `POST` request has a body, which enables more data to
    be transferred. Also, it cannot be cached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use middleware to open the header and check the credentials before sending
    the request to the desired view. This gives us an opportunity to prevent the body
    from being loaded by returning an `auth` error before loading the view preventing
    the potentially malicious body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the struct to be directly returned, we will have to implement the `Responder`
    trait. During this implementation, we will have to define the `responded_to` function
    that accepts the HTTP request struct. The `responded_to` will be fired when the
    struct is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to enact middleware, we enact the `wrap_fn` function on the `App` struct.
    In the `wrap_fn` function, we pass a closure that accepts the service request
    and routing structs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We decorate the struct with the `#[derive(Deserialize)]` macro. Once we have
    done this, we define the parameter type to be wrapped in a JSON struct: `parameter:
    web::Json<ToDoItem>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
