<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variables</h1>
                
            
            
                
<p class="calibre1">As with all programming languages, we need a way to store information within our application. This information can be anything and, as with every other language, it's stored in a variable. However, unlike every other language, Rust does not store data in the same way as (say) C does.</p>
<p class="calibre1">To that end, in this chapter we will do the following:</p>
<ul class="calibre12">
<li class="calibre13">Understand variable mutability</li>
<li class="calibre13">See how Rust stores information in a variable, and the types of variable available</li>
<li class="calibre13">See how Rust deals with vector variable types</li>
<li class="calibre13">Understand how Rust can and cannot manipulate variables</li>
<li class="calibre13">See how Rust can pass variables</li>
<li class="calibre13">Take a look at how Rust stores a variable internally</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variable mutability</h1>
                
            
            
                
<p class="calibre1">Unlike many other languages, Rust defaults to non-mutability of variables. That means that variable bindings are actually constants if not explicitly defined as mutable. The compiler checks against all variable mutations and refuses to accept mutating non-mutable variable bindings.</p>
<p>If you come from one of the C family of languages, a non-mutable can be considered to be roughly the same as a <kbd class="calibre22">const</kbd> type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a variable</h1>
                
            
            
                
<p class="calibre1">To create a new variable binding in Rust, we use the following form:</p>
<pre class="calibre21">let x = 1; </pre>
<p class="calibre1">This means that we create a new variable binding called <kbd class="calibre10">x</kbd> whose content will be <kbd class="calibre10">1</kbd>. The default type for numbers depends on the situation a bit, but usually it's a 32-bit signed integer. If we need a variable that can change, we use this form:</p>
<pre class="calibre21">let mut x = 1; </pre>
<p class="calibre1">By default, all variables in Rust are non-mutable; therefore, we have to explicitly define a variable as being mutable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How can we tell the compiler that we want x to be an int?</h1>
                
            
            
                
<p class="calibre1">Rust has a way of informing both the compiler and the developer of the variable type. For example, for a 32-bit <kbd class="calibre10">int</kbd>, we would use the following:</p>
<pre class="calibre21">let x = 1i32; </pre>
<p class="calibre1">In other words, <kbd class="calibre10">x</kbd> = <kbd class="calibre10">1</kbd>, a 32-bit signed <kbd class="calibre10">int</kbd>.</p>
<p>If a variable is defined without the <kbd class="calibre22">i32</kbd> (or any other value), the compiler will decide the type depending on how the value is used, defaulting to <kbd class="calibre22">i32</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining other variable types</h1>
                
            
            
                
<p class="calibre1">Other variable types can be declared in the same way as <kbd class="calibre10">int</kbd> variables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Float</h1>
                
            
            
                
<p class="calibre1">Much as with other languages, floating point arithmetic can be performed in Rust. As with an integer variable, a floating point variable is defined for a 32-bit <kbd class="calibre10">float</kbd> as follows:</p>
<pre class="calibre21">let pi = 3.14f32; </pre>
<p class="calibre1">For a 64-bit <kbd class="calibre10">float</kbd>, it will be defined as this:</p>
<pre class="calibre21">let pi = 3.14f64; </pre>
<p class="calibre1">The variables are literal values. Another way to declare the size would be via types:</p>
<pre class="calibre21">let pi: f32 = 3.14; </pre>
<p>If a type is omitted (for example, let <kbd class="calibre22">x</kbd> = <kbd class="calibre22">3.14</kbd>), the variable will be declared as a 64-bit floating point variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Signed and unsigned integers</h1>
                
            
            
                
<p class="calibre1">A signed <kbd class="calibre10">int</kbd> (one that can have positive or negative values) is defined like this:</p>
<pre class="calibre21">let sint = 10i32; </pre>
<p class="calibre1">An unsigned <kbd class="calibre10">int</kbd> has a <kbd class="calibre10">u</kbd> instead of <kbd class="calibre10">i</kbd> in the definition:</p>
<pre class="calibre21">let usint = 10u32; </pre>
<p class="calibre1">Again, these are number literals, and the same declaration can be made via types:</p>
<pre class="calibre21">let sint: i32 = 10; </pre>
<p>Both signed and unsigned <kbd class="calibre22">int</kbd> values can be 8, 16, 32, or 64-bits long.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Const and static</h1>
                
            
            
                
<p class="calibre1">Rust has two types of constants: <strong class="calibre8">consts</strong> and <strong class="calibre8">statics</strong>. Consts are sort of like aliases: their contents are sort of replaced on the place where they are used. The syntax is like this:</p>
<pre class="calibre21">const PI: f32 = 3.1415927; </pre>
<p class="calibre1">Statics are more like variables. They have a global scope of the program, and are defined as follows:</p>
<pre class="calibre21">static MY_VARIABLE: i32 = 255; </pre>
<p class="calibre1">They cannot be altered.</p>
<p class="calibre1">Rust is able to guess the types of local function variables. This is called <strong class="calibre8">local type inference</strong>. However, it is only local, so types of statics and consts must always be typed out.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Defining the variable value before use</h1>
                
            
            
                
<p class="calibre1">While it is not enforced in some languages, a variable must have an initial value in Rust, even if it is zero. This is good practice, and also helps when it comes to debugging since all variables have known contents. If they didn't, there'd be a risk of undefined behavior.</p>
<p>Undefined behavior means that what the program does is anyone's guess. For instance, if variables did not have initial values, their values would be whatever happens to be in memory at the time that the value is allocated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Strings</h1>
                
            
            
                
<p class="calibre1">Typically, a string can be defined in one of two ways:</p>
<pre class="calibre21">let myName = "my name"; </pre>
<p class="calibre1">This is known as a <strong class="calibre8">string slice</strong>. These will be dealt with in a while.</p>
<p class="calibre1">The second way is to use <kbd class="calibre10">String::new();</kbd>. This is a String, with a capital S. It is allocated in the heap and can grow dynamically.</p>
<p class="calibre1">At this point, it would be a good idea to break with the current narrative and discuss how Rust uses memory, as it will help greatly with explaining a number of upcoming topics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How Rust uses memory</h1>
                
            
            
                
<p class="calibre1">The memory occupied by any Rust program is split into two distinct areas: the heap and the stack. Simply put, the stack contains primitive variables, while the heap stores complex types. As with the mess on my daughter's bedroom floor, a heap can grow and grow until the available memory is exhausted. The stack is faster and simpler but may not grow without limits. Every binding in Rust is in a stack, but those bindings may refer to things in the heap, and elsewhere.</p>
<p class="calibre1">This all relates directly to the string example. The binding <kbd class="calibre10">myName</kbd> is in the stack, and refers to a literal static string, <em class="calibre9">my name</em>. That string being static means that it is somewhere in memory when the program starts. Its being static also means that it cannot be changed.</p>
<p class="calibre1"><kbd class="calibre10">String::new</kbd>, on the other hand, creates a String in the heap. It is initially empty, but may grow to fill the whole virtual memory space.</p>
<p class="calibre1">Here is an example of a growing String:</p>
<pre class="calibre21">let mut myStringOne = "This is my first string ".to_owned(); 
let myStringTwo = "This is my second string. "; 
let myStringThree = "This is my final string"; 
myStringOne = myStringOne + myStringTwo + myStringTwo + myStringThree + myStringTwo; </pre>
<p class="calibre1">One of the ways of creating Strings is to call the <kbd class="calibre10">to_owned</kbd> method on a string slice, like we have just done. There are other ways, but this is the most recommended one because it underlines the ownership issue. We'll get back to that later.</p>
<p class="calibre1">Here, the binding <kbd class="calibre10">myStringOne</kbd> starts out at 24 characters long, and would be allocated at least that size on the heap. The binding <kbd class="calibre10">myStringOne</kbd> is actually a reference to the position on the heap where <kbd class="calibre10">myStringOne</kbd> lives.</p>
<p class="calibre1">As we add to <kbd class="calibre10">myStringOne</kbd>, the size it occupies on the heap increases; however, the reference to the base position remains the same.</p>
<p>The lifetime and scope of a variable have to be taken into account. For example, if we define a string within part of a function, and then try and access the string outside the function, we get a compiler error.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Back to Strings</h1>
                
            
            
                
<p class="calibre1">As we saw before diverting onto the heap and stack, we can also define a string like this:</p>
<pre class="calibre21">let mut myString = String::new(); </pre>
<p class="calibre1">The <kbd class="calibre10">String::</kbd> tells the compiler that we are going to use the standard library, <kbd class="calibre10">String</kbd>, and we tell the program that we are going to create a mutable String and store a reference to it on the stack in something called <kbd class="calibre10">myString</kbd>.</p>
<p class="calibre1">The dynamic string can be created as either being empty, or with memory preallocated to it. For example, say we want to store the words <em class="calibre9">You'll never walk alone</em> (a total of 23 bytes), preallocating the space for them. This is how to do it:</p>
<pre class="calibre21">let mut ynwa = String::with_capacity(23); 
ynwa.push_str("You'll never walk alone"); </pre>
<p class="calibre1">This is just a performance optimization and is not typically required, since Strings grow automatically when they need to. The following does roughly the same job:</p>
<pre class="calibre21">let mut ynwa = "You'll never walk alone".to_owned(); </pre>
<p>Rust strings are not null-terminated, and consist entirely of valid Unicode. Therefore, they can contain null bytes and characters from any language, but they may require more bytes than they contain characters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">String slices</h1>
                
            
            
                
<p class="calibre1">String slices can be confusing at first sight. We define a string slice like this:</p>
<pre class="calibre21">let homeTeam = "Liverpool"; </pre>
<p class="calibre1">Coming from more dynamic languages, you might think that we are assigning the string <kbd class="calibre10">Liverpool</kbd> to the variable binding <kbd class="calibre10">homeTeam</kbd>. That's not exactly what happens, however. The <kbd class="calibre10">homeTeam</kbd> binding is actually a string slice: a reference to a part of the string that actually resides somewhere else.</p>
<p class="calibre1">The string slice is also not mutable.</p>
<p class="calibre1">The following will not work in Rust:</p>
<pre class="calibre21">let homeTeam = "Liverpool"; 
let result = " beat "; 
let awayTeam = "Manchester United"; 
let theString = homeTeam + result + awayTeam; </pre>
<p class="calibre1">The compiler will not allow this, and will give an error as follows:</p>
<div><img class="image-border6" src="img/00020.jpeg"/></div>
<p class="calibre1">We cannot concatenate the slice directly, since string slices cannot be mutable. To do that, we need to first convert the string slice into something that is mutable, or build the string with something like the <kbd class="calibre10">format!</kbd> macro. Let's try them both.</p>
<p class="calibre1">Like before, the <kbd class="calibre10">to_owned()</kbd> method takes the slice the method is attached to, and converts it to a <kbd class="calibre10">String</kbd> type:</p>
<pre class="calibre21">fn main() { 
    let homeTeam = "Liverpool"; 
    let result = " beat "; 
    let awayTeam = "Manchester United"; 
     
    let fullLine = homeTeam.to_owned() + result + awayTeam; 
     
    println!("{}", fullLine); 
} </pre>
<p>The <kbd class="calibre22">to_owned()</kbd> method is only applied to the first slice. This converts the string slice <kbd class="calibre22">homeTeam</kbd> into a String, and using the <kbd class="calibre22">+</kbd> operator on a String is fine.</p>
<p class="calibre1">When this is built and executed, you will see the following:</p>
<div><img class="image-border6" src="img/00021.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What's with the warnings?</h1>
                
            
            
                
<p class="calibre1">The recommended format that Rust uses is snake case (rather than CamelCase). The warnings can be removed if we change the variable name from <kbd class="calibre10">homeTeam</kbd> to <kbd class="calibre10">home_team</kbd>. It's not fatal, or likely to cause the program to go on a homicidal rampage; it's more of a style issue.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the format! macro</h1>
                
            
            
                
<p class="calibre1">The <kbd class="calibre10">format!</kbd> macro works in a way similar to string formatters in other languages:</p>
<pre class="calibre21">fn main() { 
    let home_team = "Liverpool"; 
    let result = " beat "; 
    let away_team = "Manchester United"; 
     
    let full_line = format!("{}{}{}", home_team, result, away_team); 
         
    println!("{}", full_line); 
} </pre>
<p class="calibre1">The <kbd class="calibre10">{}</kbd> in the format strings mark spots for the following parameters. The spots are filled in order, so <kbd class="calibre10">full_line</kbd> will be a concatenation of <kbd class="calibre10">home_team</kbd>, <kbd class="calibre10">result</kbd>, and <kbd class="calibre10">away_team</kbd>.</p>
<p class="calibre1">When the preceding code snippet is compiled and executed, you will see the following:</p>
<div><img class="image-border6" src="img/00022.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Building a string</h1>
                
            
            
                
<p class="calibre1">We've seen that we can create a String from a string slice (using <kbd class="calibre10">to_owned()</kbd> or the <kbd class="calibre10">format!</kbd> macro), or we can create it using <kbd class="calibre10">String::new()</kbd>.</p>
<p class="calibre1">There are two further ways to help build the string: <kbd class="calibre10">push</kbd> adds a single character to the string, and <kbd class="calibre10">push_str</kbd> adds an <kbd class="calibre10">str</kbd> to the string.</p>
<p class="calibre1">The following shows this in action:</p>
<pre class="calibre21">fn main() { 
    let home_team = "Liverpool"; 
    let result = " beat "; 
    let away_team = "Manchester United"; 
    let home_score = '3'; // single character 
    let away_score = "-0"; 
     
 
    let mut full_line = format!("{}{}{} ", home_team, result, away_team); 
         
    // add the character to the end of the String     
    full_line.push(home_score); 
      
    // add the away score to the end of the String 
    full_line.push_str(away_score); 
         
    println!("{}", full_line); 
} </pre>
<p class="calibre1">When this last code snippet is compiled and executed, you will see this:</p>
<div><img class="image-border6" src="img/00023.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Code review</h1>
                
            
            
                
<p class="calibre1">The preceding code is somewhat different from the code in previous examples where we have simply used <kbd class="calibre10">to_owned()</kbd> to convert the slice to a string. We now have to create a mutable string and assign to that rather than just add to the end of <kbd class="calibre10">full_line</kbd> as we did previously.</p>
<p class="calibre1">The reason is that the slice being converted to string is not mutable; therefore, the type created will also be non-mutable. Since you cannot add to a non-mutable variable, we could not use the <kbd class="calibre10">push</kbd> and <kbd class="calibre10">push_str</kbd> methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Casting</h1>
                
            
            
                
<p class="calibre1">Rust allows for variables to be cast differently. This is achieved using the <kbd class="calibre10">as</kbd> keyword. This works in the same way as it does in C#:</p>
<pre class="calibre21">let my_score = 10i32; 
let mut final_score : u32 = 100; 
let final_score = my_score as u32; </pre>
<p class="calibre1">We can also cast to a different type (for example, <kbd class="calibre10">float</kbd> to <kbd class="calibre10">int</kbd>):</p>
<pre class="calibre21">let pi = 3.14; 
let new_pi = pi as i32; // new_pi = 3 </pre>
<p class="calibre1">However, the effects of precision-losing casts like this one may not be desirable. For instance, if you cast a float that's over the bit size of <kbd class="calibre10">i8</kbd> to <kbd class="calibre10">i8</kbd>, the number gets truncated to <kbd class="calibre10">0</kbd>:</p>
<pre class="calibre21">let n = 240.51; 
let n_as_int = n as i8; // n_as_int = 0   </pre>
<p class="calibre1">An error will occur if the types you are attempting to cast to are not compatible; for example:</p>
<pre class="calibre21">let my_home = "Newton-le-Willows"; 
let my_number = my_home as u32; // cannot convert &amp;str to u32 </pre>
<p class="calibre1">Rust does not do implicit casting between primitive types, even when it would be safe. That is, if a function expects an <kbd class="calibre10">i8</kbd> as a parameter, you must cast an <kbd class="calibre10">i16</kbd> value to <kbd class="calibre10">i8</kbd> before passing it. The reason for this is to achieve the maximum type checking and, therefore, reduce the number of potential (and more problematic) hidden bugs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">String methods</h1>
                
            
            
                
<p class="calibre1">Strings are important in any language. Without them, it becomes difficult to communicate with users, and if data is coming from a web service (in the form of XML, plain text, or JSON), this data will need to be manipulated. Rust provides the developer with a number of methods in the standard library to deal with strings. Here's a table of some useful methods (don't worry about the types yet):</p>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Method</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">What it does</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Usage (or example project)</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">from(&amp;str) -&gt; String</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method creates a new String from a string slice.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let s   = String::from("Richmond");   </pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">from_utf8( Vec &lt; u8 &gt; ) -&gt; Result&lt;String, FromUtf8Error&gt;</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method creates a new string buffer from a valid vector of UTF-8 characters. It will fail if the vector contains non-UTF8 data.</p>
</td>
<td class="calibre7">
<pre class="calibre21">   
let s   = String::from_utf8(vec!(33, 34)).expect("UTF8 decoding failed);   </pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">with_capacity(usize) -&gt; String</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method preallocates a String with a number of bytes.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let s   = String::with_capacity(10);   </pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">as_bytes -&gt; &amp;[u8]</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method outputs a String as a byte slice.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let s = "A String".to_owned();<br class="calibre2"/>let slice = s.as_bytes();</pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">insert(usize, char)</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method inserts <kbd class="calibre10">char</kbd> at position <kbd class="calibre10">index</kbd>.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let mut s = "A String".to_owned();<br class="calibre2"/>s.insert(2, 'S');<br class="calibre2"/>// s = "A SString"</pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">len -&gt; usize</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method returns the length of the String in bytes. It may therefore be larger than the number of characters in the String.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let s = "A String äö";<br class="calibre2"/>// s.len() =&gt; 13</pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">is_empty -&gt; bool</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method returns <kbd class="calibre10">true</kbd> if the String is empty.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let s1 = "".to_owned();<br class="calibre2"/>let s2 = "A String".to_owned();<br class="calibre2"/>// s1.is_empty() =&gt; true<br class="calibre2"/>// s2.is_empty() =&gt; false</pre></td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">is_char_boundary(usize) -&gt; bool</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">This method returns <kbd class="calibre10">true</kbd> if a character at <kbd class="calibre10">index</kbd> falls on a Unicode boundary.</p>
</td>
<td class="calibre7">
<pre class="calibre21">let s1 = "Hellö World";<br class="calibre2"/>// s1.is_char_boundary(5) =&gt; false<br class="calibre2"/>// s1.is_char_boundary(6) =&gt; true</pre></td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generics and arrays</h1>
                
            
            
                
<p class="calibre1">For those coming from a C# or C++ background, you will no doubt be used to generic types (often referred to as having a type <kbd class="calibre10">T</kbd>); you will be used to seeing things like this:</p>
<pre class="calibre21">T a = new T(); </pre>
<p class="calibre1">Generics allow defining methods for several types. In its most general form, <kbd class="calibre10">T</kbd> means "any type." The following function, for instance, takes two arguments that can be any type <kbd class="calibre10">T</kbd>:</p>
<pre class="calibre21">fn generic_function&lt;T&gt;(a: T, b: T) </pre>
<p class="calibre1"><kbd class="calibre10">T</kbd>, as has been established, can be of any type. This means that we cannot do much with them, since only a few methods are implemented for "any type." For instance, if we would like to add these variables together, we would need to restrict the generic types somewhat. We would essentially need to tell Rust that "T may be of any type, as long as it implements addition." More about this later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Arrays</h1>
                
            
            
                
<p class="calibre1">Arrays are simple to construct. For example:</p>
<pre class="calibre21">let my_array = ["Merseybus", "Amberline", "Crosville", "Liverbus", "Liverline", "Fareway"]; </pre>
<p class="calibre1">Arrays must comply with a number of rules, which are as follows:</p>
<ul class="calibre12">
<li class="calibre13">The array has a fixed size. It can never grow as it is stored as a continuous memory block.</li>
<li class="calibre13">The contents of the array can only ever be of one type.</li>
</ul>
<p class="calibre1">As with any type of variable, by default arrays are non-mutable. Even if the array is mutable, the overall size cannot be changed. For example, if an array has five elements, it cannot be changed to six.</p>
<p class="calibre1">We can also create an array with a type, as follows:</p>
<pre class="calibre21">let mut my_array_two: [i32; 4] = [1, 11, 111, 1111]; 
let mut empty_array: [&amp;str; 0] = []; </pre>
<p class="calibre1">It is also possible to create an array a number of times with the same value, as follows:</p>
<pre class="calibre21">let number = [111; 5]; </pre>
<p class="calibre1">This will create an array called <kbd class="calibre10">number</kbd> with <kbd class="calibre10">5</kbd> elements, all initialized to a value of <kbd class="calibre10">111</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Array performance</h1>
                
            
            
                
<p class="calibre1">While arrays are useful, they do have a performance hit; as with most operations on an array, the Rust runtime will perform bound checks to ensure the program does not access the array out of bounds. This prevents classic array overflow attacks and bugs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Vectors</h1>
                
            
            
                
<p class="calibre1">While arrays are simple to use, they have a single big disadvantage: they cannot be resized. The vector (<kbd class="calibre10">Vec</kbd>) acts in a way similar to a <kbd class="calibre10">List</kbd> in C#. It is also a generic type, as <kbd class="calibre10">Vec</kbd> itself is actually <kbd class="calibre10">Vec&lt;T&gt;</kbd>.</p>
<p class="calibre1">The <kbd class="calibre10">Vec</kbd> type is found in the standard library (<kbd class="calibre10">std::vec</kbd>).</p>
<p class="calibre1">To create a vector, we use something akin to either of the following:</p>
<pre class="calibre21">let mut my_vector: Vec&lt;f32&gt; = Vec::new(); // explicit definition </pre>
<p class="calibre1">Or this:</p>
<pre class="calibre21">let mut my_alt_vector = vec![4f32, 3.14, 6.28, 13.54, 27.08]; </pre>
<p class="calibre1">The <kbd class="calibre10">f32</kbd> within the <kbd class="calibre10">Vec</kbd> macro tells the compiler that the type for the vector is <kbd class="calibre10">f32</kbd>. The <kbd class="calibre10">f32</kbd> can be omitted, as the compiler can determine the type for the vector.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a vector with an initial size</h1>
                
            
            
                
<p class="calibre1">As with a String, it is possible to create a vector with an initial allocation of memory, as follows:</p>
<pre class="calibre21">let mut my_ids: Vec&lt;i64&gt; = Vec::with_capacity(30); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a vector via an iterator</h1>
                
            
            
                
<p class="calibre1">Another way to create a vector is via an iterator. This is achieved via the <kbd class="calibre10">collect()</kbd> method:</p>
<pre class="calibre21">let my_vec: Vec&lt;u64&gt; = (0..10).collect(); </pre>
<p>The format for the iterator is very convenient. Instead of the likes of <kbd class="calibre22">let foo = {0,1,2,3};</kbd>, this is shortened to use <kbd class="calibre22">..</kbd>, which means all numbers between <em class="calibre23">a</em> and <em class="calibre23">b</em> (<em class="calibre23">b</em> being excluded - so <kbd class="calibre22">0 .. 10</kbd> creates a vector containing 0,1,2,3,4,5,6,7,8,9). This can be seen in the source example supplied with this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding and removing from the vector</h1>
                
            
            
                
<p class="calibre1">In a similar fashion to string, it is possible to add and remove from the vector list using the <kbd class="calibre10">push</kbd> and <kbd class="calibre10">pull</kbd> methods. These add or remove from the top of the vector stack. Consider the following example:</p>
<pre class="calibre21">fn main() { 
    let mut my_vec : Vec&lt;i32&gt; = (0..10).collect(); 
    println!("{:?}", my_vec);  
    my_vec.push(13); 
    my_vec.push(21); 
    println!("{:?}", my_vec);  
    let mut twenty_one = my_vec.pop(); // removes the last value 
    println!("twenty_one= {:?}", twenty_one);  
    println!("{:?}", my_vec);  
} </pre>
<p class="calibre1">We create the vector list with values from 0 going up to 10 (so the last value is 9).</p>
<p class="calibre1">The line <kbd class="calibre10">println!("{:?}", my_vec);</kbd> outputs the entire contents of <kbd class="calibre10">my_vec</kbd>. <kbd class="calibre10">{:?}</kbd> is required here due to the type <kbd class="calibre10">Vec&lt;i32&gt;</kbd> not implementing certain formatting functionalities.</p>
<p class="calibre1">We then push onto the top of the vector list 13 then 21, display the output on the screen, and then remove the top-most value on the vector list, and output it again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Manipulating an array or vector via slices</h1>
                
            
            
                
<p class="calibre1">Both arrays and vectors can be accessed using a value (such as <kbd class="calibre10">my_vec[4]</kbd>). However, if you want to manipulate a section of the array, then you would take a slice from the array. A slice is like a window to a part of the original thing.</p>
<p class="calibre1">To create a slice, use this:</p>
<pre class="calibre21">let my_slice = &amp;my_vec[1..5];  </pre>
<p class="calibre1">A slice also has no predefined size: it can be 2 bytes, or it can be 202 bytes. Due to this, the size of the slice is not known at compile time. This is important to know, because it prevents certain methods from working.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Passing values around</h1>
                
            
            
                
<p class="calibre1">Up to this point, we have kept everything within a single method. For small demonstrations (or for method testing), this is fine. However, for larger applications, passing values between methods is essential.</p>
<p class="calibre1">Rust has two main ways to pass information to other methods: by reference or by value. Passing by reference usually implies borrowing, which means that ownership is only temporarily given and can be used again after the function call. Passing by value implies either a permanent ownership change, which means that the caller of a function can no longer access the value, or it might imply copying the data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Passing by value</h1>
                
            
            
                
<p class="calibre1">The following code shows how to pass a number between two functions, and to receive a result:</p>
<pre class="calibre21">fn main() 
{ 
    let add = add_values(3, 5);  
    println!("{:?}", add); 
} 
 
fn add_values(a: i32, b: i32) -&gt; i32 
{ 
    a + b 
} </pre>
<p class="calibre1">Let's have a look at the receiving function's definition line:</p>
<pre class="calibre21">fn add_values(a: i32, b: i32) -&gt; i32 </pre>
<p class="calibre1">As with any programming language, we have to give the function a name, and then a parameter list. The parameter names are followed by a colon and the type of the parameter.</p>
<p class="calibre1">Our function returns a value (this is signified by the <kbd class="calibre10">-&gt;</kbd> symbol) of a particular type (in this case, <kbd class="calibre10">i32</kbd>). The last evaluated thing in the function will be returned from the function, provided that you don't accidentally put a semi-colon there. An implicit return statement also exists, but it's not required and it's usually better style to omit it if possible.</p>
<p class="calibre1">When built and run, you will see the following:</p>
<div><img class="image-border6" src="img/00024.jpeg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Passing by reference</h1>
                
            
            
                
<p class="calibre1">A variable passed by a reference looks like this:</p>
<pre class="calibre21">fn my_function(a: &amp;i32, b: &amp;i32) -&gt; i32 </pre>
<p class="calibre1">We take two variables as references, and return a value.</p>
<p class="calibre1">To obtain a value from a reference, the first thing to do is dereference it. This is done with the asterisk (<kbd class="calibre10">*</kbd>) operator:</p>
<pre class="calibre21">let ref_num = &amp;2; 
let deref_num = *ref_num; 
// deref_num = 2 </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The reference type</h1>
                
            
            
                
<p class="calibre1">A reference is written in one of three ways: <kbd class="calibre10">&amp;</kbd>, <kbd class="calibre10">ref</kbd>, or <kbd class="calibre10">ref mut</kbd>:</p>
<pre class="calibre21">let mut var = 4; 
let ref_to_var = &amp;var; 
let ref second_ref = var; 
let ref mut third_ref = var; </pre>
<p class="calibre1">The references are all equivalent here. Note, however, that the preceding code doesn't work as it is due to mutable reference rules. Rust allows several immutable reference to a thing, but if a mutable reference is taken, no other references may exist at the time. Therefore, the last line would not work, since there are already two active references to var.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A practical example</h1>
                
            
            
                
<p class="calibre1">In the example code, <kbd class="calibre10">matrix</kbd>, we can see how to use a 2D array and how to pass by a reference, with the receiving function calculating the result of a matrix multiplication. Let's examine the code:</p>
<pre class="calibre21">fn main()  
{ 
    // first create a couple of arrays - these will be used 
    // for the vectors 
    let line1: [i32; 4] = [4, 2, 3, 3]; 
    let line2: [i32; 4] = [3, 4, 5, 7]; 
    let line3: [i32; 4] = [2, 9, 6, 2]; 
    let line4: [i32; 4] = [5, 7, 2, 4]; 
 
    // create two holding arrays and assign 
    // we are creating an array of references 
    let array_one = [&amp;line1, &amp;line3, &amp;line4, &amp;line2]; 
    let array_two = [&amp;line2, &amp;line1, &amp;line3, &amp;line4]; 
 
    // let's do the multiply 
    // we are passing in a ref array containing ref arrays 
    let result = matrix_multiply(&amp;array_one, &amp;array_two); 
    println!("{:?}", result); 
} 
 
fn matrix_multiply(vec1: &amp;[&amp;[i32;4];4], vec2: &amp;[&amp;[i32;4];4]) -&gt; [[i32; 4];4] 
{ 
    // we need to create the arrays to put the results into 
    let mut result = [[0i32; 4]; 4]; 
 
    // loop through the two vectors 
    for vone in 0..4 
    { 
       for vtwo in 0..4 
       { 
          let mut sum = 0; 
          for k in 0..4 
          { 
               sum += vec1[vone][k] * vec2[k][vtwo]; 
          } 
          result[vone][vtwo] = sum; 
       } 
    } 
    result 
} </pre>
<p class="calibre1">When compiled, you will get the following output:</p>
<div><img class="image-border6" src="img/00025.jpeg"/></div>
<p class="calibre1">What we need to really consider here is the definition line for the <kbd class="calibre10">matrix_multiply</kbd> function:</p>
<pre class="calibre21">fn matrix_multiply(vec1: &amp;[&amp;[i32;4];4], vec2: &amp;[&amp;[i32;4];4]) -&gt; [[i32; 4];4] </pre>
<p class="calibre1">If you recall how we told a function the name of the variable and the type earlier, we said it was <kbd class="calibre10">variable_name: variable_type</kbd>. The preceding line may look very much different, but it really isn't:</p>
<div><img src="img/00026.gif" class="image-border6"/></div>
<p class="calibre1">We are passing in a reference to a holding array, which holds references to other arrays. The array is defined using <kbd class="calibre10">[i32;4]</kbd>; therefore, the reference is <kbd class="calibre10">&amp;[i32;4]</kbd>. This is the inner array. The outer array <kbd class="calibre10">[i32;4]</kbd> is also a reference (<kbd class="calibre10">&amp;[i32;4]</kbd>), which has a size of 4. Therefore, when we put these together, we have the following:</p>
<div><img src="img/00027.jpeg" class="calibre24"/></div>
<p class="calibre1">The preceding example shows how to pass by a reference quite nicely, though in reality, it is most likely that the compiler will optimize this out to something faster for such a small data sample. It does show, however, how it's done.</p>
<p class="calibre1">The golden rule is that what you send over to the function has to marry up with what the function is expecting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre1">We have covered a great deal in this chapter, and I really encourage you to play around creating functions and passing values around.</p>
<p class="calibre1">If you don't want to continually create new projects every time you create a new application, you can create and test your code on the Rust Playground website (<a href="https://play.rust-lang.org" class="calibre3">https://play.rust-lang.org</a>). Here you can enter your code, hit Run, and see instantly if what you have written works.</p>
<p class="calibre1">In the next chapter, we will be covering getting information in and out, and validating your entries.</p>
<p class="calibre1"/>
<p class="calibre1"/>


            

            
        
    </body></html>