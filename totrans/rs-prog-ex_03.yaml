- en: Events and Basic Game Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw how to add dependencies into a project thanks to
    `Cargo` and the basics of the `SDL2` library.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the Rust basics in order to write the Tetris game. Time to look
    at how we will actually write Tetris.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Tetrimino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tetriminos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a tetrimino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tetris struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the game map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SDL events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score, level, lines sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Tetris
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s review the Tetris rules (just in case):'
  prefs: []
  type: TYPE_NORMAL
- en: There is a grid with a height of 16 blocks and a width of 10 blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have seven different `tetrimino` (a tetris piece) that are all composed
    of four blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `tetrimino` appears at the top of the game's grid every time the previous
    one cannot descend any more (because the block below is already occupied or because
    you've reached the game's floor).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is over when a new `tetrimino` cannot appear anymore (because there
    is already a tetrimino at the top of the grid).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time a line is *full* (all blocks are occupied by a `tetrimino` part),
    it disappears and all lines above descend by one line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we all agree on the game rules, let's see how to actually write those
    mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to actually create those `tetrimino`s.
  prefs: []
  type: TYPE_NORMAL
- en: Tetrimino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As said previously, every `tetrimino` has four blocks. Another thing to note
    is that they can rotate. So for example you have this `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00012.jpeg)*Figure 3.1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also rotate in the three following positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.jpeg)*Figure 3.2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, every `tetrimino` should have four states, but in reality, not
    all of them do. For example, this one has no transformation so to speak:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)*Figure 3.3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And these three only have two states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)*Figure 3.4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways of handling these rotations: using matrix rotation or storing
    the different states. To have a code that''s easy to read and update, I picked
    the second option, but don''t hesitate to try using matrix on your own, it could
    help you learn a lot of new things!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, let''s write down a `struct` for `tetrimino`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything seems fine except this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pretty ugly, right? Let's make it look a bit better by using type aliasing!
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is our `states` field representing? Simply a list of states. Each state
    represents a piece''s transformation. I suppose it''s a bit hard to understand
    all of this. Let''s write an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In here, `0` means the block is empty, otherwise, it''s a `tetrimino` block.
    So from reading this code, I suppose you could guess that we were representing
    the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.jpeg)*Figure 3.5*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you wondered, we have four lines with four blocks because the *biggest *`tetrimino`
    has a height (or a width, depending the transformation) of four:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)*Figure 3.6*'
  prefs: []
  type: TYPE_NORMAL
- en: This isn't mandatory (we could make it fit the form of each `tetrimino`), but
    it makes our lives easier, so why not?
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our type aliasing: a piece is basically a vector or vector of
    numbers. It''s long to write it down every time, so let''s alias it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can rewrite the `states` field declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Way better and more explicit, right? But since we'll be using those states as
    well, why not alias them too?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And now our `states` field declaration becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the other fields (just in case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A little explanation of this struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`states` (if you didn''t already understand it) is the list of possible states
    of the `tetrimino`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is the *x* position of the `tetrimino`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` is the *y* position of the `tetrimino`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_state` is the state in which the `tetrimino` is currently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ok, so far so good. Now how should we handle the creation of this type generically?
    We don't want to rewrite this for every `tetrimino`. This is where `traits` kick
    in!
  prefs: []
  type: TYPE_NORMAL
- en: Creating tetriminos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wrote the type that will be used in our game, but we didn't write its initialization/creation
    yet. This is where Rust `trait`s will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing a generator trait that will be implemented on all `tetrimino`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. This `trait` just provides a function that creates a new `Tetrimino`
    instance. It maybe doesn't like this very much, but thanks to this `trait`, we'll
    be able to easily create all our `tetrimino`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to write our first `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'No need to look for more code, this is what a `tetrimino` really looks like.
    It''s an empty structure. The interesting part comes just after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)*Figure 3.7*'
  prefs: []
  type: TYPE_NORMAL
- en: In here, a number represents a color and `0` means no color (because there is
    no block).
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s it. Now you can create this `tetrimino` just by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It'll return an instance of the `Tetrimino` structure and that's the one you'll
    be using in the game. The other `tetrimino` structures (such as `TetriminoI` in
    here) are just used to generically create the `Tetrimino` structure with the related
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to create all the other `tetrimino` as well, so let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In case you're wondering why the blocks have `2` as values, it's simply so that
    we can differentiate them when displaying them (having all `tetrimino` with the
    same color wouldn't be very pretty...). It has no other meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `tetrimino` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)*Figure 3.8*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go for the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This `tetrimino` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)*Figure 3.9*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `tetrimino` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)*Figure 3.10*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another `tetrimino` (will it ever end?!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This `tetrimino` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)*Figure 3.11*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Guess what? Another `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This `tetrimino` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)*Figure 3.12*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last one (finally!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, this `tetrimino` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)*Figure 3.13*'
  prefs: []
  type: TYPE_NORMAL
- en: Phew... That was quite a lot of code! Easy code, but still a lot!
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to see how we can generate a new `tetrimino` randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a tetrimino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to do so, we'll need to import another `crate`—`rand`. This `crate`
    is used to generate random numbers and that is exactly what we need here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following line to your `Cargo.toml` file (in the `[dependencies]`
    section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following line to your `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''re done! Now we can write the generation function of the `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty easy, right? Though, please note that this is a bit too random. It''d
    be problematic if we had the same `tetrimino` generated more than twice in a row
    (which is already a lot!), so let''s improve this function a bit by adding a `static`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A bit of explanation might be helpful here. First, what is a `static` variable?
    It''s a variable that will keep its value and won''t be destroyed when the scope
    it has been created inside has been left. An example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute this code, it''ll print out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the other properties of the `static` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: It cannot have a destructor (it's possible to avoid this limitation by using
    the `lazy_static` crate though, but we won't talk about it here) so only *simple*
    types that don't implement the `Drop` trait can be used as `static`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the value of a `static` variable is unsafe (that's why there are `unsafe`
    blocks) for the simple reason that the `static` is shared between all threads
    in the program and can be modified and read at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the value of a mutable `static` is unsafe (for the reason mentioned
    previously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have a function that can generate a `tetrimino`. We now need to add
    the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the rotation part!
  prefs: []
  type: TYPE_NORMAL
- en: Rotating a tetrimino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to how we created the `Tetrimino` type, it''s quite easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''re done. However, we don''t check anything: what happens if there is
    a block already used by another `tetrimino`? We''ll just overwrite it. Such a
    thing cannot be accepted!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform this check, we''ll need the game *map* as well. It''s simply
    a vector line and a line is a vector of `u8`. Or, more simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering that it isn''t too hard to read, we''ll just keep it this way.
    Now let''s write the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Before explaining this function, it seems important to explain why the game
    map became a `&[Vec<u8>]`. When you send a non-mutable reference over a vector
    (`Vec<T>`), it is then dereferenced into a `&[T]` slice, which is a constant *view* over
    the vector's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we''re done (for this method)! Now time for explanations: we loop over
    every block of our `tetrimino` and check whether the block is free in the game
    map (by checking whether it is equal to `0`) and if it isn''t going out of the
    game map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `test_position` method, we can update the `rotate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A bit longer, indeed. Since we can''t be sure that the piece will be put where
    we want it to go, we need to make temporary variables and then check the possibilities.
    Let''s go through the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is *exactly* what our `rotate` method did before, except that now, we
    use temporary variables before going further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This line on its own doesn''t make much sense but it''ll be very useful next:
    in case the piece cannot be placed where we want, we try to move it on the `x`
    axis to see if it''d work in some other place. It allows you to have a Tetris
    that is much more flexible and comfortable to play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the explanations given previously, this loop should be really easy to understand.
    For each `x` shift, we check whether the piece can be placed there. If it works,
    we change the values of our `tetrimino`, otherwise we just continue.
  prefs: []
  type: TYPE_NORMAL
- en: If no `x` shift worked, we just leave the function without doing anything.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can rotate and test the position of a `tetrimino`, it'd be nice
    to actually move it as well (when the timer goes to 0 and the `tetrimino` needs
    to go down, for example). The main difference with the `rotate` method will be
    that, if the `tetrimino` cannot move, we'll return a Boolean value to allow the
    caller to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Another difference that you have certainly already spotted is that we don't
    check multiple possible positions, just the one received. The reason is simple; contrary
    to a rotation, we can't move the `tetrimino` around when it receives a move instruction.
    Imagine asking the `tetrimino` to move to the right and it doesn't move, or worse,
    it moves to the left! We can't allow it and so we're not doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now about the method''s code: it''s very simple. If we can put the `tetrimino` in
    a place, we update the position of the `tetrimino` and return true, otherwise,
    we do nothing other than return false.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work is performed in the `test_position` method, allowing our method
    to be really small.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these three methods, we have almost everything we need. But for even more
    simplicity in the future, let''s add one more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use it when we generate a new `tetrimino`: if it cannot be placed where
    it appeared because another `tetrimino` is already there, it means the game is
    over.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now say that our `Tetrimino` type is fully implemented. Congratulations!
    Time to start the game type!
  prefs: []
  type: TYPE_NORMAL
- en: Tetris struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type will be the one holding all the game''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: Game map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current `tetrimino`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some potential other information (such as a ghost, or the preview of the next
    `tetrimino`!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write down this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once again, pretty simple. I don't think any additional information is required
    so let's continue!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing the `new` method for this new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing really complicated except maybe the loop. Let''s look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We know that a `tetris` map has a width of 10 blocks and a height of 16 blocks.
    This loop creates our game map by looping over the number of lines and generating
    an empty vector of 10 blocks, which will be a line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from this, everything else is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: You start at level 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With your score at 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With 0 lines sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No current `tetrimino`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by generating a new `tetrimino` randomly. For this, you''ll require
    the `rand` crate. Add the following to your `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add this at the top of your `main` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can write the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `static` keyword is the same in `Rust` as it is in `C` and `C++` for variables:
    the value set to the variable will be kept between the function calls. So for
    example, if you write the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And you then call it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, why do we have these `unsafe` blocks? The reason is quite simple: in
    case the static variable is accessed and modified from different threads, you
    can''t be *sure* that you won''t have data race, concurrency errors, or even memory
    errors.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since we don't have threads, it's fine. However, keep in mind
    that you should ALWAYS try to avoid unsafe at all costs and use it ONLY when nothing
    else can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if our static variable wasn''t mutable, then we could access its value
    without needing the `unsafe` blocks. The reason once again is simple: even if
    multiple threads try to access its value at the same time, since this value cannot
    change, you can''t have data race and therefore it is safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with our function''s code explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This line generates a random `u8` and then limits its value between 0 (included)
    and 6 (included) because we have seven different `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the generated `tetrimino` is the same as the previous one, we generate another
    one. It enables you to prevent having the same `tetrimino` too many times at once.
    It isn''t the best way to do it, having a specific balancing for each `tetrimino`
    would be better, but this solution is acceptable enough (and a lot easier to write!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We now set the generated `tetrimino` *ID* to our `static` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing much to say about this pattern matching. Every *ID* matches a `tetrimino`
    and then we call the corresponding constructor. The only really interesting thing
    about this construction is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This macro is really useful. It allows us to add a security over the matched
    value. If the code ever enters this pattern matching, it'll panic right away (because,
    as the macro's name suggests, it's not supposed to happen).
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the game map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ok, we can now move all the `tetrimino` and generate them. Two mechanisms are
    still missing: checking lines to see whether one can be sent (that is, removed
    since complete) and making a `tetrimino` *permanent *(that is, not movable anymore).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the line check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For now, I didn't add the score, lines sent counting, nor level handling but
    this is here that'll do it later.
  prefs: []
  type: TYPE_NORMAL
- en: Now time to explain this method a bit. Its purpose is to remove lines when they're
    full (meaning when every block is occupied by a `tetrimino` block). So we just
    go through the game map line by line and run the check on each.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code itself doesn''t use much of the Rust-specific syntax, but you might
    wonder why we did it like this. I''m talking about this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we could have just used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is actually a good question and the answer is simple, but maybe hard to
    understand, if you're used to how Rust ownership works.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the problems actually come from this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In here, we mutably borrow `self.game_map` in order to remove a line. However,
    `self.game_map` would already be non-mutably borrowed by the `for` loop! A quick
    reminder on how the borrowing rules work:'
  prefs: []
  type: TYPE_NORMAL
- en: You can non-mutably borrow a variable as many times as you want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mutably borrow a variable only if there are no other borrows (either
    mutable or non-mutable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So in our case, the `for` loop would break the second rule since we'd have a
    non-mutable borrow when trying to get mutable access to `self.game_map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have two solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the game map "by hand" (with an index variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store lines to remove into a second vector and then remove them after we get
    out of the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both solutions are more or less equivalent in this case so I just picked the
    first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the first loop is finished, we have filled the game map with empty lines
    to replace the one(s) we deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: And we're done with this method! Let's write the other one.
  prefs: []
  type: TYPE_NORMAL
- en: So now it's time to write the `make_permanent` method. Just like the previous
    one, it won't be a complete version, but in the future, this is where we'll update
    the score (we update it when a `tetrimino` is made permanent).
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This code doesn''t seem very encouraging... Brace yourselves, explanations
    are coming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s simple pattern matching. If `self.current_piece` is `Some`, then we enter
    the condition and the value contained by `Some` that is bound into the `piece`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This loop and its condition allow us to avoid a buffer overflow error by checking
    whether we're not outside of the game map limit for the current rotation (that
    is, `self.current_state`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for the inner loop (which iterates over the blocks of a line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It is in this loop that we write the blocks of the current `tetrimino` into
    the game map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If the current block of the current `tetrimino` isn't empty, then we put it
    into the game map (it's as simple as that).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, this is where we call the `check_lines` method. But now you''ll
    certainly wonder why we don''t call it directly inside the `if let` condition.
    Well, it''s for the exact same reason that we didn''t use the `for` loop inside
    the `check_lines` method, `self` is already mutably borrowed by the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s right: if an element of a type is borrowed, then its parent is mutably
    borrowed as well!'
  prefs: []
  type: TYPE_NORMAL
- en: With these two methods, our `Tetris` type is now fully implemented (minus the
    small required modifications that will come later). Time to add the `SDL` events
    handling!
  prefs: []
  type: TYPE_NORMAL
- en: SDL events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There aren''t many different events to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Left* and *right arrow* keys to move the `tetrimino` to the right or the left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Up arrow* key to make the `tetrimino` rotate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Down arrow* key to make the `tetrimino` descend one block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Spacebar* to make the `tetrimino` descend to the bottom instantly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Escape* to quit the game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s still possible to add some later on (such as pausing the game with the
    *return* key, for example) but for now, let''s focus on these ones. For this,
    go back inside the main loop of the game (inside the `main` function) and replace
    the current event handling with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite a big one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable will tell us whether the current `tetrimino` is still falling.
    If not, then it becomes `true`, the `tetrimino` is then put into the game map
    and we generate a new one. Luckily for us, we already wrote all the needed functions
    to perform these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple pattern binding. If our game doesn''t have a current piece (for
    some reason), then we don''t do anything and just leave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a move on the `x` or on the `y` axis, we''ll write it into these
    variables and then we''ll test whether the `tetrimino` can actually go there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As there can be multiple events that happened since the last time we came into
    this function, we need to loop over all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re arriving at the interesting part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can almost consider this small code as the core of our application, without
    it, no interaction with the program is possible. If you want more interactions,
    this is where you''ll add them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If we receive a *quit* event from `sdl` or if we receive an `Escape`, `KeyDown`
    event, we set the `quit` variable to `true`. It''ll be used outside of this function
    to then leave the main loop--and therefore leave the program itself. Then we *break;* no
    need to go further since we know that we''re leaving the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If the *down arrow* is pressed, we need to make our `tetrimino` descend by one
    block and also put the `timer` value to now. `timer` is used to know at what speed
    the `tetrimino` blocks are falling. The shorter the time, the faster they'll descend.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, it isn''t used in this function, so we''ll see how to handle it outside
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In here, we handle the *right* and *left arrow* keys. It''s just like the *down
    arrow* key, except we don''t need to change the `timer` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we receive an *up arrow* key pressed event, we rotate the `tetrimino`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally the last of our events: the *spacebar* key pressed event. Here,
    we move the `tetrimino` down as much as we can and then set the `make_permanent`
    variable to `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: With this, that's it for our events. However, like we said before if you want
    to add more events, this is where you should put them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to put all this into our main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Doesn't seem that long, right? Just a few comments where we're supposed to draw
    our `Tetris`, but otherwise everything is in there, which means that our `Tetris`
    is now fully functional (even though it isn't displayed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain what''s happening in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In here, we initialize both our `Tetris` object and the `timer`. The timer
    will be used to let us know when the `tetrimino` is supposed to descend by one
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This code checks whether it''s been one second or more since the last time
    the `tetrimino` descended by one block. If we want to handle levels, we''ll need
    to replace the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Its replacement will need to be something more generic and we'll add an array
    to store the different levels' speed of descent.
  prefs: []
  type: TYPE_NORMAL
- en: So coming back to the code, if it's been one second or more then we try to make
    the `tetrimino` descend by one block. If it cannot, then we put it into the game
    map and re-initialize the `timer` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, you might wonder why we had to create the `make_permanent` variable
    instead of directly checking the output of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It has an `if` condition, right? Well, just like the previous times, it''s
    because of the borrow checker. We borrow `tetris` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'So as long as we''re in this condition, we can''t use `tetris` mutably, which
    is why we store the result of the condition in `make_permanent` so we can use
    the `make_permanent` method after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If there is no current `tetrimino`, we need to generate a new one, which we
    do by calling the `create_new_tetrimino` method. Then we check whether it can
    be put into the game on the top line by calling the `test_current_position` method.
    If not, then it means the game is over and we quit. Otherwise, we store the newly-generated
    `tetrimino` in `tetris.current_piece` and we move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are missing here:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't handle the increase of lines sent, nor the score, nor the level,
    there's no need to print them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We didn't add yet the highscores loading/overwrite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, we''ll add all this later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This code calls the `handle_events` function and acts according to its output.
    It returns whether the current `tetrimino` has been put into the game map or not.
    If it is the case, then there is no need to draw it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to do the following remaining things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the score, levels, and number of lines sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load/overwrite the highscores if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually draw the `Tetris`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seems like we're getting very close to the end! Let's start by adding the score,
    number of lines sent, and levels!
  prefs: []
  type: TYPE_NORMAL
- en: Score, level, lines sent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest required change will be the level handling. You need to create an
    array with different times to increase the `tetrimino`'s speed of descent and
    to check whether the level needs to be changed or not (based on the number of
    lines).
  prefs: []
  type: TYPE_NORMAL
- en: 'The score will be updated in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When the `tetrimino` is made permanent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a line is sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player makes a `Tetris` (no more blocks in the game map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the easiest change—the score.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the following method into our `Tetris` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can suppose that no additional explanations are required here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s update a few methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we create a temporary variable (here, `score_add`) and once the borrow
    of `self` is over, we call the `update_score` method. There is also the usage
    of the `increase_line` method. We haven't defined it yet; it'll come just after.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method is `make_permanent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Include this just above the `self.check_lines` call.
  prefs: []
  type: TYPE_NORMAL
- en: With these two methods updated, we now have the score handling fully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Levels and lines sent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next two being strongly bound (the level depends directly on the number
    of lines sent), we'll implement them at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing anything else, let''s define the two following `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The first one corresponds to the times before the current `tetrimino` descends
    by one block. Each case being a different level.
  prefs: []
  type: TYPE_NORMAL
- en: The second one corresponds to how many lines the player needs before getting
    to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the following method in our `Tetris` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Nothing complicated. Just be careful when reading the `LEVEL_LINES` const because
    our `current_level` variable starts at `1` and not 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll need to update how we determine whether the time is up or not.
    To do so, let''s write another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: A small but tricky one. The problem is that the type returned by `timer.elapsed`
    (which is `Duration`) doesn't provide a method to get the number of milliseconds,
    so we need to get it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the number of seconds elapsed and then multiply it by 1,000 (because
    1 second = 1,000 milliseconds). Finally, we get the number of nanoseconds (in
    the current second) and divide it by 1,000,000 (because 1 millisecond = 1 million
    nanoseconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now compare the results to see whether the `tetrimino` should descend
    or not and return the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And with this, we''ve finished this part. Let''s make the last one now: the
    highscore loading/overwriting!'
  prefs: []
  type: TYPE_NORMAL
- en: Highscores loading/overwriting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw how to perform the I/O operations in the previous chapter, so
    it''ll be very quick to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Not much to explain with this code. For the moment, we limited the number of
    each highscore to `5`. Just update it as you want.
  prefs: []
  type: TYPE_NORMAL
- en: And with this code, all the mechanisms are implemented. All that's left is to
    actually draw the game!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! That was quite the chapter! But now, all the game's mechanisms are here
    so adding the last remaining parts (such as the drawing) will be a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, be sure to understand this chapter before starting to read the next
    one.
  prefs: []
  type: TYPE_NORMAL
