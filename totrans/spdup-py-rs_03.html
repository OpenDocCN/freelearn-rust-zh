<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer057">&#13;
			<h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor062"/>Chapter 4</em>: Building pip Modules in Python</h1>&#13;
			<p>Writing code to solve our problems is useful. However, writing code can become repetitive and time-consuming, especially when we are building applications. Applications usually require defining the steps that build the application. Packaging our code can help us reuse our code and share it with other developers. In this chapter, we will package Fibonacci code into a Python <strong class="source-inline">pip</strong> module that can be easily installed and has a command-line tool. We will also cover continuous integration processes that deploy our packages once a merge has been achieved to our <strong class="source-inline">main</strong> branch.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Configuring setup tools for a Python <strong class="source-inline">pip</strong> module</li>&#13;
				<li>Packaging Python code in a <strong class="source-inline">pip</strong> module</li>&#13;
				<li>Configuring continuous integration</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Technical requirements</h1>&#13;
			<p>We will need to have Python 3 installed. To get the most out of this chapter, we will also need to have a GitHub account, as we will be using GitHub to package our code, which can be accessed via this link: <a href="https://github.com/maxwellflitton/flitton-fib-py">https://github.com/maxwellflitton/flitton-fib-py</a>. </p>&#13;
			<p>Git command-line tools are also needed in this chapter. These can be installed by following the instructions here: <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>. The chapter will also make use of a PyPI account. You will need to have your own PyPI account, which can be obtained for free with this link: <a href="https://pypi.org/">https://pypi.org/</a>. </p>&#13;
			<p>The code for this chapter can be found via this link: <a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four</a>.</p>&#13;
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Configuring setup tools for a Python pip module</h1>&#13;
			<p>Setup tools in <a id="_idIndexMarker228"/>Python are how the code in our<a id="_idIndexMarker229"/> module is packaged and installed. They provide a set of commands and parameters for the system that is installing the code to process. To explore how this is done, we will package the Fibonacci numbers example introduced in the previous chapter. However, these calculations will be packaged in a <strong class="source-inline">pip</strong> module. To configure our setup tools, we are going to have to carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Create a GitHub <a id="_idIndexMarker230"/>repository for our Python <strong class="source-inline">pip</strong> package.</li>&#13;
				<li>Define basic parameters. </li>&#13;
				<li>Define a <strong class="source-inline">README</strong> file.</li>&#13;
				<li>Define a basic module structure.</li>&#13;
			</ol>&#13;
			<p>Let's have a look at each of these steps in detail in the following subsections.</p>&#13;
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Creating a GitHub repository</h2>&#13;
			<p>Understandably, a<a id="_idIndexMarker231"/> seasoned developer can create a GitHub repository but for the sake of completeness, we will offer <a id="_idIndexMarker232"/>all the steps needed. If you can already create a GitHub repository, move on to the next subsection:</p>&#13;
			<ol>&#13;
				<li value="1">On the home URL of GitHub when we are logged in, we can create our repository by clicking on the <strong class="bold">New</strong> button, as shown here:<div id="_idContainer045" class="IMG---Figure"><img src="Images/Figure_4.01_B17720.jpg" alt="Figure 4.1 – How to create a new repository on GitHub&#13;&#10;" width="1278" height="335"/></div><p class="figure-caption">Figure 4.1 – How to create a new repository on GitHub</p></li>&#13;
				<li>Once this is<a id="_idIndexMarker233"/> clicked, we can <a id="_idIndexMarker234"/>configure our new repository with the parameters shown next:<div id="_idContainer046" class="IMG---Figure"><img src="Images/Figure_4.02_B17720.jpg" alt="Figure 4.2 – Parameters for our new GitHub repository&#13;&#10;" width="770" height="997"/></div><p class="figure-caption">Figure 4.2 – Parameters for our new GitHub repository</p><p>For this <a id="_idIndexMarker235"/>example, we have set the GitHub repository to <strong class="bold">Public</strong>; however, our <strong class="source-inline">pip</strong> packaging for this chapter<a id="_idIndexMarker236"/> will also work the same way for private repositories. We have also included a <strong class="source-inline">.gitignore</strong> file and selected it to be Python. This is to stop Python caching and for virtual environment files to be tracked by GitHub and uploaded when we upload our code to the repository. Now that we have our GitHub repository made, going to the repository will look like this:</p><div id="_idContainer047" class="IMG---Figure"><img src="Images/Figure_4.03_B17720.jpg" alt="Figure 4.3 – Our GitHub repository home page&#13;&#10;" width="1297" height="524"/></div><p class="figure-caption">Figure 4.3 – Our GitHub repository home page</p><p>We can <a id="_idIndexMarker237"/>see that our <a id="_idIndexMarker238"/>description is written in the <strong class="source-inline">README.md</strong> file. It also has to be noted that the <strong class="source-inline">README.md</strong> file is rendered. This happens in any directory of the repository. We can document what to do and how to use the code throughout the repository with a range of <strong class="source-inline">README.md</strong> files if we want.</p></li>&#13;
				<li>Once this is done, we can download our repository with the command shown next:<p class="source-code"><strong class="bold">git clone https://github.com/maxwellflitton/flitton-</strong></p><p class="source-code"><strong class="bold">  fib-py.git</strong></p><p>Your URL will be different, as you have a different repository. The only thing left is to ensure that our development environment for our repository has a Python virtual environment.</p></li>&#13;
				<li>This can be done by navigating to the root directory of the GitHub repository and then running the command shown here:<p class="source-code"><strong class="bold">python3 -m venv venv</strong></p><p>This creates a Python virtual environment under the <strong class="source-inline">venv</strong> directory in the root directory. We have to use the <strong class="source-inline">venv</strong> directory, as this is automatically included in the <strong class="source-inline">.gitignore</strong> file. However, there is nothing stopping us from calling it what we want, as long as we include it in the <strong class="source-inline">.gitignore</strong> file. However, <strong class="source-inline">venv</strong> is the convention, and using this will avoid confusion with other developers. Our environment is now fully set up. </p></li>&#13;
				<li>To use our <a id="_idIndexMarker239"/>virtual environment<a id="_idIndexMarker240"/> in the terminal, we can activate it with the command shown next:<p class="source-code"><strong class="bold">source venv/bin/activate</strong></p></li>&#13;
			</ol>&#13;
			<p>We can see that our command is prefixed with <strong class="source-inline">(venv)</strong>, meaning that it is active.</p>&#13;
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Defining the basic parameters</h2>&#13;
			<p>Now that our <a id="_idIndexMarker241"/>environment is fully functional, we are going to define the basic parameters when installing our Python <strong class="source-inline">pip</strong> module:</p>&#13;
			<ol>&#13;
				<li value="1">This is achieved by creating a <strong class="source-inline">setup.py</strong> file in the root of our repository. This will get run when another Python system installs our <strong class="source-inline">pip</strong> module. In our <strong class="source-inline">setup.py</strong> file, we import our setup tools with the code shown here:<p class="source-code">from setuptools import find_packages, setup</p><p>We are going to use <strong class="source-inline">setup</strong> to define our parameters, and we are going to use <strong class="source-inline">find_packages</strong> to exclude tests.</p></li>&#13;
				<li>Now that we have imported our setup tools, we can define our parameters in the same file with the code shown here:<p class="source-code">setup(</p><p class="source-code">    name="flitton_fib_py",</p><p class="source-code">    version="0.0.1",</p><p class="source-code">    author="Maxwell Flitton",</p><p class="source-code">    author_email="maxwell@gmail.com",</p><p class="source-code">    description="Calculates a Fibonacci number",</p><p class="source-code">    long_description="A basic library that \</p><p class="source-code">      calculates Fibonacci numbers",</p><p class="source-code">    long_description_content_type="text/markdown",</p><p class="source-code">    url="https://github.com/maxwellflitton/flitton- \</p><p class="source-code">      fib-py",</p><p class="source-code">    install_requires=[],</p><p class="source-code">    packages=find_packages(exclude=("tests",)),</p><p class="source-code">    classifiers=[</p><p class="source-code">        "Development Status :: 4 - Beta",</p><p class="source-code">        "Programming Language :: Python :: 3",</p><p class="source-code">        "Operating System :: OS Independent",</p><p class="source-code">    ],</p><p class="source-code">    python_requires='&gt;=3',</p><p class="source-code">    tests_require=['pytest'],</p><p class="source-code">)</p><p>There <a id="_idIndexMarker242"/>are a lot of parameters here. What we have done from the <strong class="source-inline">name</strong> field to <strong class="source-inline">url</strong> is essentially define the metadata around our <strong class="source-inline">pip</strong> module. The <strong class="source-inline">classifiers</strong> fields are also metadata around our module. The rest of the fields have the following effects:</p><ul><li>The <strong class="source-inline">Install_requires</strong> field is currently an empty list. This is because our module is not requiring any third-party modules right now. We will cover dependencies in <em class="italic">Managing dependencies</em> section. </li><li>The <strong class="source-inline">packages</strong> field ensures that we exclude our <strong class="source-inline">test</strong> directory when we start building our tests for our module. While we will use tests to check our module and ensure standards, we do not need to install them when we are using our module as a third-party dependency. </li><li>The <strong class="source-inline">Python_requires</strong> field ensures that the system installing our module has the correct version of Python installed. </li><li><strong class="source-inline">tests_require</strong> is a list of requirements when tests are running. </li></ul></li>&#13;
				<li>Now that <a id="_idIndexMarker243"/>we have defined our basic setup, we can upload our code with the following commands:<p class="source-code"><strong class="bold">git add -A</strong></p><p class="source-code"><strong class="bold">git commit -m "adding setup to module"</strong></p><p class="source-code"><strong class="bold">git push origin main</strong></p></li>&#13;
			</ol>&#13;
			<p>What we have done here is add all of the new and changed files to our Git branch (which is <strong class="source-inline">main</strong>). We then committed our files with the <strong class="source-inline">adding setup to module</strong> message. We then pushed our code to the <strong class="source-inline">main</strong> branch, which means that we uploaded our changes onto the Git repository online. This is not the best way to manage our code iterations. We will go over different branches and how to manage them in the continuous integration section near the end of this chapter.</p>&#13;
			<p>You may have noticed that <strong class="source-inline">long_description</strong> is a Markdown; however, trying to fit an entire Markdown into this field would end up dominating the <strong class="source-inline">setup.py</strong> file. It would essentially be a long string spanning multiple lines, with a few Python lines dispersed into it. We want our <strong class="source-inline">setup.py</strong> file to dictate the logic of setting up the module when it is being installed. We also want our long description of the module to be rendered by <a id="_idIndexMarker244"/>GitHub when we visit the GitHub repository directly online. Because of this, we will need to add some extra logic around defining our long description in the next section.</p>&#13;
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Defining a README file</h2>&#13;
			<p>Our long <a id="_idIndexMarker245"/>description is essentially the <strong class="source-inline">README.md</strong> file. If we fuse this with our <strong class="source-inline">setup.py</strong>, our <strong class="source-inline">README.md</strong> file will also render if we visit it on PyPI and it is uploaded to the PyPI server. This can be done by <a id="_idIndexMarker246"/>reading the <strong class="source-inline">README.md</strong> file into a string in the <strong class="source-inline">setup.py</strong> file and then plugging that string into our <strong class="source-inline">long_description</strong> field with the following code in the <strong class="source-inline">setup.py</strong> file:</p>&#13;
			<p class="source-code">with open("README.md", "r") as fh:</p>&#13;
			<p class="source-code">    long_description = fh.read()</p>&#13;
			<p class="source-code">setup(</p>&#13;
			<p class="source-code">    name="flitton_fib_py",</p>&#13;
			<p class="source-code">    version="0.0.1",</p>&#13;
			<p class="source-code">    author="Maxwell Flitton",</p>&#13;
			<p class="source-code">    author_email="maxwell@gmail.com",</p>&#13;
			<p class="source-code">    description="Calculates a Fibonacci number",</p>&#13;
			<p class="source-code">    long_description=long_description,</p>&#13;
			<p class="source-code">    ...</p>&#13;
			<p>The rest of the code after <strong class="source-inline">...</strong> is the same as before. With this, our basic module setup is complete. Now, all we need is to do is define a basic module to install and use, which is what we will do in the next step.</p>&#13;
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Defining a basic module</h2>&#13;
			<p>Defining a <a id="_idIndexMarker247"/>basic module takes the following structure:</p>&#13;
			<p class="source-code">├── LICENSE</p>&#13;
			<p class="source-code">├── README.md</p>&#13;
			<p class="source-code">├── flitton_fib_py</p>&#13;
			<p class="source-code">│   └── __init__.py</p>&#13;
			<p class="source-code">├── setup.py</p>&#13;
			<p class="source-code">└── venv</p>&#13;
			<p>We house the actual code that the user will have in our <strong class="source-inline">flitton_fib_py</strong> directory. For now, we are just going to have a basic function that prints something out so that we can see if our<a id="_idIndexMarker248"/> <strong class="source-inline">pip</strong> package works. Here are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">We do this by adding a basic <strong class="source-inline">print</strong> function in the <strong class="source-inline">flitton_fib_py/__init__.py</strong> file that has the following code:<p class="source-code">def say_hello() -&gt; None:</p><p class="source-code">    print("the Flitton Fibonacci module is saying hello")</p><p>Once this is done, we can upload the code to the GitHub repository using the git commands described in the <em class="italic">Packaging Python code in a pip module</em> section. We should now see all the code of our module in the <strong class="source-inline">main</strong> branch. Considering this, we need to navigate to another directory that is not associated with our <strong class="source-inline">git</strong> repository. </p></li>&#13;
				<li>We then unlink our virtual environment by typing the following command:<p class="source-code"><strong class="bold">deactivate</strong></p><p>We can then create a new virtual environment using the steps covered in the first section and activate it. Now, we are ready to install our package in our new virtual environment using <strong class="source-inline">pip install</strong> and check to see whether it works.</p></li>&#13;
				<li>To use <strong class="source-inline">pip install</strong>, we point to the URL of the GitHub repository that our <strong class="source-inline">pip</strong> module is stored and define which branch it is. We do this by typing the following <a id="_idIndexMarker249"/>command, all in one line:<p class="source-code"><strong class="bold">pip install git+https://github.com/maxwellflitton/</strong></p><p class="source-code"><strong class="bold">  flitton-fib-py@main</strong></p><p>Your GitHub repository will have a different URL and you might have a different directory. Running this command will give us a range of printouts, stating that it is cloning the repository and installing it.</p></li>&#13;
				<li>We then<a id="_idIndexMarker250"/> open up a Python terminal by typing in the following command:<p class="source-code"><strong class="bold">python</strong></p></li>&#13;
				<li>We now have an interactive terminal. We can check to see whether our module works by typing in the following commands:<p class="source-code"><strong class="bold">&gt;&gt;&gt; from flitton_fib_py import say_hello</strong></p><p class="source-code"><strong class="bold">&gt;&gt;&gt; say_hello()</strong></p><p>Once the last command is typed, we will get the following printout in the terminal:</p><p class="source-code"><strong class="bold">the Flitton Fibonacci module is saying hello</strong></p></li>&#13;
			</ol>&#13;
			<p>There we have it – our Python package works! This works for both private and public GitHub repositories. Nothing is stopping us now from packaging private Python code to reuse on other private Python projects! </p>&#13;
			<p>While this is a useful tool to package and install code on other computers with minimal setup, we have to be careful. When we are running the <strong class="source-inline">setup.py</strong> file, we are running the code as our root user. Therefore, we have to ensure that we trust what we are installing. Putting malicious code into the <strong class="source-inline">setup.py</strong> file is a vector of attack. We can run direct commands on the computer using the <strong class="source-inline">SubProcess</strong> object from the standard Python library. Make sure you trust the author of the code that you are installing with <strong class="source-inline">pip install</strong>.</p>&#13;
			<p>This also highlights how vigilant you have to be when merely just running <strong class="source-inline">pip install</strong>. There are developers out there who will slightly change a package. For instance, a famous case was the <strong class="source-inline">requests</strong> package. This is a common, well-used package; however, for some time, there was an imitation package called <strong class="source-inline">request</strong>. They relied on people mistyping <strong class="source-inline">pip install</strong> and downloading the wrong package. This is known <a id="_idIndexMarker251"/>as <strong class="bold">typosquatting</strong>. </p>&#13;
			<p>We have now packaged our Python code into a module. However, it is not a very useful module. This brings us to our next section, where we package our Fibonacci sequencing code.</p>&#13;
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Packaging Python code in a pip module</h1>&#13;
			<p>Now that we have<a id="_idIndexMarker252"/> our GitHub repository configured, we can start building out our Fibonacci code for our module. To achieve this, we must carry out the following steps: </p>&#13;
			<ol>&#13;
				<li value="1">Build our Fibonacci calculation code. </li>&#13;
				<li>Create a command-line interface.</li>&#13;
				<li>Test our Fibonacci calculation code with unit tests. </li>&#13;
			</ol>&#13;
			<p>Let's now discuss each of these steps in detail.</p>&#13;
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Building our Fibonacci calculation code</h2>&#13;
			<p>When it comes to<a id="_idIndexMarker253"/> building our Fibonacci calculation code, we will have two functions – one that will calculate a Fibonacci number and another that will take a list of numbers and lean on the calculation function to <a id="_idIndexMarker254"/>return a list of calculated Fibonacci numbers. For this module, we will take a functional programming approach. This does not mean that we should have a functional programming approach every time we build a <strong class="source-inline">pip</strong> module. We are using functional programming because Fibonacci sequence calculations naturally flow well with a functional programming style.</p>&#13;
			<p>Python is an object-orientated language, and problems that have multiple moving parts interrelating naturally flow well with object-orientated approaches. Our module structure will take the following form:</p>&#13;
			<p class="source-code">├── LICENSE</p>&#13;
			<p class="source-code">├── README.md</p>&#13;
			<p class="source-code">├── flitton_fib_py</p>&#13;
			<p class="source-code">│   ├── __init__.py</p>&#13;
			<p class="source-code">│   └── fib_calcs</p>&#13;
			<p class="source-code">│       ├── __init__.py</p>&#13;
			<p class="source-code">│       ├── fib_number.py</p>&#13;
			<p class="source-code">│       └── fib_numbers.py</p>&#13;
			<p class="source-code">├── setup.py</p>&#13;
			<p>For this chapter, we will maintain a simple interface so that we can focus on the packaging of<a id="_idIndexMarker255"/> code in a <strong class="source-inline">pip</strong> module. Here <a id="_idIndexMarker256"/>are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we can build our Fibonacci number calculator in the <strong class="source-inline">fib_number.py</strong> file with the following code:<p class="source-code">from typing import Optional</p><p class="source-code">def recurring_fibonacci_number(number: int) -&gt; \</p><p class="source-code">Optional[int]:</p><p class="source-code">    if number &lt; 0:</p><p class="source-code">        return None</p><p class="source-code">    elif number &lt;= 1:</p><p class="source-code">        return number</p><p class="source-code">    else:</p><p class="source-code">    return recurring_fibonacci_number(number - 1) + \</p><p class="source-code">           recurring_fibonacci_number(number - 2)</p><p>Here, it has to be noted that we are returning <strong class="source-inline">None</strong> when the input number is below zero. Technically, we should be throwing an error, but this is in place, for now, to demonstrate the effectiveness of a checking tool later on in our <em class="italic">Configuring continuous integration</em> section. As we know from the previous chapter, the preceding code will correctly calculate a Fibonacci number based on the input number. </p></li>&#13;
				<li>Now that we have this function, we can depend on this to create a function that creates a list<a id="_idIndexMarker257"/> of Fibonacci<a id="_idIndexMarker258"/> numbers in our <strong class="source-inline">fib_numbers.py</strong> file with the following code:<p class="source-code">from typing import List</p><p class="source-code">from .fib_number import recurring_fibonacci_number</p><p class="source-code">def calculate_numbers(numbers: List[int]) -&gt; List[int]:</p><p class="source-code">    return [recurring_fibonacci_number(number=i) \</p><p class="source-code">      for i in numbers]</p><p>We are now ready to test our <strong class="source-inline">pip</strong> module again. We must push our code to the <strong class="source-inline">main</strong> branch on our repository again, uninstall our <strong class="source-inline">pip</strong> package in another virtual environment, and install again using <strong class="source-inline">pip install</strong>.</p></li>&#13;
				<li>In our Python terminal with our new installed package, we can test our <strong class="source-inline">recurring_fibonacci_number</strong> function with the following console commands:<p class="source-code"><strong class="bold">&gt;&gt;&gt; from flitton_fib_py.fib_calcs.fib_number </strong></p><p class="source-code"><strong class="bold">    import recurring_fibonacci_number</strong></p><p class="source-code"><strong class="bold">&gt;&gt;&gt; recurring_fibonacci_number(5)</strong></p><p class="source-code"><strong class="bold">5</strong></p><p class="source-code"><strong class="bold">&gt;&gt;&gt; recurring_fibonacci_number(8)</strong></p><p class="source-code"><strong class="bold">21</strong></p><p>Here, we can see that our Fibonacci function can be imported, and it works, calculating the correct Fibonacci numbers.</p></li>&#13;
				<li>We can test our <strong class="source-inline">calculate_numbers</strong> with the following commands:<p class="source-code"><strong class="bold">&gt;&gt;&gt; from flitton_fib_py.fib_calcs.fib_numbers </strong></p><p class="source-code"><strong class="bold">     </strong><strong class="bold">import calculate_numbers</strong></p><p class="source-code"><strong class="bold">&gt;&gt;&gt; calculate_numbers([1, 2, 3, 4, 5, 6, 7])</strong></p><p class="source-code"><strong class="bold">[1, 1, 2, 3, 5, 8, 13]</strong></p></li>&#13;
			</ol>&#13;
			<p>Here, we can see <a id="_idIndexMarker259"/>that our <strong class="source-inline">calculate_numbers</strong> function also works. We have a fully functioning Fibonacci <strong class="source-inline">pip</strong> module. However, if we want to just calculate a Fibonacci number without coding a Python <a id="_idIndexMarker260"/>script, we should not have to go into a Python terminal. We can remedy this by building a command-line interface in the next step. </p>&#13;
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Creating a command-line interface</h2>&#13;
			<p>In order to build our<a id="_idIndexMarker261"/> command line function, our module can take the following structure:</p>&#13;
			<p class="source-code">├── LICENSE</p>&#13;
			<p class="source-code">├── README.md</p>&#13;
			<p class="source-code">├── flitton_fib_py</p>&#13;
			<p class="source-code">│   ├── __init__.py</p>&#13;
			<p class="source-code">│   ├── cmd</p>&#13;
			<p class="source-code">│   │   ├── __init__.py</p>&#13;
			<p class="source-code">│   │   └── fib_numb.py</p>&#13;
			<p class="source-code">│   └── fib_calcs</p>&#13;
			<p class="source-code">     . . .</p>&#13;
			<p>To build our interface, we follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">We build the command-line interface in our <strong class="source-inline">fib_numb.py</strong> file with the following code:<p class="source-code">import argparse</p><p class="source-code">from flitton_fib_py.fib_calcs.fib_number \</p><p class="source-code">    import recurring_fibonacci_number</p><p class="source-code">def fib_numb() -&gt; None:</p><p class="source-code">    parser = argparse.ArgumentParser(</p><p class="source-code">        description='Calculate Fibonacci numbers')</p><p class="source-code">    parser.add_argument('--number', action='store', </p><p class="source-code">                        type=int, required=True,</p><p class="source-code">                        help="Fibonacci number to be \</p><p class="source-code">                          calculated")</p><p class="source-code">    args = parser.parse_args()</p><p class="source-code">    print(f"Your Fibonacci number is: " \</p><p class="source-code">      f"{recurring_fibonacci_number \</p><p class="source-code">        (number=args.number)}")</p><p>Here, we can <a id="_idIndexMarker262"/>see that we get the parameters passed in from the command line using the <strong class="source-inline">argparse</strong> module. Once we have obtained the parameters, we will then calculate the number and print it out. Now, for us to actually access it via the terminal, we have to point to it in the <strong class="source-inline">setup.py</strong> file at the root of the <strong class="source-inline">pip</strong> package by adding the following parameter in the <strong class="source-inline">setup</strong> object initialization:</p><p class="source-code">entry_points={</p><p class="source-code">    'console_scripts': [</p><p class="source-code">        'fib-number = \</p><p class="source-code">           flitton_fib_py.cmd.fib_numb:fib_numb',</p><p class="source-code">    ],</p><p class="source-code">},</p><p>Here, what we are doing is linking the <strong class="source-inline">fib-number</strong> console command with the function that we have just defined. After uninstalling our <strong class="source-inline">pip</strong> module in another virtual environment, uploading the changes to the <strong class="source-inline">main</strong> branch on our repository, and installing our new module using <strong class="source-inline">pip install</strong>, we will have our new module with the command-line tool that we have built. </p></li>&#13;
				<li>Once it is<a id="_idIndexMarker263"/> installed, we just type in the following command:<p class="source-code"><strong class="bold">fib-number</strong></p><p>We get the following output:</p><p class="source-code"><strong class="bold">usage: fib-number [-h] --number NUMBER</strong></p><p class="source-code"><strong class="bold">fib-number: error: the following arguments are </strong></p><p class="source-code"><strong class="bold">required: --number</strong></p><p>Here, we can see that the <strong class="source-inline">argparse</strong> module that we are using ensures that we provide the arguments needed. If we need help, we can get this by typing in the following command:</p><p class="source-code"><strong class="bold">fib-number -h</strong></p><p>This gives us the help printout, as shown here:</p><p class="source-code"><strong class="bold">usage: fib-number [-h] --number NUMBER</strong></p><p class="source-code"><strong class="bold">Calculate Fibonacci numbers</strong></p><p class="source-code"><strong class="bold">optional arguments:</strong></p><p class="source-code"><strong class="bold">  -h, --help       show this help message and exit</strong></p><p class="source-code"><strong class="bold">  --number NUMBER  Fibonacci number to be calculated</strong></p><p>We can see that we have the type and the help description of what it does.</p></li>&#13;
				<li>So, to calculate the Fibonacci number, we use the following command:<p class="source-code"><strong class="bold">fib-number --number 20</strong></p><p>This gives us the following printout:</p><p class="source-code"><strong class="bold">Your Fibonacci number is: 6765</strong></p><p>If we were to provide a string instead of a number for our argument, our program would refuse it, throwing an error. </p></li>&#13;
			</ol>&#13;
			<p>Here we have it, we <a id="_idIndexMarker264"/>have a fully working command-line tool! This does not stop here. You can take this further. Nothing is stopping you from using <strong class="source-inline">subprocess</strong> from the standard library combined with other libraries, such as Docker, to build your own DevOps tools. You can automate whole workflows for yourself and the applications you make. However, if we are to rely more and more on our <strong class="source-inline">pip</strong> modules to do the repetitive heavy lifting, we can get into serious problems if the program introduces some bugs we need to know straight away. To do this, we need to start building unit tests for our module. These are covered in the next subsection. </p>&#13;
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Building unit tests</h2>&#13;
			<p>Unit tests <a id="_idIndexMarker265"/>are <a id="_idIndexMarker266"/>helpful for us to check and maintain quality control for our code. To build our unit tests, our module will have <a id="_idIndexMarker267"/>the following structure:</p>&#13;
			<p class="source-code">├── LICENSE</p>&#13;
			<p class="source-code">├── README.md</p>&#13;
			<p class="source-code">├── flitton_fib_py</p>&#13;
			<p class="source-code">     . . .</p>&#13;
			<p class="source-code">├── scripts</p>&#13;
			<p class="source-code">│   └── run_tests.sh</p>&#13;
			<p class="source-code">├── setup.py</p>&#13;
			<p class="source-code">├── tests</p>&#13;
			<p class="source-code">│   ├── __init__.py</p>&#13;
			<p class="source-code">│   └── flitton_fib_py</p>&#13;
			<p class="source-code">│       ├── __init__.py</p>&#13;
			<p class="source-code">│       └── fib_calcs</p>&#13;
			<p class="source-code">│           ├── __init__.py</p>&#13;
			<p class="source-code">│           ├── test_fib_number.py</p>&#13;
			<p class="source-code">│           └── test_fib_numbers.py</p>&#13;
			<p>We can see that we<a id="_idIndexMarker268"/> are mimicking the structure of the code in our module. This is important to keep track of our tests. If the module grows, then we will not get lost in our tests. If we need to chop out a directory or move it to<a id="_idIndexMarker269"/> another module, we can simply delete the appropriate directory or move it. It also has to be noted that we have built a Bash script to run our tests. </p>&#13;
			<p>When it comes to writing our tests, it is usually best to code based on the chain of dependency. For instance, our files have the dependency chain depicted as follows:</p>&#13;
			<div>&#13;
				<div id="_idContainer048" class="IMG---Figure">&#13;
					<img src="Images/Figure_4.04_B17720.jpg" alt="Figure 4.4 – Dependency chain&#13;&#10;" width="722" height="389"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.4 – Dependency chain</p>&#13;
			<p>Considering our dependency chain, we should ideally write our tests for the <strong class="source-inline">fib_number.py</strong> file first and make sure that our <strong class="source-inline">recurring_fibonacci_number</strong> function works before writing tests that rely on the <strong class="source-inline">recurring_fibonacci_number</strong> function. Here are the steps to write our tests:</p>&#13;
			<ol>&#13;
				<li value="1">We first import what we need to test our code in our <strong class="source-inline">test_fib_number.py</strong> file via the following code:<p class="source-code">from unittest import main, TestCase</p><p class="source-code">from flitton_fib_py.fib_calcs.fib_number \</p><p class="source-code">    import recurring_fibonacci_number</p><p>The <strong class="source-inline">main</strong> function <a id="_idIndexMarker270"/>is to run all <a id="_idIndexMarker271"/>tests. We also rely on the <strong class="source-inline">TestCase</strong> class by writing our own test class that inherits <strong class="source-inline">TestCase</strong>. This gives our class extra class functions to aid us in testing outcomes. </p></li>&#13;
				<li>We can write our own tests for a range of inputs with the following code:<p class="source-code">class RecurringFibNumberTest(TestCase):</p><p class="source-code">    def test_zero(self):</p><p class="source-code">        self.assertEqual(0, </p><p class="source-code">            recurring_fibonacci_number(number=0)</p><p class="source-code">        )</p><p class="source-code">    def test_negative(self):</p><p class="source-code">        self.assertEqual(</p><p class="source-code">            None, recurring_fibonacci_number \</p><p class="source-code">              (number=-1)</p><p class="source-code">        )</p><p class="source-code">    def test_one(self):</p><p class="source-code">        self.assertEqual(1, \</p><p class="source-code">          recurring_fibonacci_number(number=1))</p><p class="source-code">    def test_two(self):</p><p class="source-code">        self.assertEqual(1, \ </p><p class="source-code">          recurring_fibonacci_number(number=2))</p><p class="source-code">    def test_twenty(self):</p><p class="source-code">        self.assertEqual( \</p><p class="source-code">        6765, recurring_fibonacci_number(number=20)</p><p class="source-code">        )</p><p>Here, it has to be<a id="_idIndexMarker272"/> noted that each one of our functions has the <strong class="source-inline">test_</strong> prefix. This flags the function as a test function. This is also the case for the name of the file. All test files have the <strong class="source-inline">test_</strong> prefix to flag that the file houses tests. In our testing code, we can see that we<a id="_idIndexMarker273"/> have merely passed a range of inputs into the function that we are testing and asserted that the outcome is what we expect. If the assertions do not hold water, then we get an error and a failed result. Seeing as we are just testing the same function repeatedly, we can put all of the assertions into one test function. This is usually preferred if we are testing the whole object. We would essentially have one test function for each function that we are testing in the object. </p></li>&#13;
				<li>Now that all our tests have been run, we can run the <strong class="source-inline">unittest</strong> <strong class="source-inline">main</strong> function if the <strong class="source-inline">test_fib_number.py</strong> file is run directly at the bottom of the <strong class="source-inline">test_fib_number.py</strong> file with the code shown next:<p class="source-code">if __name__ == "__main__":</p><p class="source-code">    main()</p></li>&#13;
				<li>We now have to set our <strong class="source-inline">PYTHONPATH</strong> variable to the directory of <strong class="source-inline">flitton_fib_py</strong>. <p>Once this is done, we can run our <strong class="source-inline">test_fib_number.py</strong> file and get the console printout as shown:</p><p class="source-code"><strong class="bold">.....</strong></p><p class="source-code"><strong class="bold">--------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 5 tests in 0.002s</strong></p><p class="source-code"><strong class="bold">OK</strong></p><p>We can see that <a id="_idIndexMarker274"/>each test function is a test. The <a id="_idIndexMarker275"/>dots at the top are each test. If we were to change the <strong class="source-inline">None</strong> to a <strong class="source-inline">1</strong> in the second test, we would get the following printout:</p><p class="source-code"><strong class="bold">F....</strong></p><p class="source-code"><strong class="bold">====================================================</strong></p><p class="source-code"><strong class="bold">FAIL: test_negative (tests.flitton_fib_py.fib_calcs.</strong></p><p class="source-code"><strong class="bold">test_fib_number.RecurringFibNumberTest)</strong></p><p class="source-code"><strong class="bold">----------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Traceback (most recent call last):</strong></p><p class="source-code"><strong class="bold">  File "/Users/maxwellflitton/Documents/github/</strong></p><p class="source-code"><strong class="bold">  flitton-fib-py/tests/flitton_fib_py/fib_calcs/</strong></p><p class="source-code"><strong class="bold">  test_fib_number.py", line 15, in test_negative</strong></p><p class="source-code"><strong class="bold">    self.assertEqual(</strong></p><p class="source-code"><strong class="bold">AssertionError: 1 != None</strong></p><p class="source-code"><strong class="bold">---------------------------------------------------</strong></p><p class="source-code"><strong class="bold">Ran 5 tests in 0.003s</strong></p><p>We can see that we now have an <strong class="source-inline">F</strong> in the test dots, and it highlights what test is failing and where it is failing.</p></li>&#13;
				<li>Now that we have built our base test, we can build our tests for the function that takes in a list of integers and returns a list of Fibonacci numbers. In our <strong class="source-inline">test_fib_numbers.py</strong> file, we import what we need with the following code:<p class="source-code">from unittest import main, TestCase</p><p class="source-code">from unittest.mock import patch</p><p class="source-code">from flitton_fib_py.fib_calcs.fib_numbers \</p><p class="source-code">    import calculate_numbers</p><p>Here, we can see that we are importing the function that we are testing and the same <strong class="source-inline">main</strong> and <strong class="source-inline">TestCase</strong>. However, it has to be noted that we have imported a <strong class="source-inline">patch</strong> function. This is because we have already tested our <strong class="source-inline">recurring_fibonacci_number</strong> function. The <strong class="source-inline">patch</strong> function enables us to insert a <strong class="source-inline">MagicMock</strong> object in place of our <strong class="source-inline">recurring_fibonacci_number</strong> function.</p></li>&#13;
			</ol>&#13;
			<p>For our example, it can be<a id="_idIndexMarker276"/> argued that we do not <a id="_idIndexMarker277"/>need to patch anything. However, it is important to get an understanding of patching. <strong class="bold">Patching</strong> enables us to bypass expensive processes. For instance, if we are relying on a <a id="_idIndexMarker278"/>function that must make an API call, we should not have to make those API calls when testing. Instead, we can just patch the function. This also isolates the test. If a particular test is failing, we know that is something to do with the code that we are testing directly and not external code that it is depending on. It also speeds up the testing as we are not fully running code that we are depending on multiple times in different tests. We also get granularity because we use a <strong class="source-inline">MagicMock</strong> object; we can define the return values to anything we want during the test and log all calls to the <strong class="source-inline">MagicMock</strong> object.</p>&#13;
			<p>The advantage here is that we might accidentally call the function we are depending on twice for some reason. However, if the function returns the same value twice, we will not know anything if we did not patch it. However, with patching, we can inspect the calls and throw errors if the behavior is not what we expect. We can also test a range of edge cases very quickly by merely changing the return value of the patches and rerunning the test.</p>&#13;
			<p>With all this, it is understandable that we can get excited about patching. However, there are some downsides. If we do not update the patches' return values, the dependent code does not get the changes, and the testing does not remain accurate. This is why it is always sensible to have a mixture of approaches and run a functional test that runs the whole<a id="_idIndexMarker279"/> process without patching anything. With all<a id="_idIndexMarker280"/> this in mind, our patched unit test in the <strong class="source-inline">tests/flitton_fib_by/fib_calcs/test_fib_numbers.py</strong> file is carried out by the following code:</p>&#13;
			<p class="source-code">class Test(TestCase):</p>&#13;
			<p class="source-code">    @patch("flitton_fib_py.fib_calcs.fib_numbers." </p>&#13;
			<p class="source-code">           "recurring_fibonacci_number")</p>&#13;
			<p class="source-code">    def test_calculate_numbers(self, mock_fib_calc):</p>&#13;
			<p class="source-code">        expected_outcome = [mock_fib_calc.return_value, </p>&#13;
			<p class="source-code">                          mock_fib_calc.return_value]</p>&#13;
			<p class="source-code">        self.assertEqual(expected_outcome, </p>&#13;
			<p class="source-code">                         calculate_numbers(numbers=[3, 4]))</p>&#13;
			<p class="source-code">        self.assertEqual(2, </p>&#13;
			<p class="source-code">          len(mock_fib_calc.call_args_list))</p>&#13;
			<p class="source-code">        self.assertEqual({'number': 3}, </p>&#13;
			<p class="source-code">          mock_fib_calc.call_args_list[0][1])</p>&#13;
			<p class="source-code">        self.assertEqual({'number': 4}, </p>&#13;
			<p class="source-code">          mock_fib_calc.call_args_list[1][1])</p>&#13;
			<p>Here, we can see that we have used the patch as a decorator with a string that defines the path to the function that we are patching. We then pass the patched function through the test function under the <strong class="source-inline">mock_fib_calc</strong> parameter. We then state that we expect the outcome of the function that we are directly testing (<strong class="source-inline">calculate_numbers</strong>) to be a list of two return values of the patched function. We then pass two integers wrapped in a list into the <strong class="source-inline">calculate_numbers</strong> function and assert that this is going to be the same as our expected outcome. Once this is done, we assert that the <strong class="source-inline">mock_fib_calc</strong> was only called twice, and we inspect each of those calls, asserting that they are the numbers that we passed in, in the correct order. This has given us a lot of <a id="_idIndexMarker281"/>power to truly inspect our code. However, we are not done yet; we also must define the functional test to enable us to<a id="_idIndexMarker282"/> run our tests with the code here:</p>&#13;
			<p class="source-code">    def test_functional(self):</p>&#13;
			<p class="source-code">        self.assertEqual([2, 3, 5], </p>&#13;
			<p class="source-code">            calculate_numbers(numbers=[3, 4, 5]))</p>&#13;
			<p class="source-code">if __name__ == "__main__":</p>&#13;
			<p class="source-code">    main()</p>&#13;
			<p>For our module, all our unit tests are done. However, we do not want to go through manually running each file to see our tests. There will be times where we want to just see all the outcomes of the tests to see if there are any fails. To automate this, we can build a Bash script in the <strong class="source-inline">run_tests.sh</strong> file with the code here:</p>&#13;
			<p class="source-code">#!/usr/bin/env bash</p>&#13;
			<p class="source-code">SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"</p>&#13;
			<p class="source-code">cd $SCRIPTPATH</p>&#13;
			<p class="source-code">cd ..</p>&#13;
			<p class="source-code">source venv/bin/activate</p>&#13;
			<p class="source-code">export PYTHONPATH="./flitton_fib_py"</p>&#13;
			<p class="source-code">python -m unittest discover</p>&#13;
			<p>Here, we claim that the file is a Bash script with the first line. The first line is a shebang line and tells the computer running it what type of language it is. We then get the directory path of where this script is and assign it to the <strong class="source-inline">SCRIPTPATH</strong> variable. We then navigate to this directory, move out to the root of our module, activate our virtual environment, and then define our <strong class="source-inline">PYTHONPATH</strong> variable to be in our module with the Fibonacci number code. Now that everything is defined, to run our test we use the <strong class="source-inline">unittest</strong> command-line tool to run all the unit tests. Remember, all our tests have the <strong class="source-inline">test_</strong> prefix in their <a id="_idIndexMarker283"/>filenames. Running this<a id="_idIndexMarker284"/> gives us the following printout:</p>&#13;
			<p class="source-code">.......</p>&#13;
			<p class="source-code">------------------------------------------</p>&#13;
			<p class="source-code">Ran 7 tests in 0.003s</p>&#13;
			<p class="source-code">OK</p>&#13;
			<p>Here, we can see that we have seven tests running and they have all passed. We can see that we have started automating the test-running process. This is not where we should stop. As we move forward onto packaging and distributing our <strong class="source-inline">pip</strong> module, we should investigate automating the processes through continuous integration, which is what we explore in the next section. Right now, as it stands, if a user has access to our GitHub repository, we can install the code via <strong class="source-inline">pip</strong> and use it.</p>&#13;
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Configuring continuous integration</h1>&#13;
			<p>Our Python <strong class="source-inline">pip</strong> package<a id="_idIndexMarker285"/> is fully functioning. However, this is not the end. We will need to maintain the quality of the code and enable it to be constantly upgraded when we push new features to our module and refactor existing code. Continuous integration enables us to ensure that the tests pass and that the standard of quality is maintained. It also speeds up the deployment process, enabling us to push new iterations within a matter of minutes, enabling us to focus on the task at hand. It also reduces the risk of making a mistake. </p>&#13;
			<p>As we know, the most mundane, repetitive tasks are the ones that are at the highest risk of a mistake occurring. This is just a fact of life. It's known that most car crashes happen within 5 minutes of the driver's home. This is because the drivers pay less attention and their brain switches off, relying on muscle memory. Deployment processes are the same. They are repetitive and do not require a lot of mental focus. As a result, after several times, we will start to rely on muscle memory and forget to check certain things, and make minor blunders when deploying our <strong class="source-inline">pip</strong> package. Continuous integration is a must to avoid mistakes and saves time in not only deployment but also in not having to correct the errors. To set up continuous integration, we are going to have to carry out the <a id="_idIndexMarker286"/>following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Manually deploy onto PyPI. </li>&#13;
				<li>Manage our dependencies.</li>&#13;
				<li>Set up type checking for Python.</li>&#13;
				<li>Set up and run tests and type checking with GitHub Actions.</li>&#13;
				<li>Create automatic versioning for our <strong class="source-inline">pip</strong> package.</li>&#13;
				<li>Deploy onto PyPI using GitHub Actions.</li>&#13;
			</ol>&#13;
			<p>Let's have a look at each of these steps in detail in the following subsections.</p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Manually deploying onto PyPI</h2>&#13;
			<p>We now <a id="_idIndexMarker287"/>move on to our first step of manually deploying our GitHub repository onto PyPI. We have installed our <strong class="source-inline">pip</strong> package by directly pointing to the GitHub repository. However, if we are allowing everyone to access our module as it's open source, it is easier to upload our package onto PyPI. This will enable others to install using a simple command. Here are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to package our <strong class="source-inline">pip</strong> module before we upload it. This can be done with the following command:<p class="source-code"><strong class="bold">python setup.py sdist</strong></p><p>What this does is package our <strong class="source-inline">pip</strong> module in a <strong class="source-inline">tar.gz</strong> file, which gives us the following file outline:</p><p class="source-code">├── LICENSE</p><p class="source-code">├── README.md</p><p class="source-code">├── dist</p><p class="source-code">│   └── flitton_fib_py-0.0.1.tar.gz</p><p class="source-code">├── flitton_fib_py</p><p class="source-code">    . . .</p></li>&#13;
				<li>We can<a id="_idIndexMarker288"/> now see that the version is included in the filename. We are now ready to upload onto the PyPI server. To do this, we have to install <strong class="source-inline">twine</strong> with the following command:<p class="source-code"><strong class="bold">pip install twine</strong></p></li>&#13;
				<li>We are now able to upload the <strong class="source-inline">tar.gz</strong> file with the following command:<p class="source-code"><strong class="bold">twine upload dist/*</strong></p><p>This uploads all of the packages that we have created. During this process, the terminal will ask us for the PyPI username and password. It then uploads the package and tells us where we can find out the module on PyPI. If we visit this, we should get the view depicted in the following figure:</p></li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer049" class="IMG---Figure">&#13;
					<img src="Images/Figure_4.05_B17720.jpg" alt="Figure 4.5 – PyPI view of our module&#13;&#10;" width="1220" height="777"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.5 – PyPI view of our module</p>&#13;
			<p>We can see that <a id="_idIndexMarker289"/>our <strong class="source-inline">README.md</strong> file is being directly rendered in the view in <em class="italic">Figure 4.5</em>. We can now directly install this with the <strong class="source-inline">pip install</strong> command depicted in the PyPI view. It must be noted that we now have a dependency. We need to manage these dependencies. We will cover this in the next step.</p>&#13;
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Managing dependencies</h2>&#13;
			<p>When it comes to <a id="_idIndexMarker290"/>dependencies, we must manage two types. For instance, our <strong class="source-inline">twine</strong> dependency helps us upload it onto PyPI. However, this is not needed for the <strong class="source-inline">pip</strong> package. Therefore, we need two different lists of dependencies – one for development and the other for actual use. We define the dependencies that we need for the development with the simple standard command stated here:</p>&#13;
			<p class="source-code">pip freeze &gt; requirements.txt</p>&#13;
			<p>What the <strong class="source-inline">pip freeze</strong> command gives us is a specific list of requirements that our current Python environment needs to install in order to run. <strong class="source-inline">&gt; requirements.txt</strong> writes it to the <strong class="source-inline">requirements.txt</strong> file. If you are a new developer starting to develop our module, you can install all the requirements needed with the following command:</p>&#13;
			<p class="source-code">pip install -r requirements.txt</p>&#13;
			<p>We can be strict here because nothing is depending on the development requirements apart from the direct development of our module. However, when it comes to our module, we know that<a id="_idIndexMarker291"/> it will be installed into multiple systems with multiple requirements. Therefore, we want to allow some flexibility. For instance, if our module was going to write our Fibonacci numbers to <strong class="source-inline">yml</strong> and <strong class="source-inline">pickle</strong> files, then we will need to use the <strong class="source-inline">pyYAML</strong> and <strong class="source-inline">dill</strong> modules to enable us to write our Fibonacci numbers to <strong class="source-inline">yml</strong> and <strong class="source-inline">pickle</strong> files. To do this, we alter our <strong class="source-inline">install_requires</strong> parameter in our <strong class="source-inline">setup</strong> initialization in the <strong class="source-inline">setup.py</strong> file with the code here:</p>&#13;
			<p class="source-code">install_requires=[ </p>&#13;
			<p class="source-code">    "PyYAML&gt;=4.1.2",</p>&#13;
			<p class="source-code">    "dill&gt;=0.2.8"</p>&#13;
			<p class="source-code">],</p>&#13;
			<p>It must be noted that these are not the latest packages. We must drop a few versions and allow our dependency to be equal to or above that version. This gives our users freedom when using our pip package in their systems. We also must copy and paste these requirements into our <strong class="source-inline">requirements.txt</strong> file to ensure that our development is consistent with the user experience of our <strong class="source-inline">pip</strong> module. Let's say that we are going to add an optional feature which is to start a small Flask server that locally serves an API that calculates Fibonacci numbers. Here, we can add an <strong class="source-inline">install_requires</strong> parameter in our <strong class="source-inline">setup</strong> initialization in the <strong class="source-inline">setup.py</strong> file with the following code:</p>&#13;
			<p class="source-code">extras_require={</p>&#13;
			<p class="source-code">  'server': ["Flask&gt;=1.0.0"]</p>&#13;
			<p class="source-code">},</p>&#13;
			<p>Now, if we upload our new code to either PyPI or our personal GitHub repository, we will have a different experience when installing our package. If we normally install it, we will see that our <strong class="source-inline">pickle</strong> and <strong class="source-inline">yml</strong> requirements automatically install if we run the install command, as shown here:</p>&#13;
			<p class="source-code">pip install flitton-fib-py[server]</p>&#13;
			<p>It will actually install the<a id="_idIndexMarker292"/> server requirements. We can have as many requirements for the <strong class="source-inline">server</strong> profile as we want, and they will all be installed. Remember, our <strong class="source-inline">extras_require</strong> parameter is a dictionary, so we can define as many extra requirement profiles as we want. With this, we now have development requirements, essential <strong class="source-inline">pip</strong> module requirements, and optional <strong class="source-inline">pip</strong> module requirements. In the next step, we are now going to rely on a new development requirement to check types.</p>&#13;
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Setting up type checking for Python</h2>&#13;
			<p>At this point in the book, we have<a id="_idIndexMarker293"/> experienced the safety that Rust introduces. When types don't match up, the Rust compiler refuses to compile. However, with Python, we do not get this, as Python is an interpreted language. However, we can mimic this using the <strong class="source-inline">mypy</strong> module. The steps are as follows:</p>&#13;
			<ol>&#13;
				<li value="1">First, we can install the <strong class="source-inline">mypy</strong> module with the following command:<p class="source-code"><strong class="bold">pip install mypy</strong></p></li>&#13;
				<li>We can then type-check by using the <strong class="source-inline">mypy</strong> entry point with the code here:<p class="source-code"><strong class="bold">mypy flitton_fib_py</strong></p><p>Here, we are pointing to the main code for our Python module. We should get the console printout as follows:</p><p class="source-code"><strong class="bold">flitton_fib_py/fib_calcs/fib_number.py:16: </strong></p><p class="source-code"><strong class="bold">error: Unsupported operand types for + ("int" and </strong></p><p class="source-code"><strong class="bold">"None")</strong></p><p class="source-code"><strong class="bold">flitton_fib_py/fib_calcs/fib_number.py:16: </strong></p><p class="source-code"><strong class="bold">error: Unsupported operand types for + ("None" and </strong></p><p class="source-code"><strong class="bold">"int")</strong></p><p class="source-code"><strong class="bold">flitton_fib_py/fib_calcs/fib_number.py:16: </strong></p><p class="source-code"><strong class="bold">error: Unsupported left operand type for + ("None")</strong></p><p class="source-code"><strong class="bold">flitton_fib_py/fib_calcs/fib_number.py:16: </strong></p><p class="source-code"><strong class="bold">note: Both left and right operands are unions</strong></p><p class="source-code"><strong class="bold">flitton_fib_py/fib_calcs/fib_numbers.py:13: </strong></p><p class="source-code"><strong class="bold">error: List comprehension has incompatible </strong></p><p class="source-code"><strong class="bold">type List[Optional[int]]; expected List[int]</strong></p><p>What <strong class="source-inline">mypy</strong> is <a id="_idIndexMarker294"/>doing is checking the consistency across all of our Python code! Like a Rust compiler, it has found an inconsistency. However, because this is Python, we can still run our Python code. While Python is memory-safe, the strong type-checking that Rust enforces is going to reduce the risk of incorrect variables being passed into the function in runtime. Now, we know that there is an inconsistency. The inconsistency is that our <strong class="source-inline">recurring_fibonacci_number</strong> function returns either <strong class="source-inline">None</strong> or <strong class="source-inline">int</strong>. However, our <strong class="source-inline">calculate_numbers</strong> function relies on the <strong class="source-inline">recurring_fibonacci_number</strong> function for the return value, but it returns a list of integers as opposed to returning a list of integers or <strong class="source-inline">None</strong> values.</p></li>&#13;
				<li>We can constrict the return value to just an integer with the <strong class="source-inline">recurring_fibonacci_number</strong> function:<p class="source-code">def recurring_fibonacci_number(number: int) -&gt; int:</p><p class="source-code">    if number &lt; 0:</p><p class="source-code">        raise ValueError(</p><p class="source-code">        "Fibonacci has to be equal or above zero"</p><p class="source-code">        )</p><p class="source-code">    elif number &lt;= 1:</p><p class="source-code">        return number</p><p class="source-code">    else:</p><p class="source-code">     return recurring_fibonacci_number(number - 1) + \</p><p class="source-code">            recurring_fibonacci_number(number - 2)</p><p>Here, we can<a id="_idIndexMarker295"/> see that we raise an error if the input number is below zero. It's not going to calculate anyway, so we might as well throw an error informing the user that there is an error as opposed to silently producing a <strong class="source-inline">None</strong> value. </p><p>If we run our <strong class="source-inline">mypy</strong> check, we get the following console printout: </p><p class="source-code"><strong class="bold">Success: no issues found in 6 source files</strong></p></li>&#13;
			</ol>&#13;
			<p>Here, we can see that all our files were checked and that they have type consistency. </p>&#13;
			<p>However, we might forget to run this type of checking every time we upload new code to the GitHub repository. In the next section, we will define GitHub Actions to automate our checking.</p>&#13;
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Setting up and running tests and type-checking with GitHub Actions</h2>&#13;
			<p>GitHub Actions run a series of computations that we can define in a <strong class="source-inline">yml</strong> file. We generally use GitHub Actions to automate processes that need to run every time. Workflow <strong class="source-inline">yml</strong> files are automatically detected by GitHub and run depending on what type of tags we give it. We can <a id="_idIndexMarker296"/>set up our GitHub Actions<a id="_idIndexMarker297"/> by following these steps:</p>&#13;
			<ol>&#13;
				<li value="1"> For our tests and type-checking tags, we will define these in the <strong class="source-inline">.github/workflows/run-tests.yml</strong> file. In this file, we initially give a name for the workflow, and state that it fires when there is a push from one branch to another. This happens when a pull request is done as one branch is being pushed to another. This also reruns if we push more changes to our branch before merging the pull request. Our definitions are inserted at the top of the file with the following code:<p class="source-code"><strong class="bold">name: Run tests</strong></p><p class="source-code"><strong class="bold">on: push</strong></p><p>Here, we can see that the workflow is called <strong class="source-inline">Run tests</strong>. </p></li>&#13;
				<li>Next, we must<a id="_idIndexMarker298"/> define our jobs. We also must state that our job is a <strong class="source-inline">shell </strong>command. We then define what the<a id="_idIndexMarker299"/> operating system is. Once we have done this, we define the steps of the job. In our <strong class="source-inline">steps</strong> section, we then define the <strong class="source-inline">uses</strong>, which we will state are <strong class="source-inline">actions</strong> with the following code:<p class="source-code"><strong class="bold">jobs:</strong></p><p class="source-code"><strong class="bold">  run-shell-command:</strong></p><p class="source-code"><strong class="bold">    runs-on: ubuntu-latest</strong></p><p class="source-code"><strong class="bold">    steps:</strong></p><p class="source-code"><strong class="bold">      - uses: actions/checkout@v2</strong></p><p>If we did not define the <strong class="source-inline">uses</strong> step, then we would not be able to access files such as the requirements. </p></li>&#13;
				<li>We are now ready to define the rest of the steps under the <strong class="source-inline">steps</strong> tag. These steps usually have a <strong class="source-inline">name</strong> and <strong class="source-inline">run</strong> tag. For us, we will be defining three steps:<ol><li>The first one is to install the dependencies.</li><li>The second one is to run all the unit tests. </li><li>The third one is to run the type-checking with the code here:</li></ol><p class="source-code"><strong class="bold">      - name: Install dependencies</strong></p><p class="source-code"><strong class="bold">        run: |</strong></p><p class="source-code"><strong class="bold">          python -m pip install –upgrade pip</strong></p><p class="source-code"><strong class="bold">          pip install -r requirements.txt</strong></p><p class="source-code"><strong class="bold">      </strong><strong class="bold">- name: run tests</strong></p><p class="source-code"><strong class="bold">        run: python -m unittest discover ./tests</strong></p><p class="source-code"><strong class="bold">      - name: run type checking</strong></p><p class="source-code"><strong class="bold">        run: mypy flitton_fib_py</strong></p><p>It must be noted that <strong class="source-inline">run</strong> is just a one-line terminal command. At one point, there is a <strong class="source-inline">|</strong> (pipe) value next to a <strong class="source-inline">run</strong> tag of the <strong class="source-inline">Install dependencies</strong> step. This pipe value simply allows us to write multiple lines of commands in one step. We must ensure that our <strong class="source-inline">requirements.txt</strong> file is updated with the <strong class="source-inline">mypy</strong> module. Once this is done, we can push this code to our GitHub repository and this GitHub action will run when we do pull requests. If you are familiar with GitHub<a id="_idIndexMarker300"/> and making pull requests, then you can move on to the next step. However, if you are not, then we can perform one now.</p></li>&#13;
				<li>First, we have to pull a new<a id="_idIndexMarker301"/> branch from our <strong class="source-inline">main</strong> branch with the following command:<p class="source-code"><strong class="bold">git checkout -b test</strong></p><p>With this, we then have a branch called <strong class="source-inline">test</strong>. We can then make a change in our code. </p></li>&#13;
				<li>To just trigger a GitHub action with a pull request, we can simply scar our code with a comment in any file, such as the one here:<p class="source-code"># trigger build (14-6-2021)</p><p>You can write whatever, as it is just a comment if the code has changed. We then add and commit our changes to our <strong class="bold">test</strong> branch and push it to the GitHub repository. Once this is done, we can trigger a pull request by clicking on the <strong class="bold">Pull requests</strong> tab and selecting our <strong class="bold">test</strong> branch, as shown here:</p><div id="_idContainer050" class="IMG---Figure"><img src="Images/Figure_4.06_B17720.jpg" alt="Figure 4.6 – Setting up a GitHub pull request&#13;&#10;" width="1461" height="659"/></div><p class="figure-caption">Figure 4.6 – Setting up a GitHub pull request</p></li>&#13;
				<li>Once this is done, we<a id="_idIndexMarker302"/> can click <a id="_idIndexMarker303"/>on <strong class="bold">Create pull request</strong> to view it. Here, we will see all the GitHub Actions that get triggered and their status, as shown in the following figure:<div id="_idContainer051" class="IMG---Figure"><img src="Images/Figure_4.07_B17720.jpg" alt="Figure 4.7 – View of the GitHub Actions status of pull requests&#13;&#10;" width="1457" height="810"/></div><p class="figure-caption">Figure 4.7 – View of the GitHub Actions status of pull requests</p><p>We can see that our<a id="_idIndexMarker304"/> tests have failed! If we click on <strong class="bold">Details</strong>, we can see that everything is working; <a id="_idIndexMarker305"/>it is just that we forgot to update our tests. If we remember, we changed our code to throw an error if we pass in a negative value into the Fibonacci calculation function, as shown next:</p><div id="_idContainer052" class="IMG---Figure"><img src="Images/Figure_4.08_B17720.jpg" alt="Figure 4.8 – View of the GitHub Actions execution details&#13;&#10;" width="1356" height="684"/></div><p class="figure-caption">Figure 4.8 – View of the GitHub Actions execution details</p></li>&#13;
				<li>We can change the<a id="_idIndexMarker306"/> test code to <a id="_idIndexMarker307"/>assert that an error is raised by the testing code in the <strong class="source-inline">tests/flitton_fib_py/fib_calcs/test_fib_number.py</strong> file with the following code:<p class="source-code">def test_negative(self):</p><p class="source-code">    with self.assertRaises(ValueError) as \</p><p class="source-code">raised_error:</p><p class="source-code">        recurring_fibonacci_number(number=-1)</p><p class="source-code">    self.assertEqual(</p><p class="source-code">        "Fibonacci has to be equal or above zero",</p><p class="source-code">        str(raised_error.exception)</p><p class="source-code">    ) </p><p>Here, we can see that we assert that a value error is raised because we are running code that we expect to raise an error, and that the exception is what we expect of it. Pushing this to our<a id="_idIndexMarker308"/> GitHub repository will ensure that all the tests have passed. We can merge the pull request if we want the code to be merged into our <strong class="source-inline">main</strong> branch. </p><p>We have<a id="_idIndexMarker309"/> seen from this example that continuous integration is useful. It has picked up a change in the code that we might not have noted if we were doing everything manually. </p></li>&#13;
			</ol>&#13;
			<p>Now that our tests run automatically, we need to automate keeping track of the version of our module to avoid making the same mistake we made with not updating our tests. </p>&#13;
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Create automatic versioning for our pip package</h2>&#13;
			<p>To <a id="_idIndexMarker310"/>automate the process of updating the version number, we are going to put several functions in the <strong class="source-inline">get_latest_version.py</strong> file in the root of our <strong class="source-inline">pip</strong> module. Following are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to import everything we need with the following code:<p class="source-code"><strong class="bold">import os</strong></p><p class="source-code"><strong class="bold">import pathlib</strong></p><p class="source-code"><strong class="bold">from typing import Tuple, List, Union</strong></p><p class="source-code"><strong class="bold">import requests </strong></p><p>We are going to use <strong class="source-inline">os</strong> and <strong class="source-inline">pathlib</strong> to manage writing the latest version to a file. We are also going to use the <strong class="source-inline">requests</strong> module to call PyPI to get the latest version that is currently available to the public. </p></li>&#13;
				<li>To do this, we can create a function that will get the metadata of our module from PyPI and return the version with the following code:<p class="source-code">def get_latest_version_number() -&gt; str:</p><p class="source-code">    req = requests.get(</p><p class="source-code">    "https://pypi.org/pypi/flitton-fib-py/json")</p><p class="source-code">    return req.json()["info"]["version"]</p></li>&#13;
				<li>This is just a<a id="_idIndexMarker311"/> simple web request. Once we have done this, we are going to want to unpack this string into a tuple of integers with the function defined next:<p class="source-code">def unpack_version_number(version_string: str) \</p><p class="source-code">    -&gt; Tuple[int, int, int]:</p><p class="source-code">    version_buffer: List[str] = \</p><p class="source-code">      version_string.split(".")</p><p class="source-code">    return int(version_buffer[0]),\</p><p class="source-code">      int(version_buffer[1]),int(version_buffer[2])</p><p>Here, we can see that this is a simple split via bullet points. We then convert them to integers and pack them into a tuple to be returned. </p></li>&#13;
				<li>Now that we have got our version number, we need to increase this by one with the function defined next:<p class="source-code">def increase_version_number(version_buffer: \</p><p class="source-code">Union[Tuple[int, int, int], List[int]]) -&gt; List[int]:</p><p class="source-code">    first: int = version_buffer[0]</p><p class="source-code">    second: int = version_buffer[1]</p><p class="source-code">    third: int = version_buffer[2]</p><p class="source-code">    third += 1</p><p class="source-code">    if third &gt;= 10:</p><p class="source-code">        third = 0</p><p class="source-code">        second += 1</p><p class="source-code">        if second &gt;= 10:</p><p class="source-code">            second = 0</p><p class="source-code">            first += 1</p><p class="source-code">    return [first, second, third]</p><p>Here, we can see that if one of the integers is equal or greater than <strong class="source-inline">10</strong>, we set it back to <strong class="source-inline">0</strong> and increase the next number by <strong class="source-inline">1</strong>. The only one that does not get sent to <strong class="source-inline">0</strong> is the furthest number to the left. This will just keep going up.</p></li>&#13;
				<li>Now that we have <a id="_idIndexMarker312"/>increased our number by <strong class="source-inline">1</strong>, we will need to pack the integer into a string, with the function defined next:<p class="source-code">def pack_version_number(</p><p class="source-code">    version_buffer: Union[Tuple[int, int, int], </p><p class="source-code">      List[int]]) -&gt; str:</p><p class="source-code">    return f"{version_buffer[0]}.{version_buffer[1]} \ </p><p class="source-code">      .{version_buffer[2]}"</p></li>&#13;
				<li>Once we have packed this into a string, we will have to write the version to a file. This can be done with the function defined next:<p class="source-code">def write_version_to_file(version_number: str) -&gt; \</p><p class="source-code">None:</p><p class="source-code">    version_file_path: str = str( \</p><p class="source-code">    pathlib.Path(__file__).parent.absolute()) + \</p><p class="source-code">    "/flitton_fib_py/version.py"</p><p class="source-code">    if os.path.exists(version_file_path):</p><p class="source-code">        os.remove(version_file_path)</p><p class="source-code">    with open(version_file_path, "w") as f:</p><p class="source-code">        f.write(f"VERSION='{version_number}'")</p><p>Here, we can see that we ensure that the path is going to be at the root of our module. We then delete the version file if it already exists, as it will already be out of date. </p></li>&#13;
				<li>We then write<a id="_idIndexMarker313"/> our updated version number to the file with the following code:<p class="source-code">if __name__ == "__main__":</p><p class="source-code">    write_version_to_file(</p><p class="source-code">        version_number=pack_version_number(</p><p class="source-code">            version_buffer=increase_version_number(</p><p class="source-code">                version_buffer=unpack_version_number(</p><p class="source-code">            version_string=get_latest_version_number()</p><p class="source-code">                )</p><p class="source-code">            )</p><p class="source-code">        )</p><p class="source-code">    )</p><p>This ensures that if we run the file directly, we will get the updated version written to a file. </p></li>&#13;
				<li>Now, in our <strong class="source-inline">setup.py</strong> file at the root of our module, we must read the version file and define it for our version parameter in the <strong class="source-inline">setup</strong> initialization. For that, we first import <strong class="source-inline">pathlib</strong> into our file and read the version file with this code:<p class="source-code">import pathlib</p><p class="source-code">with open(str(pathlib.Path(__file__).parent.absolute()) +</p><p class="source-code">          "/flitton_fib_py/version.py", "r") as fh:</p><p class="source-code">    version = fh.read().split("=")[1].replace("'", "")</p></li>&#13;
				<li>We then set <a id="_idIndexMarker314"/>the <strong class="source-inline">version</strong> parameter with the read value with the following code:<p class="source-code">setup(</p><p class="source-code">    name="flitton_fib_py",</p><p class="source-code">    version=version,</p><p class="source-code">    ...</p></li>&#13;
			</ol>&#13;
			<p>We now have our version update process fully automated; we must plug this into our GitHub Actions, so we automatically run the update process and push to PyPI when merging with our <strong class="source-inline">main</strong> branch. </p>&#13;
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Deploying onto PyPI using GitHub Actions</h2>&#13;
			<p>To enable our GitHub <a id="_idIndexMarker315"/>actions to push to PyPI, we need to follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we store the username and password for our PyPI account in the <strong class="bold">Secrets</strong> section of our GitHub repository. This can be done by clicking on the <strong class="bold">Settings</strong> tab and then the <strong class="bold">Secrets</strong> tab on the left sidebar, as shown here:<div id="_idContainer053" class="IMG---Figure"><img src="Images/Figure_4.09_B17720.jpg" alt="Figure 4.9 – View of the GitHub Secrets section&#13;&#10;" width="1321" height="648"/></div><p class="figure-caption">Figure 4.9 – View of the GitHub Secrets section</p></li>&#13;
				<li>On the top <a id="_idIndexMarker316"/>right of the view in <em class="italic">Figure 4.9</em> is <strong class="bold">New repository secret</strong>. If we click this, we will get the following screen:</li>&#13;
			</ol>&#13;
			<div>&#13;
				<div id="_idContainer054" class="IMG---Figure">&#13;
					<img src="Images/Figure_4.10_B17720.jpg" alt="Figure 4.10 – View of the GitHub secret creation section&#13;&#10;" width="1205" height="745"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 4.10 – View of the GitHub secret creation section</p>&#13;
			<p>Here, we can create a <a id="_idIndexMarker317"/>secret for our PyPI password and another secret for our PyPI username. </p>&#13;
			<p>Now that we have our secrets defined, we can build our GitHub action in the <strong class="source-inline">.github/workflows/publish-package.yml</strong> file:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to ensure that we publish our package only when we have merged a branch with the <strong class="source-inline">main</strong> branch. To do this, we need to ensure that our action only executes when there's a pull request when it's closed, and the branch being pointed out is <strong class="source-inline">main</strong> with the following code:<p class="source-code">name: Publish Python <img src="Images/Figure_4.11_B17720.png" alt="" width="32" height="31"/> distributions <img src="Images/Figure_4.12_B17720.png" alt="" width="39" height="34"/> to PyPI</p><p class="source-code">on:</p><p class="source-code">  pull_request:</p><p class="source-code">    types: [closed]</p><p class="source-code">    branches:</p><p class="source-code">      - main</p></li>&#13;
				<li>Once this is <a id="_idIndexMarker318"/>done, we can define the basic jobs of installing the dependencies and updating the package version with <strong class="source-inline">jobs</strong>, defined in the following code:<p class="source-code">jobs:</p><p class="source-code">  run-shell-command:</p><p class="source-code">    runs-on: ubuntu-latest</p><p class="source-code">    steps:</p><p class="source-code">      - uses: actions/checkout@v2</p><p class="source-code">      - name: Install dependencies</p><p class="source-code">        run: |</p><p class="source-code">          python -m pip install --upgrade pip</p><p class="source-code">          pip install -r requirements.txt</p><p class="source-code">      - name: update version</p><p class="source-code">        run: python get_latest_version.py</p><p>What we have done is fine so far. However, it will run when any pull request pointing to <strong class="source-inline">main</strong> is closed. Therefore, we must ensure that the pull request has merged before executing the step.</p></li>&#13;
				<li>For the next section, we install the dependencies with the following code:<p class="source-code">      - name: install deployment dependancies</p><p class="source-code">        if: github.event.pull_request.merged == true</p><p class="source-code">        run: |</p><p class="source-code">          pip install twine</p><p class="source-code">          pip install pexpect</p></li>&#13;
				<li>We can see that <a id="_idIndexMarker319"/>our conditional statements are straightforward. We then run the <strong class="source-inline">setup.py</strong> file for it to produce our distribution with the following step:<p class="source-code">      - name: package module</p><p class="source-code">        if: github.event.pull_request.merged == true</p><p class="source-code">        run: python setup.py sdist</p></li>&#13;
				<li>Now that we have defined all the steps needed to prepare our package, we can upload our package using <strong class="source-inline">twine</strong> with the following code:<p class="source-code">      - name: deploy to pypi</p><p class="source-code">        if: github.event.pull_request.merged == true</p><p class="source-code">        env:</p><p class="source-code">          TWINE_USERNAME: ${{ secrets.TWINE_USERNAME </p><p class="source-code">            }}</p><p class="source-code">          TWINE_PASSWORD: ${{ secrets.TWINE_PASSWORD </p><p class="source-code">            }}</p><p class="source-code">        run: |</p><p class="source-code">          twine upload dist/*</p></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we have automated the deployment of our module to PyPI using GitHub Actions.</p>&#13;
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>&#13;
			<p>In this chapter, we have managed to build a fully fledged <strong class="source-inline">pip</strong> Python module that has continuous integration. We initially set up a GitHub repository and created a virtual environment. This is an essential skill for most Python projects, and you should be using GitHub repositories and virtual environments even if your project is not a <strong class="source-inline">pip</strong> module. You will be able to share your project and work with other team members. We then defined our <strong class="source-inline">setup.py</strong> file so our code could be installed via <strong class="source-inline">pip</strong>. Even if our GitHub repository is private, people who have access to the GitHub repository could freely install our code. This gives us even more power when it comes to distributing our code. </p>&#13;
			<p>When we have an interface defined, our users do not need to know much about our code, just how to use the interface. This also enables us to prevent repeated code. For instance, if we build a user data model with a database driver, we can package it as a <strong class="source-inline">pip</strong> module and use this in multiple web applications. All we need to do is change the data model in the <strong class="source-inline">pip</strong> module and make a new release, and then all web applications can use the updated version if they wish. </p>&#13;
			<p>Once our code was packaged, we rebuilt our Fibonacci code in our <strong class="source-inline">pip</strong> module, and it worked. We then went further, building entry points that enabled us to define our own command-line tools. This makes our code packaging even more powerful, as the user doesn't even have to import and code the module; they can just call the command-line argument! With this, we can build development tools to speed up our development by automating tasks with these entry points. We then built basic unit tests to ensure that the quality of our code was maintained. We then locked in these good standards with automation pipelines using GitHub Actions. We introduced type-checking with <strong class="source-inline">mypy</strong> alongside our unit-testing pipeline. We don't have to stop here. For instance, the Python script that we coded that increased the version number by one could be built in its own <strong class="source-inline">pip</strong> repository with a command-line interface. With this, we could install the module using <strong class="source-inline">pip install</strong> in our GitHub Actions and run the commands. Now, with this code packaging, you can build your own tools and add them to your belt, reducing the amount of repetition in your daily coding as time goes on. </p>&#13;
			<p>In the next chapter, we cover what we have done in this chapter in Rust. Considering this, we harness the safety and speed of Rust, with the flexibility of <strong class="source-inline">pip</strong> packaging. Utilizing this will level up your skills as a Python toolmaker, making you invaluable to your team.</p>&#13;
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How would you perform an installation with <strong class="source-inline">pip install</strong> of our GitHub repository on the <strong class="source-inline">test</strong> branch?</li>&#13;
				<li>Can other developers who do not have access to your GitHub repository install your <strong class="source-inline">pip</strong> package if you upload it to PyPI?</li>&#13;
				<li>What is the difference between development dependencies and package dependencies?</li>&#13;
				<li><strong class="source-inline">mypy</strong> ensures the consistency of types when it comes to our Python code. How is this different from type-checking in Rust?</li>&#13;
				<li>Why should we automate boring repetitive tasks?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1"><strong class="source-inline">pip install git+https://github.com/maxwellflitton/flitton-fib-py@test  </strong></li>&#13;
				<li>Yes, they can download it despite not having access to your GitHub repository. If we think about it, we package our <strong class="source-inline">pip</strong> module in a file and then upload it to the PyPI server. Downloading our package from the PyPI server is not connected to our GitHub repository.</li>&#13;
				<li>Development dependencies are specific dependencies defined in the <strong class="source-inline">requirements.txt</strong> file. This ensures that developers can work on the <strong class="source-inline">pip</strong> package. Package requirements are a little more relaxed and defined in the <strong class="source-inline">setup.py</strong> file. These get installed when the user installs our package. Package requirements are to enable the <strong class="source-inline">pip</strong> package to be used.</li>&#13;
				<li>Rust does the type-checking when it is compiling and fails to compile if the types are inconsistent. Because of this, we cannot run it. Python, however, is an interpreted language. Because of this, we can still run it with the potential errors. </li>&#13;
				<li>Repetitive tasks are easy to automate, so the effort invested is not excessive. Also, repetitive tasks have a higher risk of producing errors. Automating these tasks reduces the number of errors we could make. </li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">Python Organisation (2021) Packaging code</em>: <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/">https://packaging.python.org/guides/distributing-packages-using-setuptools/</a></li>&#13;
				<li> <em class="italic">GitHub Organisation (2021) GitHub Actions</em>: <a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>