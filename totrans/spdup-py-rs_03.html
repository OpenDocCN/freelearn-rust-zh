<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-63"><em class="italic"><a id="_idTextAnchor062"/>Chapter 4</em>: Building pip Modules in Python</h1>&#13;
			<p>Writing code to solve our problems is useful. However, writing code can become repetitive and time-consuming, especially when we are building applications. Applications usually require defining the steps that build the application. Packaging our code can help us reuse our code and share it with other developers. In this chapter, we will package Fibonacci code into a Python <code>pip</code> module that can be easily installed and has a command-line tool. We will also cover continuous integration processes that deploy our packages once a merge has been achieved to our <code>main</code> branch.</p>&#13;
			<p>In this chapter, we will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Configuring setup tools for a Python <code>pip</code> module</li>&#13;
				<li>Packaging Python code in a <code>pip</code> module</li>&#13;
				<li>Configuring continuous integration</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Technical requirements</h1>&#13;
			<p>We will need to have Python 3 installed. To get the most out of this chapter, we will also need to have a GitHub account, as we will be using GitHub to package our code, which can be accessed via this link: <a href="https://github.com/maxwellflitton/flitton-fib-py">https://github.com/maxwellflitton/flitton-fib-py</a>. </p>&#13;
			<p>Git command-line tools are also needed in this chapter. These can be installed by following the instructions here: <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>. The chapter will also make use of a PyPI account. You will need to have your own PyPI account, which can be obtained for free with this link: <a href="https://pypi.org/">https://pypi.org/</a>. </p>&#13;
			<p>The code for this chapter can be found via this link: <a href="https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four">https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_four</a>.</p>&#13;
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Configuring setup tools for a Python pip module</h1>&#13;
			<p>Setup tools in <a id="_idIndexMarker228"/>Python are how the code in our<a id="_idIndexMarker229"/> module is packaged and installed. They provide a set of commands and parameters for the system that is installing the code to process. To explore how this is done, we will package the Fibonacci numbers example introduced in the previous chapter. However, these calculations will be packaged in a <code>pip</code> module. To configure our setup tools, we are going to have to carry out the following steps:</p>&#13;
			<ol>&#13;
				<li>Create a GitHub <a id="_idIndexMarker230"/>repository for our Python <code>pip</code> package.</li>&#13;
				<li>Define basic parameters. </li>&#13;
				<li>Define a <code>README</code> file.</li>&#13;
				<li>Define a basic module structure.</li>&#13;
			</ol>&#13;
			<p>Let's have a look at each of these steps in detail in the following subsections.</p>&#13;
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Creating a GitHub repository</h2>&#13;
			<p>Understandably, a<a id="_idIndexMarker231"/> seasoned developer can create a GitHub repository but for the sake of completeness, we will offer <a id="_idIndexMarker232"/>all the steps needed. If you can already create a GitHub repository, move on to the next subsection:</p>&#13;
			<ol>&#13;
				<li value="1">On the home URL of GitHub when we are logged in, we can create our repository by clicking on the <strong class="bold">New</strong> button, as shown here:<div><img src="img/Figure_4.01_B17720.jpg" alt="Figure 4.1 – How to create a new repository on GitHub&#13;&#10;" width="1278" height="335"/></p><p class="figure-caption">Figure 4.1 – How to create a new repository on GitHub</p></li>&#13;
				<li>Once this is<a id="_idIndexMarker233"/> clicked, we can <a id="_idIndexMarker234"/>configure our new repository with the parameters shown next:<div><img src="img/Figure_4.02_B17720.jpg" alt="Figure 4.2 – Parameters for our new GitHub repository&#13;&#10;" width="770" height="997"/></div><p class="figure-caption">Figure 4.2 – Parameters for our new GitHub repository</p><p>For this <a id="_idIndexMarker235"/>example, we have set the GitHub repository to <code>pip</code> packaging for this chapter<a id="_idIndexMarker236"/> will also work the same way for private repositories. We have also included a <code>.gitignore</code> file and selected it to be Python. This is to stop Python caching and for virtual environment files to be tracked by GitHub and uploaded when we upload our code to the repository. Now that we have our GitHub repository made, going to the repository will look like this:</p><div><img src="img/Figure_4.03_B17720.jpg" alt="Figure 4.3 – Our GitHub repository home page&#13;&#10;" width="1297" height="524"/></div><p class="figure-caption">Figure 4.3 – Our GitHub repository home page</p><p>We can <a id="_idIndexMarker237"/>see that our <a id="_idIndexMarker238"/>description is written in the <code>README.md</code> file. It also has to be noted that the <code>README.md</code> file is rendered. This happens in any directory of the repository. We can document what to do and how to use the code throughout the repository with a range of <code>README.md</code> files if we want.</p></li>&#13;
				<li>Once this is done, we can download our repository with the command shown next:<pre><strong class="bold">git clone https://github.com/maxwellflitton/flitton-</strong>
<strong class="bold">  fib-py.git</strong></pre><p>Your URL will be different, as you have a different repository. The only thing left is to ensure that our development environment for our repository has a Python virtual environment.</p></li>&#13;
				<li>This can be done by navigating to the root directory of the GitHub repository and then running the command shown here:<pre><code>venv</code> directory in the root directory. We have to use the <code>venv</code> directory, as this is automatically included in the <code>.gitignore</code> file. However, there is nothing stopping us from calling it what we want, as long as we include it in the <code>.gitignore</code> file. However, <code>venv</code> is the convention, and using this will avoid confusion with other developers. Our environment is now fully set up. </p></li>&#13;
				<li>To use our <a id="_idIndexMarker239"/>virtual environment<a id="_idIndexMarker240"/> in the terminal, we can activate it with the command shown next:<pre><strong class="bold">source venv/bin/activate</strong></pre></li>&#13;
			</ol>&#13;
			<p>We can see that our command is prefixed with <code>(venv)</code>, meaning that it is active.</p>&#13;
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Defining the basic parameters</h2>&#13;
			<p>Now that our <a id="_idIndexMarker241"/>environment is fully functional, we are going to define the basic parameters when installing our Python <code>pip</code> module:</p>&#13;
			<ol>&#13;
				<li value="1">This is achieved by creating a <code>setup.py</code> file in the root of our repository. This will get run when another Python system installs our <code>pip</code> module. In our <code>setup.py</code> file, we import our setup tools with the code shown here:<pre>from setuptools import find_packages, setup</pre><p>We are going to use <code>setup</code> to define our parameters, and we are going to use <code>find_packages</code> to exclude tests.</p></li>&#13;
				<li>Now that we have imported our setup tools, we can define our parameters in the same file with the code shown here:<pre>setup(
    name="flitton_fib_py",
    version="0.0.1",
    author="Maxwell Flitton",
    author_email="maxwell@gmail.com",
    description="Calculates a Fibonacci number",
    long_description="A basic library that \
      calculates Fibonacci numbers",
    long_description_content_type="text/markdown",
    url="https://github.com/maxwellflitton/flitton- \
      fib-py",
    install_requires=[],
    packages=find_packages(exclude=("tests",)),
    classifiers=[
        "Development Status :: 4 - Beta",
        "Programming Language :: Python :: 3",
        "Operating System :: OS Independent",
    ],
    python_requires='&gt;=3',
    tests_require=['pytest'],
)</pre><p>There <a id="_idIndexMarker242"/>are a lot of parameters here. What we have done from the <code>name</code> field to <code>url</code> is essentially define the metadata around our <code>pip</code> module. The <code>classifiers</code> fields are also metadata around our module. The rest of the fields have the following effects:</p><ul><li>The <code>Install_requires</code> field is currently an empty list. This is because our module is not requiring any third-party modules right now. We will cover dependencies in <em class="italic">Managing dependencies</em> section. </li><li>The <code>packages</code> field ensures that we exclude our <code>test</code> directory when we start building our tests for our module. While we will use tests to check our module and ensure standards, we do not need to install them when we are using our module as a third-party dependency. </li><li>The <code>Python_requires</code> field ensures that the system installing our module has the correct version of Python installed. </li><li><code>tests_require</code> is a list of requirements when tests are running. </li></ul></li>&#13;
				<li>Now that <a id="_idIndexMarker243"/>we have defined our basic setup, we can upload our code with the following commands:<pre><strong class="bold">git add -A</strong>
<strong class="bold">git commit -m "adding setup to module"</strong>
<strong class="bold">git push origin main</strong></pre></li>&#13;
			</ol>&#13;
			<p>What we have done here is add all of the new and changed files to our Git branch (which is <code>main</code>). We then committed our files with the <code>adding setup to module</code> message. We then pushed our code to the <code>main</code> branch, which means that we uploaded our changes onto the Git repository online. This is not the best way to manage our code iterations. We will go over different branches and how to manage them in the continuous integration section near the end of this chapter.</p>&#13;
			<p>You may have noticed that <code>long_description</code> is a Markdown; however, trying to fit an entire Markdown into this field would end up dominating the <code>setup.py</code> file. It would essentially be a long string spanning multiple lines, with a few Python lines dispersed into it. We want our <code>setup.py</code> file to dictate the logic of setting up the module when it is being installed. We also want our long description of the module to be rendered by <a id="_idIndexMarker244"/>GitHub when we visit the GitHub repository directly online. Because of this, we will need to add some extra logic around defining our long description in the next section.</p>&#13;
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Defining a README file</h2>&#13;
			<p>Our long <a id="_idIndexMarker245"/>description is essentially the <code>README.md</code> file. If we fuse this with our <code>setup.py</code>, our <code>README.md</code> file will also render if we visit it on PyPI and it is uploaded to the PyPI server. This can be done by <a id="_idIndexMarker246"/>reading the <code>README.md</code> file into a string in the <code>setup.py</code> file and then plugging that string into our <code>long_description</code> field with the following code in the <code>setup.py</code> file:</p>&#13;
			<pre>with open("README.md", "r") as fh:</pre>&#13;
			<pre>    long_description = fh.read()</pre>&#13;
			<pre>setup(</pre>&#13;
			<pre>    name="flitton_fib_py",</pre>&#13;
			<pre>    version="0.0.1",</pre>&#13;
			<pre>    author="Maxwell Flitton",</pre>&#13;
			<pre>    author_email="maxwell@gmail.com",</pre>&#13;
			<pre>    description="Calculates a Fibonacci number",</pre>&#13;
			<pre>    long_description=long_description,</pre>&#13;
			<pre>    ...</pre>&#13;
			<p>The rest of the code after <code>...</code> is the same as before. With this, our basic module setup is complete. Now, all we need is to do is define a basic module to install and use, which is what we will do in the next step.</p>&#13;
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Defining a basic module</h2>&#13;
			<p>Defining a <a id="_idIndexMarker247"/>basic module takes the following structure:</p>&#13;
			<pre>├── LICENSE</pre>&#13;
			<pre>├── README.md</pre>&#13;
			<pre>├── flitton_fib_py</pre>&#13;
			<pre>│   └── __init__.py</pre>&#13;
			<pre>├── setup.py</pre>&#13;
			<pre>└── venv</pre>&#13;
			<p>We house the actual code that the user will have in our <code>flitton_fib_py</code> directory. For now, we are just going to have a basic function that prints something out so that we can see if our<a id="_idIndexMarker248"/> <code>pip</code> package works. Here are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">We do this by adding a basic <code>print</code> function in the <code>flitton_fib_py/__init__.py</code> file that has the following code:<pre>def say_hello() -&gt; None:
    print("the Flitton Fibonacci module is saying hello")</pre><p>Once this is done, we can upload the code to the GitHub repository using the git commands described in the <em class="italic">Packaging Python code in a pip module</em> section. We should now see all the code of our module in the <code>main</code> branch. Considering this, we need to navigate to another directory that is not associated with our <code>git</code> repository. </p></li>&#13;
				<li>We then unlink our virtual environment by typing the following command:<pre><code>pip install</code> and check to see whether it works.</p></li>&#13;
				<li>To use <code>pip install</code>, we point to the URL of the GitHub repository that our <code>pip</code> module is stored and define which branch it is. We do this by typing the following <a id="_idIndexMarker249"/>command, all in one line:<pre><strong class="bold">pip install git+https://github.com/maxwellflitton/</strong>
<strong class="bold">  flitton-fib-py@main</strong></pre><p>Your GitHub repository will have a different URL and you might have a different directory. Running this command will give us a range of printouts, stating that it is cloning the repository and installing it.</p></li>&#13;
				<li>We then<a id="_idIndexMarker250"/> open up a Python terminal by typing in the following command:<pre><strong class="bold">python</strong></pre></li>&#13;
				<li>We now have an interactive terminal. We can check to see whether our module works by typing in the following commands:<pre><strong class="bold">&gt;&gt;&gt; from flitton_fib_py import say_hello</strong>
<strong class="bold">&gt;&gt;&gt; say_hello()</strong></pre><p>Once the last command is typed, we will get the following printout in the terminal:</p><pre><strong class="bold">the Flitton Fibonacci module is saying hello</strong></pre></li>&#13;
			</ol>&#13;
			<p>There we have it – our Python package works! This works for both private and public GitHub repositories. Nothing is stopping us now from packaging private Python code to reuse on other private Python projects! </p>&#13;
			<p>While this is a useful tool to package and install code on other computers with minimal setup, we have to be careful. When we are running the <code>setup.py</code> file, we are running the code as our root user. Therefore, we have to ensure that we trust what we are installing. Putting malicious code into the <code>setup.py</code> file is a vector of attack. We can run direct commands on the computer using the <code>SubProcess</code> object from the standard Python library. Make sure you trust the author of the code that you are installing with <code>pip install</code>.</p>&#13;
			<p>This also highlights how vigilant you have to be when merely just running <code>pip install</code>. There are developers out there who will slightly change a package. For instance, a famous case was the <code>requests</code> package. This is a common, well-used package; however, for some time, there was an imitation package called <code>request</code>. They relied on people mistyping <code>pip install</code> and downloading the wrong package. This is known <a id="_idIndexMarker251"/>as <strong class="bold">typosquatting</strong>. </p>&#13;
			<p>We have now packaged our Python code into a module. However, it is not a very useful module. This brings us to our next section, where we package our Fibonacci sequencing code.</p>&#13;
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Packaging Python code in a pip module</h1>&#13;
			<p>Now that we have<a id="_idIndexMarker252"/> our GitHub repository configured, we can start building out our Fibonacci code for our module. To achieve this, we must carry out the following steps: </p>&#13;
			<ol>&#13;
				<li value="1">Build our Fibonacci calculation code. </li>&#13;
				<li>Create a command-line interface.</li>&#13;
				<li>Test our Fibonacci calculation code with unit tests. </li>&#13;
			</ol>&#13;
			<p>Let's now discuss each of these steps in detail.</p>&#13;
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Building our Fibonacci calculation code</h2>&#13;
			<p>When it comes to<a id="_idIndexMarker253"/> building our Fibonacci calculation code, we will have two functions – one that will calculate a Fibonacci number and another that will take a list of numbers and lean on the calculation function to <a id="_idIndexMarker254"/>return a list of calculated Fibonacci numbers. For this module, we will take a functional programming approach. This does not mean that we should have a functional programming approach every time we build a <code>pip</code> module. We are using functional programming because Fibonacci sequence calculations naturally flow well with a functional programming style.</p>&#13;
			<p>Python is an object-orientated language, and problems that have multiple moving parts interrelating naturally flow well with object-orientated approaches. Our module structure will take the following form:</p>&#13;
			<pre>├── LICENSE</pre>&#13;
			<pre>├── README.md</pre>&#13;
			<pre>├── flitton_fib_py</pre>&#13;
			<pre>│   ├── __init__.py</pre>&#13;
			<pre>│   └── fib_calcs</pre>&#13;
			<pre>│       ├── __init__.py</pre>&#13;
			<pre>│       ├── fib_number.py</pre>&#13;
			<pre>│       └── fib_numbers.py</pre>&#13;
			<pre>├── setup.py</pre>&#13;
			<p>For this chapter, we will maintain a simple interface so that we can focus on the packaging of<a id="_idIndexMarker255"/> code in a <code>pip</code> module. Here <a id="_idIndexMarker256"/>are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we can build our Fibonacci number calculator in the <code>fib_number.py</code> file with the following code:<pre>from typing import Optional
def recurring_fibonacci_number(number: int) -&gt; \
Optional[int]:
    if number &lt; 0:
        return None
    elif number &lt;= 1:
        return number
    else:
    return recurring_fibonacci_number(number - 1) + \
           recurring_fibonacci_number(number - 2)</pre><p>Here, it has to be noted that we are returning <code>None</code> when the input number is below zero. Technically, we should be throwing an error, but this is in place, for now, to demonstrate the effectiveness of a checking tool later on in our <em class="italic">Configuring continuous integration</em> section. As we know from the previous chapter, the preceding code will correctly calculate a Fibonacci number based on the input number. </p></li>&#13;
				<li>Now that we have this function, we can depend on this to create a function that creates a list<a id="_idIndexMarker257"/> of Fibonacci<a id="_idIndexMarker258"/> numbers in our <code>fib_numbers.py</code> file with the following code:<pre>from typing import List
from .fib_number import recurring_fibonacci_number
def calculate_numbers(numbers: List[int]) -&gt; List[int]:
    return [recurring_fibonacci_number(number=i) \
      for i in numbers]</pre><p>We are now ready to test our <code>pip</code> module again. We must push our code to the <code>main</code> branch on our repository again, uninstall our <code>pip</code> package in another virtual environment, and install again using <code>pip install</code>.</p></li>&#13;
				<li>In our Python terminal with our new installed package, we can test our <code>recurring_fibonacci_number</code> function with the following console commands:<pre><strong class="bold">&gt;&gt;&gt; from flitton_fib_py.fib_calcs.fib_number </strong>
<strong class="bold">    import recurring_fibonacci_number</strong>
<strong class="bold">&gt;&gt;&gt; recurring_fibonacci_number(5)</strong>
<strong class="bold">5</strong>
<strong class="bold">&gt;&gt;&gt; recurring_fibonacci_number(8)</strong>
<strong class="bold">21</strong></pre><p>Here, we can see that our Fibonacci function can be imported, and it works, calculating the correct Fibonacci numbers.</p></li>&#13;
				<li>We can test our <code>calculate_numbers</code> with the following commands:<pre><strong class="bold">&gt;&gt;&gt; from flitton_fib_py.fib_calcs.fib_numbers </strong>
<strong class="bold">     </strong><strong class="bold">import calculate_numbers</strong>
<strong class="bold">&gt;&gt;&gt; calculate_numbers([1, 2, 3, 4, 5, 6, 7])</strong>
<strong class="bold">[1, 1, 2, 3, 5, 8, 13]</strong></pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see <a id="_idIndexMarker259"/>that our <code>calculate_numbers</code> function also works. We have a fully functioning Fibonacci <code>pip</code> module. However, if we want to just calculate a Fibonacci number without coding a Python <a id="_idIndexMarker260"/>script, we should not have to go into a Python terminal. We can remedy this by building a command-line interface in the next step. </p>&#13;
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Creating a command-line interface</h2>&#13;
			<p>In order to build our<a id="_idIndexMarker261"/> command line function, our module can take the following structure:</p>&#13;
			<pre>├── LICENSE</pre>&#13;
			<pre>├── README.md</pre>&#13;
			<pre>├── flitton_fib_py</pre>&#13;
			<pre>│   ├── __init__.py</pre>&#13;
			<pre>│   ├── cmd</pre>&#13;
			<pre>│   │   ├── __init__.py</pre>&#13;
			<pre>│   │   └── fib_numb.py</pre>&#13;
			<pre>│   └── fib_calcs</pre>&#13;
			<pre>     . . .</pre>&#13;
			<p>To build our interface, we follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">We build the command-line interface in our <code>fib_numb.py</code> file with the following code:<pre>import argparse
from flitton_fib_py.fib_calcs.fib_number \
    import recurring_fibonacci_number
def fib_numb() -&gt; None:
    parser = argparse.ArgumentParser(
        description='Calculate Fibonacci numbers')
    parser.add_argument('--number', action='store', 
                        type=int, required=True,
                        help="Fibonacci number to be \
                          calculated")
    args = parser.parse_args()
    print(f"Your Fibonacci number is: " \
      f"{recurring_fibonacci_number \
        (number=args.number)}")</pre><p>Here, we can <a id="_idIndexMarker262"/>see that we get the parameters passed in from the command line using the <code>argparse</code> module. Once we have obtained the parameters, we will then calculate the number and print it out. Now, for us to actually access it via the terminal, we have to point to it in the <code>setup.py</code> file at the root of the <code>pip</code> package by adding the following parameter in the <code>setup</code> object initialization:</p><pre>entry_points={
    'console_scripts': [
        'fib-number = \
           flitton_fib_py.cmd.fib_numb:fib_numb',
    ],
},</pre><p>Here, what we are doing is linking the <code>fib-number</code> console command with the function that we have just defined. After uninstalling our <code>pip</code> module in another virtual environment, uploading the changes to the <code>main</code> branch on our repository, and installing our new module using <code>pip install</code>, we will have our new module with the command-line tool that we have built. </p></li>&#13;
				<li>Once it is<a id="_idIndexMarker263"/> installed, we just type in the following command:<pre><code>argparse</code> module that we are using ensures that we provide the arguments needed. If we need help, we can get this by typing in the following command:</p><pre><strong class="bold">fib-number -h</strong></pre><p>This gives us the help printout, as shown here:</p><pre><strong class="bold">usage: fib-number [-h] --number NUMBER</strong>
<strong class="bold">Calculate Fibonacci numbers</strong>
<strong class="bold">optional arguments:</strong>
<strong class="bold">  -h, --help       show this help message and exit</strong>
<strong class="bold">  --number NUMBER  Fibonacci number to be calculated</strong></pre><p>We can see that we have the type and the help description of what it does.</p></li>&#13;
				<li>So, to calculate the Fibonacci number, we use the following command:<pre><strong class="bold">fib-number --number 20</strong></pre><p>This gives us the following printout:</p><pre><strong class="bold">Your Fibonacci number is: 6765</strong></pre><p>If we were to provide a string instead of a number for our argument, our program would refuse it, throwing an error. </p></li>&#13;
			</ol>&#13;
			<p>Here we have it, we <a id="_idIndexMarker264"/>have a fully working command-line tool! This does not stop here. You can take this further. Nothing is stopping you from using <code>subprocess</code> from the standard library combined with other libraries, such as Docker, to build your own DevOps tools. You can automate whole workflows for yourself and the applications you make. However, if we are to rely more and more on our <code>pip</code> modules to do the repetitive heavy lifting, we can get into serious problems if the program introduces some bugs we need to know straight away. To do this, we need to start building unit tests for our module. These are covered in the next subsection. </p>&#13;
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Building unit tests</h2>&#13;
			<p>Unit tests <a id="_idIndexMarker265"/>are <a id="_idIndexMarker266"/>helpful for us to check and maintain quality control for our code. To build our unit tests, our module will have <a id="_idIndexMarker267"/>the following structure:</p>&#13;
			<pre>├── LICENSE</pre>&#13;
			<pre>├── README.md</pre>&#13;
			<pre>├── flitton_fib_py</pre>&#13;
			<pre>     . . .</pre>&#13;
			<pre>├── scripts</pre>&#13;
			<pre>│   └── run_tests.sh</pre>&#13;
			<pre>├── setup.py</pre>&#13;
			<pre>├── tests</pre>&#13;
			<pre>│   ├── __init__.py</pre>&#13;
			<pre>│   └── flitton_fib_py</pre>&#13;
			<pre>│       ├── __init__.py</pre>&#13;
			<pre>│       └── fib_calcs</pre>&#13;
			<pre>│           ├── __init__.py</pre>&#13;
			<pre>│           ├── test_fib_number.py</pre>&#13;
			<pre>│           └── test_fib_numbers.py</pre>&#13;
			<p>We can see that we<a id="_idIndexMarker268"/> are mimicking the structure of the code in our module. This is important to keep track of our tests. If the module grows, then we will not get lost in our tests. If we need to chop out a directory or move it to<a id="_idIndexMarker269"/> another module, we can simply delete the appropriate directory or move it. It also has to be noted that we have built a Bash script to run our tests. </p>&#13;
			<p>When it comes to writing our tests, it is usually best to code based on the chain of dependency. For instance, our files have the dependency chain depicted as follows:</p>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_4.04_B17720.jpg" alt="Figure 4.4 – Dependency chain&#13;&#10;" width="722" height="389"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 4.4 – Dependency chain</p>&#13;
			<p>Considering our dependency chain, we should ideally write our tests for the <code>fib_number.py</code> file first and make sure that our <code>recurring_fibonacci_number</code> function works before writing tests that rely on the <code>recurring_fibonacci_number</code> function. Here are the steps to write our tests:</p>&#13;
			<ol>&#13;
				<li value="1">We first import what we need to test our code in our <code>test_fib_number.py</code> file via the following code:<pre>from unittest import main, TestCase
from flitton_fib_py.fib_calcs.fib_number \
    import recurring_fibonacci_number</pre><p>The <code>main</code> function <a id="_idIndexMarker270"/>is to run all <a id="_idIndexMarker271"/>tests. We also rely on the <code>TestCase</code> class by writing our own test class that inherits <code>TestCase</code>. This gives our class extra class functions to aid us in testing outcomes. </p></li>&#13;
				<li>We can write our own tests for a range of inputs with the following code:<pre>class RecurringFibNumberTest(TestCase):
    def test_zero(self):
        self.assertEqual(0, 
            recurring_fibonacci_number(number=0)
        )
    def test_negative(self):
        self.assertEqual(
            None, recurring_fibonacci_number \
              (number=-1)
        )
    def test_one(self):
        self.assertEqual(1, \
          recurring_fibonacci_number(number=1))
    def test_two(self):
        self.assertEqual(1, \ 
          recurring_fibonacci_number(number=2))
    def test_twenty(self):
        self.assertEqual( \
        6765, recurring_fibonacci_number(number=20)
        )</pre><p>Here, it has to be<a id="_idIndexMarker272"/> noted that each one of our functions has the <code>test_</code> prefix. This flags the function as a test function. This is also the case for the name of the file. All test files have the <code>test_</code> prefix to flag that the file houses tests. In our testing code, we can see that we<a id="_idIndexMarker273"/> have merely passed a range of inputs into the function that we are testing and asserted that the outcome is what we expect. If the assertions do not hold water, then we get an error and a failed result. Seeing as we are just testing the same function repeatedly, we can put all of the assertions into one test function. This is usually preferred if we are testing the whole object. We would essentially have one test function for each function that we are testing in the object. </p></li>&#13;
				<li>Now that all our tests have been run, we can run the <code>unittest</code> <code>main</code> function if the <code>test_fib_number.py</code> file is run directly at the bottom of the <code>test_fib_number.py</code> file with the code shown next:<pre>if __name__ == "__main__":
    main()</pre></li>&#13;
				<li>We now have to set our <code>PYTHONPATH</code> variable to the directory of <code>flitton_fib_py</code>. <p>Once this is done, we can run our <code>test_fib_number.py</code> file and get the console printout as shown:</p><pre><code>None</code> to a <code>1</code> in the second test, we would get the following printout:</p><pre><code>F</code> in the test dots, and it highlights what test is failing and where it is failing.</p></li>&#13;
				<li>Now that we have built our base test, we can build our tests for the function that takes in a list of integers and returns a list of Fibonacci numbers. In our <code>test_fib_numbers.py</code> file, we import what we need with the following code:<pre>from unittest import main, TestCase
from unittest.mock import patch
from flitton_fib_py.fib_calcs.fib_numbers \
    import calculate_numbers</pre><p>Here, we can see that we are importing the function that we are testing and the same <code>main</code> and <code>TestCase</code>. However, it has to be noted that we have imported a <code>patch</code> function. This is because we have already tested our <code>recurring_fibonacci_number</code> function. The <code>patch</code> function enables us to insert a <code>MagicMock</code> object in place of our <code>recurring_fibonacci_number</code> function.</p></li>&#13;
			</ol>&#13;
			<p>For our example, it can be<a id="_idIndexMarker276"/> argued that we do not <a id="_idIndexMarker277"/>need to patch anything. However, it is important to get an understanding of patching. <code>MagicMock</code> object; we can define the return values to anything we want during the test and log all calls to the <code>MagicMock</code> object.</p>&#13;
			<p>The advantage here is that we might accidentally call the function we are depending on twice for some reason. However, if the function returns the same value twice, we will not know anything if we did not patch it. However, with patching, we can inspect the calls and throw errors if the behavior is not what we expect. We can also test a range of edge cases very quickly by merely changing the return value of the patches and rerunning the test.</p>&#13;
			<p>With all this, it is understandable that we can get excited about patching. However, there are some downsides. If we do not update the patches' return values, the dependent code does not get the changes, and the testing does not remain accurate. This is why it is always sensible to have a mixture of approaches and run a functional test that runs the whole<a id="_idIndexMarker279"/> process without patching anything. With all<a id="_idIndexMarker280"/> this in mind, our patched unit test in the <code>tests/flitton_fib_by/fib_calcs/test_fib_numbers.py</code> file is carried out by the following code:</p>&#13;
			<pre>class Test(TestCase):</pre>&#13;
			<pre>    @patch("flitton_fib_py.fib_calcs.fib_numbers." </pre>&#13;
			<pre>           "recurring_fibonacci_number")</pre>&#13;
			<pre>    def test_calculate_numbers(self, mock_fib_calc):</pre>&#13;
			<pre>        expected_outcome = [mock_fib_calc.return_value, </pre>&#13;
			<pre>                          mock_fib_calc.return_value]</pre>&#13;
			<pre>        self.assertEqual(expected_outcome, </pre>&#13;
			<pre>                         calculate_numbers(numbers=[3, 4]))</pre>&#13;
			<pre>        self.assertEqual(2, </pre>&#13;
			<pre>          len(mock_fib_calc.call_args_list))</pre>&#13;
			<pre>        self.assertEqual({'number': 3}, </pre>&#13;
			<pre>          mock_fib_calc.call_args_list[0][1])</pre>&#13;
			<pre>        self.assertEqual({'number': 4}, </pre>&#13;
			<pre>          mock_fib_calc.call_args_list[1][1])</pre>&#13;
			<p>Here, we can see that we have used the patch as a decorator with a string that defines the path to the function that we are patching. We then pass the patched function through the test function under the <code>mock_fib_calc</code> parameter. We then state that we expect the outcome of the function that we are directly testing (<code>calculate_numbers</code>) to be a list of two return values of the patched function. We then pass two integers wrapped in a list into the <code>calculate_numbers</code> function and assert that this is going to be the same as our expected outcome. Once this is done, we assert that the <code>mock_fib_calc</code> was only called twice, and we inspect each of those calls, asserting that they are the numbers that we passed in, in the correct order. This has given us a lot of <a id="_idIndexMarker281"/>power to truly inspect our code. However, we are not done yet; we also must define the functional test to enable us to<a id="_idIndexMarker282"/> run our tests with the code here:</p>&#13;
			<pre>    def test_functional(self):</pre>&#13;
			<pre>        self.assertEqual([2, 3, 5], </pre>&#13;
			<pre>            calculate_numbers(numbers=[3, 4, 5]))</pre>&#13;
			<pre>if __name__ == "__main__":</pre>&#13;
			<pre>    main()</pre>&#13;
			<p>For our module, all our unit tests are done. However, we do not want to go through manually running each file to see our tests. There will be times where we want to just see all the outcomes of the tests to see if there are any fails. To automate this, we can build a Bash script in the <code>run_tests.sh</code> file with the code here:</p>&#13;
			<pre>#!/usr/bin/env bash</pre>&#13;
			<pre>SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"</pre>&#13;
			<pre>cd $SCRIPTPATH</pre>&#13;
			<pre>cd ..</pre>&#13;
			<pre>source venv/bin/activate</pre>&#13;
			<pre>export PYTHONPATH="./flitton_fib_py"</pre>&#13;
			<pre>python -m unittest discover</pre>&#13;
			<p>Here, we claim that the file is a Bash script with the first line. The first line is a shebang line and tells the computer running it what type of language it is. We then get the directory path of where this script is and assign it to the <code>SCRIPTPATH</code> variable. We then navigate to this directory, move out to the root of our module, activate our virtual environment, and then define our <code>PYTHONPATH</code> variable to be in our module with the Fibonacci number code. Now that everything is defined, to run our test we use the <code>unittest</code> command-line tool to run all the unit tests. Remember, all our tests have the <code>test_</code> prefix in their <a id="_idIndexMarker283"/>filenames. Running this<a id="_idIndexMarker284"/> gives us the following printout:</p>&#13;
			<pre>.......</pre>&#13;
			<pre>------------------------------------------</pre>&#13;
			<pre>Ran 7 tests in 0.003s</pre>&#13;
			<pre>OK</pre>&#13;
			<p>Here, we can see that we have seven tests running and they have all passed. We can see that we have started automating the test-running process. This is not where we should stop. As we move forward onto packaging and distributing our <code>pip</code> module, we should investigate automating the processes through continuous integration, which is what we explore in the next section. Right now, as it stands, if a user has access to our GitHub repository, we can install the code via <code>pip</code> and use it.</p>&#13;
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Configuring continuous integration</h1>&#13;
			<p>Our Python <code>pip</code> package<a id="_idIndexMarker285"/> is fully functioning. However, this is not the end. We will need to maintain the quality of the code and enable it to be constantly upgraded when we push new features to our module and refactor existing code. Continuous integration enables us to ensure that the tests pass and that the standard of quality is maintained. It also speeds up the deployment process, enabling us to push new iterations within a matter of minutes, enabling us to focus on the task at hand. It also reduces the risk of making a mistake. </p>&#13;
			<p>As we know, the most mundane, repetitive tasks are the ones that are at the highest risk of a mistake occurring. This is just a fact of life. It's known that most car crashes happen within 5 minutes of the driver's home. This is because the drivers pay less attention and their brain switches off, relying on muscle memory. Deployment processes are the same. They are repetitive and do not require a lot of mental focus. As a result, after several times, we will start to rely on muscle memory and forget to check certain things, and make minor blunders when deploying our <code>pip</code> package. Continuous integration is a must to avoid mistakes and saves time in not only deployment but also in not having to correct the errors. To set up continuous integration, we are going to have to carry out the <a id="_idIndexMarker286"/>following steps:</p>&#13;
			<ol>&#13;
				<li value="1">Manually deploy onto PyPI. </li>&#13;
				<li>Manage our dependencies.</li>&#13;
				<li>Set up type checking for Python.</li>&#13;
				<li>Set up and run tests and type checking with GitHub Actions.</li>&#13;
				<li>Create automatic versioning for our <code>pip</code> package.</li>&#13;
				<li>Deploy onto PyPI using GitHub Actions.</li>&#13;
			</ol>&#13;
			<p>Let's have a look at each of these steps in detail in the following subsections.</p>&#13;
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>Manually deploying onto PyPI</h2>&#13;
			<p>We now <a id="_idIndexMarker287"/>move on to our first step of manually deploying our GitHub repository onto PyPI. We have installed our <code>pip</code> package by directly pointing to the GitHub repository. However, if we are allowing everyone to access our module as it's open source, it is easier to upload our package onto PyPI. This will enable others to install using a simple command. Here are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to package our <code>pip</code> module before we upload it. This can be done with the following command:<pre><code>pip</code> module in a <code>tar.gz</code> file, which gives us the following file outline:</p><pre>├── LICENSE
├── README.md
├── dist
│   └── flitton_fib_py-0.0.1.tar.gz
├── flitton_fib_py
    . . .</pre></li>&#13;
				<li>We can<a id="_idIndexMarker288"/> now see that the version is included in the filename. We are now ready to upload onto the PyPI server. To do this, we have to install <code>twine</code> with the following command:<pre><strong class="bold">pip install twine</strong></pre></li>&#13;
				<li>We are now able to upload the <code>tar.gz</code> file with the following command:<pre><strong class="bold">twine upload dist/*</strong></pre><p>This uploads all of the packages that we have created. During this process, the terminal will ask us for the PyPI username and password. It then uploads the package and tells us where we can find out the module on PyPI. If we visit this, we should get the view depicted in the following figure:</p></li>&#13;
			</ol>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_4.05_B17720.jpg" alt="Figure 4.5 – PyPI view of our module&#13;&#10;" width="1220" height="777"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 4.5 – PyPI view of our module</p>&#13;
			<p>We can see that <a id="_idIndexMarker289"/>our <code>README.md</code> file is being directly rendered in the view in <em class="italic">Figure 4.5</em>. We can now directly install this with the <code>pip install</code> command depicted in the PyPI view. It must be noted that we now have a dependency. We need to manage these dependencies. We will cover this in the next step.</p>&#13;
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Managing dependencies</h2>&#13;
			<p>When it comes to <a id="_idIndexMarker290"/>dependencies, we must manage two types. For instance, our <code>twine</code> dependency helps us upload it onto PyPI. However, this is not needed for the <code>pip</code> package. Therefore, we need two different lists of dependencies – one for development and the other for actual use. We define the dependencies that we need for the development with the simple standard command stated here:</p>&#13;
			<pre>pip freeze &gt; requirements.txt</pre>&#13;
			<p>What the <code>pip freeze</code> command gives us is a specific list of requirements that our current Python environment needs to install in order to run. <code>&gt; requirements.txt</code> writes it to the <code>requirements.txt</code> file. If you are a new developer starting to develop our module, you can install all the requirements needed with the following command:</p>&#13;
			<pre>pip install -r requirements.txt</pre>&#13;
			<p>We can be strict here because nothing is depending on the development requirements apart from the direct development of our module. However, when it comes to our module, we know that<a id="_idIndexMarker291"/> it will be installed into multiple systems with multiple requirements. Therefore, we want to allow some flexibility. For instance, if our module was going to write our Fibonacci numbers to <code>yml</code> and <code>pickle</code> files, then we will need to use the <code>pyYAML</code> and <code>dill</code> modules to enable us to write our Fibonacci numbers to <code>yml</code> and <code>pickle</code> files. To do this, we alter our <code>install_requires</code> parameter in our <code>setup</code> initialization in the <code>setup.py</code> file with the code here:</p>&#13;
			<pre>install_requires=[ </pre>&#13;
			<pre>    "PyYAML&gt;=4.1.2",</pre>&#13;
			<pre>    "dill&gt;=0.2.8"</pre>&#13;
			<pre>],</pre>&#13;
			<p>It must be noted that these are not the latest packages. We must drop a few versions and allow our dependency to be equal to or above that version. This gives our users freedom when using our pip package in their systems. We also must copy and paste these requirements into our <code>requirements.txt</code> file to ensure that our development is consistent with the user experience of our <code>pip</code> module. Let's say that we are going to add an optional feature which is to start a small Flask server that locally serves an API that calculates Fibonacci numbers. Here, we can add an <code>install_requires</code> parameter in our <code>setup</code> initialization in the <code>setup.py</code> file with the following code:</p>&#13;
			<pre>extras_require={</pre>&#13;
			<pre>  'server': ["Flask&gt;=1.0.0"]</pre>&#13;
			<pre>},</pre>&#13;
			<p>Now, if we upload our new code to either PyPI or our personal GitHub repository, we will have a different experience when installing our package. If we normally install it, we will see that our <code>pickle</code> and <code>yml</code> requirements automatically install if we run the install command, as shown here:</p>&#13;
			<pre>pip install flitton-fib-py[server]</pre>&#13;
			<p>It will actually install the<a id="_idIndexMarker292"/> server requirements. We can have as many requirements for the <code>server</code> profile as we want, and they will all be installed. Remember, our <code>extras_require</code> parameter is a dictionary, so we can define as many extra requirement profiles as we want. With this, we now have development requirements, essential <code>pip</code> module requirements, and optional <code>pip</code> module requirements. In the next step, we are now going to rely on a new development requirement to check types.</p>&#13;
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Setting up type checking for Python</h2>&#13;
			<p>At this point in the book, we have<a id="_idIndexMarker293"/> experienced the safety that Rust introduces. When types don't match up, the Rust compiler refuses to compile. However, with Python, we do not get this, as Python is an interpreted language. However, we can mimic this using the <code>mypy</code> module. The steps are as follows:</p>&#13;
			<ol>&#13;
				<li value="1">First, we can install the <code>mypy</code> module with the following command:<pre><strong class="bold">pip install mypy</strong></pre></li>&#13;
				<li>We can then type-check by using the <code>mypy</code> entry point with the code here:<pre><code>mypy</code> is <a id="_idIndexMarker294"/>doing is checking the consistency across all of our Python code! Like a Rust compiler, it has found an inconsistency. However, because this is Python, we can still run our Python code. While Python is memory-safe, the strong type-checking that Rust enforces is going to reduce the risk of incorrect variables being passed into the function in runtime. Now, we know that there is an inconsistency. The inconsistency is that our <code>recurring_fibonacci_number</code> function returns either <code>None</code> or <code>int</code>. However, our <code>calculate_numbers</code> function relies on the <code>recurring_fibonacci_number</code> function for the return value, but it returns a list of integers as opposed to returning a list of integers or <code>None</code> values.</p></li>&#13;
				<li>We can constrict the return value to just an integer with the <code>recurring_fibonacci_number</code> function:<pre>def recurring_fibonacci_number(number: int) -&gt; int:
    if number &lt; 0:
        raise ValueError(
        "Fibonacci has to be equal or above zero"
        )
    elif number &lt;= 1:
        return number
    else:
     return recurring_fibonacci_number(number - 1) + \
            recurring_fibonacci_number(number - 2)</pre><p>Here, we can<a id="_idIndexMarker295"/> see that we raise an error if the input number is below zero. It's not going to calculate anyway, so we might as well throw an error informing the user that there is an error as opposed to silently producing a <code>None</code> value. </p><p>If we run our <code>mypy</code> check, we get the following console printout: </p><pre><strong class="bold">Success: no issues found in 6 source files</strong></pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that all our files were checked and that they have type consistency. </p>&#13;
			<p>However, we might forget to run this type of checking every time we upload new code to the GitHub repository. In the next section, we will define GitHub Actions to automate our checking.</p>&#13;
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Setting up and running tests and type-checking with GitHub Actions</h2>&#13;
			<p>GitHub Actions run a series of computations that we can define in a <code>yml</code> file. We generally use GitHub Actions to automate processes that need to run every time. Workflow <code>yml</code> files are automatically detected by GitHub and run depending on what type of tags we give it. We can <a id="_idIndexMarker296"/>set up our GitHub Actions<a id="_idIndexMarker297"/> by following these steps:</p>&#13;
			<ol>&#13;
				<li value="1"> For our tests and type-checking tags, we will define these in the <code>.github/workflows/run-tests.yml</code> file. In this file, we initially give a name for the workflow, and state that it fires when there is a push from one branch to another. This happens when a pull request is done as one branch is being pushed to another. This also reruns if we push more changes to our branch before merging the pull request. Our definitions are inserted at the top of the file with the following code:<pre><code>Run tests</code>. </p></li>&#13;
				<li>Next, we must<a id="_idIndexMarker298"/> define our jobs. We also must state that our job is a <code>shell </code>command. We then define what the<a id="_idIndexMarker299"/> operating system is. Once we have done this, we define the steps of the job. In our <code>steps</code> section, we then define the <code>uses</code>, which we will state are <code>actions</code> with the following code:<pre><code>uses</code> step, then we would not be able to access files such as the requirements. </p></li>&#13;
				<li>We are now ready to define the rest of the steps under the <code>steps</code> tag. These steps usually have a <code>name</code> and <code>run</code> tag. For us, we will be defining three steps:<ol><li>The first one is to install the dependencies.</li><li>The second one is to run all the unit tests. </li><li>The third one is to run the type-checking with the code here:</li></ol><pre><code>run</code> is just a one-line terminal command. At one point, there is a <code>|</code> (pipe) value next to a <code>run</code> tag of the <code>Install dependencies</code> step. This pipe value simply allows us to write multiple lines of commands in one step. We must ensure that our <code>requirements.txt</code> file is updated with the <code>mypy</code> module. Once this is done, we can push this code to our GitHub repository and this GitHub action will run when we do pull requests. If you are familiar with GitHub<a id="_idIndexMarker300"/> and making pull requests, then you can move on to the next step. However, if you are not, then we can perform one now.</p></li>&#13;
				<li>First, we have to pull a new<a id="_idIndexMarker301"/> branch from our <code>main</code> branch with the following command:<pre><code>test</code>. We can then make a change in our code. </p></li>&#13;
				<li>To just trigger a GitHub action with a pull request, we can simply scar our code with a comment in any file, such as the one here:<pre># trigger build (14-6-2021)</pre><p>You can write whatever, as it is just a comment if the code has changed. We then add and commit our changes to our <strong class="bold">test</strong> branch and push it to the GitHub repository. Once this is done, we can trigger a pull request by clicking on the <strong class="bold">Pull requests</strong> tab and selecting our <strong class="bold">test</strong> branch, as shown here:</p><div><img src="img/Figure_4.06_B17720.jpg" alt="Figure 4.6 – Setting up a GitHub pull request&#13;&#10;" width="1461" height="659"/></div><p class="figure-caption">Figure 4.6 – Setting up a GitHub pull request</p></li>&#13;
				<li>Once this is done, we<a id="_idIndexMarker302"/> can click <a id="_idIndexMarker303"/>on <strong class="bold">Create pull request</strong> to view it. Here, we will see all the GitHub Actions that get triggered and their status, as shown in the following figure:<div><img src="img/Figure_4.07_B17720.jpg" alt="Figure 4.7 – View of the GitHub Actions status of pull requests&#13;&#10;" width="1457" height="810"/></div><p class="figure-caption">Figure 4.7 – View of the GitHub Actions status of pull requests</p><p>We can see that our<a id="_idIndexMarker304"/> tests have failed! If we click on <strong class="bold">Details</strong>, we can see that everything is working; <a id="_idIndexMarker305"/>it is just that we forgot to update our tests. If we remember, we changed our code to throw an error if we pass in a negative value into the Fibonacci calculation function, as shown next:</p><div><img src="img/Figure_4.08_B17720.jpg" alt="Figure 4.8 – View of the GitHub Actions execution details&#13;&#10;" width="1356" height="684"/></div><p class="figure-caption">Figure 4.8 – View of the GitHub Actions execution details</p></li>&#13;
				<li>We can change the<a id="_idIndexMarker306"/> test code to <a id="_idIndexMarker307"/>assert that an error is raised by the testing code in the <code>tests/flitton_fib_py/fib_calcs/test_fib_number.py</code> file with the following code:<pre>def test_negative(self):
    with self.assertRaises(ValueError) as \
raised_error:
        recurring_fibonacci_number(number=-1)
    self.assertEqual(
        "Fibonacci has to be equal or above zero",
        str(raised_error.exception)
    ) </pre><p>Here, we can see that we assert that a value error is raised because we are running code that we expect to raise an error, and that the exception is what we expect of it. Pushing this to our<a id="_idIndexMarker308"/> GitHub repository will ensure that all the tests have passed. We can merge the pull request if we want the code to be merged into our <code>main</code> branch. </p><p>We have<a id="_idIndexMarker309"/> seen from this example that continuous integration is useful. It has picked up a change in the code that we might not have noted if we were doing everything manually. </p></li>&#13;
			</ol>&#13;
			<p>Now that our tests run automatically, we need to automate keeping track of the version of our module to avoid making the same mistake we made with not updating our tests. </p>&#13;
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Create automatic versioning for our pip package</h2>&#13;
			<p>To <a id="_idIndexMarker310"/>automate the process of updating the version number, we are going to put several functions in the <code>get_latest_version.py</code> file in the root of our <code>pip</code> module. Following are the steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to import everything we need with the following code:<pre><code>os</code> and <code>pathlib</code> to manage writing the latest version to a file. We are also going to use the <code>requests</code> module to call PyPI to get the latest version that is currently available to the public. </p></li>&#13;
				<li>To do this, we can create a function that will get the metadata of our module from PyPI and return the version with the following code:<pre>def get_latest_version_number() -&gt; str:
    req = requests.get(
    "https://pypi.org/pypi/flitton-fib-py/json")
    return req.json()["info"]["version"]</pre></li>&#13;
				<li>This is just a<a id="_idIndexMarker311"/> simple web request. Once we have done this, we are going to want to unpack this string into a tuple of integers with the function defined next:<pre>def unpack_version_number(version_string: str) \
    -&gt; Tuple[int, int, int]:
    version_buffer: List[str] = \
      version_string.split(".")
    return int(version_buffer[0]),\
      int(version_buffer[1]),int(version_buffer[2])</pre><p>Here, we can see that this is a simple split via bullet points. We then convert them to integers and pack them into a tuple to be returned. </p></li>&#13;
				<li>Now that we have got our version number, we need to increase this by one with the function defined next:<pre>def increase_version_number(version_buffer: \
Union[Tuple[int, int, int], List[int]]) -&gt; List[int]:
    first: int = version_buffer[0]
    second: int = version_buffer[1]
    third: int = version_buffer[2]
    third += 1
    if third &gt;= 10:
        third = 0
        second += 1
        if second &gt;= 10:
            second = 0
            first += 1
    return [first, second, third]</pre><p>Here, we can see that if one of the integers is equal or greater than <code>10</code>, we set it back to <code>0</code> and increase the next number by <code>1</code>. The only one that does not get sent to <code>0</code> is the furthest number to the left. This will just keep going up.</p></li>&#13;
				<li>Now that we have <a id="_idIndexMarker312"/>increased our number by <code>1</code>, we will need to pack the integer into a string, with the function defined next:<pre>def pack_version_number(
    version_buffer: Union[Tuple[int, int, int], 
      List[int]]) -&gt; str:
    return f"{version_buffer[0]}.{version_buffer[1]} \ 
      .{version_buffer[2]}"</pre></li>&#13;
				<li>Once we have packed this into a string, we will have to write the version to a file. This can be done with the function defined next:<pre>def write_version_to_file(version_number: str) -&gt; \
None:
    version_file_path: str = str( \
    pathlib.Path(__file__).parent.absolute()) + \
    "/flitton_fib_py/version.py"
    if os.path.exists(version_file_path):
        os.remove(version_file_path)
    with open(version_file_path, "w") as f:
        f.write(f"VERSION='{version_number}'")</pre><p>Here, we can see that we ensure that the path is going to be at the root of our module. We then delete the version file if it already exists, as it will already be out of date. </p></li>&#13;
				<li>We then write<a id="_idIndexMarker313"/> our updated version number to the file with the following code:<pre>if __name__ == "__main__":
    write_version_to_file(
        version_number=pack_version_number(
            version_buffer=increase_version_number(
                version_buffer=unpack_version_number(
            version_string=get_latest_version_number()
                )
            )
        )
    )</pre><p>This ensures that if we run the file directly, we will get the updated version written to a file. </p></li>&#13;
				<li>Now, in our <code>setup.py</code> file at the root of our module, we must read the version file and define it for our version parameter in the <code>setup</code> initialization. For that, we first import <code>pathlib</code> into our file and read the version file with this code:<pre>import pathlib
with open(str(pathlib.Path(__file__).parent.absolute()) +
          "/flitton_fib_py/version.py", "r") as fh:
    version = fh.read().split("=")[1].replace("'", "")</pre></li>&#13;
				<li>We then set <a id="_idIndexMarker314"/>the <code>version</code> parameter with the read value with the following code:<pre>setup(
    name="flitton_fib_py",
    version=version,
    ...</pre></li>&#13;
			</ol>&#13;
			<p>We now have our version update process fully automated; we must plug this into our GitHub Actions, so we automatically run the update process and push to PyPI when merging with our <code>main</code> branch. </p>&#13;
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Deploying onto PyPI using GitHub Actions</h2>&#13;
			<p>To enable our GitHub <a id="_idIndexMarker315"/>actions to push to PyPI, we need to follow these steps:</p>&#13;
			<ol>&#13;
				<li value="1">First, we store the username and password for our PyPI account in the <strong class="bold">Secrets</strong> section of our GitHub repository. This can be done by clicking on the <strong class="bold">Settings</strong> tab and then the <strong class="bold">Secrets</strong> tab on the left sidebar, as shown here:<div><img src="img/Figure_4.09_B17720.jpg" alt="Figure 4.9 – View of the GitHub Secrets section&#13;&#10;" width="1321" height="648"/></div><p class="figure-caption">Figure 4.9 – View of the GitHub Secrets section</p></li>&#13;
				<li>On the top <a id="_idIndexMarker316"/>right of the view in <em class="italic">Figure 4.9</em> is <strong class="bold">New repository secret</strong>. If we click this, we will get the following screen:</li>&#13;
			</ol>&#13;
			<p>&#13;
				<p>&#13;
					<img src="img/Figure_4.10_B17720.jpg" alt="Figure 4.10 – View of the GitHub secret creation section&#13;&#10;" width="1205" height="745"/>&#13;
				</p>&#13;
			</p>&#13;
			<p class="figure-caption">Figure 4.10 – View of the GitHub secret creation section</p>&#13;
			<p>Here, we can create a <a id="_idIndexMarker317"/>secret for our PyPI password and another secret for our PyPI username. </p>&#13;
			<p>Now that we have our secrets defined, we can build our GitHub action in the <code>.github/workflows/publish-package.yml</code> file:</p>&#13;
			<ol>&#13;
				<li value="1">First, we need to ensure that we publish our package only when we have merged a branch with the <code>main</code> branch. To do this, we need to ensure that our action only executes when there's a pull request when it's closed, and the branch being pointed out is <code>main</code> with the following code:<pre>name: Publish Python <img src="img/Figure_4.11_B17720.png" alt="" width="32" height="31"/> distributions <img src="img/Figure_4.12_B17720.png" alt="" width="39" height="34"/> to PyPI
on:
  pull_request:
    types: [closed]
    branches:
      - main</pre></li>&#13;
				<li>Once this is <a id="_idIndexMarker318"/>done, we can define the basic jobs of installing the dependencies and updating the package version with <code>jobs</code>, defined in the following code:<pre>jobs:
  run-shell-command:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: update version
        run: python get_latest_version.py</pre><p>What we have done is fine so far. However, it will run when any pull request pointing to <code>main</code> is closed. Therefore, we must ensure that the pull request has merged before executing the step.</p></li>&#13;
				<li>For the next section, we install the dependencies with the following code:<pre>      - name: install deployment dependancies
        if: github.event.pull_request.merged == true
        run: |
          pip install twine
          pip install pexpect</pre></li>&#13;
				<li>We can see that <a id="_idIndexMarker319"/>our conditional statements are straightforward. We then run the <code>setup.py</code> file for it to produce our distribution with the following step:<pre>      - name: package module
        if: github.event.pull_request.merged == true
        run: python setup.py sdist</pre></li>&#13;
				<li>Now that we have defined all the steps needed to prepare our package, we can upload our package using <code>twine</code> with the following code:<pre>      - name: deploy to pypi
        if: github.event.pull_request.merged == true
        env:
          TWINE_USERNAME: ${{ secrets.TWINE_USERNAME 
            }}
          TWINE_PASSWORD: ${{ secrets.TWINE_PASSWORD 
            }}
        run: |
          twine upload dist/*</pre></li>&#13;
			</ol>&#13;
			<p>Here, we can see that we have automated the deployment of our module to PyPI using GitHub Actions.</p>&#13;
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>&#13;
			<p>In this chapter, we have managed to build a fully fledged <code>pip</code> Python module that has continuous integration. We initially set up a GitHub repository and created a virtual environment. This is an essential skill for most Python projects, and you should be using GitHub repositories and virtual environments even if your project is not a <code>pip</code> module. You will be able to share your project and work with other team members. We then defined our <code>setup.py</code> file so our code could be installed via <code>pip</code>. Even if our GitHub repository is private, people who have access to the GitHub repository could freely install our code. This gives us even more power when it comes to distributing our code. </p>&#13;
			<p>When we have an interface defined, our users do not need to know much about our code, just how to use the interface. This also enables us to prevent repeated code. For instance, if we build a user data model with a database driver, we can package it as a <code>pip</code> module and use this in multiple web applications. All we need to do is change the data model in the <code>pip</code> module and make a new release, and then all web applications can use the updated version if they wish. </p>&#13;
			<p>Once our code was packaged, we rebuilt our Fibonacci code in our <code>pip</code> module, and it worked. We then went further, building entry points that enabled us to define our own command-line tools. This makes our code packaging even more powerful, as the user doesn't even have to import and code the module; they can just call the command-line argument! With this, we can build development tools to speed up our development by automating tasks with these entry points. We then built basic unit tests to ensure that the quality of our code was maintained. We then locked in these good standards with automation pipelines using GitHub Actions. We introduced type-checking with <code>mypy</code> alongside our unit-testing pipeline. We don't have to stop here. For instance, the Python script that we coded that increased the version number by one could be built in its own <code>pip</code> repository with a command-line interface. With this, we could install the module using <code>pip install</code> in our GitHub Actions and run the commands. Now, with this code packaging, you can build your own tools and add them to your belt, reducing the amount of repetition in your daily coding as time goes on. </p>&#13;
			<p>In the next chapter, we cover what we have done in this chapter in Rust. Considering this, we harness the safety and speed of Rust, with the flexibility of <code>pip</code> packaging. Utilizing this will level up your skills as a Python toolmaker, making you invaluable to your team.</p>&#13;
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Questions</h1>&#13;
			<ol>&#13;
				<li value="1">How would you perform an installation with <code>pip install</code> of our GitHub repository on the <code>test</code> branch?</li>&#13;
				<li>Can other developers who do not have access to your GitHub repository install your <code>pip</code> package if you upload it to PyPI?</li>&#13;
				<li>What is the difference between development dependencies and package dependencies?</li>&#13;
				<li><code>mypy</code> ensures the consistency of types when it comes to our Python code. How is this different from type-checking in Rust?</li>&#13;
				<li>Why should we automate boring repetitive tasks?</li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Answers</h1>&#13;
			<ol>&#13;
				<li value="1"><code>pip install git+https://github.com/maxwellflitton/flitton-fib-py@test  </code></li>&#13;
				<li>Yes, they can download it despite not having access to your GitHub repository. If we think about it, we package our <code>pip</code> module in a file and then upload it to the PyPI server. Downloading our package from the PyPI server is not connected to our GitHub repository.</li>&#13;
				<li>Development dependencies are specific dependencies defined in the <code>requirements.txt</code> file. This ensures that developers can work on the <code>pip</code> package. Package requirements are a little more relaxed and defined in the <code>setup.py</code> file. These get installed when the user installs our package. Package requirements are to enable the <code>pip</code> package to be used.</li>&#13;
				<li>Rust does the type-checking when it is compiling and fails to compile if the types are inconsistent. Because of this, we cannot run it. Python, however, is an interpreted language. Because of this, we can still run it with the potential errors. </li>&#13;
				<li>Repetitive tasks are easy to automate, so the effort invested is not excessive. Also, repetitive tasks have a higher risk of producing errors. Automating these tasks reduces the number of errors we could make. </li>&#13;
			</ol>&#13;
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Further reading</h1>&#13;
			<ul>&#13;
				<li><em class="italic">Python Organisation (2021) Packaging code</em>: <a href="https://packaging.python.org/guides/distributing-packages-using-setuptools/">https://packaging.python.org/guides/distributing-packages-using-setuptools/</a></li>&#13;
				<li> <em class="italic">GitHub Organisation (2021) GitHub Actions</em>: <a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>