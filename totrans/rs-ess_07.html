<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Organizing Code and Macros</h1></div></div></div><p>We start this chapter by discussing the large-scale code-organizing structures in Rust, namely modules and crates. We will look at the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Building crates</li><li class="listitem">Defining a module</li><li class="listitem">Visibility of items</li><li class="listitem">Importing modules and file hierarchy</li><li class="listitem">Importing external crates</li><li class="listitem">Exporting a public interface</li><li class="listitem">Adding external crates to a project</li><li class="listitem">The test module</li></ul></div><p>We will also touch upon how to build macros in order to generate code and save time and effort, particularly in these topics:</p><div><ul class="itemizedlist"><li class="listitem">The reason for using macros</li><li class="listitem">Developing macros</li><li class="listitem">Using macros from crates</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Modules and crates</h1></div></div></div><p>Until now, we only<a id="id231" class="indexterm"/> looked at the situation <a id="id232" class="indexterm"/>where our code fitted in one file. However, when a project evolves, we will want to split the code across several files, for example, if we put all the data structures and methods that describe a certain functionality in the same file, how will the main code file be able to call these functions in other files? </p><p>In addition, when we start using multiple functions in varied files, it sometimes happens that we want to use the same name for two different functions. How can we properly differentiate between such functions? How can we make it so that some functions are callable everywhere and others are not? For this, we need what other languages call namespaces and access modifiers; in Rust, this is done through the module system.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec26"/>Building crates</h2></div></div></div><p>At the highest level of <a id="id233" class="indexterm"/>building crates, there is the crate. The Rust distribution contains a number of crates, such as the <code class="literal">std</code> crate of the standard library, which we have already used often. Other built-in crates are the <code class="literal">collections</code> crate, with the functionality to work with strings, vectors, lists, and key-value maps, and the <code class="literal">test</code> crate, with unit-testing and micro-benchmarking functionalities.</p><p>A crate is the equivalent of a package or library in other languages. It is also the unit of compilation; <code class="literal">rustc</code> only compiles one crate at a time. What does this mean? When our project has a code file containing a <code class="literal">main()</code> function, then it is clear that our project is an executable program (which is also called a binary) that starts execution in <code class="literal">main()</code>. For example, if we compile <code class="literal">structs.rs</code> as <code class="literal">rustc structs.rs, a .exe</code> file <code class="literal">structs.exe</code> will be produced in Windows (and equivalent formats on other operating systems) that can be executed on its own. This is the standard behavior when you invoke <code class="literal">rustc</code>. When working with Cargo (refer to <a class="link" title="Chapter 1. Starting with Rust" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <em>Starting with Rust</em>), we have to indicate that we want a binary project at its creation with the <code class="literal">--bin</code> flag: <code class="literal">cargo new projname --bin</code>.</p><p>However, often your intention is to write a project whose code will be called from other projects, a so-called shared library (this is a <code class="literal">.dll</code> file in Windows, a <code class="literal">.so</code> file in Linux, and a <code class="literal">.dylib</code> file in Mac OS X.) In this case, your code will only contain the data structures and functions to work on them. Then, you must explicitly indicate this to the compiler using the <code class="literal">--crate-type</code> flag with the <code class="literal">lib</code> option:<code class="literal"> rustc --crate-type=lib  structs.rs</code>.</p><p>The resulting file is far smaller in size and is called <code class="literal">libstructs.rlib</code>; the suffix is now <code class="literal">.rlib</code> (for the Rust library) and <code class="literal">lib</code> is prepended before the filename. If you want the crate to have another name such as <code class="literal">mycrate</code>, then use the <code class="literal">--crate-name</code> flag as follows:</p><p>
<code class="literal">rustc --crate-type=lib  --crate-name=mycrate  structs.rs</code>
</p><p>This creates a <code class="literal">libmycrate.rlib</code> as the output file. An alternative to using the <code class="literal">rustc</code> flags is to put this information as an attribute at the top of the code file, as follows:</p><div><pre class="programlisting">// from Chapter 7/code/structs.rs
#![crate_type = "lib"] 
#![crate_name = "mycrate"]</pre></div><p>The <code class="literal">crate_type</code> attribute can take the <code class="literal">bin</code>, <code class="literal">lib</code>, <code class="literal">rlib</code>, <code class="literal">dylib</code>, or <code class="literal">staticlib</code> values, according to whether you want an executable binary or a library of a certain type that is dynamic or statically linked. (In general, when an <code class="literal">attr</code> attribute applies to a whole crate, the syntax to use in the code is <code class="literal">#![crate_attr]</code>.)</p><p>Each library used in an application is a separate crate. In any case, you need an executable (binary) crate that uses the library crates.</p><p>Cargo's job is to handle crates (for more information on Cargo, refer to the <em>Working with Cargo</em> section of <a class="link" title="Chapter 1. Starting with Rust" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <em>Starting with Rust</em>); it creates a library project by default. You can install other crates<a id="id234" class="indexterm"/> into your project from the crates repository at <a class="ulink" href="https://crates.io">https://crates.io</a>; in the <em>Adding external crates to a project</em> section of this chapter, we will see how this is done.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec27"/>Defining a module</h2></div></div></div><p>Crates are the compiled entities that <a id="id235" class="indexterm"/>get distributed on machines to execute. All of the code of a crate is contained in an implicit root module. This code can then be split up by the developer into code units called modules, which in fact, form a hierarchy of submodules under the root module. This way the organization of our code can be greatly improved. An evident candidate for a module is the test code—we'll use this in the <em>The test module</em> section.</p><p>Modules can also be defined inside other modules as the so-called nested modules. Modules do not get compiled individually; only crates get compiled. All the module's code is inserted into the crate's source file before compilation starts.</p><p>In the previous chapters, we used built-in modules, such as <code class="literal">io</code>, <code class="literal">str</code>, and <code class="literal">vec</code> from the <code class="literal">std</code> crate. The <code class="literal">std</code> crate contains many modules and functions that are used in real projects; the most common types, traits, functions, and macros (such as <code class="literal">println!</code>) are declared in the prelude module.</p><p>A module typically contains a collection of code items such as traits, structs, methods, other functions, and even nested modules. The module's name defines a namespace for all the objects that it contains. We define a module with the <code class="literal">mod</code> keyword and a lowercase name (such as <code class="literal">game1</code>) as follows:</p><div><pre class="programlisting">mod game1 {
  // all of the module's code items go in here
}</pre></div><p>Similar as in Java each file is a module, for every code file the compiler defines an implicit module, even when it does not contain the <code class="literal">mod</code> keyword. As we will see in the <em>Importing modules and file hierarchy</em> section, such a code file can be imported into the current code file with <code class="literal">mod</code> filename. Suppose <code class="literal">game1</code> is the name of a module that contains a <code class="literal">func2</code> function. If you want to use this function in a code that is external to this module, you would address it as <code class="literal">game1::func2</code>. However, whether this is possible will depend on the visibility of <code class="literal">func2</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec28"/>The visibility of items</h2></div></div></div><p>Items in a <a id="id236" class="indexterm"/>module are by default, only visible in the module itself; they are private to the module. If you want to make an item callable from a code that is external to the module, you must explicitly indicate this by prefixing the item with <code class="literal">pub</code> (which stands for public). In the following code, trying to call <code class="literal">func1()</code> is not allowed by the compiler: <code class="literal">error: function `func1` is private:</code>.</p><div><pre class="programlisting">// from Chapter 7/code/modules.rs
mod game1 {
    // all of the module's code items go in here
    fn func1() {
      println!("Am I visible?");
    }
    pub fn func2() {
      println!("You called func2 in game1!");
    }
}

fn main() {
  // game1::func1(); // &lt;- error!
  game1::func2();
}</pre></div><p>However, if you call <code class="literal">func2()</code>, it will work without any problem because it is public, and this prints out: <code class="literal">You called func2 in game1!</code>
</p><p>A function in a nested module can only be called if it is public, provided the nested module itself is declared public, as shown in this code snippet:</p><div><pre class="programlisting">mod game1 {
   // other code
    pub mod subgame1 {
      pub fn subfunc1() {
        println!("You called subfunc1 in subgame1!");
      }
    }
}

fn main() {
  // other code
  game1::subgame1::subfunc1();
}</pre></div><p>It prints out: <code class="literal">You called subfunc1 in subgame1!</code>
</p><p>A function in a module must be prefixed with its module name when it is called. This distinguishes it from another function with the same name so that no name conflicts occur.</p><p>When a struct is <a id="id237" class="indexterm"/>accessed from outside the module in which it is defined, it is only visible when it is declared with <code class="literal">pub</code>. Moreover, its fields are private by default, so you have to explicitly declare as <code class="literal">pub</code> the fields that you want to be visible outside. This is the encapsulation property (also called information hiding) from traditional object-oriented languages. In the following example, the name and age fields of the <code class="literal">Magician</code> struct belong to the public interface but <code class="literal">power</code> does not:</p><div><pre class="programlisting">    pub struct Magician {
        pub name: String,
        pub age: i32,
        power: i32
    }</pre></div><p>So this statement:</p><div><pre class="programlisting">let mag1 = game1::Magician { name: "Gandalf".to_string(), age: 725, power: 98};</pre></div><p>This leads to the compiler error: <code class="literal">field 'power' of struct 'game1::Magician' is private</code>
</p><p>Perform the following exercise:</p><p>Does this mean that we cannot make instances from a struct with private fields? Try to think of a way around this. (As a hint, think about a constructor-like <code class="literal">new</code> function; refer to <code class="literal">Chapter 7/code/priv_struct.rs</code>.)</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec29"/>Importing modules and file hierarchy</h2></div></div></div><p>The <code class="literal">use</code> <a id="id238" class="indexterm"/>keyword in <code class="literal">use game1::func2;</code> imports a <code class="literal">func2</code> function from the <code class="literal">game1</code> <a id="id239" class="indexterm"/>module so that it can be simply called with its name, <code class="literal">func2()</code>. You can even give it a shorter name with <code class="literal">use game1::func2</code> as <code class="literal">gf2</code>; so that it can be called as <code class="literal">gf2()</code>.</p><p>When the <code class="literal">game1</code> module contains two (or more) functions such as <code class="literal">func2</code> and <code class="literal">func3</code> that we want to import, this can be done with <code class="literal">use game1::{func2, func3};</code>.</p><p>If you want to import all the (public) functions of the <code class="literal">game1</code> module, you can do it with <code class="literal">*</code>:<code class="literal"> use game1::*;</code>.</p><p>However, using such a global import is not the best practice, except in modules for testing. The main reason for this is that a global import makes it harder to see where names are bound. Furthermore, they are forwards-incompatible, since new upstream exports can clash with existing names.</p><p>Inside a module, <code class="literal">self::</code> and <code class="literal">super::</code> can be prepended to a path similar to <code class="literal">game1::func2</code> to distinguish between a function in the current module itself and a function in the parent scope, outside of the module. The <code class="literal">use</code> statements are preferably written at the top of the code file, so that they work for the whole of the code.</p><p>In the previous example, the module was defined in the main source file itself; in most cases, a module will be defined in another source file. So, how do we import such modules? In Rust, we can insert the entire contents of a module's source file into the current file by declaring the module at the top of the code (but after any <code class="literal">use</code> statements) like this: <code class="literal">mod modul1;</code>, this can be optionally preceded by <code class="literal">pub</code>. This statement will look for a <code class="literal">modul1.rs</code> file in the same folder as the current source file and import its code within the current code inside a <code class="literal">modul1</code> module. If a <code class="literal">modul1.rs</code> file is not found, it will look for a <code class="literal">mod.rs</code> file in the <code class="literal">modul1</code> subfolder and insert its code.</p><p>Here is a<a id="id240" class="indexterm"/> simple <code class="literal">import_modules.rs</code> example that contains the following code:</p><div><pre class="programlisting">// from Chapter 7/code/import_modules.rs
<strong>mod modul1;</strong>
<strong>mod modul2;</strong>
fn main() {
  modul1::func1();
  modul2::func1();
}</pre></div><p>In the <code class="literal">modul1</code> subfolder, we have the <code class="literal">mod.rs</code> file that contains the following code snippet:</p><div><pre class="programlisting">pub fn func1() {
    println!("called func1 from modul1");
}</pre></div><p>The <code class="literal">modul2.rs</code> file in the same folder as <code class="literal">import_modules.rs</code> contains the following code:</p><div><pre class="programlisting">pub fn func1() {
    println!("called func1 from modul2");
}</pre></div><div><h3 class="title"><a id="note08"/>Note</h3><p>Note that these source files of the module don't contain the <code class="literal">mod</code> declaration anymore because they were already declared in <code class="literal">import_modules.rs</code>.</p></div><p>Executing <code class="literal">import_modules</code> prints out the following output: <code class="literal">called func1 from modul1 and called func1 from modul2</code>.</p><p>What <a id="id241" class="indexterm"/>happens if you simply call <code class="literal">func1()</code> in <code class="literal">main()</code>? Now, the compiler doesn't know which <code class="literal">func1</code> to call, from <code class="literal">modul1</code> or from <code class="literal">modul2</code>, resulting in the error: <code class="literal">unresolved name 'func1'</code> message. However, if we add <code class="literal">use modul1::func1</code> and then call <code class="literal">func1()</code>, it will work as the ambiguity is resolved.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec30"/>Importing external crates</h2></div></div></div><p>In the <em>Traits</em> section of <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <em>Generalizing Code with Higher-order Functions and Parametrization</em>, we <a id="id242" class="indexterm"/>developed the <code class="literal">traits.rs</code> structs for <code class="literal">Alien</code>, <code class="literal">Zombie</code>, and <code class="literal">Predator</code> characters that implemented a <code class="literal">Monster</code> trait. The code file contained a <code class="literal">main()</code> function to make it executable. We will now incorporate this code (without the <code class="literal">main()</code> part) in a library project called monsters and see how we can call this code.</p><p>Create the project with cargo new monsters and create a folder structure in the  <code class="literal">monsters/src/lib.rs</code> file with the <code class="literal">template</code> code:</p><div><pre class="programlisting">#[test]
fn it_works() {
}</pre></div><p>Remove this code and replace it with the code from <code class="literal">traits.rs</code>, but omit the <code class="literal">main()</code> function. In addition, add a simple <code class="literal">print_from_monsters()</code> function to test whether you can call it from the library:</p><div><pre class="programlisting">// from Chapter 7/code/monsters/src/lib.rs:
fn print_from_monsters() {
  println!("Printing from crate monsters!");
}</pre></div><p>Then, compile the library with cargo build, producing a <code class="literal">libmonsters-hash.rlib</code> library file in the <code class="literal">target</code>/<code class="literal">debug</code> folder (where hash is a random string similar to <code class="literal">547968b7c0a4d435</code>).</p><p>Now, we create a <code class="literal">main.rs</code> file in the <code class="literal">src</code> folder to make an executable file that can call into our <code class="literal">monsters</code> library and copy the original <code class="literal">main()</code> code from <code class="literal">traits.rs</code> in it, adding a call to <code class="literal">print_from_monsters()</code>:</p><div><pre class="programlisting">// from Chapter 7/code/monsters/src/main.rs:
fn main() {
  print_from_monsters();
  let zmb1 = Zombie {health: 75, damage: 15};
  println!("Oh no, I hear: {}", zmb1.noise());
  zmb1.attack();
  println!("{:?}", zmb1);
}</pre></div><div><h3 class="title"><a id="note09"/>Note</h3><p>This is a common design pattern—a library project containing an executable program that can be used to demonstrate or test the library.</p></div><p>The <code class="literal">cargo build</code> function will now compile both the projects if there are no problems. However, the code will not compile, and the compiler will give the error: <code class="literal">unresolved name 'print_from_monsters'</code> message, clearly the code for the function is not found.</p><p>The first thing that we have to do is make the library code available to our program, which can be done by placing the following statement at the start:</p><div><pre class="programlisting">
<strong>extern crate monsters; </strong>
</pre></div><p>This statement will <a id="id243" class="indexterm"/>import all the (public) items contained in the crate monsters under a module with the same name. However, this is not enough; we must also indicate that the <code class="literal">print_from_monsters</code> function can be found in the <code class="literal">monsters</code> module. Indeed, the monsters crate creates an implicit module with the same name. So, we have to call our function as follows:</p><div><pre class="programlisting">
<strong>monsters::print_from_monsters();</strong>
</pre></div><p>Now, we get the error: <code class="literal">function 'print_from_monsters' is private</code> message, which tells us that the function is found, but it is inaccessible. This is easy to fix. In the <em>Visibility of Items</em> section, we saw how to remedy this; we must prefix the function header with <code class="literal">pub</code>, as follows:</p><div><pre class="programlisting">
<strong>pub fn print_from_monsters() { … }</strong>
</pre></div><p>Now, this part of our code works! Open a terminal, go (<code class="literal">cd</code>) to the <code class="literal">target/debug</code> folder and start the monsters executable. This will give the output as <code class="literal">Printing from crate monsters!</code>.</p><p>You will see that <code class="literal">extern crate abc</code> (with <code class="literal">abc</code> a crate name) is often used in code, but you will never see <code class="literal">extern crate std;</code> why does this happen? The reason is that <code class="literal">std</code> is imported by default in every other crate. For the same reason, the contents of the prelude module are imported by default in to every module.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec31"/>Exporting a public interface</h2></div></div></div><p>The compiler <a id="id244" class="indexterm"/>throws the following error at us: <code class="literal">error: Zombie does not name a structure</code>. Clearly, the code for the <code class="literal">Zombie</code> struct is not found. Since this struct also resides in the monsters module, the solution to fix this is easy; prefix <code class="literal">Zombie</code> with <code class="literal">monsters::</code> as follows:</p><div><pre class="programlisting">
<strong>let zmb1 = monsters::Zombie {health: 75, damage: 15}; </strong>
</pre></div><p>Another error: <code class="literal">struct 'Zombie' is private</code>, makes it clear that we must mark the <code class="literal">Zombie</code> struct with <code class="literal">pub</code>, that is, <code class="literal">pub struct Zombie { … }</code>.</p><p>Now, we will get an error on the line that contains <code class="literal">zmb1.noise()</code>: <code class="literal">error: type 'monsters::Zombie'</code> does not implement any method in scope named <code class="literal">'noise'</code>
</p><p>The accompanying help note explains to us what to do and why we should do it:<code class="literal"> help: methods from traits can only be called if the trait is in scope; the following trait is implemented but not in scope, perhaps add a `use` for it:</code>
</p><p>
<code class="literal">help: candidate #1: use 'monsters::Monster'</code>. So, let's add this to the following code:</p><div><pre class="programlisting">extern crate monsters;
<strong>use monsters::Monster;</strong>
</pre></div><p>The last error—<code class="literal">error: trait 'Monster' is private - source trait is private</code>— that we have to solve occurs at the <code class="literal">use</code> line. Again very logical; if we want to use a trait, it must be publicly visible: <code class="literal">p</code>
<code class="literal">ub trait Monster { … }</code>.</p><p>Now, cargo build is <a id="id245" class="indexterm"/>successful, if we execute monsters the output will be as follows:</p><div><pre class="programlisting">Printing from crate monsters!
Oh no, I hear: Aaargh!
The Zombie bites! Your health lowers with 30 damage points.
Zombie { health: 75, damage: 15 }</pre></div><p>This makes it clear that the things we want to make visible in our module (or put in another way, that we want to export) must be annotated with <code class="literal">pub</code>; they form the interface that our module exposes to the outside world.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec32"/>Adding external crates to a project</h2></div></div></div><p>How to use libraries<a id="id246" class="indexterm"/> written by others (that is, choose from the multitude of libraries <a id="id247" class="indexterm"/>available at <a class="ulink" href="https://crates.io">https://crates.io</a>) in our <a id="id248" class="indexterm"/>project? Cargo makes this very easy.</p><p>Suppose we want to use both the <code class="literal">log</code> and the <code class="literal">mac</code> libraries in the monsters project. The <code class="literal">log</code> function is a simple logging framework by the Rust Project Developers that gives us a number of macros such as <code class="literal">info!</code>, <code class="literal">warn!</code>, and <code class="literal">trace!</code> to log information messages. The <code class="literal">mac</code> function is an amazing collection of useful macros, which is maintained by Jonathan Reem.</p><p>To get these libraries, we need to edit our <code class="literal">Cargo.toml</code> configuration file and add a <code class="literal">[dependencies]</code> section when it isn't already present. Beneath it, we specify the versions of the libraries that we want to use:</p><div><pre class="programlisting">[dependencies]
log = "0.2.5"
mac = "*"</pre></div><p>A <code class="literal">*</code> character denotes that any version is okay, and the most recent version will be installed.</p><p>Save the file and, in the <code class="literal">monsters</code> folder, issue the <code class="literal">cargo build</code> command. Cargo will take care of locally installing and compiling the libraries:</p><div><img src="img/image00182.jpeg" alt="Adding external crates to a project"/></div><p style="clear:both; height: 1em;"> </p><p>It will also automatically<a id="id249" class="indexterm"/> update the <code class="literal">Cargo.lock</code> file to register the <a id="id250" class="indexterm"/>installed versions of the libraries so that subsequent project builds will always use the same versions (here, <code class="literal">log v0.3.1</code> and <code class="literal">mac v0.0.1</code>). If you later want to update to the most recent version of a library, for example for the <code class="literal">log</code> library, do a cargo update <code class="literal">–p log</code> or a <code class="literal">cargo</code> update to update all libraries. This will download the latest crate versions for the crates that are indicated with the <code class="literal">*</code> version. If you want a higher version for a crate, change its version number in <code class="literal">Cargo.toml</code>.</p><p>Start using the libraries by importing their crates in the code:</p><div><pre class="programlisting">
<strong>#[macro_use]</strong>
<strong>extern crate log;</strong>
<strong>extern crate mac;</strong>
</pre></div><p>The <code class="literal">#[macro_use]</code> attribute allows the use of macros defined in the external crate. (See the next section for more information). Then, we can for example, use the <code class="literal">info!</code> macro from <code class="literal">crate mac</code> as follows:</p><div><pre class="programlisting">info!("Gathering information from monster {:?}", zmb1);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec33"/>The test module</h2></div></div></div><p>Let's apply this code organization to a <a id="id251" class="indexterm"/>module that contains our tests. In a larger project, tests are separated from the application code as follows:</p><div><ul class="itemizedlist"><li class="listitem">Unit tests are collected in a <code class="literal">test</code> module</li><li class="listitem">Integration tests are collected in a <code class="literal">lib.rs</code> file in a <code class="literal">tests</code> directory</li></ul></div><p>Let's make a concrete example by using our <code class="literal">cube</code> function from <a class="link" title="Chapter 3. Using Functions and Control Structures" href="part0032.xhtml#aid-UGI01">Chapter 3</a>, <em>Using Functions and Control Structures</em>, and start its project with cargo new cube. We must replace the code in <code class="literal">src\lib.rs</code> with this:</p><div><pre class="programlisting">  // from Chapter 7/code/cube/src/lib.rs:
<strong>#[cfg(test)]</strong>
<strong>mod test;</strong>
pub fn cube(val: u32) -&gt; u32 {
    // implementation goes here
    val * val * val
}</pre></div><p>
<code class="literal">#[cfg(test)]</code> ensures that the test module is only compiled when testing. In the second line, we declare our <code class="literal">test</code> module, which is preceded by the <code class="literal">test</code> attribute. The code of this module goes into a <code class="literal">test.rs</code> file in the same folder:</p><div><pre class="programlisting">// from Chapter 7/code/cube/src/test.rs:
<strong>use super::*;</strong>
#[test]
fn cube_of_2_is_8() {
     assert_eq!(cube(2), 8);
}
// other test functions:
// ...</pre></div><p>We need to use <code class="literal">super::*</code> to import all the functions that need to test; here, this is cube.</p><p>Integration tests go into a <code class="literal">lib.rs</code> file in a tests folder:</p><div><pre class="programlisting">// from Chapter 7/code/cube/tests/lib.rs:
<strong>extern crate cube;</strong>
#[test]
fn cube_of_4_is_64() {
    assert_eq!(cube::cube(4), 64);
}
// other test functions:
// ...</pre></div><p>Here, we need to import the <code class="literal">cube</code> crate <a id="id252" class="indexterm"/>with an <code class="literal">extern</code> command and qualify the <code class="literal">cube</code> function name with its module name, <code class="literal">cube</code> (or else do a <code class="literal">use cube::cube;</code>).</p><p>The test code will only be compiled and run when we give the <code class="literal">cargo test</code> command, which will give these results:</p><div><img src="img/image00183.jpeg" alt="The test module"/></div><p style="clear:both; height: 1em;"> </p><p>We can see that our two tests <a id="id253" class="indexterm"/>passed. The end of the output also shows that tests in the documentation are also executed if they are present.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Macros</h1></div></div></div><p>Macros <a id="id254" class="indexterm"/>are not new to you as we have already used them. Every time we called an expression that ended with an exclamation mark (<code class="literal">!</code>), we called a built-in macro; the <code class="literal">!</code> sign distinguishes it from a function. In our code until now, we have already used <code class="literal">println!</code>, <code class="literal">assert_eq!</code>, <code class="literal">panic!</code>, and <code class="literal">vec!</code> macros.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec34"/>Why do we use macros?</h2></div></div></div><p>Macros make <a id="id255" class="indexterm"/>powerful language or syntax extensions; therefore, they make metaprogramming possible. For example, Rust has a <code class="literal">regex!</code> macro that allows you to define regular expressions in your program, which are compiled while your code is compiled. This way the regular expressions are verified, they can be optimized at compile time, and there is no runtime overhead.</p><p>Macros can capture repetitive or resembling code patterns and replace them with other source code: the macro expands the original code into new code. This expansion happens early in compilation, before any static checking is done, so the resulting code is compiled together with the original code. In this sense, they resemble Lisp macros much more than C macros. Rust macros allow you to write <a id="id256" class="indexterm"/>
<strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) code by factoring out the common parts of functions. However, a macro is at a higher level than a function because a macro allows you to generate the code for many functions at compile time.</p><p>A Rust developer can also write his/her own macros, replacing repetitive code with much simpler code and thereby automating tasks. On the other side of the spectrum, it could even make it possible to write domain-specific languages. Macro coding follows a specific set of declarative pattern-based rules. Rust's macro system is also hygienic, which means that no conflict is possible between the variables used in the macro and those outside the macro. Each <a id="id257" class="indexterm"/>macro expansion happens in a distinct syntax context, and each variable is tagged with the syntax context where it was introduced.</p><p>Macro code itself is harder to understand than normal Rust code, so it is not that easy to make. However, you won't code macros every day; if a macro is tested, just use it. The full story of macro writing extends into advanced regions of Rust, but in the following sections, we will discuss the basic techniques to develop macros.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec35"/>Developing macros</h2></div></div></div><p>The basic structure of a macro <a id="id258" class="indexterm"/>definition for a macro with the <code class="literal">mac1</code> name is of the following form:</p><div><pre class="programlisting">
<strong>macro_rules! mac1 {</strong>
  (pattern) =&gt; (expansion);
  (pattern) =&gt; (expansion);
...
<strong>}</strong>
</pre></div><p>The definition of a macro is also done through a macro, that is, the <code class="literal">macro_rules</code> macro! As you can see a macro is similar to a match block as it defines one or more rules for pattern matching, and each rule ends with a semicolon. Every rule consists of a pattern before the <code class="literal">=&gt;</code> sign (which also called a matcher) that is replaced with the expansion part during compilation, and not while executing the code.</p><p>The following <code class="literal">welcome!</code> macro expects no pattern and expands into a print statement by using the <code class="literal">println!</code> macro; this is simple, but it demonstrates how macros work:</p><div><pre class="programlisting">// from Chapter 7/code/macros.rs
macro_rules! welcome {
    () =&gt; (
        println!(""Welcome to the Game!");
    )
}</pre></div><p>It is invoked by adding an exclamation sign (<code class="literal">!</code>) to its name:</p><div><pre class="programlisting">fn main() {
<strong>  welcome!()  </strong>
}</pre></div><p>This prints out: <code class="literal">Welcome to the Game!</code>.</p><p>A matcher can contain an expression of the <code class="literal">$arg:frag</code> form:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">$arg</code> function binds an <code class="literal">arg</code> meta-variable to a value when the macro is called. Variables used inside a macro such as <code class="literal">$arg</code>, are prefixed with a <code class="literal">$</code> sign to distinguish them <a id="id259" class="indexterm"/>from normal variables in the code.</li><li class="listitem">The <code class="literal">frag</code> function is a <em>fragment specifier</em> and can be either <code class="literal">expr</code>, <code class="literal">item</code>, <code class="literal">block</code>, <code class="literal">stmt</code>, <code class="literal">pat</code>, <code class="literal">ty</code> (type), <code class="literal">ident</code>, <code class="literal">path</code>, or <code class="literal">tt</code>.</li></ul></div><p>(You can find more<a id="id260" class="indexterm"/> information on the meaning of these fragments in the official documentation at <a class="ulink" href="http://doc.rust-lang.org/1.0.0/book">http://doc.rust-lang.org/1.0.0/book</a>.)</p><p>Any other Rust literals (tokens) that appear in a matcher must match exactly. For example, the following <code class="literal">mac1</code> macro:</p><div><pre class="programlisting">macro_rules! mac1 {
<strong>    ($arg:expr) =&gt; (println!("arg is {}", $arg));</strong>
}</pre></div><p>When you call <code class="literal">mac1!(42);</code>, it will print out <code class="literal">arg is 42</code>. The <code class="literal">mac1</code> function looks at its argument, <code class="literal">42</code>, as an expression (<code class="literal">expr</code>) and binds <code class="literal">arg</code> to the value.</p><p>Perform the following exercises:</p><div><ul class="itemizedlist"><li class="listitem">Write a <code class="literal">mac2</code> macro that triples its argument. Test it out for these arguments: 5 and 2 + 3.</li><li class="listitem">Write a <code class="literal">mac3</code> macro that takes an identifier name and replaces it with a binding of that name to 42. (As a hint, use <code class="literal">$arg:ident</code> instead of <code class="literal">$arg:expr; ident</code> is used for variable and function names.)</li><li class="listitem">Write a <code class="literal">mac4</code> macro that when invoked like <code class="literal">mac4!("Where am I?");</code>, prints out <code class="literal">start - Where am I? - end</code>. (Refer to the example code in <code class="literal">Chapter 7/exercises/macro_ex.rs</code>.)</li></ul></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec06"/>Repetition</h3></div></div></div><p>What would we do if there <a id="id261" class="indexterm"/>is more than one argument? We will enclose the pattern with a <code class="literal">$(...)*</code>, where <code class="literal">*</code> means zero or more (instead of <code class="literal">*</code>, you can use <code class="literal">+</code>, which  means one or more). For example, the following <code class="literal">printall</code> macro invokes <code class="literal">println!</code> on each of its arguments, which can be of the arbitrary type and are separated by <code class="literal">a</code>:</p><div><pre class="programlisting">macro_rules! printall {
<strong>  ( $( $arg:expr ), * ) =&gt; ( {$( print!("{} / ", $arg) ); *} );</strong>
}</pre></div><p>When called with <code class="literal">printall!("hello", 42, 3.14);</code> it will print out: <code class="literal">hello / 42 / 3.14 /</code>.</p><p>In the example, each <a id="id262" class="indexterm"/>argument (separated by commas) is substituted by a corresponding invocation of <code class="literal">print!</code> that is separated by a <code class="literal">/</code>. Note that on the right-hand side, we have to make a code block of the resulting print statements by enclosing them in <code class="literal">{  }</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec07"/>Creating a new function</h3></div></div></div><p>Here is a <code class="literal">create_fn</code> macro to create a new <a id="id263" class="indexterm"/>function at compile time:</p><div><pre class="programlisting">macro_rules! create_fn {
    ($fname:ident) =&gt; (
        fn $fname() {
          println!("Called the function {:?}()", stringify!($fname))
        }
    )
}</pre></div><p>The <code class="literal">stringify!</code> macro simply makes a string from its argument. Now, we can invoke this macro with <code class="literal">create_fn!(fn1);</code>. This statement does not sit inside <code class="literal">main()</code> or another function; it is transformed during compilation into the function definition. Then, a normal call to the <code class="literal">fn1()</code> function will call it, here printing <code class="literal">Called the function "fn1"()</code>.</p><p>In the following <code class="literal">massert</code> macro, we mimic the behavior of the <code class="literal">assert!</code> macro, which does nothing when its expression argument is true but panics when it is false:</p><div><pre class="programlisting">macro_rules! massert {
    ($arg:expr) =&gt; (
            if $arg {}
            else { panic!("Assertion failed!"); }
    );
}</pre></div><p>For example, <code class="literal">massert!(1 == 42);</code> will print out <code class="literal">thread '&lt;main&gt;' panicked at 'Assertion failed!'</code>.</p><p>In the following statements, we test whether the <code class="literal">v</code> vector contains certain elements:</p><div><pre class="programlisting">    let v = [10, 40, 30];
    massert!(v.contains(&amp;30));
    massert!(!v.contains(&amp;50));</pre></div><p>The <code class="literal">unless</code> macro mimics an <code class="literal">unless</code> statement where a branch is executed if the <code class="literal">arg</code> condition is not true. For example:</p><div><pre class="programlisting">  unless!(v.contains(&amp;25), println!("v does not contain 25"));</pre></div><p>This should print out <code class="literal">v does not contain 25</code> because the condition is not true.</p><p>This is also a one-line macro:</p><div><pre class="programlisting">macro_rules! unless {
    ($arg:expr, $branch:expr) =&gt; ( if !$arg { $branch }; );
}</pre></div><p>The last example combines the<a id="id264" class="indexterm"/> techniques that we have seen so far. In the <em>Attributes - Testing</em> section of <a class="link" title="Chapter 3. Using Functions and Control Structures" href="part0032.xhtml#aid-UGI01">Chapter 3</a>, <em>Using Functions and Control Structures</em>, we saw how to make a test function with the <code class="literal">#[test]</code> attribute. Let us create a <code class="literal">test_eq</code> macro that generates a test function when it is invoked with this:</p><div><pre class="programlisting">   test_eq!(seven_times_six_is_forty_two, 7 * 6, 42);</pre></div><p>The test function is as follows:</p><div><pre class="programlisting">        #[test]
        fn seven_times_six_is_forty_two() {
            assert_eq!(7 * 6, 42);
        }</pre></div><p>We also want a test that fails:</p><div><pre class="programlisting">test_eq!(seven_times_six_is_not_forty_three, 7 * 6, 43);</pre></div><p>The first argument of <code class="literal">test_eq</code> is the test's name and the second and third arguments are values to be compared for equality, so in general, the format is: <code class="literal">test_eq!(name, left, right);</code>.</p><p>Here, <code class="literal">name</code> is an identifier; <code class="literal">left</code> and <code class="literal">right</code> are expressions. Like the <code class="literal">create_fn</code> invocation, the <code class="literal">test_eq!</code> calls are written outside a function.</p><p>Now, we can compose our macro as follows:</p><div><pre class="programlisting">macro_rules! test_eq {
    ($name:ident, $left:expr, $right:expr) =&gt; {
        #[test]
        fn $name() {
            assert_eq!($left, $right);
        }
    }
}</pre></div><p>You can create the test runner by calling <code class="literal">rustc --test macros.rs</code>.</p><p>When the macros executable is run, it prints out:</p><div><pre class="programlisting">running 2 tests
test seven_times_six_is_forty_two ... ok
test seven_times_six_is_not_forty_three ... FAILED</pre></div><p>A macro can also be recursive and call itself in the expansion branch. This is useful for processing tree-structured input, for example, when parsing HTML code.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec08"/>Using macros from crates</h3></div></div></div><p>As we <a id="id265" class="indexterm"/>demonstrated at the end of the <em>Adding external crates to a project</em> section, loading<a id="id266" class="indexterm"/> all the macros from an external crate should done by preceding the extern crate <code class="literal">abc</code> with the <code class="literal">#[macro_use]</code> attribute. If you only need the <code class="literal">mac1</code> and <code class="literal">mac2</code> macros, you can write this:</p><div><pre class="programlisting">#[macro_use(mac1, mac2)]
extern crate abc;</pre></div><p>If the attribute is not present, no macros are loaded from <code class="literal">abc</code>. Moreover, inside the <code class="literal">abc</code> module, only macros defined with the <code class="literal">#[macro_export]</code> attribute can be loaded in another module. To distinguish macros with the same name in different modules, use the <code class="literal">$crate</code> variable in the macro. Within the code of a macro imported from an <code class="literal">abc</code> crate, the special <code class="literal">$crate</code> macro variable will expand to <code class="literal">::abc</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we learned how to structure modules into crates to make our code more flexible and modular. Now, you also know the basic rules for writing macros for more compact and less repetitive code.</p><p>In the following chapter, we will explore the power of Rust when it comes to the concurrent and parallel execution of code, and how Rust also preserves memory safety in this area.</p></div></body></html>