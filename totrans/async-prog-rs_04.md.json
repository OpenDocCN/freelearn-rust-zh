["```rs\nsrc\n |-- ffi.rs\n |-- main.rs\n |-- poll.rs\n```", "```rs\nmod ffi;\nmod poll;\n```", "```rs\nuse std::{io::{self, Result}, net::TcpStream, os::fd::AsRawFd};\nuse crate::ffi;\ntype Events = Vec<ffi::Event>;\npub struct Poll {\n  registry: Registry,\n}\nimpl Poll {\n  pub fn new() -> Result<Self> {\n    todo!()\n  }\n  pub fn registry(&self) -> &Registry {\n    &self.registry\n  }\n  pub fn poll(&mut self, events: &mut Events, timeout: Option<i32>) -> Result<()> {\n    todo!()\n  }\n}\npub struct Registry {\n  raw_fd: i32,\n}\nimpl Registry {\n  pub fn register(&self, source: &TcpStream, token: usize, interests: i32) -> Result<()> \n  {\n    todo!()\n  }\n}\nimpl Drop for Registry {\n  fn drop(&mut self) {\n    todo!()\n  }\n}\n```", "```rs\nlet queue = Poll::new().unwrap();\nlet id = 1;\n// register interest in events on a TcpStream\nqueue.registry().register(&stream, id, ...).unwrap();\nlet mut events = Vec::with_capacity(1);\n// This will block the curren thread\nqueue.poll(&mut events, None).unwrap();\n//...data is ready on one of the tracked streams\n```", "```rs\npub const EPOLL_CTL_ADD: i32 = 1;\npub const EPOLLIN: i32 = 0x1;\npub const EPOLLET: i32 = 1 << 31;\n#[link(name = \"c\")]\nextern \"C\" {\n  pub fn epoll_create(size: i32) -> i32;\n  pub fn close(fd: i32) -> i32;\n  pub fn epoll_ctl(epfd: i32, op: i32, fd: i32, event: *mut Event) -> i32;\n  pub fn epoll_wait(epfd: i32, events: *mut Event, maxevents: i32, timeout: i32) -> i32;\n}\n```", "```rs\n#[derive(Debug)]\n#[repr(C, packed)]\npub struct Event {\n    pub(crate) events: u32,\n    // Token to identify event\n    pub(crate) epoll_data: usize,\n}\nimpl Event {\n    pub fn token(&self) -> usize {\n        self.epoll_data\n    }\n}\n```", "```rs\nfn main() {\n  let bitflag_a: i32 = 1 << 31;\n  let bitflag_b: i32 = 0x1;\n  let bitmask: i32 = bitflag_a | bitflag_b;\n  println!(\"{bitflag_a:032b}\");\n  println!(\"{bitflag_b:032b}\");\n  println!(\"{bitmask:032b}\");\n  check(bitmask);\n}\nfn check(bitmask: i32) {\n  const EPOLLIN: i32 = 0x1;\n  const EPOLLET: i32 = 1 << 31;\n  const EPOLLONESHOT: i32 = 0x40000000;\n  let read = bitmask & EPOLLIN != 0;\n  let et = bitmask & EPOLLET != 0;\n  let oneshot = bitmask & EPOLLONESHOT != 0;\n  println!(\"read_event? {read}, edge_triggered: {et}, oneshot?: {oneshot}\")\n}\n```", "```rs\n10000000000000000000000000000000\n00000000000000000000000000000001\n10000000000000000000000000000001\nread_event? true, edge_triggered: true, oneshot?: false\n```", "```rs\nimpl Poll {\n    pub fn new() -> Result<Self> {\n        let res = unsafe { ffi::epoll_create(1) };\n        if res < 0 {\n            return Err(io::Error::last_os_error());\n        }\n        Ok(Self {\n            registry: Registry { raw_fd: res },\n        })\n    }\n```", "```rs\n    pub fn registry(&self) -> &Registry {\n        &self.registry\n    }\n```", "```rs\n  pub fn poll(&mut self, events: &mut Events, timeout: Option<i32>) -> Result<()> {\n    let fd = self.registry.raw_fd;\n    let timeout = timeout.unwrap_or(-1);\n    let max_events = events.capacity() as i32;\n    let res = unsafe { ffi::epoll_wait(fd, events.as_mut_ptr(), max_events, timeout) };\n    if res < 0 {\n      return Err(io::Error::last_os_error());\n    };\n    unsafe { events.set_len(res as usize) };\n    Ok(())\n  }\n}\n```", "```rs\nimpl Registry {\n    pub fn register(&self, source: &TcpStream, token: usize, interests: i32) -> Result<()> {\n        let mut event = ffi::Event {\n            events: interests as u32,\n            epoll_data: token,\n        };\n        let op = ffi::EPOLL_CTL_ADD;\n        let res = unsafe {\n            ffi::epoll_ctl(self.raw_fd, op, source.as_raw_fd(), &mut event)\n        };\n        if res < 0 {\n            return Err(io::Error::last_os_error());\n        }\n        Ok(())\n    }\n}\n```", "```rs\nimpl Drop for Registry {\n    fn drop(&mut self) {\n        let res = unsafe { ffi::close(self.raw_fd) };\n        if res < 0 {\n            let err = io::Error::last_os_error();\n            eprintln!(\"ERROR: {err:?}\");\n        }\n    }\n}\n```", "```rs\nuse std::{io::{self, Read, Result, Write}, net::TcpStream};\nuse ffi::Event;\nuse poll::Poll;\nmod ffi;\nmod poll;\n```", "```rs\nfn get_req(path &str) -> Vec<u8> {\n    format!(\n        \"GET {path} HTTP/1.1\\r\\n\\\n             Host: localhost\\r\\n\\\n             Connection: close\\r\\n\\\n             \\r\\n\"\n    )\n}\n```", "```rs\nfn main() -> Result<()> {\n    let mut poll = Poll::new()?;\n    let n_events = 5;\n    let mut streams = vec![];\n    let addr = \"localhost:8080\";\n    for i in 0..n_events {\n        let delay = (n_events - i) * 1000;\n        let url_path = format!(\"/{delay}/request-{i}\");\n        let request = get_req(&url_path);\n        let mut stream = std::net::TcpStream::connect(addr)?;\n        stream.set_nonblocking(true)?;\n        stream.write_all(request.as_bytes())?;\n        poll.registry()\n            .register(&stream, i, ffi::EPOLLIN | ffi::EPOLLET)?;\n        streams.push(stream);\n    }\n```", "```rs\nlet mut handled_events = 0;\n    while handled_events < n_events {\n        let mut events = Vec::with_capacity(10);\n        poll.poll(&mut events, None)?;\n        if events.is_empty() {\n            println!(\"TIMEOUT (OR SPURIOUS EVENT NOTIFICATION)\");\n            continue;\n        }\n        handled_events += handle_events(&events, &mut streams)?;\n    }\n    println!(\"FINISHED\");\n    Ok(())\n}\n```", "```rs\nfn handle_events(events: &[Event], streams: &mut [TcpStream]) -> Result<usize> {\n    let mut handled_events = 0;\n    for event in events {\n        let index = event.token();\n        let mut data = vec![0u8; 4096];\n        loop {\n            match streams[index].read(&mut data) {\n                Ok(n) if n == 0 => {\n                    handled_events += 1;\n                    break;\n                }\n                Ok(n) => {\n                    let txt = String::from_utf8_lossy(&data[..n]);\n                    println!(\"RECEIVED: {:?}\", event);\n                    println!(\"{txt}\\n------\\n\");\n                }\n                // Not ready to read in a non-blocking manner. This could\n                // happen even if the event was reported as ready\n                Err(e) if e.kind() == io::ErrorKind::WouldBlock => break,\n                Err(e) => return Err(e),\n            }\n        }\n    }\n    Ok(handled_events)\n}\n```", "```rs\nRECEIVED: Event { events: 1, epoll_data: 4 }\nHTTP/1.1 200 OK\ncontent-length: 9\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Wed, 04 Oct 2023 15:29:09 GMT\nrequest-4\n------\nRECEIVED: Event { events: 1, epoll_data: 3 }\nHTTP/1.1 200 OK\ncontent-length: 9\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Wed, 04 Oct 2023 15:29:10 GMT\nrequest-3\n------\nRECEIVED: Event { events: 1, epoll_data: 2 }\nHTTP/1.1 200 OK\ncontent-length: 9\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Wed, 04 Oct 2023 15:29:11 GMT\nrequest-2\n------\nRECEIVED: Event { events: 1, epoll_data: 1 }\nHTTP/1.1 200 OK\ncontent-length: 9\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Wed, 04 Oct 2023 15:29:12 GMT\nrequest-1\n------\nRECEIVED: Event { events: 1, epoll_data: 0 }\nHTTP/1.1 200 OK\ncontent-length: 9\nconnection: close\ncontent-type: text/plain; charset=utf-8\ndate: Wed, 04 Oct 2023 15:29:13 GMT\nrequest-0\n------\nFINISHED\n```", "```rs\n#1 - 5000ms: request-0\n#2 - 4000ms: request-1\n#3 - 3000ms: request-2\n#4 - 2000ms: request-3\n#5 - 1000ms: request-4\n```"]