- en: Robust Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强健的树
- en: 'Lists are great for storing a bunch of items, but what about looking up specific
    elements? In the previous chapter, a skip list greatly outperformed a regular
    linked list when simply finding an item. Why? Because it was utilizing an iteration
    strategy that resembles that of a balanced tree structure: there, the internal
    order lets the algorithm strategically skip items. However, that''s only the beginning.
    Many libraries, databases, and search engines are built on trees; in fact, whenever
    a program is compiled, the compiler creates an abstract syntax tree.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 列表非常适合存储大量项目，但查找特定元素怎么办？在前一章中，跳表在简单地查找项目时，比常规链表表现要好得多。为什么？因为它利用了一种类似于平衡树结构的迭代策略：在那里，内部顺序让算法能够有策略地跳过项目。然而，这仅仅是开始。许多库、数据库和搜索引擎都是基于树构建的；事实上，每当程序编译时，编译器都会创建一个抽象语法树。
- en: 'Tree-based data structures incorporate all kinds of smart ideas that we will
    explore in this chapter, so you can look forward to the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基于树的数据库结构结合了各种智能想法，我们将在本章中探讨，所以你可以期待以下内容：
- en: Implementing and understanding a binary search tree
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和理解二叉搜索树
- en: Learning about self-balancing trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解自平衡树
- en: How prefix or suffix trees work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀或后缀树是如何工作的
- en: What a priority queue uses internally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列内部使用什么
- en: Graphs, the most general tree structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图，最通用的树结构
- en: Binary search tree
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A tree structure is almost like a linked list: each node has branches—in the
    case of a binary tree, there are two—which represent children of that node. Since
    these children have children of their own, the node count grows exponentially,
    building a hierarchical structure that looks like a regular tree turned on its
    head.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构几乎就像一个链表：每个节点都有分支——在二叉树的情况下，有两个分支——代表该节点的子节点。由于这些子节点有自己的子节点，节点数量呈指数增长，构建了一个类似常规树倒置的层次结构。
- en: Binary trees are a subset of these structures with only two branches, typically
    called left and right. However, that does not inherently help the tree's performance.
    This is why using a *binary search tree*, where left represents the smaller or
    equal value to its parent, and right anything that's greater than that parent
    node, was established!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是这些结构的一个子集，只有两个分支，通常称为左和右。然而，这并不本质上帮助树的性能。这就是为什么使用*二叉搜索树*，其中左表示小于或等于其父节点的值，而右表示大于该父节点的任何值，被建立起来的原因！
- en: 'If that was confusing, don''t worry; there will be code. First, some vocabulary
    though: what would you call the far ends of the tree? Leaves. Cutting off branches?
    Pruning. The number of branches per node? Branching factor (binary trees have
    a branching factor of 2).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让你感到困惑，别担心；会有代码。首先，一些词汇：你该如何称呼树的远端？叶子。剪掉分支？修剪。每个节点的分支数量？分支因子（二叉树的分支因子为2）。
- en: 'Great, with that out of the way, the nodes can be shown—although they look
    a lot like the doubly linked list from the previous chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，把这些都弄清楚后，节点就可以展示了——尽管它们看起来很像前一章中的双链表：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, the tree structure itself is only a pointer to the root node:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，树结构本身只是对根节点的指针：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yet before you can get comfortable with the new data structure, the product
    team from the previous chapter is back! You did a great job improving the transaction
    log and they want to continue that progress and build an **Internet of Things**
    (**IoT**) device management platform so users can register a device with a numerical
    name and later search for it. However, the search has to be fast or really fast,
    which is especially critical since many customers have announced the incorporation
    of more than 10,000 devices into the new system!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够熟悉新的数据结构之前，前一章的产品团队又回来了！你们在改进事务日志方面做得很好，他们希望继续这种进步，并构建一个**物联网（IoT**）设备管理平台，以便用户可以使用数字名称注册设备，并在以后搜索它。然而，搜索必须非常快，这对于许多宣布将超过10,000个设备纳入新系统的客户来说尤其关键！
- en: Isn't this a great opportunity to get more experience with a binary search tree?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个用二叉搜索树获得更多经验的好机会吗？
- en: IoT device management
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网设备管理
- en: Device management in the IoT space is mostly about storing and retrieving specific
    devices or device twins. These objects typically store addresses, configuration
    values, encryption keys, or other things for small devices so nobody has to connect
    manually. Consequently, keeping an inventory is critical!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网空间中的设备管理主要关于存储和检索特定的设备或设备孪生。这些对象通常存储地址、配置值、加密密钥或其他东西，以便没有人需要手动连接。因此，保持库存至关重要！
- en: 'For now, the product team settled on a numerical "name", to be available faster
    than the competition, and to keep the requirements short:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，产品团队决定采用数字“名称”，以便比竞争对手更快地可用，并保持要求简短：
- en: Store IoT device objects (containing the IP address, numerical name, and type)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储物联网设备对象（包含IP地址、数字名称和类型）
- en: Retrieve IoT objects by numerical name
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数字名称检索物联网对象
- en: Iterate over IoT objects
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历物联网对象
- en: 'A great use for a tree: the numerical name can be used to create a tree and
    search for it nice and quickly. The basic object for storing this IoT device information
    looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 树的一个很好的用途：数字名称可以用来创建一个树并快速搜索它。存储此物联网设备信息的基本对象看起来像这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For simplicity, this object will be used in the code directly (adding generics
    isn''t too tricky, but would go beyond the scope of this book):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这个对象将在代码中直接使用（添加泛型并不太复杂，但会超出本书的范围）：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Starting with this basic implementation, the requisite operations, `add` and
    `find`, can be implemented.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个基本实现开始，可以实施必要的操作，`add`和`find`。
- en: More devices
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多设备
- en: 'Unlike lists, trees make a major decision on insert: which side does the new
    element go to? Starting at the root node, each node''s value is compared to the
    value that is going to be inserted: is this greater than or less than that? Either
    decision will lead down a different subtree (left or right).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，树在插入时做出一个主要决定：新元素将放在哪一侧？从根节点开始，每个节点的值与将要插入的值进行比较：这是否大于或小于那个值？任一决定都会导致向下进入不同的子树（左或右）。
- en: 'This process is (usually recursively) repeated until the targeted subtree is
    `None`, which is exactly where the new value is inserted—as a leaf of the tree.
    If this is the first value going into the tree, it becomes the root node. There
    are some problems with this, and the more experienced programmers will have had
    a strange feeling already: what happens if you insert numbers in ascending order?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程（通常是递归地）重复，直到目标子树为`None`，这正是新值插入的位置——作为树的叶子。如果这是第一个进入树中的值，它就成为根节点。这里有一些问题，更有经验的程序员可能已经有一种奇怪的感觉：如果你按升序插入数字会发生什么？
- en: 'These feelings are justified. Inserting in ascending order (for example, `1`,
    `2`, `3`, `4`) will lead to a tree that is basically a list in disguise! This
    is also called a (very) unbalanced tree and won''t have any of the benefits of
    other trees:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些感觉是有道理的。按升序插入（例如，`1`，`2`，`3`，`4`）将导致一个基本上是伪装成列表的树！这也被称为（非常）不平衡的树，将不会有其他树的所有好处：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'During this chapter, we are going to go a lot more things on balancing trees
    and why that is important in order to achieve high performance. In order to avoid
    this pitfall associated with binary search trees, the first value to insert should
    ideally be the median of all elements since it will be used as the root node,
    as is visible in the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨平衡树以及为什么平衡树对于实现高性能很重要。为了避免与二叉搜索树相关的这种陷阱，理想情况下第一个要插入的值应该是所有元素的中位数，因为它将被用作根节点，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Split into two parts, this code walks the tree recursively to find the appropriate
    position and attaches the new value as a leaf there. Actually, the insert is not
    that different from a regular tree walk in search or iteration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分为两部分，这部分代码递归地遍历树以找到适当的位置，并将新值作为叶子附加在那里。实际上，插入并不比常规的树遍历在搜索或迭代中不同。
- en: '**Recursion** is when a function calls itself. Think of the movie Inception—having
    a dream inside a dream inside a dream. it''s the same concept. There are a few
    implications in programming: the original function is disposed of last since it''s
    only finished after all recursive calls return. This also means that everything
    lives on the much smaller stack, which may result in a stack overflow when there
    are too many calls! Typically, recursive algorithms can also be implemented iteratively,
    but they are much harder to understand—so choose wisely!'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**是函数调用自身。想想电影《盗梦空间》——梦中有梦，梦中有梦。这是同样的概念。在编程中有一些影响：原始函数最后被销毁，因为只有当所有递归调用返回后它才完成。这也意味着所有内容都存在于更小的栈上，这可能导致在调用过多时栈溢出！通常，递归算法也可以迭代实现，但它们更难理解——所以要明智选择！'
- en: Finding the right one
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找正确的一个
- en: Having the ability to add devices to the tree, it's even more important to retrieve
    them again. Just like the skip list in the previous chapter, this retrieval ideally
    runs in *O(log n)* time, meaning that the majority of elements are going to be
    skipped when searching.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将设备添加到树中，更重要的是能够再次检索它们。就像前一章中的跳表一样，这种检索理想情况下运行在 *O(log n)* 时间内，这意味着在搜索时将跳过大多数元素。
- en: 'Consequently, if the tree is skewed in one direction, the performance approaches
    *O(n)* and more elements are looked at, thereby making the search slower. Since
    a skewed tree is more like a list, the recursive insert algorithm can overflow
    the stack quickly thanks to the high number of "levels" with only a single item.
    Otherwise, the recursive algorithm is only called as many times as the tree''s
    height, a considerably lower number in a balanced tree. The algorithm itself resembles
    the previously shown insert algorithm:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果树在某一方向上倾斜，性能接近 *O(n)*，查看的元素更多，从而使得搜索变慢。由于倾斜的树更像列表，递归插入算法会因只有单个项目的“层级”数量众多而快速溢出栈。否则，递归算法只调用树的高度次数，在平衡树中这是一个相当小的数字。算法本身类似于之前展示的插入算法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although this snippet's purpose is to find a specific node, there is a close
    relationship to enumerating every device—something that the users of this service
    certainly will want to have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个片段的目的是找到特定的节点，但它与列举每个设备有着密切的关系——这是此服务用户肯定希望拥有的功能。
- en: Finding all devices
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有设备
- en: 'Walking a tree and executing a callback when visiting each node can be done
    in three ways:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问每个节点时遍历树并执行回调可以以三种方式完成：
- en: Pre-order, executing the callback *before descending*
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前序，执行回调 *在下降之前*
- en: In-order, which executes the callback *after descending left, but before descending
    into the right subtree*
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中序，它执行回调 *在下降到左子树之后，但在下降到右子树之前*
- en: Post-order, where the callback is executed *after descending*
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序，其中回调在 *下降后* 执行
- en: Each of these traversal strategies yields a different order of tree elements,
    with in-order producing a sorted output, while pre- and post-order create a more
    structurally oriented sorting. For our users, the in-order walk will provide the
    best experience, since it also lets them reason better regarding the expected
    outcome, and, if displayed in a list, it's easier to navigate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些遍历策略中的每一种都会产生不同的树元素顺序，其中中序产生排序输出，而前序和后序则创建更结构化的排序。对于我们的用户来说，中序遍历将提供最佳体验，因为它还让他们更好地推理预期的结果，如果以列表形式显示，则更容易导航。
- en: While implementing this walk is very easy to do recursively, providing an iterator
    is more user-friendly (just like the lists in the previous chapter) and it enables
    a number of added functions, such as `map()` and `filter()`. However, this implementation
    has to be iterative, which makes it more complex and removes some of the efficiency
    of the tree.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以递归方式实现这种行走非常简单，但提供一个迭代器更符合用户习惯（就像前一章中的列表一样），并且它使许多附加功能成为可能，例如 `map()` 和 `filter()`。然而，这种实现必须是迭代的，这使得它更复杂，并减少了树的一些效率。
- en: 'Therefore, this tree supports a `walk()` function which calls a provided function
    each time it encounters a node, which can be used to fill a vector for the iterator:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此树支持一个 `walk()` 函数，每次遇到节点时都会调用提供的函数，这可以用来填充迭代器的向量：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An example of how to build a vector using this walk method is shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了如何使用这种行走方法构建向量的示例：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this walking ability, all requirements are satisfied for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种行走能力，目前所有需求都已得到满足。
- en: Wrap up
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Thanks to their simplicity, binary search trees are beautifully efficient. In
    fact, the entire tree implementation for this section was done in fewer than 90
    lines of Rust code, with functions of about 10 lines each.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的简单性，二叉搜索树非常高效。事实上，本节中整个树实现只用不到90行Rust代码完成，每个函数大约10行。
- en: A binary tree's efficiency allows for recursion to be used a lot, which typically
    results in functions that are easier to understand compared to their iterative
    counterparts. In the ideal case, that is, when a tree is perfectly balanced, a
    function only has to process *log2(n)* nodes (*n* being the total number of nodes)—19
    in a tree of 1,000,000 elements!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树的效率允许大量使用递归，这通常会导致与迭代版本相比更容易理解的函数。在理想情况下，即当树完全平衡时，函数只需要处理 *log2(n)* 个节点（*n*
    是节点总数）——在一个包含100万个元素的树中只有19个！
- en: 'Unbalanced trees will decrease performance significantly and they are easily
    created by accident. The most unbalanced tree is created by inserting values that
    are already sorted, creating a very large difference in search performance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不平衡的树会显著降低性能，并且它们很容易意外创建。最不平衡的树是通过插入已经排序的值创建的，这会在搜索性能上造成很大的差异：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These results reflect the differences between a skip list and a doubly linked
    list from the previous chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果反映了跳表和前一章中的双链表之间的差异。
- en: Upsides
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'To recap, a binary search tree has a number of great benefits for its users:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，二叉搜索树对用户来说有许多好处：
- en: Simple implementation
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单实现
- en: Efficient and fast search
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效且快速的搜索
- en: Traversal allows for different orderings
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历允许不同的排序
- en: Great for large amounts of unsorted data
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常适合大量未排序的数据
- en: Downsides
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'By using a binary search tree, its drawbacks become obvious quickly:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用二叉搜索树，其缺点很快就会变得明显：
- en: Worst-case performance is that of a linked list
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏情况下的性能与链表相当
- en: Unbalanced trees are easy to create by accident
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不平衡的树很容易意外创建
- en: Unbalanced trees cannot be "repaired"
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不平衡的树不能“修复”
- en: Recursive algorithms can overflow on unbalanced trees
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归算法在不平衡的树上可能会溢出
- en: 'Obviously, a lot of the deeper issues result from the tree being unbalanced
    in some way—for which there is a solution: self-balancing binary search trees.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，许多更深层次的问题都源于树以某种方式不平衡——对此有一个解决方案：自平衡二叉搜索树。
- en: Red-black tree
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'With the previous tree structure, there was a major downside: a previously
    unknown sequence of keys that is inserted into the tree cannot be sorted. Think
    of how most identifiers are generated; they are typically ascending numbers. Shuffling
    these numbers won''t always work, especially when they are gradually added. Since
    this leads to an unbalanced tree (the extreme case behaves just like a list),
    Rudolf Bayer came up with the idea of a special, self-balancing tree: the red-black
    tree.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的树结构中，有一个主要的缺点：插入到树中的先前未知的键序列无法排序。想想大多数标识符是如何生成的；它们通常是递增的数字。对这些数字进行洗牌并不总是有效，尤其是在它们逐渐添加时。由于这会导致不平衡的树（极端情况表现得就像一个列表），鲁道夫·拜尔提出了一个特殊的自平衡树的想法：红黑树。
- en: 'This tree is a binary search tree that adds logic to rebalance after inserts.
    Within this operation, it is crucial to know when to stop "balancing"—which is
    where the inventor thought to use two colors: red and black.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树是一个二叉搜索树，它在插入后添加了重新平衡的逻辑。在这个操作中，知道何时停止“平衡”至关重要——这就是发明者想到使用两种颜色：红色和黑色。
- en: 'In literature, the red-black tree is described as a binary search tree that
    satisfies a set of rules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，红黑树被描述为满足一系列规则的二叉搜索树：
- en: The root node is always black
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点始终是黑色
- en: Each other node is either red or black
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个其他节点要么是红色，要么是黑色
- en: All leaves (often `null`/`NIL` values) are considered black
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有叶子（通常是 `null`/`NIL` 值）都被认为是黑色的
- en: A red node can only have black children
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色节点只能有黑色子节点
- en: Any path from the root to its leaves has the same number of black nodes
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从根到其叶子的任何路径都有相同数量的黑色节点
- en: 'By enforcing these rules, a tree can be programmatically verified to be balanced.
    How are these rules doing that? Rules 4 and 5 provide the answer: if each branch
    has to have the same number of black nodes, neither side can be significantly
    longer than the other unless there were lots of red nodes.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制执行这些规则，可以通过编程验证树是否平衡。这些规则是如何做到这一点的呢？规则4和5提供了答案：如果每个分支都必须有相同数量的黑色节点，那么两边不可能有显著的一边比另一边长，除非有很多红色节点。
- en: 'How many of those can there be? At most, as many as there are black nodes—because
    they cannot have red children. Thus, one branch cannot significantly exceed the
    other, making this tree balanced. The code of the validation function illustrates
    this very well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些能有多少呢？最多和黑色节点一样多——因为它们不能有红色子节点。因此，一个分支不能显著超过另一个，使得这棵树保持平衡。验证函数的代码很好地说明了这一点：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the binary search tree, each node in a tree has two children, with a key
    either greater than, equal to, or less than that of the current node. In addition
    to the key (as in a key-value pair), the nodes store a color that is red on insert,
    and a pointer back to its parent. Why? This is due to the required rebalancing,
    which will be described later. First, this can be a typical node:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像二叉搜索树一样，树中的每个节点都有两个子节点，键要么大于、等于或小于当前节点的键。除了键（如键值对）之外，节点还存储一个颜色，插入时为红色，并指向其父节点。为什么？这是因为所需的平衡，这将在后面描述。首先，这可以是一个典型的节点：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using these nodes, a tree can be created just like a binary search tree. In
    fact, the insert mechanism is exactly the same except for setting the parent pointer.
    Newly inserted nodes are always colored red and, once in place, the tree might
    violate the rules. Only then is it time to find and fix these issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些节点，可以创建一个树，就像二叉搜索树一样。实际上，插入机制完全相同，只是设置了父指针。新插入的节点总是着色为红色，一旦就位，树可能会违反规则。只有在这种情况下，才是寻找和修复这些问题的时机。
- en: After an insert, the tree is in an invalid state that requires a series of steps
    to restore the red-black tree's properties. This series, comprised of rotation
    and recolor*,* starts at the inserted node and goes up the tree until the root
    node is considered valid. In summary, a red-black tree is a binary search tree
    that is rotated and recolored until balance is restored.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 插入后，树处于无效状态，需要一系列步骤来恢复红黑树属性。这个系列，由旋转和重新着色*组成，从插入节点开始，向上到根节点被认为是有效的。总之，红黑树是一种旋转和重新着色直到恢复平衡的二叉搜索树。
- en: '**Recolor** is simply changing the color of a specified node to a specific
    color, which happens as a final step when doing tree rebalancing. **Rotation**
    is an operation of a set of three nodes: the current node, its parent, and its
    grandparent. It is employed to fold list-like chains into trees by rotating either
    left or right around a specified node. The result is a changed hierarchy, with
    either the left or right child of the center node on top, and its children adjusted
    accordingly:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新着色**只是将指定节点的颜色更改为特定颜色，这在进行树平衡的最后一步发生。**旋转**是一组三个节点（当前节点、其父节点和其祖父节点）的操作。它通过围绕指定节点左旋或右旋来折叠类似列表的链到树中。结果是改变了层次结构，中心节点的左子节点或右子节点位于顶部，其子节点相应地调整：'
- en: '![](img/f45acff7-777a-4242-b534-c2464c606330.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f45acff7-777a-4242-b534-c2464c606330.png)'
- en: 'Clearly, this example is too simple and it can only happen within the first
    few inserts. Rotations require recolors after redefining the hierarchy of a set
    of nodes. To add further complexity, rotations regularly happen in succession:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个例子太简单了，它只能在最初的几次插入中发生。在重新定义一组节点层次结构之后，旋转需要重新着色。为了增加复杂性，旋转通常会连续发生：
- en: '![](img/bd2d323f-1996-49ea-a6ba-facdae784fe9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd2d323f-1996-49ea-a6ba-facdae784fe9.png)'
- en: 'The preceding tree has had a node inserted and is now violating rule 4: *no
    red children on a red node*. The next step is to determine which steps are required
    to establish balance. For that, the parent''s sibling''s color (that is, the uncle''s
    color) is examined. Red means that a simple recoloring of both siblings to black
    and their parent to red won''t invalidate the tree and will fix the condition.
    This is not the case here (the uncle is `None`, which means black), and some rotation
    is required:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的树已经插入了一个节点，现在违反了规则 4：*红色节点上不能有红色子节点*。下一步是确定需要哪些步骤来建立平衡。为此，检查父节点的兄弟节点的颜色（即叔叔的颜色）。红色表示将两个兄弟节点都着色为黑色，并将它们的父节点着色为红色不会使树无效，并修复条件。这里不是这种情况（叔叔是
    `None`，这意味着黑色），需要进行一些旋转：
- en: '![](img/0a1e50d9-be7b-4738-b786-f1c75b648f92.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a1e50d9-be7b-4738-b786-f1c75b648f92.png)'
- en: 'The first move is to align the nodes into a chain of left children (in this
    case), which is done by rotating around the center node, the insertee''s parent:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将节点排列成一条左子节点的链（在这种情况下），这是通过围绕中心节点，插入节点的父节点旋转来完成的：
- en: '![](img/b3f8638e-86e6-4b37-bf7b-60c6340b3c60.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3f8638e-86e6-4b37-bf7b-60c6340b3c60.png)'
- en: 'Once the chain is aligned, a right rotation of the third node (grandparent)
    creates a valid subtree by elevating the middle node (the "youngest" node/insertee),
    with the former parent and grandparent to the left and right, respectively. Then,
    the new constellation is recolored and the procedure begins anew, centered around
    the root of the new subtree (in this example, though, the tree is already valid):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链对齐，第三个节点（祖父节点）向右旋转就通过提升中间节点（“最年轻”的节点/插入节点）创建了一个有效的子树，前父节点和祖父节点分别位于左侧和右侧。然后，新的星系被重新着色，程序重新开始，以新子树的根为中心（在这个例子中，尽管如此，树已经有效）：
- en: '![](img/f007f46a-f3ea-4374-8775-e444dec4c6f7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f007f46a-f3ea-4374-8775-e444dec4c6f7.png)'
- en: These steps can be repeated until the tree is valid and the root is reached
    (which might be different from what you started off with). This root node is heuristically
    painted black as well, which cannot violate the rules but shortcuts a potential
    red-red violation. For code on the fixing operation, see the following subsections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以重复进行，直到树有效且到达根节点（这可能与您开始时的情况不同）。这个根节点也被启发式地涂成黑色，这不会违反规则，但缩短了潜在的红色-红色违规。有关修复操作的代码，请参阅以下小节。
- en: The product team has even called this time to put emphasis on their new product
    ideas. The IoT platform is quite popular and customers have been using it a lot—and
    recognized a major slowdown when they kept adding their sequentially numbered
    devices. This resulted in angry calls to customer services, which then turned
    to the product team for help—and now it's time to implement the solution and replace
    the current tree for device management.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 产品团队甚至将这段时间用来强调他们的新产品理念。物联网平台相当受欢迎，客户一直在大量使用它——并且在他们继续添加顺序编号的设备时，他们认识到了重大的减速。这导致了愤怒的客户服务电话，然后转向产品团队寻求帮助——现在是时候实施解决方案并替换当前的设备管理树了。
- en: Better IoT device management
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的物联网设备管理
- en: 'The problem that our users face is clear: if a binary search tree encounters
    sorted data (such as incremental IDs), it can only ever append to one side, creating
    an unbalanced tree. A red-black tree is able to handle this at the cost of more
    operations being executed during insert (such as rotating subtrees), which is
    acceptable for the users.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用户面临的问题很清楚：如果一个二叉搜索树遇到排序数据（如增量 ID），它只能始终向一侧追加，从而创建一个不平衡的树。红黑树能够在插入时执行更多操作（如旋转子树）的代价下处理这个问题，这对用户来说是可接受的。
- en: 'This tree has similar nodes to the binary search tree, with the addition of
    a color field and a parent field, the latter of which triggers a wider change
    compared to the binary search tree. Thanks to the pointer back, the tree nodes
    cannot exclusively own the pointers to the children and parent (because, who owns
    this value, the parent or the child?), which requires a well-known pattern in
    Rust: interior mutability. As discussed in an earlier chapter, `RefCell` owns
    the data''s portion of the memory and handles borrow-checking at runtime so that
    mutable and immutable references can be obtained:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树与二叉搜索树有类似的节点，增加了颜色字段和父字段，后者相对于二叉搜索树来说，变化更大。多亏了回指，树节点不能仅拥有指向子节点和父节点的指针（因为，谁拥有这个值，父节点还是子节点？），这需要
    Rust 中一个众所周知的模式：内部可变性。正如在前一章中讨论的，`RefCell` 拥有数据的内存部分，并在运行时处理借用检查，以便可以获取可变和不可变引用：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that in place, devices can be added.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置到位，就可以添加设备。
- en: Even more devices
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的设备
- en: Once the tree is created, an `add()` function lets the user add a device. The
    tree then proceeds to insert the new key just as if it were a binary search tree—only
    to check and fix any errors immediately afterward. Where a binary search tree
    could use a simple `if` condition to decide the direction it proceeds in, in the
    red-black tree, the direction has a larger impact, and nesting `if` conditions
    will result in chaotic, unreadable code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了树，`add()` 函数允许用户添加设备。然后，树继续像二叉搜索树一样插入新键，只是在之后立即检查和修复任何错误。在二叉搜索树中可以使用简单的
    `if` 条件来决定前进的方向，而在红黑树中，方向有更大的影响，嵌套 `if` 条件会导致混乱、难以阅读的代码。
- en: 'Thus, let''s create `enum` first, so any time the direction (example, insert,
    position of a node relative to another node, and so on) has to be decided, we
    can rely on that `enum`. The same goes for the tree''s color:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建 `enum`，这样每当需要决定方向（例如，插入，节点相对于另一个节点的位置等）时，我们都可以依赖这个 `enum`。对于树的颜色也是如此：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the `add()` function can use Rust''s match clause to nicely structure
    the two branches:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`add()`函数可以使用Rust的match子句来优雅地组织两个分支：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One of the primary parts of the code is "checking" two devices, that is, comparing
    them in order to provide a direction that they should be appended to. This comparison
    is done in a separate function to improve maintainability:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主要部分之一是“检查”两个设备，即比较它们以提供它们应该附加到的方向。这种比较是在一个单独的函数中完成的，以提高可维护性：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this tree will append every larger item to the left (which seems unusual),
    the algorithms don't care; they will work regardless—and, by wrapping this into
    its own function, change is quick and easy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个树会将每个更大的项目附加到左侧（这似乎很奇怪），但算法并不关心；无论怎样它们都会工作——通过将其封装到自己的函数中，改变变得快速且简单。
- en: Balancing the tree
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡这棵树
- en: 'After the node is added properly, `fix_tree()` takes care of restoring the
    red-black tree''s properties—iteratively. While this is nicely descriptive and
    demonstrative it is long, so let''s break it up into parts. Initially, the function
    determines whether it should stop (or not even start)—which only happens in two
    cases:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点正确添加后，`fix_tree()`负责迭代地恢复红黑树的性质——这是非常好地描述性和演示性的，但它很长，所以让我们将其分成几个部分。最初，函数确定它是否应该停止（或甚至不开始）——这仅在两种情况下发生：
- en: When it's already the root node
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它已经是根节点时
- en: When the parent of the currently inspected node is red
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前检查节点的父节点是红色时
- en: 'Clearly, the former is the regular exit criterion as well, as the loop optimizes
    and moves the current pointer (`n` as in node) from the bottom toward the root
    of the tree to stop there:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前者是常规的退出标准，因为循环优化并移动当前指针（`n`代表节点）从底部向树根移动以停止在那里：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once started, the loop immediately goes for the uncle of a particular node
    (that is, the grandparent''s second child) and its color. The uncle node can either
    be black (or `None`) or red, which are the two cases covered next. It is also
    important to find out *which* uncle it is, and therefore which node the current
    pointer points to: a left node or a right node. Let''s take a look at the following
    code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始，循环立即寻找特定节点的叔叔节点（即祖父的第二个孩子）及其颜色。叔叔节点可以是黑色（或`None`）或红色，下面将讨论这两种情况。同样重要的是要找出它是哪个叔叔，因此当前指针指向哪个节点：左节点或右节点。让我们看一下下面的代码片段：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This information is critical in determining the rotation order in this area
    of the tree. In fact, the two branches will execute the same steps, but mirrored:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息对于确定这个树区域的旋转顺序至关重要。实际上，两个分支将执行相同的步骤，但相反：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code contains a large amount of `unwrap()`, `clone()`, and `borrow()` instances,
    a consequence of the interior mutability pattern. In this case, macros could help
    to reduce the code's verbosity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含大量的`unwrap()`、`clone()`和`borrow()`实例，这是内部可变性模式的后果。在这种情况下，宏可以帮助减少代码的冗长性。
- en: Once the operations for one part of the tree finishes, the next iteration is
    prepared by checking for a red-red violation to see whether the loop needs to
    continue.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一部分树的运算完成后，下一迭代通过检查是否存在红色-红色违规来准备，以查看循环是否需要继续。
- en: 'After the main loop exits, the pointer to the current node is moved up the
    tree to the root node (which is the function''s return value, after all) and colored
    black. Why? This is a shortcut solution that would otherwise result in another
    iteration requiring many more expensive steps to be executed, and the rules of
    a red-black tree mandate a black root anyway:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环退出后，当前节点的指针向上移动到树根节点（毕竟，这将是函数的返回值）并着色为黑色。为什么？这是一个快捷解决方案，否则会导致另一个迭代需要执行许多更昂贵的步骤，而红黑树的规则要求根节点必须是黑色的：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that shortcut, a valid tree is returned that can be set as the new root.
    However, the main purpose of the tree is to find stuff, which is not that different
    from a regular binary search tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个快捷方式，可以返回一个有效的树，可以将其设置为新的根。然而，树的主要目的是找到东西，这与常规的二叉搜索树并没有太大的不同。
- en: Finding the right one, now
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在找到正确的
- en: 'This piece of code can almost be reused from the binary search tree. Other
    than the `borrow()` calls (instead of a simple dereference or `*` operator) adding
    some amount of processing time, they provides a consistent search speed. For greater
    reuse of existing functions, the value to be found is wrapped into a dummy node.
    This way, no additional interface has to be created for comparing nodes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎可以重用自二叉搜索树。除了`borrow()`调用（而不是简单的解引用或`*`运算符）增加了处理时间外，它们提供了持续一致的搜索速度。为了更好地重用现有函数，要找到的值被封装到一个虚拟节点中。这样，就不需要为比较节点创建额外的接口：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is, again, a recursive walk of the tree until the specified value is found.
    Additionally, the "regular" tree walk was also added to the red-black tree variant:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是树的递归遍历，直到找到指定的值。此外，"常规"的树遍历也被添加到了红黑树变体中：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With these parts fixed, the platform performs consistently fast!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些部分修复后，平台的表现始终很快！
- en: Wrap up
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Red-black trees are great self-balancing binary trees, similar to **AVL** (short
    for **Adelson-Velsky and L****andis**) trees. Both appeared around the same time,
    yet AVL trees are considered to be superior thanks to a lower height difference
    between the branches. Regardless of which tree structure is used, both are significantly
    faster than their less complex sibling, the binary search tree. Benchmarks using
    sorted data on insert (100,000 elements in this case) show how significant the
    difference between a balanced and unbalanced tree is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树是优秀的自平衡二叉树，类似于**AVL**（代表**Adelson-Velsky and Landis**）树。两者几乎同时出现，但AVL树由于分支高度差较小而被认为是优越的。无论使用哪种树结构，两者都比它们的简单兄弟二叉搜索树快得多。使用排序数据在插入（本例中为100,000个元素）上的基准测试显示了平衡树和不平衡树之间的差异：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another variation of a balanced tree is the 2-3-4 tree, a data structure that
    the red-black tree can be converted into. However, the 2-3-4 tree is, like the
    B-Tree (coming up later in this chapter), non-binary. Therefore, it is briefly
    discussed later in this chapter, but we encourage you to find other sources for
    details.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡树的另一种变体是2-3-4树，这是一种可以将红黑树转换成的数据结构。然而，2-3-4树，就像本章后面将要提到的B树一样，是非二叉的。因此，它在本章的后面简要讨论，但我们鼓励您寻找其他来源以获取详细信息。
- en: One major upside to implementing a red-black tree in Rust is the deep understanding
    of borrowing and ownership that follows the reference juggling when rotating,
    or "unpacking", a node's grandfather. It is highly recommended as a programming
    exercise to implement your own version!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中实现红黑树的一个主要优点是，在旋转或"解包"节点祖父节点时，对借用和所有权的深入理解。在编程练习中实现自己的版本是非常推荐的！
- en: Upsides
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'A red-black tree has a few desirable properties over a regular binary search
    tree:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树相对于常规二叉搜索树有几个可取的特性：
- en: Balance makes searches consistently fast
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡使搜索始终快速
- en: Predictable, low-memory usage
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测，内存使用低
- en: Inserts are reasonably fast
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入操作相对较快
- en: Simplicity of a binary tree
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树的简单性
- en: Easy to validate
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易验证
- en: However, the data structure has some significant downsides as well, especially
    when planning to implement it!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种数据结构也有一些显著的缺点，尤其是在计划实现它的时候！
- en: Downsides
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Speed is great, but can your implementation achieve it? Let''s have a look
    at the downsides of red-black trees:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 速度很快，但你的实现能否达到这一点？让我们来看看红黑树的缺点：
- en: Complex implementation, especially in Rust
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复杂，尤其是在Rust中
- en: Concurrent writes require the entire tree to be locked
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发写入需要锁定整个树
- en: Performance is great compared to binary search trees, but other trees perform
    better at the same complexity
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与二叉搜索树相比，性能很好，但其他树在相同复杂度下表现更好
- en: Skip lists (from the previous chapter) perform similarly with better concurrency
    and simpler implementations
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳表（来自上一章）在更好的并发性和更简单的实现上表现相似
- en: In any case, the red-black tree is a great journey into sophisticated binary
    tree structures. A more exotic binary tree structure is the heap (not to be confused
    with the portion of main memory).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，红黑树都是深入复杂二叉树结构的绝佳之旅。一种更奇特的二叉树结构是堆（不要与主内存的一部分混淆）。
- en: Heaps
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: Since binary trees are the most basic forms of trees, there are several variations
    designed for a specific purpose. Where the red-black tree is an advanced version
    of the initial tree, the binary heap is a version of the binary tree that does
    not facilitate search.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二叉树是树的最基本形式，因此设计了多种变体，用于特定目的。红黑树是初始树的先进版本，而二叉堆是二叉树的一种版本，它不便于搜索。
- en: 'In fact, it has a specified purpose: finding the maximum or minimum value of
    a node. These heaps (min-heap or max-heap) are built in a way that the root node
    is always the value with the desired property (min or max) so it can be retrieved
    in constant time—that is, it always takes the same number of operations to fetch.
    Once fetched, the tree is restored in a way that the next operation works the
    same. How is this done though?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它有一个特定的目的：找到节点的最大值或最小值。这些堆（最小堆或最大堆）是以一种方式构建的，使得根节点总是具有所需属性（最小或最大）的值，因此可以以恒定时间检索——也就是说，获取所需的时间总是相同的。一旦检索到，树将以一种方式恢复，使得下一次操作可以正常工作。那么，这是如何实现的呢？
- en: Heaps work, irrespective of whether they are min-heaps or max-heaps, because
    a node's children always have the same property as the entire tree. In a max-heap,
    this means that the root node is the maximum value of the sequence, so it has
    to be the greatest value of its children (it's the same with min-heaps, just in
    reverse). While there is no specific order to this (such as the left node being
    greater than the right node), there is a convention to prefer the right node for
    max-heaps and the left for min-heaps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 堆（无论是最小堆还是最大堆）都有效，因为一个节点的子节点总是具有整个树相同的属性。在最大堆中，这意味着根节点是序列中的最大值，因此它必须是它的子节点中的最大值（最小堆的情况与此相同，只是方向相反）。虽然没有特定的顺序（例如左节点大于右节点），但有一个惯例是对于最大堆优先考虑右节点，对于最小堆优先考虑左节点。
- en: 'Upon inserting a new node, it is added last and then a place in the tree has
    to be determined. The strategy to do that is simple: look at the parent node;
    if it''s greater (in a max-heap), swap the two, and repeat until this doesn''t
    work or it becomes the root node. We call this operation **upheap**.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入一个新节点后，它会被添加到最后，然后需要在树中确定其位置。完成这一操作的策略很简单：查看父节点；如果它更大（在最大堆中），则交换这两个节点，并重复此操作，直到不再适用或成为根节点。我们称此操作为**上堆**。
- en: Similarly, this is how removals work. Once removed, the now-empty slot is replaced
    by a leaf of the tree—which is either the smallest (max-heap) or greatest (min-heap)
    value. Then, the same comparisons as with the insert are implemented, but in reverse.
    Comparing and swapping this node with the children restores the heap's properties
    and is called **downheap**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，删除操作也是这样进行的。一旦删除，现在为空的槽位会被树的一个叶子节点替换——这个叶子节点要么是最小值（最大堆）要么是最大值（最小堆）。然后，实现与插入相同的比较，但方向相反。将此节点与其子节点比较和交换可以恢复堆的性质，这被称为**下堆**。
- en: 'If you paid attention to a node''s journey, there is one detail that will be
    obvious to you: the tree is always "filled". This means that each level is fully
    populated (that is, every node has both children), making it a **complete binary
    tree** that maintains total order. This is a property that lets us implement this
    tree in an array (dynamic or not), making jumps cheap. It will all become clear
    once you see some diagram:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了一个节点的旅程，有一个细节可能会对你显而易见：树总是“填满”的。这意味着每一层都是完全填充的（也就是说，每个节点都有两个孩子），使其成为一个**完全二叉树**，并保持总顺序。这是一个让我们可以在数组（动态或静态）中实现此树并使跳跃变得便宜的性质。一旦你看到一些图表，一切都会变得清晰：
- en: '![](img/e2060e60-5458-46bd-b9e7-9634b47f8c98.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2060e60-5458-46bd-b9e7-9634b47f8c98.png)'
- en: Commonly, the heap is used to create a priority queue of some kind, thanks to
    the ability to quickly retrieve the highest- or lowest-valued items. A very basic
    heap can be implemented in Rust as an array, which will provide everything necessary
    to make it work, but won't be as convenient as a `Vec`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，堆被用来创建某种类型的优先队列，这得益于快速检索最高或最低值项的能力。一个非常基本的堆可以用Rust作为数组实现，这将提供使其工作所需的一切，但不会像`Vec`那样方便。
- en: After the great success of the IoT device platform, an add-on has been planned.
    The product team is asking for a way to efficiently process messages that come
    from the devices, so that customers only have to deal with the actual handling
    of the message and skip the "plumbing" code. Since processing can be executed
    at (short) intervals, they require a way to order them quickly—ideally so that
    the device with the most messages can come first.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网设备平台取得巨大成功之后，计划增加一个附加功能。产品团队正在寻求一种高效处理来自设备消息的方法，以便客户只需处理消息的实际处理，跳过“管道”代码。由于处理可以在（短）间隔内执行，他们需要一个快速排序它们的方法——理想情况下，让消息最多的设备先来。
- en: This sounds like the heap data structure, doesn't it? In fact, it can be a max-heap.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是堆数据结构，不是吗？实际上，它可以是最大堆。
- en: A huge inbox
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个巨大的收件箱
- en: 'Typically, heaps are used as priority queues of all kinds. Queues like that
    exist in any resource-constrained environment (and everywhere else, probably),
    but their purpose is to output things in an ordered fashion. By using the number
    of messages to determine the priority of a message notification, the heap can
    do the heavy lifting of this feature. Before jumping into the hard stuff, though,
    here are the bits containing the information:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，堆被用作各种优先队列。这样的队列存在于任何资源受限的环境中（以及其他所有地方），但它们的目的是以有序的方式输出事物。通过使用消息数量来确定消息通知的优先级，堆可以完成这个特性的繁重工作。在深入探讨难点之前，这里有一些包含信息的数据位：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The idea is to use the number of messages as an indicator of which device to
    poll first, which is why the device is required. Using this type, the heap does
    not require any specific node or link types to work:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是使用消息的数量作为指示器，以确定首先轮询哪个设备，这就是为什么需要设备。使用这种类型，堆不需要任何特定的节点或链接类型来工作：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two interesting points here: the underlying structure is a regular
    `Vec<T>`, which was chosen for its expansion capabilities (Rust''s arrays are
    sized at compile time), and the functionality of `push` or `pop`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个有趣的观点：其底层结构是一个常规的 `Vec<T>`，这是因为它具有扩展能力（Rust 的数组在编译时确定大小），以及 `push` 或 `pop`
    的功能。
- en: Another noteworthy modification is that no `Option` is needed, which removes
    a check from the code and makes it easier to read. However, since many of the
    heap's operations work well with a direct, 1-index-based access, indices have
    to be translated before hitting `Vec<T>`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的修改是，不需要 `Option`，这从代码中移除了一个检查，并使其更容易阅读。然而，由于堆的许多操作与直接、基于1的索引访问很好地配合工作，在到达
    `Vec<T>` 之前必须对索引进行转换。
- en: So how does data get in?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，数据是如何进入的？
- en: Getting messages in
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息的进入
- en: 'Once a message arrives, it is pushed to the back of the array when the upheap
    operation "bubbles up" the item until it finds its proper place. In Rust code,
    this is what that looks like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息到达，当上堆操作“冒泡”项目直到找到其适当位置时，它会被推送到数组的末尾。在 Rust 代码中，这看起来是这样的：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Initially, the new notification lives in a `Box` at the back of the `Vec<T>`,
    inserted via `push()`. A simple `while` loop then bubbles up the new addition
    by repeatedly swapping it whenever the `has_more_messages()` function is true.
    When is it true? Let''s see the code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，新的通知位于 `Vec<T>` 的末尾的 `Box` 中，通过 `push()` 插入。然后一个简单的 `while` 循环通过在 `has_more_messages()`
    函数为真时重复交换来冒泡新的添加项。何时为真？让我们看看代码：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By encapsulating this function, it's easily possible to change the heap into
    a min-heap should that be required—and the index translations are wrapped away
    here as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过封装这个函数，如果需要，可以轻松地将堆转换为最小堆——索引转换也在这里封装起来。
- en: Getting data out requires doing this process in reverse in a function called
    `pop()`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 取出数据需要在一个名为 `pop()` 的函数中反向执行这个过程。
- en: Taking messages out
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取出消息
- en: 'Removing the first item in a `Vec<T>` is not difficult—in fact, `Vec<T>` ships
    with a `swap_remove()` function that does exactly what a heap needs: removing
    the first element of a `Vec<T>` by replacing it with the last element! This makes
    the code significantly shorter and therefore easier to reason about:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Vec<T>` 中移除第一个元素并不困难——实际上，`Vec<T>` 随带一个 `swap_remove()` 函数，它正好符合堆的需求：通过用最后一个元素替换它来从
    `Vec<T>` 中移除第一个元素！这使得代码显著缩短，因此更容易推理：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, this code is not short though—so what's amiss? The bubbling down.
    Swapping downward requires to look at the children (which are at the positions
    `i * 2` and `i * 2 + 1`) to find out where (or if) the next iteration should proceed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这段代码并不短——那么有什么问题呢？冒泡下降。向下交换需要查看子节点（位于`i * 2`和`i * 2 + 1`的位置）以确定下一次迭代应该继续的位置。
- en: Wrap up
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The heap data structure is surprisingly simple to implement. There are no lengthy
    unwraps, borrows, or other calls, and the pointer is owned by the `Vec` and can
    easily be swapped. Other than that, the upheap operation is only a `while` loop,
    just like the (slightly more complex) downheap function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 堆数据结构实现起来非常简单。没有冗长的展开、借用或其他调用，指针由`Vec`拥有，可以轻松交换。除此之外，上堆操作只是一个`while`循环，就像（稍微复杂一点的）下堆函数一样。
- en: 'There is another typical use case for a heap though: sorting! Consider a bunch
    of numbers going into the heap instead of `MessageNotification` objects—they would
    come out sorted. Thanks to the efficiency of the upheap/downheap operations, the
    worst-case runtime of that sorting algorithm is great—but more on that in [Chapter
    9](a9ba9f9e-59a2-411f-8998-831fe4e69266.xhtml), *Ordering Things*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，堆的另一个典型用途是排序！考虑将一组数字放入堆中而不是`MessageNotification`对象，它们将按顺序输出。由于上堆/下堆操作的效率，该排序算法的最坏情况运行时间非常好——但更多内容将在[第9章](a9ba9f9e-59a2-411f-8998-831fe4e69266.xhtml)“排序事物”中介绍。
- en: Upsides
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'Compact and low-complexity implementation make the binary heap a great candidate
    for requiring any kind of sorting data structure. Other benefits include the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑且低复杂度的实现使二叉堆成为任何需要排序数据结构的绝佳选择。其他好处包括以下内容：
- en: An efficient way to sort lists
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率很高的列表排序方法
- en: Works well in concurrent situations
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发情况下表现良好
- en: A very efficient way to store a sorted array
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储有序数组的一种非常高效的方法
- en: Yet there are also downsides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一些缺点。
- en: Downsides
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Heaps are generally great, but have two caveats that limit their use:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 堆通常很好，但有两大缺点限制了它们的使用：
- en: Use cases outside of queuing or sorting are rare
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了队列或排序之外的使用场景很少
- en: There are better ways to sort
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有更好的排序方法
- en: 'The binary heap was the last of the binary trees, and the next section will
    cover another rather exotic variation of a tree: the trie.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆是二叉树中的最后一种，下一节将介绍另一种相当奇特的树形结构变体：前缀树。
- en: Trie
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前缀树
- en: The trie is another interesting data structure—in particular, the way in which
    it is pronounced! Depending on your mother tongue, intuition might dictate a way,
    but—according to Wikipedia—the name was selected thanks to Edward Fredkin, who
    pronounced this type of tree differently, namely like **trie** in re**trie**val.
    Many English speakers resort to saying something along the lines of "try" though.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀树是另一种有趣的数据结构——特别是它的发音方式！根据你的母语，直觉可能会指导你一种方法，但——根据维基百科——这个名字是感谢爱德华·弗雷德金，他以前缀树的方式发音这种树，即像在检索中发音**trie**。许多英语使用者倾向于说“try”。
- en: 'With that out of the way, what does the trie actually do for it to deserve
    a different name? It transpires that using retrieval was not a bad idea: tries
    store strings.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这个问题之后，前缀树实际上做了什么，以至于值得有一个不同的名字？结果是使用检索并不是一个坏主意：前缀树存储字符串。
- en: Imagine having to store the entire vocabulary of this book in a way to find
    out whether certain words are contained within the book. How can this be done
    efficiently?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，必须以某种方式存储这本书的全部词汇，以便找出某些单词是否包含在书中。这该如何高效地完成？
- en: After the previous sections, you should already have an answer, but if you think
    about strings—they are stored as arrays or lists of `char` instances—it would
    use a good amount of memory. Since each word has to use letters from the English
    alphabet, can't we use that?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节之后，你应该已经有了答案，但如果考虑字符串——它们作为`char`实例的数组或列表存储——这将使用大量的内存。由于每个单词都必须使用英文字母表中的字母，我们不能利用这一点吗？
- en: 'Tries do something similar. They use characters as nodes in a tree where the
    parent node is the preceding character and all children (limited only by the size
    of the alphabet) are what follows. A trie storing the strings ABB, ABC, CAACB,
    CAACA, BBB, and BBA can be seen in the following trie diagram:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀树做的是类似的事情。它们使用字符作为树中的节点，其中父节点是前面的字符，所有子节点（仅限于字母表的大小）是跟随的。以下是一个存储字符串ABB、ABC、CAACB、CAACA、BBB和BBA的前缀树图：
- en: '![](img/91d88689-25be-4760-b986-aeb4ebe7937f.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91d88689-25be-4760-b986-aeb4ebe7937f.png)'
- en: Storing strings like this enables a very efficient search. You only have to
    walk through the letters in the key that is to be stored to find out (or store)
    whether that string is contained in—for example—a set. In fact, if a string can
    only have a certain size, then the retrieval time is constant and it does not
    matter whether the trie stores 10 or 10 million words. Typically, this is useful
    for set data structures or key-value stores with string keys (such as hashes,
    but more on that later). Just like the binary search tree, this structure has
    a strong hierarchical memory management (that is, no pointers "back up"), making
    it a perfect fit for Rust.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式存储字符串可以非常高效地进行搜索。你只需遍历要存储的键中的字母，就可以找出（或存储）该字符串是否包含在例如集合中。实际上，如果字符串只能有特定的大小，那么检索时间将是恒定的，并且无论trie存储10个还是1000万个单词都无关紧要。通常，这对于集合数据结构或具有字符串键的键值存储（例如散列，但稍后再讨论）很有用。就像二叉搜索树一样，这种结构具有强大的分层内存管理（即没有“回指”的指针），使其非常适合Rust。
- en: Lately, the product team has looked into the user's device keys once again and
    found that the typical IoT device uses keys that represent a path, and they would
    often look like `countryA/cityB/factoryC/machine1/positionX/sensorY`. Reminded
    of the trees that worked so well earlier, they thought that you could use those
    to improve the directory as well. But you already have a better idea!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，产品团队再次查看了用户的设备键，并发现典型的物联网设备使用代表路径的键，它们通常会看起来像`countryA/cityB/factoryC/machine1/positionX/sensorY`。想起了之前工作得很好的树，他们认为可以使用这些来改进目录。但您已经有了更好的想法！
- en: More realistic IoT device management
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更现实的物联网设备管理
- en: Paths like that tend to have a huge overlap, since there are countless sensors
    and devices in a single location. Additionally, they are unique thanks to the
    hierarchical properties and are human-readable in case the sensor needs to be
    found. A great fit for a trie!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路径往往有很大的重叠，因为单个位置中有无数个传感器和设备。此外，由于分层属性，它们是唯一的，并且如果需要找到传感器，它们是可读的。非常适合trie！
- en: 'The basis for this trie will be a node type that stores the children, current
    character, and, if it''s a node that concludes a full key, the `IoTDevice` object
    from earlier in this chapter. This is what this looks like in Rust:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个trie的基础将是一个节点类型，它存储子节点、当前字符，如果是完整键的节点，则存储本章早些时候提到的`IoTDevice`对象。这在Rust中看起来是这样的：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, the children is a different data structure as well: a `HashMap`.
    Maps (also called dictionaries, associative arrays) explicitly store a key alongside
    a value and the word "hash" hints at the method, which will be discussed in the
    next chapter. For now, the `HashMap` guarantees a single character to be associated
    with a Node type, leading the way for iteration. On top of that, this data structure
    allows for a get-or-add type operation, which significantly improves code readability.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，子节点是一个不同的数据结构：一个`HashMap`。映射（也称为字典、关联数组）明确存储一个键和一个值，而“散列”这个词暗示了将在下一章讨论的方法。目前，`HashMap`保证将单个字符与节点类型相关联，从而为迭代铺平道路。除此之外，这种数据结构还允许进行获取或添加类型的操作，这显著提高了代码的可读性。
- en: 'Since the number of possible word beginnings is similar, the root is a `HashMap`
    as well, giving the trie multiple roots:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能的单词开头数量相似，根也是一个`HashMap`，这使得trie有多个根：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In order to fill up these maps with data, a method to add paths is required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充这些映射以数据，需要一个添加路径的方法。
- en: Adding paths
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路径
- en: 'The algorithm for inserting a string into a trie can be described in only a
    few sentences: go through each character of the word and trace it down the trie.
    If a node does not yet exist, create it, and add the object with the last entry.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串插入trie的算法可以用几句话来描述：遍历单词中的每个字符，并沿着trie向下追踪。如果一个节点尚不存在，则创建它，并将对象添加到最后一个条目。
- en: 'Of course, there are special cases that need to be decided as well: what happens
    when a string already exists? Overwrite or ignore? In the case of this implementation,
    the last write will win—that is, it''s overwriting whatever existed previously:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还需要决定一些特殊情况：如果字符串已经存在，会发生什么？覆盖还是忽略？在这个实现中，最后的写入将获胜——也就是说，它将覆盖之前存在的任何内容：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Another special case is the root node, since it's not a real node but a `HashMap`
    right away. Once a trie is set up, the most important thing is to get stuff out
    again!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊情况是根节点，因为它不是一个真正的节点，而是一个`HashMap`。一旦trie设置完成，最重要的事情就是再次获取内容！
- en: Walking
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步行
- en: 'Add and search work in a very similar manner: follow the links to the characters
    of the key and return the "value" in the end:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加和搜索工作非常相似：遵循链接到键的字符，并在最后返回“值”：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since the trie does not store strings in any particular order (or even consistently),
    getting the same data out in a predictable way is tricky! Walking it like a binary
    tree works well enough, but will only be deterministic with respect to the insertion
    order, something that should be kept in mind when testing the implementation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于trie不按任何特定顺序（甚至不一致）存储字符串，以可预测的方式获取相同的数据是棘手的！像二叉树一样遍历它效果足够好，但只有插入顺序是确定的，这在测试实现时应予以注意：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As previously mentioned, this walk is called a breadth-first traversal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种遍历被称为广度优先遍历。
- en: Wrap up
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The trie data structure is a very efficient way of storing and finding strings
    by storing common prefixes, and they are often used in practice. One use case
    is the popular Java search engine Lucene, which uses this structure to store words
    in the search index, but there are plenty of other examples across different fields.
    Additionally, the simplicity is great for implementing a custom trie to store
    entire words or other objects instead of characters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Trie数据结构是一种通过存储公共前缀来高效存储和查找字符串的方法，并且在实践中经常被使用。一个用例是流行的Java搜索引擎Lucene，它使用这种结构来存储搜索索引中的单词，但跨不同领域还有许多其他示例。此外，简单性非常适合实现自定义trie来存储整个单词或其他对象，而不是字符。
- en: Upsides
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'The inherent prefix is great for efficient storage and, apart from that, there
    are the following benefits:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的前缀对于高效存储非常有用，除此之外，还有以下好处：
- en: Easy implementation facilitates customizing
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于实现，便于定制
- en: Minimal memory requirements for sets of strings
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串集合的最小内存需求
- en: Constant-time retrieval for strings with a known maximum length
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于已知最大长度的字符串，检索时间恒定
- en: Exotic algorithms are available (for example, Burst Sort)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了异构算法（例如，Burst Sort）
- en: While the trie is great, it is also fairly simple, which comes with a number
    of downsides.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然trie很棒，但它也很简单，这带来了一系列缺点。
- en: Downsides
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'Tries can work in a lot of shapes and forms, but can''t handle every use case,
    unfortunately. Other disadvantages include the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Tries可以在很多形状和形式中工作，但不幸的是，不能处理每个用例。其他缺点包括以下内容：
- en: It has a name that's strange to pronounce
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个发音奇怪的名称
- en: There is no deterministic order on walking
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历时没有确定性顺序
- en: There are no duplicate keys
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有重复的键
- en: This concludes the more exotic tree varieties. Next up is the B-Tree, which
    is essentially a universal tree!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了更异构的树种类。接下来是B-Tree，它本质上是一种通用树！
- en: B-Tree
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B-Tree
- en: As you have noticed, restricting the number of children to 2 (like the binary
    trees earlier) yields a tree that only lets the algorithm decide whether to go
    left or right, and it's easily hardcoded. Additionally, storing only a single
    key-value pair in a node can be seen as a waste of space—after all, the pointers
    can be a lot larger than the actual payload!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，将子节点的数量限制为2（就像之前的二叉树一样）会产生一个只允许算法决定是向左还是向右走的树，并且很容易硬编码。此外，在节点中仅存储单个键值对可能会被视为空间浪费——毕竟，指针可以比实际的有效负载大得多！
- en: 'B-Trees generally store multiple keys and values per node, which can make them
    more space-efficient (the payload-to-pointer ratio is higher). As a tree, each
    of these (key-value) pairs has children, which hold the values between the nodes
    they are located at. Therefore, a B-Tree stores triples of key, value, and child,
    with an additional child pointer to cover any "other" values. The following diagram
    shows a simple B-Tree. Note the additional pointer to a node holding smaller keys:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: B-Tree通常在每个节点中存储多个键和值，这使得它们更节省空间（有效负载到指针的比率更高）。作为树，这些（键值）对中的每一个都有子节点，它们持有位于节点之间的值。因此，B-Tree存储键、值和子节点三重组合，还有一个额外的子指针来覆盖任何“其他”值。以下图显示了简单的B-Tree。注意指向包含较小键的节点的额外指针：
- en: '![](img/8c99ddbf-3f3d-4424-9b49-6c6aed5f7d5c.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c99ddbf-3f3d-4424-9b49-6c6aed5f7d5c.png)'
- en: As depicted here, a B-Tree can have varying amounts of those key-value pairs
    (only the keys are visible), but they will have a maximum number of children—defined
    by the *order* parameter. Consequently, a binary search tree can be considered
    an order-2 B-Tree, without the added benefit of being self-balancing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，B-Tree可以有不同数量的键值对（只有键是可见的），但它们将有一个最大子节点数——由*顺序*参数定义。因此，二叉搜索树可以被视为一个2阶B-Tree，但没有自平衡的额外好处。
- en: 'In order to achieve the self-balancing nature, a B-Tree has certain properties
    (as defined by Donald Knuth):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现自平衡的特性，B-树具有某些特性（由唐纳德·克努特定义）：
- en: Each node can only have *order* children
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个节点只能有*order*个子节点
- en: Each node that is not a leaf node or root has at least *order/2* children
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何非叶节点或根节点至少有*order/2*个子节点
- en: The root node has at least two children
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根节点至少有两个子节点
- en: All nodes hold *order - 1* keys when they have *order* children
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当节点有*order*个子节点时，所有节点都持有*order - 1*个键
- en: All leaf nodes appear on the same level
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有叶节点都位于同一级别
- en: 'How does self-balancing work? It is way simpler than a red-black tree. Firstly,
    new keys can only be inserted at the leaf level. Secondly, once the new key has
    found a node, the node is evaluated to the preceding rules—in particular, if there
    are now more than *order - 1* keys. If that is the case, the node has to be split,
    moving the center key to the parent node, as shown in the following diagram:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 自平衡是如何工作的？它比红黑树简单得多。首先，新键只能插入到叶级别。其次，一旦新键找到一个节点，该节点就会根据先前的规则进行评估——特别是如果现在有超过*order
    - 1*个键。如果是这样，节点就必须分割，将中心键移动到父节点，如下面的图所示：
- en: '![](img/5bc64dd2-6e9e-48d8-a778-49eef819928d.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bc64dd2-6e9e-48d8-a778-49eef819928d.png)'
- en: Next, the children are put in their intended position (especially important
    if the elevated node had children) and then the process is repeated up the tree
    until the root node is valid.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将子节点放入它们预定的位置（特别是如果提升节点有子节点时尤为重要），然后重复这个过程直到根节点有效。
- en: 'This process creates something that is called a **fat tree** (as opposed to
    a high tree), which means that adding height is only possible through splitting,
    which doesn''t happen very often. In order to work with the nodes, they contain
    additional information about themselves:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程创建了一个被称为**胖树**（与高树相对）的东西，这意味着增加高度只能通过分割来实现，这并不经常发生。为了与节点一起工作，它们包含有关自己的额外信息：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, the type of node is determined by a property, `node_type`, but
    the entire node could be wrapped into an enumeration as well. Furthermore, a special
    variable holding the "left child" has been attached in order to deal with keys
    lower than what is associated with the triples in the `keys` vector.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，节点的类型由一个属性`node_type`确定，但整个节点也可以被封装在一个枚举中。此外，还附加了一个特殊的变量来处理比`keys`向量中关联的三元组相关的键更低的键。 '
- en: Like binary trees, the B-Tree exhibits logarithmic runtime complexity on search
    and insert (*O(log2(n))*) and, with the the simplified rebalancing, they make
    for a great choice for database indices. In fact, many SQL databases (such as
    SQLite and SQL Server) use B-Trees to store those search indices, and B+ Trees
    to store tables thanks to their smart ways of accessing the disk.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉树一样，B-树在搜索和插入操作上表现出对数时间复杂度（*O(log2(n))*)，并且由于简化了重新平衡，它们是数据库索引的绝佳选择。实际上，许多SQL数据库（如SQLite和SQL
    Server）使用B-树来存储这些搜索索引，并使用B+树来存储表，因为它们以智能的方式访问磁盘。
- en: The product team has also heard about this and, since the previous attempts
    at the IoT device management solution have been a huge success, they thought about
    replacing the red-black tree with something better! They want to reduce the number
    of bugs by creating a more simplified version of the original database, so the
    requirements actually stay the same.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 产品团队也听说了这件事，由于之前在物联网设备管理解决方案上的尝试取得了巨大成功，他们考虑用更好的数据结构来替换红黑树！他们希望通过创建一个更简化的原始数据库版本来减少错误数量，因此要求实际上保持不变。
- en: An IoT database
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网数据库
- en: 'As in the previous implementation, this tree builds on the `numerical_id` property
    of `IoTDevice` as keys, and the device object as value. In code, a node looks
    very similar to the previous example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的实施方式，此树基于`IoTDevice`的`numerical_id`属性作为键，并将设备对象作为值。在代码中，节点看起来与之前的示例非常相似：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of triples, this node type uses a synchronized index to find the children
    associated with a specified key-value pair. These pairs are also created ad hoc
    by evaluating the `numerical_id` property of the contained device, thereby also
    simplifying the code and eventual updates to the keys. Something that is missing
    from the node is a parent pointer, which made the entire red-black tree code significantly
    more complex.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与三元组不同，此节点类型使用同步索引来查找与指定键值对关联的子节点。这些对也是通过评估包含的设备的`numerical_id`属性而专门创建的，从而简化了代码和最终对键的更新。节点缺少的是父指针，这使得整个红黑树代码变得更加复杂。
- en: 'The tree itself is stored as an `Option` on a boxed node (aliased as `Tree`),
    along with the `order` and `length` properties:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 树本身存储为一个在boxed节点上的`Option`（别名为`Tree`），以及`order`和`length`属性：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, to check the validity of the tree, here''s a `validate` method that
    recursively finds the minimum and maximum leaf height and checks whether the number
    of children is within bounds (as mentioned in the rules indicated earlier):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查树的合法性，这里有一个`validate`方法，它递归地找到最小和最大叶子高度，并检查子节点数量是否在范围内（如前面提到的规则所示）：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Having established these basic structures, we can move on to how to add new
    devices to the tree.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 建立了这些基本结构之后，我们可以继续讨论如何向树中添加新设备。
- en: Adding stuff
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加内容
- en: 'B-Trees add new entries to their leaves, which then bubble up as nodes grow
    too large. In order to efficiently find a spot, this is done recursively, removing
    and replacing ownership as needed. Here is the `add()` function, which takes care
    of retrieving ownership of the root node and calling the recursive call with an
    existing or new node:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: B-树将新条目添加到其叶子节点，随着节点变得过大，这些条目会像气泡一样上升。为了有效地找到位置，这需要递归地进行，根据需要移除和替换所有权。以下是`add()`函数，它负责检索根节点的所有权，并使用现有或新节点进行递归调用：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Except in the case of the root node, the `add_r()` function (the recursive
    call) returns two pieces of information: the key it descended into and—in case
    of a "promotion"—the device and child that are to be added to whichever node it
    returns to. In principle, this function works as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了根节点的情况外，`add_r()`函数（递归调用）返回两份数据：它下降到的键以及在“提升”的情况下要添加到它返回的任何节点的设备和子节点。原则上，这个函数的工作方式如下：
- en: Recursively find the appropriate leaf and perform a sorted insert.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地找到适当的叶子节点，并执行排序插入。
- en: Increment the length if it's not a duplicate.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不是重复项，则增加长度。
- en: 'If the node now has more keys than are allowed: split.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点现在有比允许的更多的键：分割。
- en: Return the original node and the key with its new value to the caller.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始节点及其新值的关键字返回给调用者。
- en: Place the new node where it came from.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新节点放置在它原来的位置。
- en: Add the promoted key.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加提升后的键。
- en: 'Repeat from step 3 until at the root level:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤3重复，直到到达根级别：
- en: '[PRE38]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since the root node is a special case where a new level is added to the tree,
    this has to be taken care of where the last split is happening—in the `add_r()`
    function. This is as simple as creating a new non-leaf node and adding the former
    root to the left and its sibling to the right, placing the new parent on top as
    the root node.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于根节点是一个特殊情况，其中在树中添加了一个新层级，因此必须在最后一个分割发生的地方处理这个问题——在`add_r()`函数中。这就像创建一个新的非叶子节点，将前一个根节点放在左边，其兄弟节点放在右边，将新父节点放在顶部作为根节点。
- en: 'In this implementation, a lot of the heavy lifting is done by the node''s implementation
    of several functions, including `split()`. While this is complex, it encapsulates
    the inner workings of the tree—something that should not be exposed too much so
    as to facilitate change:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，大量的繁重工作是由节点的几个函数的实现完成的，包括`split()`。虽然这很复杂，但它封装了树的内部工作原理——这一点不应该过多暴露，以便于变更：
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As described previously, splitting yields a new sibling to the original node
    and a new parent to both of them. The sibling will receive the upper half of the
    keys, the original node remains with the lower half, and the one in the center
    becomes the new parent.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，分割会产生一个新兄弟节点和两个新父节点。兄弟节点将接收键的上半部分，原始节点保留下半部分，中间的节点成为新的父节点。
- en: Having added several devices, let's talk about how to get them back out.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了几个设备后，让我们谈谈如何将它们取回。
- en: Searching for stuff
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索内容
- en: 'A B-Tree''s search works just the way binary tree searches do: recursively
    checking each node for the path to follow. In B-Trees, this becomes very convenient
    since it can be done in a loop, in this case, by the `get_device()` function:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: B-树的搜索工作方式与二叉树搜索相同：递归地检查每个节点以确定路径。在B-树中，这变得非常方便，因为它可以在循环中完成，在这种情况下，由`get_device()`函数完成：
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function is implemented at the node structure and does a regular linear
    search for the key itself. If it is unable to find that key, the `find_r()` function
    has to decide whether to continue, which it does by evaluating the node type.
    Since leaf nodes don''t have any children, not finding the desired key will end
    the search, returning `None`. Regular nodes allow the search to continue on a
    deeper level of the tree:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在节点结构中实现，并对键本身进行常规线性搜索。如果找不到该键，`find_r()`函数必须决定是否继续，它通过评估节点类型来决定。由于叶节点没有子节点，找不到所需的键将结束搜索，返回`None`。常规节点允许在树的更深层继续搜索：
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another method for finding something within the tree's values is walking the
    tree.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在树值中查找某物的另一种方法是遍历树。
- en: Walking the tree
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历树
- en: 'Similarly to the binary trees earlier in this chapter, walking can be done
    with different strategies, even if there are many more branches to walk. The following
    code shows an in-order tree walking algorithm, where the callback is executed
    between the left child and before descending into the child that is currently
    looked at:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面提到的二叉树类似，遍历可以使用不同的策略进行，即使需要遍历的分支更多。以下代码展示了中序树遍历算法，其中回调函数在左子节点和当前查看的子节点之前执行：
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Thanks to the internal sorting, this walk retrieves the keys in an ascending
    order.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内部排序，这种遍历可以按升序检索键。
- en: Wrap up
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: B-Trees are awesome. They are widely used in real-world applications, their
    implementation in Rust is not all that complex, and they maintain a great performance
    regardless of insertion order. Furthermore, the tree's order can dramatically
    improve performance by decreasing the tree's height. It is recommended to estimate
    the number of key-value pairs beforehand and adjust the order accordingly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: B-树很棒。它们在现实世界的应用中广泛使用，Rust中的实现并不复杂，并且无论插入顺序如何都能保持良好的性能。此外，通过减少树的高度，树的顺序可以显著提高性能。建议事先估计键值对的数量并相应地调整顺序。
- en: 'As a benchmark, let''s evaluate the trees by inserting 100,000 unsorted, unique
    elements, and retrieving them using `find()`. Dot size represents the variance,
    while the values shown along the *y* axis are nanoseconds:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基准，让我们通过插入100,000个未排序的唯一元素并使用`find()`检索它们来评估这些树。点的大小表示方差，而沿*Y*轴显示的值是纳秒：
- en: '![](img/320a2f24-c980-4899-a5cb-27c43debf797.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/320a2f24-c980-4899-a5cb-27c43debf797.png)'
- en: The chart output of Unsorted find ()
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 未排序查找的图表输出
- en: Other than that, it performs at the level of other trees, with vastly fewer
    lines of code and less code complexity, both of which impact readability and maintainability
    for other developers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，它的性能与其他树相当，但代码行数和代码复杂度都大大减少，这对其他开发者的可读性和可维护性都有影响。
- en: Upsides
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'This type of tree achieves great performance with the order parameter set accordingly:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此类树在设置相应的顺序参数时可以达到极高的性能：
- en: Less complex to implement than other self-balancing trees
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比其他自我平衡树实现起来更简单
- en: Widely used in database technology
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛应用于数据库技术
- en: Predictable performance thanks to self-balancing
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于自我平衡，性能可预测
- en: Range queries are possible
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以进行范围查询
- en: Variants that minimize disk access (B+ Tree)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化磁盘访问的变体（B+树）
- en: The tree's downsides are few.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 树的缺点很少。
- en: Downsides
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: Absolute performance depends significantly on the tree's order; other than that,
    this tree does not have many downsides.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对性能在很大程度上取决于树的顺序；除此之外，此树没有很多缺点。
- en: Graphs
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表
- en: 'In their most generic form, trees are graphs—directed, acyclic graphs. A general
    graph can be described as a collection of connected nodes, sometimes referred
    to as vertices, with certain properties such as whether cycles are allowed. The
    connections between those also have their own name: edges. These edges can have
    certain properties as well, in particular, weights and directions (like one-way
    streets).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们最通用的形式中，树是图——有向无环图。一个通用图可以被描述为节点集合，有时被称为顶点，具有某些属性，例如是否允许循环。这些节点之间的连接也有自己的名称：边。这些边也可以具有某些属性，特别是权重和方向（如单行道）。
- en: 'By enforcing these constraints, a model can be built that, just like trees,
    reflects a certain reality very well. There is one particular thing that is typically
    represented as a weighted graph: the internet. While, nowadays, this might be
    an oversimplification, with various versions of the Internet Protocol (IPv4 and
    IPv6) and **Network Address Translation** (**NAT**) technologies hiding large
    numbers of participants online, in its earlier days, the internet could be drawn
    as a collection of routers, computers, and servers (nodes) interconnected with
    links (edges) defined by speed and latency (weights).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制实施这些约束，可以构建一个模型，就像树一样，很好地反映了某种现实。有一件事通常被表示为加权图：互联网。虽然现在这可能是过度简化，因为各种版本的互联网协议（IPv4和IPv6）和**网络地址转换**（NAT）技术隐藏了大量的在线参与者，但在其早期，互联网可以被描绘为由路由器、计算机和服务器（节点）通过定义速度和延迟（权重）的链接（边）相互连接的集合。
- en: 'The following diagram shows a random, undirected, unweighted graph:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了一个随机、无向、无权图：
- en: '![](img/d334d74d-a7fe-4d1b-9ae7-afeb995e1afd.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d334d74d-a7fe-4d1b-9ae7-afeb995e1afd.png)'
- en: Other than humans, who can typically see and follow a reasonably efficient path
    through this mesh of interconnected nodes, computers require specific instructions
    to find anything in there! This called for new algorithms that allow for dealing
    with this complexity—which is especially tricky once the number of nodes in the
    mesh exceeds the number of nodes that can be looked at in time. This led to the
    development of many routing algorithms, techniques to finding cycles and segmenting
    the network, or popular NP-hard problems, such as the traveling salesman problem
    or the graph-coloring problem. The traveling salesman problem is defined as follows.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了人类，人类通常可以合理高效地通过这个相互连接的节点网络找到路径，而计算机需要特定的指令来在其中找到任何东西！这需要新的算法来处理这种复杂性——一旦网络中的节点数超过在时间内可以查看的节点数，这尤其棘手。这导致了许多路由算法的发展，以及寻找循环和分割网络的技术，或者流行的NP难问题，如旅行商问题或图着色问题。旅行商问题定义如下。
- en: 'Find the optimal (shortest) path between cities without visiting one twice.
    On the left are some cities in Europe; on the right, two possible solutions (dotted
    versus solid lines):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 找到城市之间的最优（最短）路径，且不重复访问任何一个城市。在左侧是一些欧洲城市；在右侧，两种可能的解决方案（虚线与实线）：
- en: '![](img/6ab202ba-48ca-4742-a8eb-2c52e0348ebe.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ab202ba-48ca-4742-a8eb-2c52e0348ebe.png)'
- en: Today, there are many examples of graphs, the most obvious being a social graph
    (in social networks), but also as part of TensorFlow's deep learning API, state
    machines, and the rise of graph databases that offer a generic query language
    to traverse graphs. Even some less obvious use cases can be found, such as storing
    genetic sequences (nodes being the small parts of the DNA)!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有许多图的例子，最明显的是社交图（在社交网络中），但也是TensorFlow深度学习API、状态机以及提供通用查询语言以遍历图的图数据库的一部分。甚至可以找到一些不那么明显的用例，例如存储遗传序列（节点是DNA的小部分）！
- en: 'To get out of theoretical constructs, how would you represent a graph in a
    program *efficiently*? As a node structure with a list of outbound vertices? How
    would you find a particular node then? A tricky problem! Graphs also have the
    habit of growing quite large, as anyone who ever wanted to serialize object graphs
    to JSON can testify: they run out of memory quite easily.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跳出理论构建，你如何在程序中**高效**地表示一个图？作为一个具有出度顶点列表的节点结构？那么你将如何找到特定的节点？这是一个棘手的问题！图也有一个习惯，那就是会变得相当大，任何曾经想要将对象图序列化为JSON的人都可以证明：它们很容易耗尽内存。
- en: 'The best way to work with this data structure is surprisingly simple: a matrix.
    This matrix can either be sparse (that is, a list of lists with varying sizes),
    called an **adjacency list**, or a full-blown matrix (adjacency matrix). Especially
    for a matrix, the size is typically the number of nodes on either side and the
    weights (or Boolean values representing "connected" or "not connected") at each
    crossing. Many implementations will also keep the "real" nodes in its own list,
    using the indices as IDs. The following diagram shows how to display a graph as
    a matrix:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种数据结构的最简单方法是惊人的：一个矩阵。这个矩阵可以是稀疏的（即大小不一的列表的列表），称为**邻接表**，或者是一个完整的矩阵（邻接矩阵）。特别是对于矩阵，其大小通常是任意一边的节点数以及每个交叉处的权重（或表示“连接”或“未连接”的布尔值）。许多实现还会在它自己的列表中保留“真实”的节点，使用索引作为ID。以下图示展示了如何将图显示为矩阵：
- en: '![](img/30d9f986-73f7-43d2-95b7-86c0f0d2fd54.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30d9f986-73f7-43d2-95b7-86c0f0d2fd54.png)'
- en: 'Rust provides many great tools for implementing really complex graph structures:
    enumerations and pattern-matching provide ways to operate on types of nodes and
    edges with low overhead, while iterators and functional approaches remove the
    need for verbose loops. Let''s look at a generic graph structure in Rust:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Rust提供了许多实现复杂图结构的优秀工具：枚举和模式匹配提供了以低开销操作节点和边类型的方法，而迭代器和函数式方法则消除了对冗长循环的需求。让我们看看Rust中的一个通用图结构：
- en: '[PRE43]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This adjacency list can store nodes and whether they are connected, making this
    a finite, undirected, unweighted graph—great for storing simple relationships
    between objects. Already, a data structure such as this has the ability to implement
    sophisticated routing algorithms or run out of resources on a backtracking algorithm.
    In an adjacency list, each index in the list represents the origin of an edge
    and the contained elements (also lists) are any outbound edges. To traverse the
    graph, start at an origin index and find the next index by searching its edges.
    Then repeat until arriving at the destination node!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个邻接列表可以存储节点以及它们是否连接，这使得它成为一个有限的无向无权图——非常适合存储对象之间简单的关系。已经，这样的数据结构有能力实现复杂的路由算法或在回溯算法中耗尽资源。在邻接列表中，列表中的每个索引代表边的起点，包含的元素（也是列表）是任何出边。要遍历图，从起点索引开始，通过搜索其边找到下一个索引。然后重复，直到到达目标节点！
- en: 'When the product team heard of this amazing data structure—and they are now
    well aware of your abilities—they came up with a new product: the literal Internet
    of Things (it''s a working title). Their idea is to provide customers with a way
    to model complex sensor placements that would have distance built in! Customers
    can then go and evaluate all sensors that are within a certain range of each other,
    find single points of failure, or plan a route to inspect them quickly.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当产品团队听到这个惊人的数据结构——并且他们现在非常了解你的能力——他们提出了一个新产品：字面意义上的物联网（这是一个工作标题）。他们的想法是为客户提供一种方式来模拟具有内置距离的复杂传感器放置！客户可以然后去评估彼此之间距离在某个范围内的所有传感器，找到单个故障点，或规划快速检查它们的路线。
- en: 'To summarize, customers should be able to do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，客户应该能够做到以下事情：
- en: Create or add a list of nodes
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或添加节点列表
- en: Connect nodes with their physical distance to each other
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据节点之间的物理距离连接节点
- en: Find the shortest path between two nodes with respect to the distance provided
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据提供的距离找到两个节点之间的最短路径
- en: Retrieve a list of neighbors of a specified node, up to a certain degree
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取指定节点的邻居列表，直到一定度数
- en: Great idea, right? A great fit for graphs as well.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的想法，对吧？非常适合图。
- en: The literal Internet of Things
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面意义上的物联网
- en: 'In order to get a head start on these requirements, the decision for a graph
    representation has to be made: list or matrix? Both work well, but for explanatory
    reasons, the examples will go with an adjacency list built on top of a vector
    of vectors:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在这些要求上取得领先，必须做出选择图表示的方法：列表还是矩阵？两者都工作得很好，但出于解释原因，示例将使用基于向量向量的邻接列表：
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As previously mentioned, it makes sense to keep the actual values, identifiers,
    or even entire objects in their own list and simply work with indices of the `usize`
    type. The edge structure in this example could be represented as a tuple just
    as well, but it''s way more readable this way:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将实际值、标识符甚至整个对象保留在其自己的列表中，并简单地使用`usize`类型的索引进行工作是有意义的。在这个示例中，边的结构可以表示为一个元组，但这样更易于阅读：
- en: '[PRE45]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Having those two structures in place, adding nodes (or... things) to the graph
    can be done with only a few lines:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这两个结构之后，只需几行代码就可以向图中添加节点（或...事物）：
- en: '[PRE46]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Within that function, there is a crucial check that''s made: every edge has
    to connect to a valid node, otherwise it will not be added to the graph. To achieve
    this, the code looks up the IDs provided in the `edges` parameter in its internal
    node storage to find the index it''s at, something that is done by the `position()`
    function of Rust''s iterator trait. It returns the position of when the provided
    predicate returns true! Similarly, the `filter_map()` function of the iterator
    will only include elements that evaluate to `Some()` (as opposed to `None`) in
    its result set. Therefore, the nodes have to have a setter that also initializes
    the adjacency list:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，有一个关键的检查：每个边必须连接到一个有效的节点，否则它将不会被添加到图中。为了实现这一点，代码在其内部节点存储中查找`edges`参数中提供的ID，以找到其索引，这是通过Rust的迭代器特质的`position()`函数完成的。它返回当提供的谓词返回true时的位置！同样，迭代器的`filter_map()`函数将只包括其结果集中评估为`Some()`（而不是`None`）的元素。因此，节点必须有一个设置器，该设置器也会初始化邻接表：
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once that's done, the graph is ready to use. How about we go looking for neighbors
    first?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，图就准备好了。我们首先去找邻居怎么样？
- en: Neighborhood search
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻域搜索
- en: 'Neighborhood search is a very trivial algorithm: starting from the node provided,
    follow every edge and return what you find. In our case, the degree of the relationship
    is important.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 邻域搜索是一个非常简单的算法：从提供的节点开始，跟随每条边，并返回你找到的内容。在我们的案例中，关系度很重要。
- en: Just like for the tree algorithms shown previously, recursion is a great choice
    for solving this problem. While an iterative solution will often be more memory-efficient
    (no stack overflows), recursion is way more descriptive once you get the hang
    of it. Additionally, some compilers (and partly `rustc`, but not guaranteed) will
    expand the recursion into a loop, providing the best of both worlds (look for
    tail call optimization)! Obviously, the most important thing is to have a projected
    growth in mind; 100,000 recursive calls are likely to fill up the stack.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前展示的树算法一样，递归是解决这个问题的好选择。虽然迭代解决方案通常会更节省内存（没有栈溢出），但一旦你掌握了递归，它就更加描述性强。此外，一些编译器（包括部分`rustc`，但不保证）会将递归展开成循环，提供两者的最佳结合（寻找尾调用优化）！显然，最重要的是要有预期的增长；10万个递归调用很可能会填满栈。
- en: 'However, the function to run the neighborhood is implemented two-fold. First,
    the public-facing function takes care of validating input data and sees whether
    the node actually exists:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行邻域的函数是双重的实现。首先，面向公众的函数负责验证输入数据，并查看节点是否实际上存在：
- en: '[PRE48]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With that out of the way, the recursive call can create a list of all its neighbors
    and run the same call on each of them. Returning a set of nodes eliminates the
    duplicates as well:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，递归调用可以创建一个包含所有邻居的列表，并对每个邻居运行相同的调用。返回一组节点也消除了重复：
- en: '[PRE49]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since the recursive call returns the internal representation (that is, indices),
    the outer function translates those back into data the user can understand. This
    function can serve as a basis for other features, such as intersecting the neighborhoods
    of two nodes, and vicinity search. Or, to make it more real, on a sensor outage,
    the company can check whether there is a common device that''s responsible (intersection),
    or if other close-by sensors are reporting similar measurements to rule out malfunctions
    (neighborhood search). Now, let''s move on to something more complex: finding
    the shortest path.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 由于递归调用返回内部表示（即索引），外部函数将这些转换回用户可以理解的数据。这个函数可以作为其他功能的基础，例如交叉两个节点的邻域，以及邻近搜索。或者，更实际一点，在传感器故障的情况下，公司可以检查是否存在一个共同设备负责（交叉），或者是否有其他附近的传感器报告了类似的测量结果，以排除故障（邻域搜索）。现在，让我们继续更复杂的事情：寻找最短路径。
- en: The shortest path
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最短路径
- en: 'This algorithm has its roots in early networking: routers had to decide where
    to forward packets to, without having any knowledge of what''s beyond. They simply
    had to make the best decision without having perfect information! Edsger Dijkstra,
    one of the pioneers of computer science, then came up with a graph-routing algorithm
    that has been named after him: Dijkstra''s algorithm.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的根源在于早期的网络：路由器必须决定将数据包转发到何处，而没有关于其背后的任何知识。他们只能在没有完美信息的情况下做出最佳决定！计算机科学的先驱之一Edsger
    Dijkstra提出了一个以他的名字命名的图路由算法：Dijkstra算法。
- en: The algorithm works iteratively and goes over each node to add up their weights,
    thereby finding the distance (or cost) of reaching this node. It will then continue
    at the node with the lowest cost, which makes this algorithm a "greedy" algorithm.
    This continues until the desired node is reached or there are no more nodes to
    evaluate.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法迭代工作，遍历每个节点以累加它们的权重，从而找到到达该节点的距离（或成本）。然后，它将继续在成本最低的节点上操作，这使得该算法成为一个“贪婪”算法。这会一直持续到达到所需的节点或没有更多节点可以评估。
- en: Algorithms that immediately converge toward what's best right now (**local optimum**)
    in order to find the best overall solution (**global optimum**) are called **greedy
    algorithms**. This, of course, is tricky, since the path to a global optimum might
    require the acceptance of an increased cost! There is no guaranteed way to finding
    the global optimum, so it's about reducing the probability of getting stuck in
    a local optimum. A well-known greedy algorithm in 2018 is stochastic gradient
    descent, which is used to train neural networks.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 立即收敛到当前最佳（**局部最优解**）以找到最佳整体解决方案（**全局最优解**）的算法被称为**贪婪算法**。这当然很棘手，因为到达全局最优解的路径可能需要接受成本的增加！没有保证找到全局最优解的方法，所以这是关于减少陷入局部最优解的概率。2018年一个著名的贪婪算法是随机梯度下降，它用于训练神经网络。
- en: 'In code, this is what that looks like:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，它看起来是这样的：
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since this is a long one, let''s break it down. This is boiler-plate code to
    ensure that both source and destination nodes are nodes in the graph:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一段较长的代码，让我们将其分解。这是确保源节点和目标节点都是图中的节点的样板代码：
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then, each node gets a tentative weight assigned, which is infinite in the beginning,
    except for the origin node, which has zero cost to reach. The "open" list, which
    contains all the nodes yet to be processed, is conveniently created using Rust's
    range—as it corresponds to the indices we are working with.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个节点都会分配一个试探性权重，初始时为无限大，除了原节点，其到达成本为零。“开放”列表，包含所有尚未处理的节点，方便地使用Rust的范围创建——因为它对应于我们正在处理的索引。
- en: The parent array keeps track of each node's parent once the lower cost is established,
    which provides a way to trace back the best possible path!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了较低的成本，父数组会跟踪每个节点的父节点，这提供了一种追踪最佳可能路径的方法！
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's plunge into the path-finding. The helper function, `min_index()`,
    takes the current distances and returns the index of the node that is easiest
    (as in lowest distance) to reach next. This node will then be removed from the
    open list. Here's a good point at which to also stop if the destination has been
    reached. For more thoughts on this, see the preceding information box on greedy
    algorithms. Setting `found` to `true` will help distinguish between no result
    and early stopping.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨路径查找。辅助函数`min_index()`接受当前距离并返回下一个最容易到达（即距离最低）的节点的索引。然后，这个节点将从开放列表中移除。如果已经到达目的地，这也是一个停止的好时机。关于这方面的更多思考，请参阅关于贪婪算法的前一个信息框。将`found`设置为`true`将有助于区分无结果和提前停止。
- en: 'For each edge of this node, the new distance is computed and, if lower, inserted
    into a distance list (as seen from the source node). There are a lot of clones
    going on as well, which is due to ensuring not borrowing while updating the vector.
    With `u64` (or `u32`) types, this should not create a large overhead (pointers
    are typically that large too), but for other types, this can be a performance
    pitfall:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个节点的每条边，都会计算新的距离，如果更低，则将其插入到距离列表中（从源节点看）。由于在更新向量时确保不借用，因此会有很多克隆操作。对于`u64`（或`u32`）类型，这不应该产生很大的开销（指针通常也这么大），但对于其他类型，这可能会成为性能陷阱：
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After this loop exits, there is a distance array and a parent array to be prepared
    for returning to the caller. First, trace back the path from the destination to
    the origin node in the parent array, which leads to the reverse optimal path between
    the two nodes:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环退出后，需要准备一个距离数组和父数组以便返回给调用者。首先，在父数组中从目标节点追踪回原节点，这将导致两个节点之间的反向最优路径：
- en: '[PRE54]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By strictly following the node with the lowest distance, Dijkstra's algorithm
    achieves a great runtime when stopping early, and runtime can even be improved
    by using more efficient data structures (such as a heap) to fetch the next node
    efficiently.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过严格遵循距离最低的节点，Dijkstra算法在提前停止时实现了很好的运行时间，并且可以通过使用更有效的数据结构（如堆）来有效地获取下一个节点来进一步提高运行时间。
- en: Modern approaches to shortest paths in a graph typically use the *A** (pronounced
    "a star") algorithm. While it operates on the same principles, it is also a bit
    more complex and would therefore go beyond the scope of this book.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的最短路径的现代方法通常使用*A*（发音为“a star”）算法。虽然它基于相同的原理，但也稍微复杂一些，因此超出了本书的范围。
- en: Wrap up
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'A graph is surprisingly straightforward to implement: clear ownership in adjacency
    lists or matrices makes them almost effortless to work with! On top of that, there
    are two additional aspects that weren''t yet covered in this implementation: an
    enumeration with an implementation, and using regular operations (here: comparison)
    with this implementation.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图的实现非常简单：在邻接表或矩阵中清晰的拥有权使得它们几乎无需费力即可使用！除此之外，还有两个尚未在本实现中涵盖的额外方面：枚举及其实现，以及使用常规操作（此处：比较）与本实现。
- en: This shows how conforming to standard interfaces provides great ways to interface
    with the standard library or well-known operations in addition to the flexibility
    enumerations provide. With a few lines of code, infinity can be represented and
    worked with in a readable way. It was also a step toward more algorithmic aspects,
    which will be covered later in the book. For now, let's focus on graphs again.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明遵守标准接口提供了很好的方式，除了枚举提供的灵活性外，还可以与标准库或知名操作进行接口。只需几行代码，就可以以可读的方式表示和操作无穷大。这也有助于更算法化的方面，这些方面将在本书的后续章节中介绍。现在，让我们再次专注于图。
- en: Upsides
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'Graph structures are unique and there are rarely other ways of achieving the
    same outcome. Working in this environment enables you to focus deeply on relationships
    and think about problems differently. Following are some upsides of using graphs:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图结构独特，很少有其他方法可以达到相同的效果。在这个环境中工作使你能够深入关注关系，并以不同的方式思考问题。以下是使用图的一些优点：
- en: Are amazing in modeling relationships
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在建模关系方面非常出色
- en: Efficient retrieval of dependencies of a specific node
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效检索特定节点的依赖关系
- en: Simplify complex abstractions
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化复杂抽象
- en: Enable certain problems to be solved at all
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使某些问题得以解决
- en: Whether you choose a matrix or list representation is often a subjective choice
    and, for example, while the matrix provides easy deletes, a list stores edges
    more efficiently in the first place. It's all a trade-off.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择矩阵或列表表示通常是主观的选择，例如，虽然矩阵提供了简单的删除操作，但列表首先以更有效的方式存储边。这全都是权衡的结果。
- en: Downsides
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'This leads us to the downsides of this particular data structure:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们想到了这种特定数据结构的缺点：
- en: Unable to solve certain problems efficiently (for example, a list of all nodes
    that have a certain property)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法高效地解决某些问题（例如，具有特定属性的节点列表）
- en: More resource-inefficient
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更低效的资源利用率
- en: Unsolved problems exist (for example, the traveling salesman problem with a
    high number of cities)
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在未解决的问题（例如，具有大量城市的旅行商问题）
- en: Typically requires a problem to be reconsidered
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常需要重新考虑问题
- en: With this, we can conclude this chapter about trees and their relatives after
    a summary.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以总结本章关于树及其相关内容。
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter went deep into trees, starting off with the simplest form: the
    binary search tree. This tree prepares the inserted data for search by creating
    a left and a right branch which hold smaller or greater values. A search algorithm
    can therefore just pick the direction based on the current node and the value
    coming in, thereby skipping a majority of the other nodes.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了树，从最简单的形式开始：二叉搜索树。此树通过创建一个左分支和一个右分支来准备插入的数据，这两个分支分别持有较小的或较大的值。因此，搜索算法可以根据当前节点和传入的值选择方向，从而跳过大多数其他节点。
- en: 'The regular binary search tree has a major drawback, however: it can become
    unbalanced. Red-black trees provide a solution for that: by rotating subtrees,
    a balanced tree structure is maintained and search performance is guaranteed.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，常规的二叉搜索树有一个主要的缺点：它可能变得不平衡。红黑树为此提供了一个解决方案：通过旋转子树，保持平衡的树结构，并保证搜索性能。
- en: Heaps are a more exotic use of the tree structure. With their primary use as
    a priority queue, they efficiently produce the lowest or highest number of an
    array in constant time. The upheap and downheap operations repair the structure
    upon insert or removal so that the root is again the lowest (min-heap) or highest
    (max-heap) number.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是对树结构的一种更奇特的使用。它们的主要用途是优先队列，它们可以高效地在常数时间内产生数组中的最低或最高数字。上移和下移操作在插入或删除时修复结构，使得根节点再次是最低（最小堆）或最高（最大堆）数字。
- en: Another very exotic structure is the trie. They are specialized in holding strings
    and very efficiently find the data associated with a certain string by combining
    the characters as nodes with words "branching off" as required.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常奇特的结构是trie。它们专门用于存储字符串，并且通过将字符作为节点，并以所需的方式“分支”单词，非常高效地找到与特定字符串关联的数据。
- en: To go up in the generalization level, B-Trees are a generic form of a tree.
    They hold several values, with the ranges between them leading to a child node.
    Similar to red-black trees, they are balanced, and adding nodes only happens at
    the leaves where they may be "promoted" to a higher level. Typically, these are
    used in database indices.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 要提高泛化水平，B-树是树的一种通用形式。它们持有多个值，它们之间的范围导致一个子节点。类似于红黑树，它们是平衡的，并且节点只添加到叶子节点，在那里它们可能被“提升”到更高的级别。通常，这些用于数据库索引。
- en: 'Last but not least, the most generic form of a tree: the graph. Graphs are
    a flexible way to express constrained relationships, such as no cycles, and directionality.
    Typically, each node has weighted connections (edges) that provide some notion
    of cost of transitioning between the nodes.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，树的最通用形式：图。图是一种灵活的方式来表达受限制的关系，例如没有循环和方向性。通常，每个节点都有加权连接（边），这提供了在节点之间转换的成本概念。
- en: With some of the essential data structures covered, the next chapter will explore
    sets and maps (sometimes called dictionaries). In fact, some of those have already
    been used in this chapter, so the next chapter will focus on implementing our
    own.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了一些基本的数据结构之后，下一章将探讨集合和映射（有时称为字典）。实际上，其中一些已经在本章中使用过了，所以下一章将专注于实现我们自己的。
- en: Questions
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does a binary search tree skip several nodes when searching?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树在搜索时如何跳过几个节点？
- en: What are self-balancing trees?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是自平衡树？
- en: Why is balance in a tree important?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么树中的平衡很重要？
- en: Is a heap a binary tree?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆是一种二叉树吗？
- en: What are good use cases for tries?
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tries有哪些好的用例？
- en: What is a B-Tree?
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是B-树？
- en: What are the fundamental components of a graph?
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的基本组成部分是什么？
