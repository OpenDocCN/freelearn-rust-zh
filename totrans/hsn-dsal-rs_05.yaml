- en: Robust Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lists are great for storing a bunch of items, but what about looking up specific
    elements? In the previous chapter, a skip list greatly outperformed a regular
    linked list when simply finding an item. Why? Because it was utilizing an iteration
    strategy that resembles that of a balanced tree structure: there, the internal
    order lets the algorithm strategically skip items. However, that''s only the beginning.
    Many libraries, databases, and search engines are built on trees; in fact, whenever
    a program is compiled, the compiler creates an abstract syntax tree.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Tree-based data structures incorporate all kinds of smart ideas that we will
    explore in this chapter, so you can look forward to the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and understanding a binary search tree
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about self-balancing trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How prefix or suffix trees work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a priority queue uses internally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs, the most general tree structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary search tree
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tree structure is almost like a linked list: each node has branches—in the
    case of a binary tree, there are two—which represent children of that node. Since
    these children have children of their own, the node count grows exponentially,
    building a hierarchical structure that looks like a regular tree turned on its
    head.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees are a subset of these structures with only two branches, typically
    called left and right. However, that does not inherently help the tree's performance.
    This is why using a *binary search tree*, where left represents the smaller or
    equal value to its parent, and right anything that's greater than that parent
    node, was established!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'If that was confusing, don''t worry; there will be code. First, some vocabulary
    though: what would you call the far ends of the tree? Leaves. Cutting off branches?
    Pruning. The number of branches per node? Branching factor (binary trees have
    a branching factor of 2).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, with that out of the way, the nodes can be shown—although they look
    a lot like the doubly linked list from the previous chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, the tree structure itself is only a pointer to the root node:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Yet before you can get comfortable with the new data structure, the product
    team from the previous chapter is back! You did a great job improving the transaction
    log and they want to continue that progress and build an **Internet of Things**
    (**IoT**) device management platform so users can register a device with a numerical
    name and later search for it. However, the search has to be fast or really fast,
    which is especially critical since many customers have announced the incorporation
    of more than 10,000 devices into the new system!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Isn't this a great opportunity to get more experience with a binary search tree?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: IoT device management
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device management in the IoT space is mostly about storing and retrieving specific
    devices or device twins. These objects typically store addresses, configuration
    values, encryption keys, or other things for small devices so nobody has to connect
    manually. Consequently, keeping an inventory is critical!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网空间中的设备管理主要关于存储和检索特定的设备或设备孪生。这些对象通常存储地址、配置值、加密密钥或其他东西，以便没有人需要手动连接。因此，保持库存至关重要！
- en: 'For now, the product team settled on a numerical "name", to be available faster
    than the competition, and to keep the requirements short:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，产品团队决定采用数字“名称”，以便比竞争对手更快地可用，并保持要求简短：
- en: Store IoT device objects (containing the IP address, numerical name, and type)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储物联网设备对象（包含IP地址、数字名称和类型）
- en: Retrieve IoT objects by numerical name
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数字名称检索物联网对象
- en: Iterate over IoT objects
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历物联网对象
- en: 'A great use for a tree: the numerical name can be used to create a tree and
    search for it nice and quickly. The basic object for storing this IoT device information
    looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 树的一个很好的用途：数字名称可以用来创建一个树并快速搜索它。存储此物联网设备信息的基本对象看起来像这样：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For simplicity, this object will be used in the code directly (adding generics
    isn''t too tricky, but would go beyond the scope of this book):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这个对象将在代码中直接使用（添加泛型并不太复杂，但会超出本书的范围）：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Starting with this basic implementation, the requisite operations, `add` and
    `find`, can be implemented.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个基本实现开始，可以实施必要的操作，`add`和`find`。
- en: More devices
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多设备
- en: 'Unlike lists, trees make a major decision on insert: which side does the new
    element go to? Starting at the root node, each node''s value is compared to the
    value that is going to be inserted: is this greater than or less than that? Either
    decision will lead down a different subtree (left or right).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表不同，树在插入时做出一个主要决定：新元素将放在哪一侧？从根节点开始，每个节点的值与将要插入的值进行比较：这是否大于或小于那个值？任一决定都会导致向下进入不同的子树（左或右）。
- en: 'This process is (usually recursively) repeated until the targeted subtree is
    `None`, which is exactly where the new value is inserted—as a leaf of the tree.
    If this is the first value going into the tree, it becomes the root node. There
    are some problems with this, and the more experienced programmers will have had
    a strange feeling already: what happens if you insert numbers in ascending order?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程（通常是递归地）重复，直到目标子树为`None`，这正是新值插入的位置——作为树的叶子。如果这是第一个进入树中的值，它就成为根节点。这里有一些问题，更有经验的程序员可能已经有一种奇怪的感觉：如果你按升序插入数字会发生什么？
- en: 'These feelings are justified. Inserting in ascending order (for example, `1`,
    `2`, `3`, `4`) will lead to a tree that is basically a list in disguise! This
    is also called a (very) unbalanced tree and won''t have any of the benefits of
    other trees:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些感觉是有道理的。按升序插入（例如，`1`，`2`，`3`，`4`）将导致一个基本上是伪装成列表的树！这也被称为（非常）不平衡的树，将不会有其他树的所有好处：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'During this chapter, we are going to go a lot more things on balancing trees
    and why that is important in order to achieve high performance. In order to avoid
    this pitfall associated with binary search trees, the first value to insert should
    ideally be the median of all elements since it will be used as the root node,
    as is visible in the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨平衡树以及为什么平衡树对于实现高性能很重要。为了避免与二叉搜索树相关的这种陷阱，理想情况下第一个要插入的值应该是所有元素的中位数，因为它将被用作根节点，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Split into two parts, this code walks the tree recursively to find the appropriate
    position and attaches the new value as a leaf there. Actually, the insert is not
    that different from a regular tree walk in search or iteration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分为两部分，这部分代码递归地遍历树以找到适当的位置，并将新值作为叶子附加在那里。实际上，插入并不比常规的树遍历在搜索或迭代中不同。
- en: '**Recursion** is when a function calls itself. Think of the movie Inception—having
    a dream inside a dream inside a dream. it''s the same concept. There are a few
    implications in programming: the original function is disposed of last since it''s
    only finished after all recursive calls return. This also means that everything
    lives on the much smaller stack, which may result in a stack overflow when there
    are too many calls! Typically, recursive algorithms can also be implemented iteratively,
    but they are much harder to understand—so choose wisely!'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**是函数调用自身。想想电影《盗梦空间》——梦中有梦，梦中有梦。这是同样的概念。在编程中有一些影响：原始函数最后被销毁，因为只有当所有递归调用返回后它才完成。这也意味着所有内容都存在于更小的栈上，这可能导致在调用过多时栈溢出！通常，递归算法也可以迭代实现，但它们更难理解——所以要明智选择！'
- en: Finding the right one
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找正确的一个
- en: Having the ability to add devices to the tree, it's even more important to retrieve
    them again. Just like the skip list in the previous chapter, this retrieval ideally
    runs in *O(log n)* time, meaning that the majority of elements are going to be
    skipped when searching.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将设备添加到树中，更重要的是能够再次检索它们。就像前一章中的跳表一样，这种检索理想情况下运行在 *O(log n)* 时间内，这意味着在搜索时将跳过大多数元素。
- en: 'Consequently, if the tree is skewed in one direction, the performance approaches
    *O(n)* and more elements are looked at, thereby making the search slower. Since
    a skewed tree is more like a list, the recursive insert algorithm can overflow
    the stack quickly thanks to the high number of "levels" with only a single item.
    Otherwise, the recursive algorithm is only called as many times as the tree''s
    height, a considerably lower number in a balanced tree. The algorithm itself resembles
    the previously shown insert algorithm:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果树在某一方向上倾斜，性能接近 *O(n)*，查看的元素更多，从而使得搜索变慢。由于倾斜的树更像列表，递归插入算法会因只有单个项目的“层级”数量众多而快速溢出栈。否则，递归算法只调用树的高度次数，在平衡树中这是一个相当小的数字。算法本身类似于之前展示的插入算法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although this snippet's purpose is to find a specific node, there is a close
    relationship to enumerating every device—something that the users of this service
    certainly will want to have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个片段的目的是找到特定的节点，但它与列举每个设备有着密切的关系——这是此服务用户肯定希望拥有的功能。
- en: Finding all devices
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有设备
- en: 'Walking a tree and executing a callback when visiting each node can be done
    in three ways:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问每个节点时遍历树并执行回调可以以三种方式完成：
- en: Pre-order, executing the callback *before descending*
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前序，执行回调 *在下降之前*
- en: In-order, which executes the callback *after descending left, but before descending
    into the right subtree*
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中序，它执行回调 *在下降到左子树之后，但在下降到右子树之前*
- en: Post-order, where the callback is executed *after descending*
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序，其中回调在 *下降后* 执行
- en: Each of these traversal strategies yields a different order of tree elements,
    with in-order producing a sorted output, while pre- and post-order create a more
    structurally oriented sorting. For our users, the in-order walk will provide the
    best experience, since it also lets them reason better regarding the expected
    outcome, and, if displayed in a list, it's easier to navigate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些遍历策略中的每一种都会产生不同的树元素顺序，其中中序产生排序输出，而前序和后序则创建更结构化的排序。对于我们的用户来说，中序遍历将提供最佳体验，因为它还让他们更好地推理预期的结果，如果以列表形式显示，则更容易导航。
- en: While implementing this walk is very easy to do recursively, providing an iterator
    is more user-friendly (just like the lists in the previous chapter) and it enables
    a number of added functions, such as `map()` and `filter()`. However, this implementation
    has to be iterative, which makes it more complex and removes some of the efficiency
    of the tree.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以递归方式实现这种行走非常简单，但提供一个迭代器更符合用户习惯（就像前一章中的列表一样），并且它使许多附加功能成为可能，例如 `map()` 和 `filter()`。然而，这种实现必须是迭代的，这使得它更复杂，并减少了树的一些效率。
- en: 'Therefore, this tree supports a `walk()` function which calls a provided function
    each time it encounters a node, which can be used to fill a vector for the iterator:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此树支持一个 `walk()` 函数，每次遇到节点时都会调用提供的函数，这可以用来填充迭代器的向量：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An example of how to build a vector using this walk method is shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了如何使用这种行走方法构建向量的示例：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this walking ability, all requirements are satisfied for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种行走能力，目前所有需求都已得到满足。
- en: Wrap up
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Thanks to their simplicity, binary search trees are beautifully efficient. In
    fact, the entire tree implementation for this section was done in fewer than 90
    lines of Rust code, with functions of about 10 lines each.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的简单性，二叉搜索树非常高效。事实上，本节中整个树实现只用不到90行Rust代码完成，每个函数大约10行。
- en: A binary tree's efficiency allows for recursion to be used a lot, which typically
    results in functions that are easier to understand compared to their iterative
    counterparts. In the ideal case, that is, when a tree is perfectly balanced, a
    function only has to process *log2(n)* nodes (*n* being the total number of nodes)—19
    in a tree of 1,000,000 elements!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树的效率允许大量使用递归，这通常会导致与迭代版本相比更容易理解的函数。在理想情况下，即当树完全平衡时，函数只需要处理 *log2(n)* 个节点（*n*
    是节点总数）——在一个包含100万个元素的树中只有19个！
- en: 'Unbalanced trees will decrease performance significantly and they are easily
    created by accident. The most unbalanced tree is created by inserting values that
    are already sorted, creating a very large difference in search performance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不平衡的树会显著降低性能，并且它们很容易意外创建。最不平衡的树是通过插入已经排序的值创建的，这会在搜索性能上造成很大的差异：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These results reflect the differences between a skip list and a doubly linked
    list from the previous chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果反映了跳表和前一章中的双链表之间的差异。
- en: Upsides
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'To recap, a binary search tree has a number of great benefits for its users:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，二叉搜索树对用户来说有许多好处：
- en: Simple implementation
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单实现
- en: Efficient and fast search
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效且快速的搜索
- en: Traversal allows for different orderings
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历允许不同的排序
- en: Great for large amounts of unsorted data
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常适合大量未排序的数据
- en: Downsides
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'By using a binary search tree, its drawbacks become obvious quickly:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用二叉搜索树，其缺点很快就会变得明显：
- en: Worst-case performance is that of a linked list
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最坏情况下的性能与链表相当
- en: Unbalanced trees are easy to create by accident
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不平衡的树很容易意外创建
- en: Unbalanced trees cannot be "repaired"
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不平衡的树不能“修复”
- en: Recursive algorithms can overflow on unbalanced trees
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归算法在不平衡的树上可能会溢出
- en: 'Obviously, a lot of the deeper issues result from the tree being unbalanced
    in some way—for which there is a solution: self-balancing binary search trees.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，许多更深层次的问题都源于树以某种方式不平衡——对此有一个解决方案：自平衡二叉搜索树。
- en: Red-black tree
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'With the previous tree structure, there was a major downside: a previously
    unknown sequence of keys that is inserted into the tree cannot be sorted. Think
    of how most identifiers are generated; they are typically ascending numbers. Shuffling
    these numbers won''t always work, especially when they are gradually added. Since
    this leads to an unbalanced tree (the extreme case behaves just like a list),
    Rudolf Bayer came up with the idea of a special, self-balancing tree: the red-black
    tree.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的树结构中，有一个主要的缺点：插入到树中的先前未知的键序列无法排序。想想大多数标识符是如何生成的；它们通常是递增的数字。对这些数字进行洗牌并不总是有效，尤其是在它们逐渐添加时。由于这会导致不平衡的树（极端情况表现得就像一个列表），鲁道夫·拜尔提出了一个特殊的自平衡树的想法：红黑树。
- en: 'This tree is a binary search tree that adds logic to rebalance after inserts.
    Within this operation, it is crucial to know when to stop "balancing"—which is
    where the inventor thought to use two colors: red and black.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树是一个二叉搜索树，它在插入后添加了重新平衡的逻辑。在这个操作中，知道何时停止“平衡”至关重要——这就是发明者想到使用两种颜色：红色和黑色。
- en: 'In literature, the red-black tree is described as a binary search tree that
    satisfies a set of rules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，红黑树被描述为满足一系列规则的二叉搜索树：
- en: The root node is always black
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点始终是黑色
- en: Each other node is either red or black
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个其他节点要么是红色，要么是黑色
- en: All leaves (often `null`/`NIL` values) are considered black
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有叶子（通常是 `null`/`NIL` 值）都被认为是黑色的
- en: A red node can only have black children
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色节点只能有黑色子节点
- en: Any path from the root to its leaves has the same number of black nodes
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从根到其叶子的任何路径都有相同数量的黑色节点
- en: 'By enforcing these rules, a tree can be programmatically verified to be balanced.
    How are these rules doing that? Rules 4 and 5 provide the answer: if each branch
    has to have the same number of black nodes, neither side can be significantly
    longer than the other unless there were lots of red nodes.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制执行这些规则，可以通过编程验证树是否平衡。这些规则是如何做到这一点的呢？规则4和5提供了答案：如果每个分支都必须有相同数量的黑色节点，那么两边不可能有显著的一边比另一边长，除非有很多红色节点。
- en: 'How many of those can there be? At most, as many as there are black nodes—because
    they cannot have red children. Thus, one branch cannot significantly exceed the
    other, making this tree balanced. The code of the validation function illustrates
    this very well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些能有多少呢？最多和黑色节点一样多——因为它们不能有红色子节点。因此，一个分支不能显著超过另一个，使得这棵树保持平衡。验证函数的代码很好地说明了这一点：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the binary search tree, each node in a tree has two children, with a key
    either greater than, equal to, or less than that of the current node. In addition
    to the key (as in a key-value pair), the nodes store a color that is red on insert,
    and a pointer back to its parent. Why? This is due to the required rebalancing,
    which will be described later. First, this can be a typical node:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像二叉搜索树一样，树中的每个节点都有两个子节点，键要么大于、等于或小于当前节点的键。除了键（如键值对）之外，节点还存储一个颜色，插入时为红色，并指向其父节点。为什么？这是因为所需的平衡，这将在后面描述。首先，这可以是一个典型的节点：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using these nodes, a tree can be created just like a binary search tree. In
    fact, the insert mechanism is exactly the same except for setting the parent pointer.
    Newly inserted nodes are always colored red and, once in place, the tree might
    violate the rules. Only then is it time to find and fix these issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些节点，可以创建一个树，就像二叉搜索树一样。实际上，插入机制完全相同，只是设置了父指针。新插入的节点总是着色为红色，一旦就位，树可能会违反规则。只有在这种情况下，才是寻找和修复这些问题的时机。
- en: After an insert, the tree is in an invalid state that requires a series of steps
    to restore the red-black tree's properties. This series, comprised of rotation
    and recolor*,* starts at the inserted node and goes up the tree until the root
    node is considered valid. In summary, a red-black tree is a binary search tree
    that is rotated and recolored until balance is restored.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 插入后，树处于无效状态，需要一系列步骤来恢复红黑树属性。这个系列，由旋转和重新着色*组成，从插入节点开始，向上到根节点被认为是有效的。总之，红黑树是一种旋转和重新着色直到恢复平衡的二叉搜索树。
- en: '**Recolor** is simply changing the color of a specified node to a specific
    color, which happens as a final step when doing tree rebalancing. **Rotation**
    is an operation of a set of three nodes: the current node, its parent, and its
    grandparent. It is employed to fold list-like chains into trees by rotating either
    left or right around a specified node. The result is a changed hierarchy, with
    either the left or right child of the center node on top, and its children adjusted
    accordingly:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新着色**只是将指定节点的颜色更改为特定颜色，这在进行树平衡的最后一步发生。**旋转**是一组三个节点（当前节点、其父节点和其祖父节点）的操作。它通过围绕指定节点左旋或右旋来折叠类似列表的链到树中。结果是改变了层次结构，中心节点的左子节点或右子节点位于顶部，其子节点相应地调整：'
- en: '![](img/f45acff7-777a-4242-b534-c2464c606330.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f45acff7-777a-4242-b534-c2464c606330.png)'
- en: 'Clearly, this example is too simple and it can only happen within the first
    few inserts. Rotations require recolors after redefining the hierarchy of a set
    of nodes. To add further complexity, rotations regularly happen in succession:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个例子太简单了，它只能在最初的几次插入中发生。在重新定义一组节点层次结构之后，旋转需要重新着色。为了增加复杂性，旋转通常会连续发生：
- en: '![](img/bd2d323f-1996-49ea-a6ba-facdae784fe9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd2d323f-1996-49ea-a6ba-facdae784fe9.png)'
- en: 'The preceding tree has had a node inserted and is now violating rule 4: *no
    red children on a red node*. The next step is to determine which steps are required
    to establish balance. For that, the parent''s sibling''s color (that is, the uncle''s
    color) is examined. Red means that a simple recoloring of both siblings to black
    and their parent to red won''t invalidate the tree and will fix the condition.
    This is not the case here (the uncle is `None`, which means black), and some rotation
    is required:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的树已经插入了一个节点，现在违反了规则 4：*红色节点上不能有红色子节点*。下一步是确定需要哪些步骤来建立平衡。为此，检查父节点的兄弟节点的颜色（即叔叔的颜色）。红色表示将两个兄弟节点都着色为黑色，并将它们的父节点着色为红色不会使树无效，并修复条件。这里不是这种情况（叔叔是
    `None`，这意味着黑色），需要进行一些旋转：
- en: '![](img/0a1e50d9-be7b-4738-b786-f1c75b648f92.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a1e50d9-be7b-4738-b786-f1c75b648f92.png)'
- en: 'The first move is to align the nodes into a chain of left children (in this
    case), which is done by rotating around the center node, the insertee''s parent:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将节点排列成一条左子节点的链（在这种情况下），这是通过围绕中心节点，插入节点的父节点旋转来完成的：
- en: '![](img/b3f8638e-86e6-4b37-bf7b-60c6340b3c60.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3f8638e-86e6-4b37-bf7b-60c6340b3c60.png)'
- en: 'Once the chain is aligned, a right rotation of the third node (grandparent)
    creates a valid subtree by elevating the middle node (the "youngest" node/insertee),
    with the former parent and grandparent to the left and right, respectively. Then,
    the new constellation is recolored and the procedure begins anew, centered around
    the root of the new subtree (in this example, though, the tree is already valid):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链对齐，第三个节点（祖父节点）向右旋转就通过提升中间节点（“最年轻”的节点/插入节点）创建了一个有效的子树，前父节点和祖父节点分别位于左侧和右侧。然后，新的星系被重新着色，程序重新开始，以新子树的根为中心（在这个例子中，尽管如此，树已经有效）：
- en: '![](img/f007f46a-f3ea-4374-8775-e444dec4c6f7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f007f46a-f3ea-4374-8775-e444dec4c6f7.png)'
- en: These steps can be repeated until the tree is valid and the root is reached
    (which might be different from what you started off with). This root node is heuristically
    painted black as well, which cannot violate the rules but shortcuts a potential
    red-red violation. For code on the fixing operation, see the following subsections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以重复进行，直到树有效且到达根节点（这可能与您开始时的情况不同）。这个根节点也被启发式地涂成黑色，这不会违反规则，但缩短了潜在的红色-红色违规。有关修复操作的代码，请参阅以下小节。
- en: The product team has even called this time to put emphasis on their new product
    ideas. The IoT platform is quite popular and customers have been using it a lot—and
    recognized a major slowdown when they kept adding their sequentially numbered
    devices. This resulted in angry calls to customer services, which then turned
    to the product team for help—and now it's time to implement the solution and replace
    the current tree for device management.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 产品团队甚至将这段时间用来强调他们的新产品理念。物联网平台相当受欢迎，客户一直在大量使用它——并且在他们继续添加顺序编号的设备时，他们认识到了重大的减速。这导致了愤怒的客户服务电话，然后转向产品团队寻求帮助——现在是时候实施解决方案并替换当前的设备管理树了。
- en: Better IoT device management
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的物联网设备管理
- en: 'The problem that our users face is clear: if a binary search tree encounters
    sorted data (such as incremental IDs), it can only ever append to one side, creating
    an unbalanced tree. A red-black tree is able to handle this at the cost of more
    operations being executed during insert (such as rotating subtrees), which is
    acceptable for the users.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用户面临的问题很清楚：如果一个二叉搜索树遇到排序数据（如增量 ID），它只能始终向一侧追加，从而创建一个不平衡的树。红黑树能够在插入时执行更多操作（如旋转子树）的代价下处理这个问题，这对用户来说是可接受的。
- en: 'This tree has similar nodes to the binary search tree, with the addition of
    a color field and a parent field, the latter of which triggers a wider change
    compared to the binary search tree. Thanks to the pointer back, the tree nodes
    cannot exclusively own the pointers to the children and parent (because, who owns
    this value, the parent or the child?), which requires a well-known pattern in
    Rust: interior mutability. As discussed in an earlier chapter, `RefCell` owns
    the data''s portion of the memory and handles borrow-checking at runtime so that
    mutable and immutable references can be obtained:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树与二叉搜索树有类似的节点，增加了颜色字段和父字段，后者相对于二叉搜索树来说，变化更大。多亏了回指，树节点不能仅拥有指向子节点和父节点的指针（因为，谁拥有这个值，父节点还是子节点？），这需要
    Rust 中一个众所周知的模式：内部可变性。正如在前一章中讨论的，`RefCell` 拥有数据的内存部分，并在运行时处理借用检查，以便可以获取可变和不可变引用：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that in place, devices can be added.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置到位，就可以添加设备。
- en: Even more devices
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的设备
- en: Once the tree is created, an `add()` function lets the user add a device. The
    tree then proceeds to insert the new key just as if it were a binary search tree—only
    to check and fix any errors immediately afterward. Where a binary search tree
    could use a simple `if` condition to decide the direction it proceeds in, in the
    red-black tree, the direction has a larger impact, and nesting `if` conditions
    will result in chaotic, unreadable code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了树，`add()` 函数允许用户添加设备。然后，树继续像二叉搜索树一样插入新键，只是在之后立即检查和修复任何错误。在二叉搜索树中可以使用简单的
    `if` 条件来决定前进的方向，而在红黑树中，方向有更大的影响，嵌套 `if` 条件会导致混乱、难以阅读的代码。
- en: 'Thus, let''s create `enum` first, so any time the direction (example, insert,
    position of a node relative to another node, and so on) has to be decided, we
    can rely on that `enum`. The same goes for the tree''s color:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建 `enum`，这样每当需要决定方向（例如，插入，节点相对于另一个节点的位置等）时，我们都可以依赖这个 `enum`。对于树的颜色也是如此：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the `add()` function can use Rust''s match clause to nicely structure
    the two branches:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`add()`函数可以使用Rust的match子句来优雅地组织两个分支：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One of the primary parts of the code is "checking" two devices, that is, comparing
    them in order to provide a direction that they should be appended to. This comparison
    is done in a separate function to improve maintainability:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主要部分之一是“检查”两个设备，即比较它们以提供它们应该附加到的方向。这种比较是在一个单独的函数中完成的，以提高可维护性：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this tree will append every larger item to the left (which seems unusual),
    the algorithms don't care; they will work regardless—and, by wrapping this into
    its own function, change is quick and easy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个树会将每个更大的项目附加到左侧（这似乎很奇怪），但算法并不关心；无论怎样它们都会工作——通过将其封装到自己的函数中，改变变得快速且简单。
- en: Balancing the tree
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡这棵树
- en: 'After the node is added properly, `fix_tree()` takes care of restoring the
    red-black tree''s properties—iteratively. While this is nicely descriptive and
    demonstrative it is long, so let''s break it up into parts. Initially, the function
    determines whether it should stop (or not even start)—which only happens in two
    cases:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点正确添加后，`fix_tree()`负责迭代地恢复红黑树的性质——这是非常好地描述性和演示性的，但它很长，所以让我们将其分成几个部分。最初，函数确定它是否应该停止（或甚至不开始）——这仅在两种情况下发生：
- en: When it's already the root node
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它已经是根节点时
- en: When the parent of the currently inspected node is red
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当当前检查节点的父节点是红色时
- en: 'Clearly, the former is the regular exit criterion as well, as the loop optimizes
    and moves the current pointer (`n` as in node) from the bottom toward the root
    of the tree to stop there:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前者是常规的退出标准，因为循环优化并移动当前指针（`n`代表节点）从底部向树根移动以停止在那里：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once started, the loop immediately goes for the uncle of a particular node
    (that is, the grandparent''s second child) and its color. The uncle node can either
    be black (or `None`) or red, which are the two cases covered next. It is also
    important to find out *which* uncle it is, and therefore which node the current
    pointer points to: a left node or a right node. Let''s take a look at the following
    code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始，循环立即寻找特定节点的叔叔节点（即祖父的第二个孩子）及其颜色。叔叔节点可以是黑色（或`None`）或红色，下面将讨论这两种情况。同样重要的是要找出它是哪个叔叔，因此当前指针指向哪个节点：左节点或右节点。让我们看一下下面的代码片段：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This information is critical in determining the rotation order in this area
    of the tree. In fact, the two branches will execute the same steps, but mirrored:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息对于确定这个树区域的旋转顺序至关重要。实际上，两个分支将执行相同的步骤，但相反：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code contains a large amount of `unwrap()`, `clone()`, and `borrow()` instances,
    a consequence of the interior mutability pattern. In this case, macros could help
    to reduce the code's verbosity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含大量的`unwrap()`、`clone()`和`borrow()`实例，这是内部可变性模式的后果。在这种情况下，宏可以帮助减少代码的冗长性。
- en: Once the operations for one part of the tree finishes, the next iteration is
    prepared by checking for a red-red violation to see whether the loop needs to
    continue.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一部分树的运算完成后，下一迭代通过检查是否存在红色-红色违规来准备，以查看循环是否需要继续。
- en: 'After the main loop exits, the pointer to the current node is moved up the
    tree to the root node (which is the function''s return value, after all) and colored
    black. Why? This is a shortcut solution that would otherwise result in another
    iteration requiring many more expensive steps to be executed, and the rules of
    a red-black tree mandate a black root anyway:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环退出后，当前节点的指针向上移动到树根节点（毕竟，这将是函数的返回值）并着色为黑色。为什么？这是一个快捷解决方案，否则会导致另一个迭代需要执行许多更昂贵的步骤，而红黑树的规则要求根节点必须是黑色的：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that shortcut, a valid tree is returned that can be set as the new root.
    However, the main purpose of the tree is to find stuff, which is not that different
    from a regular binary search tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个快捷方式，可以返回一个有效的树，可以将其设置为新的根。然而，树的主要目的是找到东西，这与常规的二叉搜索树并没有太大的不同。
- en: Finding the right one, now
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在找到正确的
- en: 'This piece of code can almost be reused from the binary search tree. Other
    than the `borrow()` calls (instead of a simple dereference or `*` operator) adding
    some amount of processing time, they provides a consistent search speed. For greater
    reuse of existing functions, the value to be found is wrapped into a dummy node.
    This way, no additional interface has to be created for comparing nodes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is, again, a recursive walk of the tree until the specified value is found.
    Additionally, the "regular" tree walk was also added to the red-black tree variant:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With these parts fixed, the platform performs consistently fast!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Red-black trees are great self-balancing binary trees, similar to **AVL** (short
    for **Adelson-Velsky and L****andis**) trees. Both appeared around the same time,
    yet AVL trees are considered to be superior thanks to a lower height difference
    between the branches. Regardless of which tree structure is used, both are significantly
    faster than their less complex sibling, the binary search tree. Benchmarks using
    sorted data on insert (100,000 elements in this case) show how significant the
    difference between a balanced and unbalanced tree is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another variation of a balanced tree is the 2-3-4 tree, a data structure that
    the red-black tree can be converted into. However, the 2-3-4 tree is, like the
    B-Tree (coming up later in this chapter), non-binary. Therefore, it is briefly
    discussed later in this chapter, but we encourage you to find other sources for
    details.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: One major upside to implementing a red-black tree in Rust is the deep understanding
    of borrowing and ownership that follows the reference juggling when rotating,
    or "unpacking", a node's grandfather. It is highly recommended as a programming
    exercise to implement your own version!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A red-black tree has a few desirable properties over a regular binary search
    tree:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Balance makes searches consistently fast
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictable, low-memory usage
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts are reasonably fast
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity of a binary tree
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to validate
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the data structure has some significant downsides as well, especially
    when planning to implement it!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speed is great, but can your implementation achieve it? Let''s have a look
    at the downsides of red-black trees:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Complex implementation, especially in Rust
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent writes require the entire tree to be locked
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance is great compared to binary search trees, but other trees perform
    better at the same complexity
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip lists (from the previous chapter) perform similarly with better concurrency
    and simpler implementations
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In any case, the red-black tree is a great journey into sophisticated binary
    tree structures. A more exotic binary tree structure is the heap (not to be confused
    with the portion of main memory).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Heaps
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since binary trees are the most basic forms of trees, there are several variations
    designed for a specific purpose. Where the red-black tree is an advanced version
    of the initial tree, the binary heap is a version of the binary tree that does
    not facilitate search.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, it has a specified purpose: finding the maximum or minimum value of
    a node. These heaps (min-heap or max-heap) are built in a way that the root node
    is always the value with the desired property (min or max) so it can be retrieved
    in constant time—that is, it always takes the same number of operations to fetch.
    Once fetched, the tree is restored in a way that the next operation works the
    same. How is this done though?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Heaps work, irrespective of whether they are min-heaps or max-heaps, because
    a node's children always have the same property as the entire tree. In a max-heap,
    this means that the root node is the maximum value of the sequence, so it has
    to be the greatest value of its children (it's the same with min-heaps, just in
    reverse). While there is no specific order to this (such as the left node being
    greater than the right node), there is a convention to prefer the right node for
    max-heaps and the left for min-heaps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon inserting a new node, it is added last and then a place in the tree has
    to be determined. The strategy to do that is simple: look at the parent node;
    if it''s greater (in a max-heap), swap the two, and repeat until this doesn''t
    work or it becomes the root node. We call this operation **upheap**.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, this is how removals work. Once removed, the now-empty slot is replaced
    by a leaf of the tree—which is either the smallest (max-heap) or greatest (min-heap)
    value. Then, the same comparisons as with the insert are implemented, but in reverse.
    Comparing and swapping this node with the children restores the heap's properties
    and is called **downheap**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'If you paid attention to a node''s journey, there is one detail that will be
    obvious to you: the tree is always "filled". This means that each level is fully
    populated (that is, every node has both children), making it a **complete binary
    tree** that maintains total order. This is a property that lets us implement this
    tree in an array (dynamic or not), making jumps cheap. It will all become clear
    once you see some diagram:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2060e60-5458-46bd-b9e7-9634b47f8c98.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Commonly, the heap is used to create a priority queue of some kind, thanks to
    the ability to quickly retrieve the highest- or lowest-valued items. A very basic
    heap can be implemented in Rust as an array, which will provide everything necessary
    to make it work, but won't be as convenient as a `Vec`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: After the great success of the IoT device platform, an add-on has been planned.
    The product team is asking for a way to efficiently process messages that come
    from the devices, so that customers only have to deal with the actual handling
    of the message and skip the "plumbing" code. Since processing can be executed
    at (short) intervals, they require a way to order them quickly—ideally so that
    the device with the most messages can come first.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This sounds like the heap data structure, doesn't it? In fact, it can be a max-heap.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: A huge inbox
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, heaps are used as priority queues of all kinds. Queues like that
    exist in any resource-constrained environment (and everywhere else, probably),
    but their purpose is to output things in an ordered fashion. By using the number
    of messages to determine the priority of a message notification, the heap can
    do the heavy lifting of this feature. Before jumping into the hard stuff, though,
    here are the bits containing the information:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The idea is to use the number of messages as an indicator of which device to
    poll first, which is why the device is required. Using this type, the heap does
    not require any specific node or link types to work:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two interesting points here: the underlying structure is a regular
    `Vec<T>`, which was chosen for its expansion capabilities (Rust''s arrays are
    sized at compile time), and the functionality of `push` or `pop`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Another noteworthy modification is that no `Option` is needed, which removes
    a check from the code and makes it easier to read. However, since many of the
    heap's operations work well with a direct, 1-index-based access, indices have
    to be translated before hitting `Vec<T>`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: So how does data get in?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Getting messages in
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a message arrives, it is pushed to the back of the array when the upheap
    operation "bubbles up" the item until it finds its proper place. In Rust code,
    this is what that looks like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Initially, the new notification lives in a `Box` at the back of the `Vec<T>`,
    inserted via `push()`. A simple `while` loop then bubbles up the new addition
    by repeatedly swapping it whenever the `has_more_messages()` function is true.
    When is it true? Let''s see the code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By encapsulating this function, it's easily possible to change the heap into
    a min-heap should that be required—and the index translations are wrapped away
    here as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Getting data out requires doing this process in reverse in a function called
    `pop()`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Taking messages out
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing the first item in a `Vec<T>` is not difficult—in fact, `Vec<T>` ships
    with a `swap_remove()` function that does exactly what a heap needs: removing
    the first element of a `Vec<T>` by replacing it with the last element! This makes
    the code significantly shorter and therefore easier to reason about:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, this code is not short though—so what's amiss? The bubbling down.
    Swapping downward requires to look at the children (which are at the positions
    `i * 2` and `i * 2 + 1`) to find out where (or if) the next iteration should proceed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heap data structure is surprisingly simple to implement. There are no lengthy
    unwraps, borrows, or other calls, and the pointer is owned by the `Vec` and can
    easily be swapped. Other than that, the upheap operation is only a `while` loop,
    just like the (slightly more complex) downheap function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another typical use case for a heap though: sorting! Consider a bunch
    of numbers going into the heap instead of `MessageNotification` objects—they would
    come out sorted. Thanks to the efficiency of the upheap/downheap operations, the
    worst-case runtime of that sorting algorithm is great—but more on that in [Chapter
    9](a9ba9f9e-59a2-411f-8998-831fe4e69266.xhtml), *Ordering Things*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compact and low-complexity implementation make the binary heap a great candidate
    for requiring any kind of sorting data structure. Other benefits include the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: An efficient way to sort lists
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works well in concurrent situations
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very efficient way to store a sorted array
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet there are also downsides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heaps are generally great, but have two caveats that limit their use:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Use cases outside of queuing or sorting are rare
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are better ways to sort
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The binary heap was the last of the binary trees, and the next section will
    cover another rather exotic variation of a tree: the trie.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Trie
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trie is another interesting data structure—in particular, the way in which
    it is pronounced! Depending on your mother tongue, intuition might dictate a way,
    but—according to Wikipedia—the name was selected thanks to Edward Fredkin, who
    pronounced this type of tree differently, namely like **trie** in re**trie**val.
    Many English speakers resort to saying something along the lines of "try" though.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, what does the trie actually do for it to deserve
    a different name? It transpires that using retrieval was not a bad idea: tries
    store strings.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Imagine having to store the entire vocabulary of this book in a way to find
    out whether certain words are contained within the book. How can this be done
    efficiently?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: After the previous sections, you should already have an answer, but if you think
    about strings—they are stored as arrays or lists of `char` instances—it would
    use a good amount of memory. Since each word has to use letters from the English
    alphabet, can't we use that?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Tries do something similar. They use characters as nodes in a tree where the
    parent node is the preceding character and all children (limited only by the size
    of the alphabet) are what follows. A trie storing the strings ABB, ABC, CAACB,
    CAACA, BBB, and BBA can be seen in the following trie diagram:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91d88689-25be-4760-b986-aeb4ebe7937f.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Storing strings like this enables a very efficient search. You only have to
    walk through the letters in the key that is to be stored to find out (or store)
    whether that string is contained in—for example—a set. In fact, if a string can
    only have a certain size, then the retrieval time is constant and it does not
    matter whether the trie stores 10 or 10 million words. Typically, this is useful
    for set data structures or key-value stores with string keys (such as hashes,
    but more on that later). Just like the binary search tree, this structure has
    a strong hierarchical memory management (that is, no pointers "back up"), making
    it a perfect fit for Rust.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Lately, the product team has looked into the user's device keys once again and
    found that the typical IoT device uses keys that represent a path, and they would
    often look like `countryA/cityB/factoryC/machine1/positionX/sensorY`. Reminded
    of the trees that worked so well earlier, they thought that you could use those
    to improve the directory as well. But you already have a better idea!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: More realistic IoT device management
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Paths like that tend to have a huge overlap, since there are countless sensors
    and devices in a single location. Additionally, they are unique thanks to the
    hierarchical properties and are human-readable in case the sensor needs to be
    found. A great fit for a trie!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The basis for this trie will be a node type that stores the children, current
    character, and, if it''s a node that concludes a full key, the `IoTDevice` object
    from earlier in this chapter. This is what this looks like in Rust:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, the children is a different data structure as well: a `HashMap`.
    Maps (also called dictionaries, associative arrays) explicitly store a key alongside
    a value and the word "hash" hints at the method, which will be discussed in the
    next chapter. For now, the `HashMap` guarantees a single character to be associated
    with a Node type, leading the way for iteration. On top of that, this data structure
    allows for a get-or-add type operation, which significantly improves code readability.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the number of possible word beginnings is similar, the root is a `HashMap`
    as well, giving the trie multiple roots:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In order to fill up these maps with data, a method to add paths is required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Adding paths
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The algorithm for inserting a string into a trie can be described in only a
    few sentences: go through each character of the word and trace it down the trie.
    If a node does not yet exist, create it, and add the object with the last entry.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are special cases that need to be decided as well: what happens
    when a string already exists? Overwrite or ignore? In the case of this implementation,
    the last write will win—that is, it''s overwriting whatever existed previously:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Another special case is the root node, since it's not a real node but a `HashMap`
    right away. Once a trie is set up, the most important thing is to get stuff out
    again!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Walking
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add and search work in a very similar manner: follow the links to the characters
    of the key and return the "value" in the end:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since the trie does not store strings in any particular order (or even consistently),
    getting the same data out in a predictable way is tricky! Walking it like a binary
    tree works well enough, but will only be deterministic with respect to the insertion
    order, something that should be kept in mind when testing the implementation:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As previously mentioned, this walk is called a breadth-first traversal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trie data structure is a very efficient way of storing and finding strings
    by storing common prefixes, and they are often used in practice. One use case
    is the popular Java search engine Lucene, which uses this structure to store words
    in the search index, but there are plenty of other examples across different fields.
    Additionally, the simplicity is great for implementing a custom trie to store
    entire words or other objects instead of characters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The inherent prefix is great for efficient storage and, apart from that, there
    are the following benefits:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Easy implementation facilitates customizing
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal memory requirements for sets of strings
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant-time retrieval for strings with a known maximum length
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exotic algorithms are available (for example, Burst Sort)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the trie is great, it is also fairly simple, which comes with a number
    of downsides.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tries can work in a lot of shapes and forms, but can''t handle every use case,
    unfortunately. Other disadvantages include the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: It has a name that's strange to pronounce
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no deterministic order on walking
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no duplicate keys
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes the more exotic tree varieties. Next up is the B-Tree, which
    is essentially a universal tree!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: B-Tree
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have noticed, restricting the number of children to 2 (like the binary
    trees earlier) yields a tree that only lets the algorithm decide whether to go
    left or right, and it's easily hardcoded. Additionally, storing only a single
    key-value pair in a node can be seen as a waste of space—after all, the pointers
    can be a lot larger than the actual payload!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'B-Trees generally store multiple keys and values per node, which can make them
    more space-efficient (the payload-to-pointer ratio is higher). As a tree, each
    of these (key-value) pairs has children, which hold the values between the nodes
    they are located at. Therefore, a B-Tree stores triples of key, value, and child,
    with an additional child pointer to cover any "other" values. The following diagram
    shows a simple B-Tree. Note the additional pointer to a node holding smaller keys:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c99ddbf-3f3d-4424-9b49-6c6aed5f7d5c.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: As depicted here, a B-Tree can have varying amounts of those key-value pairs
    (only the keys are visible), but they will have a maximum number of children—defined
    by the *order* parameter. Consequently, a binary search tree can be considered
    an order-2 B-Tree, without the added benefit of being self-balancing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve the self-balancing nature, a B-Tree has certain properties
    (as defined by Donald Knuth):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Each node can only have *order* children
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each node that is not a leaf node or root has at least *order/2* children
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The root node has at least two children
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All nodes hold *order - 1* keys when they have *order* children
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All leaf nodes appear on the same level
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How does self-balancing work? It is way simpler than a red-black tree. Firstly,
    new keys can only be inserted at the leaf level. Secondly, once the new key has
    found a node, the node is evaluated to the preceding rules—in particular, if there
    are now more than *order - 1* keys. If that is the case, the node has to be split,
    moving the center key to the parent node, as shown in the following diagram:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bc64dd2-6e9e-48d8-a778-49eef819928d.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Next, the children are put in their intended position (especially important
    if the elevated node had children) and then the process is repeated up the tree
    until the root node is valid.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'This process creates something that is called a **fat tree** (as opposed to
    a high tree), which means that adding height is only possible through splitting,
    which doesn''t happen very often. In order to work with the nodes, they contain
    additional information about themselves:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, the type of node is determined by a property, `node_type`, but
    the entire node could be wrapped into an enumeration as well. Furthermore, a special
    variable holding the "left child" has been attached in order to deal with keys
    lower than what is associated with the triples in the `keys` vector.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Like binary trees, the B-Tree exhibits logarithmic runtime complexity on search
    and insert (*O(log2(n))*) and, with the the simplified rebalancing, they make
    for a great choice for database indices. In fact, many SQL databases (such as
    SQLite and SQL Server) use B-Trees to store those search indices, and B+ Trees
    to store tables thanks to their smart ways of accessing the disk.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The product team has also heard about this and, since the previous attempts
    at the IoT device management solution have been a huge success, they thought about
    replacing the red-black tree with something better! They want to reduce the number
    of bugs by creating a more simplified version of the original database, so the
    requirements actually stay the same.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: An IoT database
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous implementation, this tree builds on the `numerical_id` property
    of `IoTDevice` as keys, and the device object as value. In code, a node looks
    very similar to the previous example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of triples, this node type uses a synchronized index to find the children
    associated with a specified key-value pair. These pairs are also created ad hoc
    by evaluating the `numerical_id` property of the contained device, thereby also
    simplifying the code and eventual updates to the keys. Something that is missing
    from the node is a parent pointer, which made the entire red-black tree code significantly
    more complex.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The tree itself is stored as an `Option` on a boxed node (aliased as `Tree`),
    along with the `order` and `length` properties:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, to check the validity of the tree, here''s a `validate` method that
    recursively finds the minimum and maximum leaf height and checks whether the number
    of children is within bounds (as mentioned in the rules indicated earlier):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Having established these basic structures, we can move on to how to add new
    devices to the tree.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Adding stuff
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'B-Trees add new entries to their leaves, which then bubble up as nodes grow
    too large. In order to efficiently find a spot, this is done recursively, removing
    and replacing ownership as needed. Here is the `add()` function, which takes care
    of retrieving ownership of the root node and calling the recursive call with an
    existing or new node:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Except in the case of the root node, the `add_r()` function (the recursive
    call) returns two pieces of information: the key it descended into and—in case
    of a "promotion"—the device and child that are to be added to whichever node it
    returns to. In principle, this function works as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Recursively find the appropriate leaf and perform a sorted insert.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the length if it's not a duplicate.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the node now has more keys than are allowed: split.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the original node and the key with its new value to the caller.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the new node where it came from.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the promoted key.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat from step 3 until at the root level:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since the root node is a special case where a new level is added to the tree,
    this has to be taken care of where the last split is happening—in the `add_r()`
    function. This is as simple as creating a new non-leaf node and adding the former
    root to the left and its sibling to the right, placing the new parent on top as
    the root node.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation, a lot of the heavy lifting is done by the node''s implementation
    of several functions, including `split()`. While this is complex, it encapsulates
    the inner workings of the tree—something that should not be exposed too much so
    as to facilitate change:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As described previously, splitting yields a new sibling to the original node
    and a new parent to both of them. The sibling will receive the upper half of the
    keys, the original node remains with the lower half, and the one in the center
    becomes the new parent.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Having added several devices, let's talk about how to get them back out.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Searching for stuff
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A B-Tree''s search works just the way binary tree searches do: recursively
    checking each node for the path to follow. In B-Trees, this becomes very convenient
    since it can be done in a loop, in this case, by the `get_device()` function:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function is implemented at the node structure and does a regular linear
    search for the key itself. If it is unable to find that key, the `find_r()` function
    has to decide whether to continue, which it does by evaluating the node type.
    Since leaf nodes don''t have any children, not finding the desired key will end
    the search, returning `None`. Regular nodes allow the search to continue on a
    deeper level of the tree:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another method for finding something within the tree's values is walking the
    tree.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Walking the tree
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly to the binary trees earlier in this chapter, walking can be done
    with different strategies, even if there are many more branches to walk. The following
    code shows an in-order tree walking algorithm, where the callback is executed
    between the left child and before descending into the child that is currently
    looked at:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Thanks to the internal sorting, this walk retrieves the keys in an ascending
    order.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: B-Trees are awesome. They are widely used in real-world applications, their
    implementation in Rust is not all that complex, and they maintain a great performance
    regardless of insertion order. Furthermore, the tree's order can dramatically
    improve performance by decreasing the tree's height. It is recommended to estimate
    the number of key-value pairs beforehand and adjust the order accordingly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'As a benchmark, let''s evaluate the trees by inserting 100,000 unsorted, unique
    elements, and retrieving them using `find()`. Dot size represents the variance,
    while the values shown along the *y* axis are nanoseconds:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/320a2f24-c980-4899-a5cb-27c43debf797.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: The chart output of Unsorted find ()
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, it performs at the level of other trees, with vastly fewer
    lines of code and less code complexity, both of which impact readability and maintainability
    for other developers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of tree achieves great performance with the order parameter set accordingly:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Less complex to implement than other self-balancing trees
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widely used in database technology
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictable performance thanks to self-balancing
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range queries are possible
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variants that minimize disk access (B+ Tree)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tree's downsides are few.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Absolute performance depends significantly on the tree's order; other than that,
    this tree does not have many downsides.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Graphs
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In their most generic form, trees are graphs—directed, acyclic graphs. A general
    graph can be described as a collection of connected nodes, sometimes referred
    to as vertices, with certain properties such as whether cycles are allowed. The
    connections between those also have their own name: edges. These edges can have
    certain properties as well, in particular, weights and directions (like one-way
    streets).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'By enforcing these constraints, a model can be built that, just like trees,
    reflects a certain reality very well. There is one particular thing that is typically
    represented as a weighted graph: the internet. While, nowadays, this might be
    an oversimplification, with various versions of the Internet Protocol (IPv4 and
    IPv6) and **Network Address Translation** (**NAT**) technologies hiding large
    numbers of participants online, in its earlier days, the internet could be drawn
    as a collection of routers, computers, and servers (nodes) interconnected with
    links (edges) defined by speed and latency (weights).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a random, undirected, unweighted graph:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d334d74d-a7fe-4d1b-9ae7-afeb995e1afd.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Other than humans, who can typically see and follow a reasonably efficient path
    through this mesh of interconnected nodes, computers require specific instructions
    to find anything in there! This called for new algorithms that allow for dealing
    with this complexity—which is especially tricky once the number of nodes in the
    mesh exceeds the number of nodes that can be looked at in time. This led to the
    development of many routing algorithms, techniques to finding cycles and segmenting
    the network, or popular NP-hard problems, such as the traveling salesman problem
    or the graph-coloring problem. The traveling salesman problem is defined as follows.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the optimal (shortest) path between cities without visiting one twice.
    On the left are some cities in Europe; on the right, two possible solutions (dotted
    versus solid lines):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ab202ba-48ca-4742-a8eb-2c52e0348ebe.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: Today, there are many examples of graphs, the most obvious being a social graph
    (in social networks), but also as part of TensorFlow's deep learning API, state
    machines, and the rise of graph databases that offer a generic query language
    to traverse graphs. Even some less obvious use cases can be found, such as storing
    genetic sequences (nodes being the small parts of the DNA)!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'To get out of theoretical constructs, how would you represent a graph in a
    program *efficiently*? As a node structure with a list of outbound vertices? How
    would you find a particular node then? A tricky problem! Graphs also have the
    habit of growing quite large, as anyone who ever wanted to serialize object graphs
    to JSON can testify: they run out of memory quite easily.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to work with this data structure is surprisingly simple: a matrix.
    This matrix can either be sparse (that is, a list of lists with varying sizes),
    called an **adjacency list**, or a full-blown matrix (adjacency matrix). Especially
    for a matrix, the size is typically the number of nodes on either side and the
    weights (or Boolean values representing "connected" or "not connected") at each
    crossing. Many implementations will also keep the "real" nodes in its own list,
    using the indices as IDs. The following diagram shows how to display a graph as
    a matrix:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30d9f986-73f7-43d2-95b7-86c0f0d2fd54.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: 'Rust provides many great tools for implementing really complex graph structures:
    enumerations and pattern-matching provide ways to operate on types of nodes and
    edges with low overhead, while iterators and functional approaches remove the
    need for verbose loops. Let''s look at a generic graph structure in Rust:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This adjacency list can store nodes and whether they are connected, making this
    a finite, undirected, unweighted graph—great for storing simple relationships
    between objects. Already, a data structure such as this has the ability to implement
    sophisticated routing algorithms or run out of resources on a backtracking algorithm.
    In an adjacency list, each index in the list represents the origin of an edge
    and the contained elements (also lists) are any outbound edges. To traverse the
    graph, start at an origin index and find the next index by searching its edges.
    Then repeat until arriving at the destination node!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'When the product team heard of this amazing data structure—and they are now
    well aware of your abilities—they came up with a new product: the literal Internet
    of Things (it''s a working title). Their idea is to provide customers with a way
    to model complex sensor placements that would have distance built in! Customers
    can then go and evaluate all sensors that are within a certain range of each other,
    find single points of failure, or plan a route to inspect them quickly.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, customers should be able to do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Create or add a list of nodes
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect nodes with their physical distance to each other
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the shortest path between two nodes with respect to the distance provided
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve a list of neighbors of a specified node, up to a certain degree
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great idea, right? A great fit for graphs as well.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The literal Internet of Things
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get a head start on these requirements, the decision for a graph
    representation has to be made: list or matrix? Both work well, but for explanatory
    reasons, the examples will go with an adjacency list built on top of a vector
    of vectors:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As previously mentioned, it makes sense to keep the actual values, identifiers,
    or even entire objects in their own list and simply work with indices of the `usize`
    type. The edge structure in this example could be represented as a tuple just
    as well, but it''s way more readable this way:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Having those two structures in place, adding nodes (or... things) to the graph
    can be done with only a few lines:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Within that function, there is a crucial check that''s made: every edge has
    to connect to a valid node, otherwise it will not be added to the graph. To achieve
    this, the code looks up the IDs provided in the `edges` parameter in its internal
    node storage to find the index it''s at, something that is done by the `position()`
    function of Rust''s iterator trait. It returns the position of when the provided
    predicate returns true! Similarly, the `filter_map()` function of the iterator
    will only include elements that evaluate to `Some()` (as opposed to `None`) in
    its result set. Therefore, the nodes have to have a setter that also initializes
    the adjacency list:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once that's done, the graph is ready to use. How about we go looking for neighbors
    first?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Neighborhood search
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Neighborhood search is a very trivial algorithm: starting from the node provided,
    follow every edge and return what you find. In our case, the degree of the relationship
    is important.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Just like for the tree algorithms shown previously, recursion is a great choice
    for solving this problem. While an iterative solution will often be more memory-efficient
    (no stack overflows), recursion is way more descriptive once you get the hang
    of it. Additionally, some compilers (and partly `rustc`, but not guaranteed) will
    expand the recursion into a loop, providing the best of both worlds (look for
    tail call optimization)! Obviously, the most important thing is to have a projected
    growth in mind; 100,000 recursive calls are likely to fill up the stack.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the function to run the neighborhood is implemented two-fold. First,
    the public-facing function takes care of validating input data and sees whether
    the node actually exists:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With that out of the way, the recursive call can create a list of all its neighbors
    and run the same call on each of them. Returning a set of nodes eliminates the
    duplicates as well:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since the recursive call returns the internal representation (that is, indices),
    the outer function translates those back into data the user can understand. This
    function can serve as a basis for other features, such as intersecting the neighborhoods
    of two nodes, and vicinity search. Or, to make it more real, on a sensor outage,
    the company can check whether there is a common device that''s responsible (intersection),
    or if other close-by sensors are reporting similar measurements to rule out malfunctions
    (neighborhood search). Now, let''s move on to something more complex: finding
    the shortest path.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This algorithm has its roots in early networking: routers had to decide where
    to forward packets to, without having any knowledge of what''s beyond. They simply
    had to make the best decision without having perfect information! Edsger Dijkstra,
    one of the pioneers of computer science, then came up with a graph-routing algorithm
    that has been named after him: Dijkstra''s algorithm.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works iteratively and goes over each node to add up their weights,
    thereby finding the distance (or cost) of reaching this node. It will then continue
    at the node with the lowest cost, which makes this algorithm a "greedy" algorithm.
    This continues until the desired node is reached or there are no more nodes to
    evaluate.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms that immediately converge toward what's best right now (**local optimum**)
    in order to find the best overall solution (**global optimum**) are called **greedy
    algorithms**. This, of course, is tricky, since the path to a global optimum might
    require the acceptance of an increased cost! There is no guaranteed way to finding
    the global optimum, so it's about reducing the probability of getting stuck in
    a local optimum. A well-known greedy algorithm in 2018 is stochastic gradient
    descent, which is used to train neural networks.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, this is what that looks like:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since this is a long one, let''s break it down. This is boiler-plate code to
    ensure that both source and destination nodes are nodes in the graph:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Then, each node gets a tentative weight assigned, which is infinite in the beginning,
    except for the origin node, which has zero cost to reach. The "open" list, which
    contains all the nodes yet to be processed, is conveniently created using Rust's
    range—as it corresponds to the indices we are working with.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The parent array keeps track of each node's parent once the lower cost is established,
    which provides a way to trace back the best possible path!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's plunge into the path-finding. The helper function, `min_index()`,
    takes the current distances and returns the index of the node that is easiest
    (as in lowest distance) to reach next. This node will then be removed from the
    open list. Here's a good point at which to also stop if the destination has been
    reached. For more thoughts on this, see the preceding information box on greedy
    algorithms. Setting `found` to `true` will help distinguish between no result
    and early stopping.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'For each edge of this node, the new distance is computed and, if lower, inserted
    into a distance list (as seen from the source node). There are a lot of clones
    going on as well, which is due to ensuring not borrowing while updating the vector.
    With `u64` (or `u32`) types, this should not create a large overhead (pointers
    are typically that large too), but for other types, this can be a performance
    pitfall:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After this loop exits, there is a distance array and a parent array to be prepared
    for returning to the caller. First, trace back the path from the destination to
    the origin node in the parent array, which leads to the reverse optimal path between
    the two nodes:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By strictly following the node with the lowest distance, Dijkstra's algorithm
    achieves a great runtime when stopping early, and runtime can even be improved
    by using more efficient data structures (such as a heap) to fetch the next node
    efficiently.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Modern approaches to shortest paths in a graph typically use the *A** (pronounced
    "a star") algorithm. While it operates on the same principles, it is also a bit
    more complex and would therefore go beyond the scope of this book.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A graph is surprisingly straightforward to implement: clear ownership in adjacency
    lists or matrices makes them almost effortless to work with! On top of that, there
    are two additional aspects that weren''t yet covered in this implementation: an
    enumeration with an implementation, and using regular operations (here: comparison)
    with this implementation.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: This shows how conforming to standard interfaces provides great ways to interface
    with the standard library or well-known operations in addition to the flexibility
    enumerations provide. With a few lines of code, infinity can be represented and
    worked with in a readable way. It was also a step toward more algorithmic aspects,
    which will be covered later in the book. For now, let's focus on graphs again.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Upsides
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graph structures are unique and there are rarely other ways of achieving the
    same outcome. Working in this environment enables you to focus deeply on relationships
    and think about problems differently. Following are some upsides of using graphs:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Are amazing in modeling relationships
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient retrieval of dependencies of a specific node
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify complex abstractions
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable certain problems to be solved at all
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you choose a matrix or list representation is often a subjective choice
    and, for example, while the matrix provides easy deletes, a list stores edges
    more efficiently in the first place. It's all a trade-off.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Downsides
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This leads us to the downsides of this particular data structure:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Unable to solve certain problems efficiently (for example, a list of all nodes
    that have a certain property)
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More resource-inefficient
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsolved problems exist (for example, the traveling salesman problem with a
    high number of cities)
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically requires a problem to be reconsidered
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we can conclude this chapter about trees and their relatives after
    a summary.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter went deep into trees, starting off with the simplest form: the
    binary search tree. This tree prepares the inserted data for search by creating
    a left and a right branch which hold smaller or greater values. A search algorithm
    can therefore just pick the direction based on the current node and the value
    coming in, thereby skipping a majority of the other nodes.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular binary search tree has a major drawback, however: it can become
    unbalanced. Red-black trees provide a solution for that: by rotating subtrees,
    a balanced tree structure is maintained and search performance is guaranteed.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Heaps are a more exotic use of the tree structure. With their primary use as
    a priority queue, they efficiently produce the lowest or highest number of an
    array in constant time. The upheap and downheap operations repair the structure
    upon insert or removal so that the root is again the lowest (min-heap) or highest
    (max-heap) number.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Another very exotic structure is the trie. They are specialized in holding strings
    and very efficiently find the data associated with a certain string by combining
    the characters as nodes with words "branching off" as required.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: To go up in the generalization level, B-Trees are a generic form of a tree.
    They hold several values, with the ranges between them leading to a child node.
    Similar to red-black trees, they are balanced, and adding nodes only happens at
    the leaves where they may be "promoted" to a higher level. Typically, these are
    used in database indices.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, the most generic form of a tree: the graph. Graphs are
    a flexible way to express constrained relationships, such as no cycles, and directionality.
    Typically, each node has weighted connections (edges) that provide some notion
    of cost of transitioning between the nodes.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: With some of the essential data structures covered, the next chapter will explore
    sets and maps (sometimes called dictionaries). In fact, some of those have already
    been used in this chapter, so the next chapter will focus on implementing our
    own.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does a binary search tree skip several nodes when searching?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are self-balancing trees?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is balance in a tree important?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is a heap a binary tree?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are good use cases for tries?
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a B-Tree?
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the fundamental components of a graph?
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
