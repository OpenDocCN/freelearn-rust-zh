- en: Creating a Music Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters you created an awesome game, so now let's move on to another
    exciting topic—desktop applications. We'll use the Rust bindings of the GTK+ library
    in order to code an MP3 music player. We'll have the opportunity to learn about
    threads to code the music player itself in the next chapter. But, in this chapter,
    we'll focus on the graphical interface, how to manage the layout of the interface,
    and how to manage user events.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the prerequisite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since GTK+ is a C library, we'll need to install it first. The Rust bindings
    use GTK+ version 3, so make sure you do not install the old version 2.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GTK+ on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Linux, GTK+ can be installed through the package manager of your distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu (or other Debian derivatives):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing GTK+ on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On OSX, you just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Installing GTK+ on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Windows, you''ll need to first download and install MSYS2, which provides
    a Unix-like environment on Windows. After it is installed, issue the following
    command in a MSYS2 shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating your first window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''re ready to start using GTK+ from Rust. Let''s create a new project
    for our music player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the dependency on the `gio` and `gtk` crates in your `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the content of the `src/main.rs` file with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the application with `cargo run`. You should see a small and empty
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.gif)**Figure 5.1**'
  prefs: []
  type: TYPE_NORMAL
- en: If you saw this window, it means you have installed GTK+ correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain this code in smaller chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As usual, when using an external crate, we need to declare it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we import the types and modules we''ll use from the standard library,
    `gio`, and `gtk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we start the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this function creates a new `gio` application. We provide
    an application ID that can be used to make sure the application is only run once.
    An `Application` makes it easier to manage applications and its windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the window, set its title, and show it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After creating a new window, we set its title and show it.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're actually handling an event; the `startup` is a signal that is emitted
    when the application is registered- so, when it is ready to be used. As you can
    see in the documentation on GTK+ ([https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup](https://developer.gnome.org/gio/stable/GApplication.html#GApplication-startup)),
    signals are represented by strings. This signal is actually called `startup`,
    but the Rust method we used to connect this signal is `connect_startup`. So, we
    need to add `connect_` before the signal name and change the dashes to underscores.
  prefs: []
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The argument of this method is somewhat special:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is what we call a closure. A closure is a concise way of declaring a function
    that does not have a name and can capture the environment. Capturing the environment
    means that it can access the variables from outside the closure, something which
    is not possible to do with normal functions. The methods to connect a signal will
    run the function (in this case, a closure) passed as an argument. Here, create
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have decided to create a normal function, as the following code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But that is less convenient than using a closure. Besides the fact that you
    might need to import other crates and types, you need to specify the types of
    the parameters and the return type. Indeed, type inference is available for closures
    but not for functions. Also, the function must be declared elsewhere, so it can
    become less readable than using a closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `main` function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This starts the `gtk` event loop. This is an infinite loop that processes the
    user events like a button click or a request to close a window. It also manages
    other things like timeouts and asynchronous, IO-like network requests.
  prefs: []
  type: TYPE_NORMAL
- en: Some event handlers require you to return a value, which is the case for the
    signal `delete_event` where we need to return `Inhibit(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing the default behavior of an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Inhibit` type is only a wrapper over the `bool` type. It is used to indicate
    whether we should  stop propagating the event to the default handler or not. To
    see what this means, let''s add an event handler for the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you run it, you'll note that we cannot close the window anymore. That's because
    we returned `Inhibit(true)` to indicate that we want to prevent the default behavior
    of the `delete_event` signal, which is to close the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try a slight variant of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we do not prevent the default handler from being run, so the window
    will be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start our music player by adding a toolbar with the buttons needed for
    such software:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previous/next song
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove song from playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That'll be a good start for our first non-empty window.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll need some additional import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll declare a constant because we''ll use this value elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We'll explain what this is very soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now create a toolbar and add it to the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: Don''t call `window.show()` yet, as we''ll use another method ahead.'
  prefs: []
  type: TYPE_NORMAL
- en: This code is pretty straightforward. The only thing to note is that the `gtk-rs`
    API requires a reference to values in most cases; in this case, we send a reference
    to the toolbar as a parameter to the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see this `add()` method called literally everywhere. It allows you to
    add a widget to another. A widget is a component (visual or not) of a user interface.
    It can be a button, a menu, a separator, but it can also be an invisible component
    such as a box allowing you to place the widgets horizontally. We'll talk about
    containers like `gtk::Box` and how to lay out our widgets later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a button to this toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This creates a toolbar button and adds it to the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Stock item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using the usual `new()` constructor, we decided to use the `new_from_stock()`
    one here. This takes a string as an argument. This string is an identifier for
    the item that represents a built-in menu or toolbar item, such as `Open` or `Save`.
    These items have an icon and a label that is translated according to the user
    locale. By using stock items, you can quickly create a beautiful application that
    will look the same as other applications built with GTK+.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s show this window containing the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This goes right at the end of the startup event handler. Here, we use `show_all()`
    instead of only `show()` because we have more widgets to show. Instead of using
    `show_all()`, we could call `show()` on every single widget, but this can become
    cumbersome; that's why `show_all()` exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this application, you''ll see the following window with an open
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.gif)*Figure 5.2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the open buttons we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code should go right before the call to `window.show_all()`.  `SeparatorToolItem` ,
    which was added several times to separate the buttons logically so that buttons
    for similar actions are grouped together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have an application that is starting to look like a music player, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)*Figure 5.3*'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the organization of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function is starting to get bigger, so we'll refactor our code a
    little to make it easier to update in the upcoming sections and chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a new module called `toolbar`. As a reminder, here''s
    how to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file: `src/toolbar.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a statement, `mod toolbar;`, at the top of the file `main.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This new module `toolbar` will start with the import statement and the `const`
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then create a new structure holding all the widgets that compose the
    toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We use the `pub` keyword here because we want to be able to use this type from
    other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll create a constructor for this `struct` that will create all the
    buttons, like we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference with the previous code is that we now return a `struct
    MusicToolbar`. We''ll also add a method in this `impl` to be able to access the
    `gtk::Toolbar` widget from the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for now for this `toolbar` module. Let''s go back to the `main`
    module. First, we need to import our new `MusicToolbar` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a structure like we did for our toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will also create a constructor for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created the window as we did before and then created our own `MusicToolbar`
    structure. We add the wrapped toolbar widget by sending the result of the `toolbar()`
    method (which returns the `gtk` widget) to the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we used a little trick that enabled us to call a method on the
    `struct` yet to be created; we first assign the `struct` to a variable, then call
    the method and return the variable. This method is defined next, within the same
    `impl` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We'll fill in this method in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tool button events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll continue by adding event handlers to some of the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll need new `use` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `ToolButtonExt`, which provides methods to be called on `ToolButton`
    and `App` from the `main` module, because we''ll add a new method to this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In Rust, it's perfectly valid to declare a method in a module different to where
    the type was created. Here, we say that clicking the quit button will destroy
    the window, which will effectively exit the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another event that will toggle the play button image with the pause
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This code requires a new constant to be added next to `PLAY_STOCK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's first look at the body of the closure before looking at the peculiarities
    of this code. Here, we use a condition to check whether the button is showing
    the play image—if it is, we switch to the pause stock item. Otherwise, we switch
    back to the play icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why do we need to clone the button and use this `move` keyword before the
    closure? Let''s try the normal way, that is, how you would do that in most programming
    languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do that, we get the following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And it continues even further to explain why the lifetime cannot be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the signature of the `connect_clicked()` method to understand
    what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Fn(&Self)` part means the function requires something that looks like a
    function that takes a parameter that is a reference to `Self` (`ToolButton` in
    this case). The `'static` part is a lifetime annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lifetime is one of the Rust features that the compiler uses to ensure memory
    safety. The lifetime specifies the minimum duration an object must live to be
    used safely. Let''s try to do something that is allowed in certain programming
    languages, but is actually an error to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we try to return a reference from a stack-allocated value. The problem
    is that this value will be deallocated when the function returns and the caller
    will try to access this deallocated value. In other programming languages, this
    code will compile fine and produce (hopefully) a segmentation fault at runtime.
    But Rust is a safe programming language and refuses to compile such code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The compile noticed that the value `element` will be deallocated at the end
    of the function; that''s what the sentence on the last line means. This is right,
    because the lifetime of `element` starts from its declaration until the end of
    the scope where it is declared; here, the scope is the function. Here''s an illustration
    of the lifetime of `element`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)*Figure 5.4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'But how does the compiler know what the required lifetime is for the returned
    value? To answer this question, let''s add the lifetime annotations that were
    added by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax for lifetimes is the same as the one used for labels—`'label`.
    When we want to specify the lifetimes, we need to declare the lifetime names between
    angle brackets, in a similar way to how we declare generic types. In this case,
    we specified that the lifetime of the returned value must be the same as the one
    from the parameter `elements`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s annotate the code again with lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)*Figure 5.5*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we clearly see that the lifetime of the returned value is smaller than
    the required one; that's why the compiler rejected our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, there are two ways to fix this code (without changing the signature).
    One way to get a value that satisfies the lifetime `''a` is to get a reference
    to a value of the same lifetime; the parameter `elements` also has the lifetime
    `''a` , so we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to return a reference to a value of lifetime `''static`. This
    special lifetime is equal to the duration of the program, that is, the value must
    live until the end of the program. One way to get such a lifetime is to use a
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The lifetime `'static` satisfies the constraint `'a` because `'static` lives
    longer than the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both of these examples, the lifetime annotations were not required. We didn''t
    have to specify the lifetime in the first place, thanks to a feature called lifetime
    elision; the compiler can infer what the required lifetimes are in most cases
    by following these simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A different lifetime parameter is assigned to each parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's only one parameter that needs a lifetime, that lifetime is assigned
    to every lifetime in the return value (as for our `get_element` function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are multiple parameters that need a lifetime, but one of them is for
    `&self`, the lifetime for `self` is assigned to every lifetime in the return value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go back to the method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we notice that the parameter `f` has the `''static` lifetime. We now
    know that this means that this parameter must live until the end of the program.
    That''s why we cannot use the *normal* version of the closure: because the lifetime
    of `self` is not `''static` , meaning the `app` will get deallocated when the
    `main` function ends. To make this work, we cloned the `play_button` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use this new variable in the closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Take note that cloning a GTK+ widget is really cheap; only a pointer
    is cloned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, trying to do the following will still result in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that the closure can (and will) be called after
    the function returns, but the variable button is declared in the method `connect_toolbar_events()`
    and will be deallocated when it returns. Again, Rust prevents us from having a
    segmentation fault by checking if we correctly use references. The compiler talks
    about ownership; let's look at what that is.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Rust, there''s no garbage collector to deallocate the memory when it''s
    not needed anymore. Also, there''s no need for the programmer to specify where
    the memory should be deallocated. But how can this work? The compiler is able
    to determine when to deallocate the memory thanks to the concept of ownership;
    only one variable can own a value. By this simple rule, the matter of when to
    deallocate the value is simple: when the owner goes out of scope, the value is
    deallocated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how deallocation is related to scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we remove an element from the vector in a new scope—the block for the
    condition. The variable `element` will own the value that was removed from the
    vector (we also say that the value was moved from the vector to the variable `element`).
    Since it owns the value, the variable is not responsible for deallocating it when
    it goes out of scope. Thus, after the condition, the value `"string"` will be
    freed and cannot be accessed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We added the keyword `move` to closure to indicate that the value must be moved
    into the closure. (That's actually what the compiler told us to do, if you remember
    the error message.) By doing so, we satisfy the borrow checker because the value
    is not borrowed anymore. This was causing a lifetime error, but has now been moved
    into the closure and will thus live as long as the closure itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to add the call to this method in the method `App::new()`, right
    after the call to `connect_events()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll now add other widgets to our window: an image to show the cover of the
    song that is currently being played and a cursor to see the progression of the
    music. However, it is not possible to add multiple widgets to a window. To do
    so, we need to use containers.'
  prefs: []
  type: TYPE_NORMAL
- en: Containers are a way to manage how multiple widgets will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Types of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are simple non-visual containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gtk::Box`: disposes widgets either horizontally or vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gtk::Grid`: disposes widgets in rows and columns, like a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gtk::Fixed`: displays widgets at a very specific position in pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gtk::Stack`: displays only one widget at a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these widgets, except `gtk::Fixed` , automatically rearrange the widgets
    when the window is resized. That's why you should avoid using this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more fancy containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gtk::Notebook`: displays only one widget at a time, but the user can select
    which one to show by clicking on a tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gtk::Paned`: displays two widgets, separated by a handle that the user can
    drag to adjust the division between the widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Box container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use a `gtk::Box` to arrange our widgets. First of all, remove the call
    to `Window::add()` that we added before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We remove this call because we''ll instead add the toolbar to the box and the
    box to the window. Let''s do that, but before we do, we''ll add a couple of new
    imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: (This code goes into the `App::new()` method.)
  prefs: []
  type: TYPE_NORMAL
- en: Here, we fully qualified `gtk::Box` because `Box` is a type from the standard
    library that is automatically imported. We specified that the orientation of the
    box is vertical and there's no spacing (`0`) between the children widgets of the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to add widgets to this box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We first add our toolbar, then add an image and load a cover from a static file
    because we haven't yet written the code to extract the cover from an MP3 file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add the cursor widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The cursor widget is named `Scale`. This widget needs an `Adjustment`, which
    is an object that represents which values the cursor can take, and also contains
    the current value and the increment values. Again, since we don't know how to
    fetch the duration of a song from an MP3 file, we hardcode values for  `Adjustment`.
    We also disable the feature to show the actual value of the cursor by calling
    `set_draw_value(false)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)*Figure 5.6*'
  prefs: []
  type: TYPE_NORMAL
- en: (We can almost hear the music when looking at it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this section, we''ll add a few fields to the `App` structure so
    that it becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The end of the `App` constructor is then updated to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Adding a playlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now ready to add the playlist widget to our music player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use new crates, so add the following to the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The crate `gdk_pixbuf` will be used to show and manipulate the cover and the
    `id3` crate to get the metadata from MP3 files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add the following to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a new module to contain this new widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll start this module by adding a bunch of `use` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'These will be followed by some constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*_COLUMN` constant represents the column we''ll show in the playlist.
    The last one, `PIXBUF_COLUMN`, is a bit special: it will be a hidden column holding
    the cover of a bigger size so that we can show this image in the `cover` widget
    we created earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a new structure to hold the widget and its model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the list and tree widgets, GTK+ follows the MVC pattern. MVC stands for
    Model-View-Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add a constructor for our playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `gtk::ListStore` type is a model to represent the data as a list. Its constructor
    needs the types of the columns; in this case, most of the types are strings for
    the metadata of the MP3 files, such as the song title and author name. The first
    `Pixbuf` is for the thumbnail image and the last one is for the bigger image only
    shown for the music currently playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a `TreeView`, which will actually be a view for a list since
    we initialize it with our list model. We then modify the widget so that it expands
    both vertically and horizontally, meaning that the widget will use as much space
    as possible. Finally, just before we return the `struct Playlist`, we call the
    `create_columns()` method, which will create the columns to be shown in this view.
    Let''s see this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we call two methods to create the different types of columns—we specify
    the header label and the column number of every column. As for the last parameter
    of the `add_pixbuf_column()` method, it indicates whether the column is visible
    or not. This parameter is of a custom type, so let''s declare it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We also added a `use` statement to be able to directly use `Visible` instead
    of having to fully qualify it (`Visibility::Visible`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `add_text_column()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating the column itself and setting the label of the header
    by calling `set_title()`. Then, we create a `CellRenderer`, which indicates how
    the data from the model should be rendered in the view; here, we only want to
    show some text, so we chose `CellRendererText`, we set it to take up as much space
    as possible, and added the renderer to the column. Next comes a very important
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This line specifies that the view will set the `text` attribute from the data
    that comes from the model at the specified column.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we add the column to the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll write a similar function for the `pixbuf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new type of renderer (`CellRendererPixbuf`), which will show
    an image instead of text. This time, we set the `pixbuf` attribute because we
    want to show an image. The renderer is only created if the column is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all that''s left is to write a function to get the actual widget to be
    able to add the widget in the `main` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to the method `App::new()` and create the playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: (Add this code right before creating the `Image`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also add a `playlist` attribute in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, don''t forget to edit the creation of the structure to include the following
    new field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to launch our application again to see an empty playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)**Figure 5.7**'
  prefs: []
  type: TYPE_NORMAL
- en: Opening MP3 files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's finish this chapter by adding the ability to open MP3 files and show their
    metadata in the playlist widget we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''ll remove this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is because the image will be set from the data of the MP3 files we play.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a new crate, so add this line in the `[dependencies]` section of
    your `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following line to your `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `*-sys` crates of the `gtk-rs` ecosystem are low-level crates, the ones
    that directly bind to the GTK+ C library. Since they're very low-level and require
    the use of unsafe code, wrappers have been made; these are crates without the
    `-sys` suffix, such as `gtk` and `gdk`.
  prefs: []
  type: TYPE_NORMAL
- en: Reference-counting pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll also change some code before we continue. Since we''ll want to share
    our `Playlist` widget with different parts of our code, including some event handlers,
    we need a way of sharing a reference that will last long enough (remember the
    issue we had with the lifetime). One easy way of doing so is to use a reference-counting
    pointer type—`Rc`. So, in our `App` structure, let''s change the `playlist` field
    to use an `Rc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires a new import at the top of the `main` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the creation of the playlist needs to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We now wrap the `Paylist` inside an `Rc`. We can still use the playlist like
    before, as long as we''re calling immutable methods, that is, methods that take
    `&self` but not `&mut self`. So, the next line is still valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we create the method to add an MP3 file to the playlist, we''ll need
    another method to set the `pixbuf` values in the model from the MP3 metadata.
    In the `impl Playlist`, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The type `Tag` represents the metadata of an MP3 file. We get the first picture
    contained in the file and we load it. If the loading was successful, we resize
    it to get a thumbnail and then we set the values in the model.
  prefs: []
  type: TYPE_NORMAL
- en: ID3— MP3 metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re now ready to get all the relevant metadata from the MP3 files and add
    them to the playlist. Let''s start the `Playlist::add()` method by fetching the
    metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We first get the filename without the extension and convert it to a string;
    we'll show this if there's no song title in the file. Then, we read the metadata
    from the file and assign a default value such as `"(no artist)"` in case a value
    is missing by calling `unwrap_or()`, which gets the value from `Option` if or
    returns the argument if the value is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the rest of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new row in the model and call the `set_pixbuf()` we created
    just before. After that, we set the value in the new row. One special value is
    the path, which will be useful later when we want to play the selected song from
    the playlist; we'll only need to fetch the path and then play it.
  prefs: []
  type: TYPE_NORMAL
- en: Opening files with a file dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s another function we''ll need before we can handle the click event
    of the open button. We need a function that''ll show a file dialog to allow the
    user to select a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This function starts by creating a new file dialog of the type `open`. Afterwards,
    it adds a filter to this dialog so that it only shows MP3 files. Then, we add
    two buttons using some constants that we'll define later. At the moment, we can
    show the dialog by calling `run()`; this function blocks until the dialog is closed
    and returns which button was clicked. After that, we check whether the accept
    button was clicked to save the filename that was selected by the user and we return
    that filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the constants needed by the previous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to handle the click event of the open button. Add the following
    in the method `App::connect_toolbar_events()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In the event handler, we call the function we just defined and, if a file was
    selected, we call the `add()` method of the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now try the application and open an MP3 file. Here''s what you''ll
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)*Figure 5.8*'
  prefs: []
  type: TYPE_NORMAL
- en: Let's add two more features before we end this chapter. The first one is to
    remove a song from the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a song
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add a method to the `Playlist` struct to remove the selected item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This first starts by getting the selection and, if there was one, we remove
    it from the model. We can now add an event handler for the remove button in the
    `App::connect_toolbar_events()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new in this code; we simply clone the reference-counted playlist
    and call a method on it when the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the cover when playing a song
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other feature to add is to show a bigger cover when we click the play button. We''ll
    start by adding a function to get the image from the selection in the playlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This method to be added to the `Playlist` structure starts by getting the selection;
    if there's one, it simply gets the `pixbuf` from the model and returns it. Otherwise,
    it returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now write a function that will fetch the cover from the playlist and
    show the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this function in the `toolbar` module. And, finally, we can call this function
    from the click event handler of the play button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result after adding a song and clicking play:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)*Figure 5.9*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by showing you how to install GTK+ on your machine. You
    then learned how to use `gtk-rs` to create windows, to manage user events like
    mouse click, to add different types of widgets to your window, to arrange your
    widgets with containers, and to show beautiful icons with stock items. You also
    saw how to use complex GTK+ widgets that use the MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: You also gained more knowledge of Rust in the areas of closures, lifetimes,
    and ownerships, which are key concepts in this language.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to extract the metadata of an MP3 file by getting the
    ID3 tags.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll improve the music player so that it can actually
    play a song.
  prefs: []
  type: TYPE_NORMAL
