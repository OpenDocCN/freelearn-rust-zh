<html><head></head><body>
        

                            
                    <h1 class="header-title">Types, Generics, and Traits</h1>
                
            
            
                
<p>Rust's type system is one of the striking features of the language. In this chapter, we'll go into detail on some of the notable aspects of the language such as traits, generics, and how to use them to write expressive code. We'll also explore some of the standard library traits that help with writing idiomatic Rust libraries. Expect lots of interesting material in this chapter!</p>
<p>We'll cover the following topics:</p>
<ul>
<li>Type systems and why they matter</li>
<li>Generic programming</li>
<li>Augmenting types using traits</li>
<li>Exploring standard library traits</li>
<li>Composing traits and generics for writing expressive code</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Type systems and why they matter</h1>
                
            
            
                
<p>"Be conservative in what you send, be liberal in what you accept."                                                                                                                                                                                                                                                                                                         - John Postel</p>
<p>Why do we need types in a language? That's a good question to ask as a motivation to understand type systems in programming languages. As programmers, we know that programs written for computers are represented in binary as combinations of 0s and 1s at the lowest level. In fact, the earliest computers had to be programmed manually in machine code. Eventually, programmers realized that this is very error-prone, tedious, and time-consuming. It's not practical for a human to manipulate and reason about these entities at the binary level. Later, during the 1950s, the programming community came up with machine code mnemonics, which turned into the assembly language we know of today. Following that, programming languages came into existence, which compiled down to assembly code and allowed programmers to write code that is human readable yet easy for computers to compile down to machine code. However, the languages that we humans speak can be quite ambiguous, so a set of rules and constraints needed to be put in place to convey what is possible and what is not in a computer program written in a human-like language, that is, the semantics. This brings us to the idea of types and type systems.</p>
<p>A type is a named set of possible values. For example, <kbd>u8</kbd> is a type that can contain only positive values from 0 to 255. Types provide us with a way to bridge the gap between the lower-level representation and the mental model we create of these entities. Apart from this, types also provide us with a way to express intent, behavior, and constraints for an entity. They define what we can and cannot do with types. For example, it is undefined to add a value of a type string to a value of a type number. From types, language designers built type systems, which are sets of rules that govern how different types interact with one another in a programming language. They act as a tool for reasoning about programs and help ensure that our programs behave correctly and according to the specification. Type systems are qualified based on their expressiveness, which simply means the extent to which you can express your logic, as well as invariants in the program using only the type system. For example, Haskell, a high-level language, has a very expressive type system, while C, a low-level language, provides us with very few type-based abstractions. Rust tries to draw a fine line between these two extremes.</p>
<p>Rust's type system is inspired quite a bit by functional languages such as Ocaml and Haskell with their ADTs such as enums and structs, traits (akin to haskell typeclasses), and error handling types (<kbd>Option</kbd> and <kbd>Result</kbd>). The type system is characterized as a strong type system, which simply means that it performs more type checks at compile time rather than throwing them at runtime. Furthermore, the type system is static, which means that variables that are, for example, bound to an integer value, cannot be changed to point to a string later. These features enable robust programs that rarely break the invariants at runtime, with the cost that writing programs requires a bit of planning and thinking from the programmer. Rust tries to put more planning on your plate when designing programs, which can put off some programmers looking to prototype things fast. However, it is a good thing from the long-term perspective of maintaining software systems.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>With that aside, let's start by exploring how Rust's type system enables code reuse.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generics</h1>
                
            
            
                
<p>From the dawn of high-level programming languages, the pursuit of better abstraction is something that language designers have always strived for. As such, many ideas concerning code reuse emerged. The very first of them was functions. Functions allow you to chunk away a sequence of instructions within a named entity that can be called later many times, optionally accepting any arguments for each invocation. They reduce code complexity and amplify readability. However, functions can only get you so far. If you have a function, say <kbd>avg</kbd>, that calculates the average of a given list of integer values and later you have a use case where you need to calculate the average for a list of float values too, then the usual solution is to create a new function that can average float values from the list of floats. What if you wanted to accept a list of double values too? We probably need to write another function again. Writing the same function over and over again that differs only by its arguments is a waste of precious time for programmers. To reduce this repetition, language designers wanted a way to express code so that the <kbd>avg</kbd> function can be written in a way that accepts multiple types, a generic function, and thus the idea of generic programming, or generics, was born. Having functions that can take more than one type is one of the features of generic programming, and there are other places that generics can be used. We'll explore all of them in this section.</p>
<p>Generic programming is a technique that is only applicable in the case of statically typed programming languages. They first appeared in ML, a statically typed functional language. Dynamic languages such as Python use duck typing, where APIs treat arguments based on what they can do rather than what they are, so they don't rely on generics. Generics are part of the language design feature that enables code reuse and the <strong>Don't repeat yourself </strong>(<strong>DRY</strong>) principle. Using this technique, you can write algorithms, functions, methods, and types with placeholders for types, and specify a type variable (with a single letter, which is usually <kbd>T</kbd>, <kbd>K</kbd>, or <kbd>V</kbd> by convention) on these types, telling the compiler to fill in the actual types later when any code instantiates them. These types are referred to as generic types or items. The single letter symbols such as <kbd>T</kbd> on type are called <strong>generic type</strong> <strong>parameters</strong>. They are substituted with concrete types such as  <kbd>u32</kbd> when you use or instantiate any generic item.</p>
<div><strong>Note</strong>: By substitution, we mean that every time a generic item is used with a concrete type, a specialized copy of that code is generated at compile time with the type variable <kbd>T</kbd>, getting replaced with the concrete type. This process of generating specialized functions with concrete types at compile time is called <strong>monomorphization</strong>, which is the procedure of doing the opposite of polymorphic functions.</div>
<p>Let's look at some of the existing generic types from the Rust standard library.</p>
<p>The <kbd>Vec&lt;T&gt;</kbd> type from the standard library is a generic type that is defined as follows:</p>
<pre class="rust">pub struct Vec&lt;T&gt; {<br/>    buf: RawVec&lt;T&gt;,<br/>    len: usize,<br/>}</pre>
<p>We can see that the type signature of <kbd>Vec</kbd> contains a type parameter <kbd>T</kbd> after its name, surrounded by a pair of angle brackets <kbd>&lt; &gt;</kbd>. Its member field, <kbd>buf</kbd>, is a generic type as well, and so the <kbd>Vec</kbd> itself has to be generic. If we don't have <kbd>T</kbd> on our generic type <kbd>Vec&lt;T&gt;</kbd>, even though we have a <kbd>T</kbd> on its <kbd>buf</kbd> field, we get the following error:</p>
<pre><strong>error[E0412]: cannot find type `T` in this scope</strong></pre>
<p>This <kbd>T</kbd> needs to be part of the type definition for <kbd>Vec</kbd>. So, when we denote a <kbd>Vec</kbd>, we always refer to it by using <kbd>Vec&lt;T&gt;</kbd> when denoting generically or by using <kbd>Vec&lt;u64&gt;</kbd> when we know the concrete type. Next, let's look at how to create our own generic types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating generic types</h1>
                
            
            
                
<p>Rust allows us to declare many things as generics such as structs, enums, functions, traits, methods, and implementation blocks. One thing that they have in common is that the generic type parameters are separated by and enclosed within a pair of <kbd>&lt; &gt;</kbd> brackets. Within them, you can put any number of comma-separated generic type parameters. Let's go through how you might create generics, starting by looking at generic functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic functions</h1>
                
            
            
                
<p>To create a generic function, we place the generic type parameter immediately after the function name and before the parenthesis, like so:</p>
<pre>// generic_function.rs<br/><br/>fn give_me&lt;T&gt;(value: T) {<br/>    let _ = value;<br/>}<br/><br/>fn main() {<br/>    let a = "generics";<br/>    let b = 1024;<br/>    give_me(a);<br/>    give_me(b);<br/>}</pre>
<p>In the preceding code, <kbd>give_me</kbd> is a generic function with <kbd>&lt;T&gt;</kbd> after its name, and the <kbd>value</kbd> parameter is of type <kbd>T</kbd>. In <kbd>main</kbd>, we can call this function with any argument. During compilation, our compiled object file will contain two specialized copies of this function. We can confirm this in our generated binary object file by using the <kbd>nm</kbd> command, like so:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3876463a-6779-4ef4-9d8e-20433f15aa1e.png" style="width:40.17em;height:3.25em;"/></p>
<p><kbd>nm</kbd> is a utility from the GNU binutils package for viewing symbols from compiled object files. By passing <kbd>nm</kbd> our binary, we pipe and grep for the prefix of our <kbd>give_me</kbd> function. As you can see, we have two copies of the function with random IDs appended to them to distinguish them. One of them takes a <kbd>&amp;str</kbd> and the other a <kbd>i32</kbd>, because of two invocations with different arguments.</p>
<p>Generic functions are a cheap way to give the illusion of polymorphic code. I say illusion because after compilation, it is all duplicated code with concrete types as parameters. They come with a downside though, which is an increase in the size of the compiled object file due to code duplication. This is proportional to the number of concrete types that are used. In later sections, when we get to traits, we'll see the true form of polymorphism, trait objects. Still, polymorphism through generics is preferred in most cases because it has no runtime overhead, as is the case with trait objects. Trait objects should only be used when generics don't cater to the solution and cases where you need to store a bunch of types together in a collection. We'll see those examples when we get to trait objects. Next, we'll look at how we can make our structs and enums generic. We'll only explore how to declare them first. Creating and using these types are covered in the later sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic types</h1>
                
            
            
                
<p><strong>Generic structs</strong>: We can declare tuple structs and normal structs generically like so:</p>
<pre>// generic_struct.rs<br/><br/>struct GenericStruct&lt;T&gt;(T);<br/><br/>struct Container&lt;T&gt; {<br/>    item: T<br/>}<br/><br/>fn main() {<br/>    // stuff<br/>}</pre>
<p>Generic structs contain the generic type parameter after the name of the struct, as shown in the preceding code. With this, whenever we denote this struct anywhere in our code, we also need to type the <kbd>&lt;T&gt;</kbd> part together with the type.</p>
<p><strong>Generic enums</strong>: Similarly, we can create generic enums as well:</p>
<pre>// generic_enum.rs<br/><br/>enum Transmission&lt;T&gt; {<br/>    Signal(T),<br/>    NoSignal<br/>}<br/><br/>fn main() {<br/>    // stuff<br/>}</pre>
<p>Our <kbd>Transmission</kbd> enum has a variant called <kbd>Signal</kbd>, which holds a generic value, and a variant called <kbd>NoSignal</kbd>, which is a no value variant.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic implementations</h1>
                
            
            
                
<p>We can also write <kbd>impl</kbd> blocks for our generic types too, but it gets verbose here because of the extra generic type parameters, as we'll see. Let's implement a <kbd>new()</kbd> method on our <kbd>Container&lt;T&gt;</kbd> struct:</p>
<pre>// generic_struct_impl.rs<br/><br/>struct Container&lt;T&gt; {<br/>    item: T<br/>}<br/><br/>impl Container&lt;T&gt; {<br/>    fn new(item: T) -&gt; Self {<br/>        Container { item }<br/>    }<br/>}<br/><br/>fn main() {<br/>    // stuff<br/>}</pre>
<p>Let's compile this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/030da4c0-1c15-493c-82f0-fa4967b03e75.png" style="width:39.25em;height:16.58em;"/></p>
<p>The error message cannot find our generic type <kbd>T</kbd>. When writing an <kbd>impl</kbd> block for any generic type, we need to declare the generic type parameter before using it within our type. <kbd>T</kbd> is just like a variable—a type variable—and we need to declare it. Therefore, we need to modify the implementation block a bit by adding <kbd>&lt;T&gt;</kbd> after <kbd>impl</kbd>, like so:</p>
<pre>impl&lt;T&gt; Container&lt;T&gt; {<br/>    fn new(item: T) -&gt; Self {<br/>        Container { item }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>With that change, the preceding code compiles. The previous <kbd>impl</kbd> block  basically means that we are implementing these methods for all types <kbd>T</kbd>, which appear in <kbd>Container&lt;T&gt;</kbd>. This <kbd>impl</kbd> block is a generic implementation. Therefore, every concrete <kbd>Container</kbd> that ever gets generated will have these methods. Now, we could have also written a more specific <kbd>impl</kbd> block for <kbd>Container&lt;T&gt;</kbd> by putting any concrete type in place of <kbd>T</kbd>. This is what it would look like:</p>
<pre>impl Container&lt;u32&gt; {<br/>    fn sum(item: u32) -&gt; Self {<br/>        Container { item }<br/>    }<br/>}</pre>
<p>In the preceding code, we implemented a method called <kbd>sum</kbd>, which is only present on <kbd>Container&lt;u32&gt;</kbd> types. Here, we don't need the <kbd>&lt;T&gt;</kbd> after <kbd>impl</kbd> because of the presence of <kbd>u32</kbd> as a concrete type. This is another nice property of <kbd>impl</kbd> blocks, which allows you to specialize generic types by implementing methods independently.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using generics</h1>
                
            
            
                
<p>Now, the way we instantiate or use generic types is also a bit different than their non-generic counterparts. Any time we instantiate them, the compiler needs to know the concrete type in place of <kbd>T</kbd> in their type, signature, which gives it the type information to monomorphize the generic code. Most of the time, the concrete type is inferred based on the instantiation of the type or by calling any method that takes a concrete type in the case of generic functions. In rare cases, we need to help the compiler by specifically typing out the concrete type in place of the generic type by using the turbofish (<kbd>::&lt;&gt;</kbd>) operator. We'll see how that is used in a moment.</p>
<p>Let's look at the case of instantiating <kbd>Vec&lt;T&gt;</kbd>, a generic type. Without any type signature, the following code does not compile:</p>
<pre>// creating_generic_vec.rs<br/><br/>fn main() {<br/>    let a = Vec::new();<br/>}</pre>
<p>Compiling the preceding code, gives the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/156ddf29-ad47-42a3-af39-d8a5a315707a.png" style="width:37.75em;height:10.33em;"/></p>
<p>This is because the compiler doesn't know what type <kbd>a</kbd> would contain until we specify it manually or call one of its methods, thereby passing in a concrete value. This is shown in the following snippet:</p>
<pre>// using_generic_vec.rs<br/><br/>fn main() {<br/>    // providing a type<br/>    let v1: Vec&lt;u8&gt; = Vec::new();<br/><br/>    // or calling method<br/>    let mut v2 = Vec::new();<br/>    v2.push(2);    // v2 is now Vec&lt;i32&gt;<br/><br/>    // or using turbofish<br/>    let v3 = Vec::&lt;u8&gt;::new();    // not so readable<br/>}</pre>
<p>In the second code snippet, we specified the type of <kbd>v1</kbd> to be a <kbd>Vec</kbd> of <kbd>u8</kbd>, and it compiles fine. Another way, as with <kbd>v2</kbd>, is to call a method that accepts any concrete type. After the <kbd>push</kbd> method call, the compiler can infer that <kbd>v2</kbd> is a <kbd>Vec&lt;i32&gt;</kbd>. The other way to create the <kbd>Vec</kbd> is to use the <kbd>turbofish</kbd> operator, as is the case with <kbd>v3</kbd> binding in the preceding code.</p>
<p>The <kbd>turbofish</kbd> operator in generic functions appears right after the function name and before the parenthesis. Another example of this is the generic <kbd>parse</kbd> function from the <kbd>std::str</kbd> module. <kbd>parse</kbd> can parse values from a string, and many types are able to parse from it, such as <kbd>i32</kbd>, <kbd>f64</kbd>, <kbd>usize</kbd>, and so on, so it's a generic type. So, when using <kbd>parse</kbd>, you really need to use the <kbd>turbofish</kbd> operator, like so:</p>
<pre>// using_generic_func.rs<br/><br/>use std::str;<br/><br/>fn main() {<br/>    let num_from_str = str::parse::&lt;u8&gt;("34").unwrap();<br/>    println!("Parsed number {}", num_from_str);<br/>}</pre>
<p>Something to take note of is that only types that implement the <kbd>FromStr</kbd> interface or trait can be passed to the <kbd>parse</kbd> function. <kbd>u8</kbd> has an implementation of <kbd>FromStr</kbd>, and so we were able to parse it in the preceding code. The <kbd>parse</kbd> function uses the <kbd>FromStr</kbd> trait to limit types that can be passed to it. We'll get to know how we can mix generics and traits after we're done exploring traits.</p>
<p>With the idea of generics under our belt, let's focus on one of the most ubiquitous features in Rust, traits!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Abstracting behavior with traits</h1>
                
            
            
                
<p>From a polymorphism and code reuse perspective, it is often a good idea to separate shared behavior and common properties of types from themselves in code and only have methods that are unique to themselves. In doing so, we allow different types to relate to each other with these common properties, which allows us to program for APIs that are more general or inclusive in terms of their parameters. This means that we can accept types that have those shared properties while not being restricted to one particular type.</p>
<p>In object-oriented languages such as Java or C#, interfaces convey the same idea, where we can define shared behavior that many types can implement. For example, instead of having multiple <kbd>sort</kbd> functions, which take in a list of integer values, and other functions that take in a list of string values, we can have a single <kbd>sort</kbd> function that can take a list of items that implement the <kbd>Comparable</kbd> or <kbd>Comparator</kbd> interface. This allows us to pass anything that is <kbd>Comparable</kbd> to our <kbd>sort</kbd> function.</p>
<p>Rust also has a similar yet powerful construct known as <strong>traits</strong>. There are many forms of traits in Rust, and we'll look at most of them and the ways we can interact with them briefly. Also, when traits are mixed with generics, we can restrict the range of parameters that we can pass to our APIs. We'll see how that happens when we learn more about trait bounds.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Traits</h1>
                
            
            
                
<p>A trait is an item that defines a set of contracts or shared behavior that types can opt to implement. Traits are not usable by themselves and are meant to be implemented by types. Traits have the power to establish relationships between distinct types. They are the backbone to many language features such as closures, operators, smart pointers, loops, compile-time data race checks, and much more. Quite a few of the high-level language features in Rust boil down to some type calling a trait method that it implements. With that said, let's look at how we can define and use a trait in Rust!</p>
<p>Let's say we are modeling a simple media player application that can play audio and video files. For this demo, we'll create a project by running <kbd>cargo new super_player</kbd>. To convey the idea of traits and to make this simple, in our <kbd>main.rs</kbd> file, we have represented our audio and video media as tuple structs with the name of the media as a <kbd>String</kbd>, like so:</p>
<pre>// super_player/src/main.rs<br/><br/>struct Audio(String);<br/>struct Video(String);<br/><br/>fn main() {<br/>    // stuff<br/>}</pre>
<p>Now, at the very minimum, both the <kbd>Audio</kbd> and <kbd>Video</kbd> structs need to have a <kbd>play</kbd> and <kbd>pause</kbd> method. It's a functionality that's shared by both of them. It's a good opportunity for us to use a trait here. Here, we'll define a trait called <kbd>Playable</kbd> with two methods in a separate module called <kbd>media.rs</kbd>, like so:</p>
<pre>// super_player/src/media.rs<br/><br/>trait Playable {<br/>    fn play(&amp;self);<br/>    fn pause() {<br/>        println!("Paused");<br/>    }<br/>}</pre>
<p>We use the <kbd>trait</kbd> keyword to create a trait, followed by its name and a pair of braces. Within the braces, we can provide zero or more methods that any type implementing the trait should fulfill. We can also define constants within traits, which all of the implementers can share. The implementer can be any struct, enum, primitive, function, closure, or even a trait.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You may have noticed the signature of <kbd>play</kbd>; it takes a reference to a symbol, <kbd>self</kbd>, but does not have a body, and ends with a semicolon.  <kbd>self</kbd> is just a type alias to <kbd>Self</kbd>, which refers to the type on which the trait is being implemented. We'll cover these in detail in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>,  <em>Advanced Concepts</em>. This means that the methods within the traits are like an abstract method from Java. It is up to the types to implement this trait and define the function according to their use case. However, methods declared within a trait can also have default implementations, as is the case with the <kbd>pause</kbd> function in the preceding code. <kbd>pause</kbd> does not take <kbd>self</kbd>, and so it's akin to a static method that does not require an instance of the implementer to invoke it.</p>
<p>We can have two kinds of methods within a trait:</p>
<ul>
<li><strong>Associated methods</strong>: These are methods that are available directly on the type implementing the trait and do not need an instance of the type to invoke them. There are also known as static methods in mainstream languages, for example, the <kbd>from_str</kbd> method from the <kbd>FromStr</kbd> trait in the standard library. It is implemented for a <kbd>String</kbd> and thus allows you to create a <kbd>String</kbd> from a <kbd>&amp;str</kbd> by calling <kbd>String::from_str("foo")</kbd>.</li>
<li><strong>Instance methods</strong>: These are methods that have their first parameter as <kbd>self</kbd>. These are only available on instances of the type that are implementing the trait.  <kbd>self</kbd> points to the instance of the type implementing the trait. It can be of three types: <kbd>self</kbd>  methods, which consume the instance when called; <kbd>&amp;self</kbd> methods, which only have read access to the instance its members (if any); and <kbd>&amp;mut self</kbd> methods, which have mutable access to its members and can modify them or even replace them with another instance. For example, the <kbd>as_ref</kbd> method from the <kbd>AsRef</kbd> trait in the standard library is an instance method that takes <kbd>&amp;self</kbd>, and is meant to be implemented by types that can be converted to a reference or a pointer. We'll cover references and the <kbd>&amp;</kbd> and <kbd>&amp;mut</kbd> parts of the type signature in these methods when we get to <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 5</a>, <em>Memory Management and Safety.</em></li>
</ul>
<p>Now, we'll implement the preceding <kbd>Playable</kbd> trait on our <kbd>Audio</kbd>  and <kbd>Video</kbd> types, like so:</p>
<pre>// super_player/src/main.rs<br/><br/>struct Audio(String);<br/>struct Video(String);<br/><br/>impl Playable for Audio {<br/>    fn play(&amp;self) {<br/>        println!("Now playing: {}", self.0);<br/>    }<br/>}<br/><br/>impl Playable for Video {<br/>    fn play(&amp;self) {<br/>        println!("Now playing: {}", self.0);<br/>    }<br/>}<br/><br/>fn main() {<br/>    println!("Super player!");<br/>}</pre>
<p>We write trait implementations with the <kbd>impl</kbd> keyword followed by the trait name, followed by the <kbd>for</kbd> keyword and the type we want to implement the trait for, followed by a pair of braces. Within these braces, we are required to provide the implementations of methods, and optionally override any default implementation that exists in the trait. Let's compile this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cfa66081-2815-459f-94f9-16b38038c29f.png"/></p>
<p>The preceding error highlights an important feature of traits: traits are private by default. To be usable by other modules or across crates, they need to be made public. There are two steps to this. First, we need to expose our trait to the outside world. To do that, we need to prepend our <kbd>Playable</kbd> trait declaration with the <kbd>pub</kbd> keyword:</p>
<pre>// super_player/src/media.rs<br/><br/>pub trait Playable {<br/>    fn play(&amp;self);<br/>    fn pause() {<br/>        println!("Paused");<br/>    }<br/>}</pre>
<p>After we have exposed our trait, we need to use the <kbd>use</kbd> keyword to bring the trait into scope in the module we want to use the trait in. This will allow us to call its methods, like so:</p>
<pre>// super_player/src/main.rs<br/><br/>mod media;<br/><br/>struct Audio(String);<br/>struct Video(String);<br/><br/>impl Playable for Audio {<br/>    fn play(&amp;self) {<br/>        println!("Now playing: {}", self.0);<br/>    }<br/>}<br/><br/>impl Playable for Video {<br/>    fn play(&amp;self) {<br/>        println!("Now playing: {}", self.0);<br/>    }<br/>}<br/><br/>fn main() {<br/>    println!("Super player!");<br/>    let audio = Audio("ambient_music.mp3".to_string());<br/>    let video = Video("big_buck_bunny.mkv".to_string());<br/>    audio.play();<br/>    video.play();<br/>}</pre>
<p>With that, we can play our audio and video media:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e9db8c6-9ad4-4880-b753-13f114e2fe5e.png" style="width:39.92em;height:7.50em;"/></p>
<p>This is very far from any actual media player implementation, but our aim was to explore the use case for traits.</p>
<p>Traits can also specify in their declaration that they depend on other traits; this is a feature known as trait inheritance. We can declare inherited traits like so:</p>
<pre>// trait_inheritance.rs<br/><br/>trait Vehicle {<br/>    fn get_price(&amp;self) -&gt; u64;<br/>}<br/><br/>trait Car: Vehicle {<br/>    fn model(&amp;self) -&gt; String;<br/>}<br/><br/>struct TeslaRoadster {<br/>    model: String,<br/>    release_date: u16<br/>}<br/><br/>impl TeslaRoadster {<br/>    fn new(model: &amp;str, release_date: u16) -&gt; Self {<br/>        Self { model: model.to_string(), release_date }<br/>    }<br/>}<br/><br/>impl Car for TeslaRoadster {<br/>    fn model(&amp;self) -&gt; String {<br/>        "Tesla Roadster I".to_string()<br/>    }<br/>}<br/><br/>fn main() {<br/>    let my_roadster = TeslaRoadster::new("Tesla Roadster II", 2020);<br/>    println!("{} is priced at ${}", my_roadster.model, my_roadster.get_price());<br/>}</pre>
<p>In the preceding code, we declared two traits: a <kbd>Vehicle</kbd> (a more general) trait and a <kbd>Car</kbd> (more specific) trait, which depends on <kbd>Vehicle</kbd>. Since <kbd>TeslaRoadster</kbd> is a car, we implemented the <kbd>Car</kbd> trait for it. Also, notice the body of the method <kbd>new</kbd> on <kbd>TeslaRoadster</kbd>, which uses <kbd>Self</kbd> as the return type. This is also substituted for the <kbd>TeslaRoadster</kbd> instance that we return from <kbd>new</kbd>. <kbd>Self</kbd> is just a convenient type alias for the implementing type within the trait's impl blocks. It can also be used to create other types, such as tuple structs and enums, and also in match expressions. Let's try compiling this code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f86789bc-8698-45a2-a43d-017c212d109e.png" style="width:41.83em;height:12.58em;"/></p>
<p>See that error? In its definition, the <kbd>Car</kbd> trait specifies the constraint that any type that implements the trait must also implement the <kbd>Vehicle</kbd> trait, <kbd>Car: Vehicle</kbd>. We did not implement <kbd>Vehicle</kbd> for our <kbd>TeslaRoadster</kbd>, and Rust caught and reported it for us. Therefore, we must implement the <kbd>Vehicle</kbd> trait like so:</p>
<pre>// trait_inheritance.rs<br/><br/>impl Vehicle for TeslaRoadster {<br/>    fn get_price(&amp;self) -&gt; u64 {<br/>        200_000<br/>    }<br/>}</pre>
<p>With that implementation satisfied, our program compiles fine with the following output:</p>
<pre> Tesla Roadster II is priced at $200000</pre>
<p>The underscore in <kbd>200_200</kbd> in the <kbd>get_price</kbd> method is a handy syntax to create readable numeric literals.</p>
<p>As an analogy to object-oriented languages, traits and their implementations are similar to interfaces and classes that implement those interfaces. However, it is to be noted that traits are very different from interfaces:</p>
<ul>
<li>Even though traits have a form of inheritance in Rust, implementations do not. This means that a trait called <kbd>Panda</kbd> can be declared, which requires another trait called <kbd>KungFu</kbd> to be implemented by types that implement <kbd>Panda</kbd>. However, the types themselves don't have any sort of inheritance. Therefore, instead of object inheritance, type composition is used, which relies on trait inheritance to model any real-world entity in code.</li>
<li>You can write trait implementation blocks anywhere, without having access to the actual type.</li>
<li>You can also implement your own traits on any type ranging from built-in primitive types to generic types.</li>
<li>You cannot implicitly have return types as traits in a function like you can return an <em>interface</em> as a return type in Java. You have to return something called a trait object, and the syntax to do that is explicit. We'll see how to do that when we get to trait objects.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The many forms of traits</h1>
                
            
            
                
<p>In the preceding examples, we had a glimpse of the simplest form of trait. But there's more to traits than meets the eye. As you start interacting with traits in bigger code bases, you will encounter different forms of them. Depending on the complexity of the program and the problem to be solved, the simple form of traits might not be suitable. Rust provides us with other forms of traits that model the problem well. We'll take a look at some of the standard library traits and try to classify them so that we have a good idea when to use what.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Marker traits</h1>
                
            
            
                
<p>Traits defined in the <kbd>std::marker</kbd> module are called <strong>marker traits</strong>. These traits don't have any method, and simply have their declaration with their name with an empty body. Examples from the standard library include <kbd>Copy</kbd>, <kbd>Send</kbd>, and <kbd>Sync</kbd>. They are called marker traits because they are used to simply mark a type as belonging to a particular family for to gain some compile time guarantees. Two such examples from the standard library are the <kbd>Send</kbd> and <kbd>Sync</kbd> traits that are auto-implemented by the language for most types whenever appropriate, and convey which values are safe to send and share across threads. We'll get to know more about them in <a href="8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml">Chapter 8</a>, <em>Concurrency</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple traits</h1>
                
            
            
                
<p>This is the simplest form a trait definition could possibly be. We already discussed this as an introduction to traits:</p>
<pre>trait Foo {<br/>    fn foo();<br/>}</pre>
<p>An example from the standard library would be the <kbd>Default</kbd> trait, which is implemented for types that can be initialized with a default value. It is documented at <a href="https://doc.rust-lang.org/std/default/trait.Default.html">https://doc.rust-lang.org/std/default/trait.Default.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Generic traits</h1>
                
            
            
                
<p>Traits can also be generic. This is useful in scenarios where you want to implement a trait for a wide variety of types:</p>
<pre>pub trait From&lt;T&gt; {<br/>    fn from(T) -&gt; Self;<br/>}</pre>
<p>Two such examples are is the <kbd>From&lt;T&gt;</kbd> and <kbd>Into&lt;T&gt;</kbd> traits, which allow from conversion from a type to a type <kbd>T</kbd> and vice versa. Their use becomes prominent when these traits are used as trait bounds in function parameters. We'll see what trait bounds are and how they work in a moment. However, generic traits can get quite verbose when they are declared with three or four generic types. For those cases, we have associated type traits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Associated type traits</h1>
                
            
            
                
<pre>trait Foo {<br/>    type Out;<br/>    fn get_value(self) -&gt; Self::Out;<br/>}</pre>
<p>These are a better alternative to generic traits due to their ability to declare associated types within the trait, like the <kbd>Out</kbd> type in the declaration of <kbd>Foo</kbd> in the preceding code. They have a less verbose type signature. The advantage of them is that, in the implementation, they allow us to declare the associated type once and use <kbd>Self::Out</kbd> as the return type or parameter type in any of the trait methods or functions. This removes the redundant specification of types, as is the case with generic traits. One of the finest examples of associated type traits is the <kbd>Iterator</kbd> trait, which is used for iterating over the values of a custom type. Its documentation can be found at <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a>. We'll dig deeper into iterators when we get to <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 8</a>,  <em>Advanced Topics</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inherited traits</h1>
                
            
            
                
<p>We already saw these traits in our <kbd>trait_inheritance.rs</kbd> code example. Unlike types in Rust, traits can have an inheritance relationship, for instance:</p>
<pre>trait Bar {<br/>    fn bar();<br/>}<br/><br/>trait Foo: Bar {<br/>    fn foo();<br/>}</pre>
<p>In the preceding snippet , we declared a trait, <kbd>Foo</kbd>, that depends on a super trait, <kbd>Bar</kbd>. The definition of <kbd>Foo</kbd> mandates implementing <kbd>Bar</kbd> whenever you are implementing <kbd>Foo</kbd> for your type. One such example from the standard library is the <kbd>Copy</kbd> trait, which requires  the type to also implement the <kbd>Clone</kbd> trait.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using traits with generics – trait bounds</h1>
                
            
            
                
<p>Now that we have a decent idea about generics and traits, we can explore ways in which we can combine them to express more about our interfaces at compile time. Consider the following code:</p>
<pre>// trait_bound_intro.rs<br/><br/>struct Game;<br/>struct Enemy;<br/>struct Hero;<br/><br/>impl Game {<br/>    fn load&lt;T&gt;(&amp;self, entity: T) {<br/>        entity.init();<br/>    }<br/>}<br/><br/>fn main() {<br/>    let game = Game;<br/>    game.load(Enemy);<br/>    game.load(Hero);<br/>}</pre>
<p>In the preceding code, we have a generic function, <kbd>load</kbd>, on our <kbd>Game</kbd> type that can take any game entity and load it in our game world by calling <kbd>init()</kbd> on all kinds of <kbd>T</kbd>. However, this example fails to compile with the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f9c1cf25-669f-4489-9bb2-f5592e705788.png" style="width:39.75em;height:10.33em;"/></p>
<p>So, a generic function taking any type <kbd>T</kbd> cannot know or assume by default  the <kbd>init</kbd> method exists on <kbd>T</kbd>. If it did, it wouldn't be generic at all, and would only be able to accept types that have the <kbd>init()</kbd> method on them. So, there is a way that we can let the compiler know of this and constrain the set of types that <kbd>load</kbd> can accept using traits. This is where trait bounds come into the picture. We can define a trait called <kbd>Loadable</kbd> and implement it on our our <kbd>Enemy</kbd> and <kbd>Hero</kbd> types. Following that, we have to put a couple of symbols beside our generic type declaration to specify the trait. We call this a trait bound. The changes to the code are as follows:</p>
<pre>// trait_bounds_intro_fixed.rs<br/><br/>struct Game;<br/>struct Enemy;<br/>struct Hero;<br/><br/>trait Loadable {<br/>    fn init(&amp;self);<br/>}<br/><br/>impl Loadable for Enemy {<br/>    fn init(&amp;self) {<br/>        println!("Enemy loaded");<br/>    }<br/>}<br/><br/>impl Loadable for Hero {<br/>    fn init(&amp;self) {<br/>        println!("Hero loaded");<br/>    }<br/>}<br/><br/>impl Game {<br/>    fn load&lt;T: Loadable&gt;(&amp;self, entity: T) {<br/>        entity.init();<br/>    }<br/>}<br/><br/>fn main() {<br/>    let game = Game;<br/>    game.load(Enemy);<br/>    game.load(Hero);<br/>}</pre>
<p>In this new code, we implement Loadable for both <kbd>Enemy</kbd> and <kbd>Hero</kbd> and we also modified the load method as follows:</p>
<pre>fn load&lt;T: Loadable&gt;(&amp;self, entity: T) { .. }</pre>
<p>Notice the <kbd>: Loadable</kbd> part. This is how we specify a trait bound. Trait bounds allow us to constrain the range of parameters that a generic API can accept. Specifying a trait bound on a generic item is similar to how we specify types for variables, but here the variable is the generic type <kbd>T</kbd> and the type is some trait, such as <kbd>T: SomeTrait</kbd>. Trait bounds are almost always needed when defining generic functions. If one defines a generic function that takes <kbd>T</kbd> without any trait bounds, we cannot call any of the methods since Rust does not know what implementation to use for the given method. It needs to know whether <kbd>T</kbd> has the <kbd>foo</kbd> method or not to monomorphize the code. Take a look at another example:</p>
<pre>// trait_bounds_basics.rs<br/><br/>fn add_thing&lt;T&gt;(fst: T, snd: T) {<br/>    let _ = fst + snd;<br/>}<br/><br/>fn main() {<br/>    add_thing(2, 2);<br/>}</pre>
<p>We have a method,  <kbd>add_thing</kbd>, that can add any type <kbd>T</kbd>. If we compile the preceding snippet, it does not compile and gives the following error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/677a9ad2-011e-4d14-a6ff-adf0b2af2dc0.png" style="width:45.33em;height:14.33em;"/></p>
<p>It says to add a trait bound <kbd>Add</kbd> on <kbd>T</kbd>. The reason for this is that the addition operation is dictated by the <kbd>Add</kbd> trait, which is generic, and different types have different implementations that might even return a different type altogether. This means that Rust needs our help to annotate that for us. Here, we need to modify our function definition like so:</p>
<pre>// trait_bound_basics_fixed.rs<br/><br/>use std::ops::Add;<br/><br/>fn add_thing&lt;T: Add&gt;(fst: T, snd: T) {<br/>    let _ = fst + snd;<br/>}<br/><br/>fn main() {<br/>    add_thing(2, 2);<br/>}</pre>
<p>We added the <kbd>: Add</kbd> after <kbd>T</kbd> and with that change, our code compiles. Now, there are two ways to specify trait, bounds depending on how complex the type signature gets when defining generic items with trait bounds:</p>
<p><strong>In-between generics</strong>:</p>
<pre>fn show_me&lt;T: Display&gt;(val: T) {<br/>    // can use {} format string now, because of Display bound<br/>    println!("{}", val);<br/>}</pre>
<p>This is the most common syntax to specify trait bounds on generic items. We read the preceding function as follows <kbd>show_me</kbd> is a method that takes any type that implements the <kbd>Display</kbd> trait. This is the usual syntax used to declare the trait bound when the length of the type signature of the generic function is small. This syntax also works when specifying trait bounds on types. Now, let's look at the second way to specify trait bounds.</p>
<p><strong>Using where clauses:</strong></p>
<p>This syntax is used when the type signature of any generic item becomes too large to fit on a line. For example, there is a <kbd>parse</kbd> method in the standard library's <kbd>std::str</kbd> module, which has the following signature:</p>
<pre>pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;<br/>where F: FromStr { ... }</pre>
<p>Notice the <kbd>where F: FromStr</kbd> part. This tells us that our <kbd>F</kbd> type must implement the <kbd>FromStr</kbd> trait. The <kbd>where</kbd> clause decouples the trait bound from the function signature and makes it readable.</p>
<p>Having seen how to write trait bounds, it's important to know where can we specify these bounds. Trait bounds are applicable in all of the places where you can use generics.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trait bounds on types</h1>
                
            
            
                
<p>We can specify trait bounds on types too:</p>
<pre>// trait_bounds_types.rs<br/><br/>use std::fmt::Display;<br/><br/>struct Foo&lt;T: Display&gt; {<br/>    bar: T<br/>}<br/><br/>// or<br/><br/>struct Bar&lt;F&gt; where F: Display {<br/>    inner: F<br/>}<br/><br/>fn main() {}</pre>
<p class="mce-root"/>
<p>However, trait bounds on types are discouraged as it places restrictions on types themselves. Generally, we want types to be as generic as possible, allowing us to create instances using any type, and instead place restrictions on their behavior using traits bounds in functions or methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trait bounds on generic functions and impl blocks</h1>
                
            
            
                
<p>This is the most common place where trait bounds are used. We can specify trait bounds on functions and also on generic implementations, as shown in the following example:</p>
<pre>// trait_bounds_functions.rs<br/><br/>use std::fmt::Debug;<br/><br/>trait Eatable {<br/>    fn eat(&amp;self);<br/>}<br/><br/>#[derive(Debug)]<br/>struct Food&lt;T&gt;(T);<br/><br/>#[derive(Debug)]<br/>struct Apple;<br/><br/>impl&lt;T&gt; Eatable for Food&lt;T&gt; where T: Debug {<br/>    fn eat(&amp;self) {<br/>        println!("Eating {:?}", self);<br/>    }<br/>}<br/><br/>fn eat&lt;T&gt;(val: T) where T: Eatable {<br/>    val.eat();<br/>}<br/><br/>fn main() {<br/>    let apple = Food(Apple);<br/>    eat(apple);<br/>}</pre>
<p>We have a generic type <kbd>Food</kbd> and a specific food type <kbd>Apple</kbd> that we put into a <kbd>Food</kbd> instance and bind to variable <kbd>apple</kbd>. Next, we call the generic method <kbd>eat</kbd>, passing <kbd>apple</kbd>. Looking at the signature of <kbd>eat</kbd>, the type <kbd>T</kbd> has to be <kbd>Eatable</kbd>. To make <kbd>apple</kbd> eatable, we implement the <kbd>Eatable</kbd> trait for <kbd>Food</kbd>, also specifying that our type has to be <kbd>Debug</kbd> to make it printable to the console inside our method. This is a dumb example but demonstrates the idea.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using + to compose traits as bounds</h1>
                
            
            
                
<p>We can also specify multiple trait bounds to a generic type using the <kbd>+</kbd> symbol. Let's take a look at the impl block for the <kbd>HashMap</kbd> type from the standard library:</p>
<pre>impl&lt;K: Hash + Eq, V&gt; HashMap&lt;K, V, RandomState&gt;</pre>
<p>Here, we can see that <kbd>K</kbd>, denoting the type of the <kbd>HashMap</kbd> key, has to implement the <kbd>Eq</kbd> trait, as well as the <kbd>Hash</kbd> trait.</p>
<p>We can also combine traits to create a new trait, that represents all of them:</p>
<pre>// traits_composition.rs<br/><br/>trait Eat {<br/>    fn eat(&amp;self) {<br/>        println!("eat");<br/>    }<br/>}<br/>trait Code {<br/>    fn code(&amp;self) {<br/>        println!("code");<br/>    }<br/>}<br/>trait Sleep {<br/>    fn sleep(&amp;self) {<br/>        println!("sleep");<br/>    }<br/>}<br/><br/>trait Programmer : Eat + Code + Sleep {<br/>    fn animate(&amp;self) {<br/>        self.eat();<br/>        self.code();<br/>        self.sleep();<br/>        println!("repeat!");<br/>    }<br/>}<br/><br/>struct Bob;<br/>impl Programmer for Bob {}<br/>impl Eat for Bob {}<br/>impl Code for Bob {}<br/>impl Sleep for Bob {}<br/><br/>fn main() {<br/>    Bob.animate();<br/>}</pre>
<p>In the preceding code, we created a new trait <kbd>Programmer</kbd>, that is a composition of three traits, <kbd>Eat</kbd> <kbd>Code</kbd> and <kbd>Sleep</kbd>. In this way, we have put constraints on the type, so that if a type <kbd>T</kbd> implements <kbd>Programmer</kbd>, it has to implement all the other traits. Running the code produces the following output:</p>
<pre>eat<br/>code<br/>sleep<br/>repeat!</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Trait bounds with impl trait syntax</h1>
                
            
            
                
<p>The other syntax for declaring trait bounds is the impl trait syntax, which is a recent addition to the compiler. Using this syntax, you can also write a generic function with trait bounds like this:</p>
<pre>// impl_trait_syntax.rs<br/><br/>use std::fmt::Display;<br/><br/>fn show_me(val: impl Display) {<br/>    println!("{}", val);<br/>}<br/><br/>fn main() {<br/>    show_me("Trait bounds are awesome");<br/>}</pre>
<p>Instead of specifying <kbd>T: Display</kbd>, we directly use <kbd>impl Display</kbd>. This is the impl trait syntax. This provides advantages in cases where we want to return a complex or unrepresentable type, such as a closure from a function. Without this syntax, you had to return it by putting it behind a pointer using the <kbd>Box</kbd> smart pointer type, which involves heap allocation. Closures under the hood are implemented as structs that implement a family of traits. One of these traits is the <kbd>Fn(T) -&gt; U</kbd> trait. So, using the impl trait syntax, it's now possible to write functions where we can write something like this: </p>
<pre>// impl_trait_closure.rs<br/><br/>fn lazy_adder(a:u32, b: u32) -&gt; impl Fn() -&gt; u32 {<br/>    move || a + b<br/>}<br/><br/>fn main() {<br/>    let add_later = lazy_adder(1024, 2048);<br/>    println!("{:?}", add_later());<br/>}</pre>
<p>In the preceding code, we created a function, <kbd>lazy_adder</kbd>, that takes in two numbers and returns a closure that adds two numbers. We then call <kbd>lazy_adder</kbd>, passing in two numbers. This creates a closure in <kbd>add_later</kbd> but does not evaluate it. In <kbd>main</kbd>, we called <kbd>add_later</kbd> in the <kbd>println!</kbd> macro. We can even have this syntax in both places, like so:</p>
<pre>// impl_trait_both.rs<br/><br/>use std::fmt::Display;<br/><br/>fn surround_with_braces(val: impl Display) -&gt; impl Display {<br/>    format!("{{{}}}", val)<br/>}<br/><br/>fn main() {<br/>    println!("{}", surround_with_braces("Hello"));<br/>}</pre>
<p><kbd>surround_with_braces</kbd> takes in anything that is <kbd>Display</kbd> and returns a string surrounded with <kbd>{}</kbd>. Here, both our return types are <kbd>impl Display</kbd>.</p>
<p>The extra braces are there to escape the brace itself, as <kbd>{}</kbd> has a special meaning in string formatting for string interpolation.</p>
<p>The impl trait syntax for trait bounds is mostly recommended to be used as return types from functions. Using it in parameter position means that we can't use the turbofish operator. This can cause API incompatibility if some dependent code uses the turbofish operator to invoke one of your crate's methods. It should only be used when we don't have a concrete type available to us, as is the case with closures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring standard library traits</h1>
                
            
            
                
<p>Rust's standard library has a lot of built-in traits. Most of the syntatic sugar in Rust is due to traits. These traits also provide a nice baseline upon which crate authors can provide an idiomatic interface to their libraries. In this section, we'll explore some of the abstractions and conveniences of the standard library traits that enhance the experience for a crate author and the consumer. We'll base our exploration from a library author's perspective and create a library that provides support for complex number types. This example serves well to introduce the common traits you have to implement if you are creating a crate of your own.</p>
<p>We'll create a new project by running <kbd>cargo new complex --lib</kbd>. To start with, we need to represent our complex number as a type. We'll use a struct for this. Our complex number struct has two fields: the <em>real</em> and <em>imaginary</em> part of a complex number. Here's how we have defined it:</p>
<pre>// complex/src/lib.rs<br/><br/>struct Complex&lt;T&gt; {<br/>    // Real part<br/>    re: T,<br/>    // Complex part<br/>    im: T<br/>}</pre>
<p>We're making it generic over <kbd>T</kbd>, as <kbd>re</kbd> and <kbd>im</kbd> can both be a float or an integer value. For this type to be of any use, we want ways to create instances of it. The usual way to do this is to implement the associated method <kbd>new</kbd>, where we pass the values for <kbd>re</kbd> and <kbd>im</kbd>. What if we also wanted to initialize a complex value with defaults (say <kbd>re = 0</kbd>, <kbd>im = 0</kbd>) ? For this, we have a trait called <kbd>Default</kbd>. Implementing <kbd>Default</kbd> is very simple for a user-defined type; we can just put a <kbd>#[derive(Default)]</kbd> attribute over the <kbd>Complex</kbd> structure to automatically implement the <kbd>Default</kbd> trait for it.</p>
<p>Note: <kbd>Default</kbd> can only be implemented for structs, enums, or unions whose members and fields themselves implement <kbd>Default</kbd>.</p>
<p>Now, our updated code with the method <kbd>new</kbd> and the <kbd>Default</kbd> annotation looks like this:</p>
<pre>// complex/src/lib.rs<br/><br/>#[derive(Default)]<br/>struct Complex&lt;T&gt; {<br/>    // Real part<br/>    re: T,<br/>    // Complex part<br/>    im: T<br/>}<br/><br/>impl&lt;T&gt; Complex&lt;T&gt; {<br/>    fn new(re: T, im: T) -&gt; Self {<br/>        Complex { re, im }<br/>    }<br/>}<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    use Complex;<br/>    #[test]<br/>    fn complex_basics() {<br/>        let first = Complex::new(3,5);<br/>        let second: Complex&lt;i32&gt; = Complex::default();<br/>        assert_eq!(first.re, 3);<br/>        assert_eq!(first.im, 5);<br/>        assert!(second.re == second.im);<br/>    }<br/>}</pre>
<p>We also added a simple initialization test case at the bottom under the <kbd>tests</kbd> module. The <kbd>#[derive(Default)]</kbd> attribute functionality is implemented as a procedural macro that can automatically implement traits for the type on which it appear. This auto-deriving requires that the fields of any custom type, such as a struct or an enum, also implement the <kbd>Default</kbd> trait themselves. Deriving a trait using them is only applicable to structs, enums, and unions. We'll look at how to write our own deriving procedural macros in <a href="7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml"/>Chapter 9, <em>Metaprogramming with Macros</em>. Also, the function <kbd>new</kbd> is not really a special constructor function (if you are familiar with languages with constructors), but just a conventional name adopted by the community as a method name to create new instances of types.</p>
<p>Now, before we get into more complex trait implementations, we need to auto-derive some more built-in traits that will help us implement more high-level functionality. Let's look at some of them:</p>
<ul>
<li><kbd>Debug</kbd>: We have already seen this before. As the name suggests, this trait helps types to be printed on the console for debugging purposes. In the case of a composite type, the types will be printed in a JSON-like format with braces and parentheses, and quotes if the type is a string. This is implemented for most built-in types in Rust.</li>
<li><kbd>PartialEq</kbd> and <kbd>Eq</kbd>: These traits allow two items to be compared to each other for equality. For our complex type, only <kbd>PartialEq</kbd> makes sense, because when our complex type contains <kbd>f32</kbd> or <kbd>f64</kbd> values, we cannot compare them since <kbd>Eq</kbd> is not implemented for <kbd>f32</kbd> and <kbd>f64</kbd> values. <kbd>PartialEq</kbd> defines partial ordering. whereas <kbd>Eq</kbd> requires a total ordering, Total ordering is undefined for floats, as <kbd>NaN</kbd> is not equal to <kbd>NaN</kbd>.  <kbd>NaN</kbd> is a type in floating point types that represents an operation whose result is undefined, such as <kbd>0.0 / 0.0</kbd>.</li>
<li><kbd>Copy</kbd> and <kbd>Clone</kbd>: These traits define how types get duplicated. We have a separate section for them in <a href="db2c2723-8ca0-43be-b135-afd847342146.xhtml">Chapter 6</a>, <em>Memory Management and Safety</em>. In brief, when auto-derived on any custom type, these traits allow you to create a new copy from the instance, either implicitly when <kbd>Copy</kbd> is implemented or explicitly by calling <kbd>clone()</kbd> on them when <kbd>Clone</kbd> is implemented. Please note that the <kbd>Copy</kbd> trait depends on <kbd>Clone</kbd> being implemented on types.</li>
</ul>
<p>With those explanations out of the way, we'll add auto-derives for these built-in traits, like so:</p>
<pre>#[derive(Default, Debug, PartialEq, Copy, Clone)]<br/>struct Complex&lt;T&gt; {<br/>    // Real part<br/>    re: T,<br/>    // Complex part<br/>    im: T<br/>}</pre>
<p>Next, let's enhance our <kbd>Complex&lt;T&gt;</kbd> type more so that we have better ergonomics in terms of its use. Some additional traits we'll implement (in no particular order) are as follows:</p>
<ul>
<li>The <kbd>Add</kbd> trait from the <kbd>std::ops</kbd> module ,which will let us use the <kbd>+</kbd> operator to add <kbd>Complex</kbd> types</li>
<li>The <kbd>Into</kbd> and <kbd>From</kbd> traits from the <kbd>std::convert</kbd> module ,which will give us the ability to create <kbd>Complex</kbd> types from other types</li>
</ul>
<ul>
<li>The <kbd>Display</kbd> trait, will let us print a human readable version of our <kbd>Complex</kbd> type</li>
</ul>
<p>Let's start with the implementation of the <kbd>Add</kbd> trait. It is documented at <a href="https://doc.rust-lang.org/std/ops/trait.Add.html">https://doc.rust-lang.org/std/ops/trait.Add.html</a>, and the trait is declared like so:</p>
<pre>pub trait Add&lt;RHS = Self&gt; { <br/>    type Output; <br/>    fn add(self, rhs: RHS) -&gt; Self::Output; <br/>} </pre>
<p>Let's go through it line by line:</p>
<ul>
<li><kbd>pub trait Add&lt;RHS = Self&gt;</kbd> says that <kbd>Add</kbd> is a trait that has a generic type, <kbd>RHS</kbd>, that is set to <kbd>Self</kbd> by default. Here, <kbd>Self</kbd> is an alias for the type that implements this trait, which is <kbd>Complex</kbd> in our case. It's a convenient way to refer to the implementer within the trait.</li>
<li><kbd>Output</kbd> is an associated type that the implementer needs to declare.</li>
<li><kbd>fn add(self, rhs: RHS) -&gt; Self::Output</kbd> is the core functionality that's provided by the <kbd>Add</kbd> trait and is the method that gets invoked whenever we use <kbd>+</kbd> operator between two implementing types. It's an instance method, takes <kbd>self</kbd> by value and takes in an <kbd>rhs</kbd> as a parameter, which is <kbd>RHS</kbd> in the trait definition. In our case, the left-hand side and the right-hand side around the <kbd>+</kbd> operator are of the same type by default, but <kbd>RHS</kbd> can be changed to any other type when we are writing impl blocks. For example, we can have an implementation that adds the <kbd>Meter</kbd> and <kbd>Centimeter</kbd> types. In that case, we'll write <kbd>RHS=Centimeter</kbd> in our impl block. Finally, it says that the <kbd>add</kbd> method must return the <kbd>Output</kbd> type that we declared on the second line with the <kbd>Self::Output</kbd> syntax.</li>
</ul>
<p>OK, let's try implementing this. Here's the code, along with the tests:</p>
<pre>// complex/src/lib.rs<br/><br/>use std::ops::Add;<br/><br/>#[derive(Default, Debug, PartialEq, Copy, Clone)]<br/>struct Complex&lt;T&gt; {<br/>    // Real part<br/>    re: T,<br/>    // Complex part<br/>    im: T<br/>}<br/><br/>impl&lt;T&gt; Complex&lt;T&gt; {<br/>    fn new(re: T, im: T) -&gt; Self {<br/>        Complex { re, im }<br/>    }<br/>}<br/><br/>impl&lt;T: Add&lt;T, Output=T&gt;&gt; Add for Complex&lt;T&gt; { <br/>    type Output = Complex&lt;T&gt;; <br/>    fn add(self, rhs: Complex&lt;T&gt;) -&gt; Self::Output { <br/>        Complex { re: self.re + rhs.re, im: self.im + rhs.im } <br/>    } <br/>}<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    use Complex;<br/>    #[test]<br/>    fn complex_basics() {<br/>        let first = Complex::new(3,5);<br/>        let second: Complex&lt;i32&gt; = Complex::default();<br/>    }<br/><br/>    fn complex_addition() {<br/>        let a = Complex::new(1,-2);<br/>        let b = Complex::default();<br/>        let res = a + b;<br/>        assert_eq!(res, a);<br/>    }<br/>}</pre>
<p>Let's dig into the <kbd>impl</kbd> block for <kbd>Complex&lt;T&gt;</kbd>:</p>
<pre>impl&lt;T: Add&lt;T, Output=T&gt; Add for Complex&lt;T&gt;</pre>
<p>The impl block for <kbd>Add</kbd> seems more complex. Let's go through this piece by piece:</p>
<ul>
<li>The <kbd>impl&lt;T: Add&lt;T, Output=T&gt;</kbd> part says that we are implementing <kbd>Add</kbd> for a generic type <kbd>T</kbd>, where <kbd>T</kbd> implements <kbd>Add&lt;T, Output=T&gt;</kbd>. The <kbd>&lt;T, Output=T&gt;</kbd> part says that the implementation of the <kbd>Add</kbd> trait must have the same input and output types.</li>
<li><kbd>Add for Complex&lt;T&gt;</kbd> says that we are implementing the <kbd>Add</kbd> trait for the <kbd>Complex&lt;T&gt;</kbd> type.</li>
<li><kbd>T: Add</kbd> has to implement the <kbd>Add</kbd> trait. If it doesn't, we can't use the <kbd>+</kbd> operator on it.</li>
</ul>
<p class="mce-root"/>
<p>Then comes the <kbd>From</kbd> trait. It would be convenient if we could also construct <kbd>Complex</kbd> types from a built-in primitive type such as a two-element tuple, where the first element is the real part and the second is the imaginary part. We can do this by implementing the <kbd>From</kbd> trait. This trait defines a <kbd>from</kbd> method, giving us a general way to do conversions between types. Its documentation can be found at <a href="https://doc.rust-lang.org/std/convert/trait.From.html">https://doc.rust-lang.org/std/convert/trait.From.html</a>.</p>
<p>Here's the trait definition:</p>
<pre>pub trait From&lt;T&gt; { <br/>    fn from(self) -&gt; T;<br/>} </pre>
<p>This is a bit simpler than the previous one. It's a generic trait, where <kbd>T</kbd> specifies what type to convert from. When we implement this, we just need to substitute the <kbd>T</kbd> with the type we want to implement it for and implement the <kbd>from</kbd> method. Then, we can use the method on our type. Here's an implementation that converts our <kbd>Complex</kbd> value into a two-element tuple type, which is natively known to Rust:</p>
<pre>// complex/src/lib.rs<br/><br/>// previous code omitted for brevity<br/><br/>use std::convert::From;<br/><br/>impl&lt;T&gt; From&lt;(T, T)&gt; for Complex&lt;T&gt; { <br/>    fn from(value: (T, T)) -&gt; Complex&lt;T&gt; { <br/>        Complex { re: value.0, im: value.1 }<br/>    } <br/>}<br/><br/>// other impls omitted<br/><br/>#[cfg(test)]<br/>mod tests {<br/>    <br/>    // other tests<br/>        <br/>     use Complex;<br/>     #[test]<br/>     fn complex_from() {<br/>         let a = (2345, 456);<br/>         let complex = Complex::from(a);<br/>         assert_eq!(complex.re, 2345);<br/>         assert_eq!(complex.im, 456);<br/>     }<br/>}</pre>
<p>Let's look at the <kbd>impl</kbd> line for this one. This is similar to the <kbd>Add</kbd> trait, except that we don't have to constrain our generic by any special output type, since <kbd>From</kbd> does not have that:</p>
<pre>impl&lt;T&gt; From&lt;(T, T)&gt; for Complex&lt;T&gt; { <br/>    fn from(value: (T, T)) -&gt; Complex&lt;T&gt; { <br/>        Complex { re: value.0, im: value.1 }<br/>    } <br/>}</pre>
<p>The first <kbd>&lt;T&gt;</kbd> is a declaration of the generic type <kbd>T</kbd>, and the second and third are the uses of it. We are creating it from a <kbd>(T, T)</kbd> type.</p>
<p>Finally, to be able to let the users view the complex type as in mathematical notation, we should implement the <kbd>Display</kbd> trait. It's documented at <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">https://doc.rust-lang.org/std/fmt/trait.Display.html</a>, and here's the trait's type signature:</p>
<pre>pub trait Display { <br/>    fn fmt(&amp;self, &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;; <br/>}</pre>
<p>The following code shows the implementation of <kbd>Display</kbd> for the <kbd>Complex&lt;T&gt;</kbd> type:</p>
<pre>// complex/src/lib.rs<br/><br/>// previous code omitted for brevity<br/><br/>use std::fmt::{Formatter, Display, Result};<br/><br/>impl&lt;T: Display&gt; Display for Complex&lt;T&gt; {<br/>    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result { <br/>        write!(f, "{} + {}i", self.re, self.im)<br/>    } <br/>} <br/><br/>#[cfg(test)]<br/>mod tests {<br/>    <br/>    // other tests<br/>        <br/>    use Complex;<br/>    #[test]<br/>    fn complex_display() {<br/>        let my_imaginary = Complex::new(2345,456);<br/>        println!("{}", my_imaginary);<br/>    }<br/>}</pre>
<p>The <kbd>Display</kbd> trait has an <kbd>fmt</kbd> method, which takes in a <kbd>Formatter</kbd> type that we write into using the <kbd>write!</kbd> macro. Like before, because our <kbd>Complex&lt;T&gt;</kbd> type uses a generic type for both the <kbd>re</kbd> and <kbd>im</kbd> fields, we need to specify that it also must satisfy the <kbd>Display</kbd> trait.</p>
<p>Running <kbd>cargo test -- --nocapture</kbd>, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/931da4d9-fcd8-4c68-aaaf-2f87d58dfb61.png" style="width:41.50em;height:11.83em;"/></p>
<p>We can see that our complex type is printed in a readable format as <kbd>2345 + 456i</kbd> and that all of our tests are green. Next, let's look at the idea of polymorphism and how Rust traits model this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">True polymorphism using trait objects</h1>
                
            
            
                
<p>Rust allows a true form of polymorphism through special forms of types implementing a trait. These are known as <em>trait objects</em>. Before we explain how Rust achieves polymorphism using trait objects, we need to understand the idea of <strong>dispatch</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dispatch</h1>
                
            
            
                
<p>Dispatch is a concept that emerged from the object-oriented programming paradigm, mainly in the context of one of its features called polymorphism. In the context of OOP, when APIs are generic or take parameters implementing an interface, it here has to figure out what method implementation to invoke on an instance of a type that's passed to the API. This process of method resolution in a polymorphic context is called <strong>dispatch</strong>, and invoking the method is called dispatching. In mainstream languages that support polymorphism, the dispatch may happen in either of the following ways:</p>
<ul>
<li><strong>Static dispatch:</strong> When the method to invoke is decided at compile time, it is known as static dispatch or early binding. The method's signature is used to decide the method to call, and all of this is decided at compile time. In Rust, generics exhibit this form of dispatch because even though the generic function can accept many arguments, a specialized copy of the function is generated at compile time with that concrete type.</li>
<li><strong>Dynamic dispatch:</strong> In object-oriented languages, there are times when the method call can't be decided until runtime. This is because the concrete type is hidden and only interface methods are available to call on the type. In Java, this is the case when a function has an argument, which is known as an <strong>interface</strong>. Such a scenario can only be handled by dynamic dispatch. In dynamic dispatch, the method is determined dynamically by navigating through the list of implementations of the interface from the <kbd>vtable</kbd> and invoking the method. The <kbd>vtable</kbd> is a list of function pointers that point to each type's implemented method. This has a bit of overhead because of the extra pointer indirection in method invocation.</li>
</ul>
<p>Let's explore trait objects next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Trait objects</h1>
                
            
            
                
<p>Now, up until this point, we have mostly seen traits being used in a static dispatch context, where we specified trait bounds in generic APIs. However, we also have another way to create polymorphic APIs, where we can specify parameters as something that implements a trait rather than a generic or a concrete type. This form of type, specified as implementing a trait API, is known as a trait object. Trait objects are similar to C++ virtual methods. A trait object is implemented as a fat pointer and is an unsized type, which means that they can only be used behind references (<kbd>&amp;</kbd>). We explain unsized types in <a href="63263043-9b5e-4711-b2e2-e44240a0e843.xhtml">Chapter 7</a>, <em>Advanced Concepts</em>. A trait object fat pointer has the first pointer pointing points to the actual data associated with the object while the second pointer to a virtual table (vtable), which is a structure holding one function pointer per method for the object, at a fixed offset.</p>
<p>Trait objects are Rust's way of performing dynamic dispatch where we don't have the actual concrete type information. Method resolution is done by hopping down to the vtable and invoking the appropriate method. One of the use cases for trait objects is that they allow you to operate on a collection that can have multiple types, but with an extra pointer indirection at runtime. To illustrate this, consider the following program:</p>
<pre>// trait_objects.rs<br/><br/>use std::fmt::Debug;<br/><br/>#[derive(Debug)]<br/>struct Square(f32);<br/>#[derive(Debug)]<br/>struct Rectangle(f32, f32);<br/><br/>trait Area: Debug {<br/>    fn get_area(&amp;self) -&gt; f32; <br/>}<br/><br/>impl Area for Square {<br/>    fn get_area(&amp;self) -&gt; f32 {<br/>        self.0 * self.0<br/>    }<br/>}<br/><br/>impl Area for Rectangle {<br/>    fn get_area(&amp;self) -&gt; f32 {<br/>        self.0 * self.1<br/>    }<br/>}<br/><br/>fn main() {<br/>    let shapes: Vec&lt;&amp;dyn Area&gt; = vec![&amp;Square(3f32), &amp;Rectangle(4f32, 2f32)];<br/>    for s in shapes {<br/>        println!("{:?}", s);<br/>    }<br/>}</pre>
<p>As you can see, the elements of shapes are of type <kbd>&amp;dyn Area</kbd>, a type that is represented as a trait. The trait object is represented by <kbd>dyn Area</kbd>, denoting that it's a pointer to some implementation of the <kbd>Area</kbd> trait. A type in the form of a trait object allows you to store different types within a collection type such as <kbd>Vec</kbd>. In the preceding example, <kbd>Square</kbd> and <kbd>Rectangle</kbd> were converted into trait objects implicitly because we pushed a reference to them. We can also make a type, a trait object by casting it manually. This is an advanced case, though, and is used when the compiler cannot cast the type as a trait object by itself. Do note that we can only create trait objects of types whose sizes we know at compile time. A <kbd>dyn Trait</kbd> is an unsized type and can only be created as a reference. We can also create trait objects by putting them behind other pointer types such as <kbd>Box</kbd>, <kbd>Rc</kbd>, <kbd>Arc</kbd>, and so on.</p>
<p>In the older Rust 2015 edition, trait objects are referred to as just the name of the trait, for a trait object <kbd>dyn Foo</kbd> , it is represented as <kbd>Foo</kbd>. This syntax is confusing and it deprecated in the latest 2018 edition.</p>
<p>In the following code, we are illustrating the use of <kbd>dyn Trait</kbd> as a parameters in functions:</p>
<pre>// dyn_trait.rs<br/><br/>use std::fmt::Display;<br/><br/>fn show_me(item: &amp;dyn Display) {<br/>    println!("{}", item);<br/>}<br/><br/>fn main() {<br/>    show_me(&amp;"Hello trait object");<br/>}</pre>
<p>Traits, along with generics, provide both kinds of code reuse, either through monomorphization (early binding) or through runtime polymorphism (late binding). The decision on when to use which depends on the context and the needs of the application in question. Often, error types are taken toward the dynamic dispatch train as they are supposed to be code paths that rarely get executed. Monomorphization can be handy for small use cases, but the downside to it is that it introduces code bloat and duplication, which affects the cache line and increases binary size. However, of these two options, static dispatch should be preferred unless there is a hard constraint on binary size.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Types are one of the most beautiful aspects of any statically typed language. They allow you to express so much at compile time. This chapter might not be the most advanced in this book, but the content was probably the heaviest. We now have a working knowledge of the different ways to reuse code. We also got to know about the mighty traits and how Rust's standard library makes heavy use of them.</p>
<p>In the next chapter, we'll learn about how programs use memory and how Rust provides compile-time memory management.</p>


            

            
        
    </body></html>