<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rust Best Practices</h1>
                
            
            
                
<p class="calibre3">Rust is a powerful language, but a few things easily avoidable with practice can make your life really hard when starting. This chapter aims to show you some good practices and tips.</p>
<p class="calibre3">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Best practices</li>
<li class="calibre11">API tips and improvements</li>
<li class="calibre11">Usage tips</li>
<li class="calibre11">Code readability</li>
</ul>
<p class="calibre3">Now let's go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rust best practices</h1>
                
            
            
                
<p class="calibre3">Let's start with some basics (and maybe obvious) things.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Slices</h1>
                
            
            
                
<p class="calibre3">First, a little recap; a slice is a constant view over an array, and <kbd class="calibre14">&amp;[T]</kbd> is the constant view of a <kbd class="calibre14">Vec&lt;T&gt;</kbd>, whereas <kbd class="calibre14">&amp;str</kbd> is the constant view of a <kbd class="calibre14">String</kbd> (just like <kbd class="calibre14">Path</kbd> is the constant view of a <kbd class="calibre14">PathBuf</kbd> and <kbd class="calibre14">OsStr</kbd> is the constant view of an <kbd class="calibre14">OsString</kbd>). Now that you have this in mind, let's continue!</p>
<p class="calibre3">When a function expects a constant argument of type <kbd class="calibre14">Vec</kbd> or <kbd class="calibre14">String</kbd>, then always write them as follows:</p>
<pre class="calibre22">fn some_func(v: &amp;[u8]) {
    // some code...
}</pre>
<p class="calibre3">Instead of:</p>
<pre class="calibre22">fn some_code(v: &amp;Vec&lt;u8&gt;) {
    // some code
}</pre>
<p class="calibre3">And:</p>
<pre class="calibre22">fn some_func(s: &amp;str) {
    // some code...
}</pre>
<p class="calibre3">Instead of:</p>
<pre class="calibre22">fn some_func(s: &amp;String) {
    // some code...
}</pre>
<p class="calibre3">You might be wondering why this is the case. So, let's imagine your function displays your <kbd class="calibre14">Vec</kbd> as ASCII characters:</p>
<pre class="calibre22">fn print_as_ascii(v: &amp;[u8]) {
    for c in v {
        print!("{}", *c as char);
    }
    println!("");
}</pre>
<p class="calibre3">And now you just want to print a part of your <kbd class="calibre14">Vec</kbd>:</p>
<pre class="calibre22">let v = b"salut!";

print_as_ascii(&amp;v[2..]);</pre>
<p class="calibre3">Now, if the <kbd class="calibre14">print_as_ascii</kbd> only accepted references on <kbd class="calibre14">Vec</kbd>, you'd have to make a (useless) allocation, as follows:</p>
<pre class="calibre22">let v = b"salut!";

print_as_ascii(&amp;v[2..].to_vec());</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">API tips and improvements</h1>
                
            
            
                
<p class="calibre3">When writing a public API (either for you or other users), a few tips can really make everyone's life easier. This is where generics kick in. Let's start with <kbd class="calibre14">Option</kbd> arguments:</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0"> Explaining the Some function</h1>
                
            
            
                
<p class="calibre3">Generally, when a function expects an <kbd class="calibre14">Option</kbd> argument, it looks like this:</p>
<pre class="calibre22">fn some_func(arg: Option&lt;&amp;str&gt;) {
    // some code
}</pre>
<p class="calibre3">And you call it as follows:</p>
<pre class="calibre22">some_func(Some("ratatouille"));
some_func(None);</pre>
<p class="calibre3">Now, what if I told you that you could get rid of the <kbd class="calibre14">Some</kbd>? Nice, right? Well, this is actually pretty easy:</p>
<pre class="calibre22">fn some_func&lt;'a, T: Into&lt;Option&lt;&amp;'a str&gt;&gt;&gt;(arg: T) {
    // some code
}</pre>
<p class="calibre3">And you can now call it as follows:</p>
<pre class="calibre22">some_func(Some("ratatouille")); // If you *really* like to write "Some"...
some_func("ratatouille");
some_func(None);</pre>
<p class="calibre3">Better! However, to make users' lives easier, it'll require a bit more code for whoever's writing the function. You can't use <kbd class="calibre14">arg</kbd> as it is; you need to add an extra step. Before, you'd just do this:</p>
<pre class="calibre22">fn some_func(arg: Option&lt;&amp;str&gt;) {
    if let Some(a) = arg {
        println!("{}", a);
    } else {
        println!("nothing...");
    }
}</pre>
<p class="calibre3">Now, you'll need to add an <kbd class="calibre14">.into</kbd> call before being able to use <kbd class="calibre14">arg</kbd>:</p>
<pre class="calibre22">fn some_func&lt;'a, T: Into&lt;Option&lt;&amp;'a str&gt;&gt;&gt;(arg: T) {
    let arg = arg.into();
    if let Some(a) = arg {
        println!("{}", a);
    } else {
        println!("nothing...");
    }
}</pre>
<p class="calibre3">And that's it. As we said before, it doesn't require much and makes users' lives easier, so why not do it?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0"> Using the Path function</h1>
                
            
            
                
<p class="calibre3">Just like the previous section, this will show you some tips to make your API more comfortable to use by <em class="calibre21">auto-converting</em> it into a <kbd class="calibre14">Path</kbd>.</p>
<p class="calibre3">So, let's take an example with a function receiving a <kbd class="calibre14">Path</kbd> as an argument:</p>
<pre class="calibre22">use std::path::Path;

fn some_func(p: &amp;Path) {
    // some code...
}</pre>
<p class="calibre3">There's nothing new in here. You can call this function just like this:</p>
<pre class="calibre22">some_func(Path::new("tortuga.txt"));</pre>
<p class="calibre3">The annoying thing, here, is that you have to build the <kbd class="calibre14">Path</kbd> yourself before sending it to the function. This is way too annoying, but we can do better!</p>
<pre class="calibre22">fn some_func&lt;P: AsRef&lt;Path&gt;&gt;(p: P) {
    // some code...
}</pre>
<p class="calibre3">And that's it... You can now call the function as follows:</p>
<pre class="calibre22">some_func(Path::new("tortuga.txt")); // If you *really* like to build the "Path" by yourself...
some_func("tortuga.txt");</pre>
<p class="calibre3">And just like for the <kbd class="calibre14">Into</kbd> trait, you need to add one line of code in order to make it work:</p>
<pre class="calibre22">fn some_func&lt;P: AsRef&lt;Path&gt;&gt;(p: P) {
    let p: &amp;Path = p.as_ref();
    // some code...
}</pre>
<p class="calibre3">And that's it! Now, as long as the given type implements <kbd class="calibre14">AsRef&lt;Path&gt;</kbd>, you can just send it like that. For information, here's a (non-exhaustive) list of types implementing this trait:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">OsStr</kbd> / <kbd class="calibre14">OsString</kbd></li>
<li class="calibre11"><kbd class="calibre14">&amp;str</kbd> / <kbd class="calibre14">String</kbd></li>
<li class="calibre11"><kbd class="calibre14">Path</kbd> (yes, <kbd class="calibre14">Path</kbd> implements <kbd class="calibre14">AsRef&lt;Path&gt;</kbd> as well!) / <kbd class="calibre14">PathBuf</kbd></li>
<li class="calibre11"><kbd class="calibre14">Iter</kbd></li>
</ul>
<p class="calibre3">This is already quite a lot, so you should be able to do it pretty easily!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Usage tips</h1>
                
            
            
                
<p class="calibre3">Now that you've seen few examples about how some small tips can make users' code more beautiful, how about we see some others things that might make <em class="calibre21">your</em> code better?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Builder pattern</h1>
                
            
            
                
<p class="calibre3">A builder pattern is meant to be able to <em class="calibre21">build</em> a final object through multiple calls that can be chained. An excellent example is the <kbd class="calibre14">OpenOptions</kbd> type in the Rust standard library.</p>
<p>It's strongly recommended you use <kbd class="calibre25">OpenOptions</kbd> when you need to play with <kbd class="calibre25">File</kbd>!</p>
<pre class="calibre22">use std::fs::OpenOptions;

let file = OpenOptions::new()
                       .read(true)
                       .write(true)
                       .create(true)
                       .open("foo.txt");</pre>
<p class="calibre3">To make such APIs, you have two ways:</p>
<ul class="calibre10">
<li class="calibre11">Playing with mutable borrows</li>
<li class="calibre11">Playing with moves</li>
</ul>
<p class="calibre3">Let's start with the mutable borrows!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing with mutable borrows</h1>
                
            
            
                
<p class="calibre3">The first one works just like <kbd class="calibre14">OpenOptions</kbd>:</p>
<pre class="calibre22">struct Number(u32);

impl Number {
    fn new(nb: u32) -&gt; Number {
        Number(nb)
    }

    fn add(&amp;mut self, other: u32) -&gt; &amp;mut Number {
        self.0 += other;
        self
    }

    fn sub(&amp;mut self, other: u32) -&gt; &amp;mut Number {
        self.0 -= other;
        self
    }

    fn compute(&amp;self) -&gt; u32 {
        self.0
    }
}</pre>
<p class="calibre3">If you wonder about <kbd class="calibre14">self.0</kbd>, just remember that it's how you access a tuple field.</p>
<p class="calibre3">And then you can call it as follow:</p>
<pre class="calibre22">let nb = Number::new(0).add(10).sub(5).add(12).compute();
assert_eq!(nb, 17);</pre>
<p class="calibre3">This is the first way to do it.</p>
<p>You'll note that you need to add an <em class="calibre83">ending</em> method so that you can transform your mutable borrow into an object (otherwise, you'll have a borrow issue).</p>
<p class="calibre3">Let's now take a look at the second way to do it!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing with moves</h1>
                
            
            
                
<p class="calibre3">Instead of taking <kbd class="calibre14">&amp;mut</kbd> every time, we'll directly take the object's ownership every time:</p>
<pre class="calibre22">struct Number(u32);

impl Number {
    fn new(nb: u32) -&gt; Number {
        Number(nb)
    }

    fn add(mut self, other: u32) -&gt; Number {
        self.0 += other;
        self
    }

    fn sub(mut self, other: u32) -&gt; Number {
        self.0 -= other;
        self
    }
}</pre>
<p class="calibre3">Then, there's no more need for the <em class="calibre21">ending</em> method:</p>
<pre class="calibre22">let nb = Number::new(0).add(10).sub(5).add(12);
assert_eq!(nb.0, 17);</pre>
<p class="calibre3">I generally prefer this way of doing builder patterns but it's more of a personal opinion than a thoughtful decision. Pick whichever seems to fit the best in your situation!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Code readability</h1>
                
            
            
                
<p class="calibre3">We'll now talk about Rust's syntax itself. A few things can improve the code readability and are important to know. Let's start with big numbers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Big number formatting</h1>
                
            
            
                
<p class="calibre3">It's not uncommon to see huge constant numbers in code, such as this:</p>
<pre class="calibre22">let x = 1000000000;</pre>
<p class="calibre3">However, this is quite difficult to read for us (human brains aren't very efficient at parsing such numbers). In Rust, you can insert <kbd class="calibre14">_</kbd> characters into numbers without any problem:</p>
<pre class="calibre22">let x = 1_000_000_000;</pre>
<p class="calibre3">A lot better, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Specifying types</h1>
                
            
            
                
<p class="calibre3">The Rust compiler can automatically detect the type of a variable in most cases. However, for people reading the code, it's not always obvious what a code returns. An example? Sure!</p>
<pre class="calibre22">let x = "a 10 11 coucou 12 14".split(' ')
                              .filter_map(|e| e.parse::&lt;u32&gt;().ok())
                              .filter(|x| x % 2 == 0)
                              .map(|s| format!("{}", s))
                              .collect::&lt;Vec&lt;_&gt;&gt;()
                              .join("::");</pre>
<p class="calibre3">After reading the code carefully, you'll guess that <kbd class="calibre14">x</kbd> is a <kbd class="calibre14">String</kbd>. However, you needed to read all those closures to get it and even then, are you really sure of the type?</p>
<p class="calibre3">In such cases, it's strongly recommended to just add the type annotation:</p>
<pre class="calibre22">let x: String = "a 10 11 coucou 12 14".split(' ')
                                      .filter_map(|e| e.parse::&lt;u32&gt;().ok())
                                      .filter(|x| x % 2 == 0)
                                      .map(|s| format!("{}", s))
                                      .collect::&lt;Vec&lt;_&gt;&gt;()
                                      .join("::");</pre>
<p class="calibre3">It doesn't cost much and allows readers (including you) to go through the code so much faster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Matching</h1>
                
            
            
                
<p class="calibre3">It's common to use pattern matching through <kbd class="calibre14">match</kbd> blocks in Rust. However, it's often a better solution to use <kbd class="calibre14">if let</kbd> conditions. Let's take a simple example:</p>
<pre class="calibre22">enum SomeEnum {
    Ok,
    Err,
    Unknown,
}</pre>
<p class="calibre3">Now let's say you want to perform an action only when you get <kbd class="calibre14">Ok</kbd>. With a <kbd class="calibre14">match</kbd>, you would do this:</p>
<pre class="calibre22">let x = SomeEnum::Err;

match x {
    SomeEnum::Ok =&gt; {
        // Huge code doing a lot of things...
    }
    _ =&gt; {}
}</pre>
<p class="calibre3">Not really an issue, right? Now let's see it with an <kbd class="calibre14">if let</kbd>:</p>
<pre class="calibre22">let x = SomeEnum::Err;

if let SomeEnum::Ok = x {
    // Huge code doing a lot of things...
}</pre>
<p class="calibre3">And that's it. It basically makes the code a little shorter, while improving readability a lot. Whenever you just need to get one value, it's often a better solution to use <kbd class="calibre14">if let</kbd> instead of <kbd class="calibre14">match</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">With this last chapter, you should have a good overview of good practices in Rust. Keep in mind that good code is easy to read and well commented. Even complex features can be a lot simpler to understand with well-made documentation.</p>


            

            
        
    </body></html>