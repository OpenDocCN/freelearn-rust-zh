<html><head></head><body>
        

                            
                    <h1 class="header-title">Design Patterns</h1>
                
            
            
                
<p class="mce-root">Functional programming has developed design patterns just like object-oriented or other communities. These patterns, unsurprisingly, make use of functions as a central concept. They also emphasize something called the <strong>single responsibility principle</strong>. The single responsibility principle states that program's logical components should do one thing and do that one thing well. In this chapter, we will focus on a few very common patterns. Some of these concepts are so simple that they counter-intuitively become harder to explain. In these cases, we will make use of various examples to demonstrate how a simple concept can exhibit complex behavior.<br/></p>
<p>In this chapter, you will do the following:</p>
<ul>
<li>Learn to recognize and use functors</li>
<li>Learn to recognize and use monads</li>
<li>Learn to recognize and use combinators</li>
<li>Learn to recognize and use lazy evaluation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>A recent version of Rust is necessary to run the examples provided:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the functor pattern</h1>
                
            
            
                
<p>A functor is approximately the inverse of a function:</p>
<ul>
<li>A function defines a transformation, accepts data, and returns the result of the transformation</li>
<li>A functor defines data, accepts a function, and returns the result of the transformation</li>
</ul>
<p>A simple example of a functor is the Rust vector and its accompanying <kbd>map</kbd> function:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<br/>   let m: Vec&lt;u64&gt; = vec![1, 2, 3];<br/>   let n: Vec&lt;u64&gt; = m.iter().map(|x| { x*x }).collect();<br/>   println!("{:?}", m);<br/>   println!("{:?}", n);<br/>}</pre>
<p>Functors are often thought of as only the <kbd>map</kbd> function, due to the rules of what constitutes a functor or not. The preceding common case is what's called a <strong>structure-preserving map</strong>. Functors do not need to be structure-preserving. For example, take the very similar case of a map implemented for a set, as shown in the following code:</p>
<pre class="p1" style="padding-left: 30px">use std::collections::{HashSet};<br/><br/>fn main() {<br/>   let mut a: HashSet&lt;u64&gt; = HashSet::new();<br/>   a.insert(1);<br/>   a.insert(2);<br/>   a.insert(3);<br/>   a.insert(4);<br/>   let b: HashSet&lt;u64&gt; = a.iter().cloned().map(|x| x/2).collect();<br/>   println!("{:?}", a);<br/>   println!("{:?}", b);<br/>}</pre>
<p>We see here that the resulting set is smaller than the original set due to collisions. This mapping still satisfies the properties of a functor. The defining properties of a functor are as follows:</p>
<ul>
<li>A collection of objects, <kbd>C</kbd></li>
<li>A mapping function that will transform objects in <kbd>C</kbd> into objects in <kbd>D</kbd></li>
</ul>
<p>The preceding <kbd>Set</kbd> map satisfies both the first and second property, and is therefore a proper functor. It also demonstrates how data can be transformed into a differently shaped structure through a functor. Using a little imagination, we may also consider the case where each mapped value may produce multiple outputs:</p>
<pre style="padding-left: 30px">fn main() {<br/>   let sentences = vec!["this is a sentence","paragraphs have many sentences"];<br/>   let words:Vec&lt;&amp;str&gt; = sentences.iter().flat_map(|&amp;x| x.split(" ")).collect();<br/>   println!("{:?}", sentences);<br/>   println!("{:?}", words);<br/>}</pre>
<p>Technically speaking, this last case is not a normal functor, but rather a contravariant functor. All functors are covariant. The distinction between covariance and contravariance is not important for our purposes, so we will leave that topic to only the most curious readers.</p>
<p>As a final definition by example, we should note that the input and output of a functor map need not be of the same type. For example, we can map from a vector to a <kbd>HashSet</kbd>:</p>
<pre class="p1">use std::collections::{HashSet};<br/><br/>fn main() {<br/>   let v: Vec&lt;u64&gt; = vec![1, 2, 3];<br/>   let s: HashSet&lt;u64&gt; = v.iter().cloned().map(|x| x/2).collect();<br/>   println!("{:?}", v);<br/>   println!("{:?}", s);<br/>}</pre>
<p>To give a non-trivial example of how the functor pattern could be used, let's look at webcams and AI. Modern AI facial recognition software is capable of identifying human faces in pictures and even visible emotional states. Let's imagine an app that connects to a webcam and processes the input with a filter. Here are some type definitions for the program:</p>
<pre class="p1" style="padding-left: 30px">struct WebCamera;<br/><br/>#[derive(Debug)]<br/>enum VisibleEmotion {<br/>   Anger,<br/>   Contempt,<br/>   Disgust,<br/>   Fear,<br/>   Happiness,<br/>   Neutral,<br/>   Sadness,<br/>   Surprise<br/>}<br/><br/>#[derive(Debug,Clone)]<br/>struct BoundingBox {<br/>   top: u64,<br/>   left: u64,<br/>   height: u64,<br/>   width: u64<br/>}<br/><br/>#[derive(Debug)]<br/>enum CameraFilters {<br/>   Sparkles,<br/>   Rain,<br/>   Fire,<br/>   Disco<br/>}<br/><br/></pre>
<p>On the <kbd>WebCamera</kbd> type, we will implement two functors. One functor, <kbd>map_emotion</kbd>, will map emotions to other emotions. Maybe this could be used to add emojis to the text chat. The second contravariant functor, <kbd>flatmap_emotion</kbd>, maps emotions to zero, or more filters. These are animations or effects that can be applied back onto the web camera field of view:</p>
<pre class="p1" style="padding-left: 30px">impl WebCamera {<br/>   fn map_emotion&lt;T,F&gt;(&amp;self, translate: F) -&gt; Vec&lt;(BoundingBox,T)&gt;<br/>   where F: Fn(VisibleEmotion) -&gt; T {<br/>      //Simulate emotion extracted from WebCamera<br/>      vec![<br/>         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),<br/>         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),<br/>         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),<br/>         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)<br/>      ].into_iter().map(|(bb,emt)| {<br/>         (bb, translate(emt))<br/>      }).collect::&lt;Vec&lt;(BoundingBox,T)&gt;&gt;()<br/>   }<br/>   fn flatmap_emotion&lt;T,F,U:IntoIterator&lt;Item=T&gt;&gt;(&amp;self, mut translate: F) -&gt; Vec&lt;(BoundingBox,T)&gt;<br/>   where F: FnMut(VisibleEmotion) -&gt; U {<br/>      //Simulate emotion extracted from WebCamera<br/>      vec![<br/>         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),<br/>         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),<br/>         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),<br/>         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)<br/>      ].into_iter().flat_map(|(bb,emt)| {<br/>         translate(emt).into_iter().map(move |t| (bb.clone(), t))<br/>      }).collect::&lt;Vec&lt;(BoundingBox,T)&gt;&gt;()<br/>   }<br/>}<br/></pre>
<p>To use the functors, the programmer supplies which emotions map to which filters. The complex AI and effects can be easily modified due to the encapsulation provided by the functor pattern:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<br/>   let camera = WebCamera;<br/>   let emotes: Vec&lt;(BoundingBox,VisibleEmotion)&gt; = camera.map_emotion(|emt| {<br/>      match emt {<br/>         VisibleEmotion::Anger |<br/>         VisibleEmotion::Contempt |<br/>         VisibleEmotion::Disgust |<br/>         VisibleEmotion::Fear |<br/>         VisibleEmotion::Sadness =&gt; VisibleEmotion::Happiness,<br/>         VisibleEmotion::Neutral |<br/>         VisibleEmotion::Happiness |<br/>         VisibleEmotion::Surprise =&gt; VisibleEmotion::Sadness<br/>      }<br/>   });<br/><br/>   let filters: Vec&lt;(BoundingBox,CameraFilters)&gt; = camera.flatmap_emotion(|emt| {<br/>      match emt {<br/>         VisibleEmotion::Anger |<br/>         VisibleEmotion::Contempt |<br/>         VisibleEmotion::Disgust |<br/>         VisibleEmotion::Fear |<br/>         VisibleEmotion::Sadness =&gt; vec![CameraFilters::Sparkles, CameraFilters::Rain],<br/>         VisibleEmotion::Neutral |<br/>         VisibleEmotion::Happiness |<br/>         VisibleEmotion::Surprise =&gt; vec![CameraFilters::Disco]<br/>      }<br/>   });<br/><br/>   println!("{:?}",emotes);<br/>   println!("{:?}",filters);<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the monad pattern</h1>
                
            
            
                
<p>A monad defines <kbd>return</kbd> and <kbd>bind</kbd> operations for a type. The <kbd>return</kbd> operation is like a constructor to make the monad. The <kbd>bind</kbd> operation incorporates new information and returns a new monad. There are also several laws that monads should obey. Rather than quote the laws, we'll just say that monads should behave well when daisy chained like the following:</p>
<pre style="padding-left: 30px">MyMonad::return(value)  //We start with a new MyMonad&lt;A&gt;<br/>        .bind(|x| x+x)  //We take a step into MyMonad&lt;B&gt;<br/>        .bind(|y| y*y); //Similarly we get to MyMonad&lt;C&gt;</pre>
<p>In Rust, there are several semi-monads that appear in standard libraries:</p>
<pre class="p1" style="padding-left: 30px">fn main()<br/>{<br/>   let v1 = Some(2).and_then(|x| Some(x+x)).and_then(|y| Some(y*y));<br/>   println!("{:?}", v1);<br/><br/>   let v2 = None.or_else(|| None).or_else(|| Some(222));<br/>   println!("{:?}", v2);<br/>}</pre>
<p>In this example, the normal <kbd>Option</kbd> constructors, <kbd>Some</kbd> or <kbd>None</kbd>, take the place of the monadic naming convention, <kbd>return</kbd>. There are two semi-monads implemented here, one associated with <kbd>and_then</kbd>, and the other with <kbd>or_else</kbd>. Both of these correspond to the monadic <kbd>bind</kbd> naming convention for the operator responsible for incorporating new information into a new monad return value.</p>
<p>Monadic <kbd>bind</kbd> operations are also polymorphic, meaning they should permit returning monads of different types from the current monad. According to this rule, <kbd>or_else</kbd> is not technically a monad; hence it is a semi-monad:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<br/>   let v3 = Some(2).and_then(|x| Some("abc"));<br/>   println!("{:?}", v3);<br/><br/>   // or_else is not quite a monad<br/>   // does not permit polymorphic bind<br/>   //let v4 = Some(2).or_else(|| Some("abc"));<br/>   //println!("{:?}", v4);<br/>}</pre>
<p>Monads were originally developed to express side-effects in purely functional languages. Isn't that a contradiction—pure with side-effects?</p>
<p>The answer is <em>no</em> if the effects are passed as input and output through pure functions. However, for this to work, every function would need to declare every state variable and pass it along, which could become a huge list of parameters. This is where monads come in. A monad can hide state inside itself, which becomes essentially a larger, more complex function than what the programmer interacts with.</p>
<p>One concrete example of side-effect hiding is the concept of a universal logger. The monadic <kbd>return</kbd> and <kbd>bind</kbd> can be used to wrap state and computation inside of a monad that will log all intermediate results. Here is the logger monad:</p>
<pre class="p1" style="padding-left: 30px">use std::fmt::{Debug};<br/><br/>struct LogMonad&lt;T&gt;(T);<br/>impl&lt;T&gt; LogMonad&lt;T&gt; {<br/>   fn _return(t: T) -&gt; LogMonad&lt;T&gt;<br/>   where T: Debug {<br/>      println!("{:?}", t);<br/>      LogMonad(t)<br/>   }<br/>   fn bind&lt;R,F&gt;(&amp;self, f: F) -&gt; LogMonad&lt;R&gt;<br/>   where F: FnOnce(&amp;T) -&gt; R,<br/>   R: Debug {<br/>      let r = f(&amp;self.0);<br/>      println!("{:?}", r);<br/>      LogMonad(r)<br/>   }<br/>}<br/><br/>fn main() {<br/>   LogMonad::_return(4)<br/>            .bind(|x| x+x)<br/>            .bind(|y| y*y)<br/>            .bind(|z| format!("{}{}{}", z, z, z));<br/>}</pre>
<p>As long as each result implements the <kbd>Debug</kbd> trait, it can be automatically logged with this pattern.</p>
<p>The monad pattern is also very useful for chaining together code that can't be written in a normal code block. For example, code blocks are always evaluated eagerly. If you want to define code that will be evaluated later or in pieces, the lazy monad pattern is very convenient. Lazy evaluation is a term used to describe code or data that is not evaluated until it is referenced. This is contrary to the typical eager evaluation of Rust code that will execute immediately regardless of context. Here is the lazy monad pattern:</p>
<pre class="p1" style="padding-left: 30px">struct LazyMonad&lt;A,B&gt;(Box&lt;Fn(A) -&gt; B&gt;);<br/><br/>impl&lt;A: 'static,B: 'static&gt; LazyMonad&lt;A,B&gt; {<br/>   fn _return(u: A) -&gt; LazyMonad&lt;B,B&gt; {<br/>      LazyMonad(Box::new(move |b: B| b))<br/>   }<br/>   fn bind&lt;C,G: 'static&gt;(self, g: G) -&gt; LazyMonad&lt;A,C&gt;<br/>   where G: Fn(B) -&gt; C {<br/>      LazyMonad(Box::new(move |a: A| g(self.0(a))))<br/>   }<br/>   fn apply(self, a: A) -&gt; B {<br/>      self.0(a)<br/>   }<br/>}<br/><br/>fn main() {<br/>   let notyet = LazyMonad::_return(())   //we create LazyMonad&lt;()&gt;<br/>                          .bind(|x| x+2) //and now a LazyMonad&lt;A&gt;<br/>                          .bind(|y| y*3) //and now a LazyMonad&lt;B&gt;<br/>                          .bind(|z| format!("{}{}", z, z));<br/><br/>   let nowdoit = notyet.apply(222); //The above code now run<br/>   println!("nowdoit {}", nowdoit);<br/>}</pre>
<p>This block defines statements that will be evaluated one at a time after a value is supplied, but not before. This may seem a bit trivial since we can do the same with a simple closure and code block; however, to make this pattern stick, let's consider a more complex case—an asynchronous web server.</p>
<p>A web server will typically receive a full HTTP request before processing it. Choosing what to do with a request is sometimes called <strong>routing</strong>. Then requests are sent to a request handler. In the following code, we define a server that helps us wrap routes and handlers into a single web server object. Here are the type and method definitions:</p>
<pre class="p1">use std::io::prelude::*;<br/>use std::net::TcpListener;<br/>use std::net::TcpStream;<br/><br/>struct ServerMonad&lt;St&gt; {<br/>   state: St,<br/>   handlers: Vec&lt;Box&lt;Fn(&amp;mut St,&amp;String) -&gt; Option&lt;String&gt;&gt;&gt;<br/>}<br/><br/>impl&lt;St: Clone&gt; ServerMonad&lt;St&gt; {<br/>   fn _return(st: St) -&gt; ServerMonad&lt;St&gt; {<br/>      ServerMonad {<br/>         state: st,<br/>         handlers: Vec::new()<br/>      }<br/>   }<br/>   fn listen(&amp;mut self, address: &amp;str) {<br/>      let listener = TcpListener::bind(address).unwrap();<br/>      for stream in listener.incoming() {<br/>         let mut st = self.state.clone();<br/>         let mut buffer = [0; 2048];<br/>         let mut tcp = stream.unwrap();<br/>         tcp.read(&amp;mut buffer);<br/>         let buffer = String::from_utf8_lossy(&amp;buffer).into_owned();<br/>         for h in self.handlers.iter() {<br/>            if let Some(response) = h(&amp;mut st,&amp;buffer) {<br/>               tcp.write(response.as_bytes());<br/>               break<br/>            }<br/>         }<br/>      }<br/>   }<br/>   fn bind_handler&lt;F&gt;(mut self, f: F) -&gt; Self<br/>      where F: 'static + Fn(&amp;mut St,&amp;String) -&gt; Option&lt;String&gt; {<br/>      self.handlers.push(Box::new(f));<br/>      self<br/>   }<br/>}</pre>
<p>This type defines <kbd>return</kbd> and <kbd>bind</kbd> like operations. However, the <kbd>bind</kbd> function is not polymorphic and the operation is not a pure function. Without these compromises, we would need to fight against the Rust type and ownership system; the preceding example is not written monadically due to complications when trying to box and copy closures. This is an expected trade-off and the semi-monad pattern should not be discouraged when appropriate.</p>
<p>To define our web server responses, we can attach handlers like in the following code:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<br/>   ServerMonad::_return(())<br/>               .bind_handler(|&amp;mut st, ref msg| if msg.len()%2 == 0 { Some("divisible by 2".to_string()) } else { None })<br/>               .bind_handler(|&amp;mut st, ref msg| if msg.len()%3 == 0 { Some("divisible by 3".to_string()) } else { None })<br/>               .bind_handler(|&amp;mut st, ref msg| if msg.len()%5 == 0 { Some("divisible by 5".to_string()) } else { None })<br/>               .bind_handler(|&amp;mut st, ref msg| if msg.len()%7 == 0 { Some("divisible by 7".to_string()) } else { None })<br/>               .listen("127.0.0.1:8888");<br/>}</pre>
<p>If you run this program and send messages to localhost <kbd>8888</kbd>, then you may get a response if the message length is divisible by <kbd>2</kbd>, <kbd>3</kbd>, <kbd>5</kbd>, or <kbd>7</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the combinator pattern</h1>
                
            
            
                
<p>A combinator is a function that takes other functions as arguments and returns a new function.</p>
<p>A simple example of a combinator would be the composition operator, which chains two functions together:</p>
<pre class="p1" style="padding-left: 30px">fn compose&lt;A,B,C,F,G&gt;(f: F, g: G) -&gt; impl Fn(A) -&gt; C<br/>   where F: 'static + Fn(A) -&gt; B,<br/>         G: 'static + Fn(B) -&gt; C {<br/>   move |x| g(f(x))<br/>}<br/><br/>fn main() {<br/>   let fa = |x| x+1;<br/>   let fb = |y| y*2;<br/>   let fc = |z| z/3;<br/>   let g = compose(compose(fa,fb),fc);<br/>   println!("g(1) = {}", g(1));<br/>   println!("g(12) = {}", g(12));<br/>   println!("g(123) = {}", g(123));<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Parser combinators</h1>
                
            
            
                
<p>Another major application of combinators is parser combinators. A parser combinator makes use of both the monad and combinator patterns. The monadic <kbd>bind</kbd> functions are used to bind data from parsers that are later returned as a parse result. The combinators join parsers into a sequence, failover, or other patterns.</p>
<p>The <kbd>chomp</kbd> parser combinator library is a good implementation of this concept. Also, the library provides a nice <kbd>parse!</kbd> macro that makes the combinator logic much easier to read. Here is an example:</p>
<pre class="p1">#[macro_use]<br/>extern crate chomp;<br/>use chomp::prelude::*;<br/><br/>#[derive(Debug, Eq, PartialEq)]<br/>struct Name&lt;B: Buffer&gt; {<br/>   first: B,<br/>   last:  B,<br/>}<br/><br/>fn name&lt;I: U8Input&gt;(i: I) -&gt; SimpleResult&lt;I, Name&lt;I::Buffer&gt;&gt; {<br/>   parse!{i;<br/>      let first = take_while1(|c| c != b' ');<br/>      token(b' ');  // skipping this char<br/>      let last  = take_while1(|c| c != b'\n');<br/><br/>      ret Name{<br/>         first: first,<br/>         last:  last,<br/>      }<br/>   }<br/>}<br/><br/>fn main() {<br/>   let parse_result = parse_only(name, "Martin Wernstål\n".as_bytes()).unwrap();<br/>   println!("first:{} last:{}",<br/></pre>
<pre class="p1">      String::from_utf8_lossy(parse_result.first),<br/>      String::from_utf8_lossy(parse_result.last));<br/>}</pre>
<p>Here, the example defines a grammar for a first name, last name parser. In the name function, the parser is defined with a macro. The inside of the macro looks almost like a normal code, like the <kbd>let</kbd> statements, function calls, and closure definitions. However, the generated code is actually a mix of monads and combinators.</p>
<p>Each <kbd>let</kbd> binding corresponds to a combinator. Each semicolon corresponds to a combinator. The functions <kbd>take_while1</kbd> and <kbd>token</kbd> are both combinators that introduce parser monads. Then, when the macro ends, we are left with an expression that processes the input to parse a result.</p>
<p>This <kbd>chomp</kbd> parser combinator library is fully featured and may be hard to understand if you just casually examined the source code. To see what is happening here, let's create our own parser combinators. First, let's define the parser state:</p>
<pre class="p1" style="padding-left: 30px">use std::rc::Rc;<br/><br/>#[derive(Clone)]<br/>struct ParseState&lt;A: Clone&gt; {<br/>   buffer: Rc&lt;Vec&lt;char&gt;&gt;,<br/>   index: usize,<br/>   a: A<br/>}<br/><br/>impl&lt;A: Clone&gt; ParseState&lt;A&gt; {<br/>   fn new(a: A, buffer: String) -&gt; ParseState&lt;A&gt; {<br/>      let buffer: Vec&lt;char&gt; = buffer.chars().collect();<br/>      ParseState {<br/>         buffer: Rc::new(buffer),<br/>         index: 0,<br/>         a: a<br/>      }<br/>   }<br/>   fn next(&amp;self) -&gt; (ParseState&lt;A&gt;,Option&lt;char&gt;) {<br/>      if self.index &lt; self.buffer.len() {<br/>         let new_char = self.buffer[self.index];<br/>         let new_index = self.index + 1;<br/>         (ParseState {<br/>            buffer: Arc::clone(&amp;self.buffer),<br/>            index: new_index,<br/>            a: self.a.clone()<br/>         }, Some(new_char))<br/>      } else {<br/>         (ParseState {<br/>            buffer: Rc::clone(&amp;self.buffer),<br/>            index: self.index,<br/>            a: self.a.clone()<br/>         },None)<br/>      }<br/>   }<br/>}<br/><br/>#[derive(Debug)]<br/>struct ParseRCon&lt;A,B&gt;(A,Result&lt;Option&lt;B&gt;,String&gt;);<br/><br/>#[derive(Debug)]<br/>enum ParseOutput&lt;A&gt; {<br/>   Success(A),<br/>   Failure(String)<br/>}</pre>
<p>Here we define <kbd>ParseState</kbd>, <kbd>ParseRCon</kbd>, and <kbd>ParseResult</kbd>. The parse state keeps track of what character index the parser is at. The parse state often also records information, such as the line and column number.</p>
<p>The <kbd>ParseRCon</kbd> structure encapsulates state along with an optional value wrapped in a result. If an unrecoverable error happens while parsing, the result will become <kbd>Err</kbd>. If a recoverable error happens while parsing, the option will be <kbd>None</kbd>. Otherwise, the parsers should work mostly as if they expect to always have the optional value.</p>
<p>The <kbd>ParseResult</kbd> type is returned at the very end of a parse execution to provide a successful result or error message.</p>
<p>The parser monads and combinators are defined ad hoc with different functions. To create a parser, the simplest options would be <kbd>parse_mzero</kbd> and <kbd>parse_return</kbd>:</p>
<pre class="p1" style="padding-left: 30px">fn parse&lt;St: Clone,A,P&gt;(p: &amp;P, st: &amp;ParseState&lt;St&gt;) -&gt; ParseOutput&lt;A&gt;<br/>   where P: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/>   match p(st.clone()) {<br/>      ParseRCon(_,Ok(Some(a))) =&gt; ParseOutput::Success(a),<br/>      ParseRCon(_,Ok(None)) =&gt; ParseOutput::Failure("expected input".to_string()),<br/>      ParseRCon(_,Err(err)) =&gt; ParseOutput::Failure(err)<br/>   }<br/>}<br/><br/>fn parse_mzero&lt;St: Clone,A&gt;(st: ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/>   ParseRCon(st,Err("mzero failed".to_string()))<br/>}<br/><br/>fn parse_return&lt;St: Clone,A: Clone&gt;(a: A) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;) {<br/>   move |st| { ParseRCon(st,Ok(Some(a.clone()))) }<br/>}<br/><br/>fn main() {<br/>   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/>   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/><br/>   let p1 = parse_mzero::&lt;(),()&gt;;<br/>   println!("p1 input1: {:?}", parse(&amp;p1,&amp;input1));<br/>   println!("p1 input2: {:?}", parse(&amp;p1,&amp;input2));<br/><br/>   let p2 = parse_return(123);<br/>   println!("p2 input1: {:?}", parse(&amp;p2,&amp;input1));<br/>   println!("p2 input2: {:?}", parse(&amp;p2,&amp;input2));<br/>}</pre>
<p>The <kbd>parse_mzero</kbd> monad always fails and returns a simple message. The <kbd>parse_return</kbd> always succeeds and returns a given value.</p>
<p>To make things more interesting, let's actually look at a parser that consumes input. We create the following two functions—<kbd>parse_token</kbd> and <kbd>parse_satisfy</kbd>. <kbd>parse_token</kbd> will always consume one token and return its value unless there is no more input. <kbd>parse_satisfy</kbd> will consume a token if the token satisfies some condition. Here are the definitions:</p>
<pre class="p1" style="padding-left: 30px">fn parse_token&lt;St: Clone,A,T&gt;(t: T) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;)<br/>   where T: 'static + Fn(char) -&gt; Option&lt;A&gt; {<br/>   move |st: ParseState&lt;St&gt;| {<br/>      let (next_state,next_char) = st.clone().next();<br/>      match next_char {<br/>         Some(c) =&gt; ParseRCon(next_state,Ok(t(c))),<br/>         None =&gt; ParseRCon(st,Err("end of input".to_string()))<br/>      }<br/>   }<br/>}<br/><br/>fn parse_satisfy&lt;St: Clone,T&gt;(t: T) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,char&gt;)<br/>   where T: 'static + Fn(char) -&gt; bool {<br/>   parse_token(move |c| if t(c) {Some(c)} else {None})<br/>}<br/><br/>fn main() {<br/>   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/>   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/><br/>   let p3 = parse_satisfy(|c| c=='1');<br/>   println!("p3 input1: {:?}", parse(&amp;p3,&amp;input1));<br/>   println!("p3 input2: {:?}", parse(&amp;p3,&amp;input2));<br/><br/>   let digit = parse_satisfy(|c| c.is_digit(10));<br/>   println!("digit input1: {:?}", parse(&amp;digit,&amp;input1));<br/>   println!("digit input2: {:?}", parse(&amp;digit,&amp;input2));<br/><br/>   let space = parse_satisfy(|c| c==' ');<br/>   println!("space input1: {:?}", parse(&amp;space,&amp;input1));<br/>   println!("space input2: {:?}", parse(&amp;space,&amp;input2));<br/><br/>   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');<br/>   println!("operator input1: {:?}", parse(&amp;operator,&amp;input1));<br/>   println!("operator input2: {:?}", parse(&amp;operator,&amp;input2));<br/>}</pre>
<p>The <kbd>parse_token</kbd> and <kbd>parse_satisfy</kbd> look at one token. If the token satisfies the provided condition, it then returns the input token. Here, we create several conditions to correspond to single character matching, digits, spaces, or arithmetic operators.</p>
<p>These functions can be composed using high-level combinators to create complex grammar:</p>
<pre class="p1" style="padding-left: 30px">fn parse_bind&lt;St: Clone,A,B,P1,P2,B1&gt;(p1: P1, b1: B1)<br/>   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;<br/>   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/>         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;,<br/>         B1: Fn(A) -&gt; P2 {<br/>   move |st| {<br/>      match p1(st) {<br/>         ParseRCon(nst,Ok(Some(a))) =&gt; b1(a)(nst),<br/>         ParseRCon(nst,Ok(None)) =&gt; ParseRCon(nst,Err("bind failed".to_string())),<br/>         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/>      }<br/>   }<br/>}<br/><br/>fn parse_sequence&lt;St: Clone,A,B,P1,P2&gt;(p1: P1, p2: P2)<br/>   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;<br/>   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/>         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt; {<br/>   move |st| {<br/>      match p1(st) {<br/>         ParseRCon(nst,Ok(_)) =&gt; p2(nst),<br/>         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/>      }<br/>   }<br/>}<br/><br/>fn parse_or&lt;St: Clone,A,P1,P2&gt;(p1: P1, p2: P2)<br/>   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;<br/>   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/>         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/>   move |st| {<br/>      match p1(st.clone()) {<br/>         ParseRCon(nst,Ok(Some(a))) =&gt; ParseRCon(nst,Ok(Some(a))),<br/>         ParseRCon(_,Ok(None)) =&gt; p2(st),<br/>         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/>      }<br/>   }<br/>}<br/><br/>fn main() {<br/>   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/>   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/><br/>   let digit = parse_satisfy(|c| c.is_digit(10));<br/>   let space = parse_satisfy(|c| c==' ');<br/>   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');<br/>   let ps1 = parse_sequence(digit,space);<br/>   let ps2 = parse_sequence(ps1,operator);<br/>   println!("digit,space,operator input1: {:?}", parse(&amp;ps2,&amp;input1));<br/>   println!("digit,space,operator input2: {:?}", parse(&amp;ps2,&amp;input2));<br/>}</pre>
<p>Here, we see how the monadic <kbd>parse_bind</kbd> or its derivative, <kbd>parse_sequence</kbd>, can be used to sequence two parsers together. We don't have an example here but the failover combinator is also defined in <kbd>parse_or</kbd>.</p>
<p>Using these primitives, we can create nice tools to help us generate complex parsers that expect, store, and manipulate data from token streams. Parse combinators are one of the more practical yet challenging applications of monads and combinators. The fact that these concepts are at all possible in Rust demonstrates how far the language has developed towards supporting functional concepts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the lazy evaluation pattern</h1>
                
            
            
                
<p>Lazy evaluation is procrastination, doing work later rather than now. Why is this important? Well, it turns out if you procrastinate long enough, sometimes it turns out that the work never needed to be done after all!</p>
<p>Take, for example, a simple expression evaluation:</p>
<pre class="p1" style="padding-left: 30px">fn main()<br/>{<br/>   2 + 3;<br/><br/>   || 2 + 3;<br/>}</pre>
<p>In a strict interpretation, the first expression will perform an arithmetic calculation. The second expression will define an arithmetic calculation but will wait before evaluating it.</p>
<p>This case is so simple that the compiler gives a warning and might choose to discard the unused constant expression. In more complicated cases, the lazy evaluated case will always perform better when not evaluated. This should be expected because unused lazy expressions do nothing, intentionally.</p>
<p>Iterators are lazy. They don't do anything until you collect or otherwise iterate over them:</p>
<pre class="p1">fn main() {<br/>   let a = (0..10).map(|x| x * x);<br/>   //nothing yet<br/><br/>   for x in a {<br/>      println!("{}", x);<br/></pre>
<pre class="p1">   }<br/>   //now it ran<br/>}</pre>
<p>Another data structure that intentionally uses lazy evaluation is the lazy list. A lazy list is very similar to an iterator with the exception that lazy lists can be shared and consumed at different paces independently.</p>
<p>In the parser combinator example, we hid a lazy list inside of the parser state structure. Let's isolate that and see what a pure definition looks like:</p>
<pre class="p1" style="padding-left: 30px">use std::rc::Rc;<br/><br/>#[derive(Clone)]<br/>struct LazyList&lt;A: Clone&gt; {<br/>   buffer: Rc&lt;Vec&lt;A&gt;&gt;,<br/>   index: usize<br/>}<br/><br/>impl&lt;A: Clone&gt; LazyList&lt;A&gt; {<br/>   fn new(buf: Vec&lt;A&gt;) -&gt; LazyList&lt;A&gt; {<br/>      LazyList {<br/>         buffer: Rc::new(buf),<br/>         index: 0<br/>      }<br/>   }<br/>   fn next(&amp;self) -&gt; Option&lt;(LazyList&lt;A&gt;,A)&gt; {<br/>      if self.index &lt; self.buffer.len() {<br/>         let new_item = self.buffer[self.index].clone();<br/>         let new_index = self.index + 1;<br/>         Some((LazyList {<br/>            buffer: Rc::clone(&amp;self.buffer),<br/>            index: new_index<br/>         },new_item))<br/>      } else {<br/>         None<br/>      }<br/>   }<br/>}<br/><br/>fn main()<br/>{<br/>   let ll = LazyList::new(vec![1,2,3]);<br/>   let (ll1,a1) = ll.next().expect("expect 1 item");<br/>   println!("lazy item 1: {}", a1);<br/><br/>   let (ll2,a2) = ll1.next().expect("expect 2 item");<br/>   println!("lazy item 2: {}", a2);<br/><br/>   let (ll3,a3) = ll2.next().expect("expect 3 item");<br/>   println!("lazy item 3: {}", a3);<br/><br/>   let (ll2,a2) = ll1.next().expect("expect 2 item");<br/>   println!("lazy item 2: {}", a2);<br/>}</pre>
<p>Here, we can see that a lazy list is much like an iterator. In fact, a lazy list could implement the <kbd>Iterator</kbd> trait; then it really would be an iterator. However, iterators are not lazy lists. Lazy lists inherently have an unlimited capacity to look ahead to any number of items. Iterators, on the other hand, optionally, may implement the <kbd>Peekable</kbd> trait permitting one look ahead.</p>
<p>There is a fundamental problem at the core of lazy programming, though. Too much procrastination will never complete any task. If you write a program to launch missiles, at some point in the program, it needs to actually launch missiles. This is an irreversible side-effect of running the program. We don't like side-effects, and lazy programming takes an extreme stance against side- effects. At the same time, we need to accomplish the given task though, and that involves making a choice at some point to push the launch button.</p>
<p>Clearly, we can never fully contain the behavior of programs with side-effects. However, we can make them easier to work with. By wrapping side-effects into lazy evaluated expressions, then turning them into monads, what we create are side-effect units. These units can then be manipulated and composed in a more functional style.</p>
<p>The last lazy pattern that we will introduce is <strong>functional reactive programming</strong>, <strong>FRP</strong> for short. There are entire programming languages, such as Elm, based on this concept. Popular web UI frameworks, such as React or Angular, are also influenced by FRP concepts.</p>
<p>The FRP concept is an extension of the side-effect/state monad example. Event handling, state transitions, and side-effects can be turned into units of reactive programming. Let's define a monad to capture this reactive unit concept:</p>
<pre class="p1" style="padding-left: 30px">struct ReactiveUnit&lt;St,A,B&gt; {<br/>   state: Arc&lt;Mutex&lt;St&gt;&gt;,<br/>   event_handler: Arc&lt;Fn(&amp;mut St,A) -&gt; B&gt;<br/>}<br/><br/>impl&lt;St: 'static,A: 'static,B: 'static&gt; ReactiveUnit&lt;St,A,B&gt; {<br/>   fn new&lt;F&gt;(st: St, f: F) -&gt; ReactiveUnit&lt;St,A,B&gt;<br/>      where F: 'static + Fn(&amp;mut St,A) -&gt; B<br/>   {<br/>      ReactiveUnit {<br/>         state: Arc::new(Mutex::new(st)),<br/>         event_handler: Arc::new(f)<br/>      }<br/>   }<br/>   fn bind&lt;G,C&gt;(&amp;self, g: G) -&gt; ReactiveUnit&lt;St,A,C&gt;<br/>      where G: 'static + Fn(&amp;mut St,B) -&gt; C {<br/>      let ev = Arc::clone(&amp;self.event_handler);<br/>      ReactiveUnit {<br/>         state: Arc::clone(&amp;self.state),<br/>         event_handler: Arc::new(move |st: &amp;mut St,a| {<br/>            let r = ev(st,a);<br/>            let r = g(st,r);<br/>            r<br/>         })<br/>      }<br/>   }<br/>   fn plus&lt;St2: 'static,C: 'static&gt;(&amp;self, other: ReactiveUnit&lt;St2,B,C&gt;) -&gt; ReactiveUnit&lt;(Arc&lt;Mutex&lt;St&gt;&gt;,Arc&lt;Mutex&lt;St2&gt;&gt;),A,C&gt; {<br/>      let ev1 = Arc::clone(&amp;self.event_handler);<br/>      let st1 = Arc::clone(&amp;self.state);<br/>      let ev2 = Arc::clone(&amp;other.event_handler);<br/>      let st2 = Arc::clone(&amp;other.state);<br/>      ReactiveUnit {<br/>         state: Arc::new(Mutex::new((st1,st2))),<br/>         event_handler: Arc::new(move |stst: &amp;mut (Arc&lt;Mutex&lt;St&gt;&gt;,Arc&lt;Mutex&lt;St2&gt;&gt;),a| {<br/>            let mut st1 = stst.0.lock().unwrap();<br/>            let r = ev1(&amp;mut st1, a);<br/>            let mut st2 = stst.1.lock().unwrap();<br/>            let r = ev2(&amp;mut st2, r);<br/>            r<br/>         })<br/>      }<br/>   }<br/>   fn apply(&amp;self, a: A) -&gt; B {<br/>      let mut st = self.state.lock().unwrap();<br/>      (self.event_handler)(&amp;mut st, a)<br/>   }<br/>}</pre>
<p>Here, we find that a <kbd>ReactiveUnit</kbd> holds state, can respond to an input, cause side-effects, and return a value. Reactive units can be extended with <kbd>bind</kbd> or concatenated with <kbd>plus</kbd>.</p>
<p>Now, let's make a reactive unit. We will focus on web frameworks since those seem to be popular. First, we render a simple HTML page, as follows:</p>
<pre class="p1" style="padding-left: 30px">let render1 = ReactiveUnit::new((),|(),()| {<br/>   let html = r###"$('body').innerHTML = '<br/>      &lt;header&gt;<br/>         &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/>         &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/>         &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/>      &lt;/header&gt;<br/>      &lt;div&gt;page content&lt;/div&gt;<br/>    &lt;footer&gt;Copyright&lt;/footer&gt;<br/>  ';"###;<br/>  html.to_string()<br/>});<br/>println!("{}", render1.apply(()));</pre>
<p>Here, the unit renders a simple page corresponding to <kbd>section 1</kbd> on a website. The unit will always render a whole page and does not consider any state or input. Let's give the unit more responsibilities by telling it to render different content based on which section is active:</p>
<pre class="p1" style="padding-left: 30px">let render2 = ReactiveUnit::new((),|(),section: usize| {<br/><br/>   let section_1 = r###"$('body').innerHTML = '<br/>      &lt;header&gt;<br/>         &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/>         &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/>         &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/>      &lt;/header&gt;<br/>      &lt;div&gt;section 1 content&lt;/div&gt;<br/>      &lt;footer&gt;Copyright&lt;/footer&gt;<br/>    ';"###;<br/><br/>    let section_2 = r###"$('body').innerHTML = '<br/>      &lt;header&gt;<br/>        &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/>        &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/>        &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/>      &lt;/header&gt;<br/>      &lt;div&gt;section 2 content&lt;/div&gt;<br/>      &lt;footer&gt;Copyright&lt;/footer&gt;<br/>    ';"###;<br/><br/>    let section_3 = r###"$('body').innerHTML = '<br/>      &lt;header&gt;<br/>        &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/>        &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/>        &lt;h3 data-section="3" class="active"&gt;Section 3&lt;/h3&gt;<br/>      &lt;/header&gt;<br/>      &lt;div&gt;section 3 content&lt;/div&gt;<br/>      &lt;footer&gt;Copyright&lt;/footer&gt;<br/>   ';"###;<br/><br/>   if section==1 {<br/>      section_1.to_string()<br/>   } else if section==2 {<br/>      section_2.to_string()<br/>   } else if section==3 {<br/>      section_3.to_string()<br/>   } else {<br/>      panic!("unknown section")<br/>   }<br/>});<br/><br/>println!("{}", render2.apply(1));<br/>println!("{}", render2.apply(2));<br/>println!("{}", render2.apply(3));</pre>
<p>Here, the unit makes use of the parameter to decide what section should be rendered. This is starting to feel more like a UI framework, but we aren't using the state, yet. Let's try using that to address a common web problem—page tearing. When a large portion of HTML is changed on a web page, the browser must recalculate how the page should be displayed. Most modern browsers do this in stages and the result is an ugly mishmash of components being visibly thrown around the page.</p>
<p>To reduce or prevent page tearing, we should only update portions of the page that have changed. Let's use the state variable along with the input parameter to only send updates when a component has changed:</p>
<pre style="padding-left: 30px">let render3header = ReactiveUnit::new(None,|opsec: &amp;mut Option&lt;usize&gt;,section: usize| {<br/>   let section_1 = r###"$('header').innerHTML = '<br/>      &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/>      &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/>      &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/>   ';"###;<br/>   let section_2 = r###"$('header').innerHTML = '<br/>      &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/>      &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/>      &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/>   ';"###;<br/>   let section_3 = r###"$('header').innerHTML = '<br/>      &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/>      &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/>      &lt;h3 data-section="3" class="active"&gt;Section 3&lt;/h3&gt;<br/>   ';"###;<br/>   let changed = if section==1 {<br/>      section_1<br/>   } else if section==2 {<br/>      section_2<br/>   } else if section==3 {<br/>      section_3<br/>   } else {<br/>      panic!("invalid section")<br/>   };<br/>   if let Some(sec) = *opsec {<br/>      if sec==section { "" }<br/>      else {<br/>         *opsec = Some(section);<br/>         changed<br/>      }<br/>   } else {<br/>      *opsec = Some(section);<br/>      changed<br/>   }<br/>});<br/></pre>
<p>Here, we issue commands to conditionally render changes to the header. If the header is already in the correct state, then we do nothing. This code only takes responsibility for the header component. We also need to render changes to page content:</p>
<pre class="p1" style="padding-left: 30px">let render3content = ReactiveUnit::new(None,|opsec: &amp;mut Option&lt;usize&gt;,section: usize| {<br/>   let section_1 = r###"$('div#content').innerHTML = '<br/>      section 1 content<br/>   ';"###;<br/>   let section_2 = r###"$('div#content').innerHTML = '<br/>      section 2 content<br/>   ';"###;<br/>   let section_3 = r###"$('div#content').innerHTML = '<br/>      section 3 content<br/>   ';"###;<br/>   let changed = if section==1 {<br/>      section_1<br/>   } else if section==2 {<br/>      section_2<br/>   } else if section==3 {<br/>      section_3<br/>   } else {<br/>      panic!("invalid section")<br/>   };<br/>   if let Some(sec) = *opsec {<br/>      if sec==section { "" }<br/>      else {<br/>         *opsec = Some(section);<br/>         changed<br/>      }<br/>   } else {<br/>      *opsec = Some(section);<br/>      changed<br/>   }<br/>});</pre>
<p>Now, we have a component for the header and another component for the content. We should combine these two into a single unit. FRP libraries would probably have a cool neat way of doing this, but we don't; so instead, we just write a little unit to combine them manually:</p>
<pre class="p1" style="padding-left: 30px">let render3 = ReactiveUnit::new((render3header,render3content), |(rheader,rcontent),section: usize| {<br/>   let header = rheader.apply(section);<br/>   let content = rcontent.apply(section);<br/>   format!("{}{}", header, content)<br/>});</pre>
<p>Now, let's test this out:</p>
<pre class="p1" style="padding-left: 30px">println!("section 1: {}", render3.apply(1));<br/>println!("section 2: {}", render3.apply(2));<br/>println!("section 2: {}", render3.apply(2));<br/>println!("section 3: {}", render3.apply(3));</pre>
<p>Each <kbd>apply</kbd> issues appropriate new update commands. The redundant <kbd>apply</kbd> to render <kbd>section 2</kbd> again returns no commands, as intended. This is really lazy code; the good kind of lazy.</p>
<p>What would reactive programming be without event handling? Let's handle a couple of signals and events. On top of the page state, let's introduce some database interaction:</p>
<pre class="p1" style="padding-left: 30px">let database = ("hello world", 5, 2);<br/>let react1 = ReactiveUnit::new((database,render3), |(database,render),evt:(&amp;str,&amp;str)| {<br/>   match evt {<br/>      ("header button click",n) =&gt; render.apply(n.parse::&lt;usize&gt;().unwrap()),<br/>      ("text submission",s) =&gt; { database.0 = s; format!("db.textfield1.set(\"{}\")",s) },<br/>      ("number 1 submission",n) =&gt; { database.1 += n.parse::&lt;i32&gt;().unwrap(); format!("db.numfield1.set(\"{}\")",database.1) },<br/>      ("number 2 submission",n) =&gt; { database.2 += n.parse::&lt;i32&gt;().unwrap(); format!("db.numfield2.set(\"{}\")",database.2) },<br/>      _ =&gt; "".to_string()<br/>   }<br/>});<br/><br/>println!("react 1: {}", react1.apply(("header button click","2")));<br/>println!("react 1: {}", react1.apply(("header button click","2")));<br/>println!("react 1: {}", react1.apply(("text submission","abc def")));<br/>println!("react 1: {}", react1.apply(("number 1 submission","123")));<br/>println!("react 1: {}", react1.apply(("number 1 submission","234")));<br/>println!("react 1: {}", react1.apply(("number 2 submission","333")));<br/>println!("react 1: {}", react1.apply(("number 2 submission","222")));</pre>
<p>We define four event types to react to. Responding to page state changes still works as previously defined. Events that should interact with the database issue commands to update the database locally and remotely. A view of the output JavaScript looks like the following:</p>
<pre class="p1" style="padding-left: 30px">event: ("header button click", "2")<br/>$('header').innerHTML = '<br/>   &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/>   &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/>   &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/>';$('div#content').innerHTML = '<br/>   section 2 content<br/>';<br/><br/>event: ("header button click", "2")<br/><br/>event: ("text submission", "abc def")<br/>db.textfield1.set("abc def")<br/><br/>event: ("number 1 submission", "123")<br/>db.numfield1.set("128")<br/><br/>event: ("number 1 submission", "234")<br/>db.numfield1.set("362")<br/><br/>event: ("number 2 submission", "333")<br/>db.numfield2.set("335")<br/><br/>event: ("number 2 submission", "222")<br/>db.numfield2.set("557")</pre>
<p>This correspondence demonstrates how simple side-effect units can be composed to create complex programmatic behavior. This is all built from an FRP library that is less than 50 lines long. Imagine the potential utility of a few more helper functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we introduced many common functional design patterns. We used a lot of scary words, such as functor, monad, and combinator. You should try to remember these words and their meanings. Other scary words, such as contravariant, you can probably forget unless you want to pursue math.</p>
<p>In an applied context, we learned that functors can hide information to expose simple transformations on data. The monad pattern allows us to turn sequential actions into units of computation. Monads can be used to create iterators that also behave more like lists. Laziness can be used to defer computation. Also, these patterns can often be combined in useful ways, such as FRP, which is gaining popularity as a tool to develop user interfaces and other complex interactive programs.</p>
<p>In the next chapter, we will explore concurrency. We will introduce the Rust concepts of thread/data ownership, shared synchronized data, and message passing. Thread-level concurrency is something that Rust was specifically designed for. If you have worked with threads in other languages, then hopefully the next chapter will be encouraging.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is a functor?</li>
<li>What is a contravariant functor?</li>
<li>What is a monad?</li>
<li>What are the monad laws?</li>
<li>What is a combinator?</li>
<li>Why is the <kbd>impl</kbd> keyword necessary for closure return values?</li>
<li>What is lazy evaluation?</li>
</ol>


            

            
        
    </body></html>