<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Design Patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root">Functional programming ha<span>s developed design patterns just like object-oriented or other communities. These patterns, unsurprisingly, make use of functions as a central concept. They also emphasize something called the</span> <strong>single responsibility principle</strong><span>. The single responsibility principle states that program's logical components should do one thing and do that one thing well. In this chapter, we will focus on a few very common patterns. Some of these concepts are so</span> simple<span> that they counter-intuitively become harder to explain. In these cases, we will make use of various examples to demonstrate how a simple concept can exhibit complex behavior.</span><br/></p>
<p>In this chapter, you will do the following:</p>
<ul>
<li>Learn to recognize and use functors</li>
<li>Learn to recognize and use monads</li>
<li>Learn to recognize and use combinators</li>
<li>Learn to recognize and use lazy evaluation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>A recent version of Rust is necessary to run the examples provided:</p>
<p><a href="https://www.rust-lang.org/en-US/install.html">https://www.rust-lang.org/en-US/install.html</a></p>
<p>This chapter's code is also available on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST">https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST</a></p>
<p>Specific installation and build instructions are also included in each chapter's <kbd>README.md</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the functor pattern</h1>
                </header>
            
            <article>
                
<p>A functor is approximately the inverse of a function:</p>
<ul>
<li>A function defines a transformation, accepts data, and returns the result of the transformation</li>
<li>A functor defines data, accepts a function, and returns the result of the transformation</li>
</ul>
<p>A simple example of a functor is the Rust vector and its accompanying <kbd>map</kbd> function:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main() {<br/>   let m: Vec&lt;u64&gt; = vec![1, 2, 3];<br/></span><span class="s1">   let n: Vec&lt;u64&gt; = m.iter().map(|x| { x*x }).collect();<br/></span><span class="s1">   println!("{:?}", m);<br/></span><span class="s1">   println!("{:?}", n);<br/>}</span></pre>
<p>Functors are often thought of as only the <kbd>map</kbd> function, due to the rules of what constitutes a functor or not. The preceding common case is what's called a <strong>structure-preserving map</strong>. Functors do not need to be structure-preserving. For example, take the very similar case of a map implemented for a set, as shown in the following code:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::collections::{HashSet};<br/><br/></span><span class="s1">fn main() </span><span class="s1">{<br/></span><span class="s1">   let mut a: HashSet&lt;u64&gt; = HashSet::new();<br/></span><span class="s1">   a.insert(1);<br/></span><span class="s1">   a.insert(2);<br/></span><span class="s1">   a.insert(3);<br/></span><span class="s1">   a.insert(4);<br/></span><span class="s1">   let b: HashSet&lt;u64&gt; = a.iter().cloned().map(|x| x/2).collect();<br/></span><span class="s1">   println!("{:?}", a);<br/></span><span class="s1">   println!("{:?}", b);<br/></span><span class="s1">}</span></pre>
<p>We see here that the resulting set is smaller than the original set due to collisions. This mapping still satisfies the properties of a functor. The defining properties of a functor are as follows:</p>
<ul>
<li>A collection of objects, <kbd>C</kbd></li>
<li>A mapping function that will transform objects in <kbd>C</kbd> into objects in <kbd>D</kbd></li>
</ul>
<p>The preceding <kbd>Set</kbd> map satisfies both the first and second property, and is therefore a proper functor. It also demonstrates how data can be transformed into a differently shaped structure through a functor. Using a little imagination, we may also consider the case where each mapped value may produce multiple outputs:</p>
<pre style="padding-left: 30px">fn main() {<br/><span class="s1">   let sentences = vec!["this is a sentence","paragraphs have many sentences"];<br/></span><span class="s1">   let words:Vec&lt;&amp;str&gt; = sentences.iter().flat_map(|&amp;x| x.split(" ")).collect();<br/></span><span class="s1">   println!("{:?}", sentences);<br/></span><span class="s1">   println!("{:?}", words);<br/></span><span class="s1">}</span></pre>
<p>Technically speaking, this last case is not a normal functor, but rather a contravariant functor. All functors are covariant. The distinction between covariance and contravariance is not important for our purposes, so we will leave that topic to only the most curious readers.</p>
<p>As a final definition by example, we should note that the input and output of a functor map need not be of the same type. For example, we can map from a vector to a <kbd>HashSet</kbd>:</p>
<pre class="p1"><span class="s1">use std::collections::{HashSet};<br/><br/></span><span class="s1">fn main() </span><span class="s1">{<br/></span><span class="s1">   let v: Vec&lt;u64&gt; = vec![1, 2, 3];<br/></span><span class="s1">   let s: HashSet&lt;u64&gt; = v.iter().cloned().map(|x| x/2).collect();<br/></span><span class="s1">   println!("{:?}", v);<br/></span><span class="s1">   println!("{:?}", s);<br/></span><span class="s1">}</span></pre>
<p>To give a non-trivial example of how the functor pattern could be used, let's look at webcams and AI. Modern AI facial recognition software is capable of identifying human faces in pictures and even visible emotional states. Let's imagine an app that connects to a webcam and processes the input with a filter. Here are some type definitions for the program:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct WebCamera;<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">enum VisibleEmotion {<br/></span><span class="s1">   Anger,<br/></span><span class="s1">   Contempt,<br/></span><span class="s1">   Disgust,<br/></span><span class="s1">   Fear,<br/></span><span class="s1">   Happiness,<br/></span><span class="s1">   Neutral,<br/></span><span class="s1">   Sadness,<br/></span><span class="s1">   Surprise<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Debug,Clone)]<br/></span><span class="s1">struct BoundingBox {<br/></span><span class="s1">   top: u64,<br/></span><span class="s1">   left: u64,<br/></span><span class="s1">   height: u64,<br/></span><span class="s1">   width: u64<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">enum CameraFilters {<br/></span><span class="s1">   Sparkles,<br/></span><span class="s1">   Rain,<br/></span><span class="s1">   Fire,<br/></span><span class="s1">   Disco<br/></span><span class="s1">}<br/><br/></span></pre>
<p>On the <kbd>WebCamera</kbd> type, we will implement two functors. One functor, <kbd>map_emotion</kbd>, will map emotions to other emotions. Maybe this could be used to add emojis to the text chat. The second contravariant functor, <kbd>flatmap_emotion</kbd>, maps emotions to zero, or more filters. These are animations or effects that can be applied back onto the web camera field of view:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">impl WebCamera {<br/></span><span class="s1">   fn map_emotion&lt;T,F&gt;(&amp;self, translate: F) -&gt; Vec&lt;(BoundingBox,T)&gt;<br/></span><span class="s1">   where F: Fn(VisibleEmotion) -&gt; T {<br/></span><span class="s1">      //Simulate emotion extracted from WebCamera<br/></span><span class="s1">      vec![<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),<br/></span><span class="s1">         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),<br/></span><span class="s1">         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)<br/></span><span class="s1">      ].into_iter().map(|(bb,emt)| {<br/></span><span class="s1">         (bb, translate(emt))<br/></span><span class="s1">      }).collect::&lt;Vec&lt;(BoundingBox,T)&gt;&gt;()<br/></span><span class="s1">   }<br/></span><span class="s1">   fn flatmap_emotion&lt;T,F,U:IntoIterator&lt;Item=T&gt;&gt;(&amp;self, mut translate: F) -&gt; Vec&lt;(BoundingBox,T)&gt;<br/></span><span class="s1">   where F: FnMut(VisibleEmotion) -&gt; U {<br/></span><span class="s1">      //Simulate emotion extracted from WebCamera<br/></span><span class="s1">      vec![<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Anger),<br/></span><span class="s1">         (BoundingBox { top: 1, left: 1, height: 1, width: 1 }, VisibleEmotion::Sadness),<br/></span><span class="s1">         (BoundingBox { top: 4, left: 4, height: 1, width: 1 }, VisibleEmotion::Surprise),<br/></span><span class="s1">         (BoundingBox { top: 8, left: 1, height: 1, width: 1 }, VisibleEmotion::Neutral)<br/></span><span class="s1">      ].into_iter().flat_map(|(bb,emt)| {<br/></span><span class="s1">         translate(emt).into_iter().map(move |t| (bb.clone(), t))<br/></span><span class="s1">      }).collect::&lt;Vec&lt;(BoundingBox,T)&gt;&gt;()<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/></span></pre>
<p>To use the functors, the programmer supplies which emotions map to which filters. The complex AI and effects can be easily modified due to the encapsulation provided by the functor pattern:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main() {<br/></span><span class="s1">   let camera = WebCamera;<br/></span><span class="s1">   let emotes: Vec&lt;(BoundingBox,VisibleEmotion)&gt; = camera.map_emotion(|emt| {<br/></span><span class="s1">      match emt {<br/></span><span class="s1">         VisibleEmotion::Anger |<br/></span><span class="s1">         VisibleEmotion::Contempt |<br/></span><span class="s1">         VisibleEmotion::Disgust |<br/></span><span class="s1">         VisibleEmotion::Fear |<br/></span><span class="s1">         VisibleEmotion::Sadness =&gt; VisibleEmotion::Happiness,<br/></span><span class="s1">         VisibleEmotion::Neutral |<br/></span><span class="s1">         VisibleEmotion::Happiness |<br/></span><span class="s1">         VisibleEmotion::Surprise =&gt; VisibleEmotion::Sadness<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/><br/></span><span class="s1">   let filters: Vec&lt;(BoundingBox,CameraFilters)&gt; = camera.flatmap_emotion(|emt| {<br/></span><span class="s1">      match emt {<br/></span><span class="s1">         VisibleEmotion::Anger |<br/></span><span class="s1">         VisibleEmotion::Contempt |<br/></span><span class="s1">         VisibleEmotion::Disgust |<br/></span><span class="s1">         VisibleEmotion::Fear |<br/></span><span class="s1">         VisibleEmotion::Sadness =&gt; vec![CameraFilters::Sparkles, CameraFilters::Rain],<br/></span><span class="s1">         VisibleEmotion::Neutral |<br/></span><span class="s1">         VisibleEmotion::Happiness |<br/></span><span class="s1">         VisibleEmotion::Surprise =&gt; vec![CameraFilters::Disco]<br/></span><span class="s1">      }<br/></span><span class="s1">   });<br/><br/></span><span class="s1">   println!("{:?}",emotes);<br/></span><span class="s1">   println!("{:?}",filters);<br/>}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the monad pattern</h1>
                </header>
            
            <article>
                
<p>A monad defines <kbd>return</kbd> and <kbd>bind</kbd> operations for a type. The <kbd>return</kbd> operation is like a constructor to make the monad. The <kbd>bind</kbd> operation incorporates new information and returns a new monad. There are also several laws that monads should obey. Rather than quote the laws, we'll just say that monads should behave well when daisy chained like the following:</p>
<pre style="padding-left: 30px">MyMonad::return(value)  //We start with a new MyMonad&lt;A&gt;<br/>        .bind(|x| x+x)  //We take a step into MyMonad&lt;B&gt;<br/>        .bind(|y| y*y); //Similarly we get to MyMonad&lt;C&gt;</pre>
<p>In Rust, there are several semi-monads that appear in standard libraries:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main()<br/></span><span class="s1">{<br/></span><span class="s1">   let v1 = Some(2).and_then(|x| Some(x+x)).and_then(|y| Some(y*y));<br/></span><span class="s1">   println!("{:?}", v1);<br/><br/></span><span class="s1">   let v2 = None.or_else(|| None).or_else(|| Some(222));<br/></span><span class="s1">   println!("{:?}", v2);<br/></span><span class="s1">}</span></pre>
<p>In this example, the normal <kbd>Option</kbd> constructors, <kbd>Some</kbd> or <kbd>None</kbd>, take the place of the monadic naming convention, <kbd>return</kbd>. There are two semi-monads implemented here, one associated with <kbd>and_then</kbd>, and the other with <kbd>or_else</kbd>. Both of these correspond to the monadic <kbd>bind</kbd> naming convention for the operator responsible for incorporating new information into a new monad return value.</p>
<p>Monadic <kbd>bind</kbd> operations are also polymorphic, meaning they should permit returning monads of different types from the current monad. According to this rule, <kbd>or_else</kbd> is not technically a monad; hence it is a semi-monad:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main() </span><span class="s1">{<br/></span><span class="s1">   let v3 = Some(2).and_then(|x| Some("abc"));<br/></span><span class="s1">   println!("{:?}", v3);<br/><br/></span><span class="s1">   // or_else is not quite a monad<br/></span><span class="s1">   // does not permit polymorphic bind<span class="Apple-converted-space"><br/></span></span><span class="s1">   //let v4 = Some(2).or_else(|| Some("abc"));<br/></span><span class="s1">   //println!("{:?}", v4);<br/></span><span class="s1">}</span></pre>
<p>Monads were originally developed to express side-effects in purely functional languages. Isn't that a contradiction—pure with side-effects?</p>
<p>The answer is <em>no</em> if the effects are passed as input and output through pure functions. However, for this to work, every function would need to declare every state variable and pass it along, which could become a huge list of parameters. This is where monads come in. A monad can hide state inside itself, which becomes essentially a larger, more complex function than what the programmer interacts with.</p>
<p>One concrete example of side-effect hiding is the concept of a universal logger. The monadic <kbd>return</kbd> and <kbd>bind</kbd> can be used to wrap state and computation inside of a monad that will log all intermediate results. Here is the logger monad:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::fmt::{Debug};<br/><br/></span><span class="s1">struct LogMonad&lt;T&gt;(T);<br/></span><span class="s1">impl&lt;T&gt; LogMonad&lt;T&gt; {<br/></span><span class="s1">   fn _return(t: T) -&gt; LogMonad&lt;T&gt;<br/></span><span class="s1">   where T: Debug {<br/></span><span class="s1">      println!("{:?}", t);<br/></span><span class="s1">      LogMonad(t)<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind&lt;R,F&gt;(&amp;self, f: F) -&gt; LogMonad&lt;R&gt;<br/></span><span class="s1">   wher</span>e F: FnOnce(<span class="s1">&amp;T) -&gt; R,<br/></span><span class="s1">   R: Debug {<br/></span><span class="s1">      let r = f(&amp;self.0);<br/></span><span class="s1">      println!("{:?}", r);<br/></span><span class="s1">      LogMonad(r)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   LogMonad::_return(4)<br/></span><span class="s1">            .bind(|x| x+x)<br/></span><span class="s1">            .bind(|y| y*y)<br/></span><span class="s1">            .bind(|z| format!("{}{}{}", z, z, z));<br/></span><span class="s1">}</span></pre>
<p>As long as each result implements the <kbd>Debug</kbd> trait, it can be automatically logged with this pattern.</p>
<p>The monad pattern is also very useful for chaining together code that can't be written in a normal code block. For example, code blocks are always evaluated eagerly. If you want to define code that will be evaluated later or in pieces, the lazy monad pattern is very convenient. Lazy evaluation is a term used to describe code or data that is not evaluated until it is referenced. This is contrary to the typical eager evaluation of Rust code that will execute immediately regardless of context. Here is the lazy monad pattern:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct LazyMonad&lt;A,B&gt;(Box&lt;Fn(A) -&gt; B&gt;);<br/><br/></span><span class="s1">impl&lt;A: 'static,B: 'static&gt; LazyMonad&lt;A,B&gt; {<br/></span><span class="s1">   fn _return(u: A) -&gt; LazyMonad&lt;B,B&gt; {<br/></span><span class="s1">      LazyMonad(Box::new(move |b: B| b))<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind&lt;C,G: 'static&gt;(self, g: G) -&gt; LazyMonad&lt;A,C&gt;<br/></span><span class="s1">   where G: Fn(B) -&gt; C {<br/></span><span class="s1">      LazyMonad(Box::new(move |a: A| g(self.0(a))))<br/></span><span class="s1">   }<br/></span><span class="s1">   fn apply(self, a: A) -&gt; B {<br/></span><span class="s1">      self.0(a)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   let notyet = LazyMonad::_return(())   //we create LazyMonad&lt;()&gt;</span><span class="s1"><br/></span><span class="s1">                          .bind(|x| x+2) //and now a LazyMonad&lt;A&gt;<br/></span><span class="s1">                          .bind(|y| y*3) //and now a LazyMonad&lt;B&gt;<br/></span><span class="s1">                          .bind(|z| format!("{}{}", z, z));<br/><br/></span><span class="s1">   let nowdoit = notyet.apply(222); //The above code now run<br/></span><span class="s1">   println!("nowdoit {}", nowdoit);<br/></span>}</pre>
<p>This block defines statements that will be evaluated one at a time after a value is supplied, but not before. This may seem a bit trivial since we can do the same with a simple closure and code block; however, to make this pattern stick, let's consider a more complex case—an asynchronous web server.</p>
<p>A web server will typically receive a full HTTP request before processing it. Choosing what to do with a request is sometimes called <strong>routing</strong>. Then requests are sent to a request handler. In the following code, we define a server that helps us wrap routes and handlers into a single web server object. Here are the type and method definitions:</p>
<pre class="p1"><span class="s1">use std::io::prelude::*;<br/></span><span class="s1">use std::net::TcpListener;<br/></span><span class="s1">use std::net::TcpStream;<br/><br/></span><span class="s1">struct ServerMonad&lt;St&gt; {<br/></span><span class="s1">   state: St,<br/></span><span class="s1">   handlers: Vec&lt;Box&lt;Fn(&amp;mut St,&amp;String) -&gt; Option&lt;String&gt;&gt;&gt;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;St: Clone&gt; ServerMonad&lt;St&gt; {<br/></span><span class="s1">   fn _return(st: St) -&gt; ServerMonad&lt;St&gt; {<br/></span><span class="s1">      ServerMonad {<br/></span><span class="s1">         state: st,<br/></span><span class="s1">         handlers: Vec::new()<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn listen(&amp;mut self, address: &amp;str) {<br/></span><span class="s1">      let listener = TcpListener::bind(address).unwrap();<br/></span><span class="s1">      for stream in listener.incoming() {<br/></span><span class="s1">         let mut st = self.state.clone();<br/></span><span class="s1">         let mut buffer = [0; 2048];<br/></span><span class="s1">         let mut tcp = stream.unwrap();<br/></span><span class="s1">         tcp.read(&amp;mut buffer);<br/></span><span class="s1">         let buffer = String::from_utf8_lossy(&amp;buffer).into_owned();<br/></span><span class="s1">         for h in self.handlers.iter() {<br/></span><span class="s1">            if let Some(response) = h(&amp;mut st,&amp;buffer) {<br/></span><span class="s1">               tcp.write(response.as_bytes());<br/></span><span class="s1">               break<br/></span><span class="s1">            }<br/></span><span class="s1">         }<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind_handler&lt;F&gt;(mut self, f: F) -&gt; Self<br/></span><span class="s1">      where F: 'static + Fn(&amp;mut St,&amp;String) -&gt; Option&lt;String&gt; {<br/></span><span class="s1">      self.handlers.push(Box::new(f));<br/></span><span class="s1">      self<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>This type defines <kbd>return</kbd> and <kbd>bind</kbd> like operations. However, the <kbd>bind</kbd> function is not polymorphic and the operation is not a pure function. Without these compromises, we would need to fight against the Rust type and ownership system; the preceding example is not written monadically due to complications when trying to box and copy closures. This is an expected trade-off and the semi-monad pattern should not be discouraged when appropriate.</p>
<p>To define our web server responses, we can attach handlers like in the following code:</p>
<pre class="p1" style="padding-left: 30px">fn main() {<br/><span class="s1">   ServerMonad::_return(())<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%2 == 0 { Some("divisible by 2".to_string()) } else { None })<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%3 == 0 { Some("divisible by 3".to_string()) } else { None })<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%5 == 0 { Some("divisible by 5".to_string()) } else { None })<br/></span><span class="s1">               .bind_handler(|&amp;mut st, ref msg| if msg.len()%7 == 0 { Some("divisible by 7".to_string()) } else { None })<br/></span><span class="s1">               .listen("127.0.0.1:8888");<br/></span>}</pre>
<p>If you run this program and send messages to localhost <kbd>8888</kbd>, then you may get a response if the message length is divisible by <kbd>2</kbd>, <kbd>3</kbd>, <kbd>5</kbd>, or <kbd>7</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the combinator pattern</h1>
                </header>
            
            <article>
                
<p><span>A combinator is a function that takes other functions as arguments and returns a new function.</span></p>
<p>A simple example of a combinator would be the composition operator, which chains two functions together:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn compose&lt;A,B,C,F,G&gt;(f: F, g: G) -&gt; impl Fn(A) -&gt; C<br/></span><span class="s1">   where F: 'static + Fn(A) -&gt; B,<br/></span><span class="s1">         G: 'static + Fn(B) -&gt; C {<br/></span><span class="s1">   move |x| g(f(x))<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   let fa = |x| x+1;<br/></span><span class="s1">   let fb = |y| y*2;<br/></span><span class="s1">   let fc = |z| z/3;<br/></span><span class="s1">   let g = compose(compose(fa,fb),fc);<br/></span><span class="s1">   println!("g(1) = {}", g(1));<br/></span><span class="s1">   println!("g(12) = {}", g(12));<br/></span><span class="s1">   println!("g(123) = {}", g(123));<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parser combinators</h1>
                </header>
            
            <article>
                
<p>Another major application of combinators is parser combinators. A parser combinator makes use of both the monad and combinator patterns. The monadic <kbd>bind</kbd> functions are used to bind data from parsers that are later returned as a parse result. The combinators join parsers into a sequence, failover, or other patterns.</p>
<p>The <kbd>chomp</kbd> parser combinator library is a good implementation of this concept. Also, the library provides a nice <kbd>parse!</kbd> macro that makes the combinator logic much easier to read. Here is an example:</p>
<pre class="p1"><span class="s1">#[macro_use]<br/></span><span class="s1">extern crate chomp;<br/></span><span class="s1">use chomp::prelude::*;<br/><br/></span><span class="s1">#[derive(Debug, Eq, PartialEq)]<br/></span><span class="s1">struct Name&lt;B: Buffer&gt; {<br/></span><span class="s1">   first: B,<br/></span><span class="s1">   last:<span class="Apple-converted-space">  </span>B,<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn name&lt;I: U8Input&gt;(i: I) -&gt; SimpleResult&lt;I, Name&lt;I::Buffer&gt;&gt; {<br/></span><span class="s1">   parse!{i;<br/></span><span class="s1">      let first = take_while1(|c| c != b' ');<br/></span><span class="s1">      token(b' ');<span class="Apple-converted-space">  </span>// skipping this char<br/></span><span class="s1">      let last<span class="Apple-converted-space">  </span>= take_while1(|c| c != b'\n');<br/><br/></span><span class="s1">      ret Name{<br/></span><span class="s1">         first: first,<br/></span><span class="s1">         last:<span class="Apple-converted-space">  </span>last,<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}</span><span class="s1"><br/><br/></span>fn main() {<br/><span class="s1">   let parse_result = parse_only(name, "Martin Wernstål\n".as_bytes()).unwrap();<br/></span><span class="s1">   println!("first:{} last:{}",<br/></span></pre>
<pre class="p1"><span class="s1">      String::from_utf8_lossy(parse_result.first),<br/></span><span class="s1">      String::from_utf8_lossy(parse_result.last));<br/></span>}</pre>
<p>Here, the example defines a grammar for a first name, last name parser. In the name function, the parser is defined with a macro. The inside of the macro looks almost like a normal code, like the <kbd>let</kbd> statements, function calls, and closure definitions. However, the generated code is actually a mix of monads and combinators.</p>
<p>Each <kbd>let</kbd> binding corresponds to a combinator. Each semicolon corresponds to a combinator. The functions <kbd>take_while1</kbd> and <kbd>token</kbd> are both combinators that introduce parser monads. Then, when the macro ends, we are left with an expression that processes the input to parse a result.</p>
<p>This <kbd>chomp</kbd> parser combinator library is fully featured and may be hard to understand if you just casually examined the source code. To see what is happening here, let's create our own parser combinators. First, let's define the parser state:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">use std::rc::Rc;<br/><br/></span><span class="s1">#[derive(Clone)]<br/></span><span class="s1">struct ParseState&lt;A: Clone&gt; {<br/></span><span class="s1">   buffer: Rc&lt;Vec&lt;char&gt;&gt;,<br/></span><span class="s1">   index: usize,<br/></span><span class="s1">   a: A<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;A: Clone&gt; ParseState&lt;A&gt; {<br/></span><span class="s1">   fn new(a: A, buffer: String) -&gt; ParseState&lt;A&gt; {<br/></span><span class="s1">      let buffer: Vec&lt;char&gt; = buffer.chars().collect();<br/></span><span class="s1">      ParseState {<br/></span><span class="s1">         buffer: Rc::new(buffer),<br/></span><span class="s1">         index: 0,<br/></span><span class="s1">         a: a<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn next(&amp;self) -&gt; (ParseState&lt;A&gt;,Option&lt;char&gt;) {</span><span class="s1"><br/></span><span class="s1">      if self.index &lt; self.buffer.len() {<br/></span><span class="s1">         let new_char = self.buffer[self.index];<br/></span><span class="s1">         let new_index = self.index + 1;<br/></span><span class="s1">         (ParseState {<br/></span><span class="s1">            buffer: Arc::clone(&amp;self.buffer),<br/></span><span class="s1">            index: new_index,<br/></span><span class="s1">            a: self.a.clone()<br/></span><span class="s1">         }, Some(new_char))<br/></span><span class="s1">      } else {<br/></span><span class="s1">         (ParseState {<br/></span><span class="s1">            buffer: Rc::clone(&amp;self.buffer),<br/></span><span class="s1">            index: self.index,<br/></span><span class="s1">            a: self.a.clone()<br/></span><span class="s1">         },None)<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">struct ParseRCon&lt;A,B&gt;(A,Result&lt;Option&lt;B&gt;,String&gt;);<br/><br/></span><span class="s1">#[derive(Debug)]<br/></span><span class="s1">enum ParseOutput&lt;A&gt; {<br/></span><span class="s1">   Success(A),<br/></span><span class="s1">   Failure(String)<br/></span><span class="s1">}</span></pre>
<p>Here we define <kbd>ParseState</kbd>, <kbd>ParseRCon</kbd>, and <kbd>ParseResult</kbd>. The parse state keeps track of what character index the parser is at. The parse state often also records information, such as the line and column number.</p>
<p>The <kbd>ParseRCon</kbd> structure encapsulates state along with an optional value wrapped in a result. If an unrecoverable error happens while parsing, the result will become <kbd>Err</kbd>. If a recoverable error happens while parsing, the option will be <kbd>None</kbd>. Otherwise, the parsers should work mostly as if they expect to always have the optional value.</p>
<p>The <kbd>ParseResult</kbd> type is returned at the very end of a parse execution to provide a successful result or error message.</p>
<p>The parser monads and combinators are defined ad hoc with different functions. To create a parser, the simplest options would be <kbd>parse_mzero</kbd> and <kbd>parse_return</kbd>:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn parse&lt;St: Clone,A,P&gt;(p: &amp;P, st: &amp;ParseState&lt;St&gt;) -&gt; ParseOutput&lt;A&gt;<br/></span><span class="s1">   where P: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/></span><span class="s1">   match p(st.clone()) {<br/></span><span class="s1">      ParseRCon(_,Ok(Some(a))) =&gt; ParseOutput::Success(a),<br/></span><span class="s1">      ParseRCon(_,Ok(None)) =&gt; ParseOutput::Failure("expected input".to_string()),<br/></span><span class="s1">      ParseRCon(_,Err(err)) =&gt; ParseOutput::Failure(err)<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_mzero&lt;St: Clone,A&gt;(st: ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/></span><span class="s1">   ParseRCon(st,Err("mzero failed".to_string()))<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_return&lt;St: Clone,A: Clone&gt;(a: A) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;) {<br/></span><span class="s1">   move |st| { ParseRCon(st,Ok(Some(a.clone()))) }<br/></span><span class="s1">}<br/><br/>fn main() {<br/></span><span class="s1">   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/></span><span class="s1">   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/><br/></span><span class="s1">   let p1 = parse_mzero::&lt;(),()&gt;;<br/></span><span class="s1">   println!("p1 input1: {:?}", parse(&amp;p1,&amp;input1));<br/></span><span class="s1">   println!("p1 input2: {:?}", parse(&amp;p1,&amp;input2));<br/><br/></span><span class="s1">   let p2 = parse_return(123);<br/></span><span class="s1">   println!("p2 input1: {:?}", parse(&amp;p2,&amp;input1));<br/></span><span class="s1">   println!("p2 input2: {:?}", parse(&amp;p2,&amp;input2));<br/>}</span></pre>
<p>The <kbd>parse_mzero</kbd> monad always fails and returns a simple message. The <kbd>parse_return</kbd> always succeeds and returns a given value.</p>
<p>To make things more interesting, let's actually look at a parser that consumes input. We create the following two functions—<kbd>parse_token</kbd> and <kbd>parse_satisfy</kbd>. <kbd>parse_token</kbd> will always consume one token and return its value unless there is no more input. <kbd>parse_satisfy</kbd> will consume a token if the token satisfies some condition. Here are the definitions:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn parse_token&lt;St: Clone,A,T&gt;(t: T) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;)<br/></span><span class="s1">   where T: 'static + Fn(char) -&gt; Option&lt;A&gt; {<br/></span><span class="s1">   move |st: ParseState&lt;St&gt;| {<br/></span><span class="s1">      let (next_state,next_char) = st.clone().next();<br/></span><span class="s1">      match next_char {<br/></span><span class="s1">         Some(c) =&gt; ParseRCon(next_state,Ok(t(c))),<br/></span><span class="s1">         None =&gt; ParseRCon(st,Err("end of input".to_string()))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_satisfy&lt;St: Clone,T&gt;(t: T) -&gt; impl (Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,char&gt;)<br/></span><span class="s1">   where T: 'static + Fn(char) -&gt; bool {<br/></span><span class="s1">   parse_token(move |c| if t(c) {Some(c)} else {None})<br/></span><span class="s1">}<br/><br/>fn main() {<br/></span><span class="s1">   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/></span><span class="s1">   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/></span><span class="s1"><br/></span><span class="s1">   let p3 = parse_satisfy(|c| c=='1');<br/></span><span class="s1">   println!("p3 input1: {:?}", parse(&amp;p3,&amp;input1));<br/></span><span class="s1">   println!("p3 input2: {:?}", parse(&amp;p3,&amp;input2));<br/><br/></span><span class="s1">   let digit = parse_satisfy(|c| c.is_digit(10));<br/></span><span class="s1">   println!("digit input1: {:?}", parse(&amp;digit,&amp;input1));<br/></span><span class="s1">   println!("digit input2: {:?}", parse(&amp;digit,&amp;input2));<br/><br/></span><span class="s1">   let space = parse_satisfy(|c| c==' ');<br/></span><span class="s1">   println!("space input1: {:?}", parse(&amp;space,&amp;input1));<br/></span><span class="s1">   println!("space input2: {:?}", parse(&amp;space,&amp;input2));<br/><br/></span><span class="s1">   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');<br/></span><span class="s1">   println!("operator input1: {:?}", parse(&amp;operator,&amp;input1));<br/></span><span class="s1">   println!("operator input2: {:?}", parse(&amp;operator,&amp;input2));</span><span class="s1"><br/>}</span></pre>
<p>The <kbd>parse_token</kbd> and <kbd>parse_satisfy</kbd> look at one token. If the token satisfies the provided condition, it then returns the input token. Here, we create several conditions to correspond to single character matching, digits, spaces, or arithmetic operators.</p>
<p>These functions can be composed using high-level combinators to create complex grammar:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn parse_bind&lt;St: Clone,A,B,P1,P2,B1&gt;(p1: P1, b1: B1)<br/></span><span class="s1">   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;<br/></span><span class="s1">   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/></span><span class="s1">         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;,<br/></span><span class="s1">         B1: Fn(A) -&gt; P2 {<br/></span><span class="s1">   move |st| {<br/></span><span class="s1">      match p1(st) {<br/></span><span class="s1">         ParseRCon(nst,Ok(Some(a))) =&gt; b1(a)(nst),<br/></span><span class="s1">         ParseRCon(nst,Ok(None)) =&gt; ParseRCon(nst,Err("bind failed".to_string())),<br/></span><span class="s1">         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_sequence&lt;St: Clone,A,B,P1,P2&gt;(p1: P1, p2: P2)<br/></span><span class="s1">   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt;<br/></span><span class="s1">   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/></span><span class="s1">         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,B&gt; {<br/></span><span class="s1">   move |st| {<br/></span><span class="s1">      match p1(st) {<br/></span><span class="s1">         ParseRCon(nst,Ok(_)) =&gt; p2(nst),<br/></span><span class="s1">         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn parse_or&lt;St: Clone,A,P1,P2&gt;(p1: P1, p2: P2)<br/></span><span class="s1">   -&gt; impl Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;<br/></span><span class="s1">   where P1: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt;,<br/></span><span class="s1">         P2: Fn(ParseState&lt;St&gt;) -&gt; ParseRCon&lt;ParseState&lt;St&gt;,A&gt; {<br/></span><span class="s1">   move |st| {<br/></span><span class="s1">      match p1(st.clone()) {<br/></span><span class="s1">         ParseRCon(nst,Ok(Some(a))) =&gt; ParseRCon(nst,Ok(Some(a))),<br/></span><span class="s1">         ParseRCon(_,Ok(None)) =&gt; p2(st),<br/></span><span class="s1">         ParseRCon(nst,Err(err)) =&gt; ParseRCon(nst,Err(err))<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span>fn main() {<br/><span class="s1">   let input1 = ParseState::new((), "1 + 2 * 3".to_string());<br/></span><span class="s1">   let input2 = ParseState::new((), "3 / 2 - 1".to_string());<br/></span><br/><span class="s1">   let digit = parse_satisfy(|c| c.is_digit(10));<br/></span><span class="s1">   let space = parse_satisfy(|c| c==' ');<br/></span><span class="s1">   let operator = parse_satisfy(|c| c=='+' || c=='-' || c=='*' || c=='/');<br/></span><span class="s1">   let ps1 = parse_sequence(digit,space);<br/></span><span class="s1">   let ps2 = parse_sequence(ps1,operator);<br/></span><span class="s1">   println!("digit,space,operator input1: {:?}", parse(&amp;ps2,&amp;input1));<br/></span><span class="s1">   println!("digit,space,operator input2: {:?}", parse(&amp;ps2,&amp;input2));<br/></span>}</pre>
<p>Here, we see how the monadic <kbd>parse_bind</kbd> or its derivative, <kbd>parse_sequence</kbd>, can be used to sequence two parsers together. We don't have an example here but the failover combinator is also defined in <kbd>parse_or</kbd>.</p>
<p>Using these primitives, we can create nice tools to help us generate complex parsers that expect, store, and manipulate data from token streams. Parse combinators are one of the more practical yet challenging applications of monads and combinators. The fact that these concepts are at all possible in Rust demonstrates how far the language has developed towards supporting functional concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the lazy evaluation pattern</h1>
                </header>
            
            <article>
                
<p>Lazy evaluation is procrastination, doing work later rather than now. Why is this important? Well, it turns out if you procrastinate long enough, sometimes it turns out that the work never needed to be done after all!</p>
<p>Take, for example, a simple expression evaluation:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">fn main()<br/></span><span class="s1">{<br/></span><span class="s1">   2 + 3;<br/><br/></span><span class="s1">   || 2 + 3;<br/></span><span class="s1">}</span></pre>
<p>In a strict interpretation, the first expression will perform an arithmetic calculation. The second expression will define an arithmetic calculation but will wait before evaluating it.</p>
<p>This case is so simple that the compiler gives a warning and might choose to discard the unused constant expression. In more complicated cases, the lazy evaluated case will always perform better when not evaluated. This should be expected because unused lazy expressions do nothing, intentionally.</p>
<p>Iterators are lazy. They don't do anything until you collect or otherwise iterate over them:</p>
<pre class="p1"><span class="s1">fn main() {<br/></span><span class="s1">   let a = (0..10).map(|x| x * x);<br/>   //nothing yet<br/><br/></span><span class="s1">   for x in a {<br/></span><span class="s1">      println!("{}", x);<br/></span></pre>
<pre class="p1"><span class="s1">   }<br/>   //now it ran<br/></span><span class="s1">}</span></pre>
<p>Another data structure that intentionally uses lazy evaluation is the lazy list. A lazy list is very similar to an iterator with the exception that lazy lists can be shared and consumed at different paces independently.</p>
<p>In the parser combinator example, we hid a lazy list inside of the parser state structure. Let's isolate that and see what a pure definition looks like:</p>
<pre class="p1" style="padding-left: 30px">use std::rc::Rc;<span class="s1"><br/><br/></span><span class="s1">#[derive(Clone)]<br/></span><span class="s1">struct LazyList&lt;A: Clone&gt; {<br/></span><span class="s1">   buffer: Rc&lt;Vec&lt;A&gt;&gt;,<br/></span><span class="s1">   index: usize<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;A: Clone&gt; LazyList&lt;A&gt; {<br/></span><span class="s1">   fn new(buf: Vec&lt;A&gt;) -&gt; LazyList&lt;A&gt; {<br/></span><span class="s1">      LazyList {<br/></span><span class="s1">         buffer: Rc::new(buf),<br/></span><span class="s1">         index: 0<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn next(&amp;self) -&gt; Option&lt;(LazyList&lt;A&gt;,A)&gt; {</span><span class="s1"><br/></span><span class="s1">      if self.index &lt; self.buffer.len() {<br/></span><span class="s1">         let new_item = self.buffer[self.index].clone();<br/></span><span class="s1">         let new_index = self.index + 1;<br/></span><span class="s1">         Some((LazyList {<br/></span><span class="s1">            buffer: Rc::clone(&amp;self.buffer),<br/></span><span class="s1">            index: new_index<br/></span><span class="s1">         },new_item))<br/></span><span class="s1">      } else {<br/></span><span class="s1">         None<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">}<br/><br/></span><span class="s1">fn main()<br/></span><span class="s1">{<br/></span><span class="s1">   let ll = LazyList::new(vec![1,2,3]);<br/></span><span class="s1">   let (ll1,a1) = ll.next().expect("expect 1 item");<br/></span><span class="s1">   println!("lazy item 1: {}", a1);<br/><br/></span><span class="s1">   let (ll2,a2) = ll1.next().expect("expect 2 item");<br/></span><span class="s1">   println!("lazy item 2: {}", a2);<br/><br/></span><span class="s1">   let (ll3,a3) = ll2.next().expect("expect 3 item");<br/></span><span class="s1">   println!("lazy item 3: {}", a3);<br/></span><span class="s1"><br/>   let (ll2,a2) = ll1.next().expect("expect 2 item");<br/></span><span class="s1">   println!("lazy item 2: {}", a2);<br/></span><span class="s1">}</span></pre>
<p>Here, we can see that a lazy list is much like an iterator. In fact, a lazy list could implement the <kbd>Iterator</kbd> trait; then it really would be an iterator. However, iterators are not lazy lists. Lazy lists inherently have an unlimited capacity to look ahead to any number of items. Iterators, on the other hand, optionally, may implement the <kbd>Peekable</kbd> trait permitting one look ahead.</p>
<p>There is a fundamental problem at the core of lazy programming, though. Too much procrastination will never complete any task. If you write a program to launch missiles, at some point in the program, it needs to actually launch missiles. This is an irreversible side-effect of running the program. We don't like side-effects, and lazy programming takes an extreme stance against side- effects. At the same time, we need to accomplish the given task though, and that involves making a choice at some point to push the launch button.</p>
<p>Clearly, we can never fully contain the behavior of programs with side-effects. However, we can make them easier to work with. By wrapping side-effects into lazy evaluated expressions, then turning them into monads, what we create are side-effect units. These units can then be manipulated and composed in a more functional style.</p>
<p>The last lazy pattern that we will introduce is <strong>functional reactive programming</strong>, <strong>FRP</strong> for short. There are entire programming languages, such as Elm, based on this concept. Popular web UI frameworks, such as React or Angular, are also influenced by FRP concepts.</p>
<p>The FRP concept is an extension of the side-effect/state monad example. Event handling, state transitions, and side-effects can be turned into units of reactive programming. Let's define a monad to capture this reactive unit concept:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">struct ReactiveUnit&lt;St,A,B&gt; {<br/></span><span class="s1">   state: Arc&lt;Mutex&lt;St&gt;&gt;,<br/></span><span class="s1">   event_handler: Arc&lt;Fn(&amp;mut St,A) -&gt; B&gt;<br/></span><span class="s1">}<br/><br/></span><span class="s1">impl&lt;St: 'static,A: 'static,B: 'static&gt; ReactiveUnit&lt;St,A,B&gt; {<br/></span><span class="s1">   fn new&lt;F&gt;(st: St, f: F) -&gt; ReactiveUnit&lt;St,A,B&gt;<br/></span><span class="s1">      where F: 'static + Fn(&amp;mut St,A) -&gt; B<br/></span><span class="s1">   {<br/></span><span class="s1">      ReactiveUnit {<br/></span><span class="s1">         state: Arc::new(Mutex::new(st)),<br/></span><span class="s1">         event_handler: Arc::new(f)<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn bind&lt;G,C&gt;(&amp;self, g: G) -&gt; ReactiveUnit&lt;St,A,C&gt;<br/></span><span class="s1">      where G: 'static + Fn(&amp;mut St,B) -&gt; C {<br/></span><span class="s1">      let ev = Arc::clone(&amp;self.event_handler);<br/></span><span class="s1">      ReactiveUnit {<br/></span><span class="s1">         state: Arc::cl</span>one(&amp;self.state),<span class="s1"><br/></span><span class="s1">         event_handler: Arc::new(move |st: &amp;mut St,a| {<br/></span><span class="s1">            let r = ev(st,a);<br/></span><span class="s1">            let r = g(st,r);<br/></span><span class="s1">            r<br/></span><span class="s1">         })<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn plus&lt;St2: 'static,C: 'static&gt;(&amp;self, other: ReactiveUnit&lt;St2,B,C&gt;) -&gt; ReactiveUnit&lt;(Arc&lt;Mutex&lt;St&gt;&gt;,Arc&lt;Mutex&lt;St2&gt;&gt;),A,C&gt; {<br/></span><span class="s1">      let ev1 = Arc::clone(&amp;self.event_handler);<br/></span><span class="s1">      let st1 = Arc::clone(&amp;self.state);<br/></span><span class="s1">      let ev2 = Arc::clone(&amp;other.event_handler);<br/></span><span class="s1">      let st2 = Arc::clone(&amp;other.state);<br/></span><span class="s1">      ReactiveUnit {<br/></span><span class="s1">         state: Arc::new(Mutex::new((st1,st2))),<br/></span><span class="s1">         event_handler: Arc::new(move |stst: &amp;mut (Arc&lt;Mutex&lt;St&gt;&gt;,Arc&lt;Mutex&lt;St2&gt;&gt;),a| {<br/></span><span class="s1">            let mut st1 = stst.0.lock().unwrap();<br/></span><span class="s1">            let r = ev1(&amp;mut st1, a);<br/></span><span class="s1">            let mut st2 = stst.1.lock().unwrap();<br/></span><span class="s1">            let r = ev2(&amp;mut st2, r);<br/></span><span class="s1">            r<br/></span><span class="s1">         })<br/></span><span class="s1">      }<br/></span><span class="s1">   }<br/></span><span class="s1">   fn apply(&amp;self, a: A) -&gt; B {<br/></span><span class="s1">      let mut st = self.state.lock().unwrap();<br/></span><span class="s1">      (self.event_handler)(&amp;mut st, a)<br/></span><span class="s1">   }<br/></span><span class="s1">}</span></pre>
<p>Here, we find that a <kbd>ReactiveUnit</kbd> holds state, can respond to an input, cause side-effects, and return a value. Reactive units can be extended with <kbd>bind</kbd> or concatenated with <kbd>plus</kbd>.</p>
<p>Now, let's make a reactive unit. We will focus on web frameworks since those seem to be popular. First, we render a simple HTML page, as follows:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render1 = ReactiveUnit::new((),|(),()| {<br/></span><span class="s1">   let html = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">         &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;page content&lt;/div&gt;<br/></span><span class="s1">    &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">  ';"###;<br/></span><span class="s1">  html.to_string()<br/></span><span class="s1">});<br/></span><span class="s1">println!("{}", render1.apply(()));</span></pre>
<p>Here, the unit renders a simple page corresponding to <kbd>section 1</kbd> on a website. The unit will always render a whole page and does not consider any state or input. Let's give the unit more responsibilities by telling it to render different content based on which section is active:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render2 = ReactiveUnit::new((),|(),section: usize| {<br/><br/></span><span class="s1">   let section_1 = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">         &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">         &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;section 1 content&lt;/div&gt;<br/></span><span class="s1">      &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">    ';"###;<br/><br/></span><span class="s1">    let section_2 = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">        &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;section 2 content&lt;/div&gt;<br/></span><span class="s1">      &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">    ';"###;<br/><br/></span><span class="s1">    let section_3 = r###"$('body').innerHTML = '<br/></span><span class="s1">      &lt;header&gt;<br/></span><span class="s1">        &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">        &lt;h3 data-section="3" class="active"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">      &lt;/header&gt;<br/></span><span class="s1">      &lt;div&gt;section 3 content&lt;/div&gt;<br/></span><span class="s1">      &lt;footer&gt;Copyright&lt;/footer&gt;<br/></span><span class="s1">   ';"###;<br/><br/></span><span class="s1">   if section==1 {<br/></span><span class="s1">      section_1.to_string()<br/></span><span class="s1">   } else if section==2 {<br/></span><span class="s1">      section_2.to_string()<br/></span><span class="s1">   } else if section==3 {<br/></span><span class="s1">      section_3.to_string()<br/></span><span class="s1">   } else {<br/></span><span class="s1">      panic!("unknown section")<br/></span><span class="s1">   }<br/></span>});<br/><br/><span class="s1">println!("{}", render2.apply(1));<br/></span><span class="s1">println!("{}", render2.apply(2));<br/></span><span class="s1">println!("{}", render2.apply(3));</span></pre>
<p>Here, the unit makes use of the parameter to decide what section should be rendered. This is starting to feel more like a UI framework, but we aren't using the state, yet. Let's try using that to address a common web problem—page tearing. When a large portion of HTML is changed on a web page, the browser must recalculate how the page should be displayed. Most modern browsers do this in stages and the result is an ugly mishmash of components being visibly thrown around the page.</p>
<p>To reduce or prevent page tearing, we should only update portions of the page that have changed. Let's use the state variable along with the input parameter to only send updates when a component has changed:</p>
<pre style="padding-left: 30px"><span class="s1">let render3header = ReactiveUnit::new(None,|opsec: &amp;mut Option&lt;usize&gt;,section: usize| {<br/></span><span class="s1">   let section_1 = r###"$('header').innerHTML = '<br/></span><span class="s1">      &lt;h3 data-section="1" class="active"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_2 = r###"$('header').innerHTML = '<br/></span><span class="s1">      &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_3 = r###"$('header').innerHTML = '<br/></span><span class="s1">      &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="2"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">      &lt;h3 data-section="3" class="active"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let changed = if section==1 {<br/></span><span class="s1">      section_1<br/></span><span class="s1">   } else if section==2 {<br/></span><span class="s1">      section_2<br/></span><span class="s1">   } else if section==3 {<br/></span><span class="s1">      section_3<br/></span><span class="s1">   } else {<br/></span><span class="s1">      panic</span>!("invalid section")<span class="s1"><br/></span><span class="s1">   };<br/></span><span class="s1">   if let Some(sec) = *opsec {<br/></span><span class="s1">      if sec==section { "" }<br/></span><span class="s1">      else {<br/></span><span class="s1">         *opsec = Some(section);<br/></span><span class="s1">         changed<br/></span><span class="s1">      }<br/></span>   } else<span class="s1"> {<br/></span><span class="s1">      *opsec = Some(section);<br/></span><span class="s1">      changed<br/></span><span class="s1">   }<br/></span><span class="s1">});<br/></span></pre>
<p>Here, we issue commands to conditionally render changes to the header. If the header is already in the correct state, then we do nothing. This code only takes responsibility for the header component. We also need to render changes to page content:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render3content = ReactiveUnit::new(None,|opsec: &amp;mut Option&lt;usize&gt;,section: usize| {<br/></span><span class="s1">   let section_1 = r###"$('div#content').innerHTML = '<br/></span><span class="s1">      section 1 content<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_2 = r###"$('div#content').innerHTML = '<br/></span><span class="s1">      section 2 content<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let section_3 = r###"$('div#content').innerHTML = '<br/></span><span class="s1">      section 3 content<br/></span><span class="s1">   ';"###;<br/></span><span class="s1">   let changed = if section==1 {<br/></span><span class="s1">      section_1<br/></span><span class="s1">   } else if section==2 {<br/></span><span class="s1">      section_2<br/></span><span class="s1">   } else if section==3 {<br/></span><span class="s1">      section_3<br/></span><span class="s1">   } else {<br/></span><span class="s1">      panic!("invalid section")<br/></span><span class="s1">   };<br/></span><span class="s1">   if let Some(sec) = *opsec {<br/></span><span class="s1">      if sec==section { "" }<br/></span><span class="s1">      else {<br/></span><span class="s1">         *opsec = Some(section);<br/></span><span class="s1">         changed<br/></span><span class="s1">      }<br/></span>   } else<span class="s1"> {<br/></span><span class="s1">      *opsec = Some(section);<br/></span><span class="s1">      changed<br/></span><span class="s1">   }<br/></span><span class="s1">});</span></pre>
<p>Now, we have a component for the header and another component for the content. We should combine these two into a single unit. FRP libraries would probably have a cool neat way of doing this, but we don't; so instead, we just write a little unit to combine them manually:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let render3 = ReactiveUnit::new((render3header,render3content), |(rheader,rcontent),section: usize| {<br/></span><span class="s1">   let header = rheader.apply(section);<br/></span><span class="s1">   let content = rcontent.apply(section);<br/></span><span class="s1">   format!("{}{}", header, content)<br/></span><span class="s1">});</span></pre>
<p>Now, let's test this out:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">println!("section 1: {}", render3.apply(1));<br/></span><span class="s1">println!("section 2: {}", render3.apply(2));<br/></span><span class="s1">println!("section 2: {}", render3.apply(2));<br/></span><span class="s1">println!("section 3: {}", render3.apply(3));</span></pre>
<p>Each <kbd>apply</kbd> issues appropriate new update commands. The redundant <kbd>apply</kbd> to render <kbd>section 2</kbd> again returns no commands, as intended. This is really lazy code; the good kind of lazy.</p>
<p>What would reactive programming be without event handling? Let's handle a couple of signals and events. On top of the page state, let's introduce some database interaction:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">let database = ("hello world", 5, 2);<br/></span><span class="s1">let react1 = ReactiveUnit::new((database,render3), |(database,render),evt:(&amp;str,&amp;str)| {<br/></span><span class="s1">   match evt {<br/></span><span class="s1">      ("header button click",n) =&gt; render.apply(n.parse::&lt;usize&gt;().unwrap()),<br/></span><span class="s1">      ("text submission",s) =&gt; { database.0 = s; format!("db.textfield1.set(\"{}\")",s) },<br/></span><span class="s1">      ("number 1 submission",n) =&gt; { database.1 += n.parse::&lt;i32&gt;().unwrap(); format!("db.numfield1.set(\"{}\")",database.1) },<br/></span><span class="s1">      ("number 2 submission",n) =&gt; { database.2 += n.parse::&lt;i32&gt;().unwrap(); format!("db.numfield2.set(\"{}\")",database.2) },<br/></span><span class="s1">      _ =&gt; "".to_string()<br/></span><span class="s1">   }<br/></span><span class="s1">});<br/><br/></span><span class="s1">println!("react 1: {}", react1.apply(("header button click","2")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("header button click","2")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("text submission","abc def")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 1 submission","123")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 1 submission","234")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 2 submission","333")));<br/></span><span class="s1">println!("react 1: {}", react1.apply(("number 2 submission","222")));</span></pre>
<p>We define four event types to react to. Responding to page state changes still works as previously defined. Events that should interact with the database issue commands to update the database locally and remotely. A view of the output JavaScript looks like the following:</p>
<pre class="p1" style="padding-left: 30px"><span class="s1">event: ("header button click", "2")<br/>$('header').innerHTML = '<br/></span><span class="s1">   &lt;h3 data-section="1"&gt;Section 1&lt;/h3&gt;<br/></span><span class="s1">   &lt;h3 data-section="2" class="active"&gt;Section 2&lt;/h3&gt;<br/></span><span class="s1">   &lt;h3 data-section="3"&gt;Section 3&lt;/h3&gt;<br/></span><span class="s1">';$('div#content').innerHTML = '<br/></span><span class="s1">   section 2 content<br/></span><span class="s1">';<br/></span><span class="s1"><br/>event: ("header button click", "2")<br/><br/></span><span class="s1">event: ("text submission", "abc def")<br/>db.textfield1.set("abc def")<br/><br/>event: ("number 1 submission", "123")<br/>db.numfield1.set("128")<br/><br/>event: ("number 1 submission", "234")<br/>db.numfield1.set("362")<br/><br/>event: ("number 2 submission", "333")<br/>db.numfield2.set("335")<br/><br/>event: ("number 2 submission", "222")<br/>db.numfield2.set("557")</span></pre>
<p>This correspondence demonstrates how simple side-effect units can be composed to create complex programmatic behavior. This is all built from an FRP library that is less than 50 lines long. Imagine the potential utility of a few more helper functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced many common functional design patterns. We used a lot of scary words, such as functor, monad, and combinator. You should try to remember these words and their meanings. Other scary words, such as contravariant, you can probably forget unless you want to pursue math.</p>
<p>In an applied context, we learned that functors can hide information to expose simple transformations on data. The monad pattern allows us to turn sequential actions into units of computation. Monads can be used to create iterators that also behave more like lists. Laziness can be used to defer computation. Also, these patterns can often be combined in useful ways, such as FRP, which is gaining popularity as a tool to develop user interfaces and other complex interactive programs.</p>
<p>In the next chapter, we will explore concurrency. We will introduce the Rust concepts of thread/data ownership, shared synchronized data, and message passing. Thread-level concurrency is something that Rust was specifically designed for. If you have worked with threads in other languages, then hopefully the next chapter will be encouraging.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is a functor?</li>
<li>What is a contravariant functor?</li>
<li>What is a monad?</li>
<li>What are the monad laws?</li>
<li>What is a combinator?</li>
<li>Why is the <kbd>impl</kbd> keyword necessary for closure return values?</li>
<li>What is lazy evaluation?</li>
</ol>


            </article>

            
        </section>
    </body></html>