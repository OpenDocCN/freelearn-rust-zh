<html><head></head><body>
        

                            
                    <h1 class="header-title">Memory Management in Rust</h1>
                
            
            
                
<p class="mce-root">Until now, we have always talked about how the Rust compiler handles the memory by itself, and how that makes it memory-safe and gives us some extra superpowers without the fear of creating memory vulnerabilities. Nevertheless, there is no limit to what you can accomplish by using unsafe scopes, and even by using safe code.</p>
<p>We will check all the configuration and metaprogramming options that Rust gives us regarding memory management and see how we can improve our code by using both safe and unsafe code.</p>
<p>In this chapter, we will be looking into the following topics:</p>
<ul>
<li>Learning the rules of the borrow checker</li>
<li>Binding lifetimes</li>
<li>Memory representation</li>
<li>Data representation for FFI with C/C++</li>
<li>Shared pointers</li>
<li>Reference counted pointers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Mastering the borrow checker</h1>
                
            
            
                
<p>To ensure memory and thread safety, Rust's borrow checker has three simple rules. They are enforced all through the code except in unsafe scopes. Here they are:</p>
<ul>
<li>Each binding will have an owner</li>
<li>There can only be one owner for a binding</li>
<li>When the owner goes out of the scope, the binding gets dropped</li>
</ul>
<p>These three rules seem simple enough, but they have a great implication on how we code. The compiler can know beforehand when an owner goes out of scope, so it will always know when to drop/destruct a binding/variable. This means that you can write your code without having to think about where you create variables, where you call destructors, or whether you have already called a destructor or you are calling it twice.</p>
<p>Of course, this comes with an additional learning curve that can sometimes be difficult to catch up. The second rule is what most people find difficult to manage. Since there can only be one owner at a time, sharing information sometimes becomes somewhat difficult.</p>
<p>Let's see an example of this behavior with a known type, the <kbd>Vec</kbd> type:</p>
<pre>    let mut my_vector = vec![0, 16, 34, 13, 95];<br/>    my_vector.push(22);<br/>    println!("{:?}", my_vector);</pre>
<p>This will print the following:</p>
<div><img src="img/9e603958-352b-4675-b3e4-635253803fb6.png" style="width:16.75em;height:1.58em;"/></div>
<p>At the end of the current scope (the <kbd>main()</kbd> function, for example), the vector will be dropped by calling its destructor. In this case, it will simply deallocate the memory cleanly and then destroy itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Allocations</h1>
                
            
            
                
<p>For a variable to be growable (so that it can occupy different amounts of space in the memory at different times), it needs to be allocated on the heap, and not on the stack. The stack works faster, since on the loading of the program, it gets assigned to it. But the heap is slower, since for each allocation you need to perform a system call to the kernel, which means you will need a context switch (to kernel mode) and back (to user mode). This makes things too slow.</p>
<p>Vectors (and other standard library structures) have an interesting way of allocating that memory so that they perform as efficiently as possible. Let's check the algorithm it uses to allocate new memory with this code:</p>
<pre>    let mut my_vector = vec![73, 55];<br/>    println!(<br/>        "length: {}, capacity: {}",<br/>        my_vector.len(),<br/>        my_vector.capacity()<br/>    );<br/><br/>    my_vector.push(25);<br/>    println!(<br/>        "length: {}, capacity: {}",<br/>        my_vector.len(),<br/>        my_vector.capacity()<br/>    );<br/><br/>    my_vector.push(33);<br/>    my_vector.push(24);<br/>    println!(<br/>        "length: {}, capacity: {}",<br/>        my_vector.len(),<br/>        my_vector.capacity()<br/>    );</pre>
<p>The output should be something along these lines:</p>
<div><img src="img/ad0089ad-34f2-4d39-80f3-82a12241a276.png" style="width:14.83em;height:3.92em;"/></div>
<p>This means that, at the beginning, the vector will have allocated only the space required by our first two elements. But as soon as we push a new one, it will allocate space for two new elements, so that with the fourth push it won't need to allocate more memory. When we finally insert a fifth element, it allocates space for another four, so that it does not need to allocate until it gets to the ninth.</p>
<p>If you follow the progression, the next time it will allocate space for 8 more elements, making the capacity grow to 16. This is dependent on the first allocation, and if we had started the vector with 3 elements, the numbers would be 3, 6, 12, 24,... We can, in any case, force the vector to pre-allocate a given number of elements with two functions, <kbd>reserve()</kbd> and <kbd>reserve_exact()</kbd>. The former will reserve space for at least the given number of elements, while the latter will reserve space exactly for the given number of elements. This is really useful when you know the size of the input, so that it doesn't need to allocate once and again. It will just allocate once.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mutability, borrowing, and owning</h1>
                
            
            
                
<p>There are also rules about mutability in Rust, that prevent data races between threads. Let's see them:</p>
<ul>
<li>All bindings are immutable by default</li>
<li>There can be unlimited immutable borrows of a binding at the same time</li>
<li>There can only be one mutable borrow of a binding at most at a given point in time</li>
<li>If there is a mutable borrow, no immutable borrows can coexist at a given point in time</li>
</ul>
<p>They are fairly simple to understand. You can read the contents of a binding from as many places as you would like, but if you want to modify a binding, you must somehow ensure that no readers or other writers exist. This, of course, prevents data races, but makes your coding a bit more troublesome.</p>
<p>Let's see this with a couple of examples. Let's first define these two functions:</p>
<pre>fn change_third(slice: &amp;mut [u32]) {<br/>    if let Some(item) = slice.get_mut(2) {<br/>        *item += 1<br/>    }<br/>}<br/><br/>fn print_third(slice: &amp;[u32]) {<br/>    if let Some(item) = slice.get(2) {<br/>        println!("Third element: {}", item);<br/>    }<br/>}</pre>
<p>The <kbd>change_third()</kbd> function requires a mutable <kbd>u32</kbd> slice that will use to add <kbd>1</kbd> to the third element if the slice has at least three elements. The second will print that element. You can then use this <kbd>main()</kbd> function to test it:</p>
<pre>fn main() {<br/>    let mut my_vector = vec![73, 55, 33];<br/>    print_third(&amp;my_vector);<br/>    change_third(&amp;mut my_vector[..]);<br/>    print_third(&amp;my_vector);<br/>}</pre>
<p>As you can see, since the two functions borrow the vector (one of them mutably and the other one immutably), you can continue using the vector in the <kbd>main()</kbd> function. This means that the ownership of the vector is in the <kbd>main()</kbd> function.</p>
<p class="mce-root">If we had a function that took ownership of the vector, we wouldn't be able to use it later. Consider changing the <kbd>change_third()</kbd> function for this one:</p>
<pre>fn change_third(mut slice: Vec&lt;u32&gt;) {<br/>    if let Some(item) = slice.get_mut(2) {<br/>        *item += 1<br/>    }<br/>}</pre>
<p>In this case, the function receives the argument and takes ownership of the vector (there is no slicing or referencing on the function declaration). Of course, we will need to change the call to the function:</p>
<pre>    change_third(my_vector);</pre>
<p>The issue is that the program will no longer compile. After we give the ownership of the vector to the <kbd>change_third()</kbd> function, there will no longer be a <kbd>my_vector</kbd> variable in the <kbd>main()</kbd> function. The error that the Rust compiler shows is really clarifying, and it will even point out where the issue is:</p>
<div><img src="img/95d20d42-bcaf-4713-bf81-18b287cbd42c.png"/></div>
<p>In conclusion, if you need to continue using the variable after using it to call a function, pass it by reference, let the function borrow your variable but not own it. If you don't, and you prefer the new function to have absolute control over the variable (even to drop it), pass it by value. This doesn't apply to <kbd>Copy</kbd> types, as we saw in <a href="ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml" target="_blank">Chapter 1</a>, <em>Common Performance Pitfalls</em>, since, in that case, the whole object gets copied to the new function.</p>
<p>References can be a little difficult to manage though. We sometimes require a structure to have a referenced value, but since the structure won't have ownership of the variable to drop it, it will have to make sure that the owner of the variable doesn't do it while it is still in use. For this, we have lifetimes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lifetimes</h1>
                
            
            
                
<p>Every variable, structure attribute, and constant has a lifetime in Rust. Most of them can be elided, since we usually know that a constant has a static lifetime (it will always be there for us), or that most of the variables have the lifetime of its scope. Nevertheless, there is sometimes a place where we need to specify that lifetime. Let's check the following structures:</p>
<pre>struct Parent&lt;'p&gt; {<br/>    age: u8,<br/>    child: Option&lt;&amp;'p Child&gt;,<br/>}<br/><br/>struct Child {<br/>    age: u8,<br/>}</pre>
<p class="mce-root">As you can see, the parent has a reference to the child, but we added two letters preceded by a single quote. These are lifetime specifications, and what means is that the reference to the child has to live at least while the parent exists. Let's see this behavior with a simple <kbd>main()</kbd> function:</p>
<pre>fn main() {<br/>    let child = Child { age: 10 };<br/>    let parent = Parent {<br/>        age: 35,<br/>        child: Some(&amp;child),<br/>    };<br/><br/>    println!("Child's age: {} years.", parent.child.unwrap().age);<br/>}</pre>
<p>This will print that the child is <kbd>10</kbd> years old. The child gets dropped at the end of the <kbd>main</kbd> function, so the reference is valid while the parent exists. But let's create a small inner scope to see if we can trick the compiler. Inner scopes are explicit scopes that you can create by using curly braces. All variables defined in there will be dropped at the end of the inner scope, and if an expression is added at the end without a semicolon, it will be the value of the scope, and can be assigned to any variable.</p>
<p>Let's try to add a <kbd>child</kbd> to a <kbd>parent</kbd> that will be dropped at an inner scope:</p>
<pre>    let mut parent = Parent {<br/>        age: 35,<br/>        child: None,<br/>    };<br/><br/>    {<br/>        let child = Child { age: 10 };<br/>        parent.child = Some(&amp;child);<br/>    }<br/><br/>    println!("Child's age: {} years.", parent.child.unwrap().age);</pre>
<p>If we try to compile this, the compiler will tell us that <kbd>child</kbd> does not live long enough. The compiler has understood that we told it in the structure that <kbd>child</kbd> had to live at least as long as the <kbd>Parent</kbd> structure, and since, in this case, it knows that the variable defined inside the inner scope will be dropped there, it will complain at compile time and not let you add it to the <kbd>parent</kbd>.</p>
<p class="mce-root">This can be extended to functions. Let's consider a very simple function that returns a reference to the oldest child of the two provided:</p>
<pre>fn oldest_child(child1: &amp;Child, child2: &amp;Child) -&gt; &amp;Child {<br/>    if child1.age &gt; child2.age {<br/>        child1<br/>    } else {<br/>        child2<br/>    }<br/>}</pre>
<p>This will not compile, since it needs a lifetime parameter. This means that the compiler does not know whether the return child will live as long as <kbd>child1</kbd> or as long as <kbd>child2</kbd>. We don't know either, so we will specify that all lifetimes must be at least as long as the current function, and then the rest is the problem of our caller:</p>
<pre>fn oldest_child&lt;'f&gt;(child1: &amp;'f Child, child2: &amp;'f Child) -&gt; &amp;'f Child {<br/>    if child1.age &gt; child2.age {<br/>        child1<br/>    } else {<br/>        child2<br/>    }<br/>}</pre>
<p>This just declares a new lifetime (declared before the first parenthesis before the arguments) that we call <kbd>f</kbd>, that will be the lifetime of the function. We then specify that all references must live at least as long as the function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Memory representation</h1>
                
            
            
                
<p>Apart from managing the references, ownerships, allocations, and copies, we can also manage the memory layout of those structures we saw earlier, and we can do it by using both safe and unsafe code. Let's first understand how Rust manages the memory. Think of the following structure:</p>
<pre>struct Complex {<br/>    attr1: u8,<br/>    attr2: u16,<br/>    attr3: u8,<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Alignment</h1>
                
            
            
                
<p class="mce-root">When accessing the attributes from memory, they need to be aligned so that their position in memory is a multiple of their size, 16 bits in this case. That way, when we try to get each attribute, we will only need to add 16 bits to the base address of the structure, multiplied by the attribute. This makes information retrieval much more efficient, and it's done by the compiler automatically. The main issue with it is that for each attribute to be 16-bit aligned, the compiler would need to pad 8 bits for each of the first and third attributes.</p>
<p>This means that the structure gets converted to the following:</p>
<pre>struct Complex {<br/>    attr1: u8,<br/>    _pad1: u8,<br/>    attr2: u16,<br/>    attr3: u8,<br/>    _pad2: u8,<br/>}</pre>
<p>But, in this concrete case, both <kbd>attr1</kbd> and <kbd>attr3</kbd> have 8 bits, so they do not need to be 16-bit aligned; they could be 8-bit aligned and work properly. This means that we could move the first attribute to the end and, that way, it would be something like having two 16-bit aligned attributes, and the second one would contain two 8-bit aligned attributes:</p>
<pre>struct Complex {<br/>    attr2: u16,<br/>    attr1: u8,<br/>    attr3: u8,<br/>}</pre>
<p>This does not require extra padding and thus the structure will occupy 32 bits (instead of 48 as before). This is a typical optimization that has to be done manually in C/C++, messing up our order of attributes, but in Rust we can do better. The compiler knows about this, and it will reorder the fields the best it can to have a better memory footprint, so you can put the attributes in the order you'd like.</p>
<p>But, if the compiler already does this automatically, what is this doing in a performance optimization book? Well, there is a situation where you want to avoid this behavior.</p>
<p>Let's face it, not all of the software is written in Rust yet, and in the case of high-performance libraries, it's common that we have to use C dependencies. Luckily, Rust can seamlessly integrate with any C-compatible interface at no cost. But you will have a problem if you move structures between the Rust and C codes.</p>
<p>As we discussed, Rust will reorder the fields, which means that the structure in C and in Rust might not have attributes positioned the same way. We can tell Rust not to change the order of the fields, though, by using the <kbd>repr</kbd> attribute with the <kbd>C</kbd> value:</p>
<pre>#[repr(C)]<br/>struct Complex {<br/>    attr3: u8,<br/>    attr2: u16,<br/>    attr1: u8,<br/>}</pre>
<p>This will make the structure compatible with C. We can also tell Rust not to add padding to attributes, and therefore make the structure minimal size even if its alignment could be better. Note that this will break the code for platforms that require aligned structures. If you still want to use it, you can simply use the <kbd>packed</kbd> form of representation:</p>
<pre>#[repr(packed)]<br/>struct Complex {<br/>    attr3: u8,<br/>    attr2: u16,<br/>    attr1: u8,<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Complex enumerations</h1>
                
            
            
                
<p>If you know about C/C++ enumerations, you know that each element represents a value, and that you can use them to avoid remembering the proper integers from the set of possible values. They are not strongly typed, though, so you can mix different enumerations. And they can only store one integer.</p>
<p>Once again, Rust can do better, and we can create complex enumerations where we cannot only have strong typing (we won't mix enumerations) but we will even be able to have more than integers in enumerations. As you can see in the following <kbd>Color</kbd> enumeration, we can have inner data, and even attributes:</p>
<pre>enum Color {<br/>    Red,<br/>    Blue,<br/>    Green,<br/>    Other { r: u32, g: u32, b: u32 },<br/>}</pre>
<p>As you can see, in this case, the enumeration can have one of four values, but in the case of the last one, it will have three numbers associated. This gives you almost infinite possibilities, where you can safely represent any data structure. Check out, for instance, this implementation of <em>any JSON value</em> by the <kbd>Serde</kbd> crate, one of the most-used crates in the ecosystem:</p>
<pre>pub enum Value {<br/>    Null,<br/>    Bool(bool),<br/>    Number(Number),<br/>    String(String),<br/>    Array(Vec&lt;Value&gt;),<br/>    Object(Map&lt;String, Value&gt;),<br/>}</pre>
<p>A value in a JSON structure can either be null, a Boolean (and with the information whether it's <kbd>true</kbd> or <kbd>false</kbd>), a number (that will be another enumeration to know whether it's positive, negative, or float point), a string, with the text information, an array of values, or a whole JSON object with its keys as strings and values.</p>
<p>There are two caveats with this approach, though. For comparison between the different variants of an enumeration, they must be tagged. This means that they will need to occupy some extra space just to differentiate between them at runtime.</p>
<p>The second problem is that the size of the enumeration type (without taking into account the tag) will be the size of the biggest option. So if you have 10 options that can be stored in 1 byte, but another one needs 10 bytes, the enumeration will have 10 bytes (plus the tag) independently of the variant being stored. This works this way because it works as a <kbd>union</kbd> (in C/C++ language), where all variants share the same representation.</p>
<p>To mitigate this, an option is for big objects to be references. We can do this in two ways. The first way is by borrowing the color, in which case the compiler will force us to not return the enumeration from any function where the color was created (remember, the reference would be destroyed at the end of the scope):</p>
<pre>enum Color&lt;'c&gt; {<br/>    Red,<br/>    Blue,<br/>    Green,<br/>    Other(&amp;'c Rgb),<br/>}<br/><br/>struct Rgb {<br/>    r: u32,<br/>    g: u32,<br/>    b: u32,<br/>}</pre>
<p>And if we want to avoid that, we can simply store that element in the heap by boxing it (yes, this will slow performance). It depends whether you require a lower RAM consumption or an improved speed. To store an element in the heap, you will need to use the <kbd>Box</kbd> type, as you can see here:</p>
<pre>enum Color {<br/>    Red,<br/>    Blue,<br/>    Green,<br/>    Other(Box&lt;Rgb&gt;),<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Unions</h1>
                
            
            
                
<p class="mce-root">There is also another type of union that is not tagged. If the types in the union are not <kbd>Copy</kbd>, you will need to use the <kbd>untagged_unions</kbd> feature and compile the code with the nightly compiler. This can be avoided by deriving the <kbd>Copy</kbd> trait in the structures used inside the union, but you shouldn't do this for big structures, as we discussed earlier:</p>
<pre>union Plant {<br/>    g: Geranium,<br/>    c: Carnation,<br/>}<br/><br/>#[derive(Copy, Clone)]<br/>struct Geranium {<br/>    height: u32,<br/>}<br/><br/>#[derive(Copy, Clone)]<br/>struct Carnation {<br/>    flowers: u8,<br/>}</pre>
<p>In this particular example, the <kbd>Plant</kbd> can be a <kbd>Geranium</kbd> or a <kbd>Carnation</kbd>. Or more precisely, it will be both at the same time. The <kbd>Plant</kbd> will have the size of the biggest structure in it, and it won't have any extra padding for a tag describing which of the two variants it is.</p>
<p>This means that when writing one of the fields of the union, you will change the rest of the fields too. When creating the union, you will need to specify only one field, and since the compiler won't know which variant it is at compile time, you will need to read the values using an unsafe block, as you can see in the next piece of code, since reading an unset value ends up being undefined behavior:</p>
<pre>fn main() {<br/>    let mut my_plant = Plant {<br/>        c: Carnation { flowers: 15 },<br/>    };<br/>    my_plant.g = Geranium { height: 300 };<br/>    let height = unsafe { my_plant.g }.height;<br/><br/>    println!("Height: {}", height);<br/>}</pre>
<p>In this example, we first create a <kbd>Plant</kbd> that is a <kbd>Carnation</kbd>, and then we convert it to a <kbd>Geranium</kbd>. That change does not need an unsafe block, since the <kbd>Plant</kbd> will always have 32 bits, the size of the <kbd>Geranium</kbd>, so it can be assigned with perfect memory safety.</p>
<p>When we retrieve the height, though, we need to specify that we want to read the <kbd>Plant</kbd> as a <kbd>Geranium</kbd>, and then get the height. In this case, it works perfectly, since we changed the <kbd>Plant</kbd> to be a <kbd>Geranium</kbd>. If we tried to get the plant as a <kbd>Carnation</kbd> in this example, it would trigger undefined behavior. This means that the number of flowers can be a random number depending on the layout of the union. Still, this is not a security vulnerability, since the <kbd>u8</kbd> we will get for the number of flowers will be one of the bytes of the <kbd>Geranium</kbd> height, it will just feel random (in my case, it says 44 flowers).</p>
<p>But in any case, this is particularly great for interfacing with C (FFI). If we use the <kbd>#[repr(C)]</kbd> attribute in the union, it will be structured exactly the same way as in C, so we will be able to send the union to a C library without needing to think about how to emulate a C union.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shared pointers</h1>
                
            
            
                
<p class="mce-root">One of Rust's most criticized problems is that it's difficult to develop an application with shared pointers. As we have seen before, it's true that due to Rust's memory safety guarantees, it might be difficult to develop those kinds of algorithms, but as we will see now, the standard library gives us some types we can use to safely allow that behavior.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The cell module</h1>
                
            
            
                
<p>The standard library has one interesting module, the <kbd>std::cell</kbd> module, that allows us to use objects with interior mutability. This means that we can have an immutable object and still mutate it by getting a mutable borrow to the underlying data. This, of course, would not comply with the mutability rules we saw before, but the cells make sure this works by checking the borrows at runtime or by doing copies of the underlying data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cells</h1>
                
            
            
                
<p>Let's start with the basic <kbd>Cell</kbd> structure. A <kbd>Cell</kbd> will contain a mutable value, but it can be mutated without having a mutable <kbd>Cell</kbd>. It has mainly three interesting methods: <kbd>set()</kbd>, <kbd>swap()</kbd>, and <kbd>replace()</kbd>. The first allows us to set the contained value, replacing it with a new value. The previous structure will be dropped (the destructor will run). That last bit is the only difference with the <kbd>replace()</kbd> method. In the <kbd>replace()</kbd> method, instead of dropping the previous value, it will be returned. The <kbd>swap()</kbd> method, on the other hand, will take another <kbd>Cell</kbd> and swap the values between the two. All this without the <kbd>Cell</kbd> needing to be mutable. Let's see it with an example:</p>
<pre>use std::cell::Cell;<br/><br/>#[derive(Copy, Clone)]<br/>struct House {<br/>    bedrooms: u8,<br/>}<br/><br/>impl Default for House {<br/>    fn default() -&gt; Self {<br/>        House { bedrooms: 1 }<br/>    }<br/>}<br/><br/>fn main() {<br/>    let my_house = House { bedrooms: 2 };<br/>    let my_dream_house = House { bedrooms: 5 };<br/><br/>    let my_cell = Cell::new(my_house);<br/>    println!("My house has {} bedrooms.", my_cell.get().bedrooms);<br/><br/>    my_cell.set(my_dream_house);<br/>    println!("My new house has {} bedrooms.", my_cell.get().bedrooms);<br/><br/>    let my_new_old_house = my_cell.replace(my_house);<br/>    println!(<br/>        "My house has {} bedrooms, it was better with {}",<br/>        my_cell.get().bedrooms,<br/>        my_new_old_house.bedrooms<br/>    );<br/><br/>    let my_new_cell = Cell::new(my_dream_house);<br/><br/>    my_cell.swap(&amp;my_new_cell);<br/>    println!(<br/>        "Yay! my current house has {} bedrooms! (my new house {})",<br/>        my_cell.get().bedrooms,<br/>        my_new_cell.get().bedrooms<br/>    );<br/><br/>    let my_final_house = my_cell.take();<br/>    println!(<br/>        "My final house has {} bedrooms, the shared one {}",<br/>        my_final_house.bedrooms,<br/>        my_cell.get().bedrooms<br/>    );<br/>}</pre>
<p>As you can see in the example, to use a <kbd>Cell</kbd>, the contained type must be <kbd>Copy</kbd>. If the contained type is not <kbd>Copy</kbd>, you will need to use a <kbd>RefCell</kbd>, which we will see next. Continuing with this <kbd>Cell</kbd> example, as you can see through the code, the output will be the following:</p>
<div><img src="img/a6ec229b-d16d-47f1-8d9a-9ae73cdc5b26.png" style="width:33.17em;height:6.08em;"/></div>
<p>So we first create two houses, we select one of them as the current one, and we keep mutating the current and the new ones. As you might have seen, I also used the <kbd>take()</kbd> method, only available for types implementing the <kbd>Default</kbd> trait. This method will return the current value, replacing it with the default value. As you can see, you don't really mutate the value inside, but you replace it with another value. You can either retrieve the old value or lose it. Also, when using the <kbd>get()</kbd> method, you get a copy of the current value, and not a reference to it. That's why you can only use elements implementing <kbd>Copy</kbd> with a <kbd>Cell</kbd>. This also means that a <kbd>Cell</kbd> does not need to dynamically check borrows at runtime.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RefCell</h1>
                
            
            
                
<p class="mce-root"><kbd>RefCell</kbd> is similar to <kbd>Cell</kbd>, except that it accepts non-<kbd>Copy</kbd> data. This also means that when modifying the underlying object, it cannot simply copy it when returning it, it will need to return references. The same way, when you want to mutate the object inside, it will return a mutable reference. This only works because it will dynamically check at runtime whether a borrow exists before returning a mutable borrow, or the other way around, and if it does, the thread will panic.</p>
<p>Instead of using the <kbd>get()</kbd> method as in <kbd>Cell</kbd>, <kbd>RefCell</kbd> has two methods to get the underlying data: <kbd>borrow()</kbd> and <kbd>borrow_mut()</kbd>. The first will get a read-only borrow, and you can have as many immutable borrows in a scope. The second one will return a read-write borrow, and you will only be able to have one in scope to follow the mutability rules. If you try to do a <kbd>borrow_mut()</kbd> after a <kbd>borrow()</kbd> in the same scope, or a <kbd>borrow()</kbd> after a <kbd>borrow_mut()</kbd>, the thread will panic.</p>
<p>There are two non-panicking alternatives to these borrows: <kbd>try_borrow()</kbd> and <kbd>try_borrow_mut()</kbd>. These two will try to borrow the data (the first read-only and the second read/write), and if there are incompatible borrows present, they will return a <kbd>Result::Err</kbd>, so that you can handle the error without panicking.</p>
<p class="mce-root CDPAlignLeft CDPAlign">Both <kbd>Cell</kbd> and <kbd>RefCell</kbd> have a <kbd>get_mut()</kbd> method, that will get a mutable reference to the element inside, but it requires the <kbd>Cell</kbd> / <kbd>RefCell</kbd> to be mutable, so it doesn't make much sense if you need the <kbd>Cell</kbd> / <kbd>RefCell</kbd> to be immutable. Nevertheless, if in a part of the code you can actually have a mutable <kbd>Cell</kbd> / <kbd>RefCell</kbd>, you should use this method to change the contents, since it will check all rules statically at compile time, without runtime overhead.</p>
<p class="mce-root CDPAlignLeft CDPAlign">Interestingly enough, <kbd>RefCell</kbd> does not return a plain reference to the underlying data when we call <kbd>borrow()</kbd> or <kbd>borrow_mut()</kbd>. You would expect them to return <kbd>&amp;T</kbd> and <kbd>&amp;mut T</kbd> (where <kbd>T</kbd> is the wrapped element). Instead, they will return a <kbd>Ref</kbd> and a <kbd>RefMut</kbd>, respectively. This is to safely wrap the reference inside, so that the lifetimes get correctly calculated by the compiler without requiring references to live for the whole lifetime of the <kbd>RefCell</kbd>. They implement <kbd>Deref</kbd> into references, though, so thanks to Rust's <kbd>Deref</kbd> coercion, you can use them as references.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The rc module</h1>
                
            
            
                
<p>The <kbd>std::rc</kbd> module contains reference-counted pointers that can be used in single-threaded applications. They have very little overhead, thanks to counters not being atomic counters, but this means that using them in multithreaded applications could cause data races. Thus, Rust will stop you from sending them between threads at compile time. There are two structures in this module: <kbd>Rc</kbd> and <kbd>Weak</kbd>.</p>
<p>An <kbd>Rc</kbd> is an owning pointer to the heap. This means that it's the same as a <kbd>Box</kbd>, except that it allows for reference-counted pointers. When the <kbd>Rc</kbd> goes out of scope, it will decrease by <kbd>1</kbd> the number of references, and if that count is <kbd>0</kbd>, it will drop the contained object.</p>
<p>Since an <kbd>Rc</kbd> is a shared reference, it cannot be mutated, but a common pattern is to use a <kbd>Cell</kbd> or a <kbd>RefCell</kbd> inside the <kbd>Rc</kbd> to allow for interior mutability.</p>
<p><kbd>Rc</kbd> can be downgraded to a <kbd>Weak</kbd> pointer, that will have a borrowed reference to the heap. When an <kbd>Rc</kbd> drops the value inside, it will not check whether there are <kbd>Weak</kbd> pointers to it. This means that a <kbd>Weak</kbd> pointer will not always have a valid reference, and therefore, for safety reasons, the only way to check the value of the <kbd>Weak</kbd> pointer is to upgrade it to an <kbd>Rc</kbd>, which could fail. The <kbd>upgrade()</kbd> method will return <kbd>None</kbd> if the reference has been dropped.</p>
<p>Let's check all this by creating an example binary tree structure:</p>
<pre>use std::cell::RefCell;<br/>use std::rc::{Rc, Weak};<br/><br/>struct Tree&lt;T&gt; {<br/>    root: Node&lt;T&gt;,<br/>}<br/><br/>struct Node&lt;T&gt; {<br/>    parent: Option&lt;Weak&lt;Node&lt;T&gt;&gt;&gt;,<br/>    left: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,<br/>    right: Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;,<br/>    value: T,<br/>}</pre>
<p>In this case, the tree will have a root node, and each of the nodes can have up to two children. We call them left and right, because they are usually represented as trees with one child on each side. Each node has a pointer to one of the children, and it owns the children nodes. This means that when a node loses all references, it will be dropped, and with it, its children.</p>
<p>Each child has a pointer to its parent. The main issue with this is that, if the child has an <kbd>Rc</kbd> pointer to its parent, it will never drop. This is a circular dependency, and to avoid it, the pointer to the parent will be a <kbd>Weak</kbd> pointer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you have learned how the borrow checker works. You now understand the rules that your code must follow to compile, and how little tricks can make your code much faster without having to worry about making the compiler happy.</p>
<p>You also learned about the memory representation of structures and enumerations in Rust and how to make your Rust code compatible with the C/C++.</p>
<p>Finally, you understood how Rust manages shared pointers for complex structures where the Rust borrow checker can make your coding experience much more difficult.</p>
<p>In <a href="0a00a575-c592-4022-8721-79c2f2d63f76.xhtml" target="_blank">Chapter 4</a>, <em>Lints and Clippy</em>, we will learn about linting and a surprisingly good linting tool called <strong>Clippy</strong>. With these lints, you will be able to find many of the issues we saw at compile time.</p>


            

            
        
    </body></html>