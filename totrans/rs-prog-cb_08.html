<html><head></head><body><div><h1 class="header-title">Safe Programming for the Web</h1>
                
            
            
                
<p>Ever since the popular Rails framework for the Ruby programming language, creating backend web services seemed like a domain for dynamically typed languages. This trend was only reinforced by the rise of Python and JavaScript as primary languages for these tasks. After all, the nature of these technologies made creating these services especially fast and changes to services (for example, a new field in the JSON response) are simple to do. Returning to static types for web services feels strange for many of us; after all, it takes a lot longer to get <em>something</em> going. </p>
<p>However, there is a cost to these: many services are deployed in the cloud nowadays, which means that a pay-as-you-go model is employed together with (practically) infinite scalability. Since—most notably—Python is not known for its execution speed, we can now see the cost of this overhead on the bill from the cloud provider. A 10% faster execution time can mean serving 10% more customers on the same hardware at the same level of quality (for example, response time). Similarly, smaller devices benefit from lower resource usage, which translates into faster software and therefore less energy consumed. Rust, as a systems programming language, was built with zero overhead in mind and is a close rival to C in many aspects such as speed or efficiency. It is therefore not unreasonable for heavily used web services to write critical parts in Rust, a move that has famously been made by Dropbox to improve its service quality and save costs. </p>
<p>Rust is a great language for the web and, in this chapter, we are looking at creating a regular RESTful API using a framework that is in use at many different applications and developed at Microsoft. You can look forward to learning about the following:</p>
<ul>
<li>Setting up a web server</li>
<li>Designing a RESTful API</li>
<li>Handling JSON payloads</li>
<li>Web error handling</li>
<li>Rendering HTML templates</li>
<li>Using an ORM to save data to a database</li>
<li>Running advanced queries using an ORM</li>
<li>Authentication on the web</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Setting up a web server</h1>
                
            
            
                
<p>Over the last few years, web servers have changed. Where early web applications have been deployed behind some sort of web server application such as Apache Tomcat (<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a>), IIS (<a href="https://www.iis.net/">https://www.iis.net/</a>), and nginx (<a href="https://www.nginx.com/">https://www.nginx.com/</a>), it is now more common to embed the serving part into the application as well. Not only is this easier on the Ops people, it also allows developers to have tight control over the entire application. Let's see how we can get started and set up a basic static web server. </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's set up a Rust binary project using <kbd>cargo new static-web</kbd>. Since we are going to serve stuff on local port <kbd>8081</kbd>, make sure that the port is accessible as well. Inside the newly created project folder, we need an additional folder, <kbd>static/</kbd>, where you can put an interesting <kbd>.jpg</kbd> image and serve it. We are going to assume that this image is called <kbd>foxes.jpg</kbd>. </p>
<p>Finally, open the entire directory with VS Code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We are going to set up and run our own web server in just a few steps:</p>
<ol>
<li class="mce-root">Open <kbd>src/main.rs</kbd> first, and let's add some code. We will work our way down to the <kbd>main</kbd> function, starting with imports and a simple index handler:</li>
</ol>
<pre style="color: black;padding-left: 60px">#[macro_use]<br/>extern crate actix_web;<br/><br/>use actix_web::{web, App, middleware, HttpServer, Responder, Result};<br/>use std::{env};<br/>use actix_files as fs;<br/><br/><br/>fn index() -&gt; Result&lt;fs::NamedFile&gt; {<br/>    Ok(fs::NamedFile::open("static/index.html")?)<br/>}</pre>
<ol start="2">
<li>This is not going to be the only request handler, however, so let's add a few more to see how request-handling works:</li>
</ol>
<pre style="padding-left: 60px">fn path_parser(info: web::Path&lt;(String, i32)&gt;) -&gt; impl Responder {<br/>    format!("You tried to reach '{}/{}'", info.0, info.1)<br/>}<br/><br/>fn rust_cookbook() -&gt; impl Responder {<br/>    format!("Welcome to the Rust Cookbook")<br/>}<br/><br/>#[get("/foxes")]<br/>fn foxes() -&gt; Result&lt;fs::NamedFile&gt; {<br/>    Ok(fs::NamedFile::open("static/foxes.jpg")?)<br/>}</pre>
<ol start="3">
<li>What's missing is the <kbd>main</kbd> function. This <kbd>main</kbd> function starts the server and attaches the services we created in the previous step:</li>
</ol>
<pre style="padding-left: 60px">fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(<br/>        || App::new()<br/>            .wrap(middleware::Logger::default())<br/>            .service(foxes)<br/>            .service(web::resource("/").to(index))<br/>            .service(web::resource("/welcome").to(rust_cookbook))  <br/>            .service(web::resource("/{path}/{id}").to(path_parser)))<br/>        .bind("127.0.0.1:8081")?<br/>        .run()<br/>}</pre>
<ol start="4">
<li>In the first handler, we mention a static <kbd>index.html</kbd> handle, which we haven't yet created. Add a simple <kbd>marquee</kbd> output to a new file and save it as <kbd>static/index.html</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;html&gt;<br/>    &lt;body&gt;<br/>        &lt;marquee&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/marquee&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<ol start="5">
<li>One important thing that we are still need to do is adjust <kbd>Cargo.toml</kbd>. Declare the dependencies in <kbd>Cargo.toml</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>actix-web = "1"<br/>env_logger = "0.6"<br/>actix-files = "0"</pre>
<ol start="6">
<li>Use a Terminal to execute <kbd>cargo run</kbd> and run the code, then open a browser window at <kbd>http://localhost:8081/</kbd>, <kbd>http://localhost:8081/welcome</kbd>, <kbd>http://localhost:8081/foxes</kbd>, and <kbd>http://localhost:8081/somethingarbitrary/10</kbd>:</li>
</ol>
<pre style="padding-left: 60px">$ <strong>cargo run</strong><br/>   Compiling autocfg v0.1.4<br/>   Compiling semver-parser v0.7.0<br/>   Compiling libc v0.2.59<br/>[...]<br/>   Compiling static-web v0.1.0 (Rust-Cookbook/Chapter08/static-web)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 1m 51s<br/>     Running `target/debug/static-web`</pre>
<p style="padding-left: 60px">Here is the output for <kbd>http://localhost:8081</kbd>, handled by the <kbd>index</kbd> function:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7d7d636-1c6d-4374-9972-f8b2bcb88743.png" style="width:39.58em;height:26.00em;"/></p>
<p style="padding-left: 60px">You can also call the welcome handler at <kbd>http://localhost:8081/welcome</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fd5b036f-2750-4554-a671-803761ba3eb0.png" style="width:35.33em;height:23.42em;"/></p>
<p style="padding-left: 60px">Our static handler returns a photo of the Mozilla office in Berlin at <kbd>http://localhost:8081/foxes</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a78dedb7-20a5-4320-ba71-134a7ac1947c.png" style="width:36.33em;height:24.00em;"/></p>
<p style="padding-left: 60px">Lastly, we added a path handler that parses a string and an integer from the path, only to return the values:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/dd845229-2c6e-468d-a19a-3ec92867e03d.png" style="width:40.00em;height:26.58em;"/></p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">To verify the requests were actually handled by our web server, you should view the individual requests in the log output of the Terminal running <kbd>cargo run</kbd>:</p>
<pre style="padding-left: 60px">[...]<br/>    Finished dev [unoptimized + debuginfo] target(s) in 1m 51s<br/>     Running `target/debug/static-web`<br/>[2019-07-17T06:20:27Z INFO actix_web::middleware::logger] 127.0.0.1:35358 "GET / HTTP/1.1" 200 89 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" 0.004907<br/>[2019-07-17T06:21:58Z INFO actix_web::middleware::logger] 127.0.0.1:36154 "GET /welcome HTTP/1.1" 200 28 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" 0.000844<br/>^[[B[2019-07-17T06:22:34Z INFO actix_web::middleware::logger] 127.0.0.1:36476 "GET /somethingarbitrary/10 HTTP/1.1" 200 42 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" 0.000804<br/>[2019-07-17T06:24:22Z INFO actix_web::middleware::logger] 127.0.0.1:37424 "GET /foxes HTTP/1.1" 200 1416043 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" 0.010263</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>actix-web</kbd> (<a href="https://actix.rs">https://actix.rs</a>) is a versatile web framework and it—among other things—efficiently serves static files as well. In this recipe, we covered how to declare and register request handlers, as well as some ways to provide responses. In a typical web framework, there are several ways to achieve these tasks (declaring handlers, creating responses) and <em>steps 1 </em>to <em>3</em> show two ways to do this with <kbd>actix-web</kbd>:</p>
<ul>
<li>Using an attribute (<kbd>#[get("/foxes")]</kbd>)</li>
<li>Via the service registration call (<kbd>.service(web::resource("/welcome").to(rust_cookbook)</kbd>)</li>
</ul>
<p>Regardless of the way we associate a handler with a route, each of them is wrapped into a factory that creates new handler instances on demand, which is very visible when a compiler error points to the <kbd>#[get(...)]</kbd> attribute instead of the actual function. The paths include typed placeholders for passing data from the path into the handler function—but more on that in the next recipe (<em>Designing a RESTful API</em>).</p>
<p>In <em>step 3</em>, we also add logging middleware that logs the user agent, time, and IP address so we can see requests also on the server side. All of this is done using <kbd>actix-web</kbd> method chaining, which structures the calls nicely. The call to <kbd>run()</kbd> blocks the application and starts the actix main loop. </p>
<p>The photo in <em>step 6</em> was taken in Mozilla's Berlin office during Rust All Hands 2019. Yes, those are Firefox pillows.</p>
<p><em>Step 4</em> adds a very basic <kbd>index.html</kbd> file to be served, while <em>step 5</em> declares the dependencies in <kbd>Cargo.toml</kbd> as we have done before.</p>
<p>In the last step, we are running the code and showing the output—both in the browser and the logging. </p>
<p>We've successfully learned the basics of setting up a web server. Equipped with this knowledge of serving static files and images, as well as parsed path parameters, we can move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Designing a RESTful API</h1>
                
            
            
                
<p>Almost everything relies on web resources—from a single page application that dynamically fetches data via JavaScript and displays it in HTML to the app integration for a particular service. A resource on a web service can be anything but it's typically expressed using readable URIs so information is already transferred by using a specific path, which then only accepts the required information it needs to process. This allows structuring code internally and globally utilizes all <kbd>HTTP</kbd> methods to create an expressive interface that developers can use. RESTful APIs (<a href="https://www.codecademy.com/articles/what-is-rest">https://www.codecademy.com/articles/what-is-rest</a>) ideally capture all of these benefits.</p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's set up a Rust binary project using <kbd>cargo new api</kbd>. Since we are going to serve stuff on local port <kbd>8081</kbd>, make sure that the port is accessible as well. Inside the newly created project folder, we need an additional <kbd>static/</kbd> folder, where you can put an interesting <kbd>.jpg</kbd> image to serve. Additionally, make sure that there is a program such as <kbd>curl</kbd> (<a href="https://curl.haxx.se/">https://curl.haxx.se/</a>) available on your command line. Alternatively, Postman (<a href="https://www.getpostman.com/">https://www.getpostman.com/</a>) is a tool that does the same thing with a graphical interface.</p>
<p>Finally, open the entire directory with VS Code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's build an API with a few steps:</p>
<ol>
<li>Open <kbd>src/main.rs</kbd> to add the primary code for the server and handling requests. Let's go step by step and start with the imports:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate actix_web;<br/><br/>use actix_files as fs;<br/>use actix_web::{ guard,<br/>    http::header, http::Method, middleware, web, App, HttpRequest, HttpResponse, HttpServer,<br/>    Responder, Result,<br/>};<br/>use std::env;<br/>use std::path::PathBuf;</pre>
<ol start="2">
<li>Next, we are defining a few handlers that take requests and use that data somehow. Add these lines to <kbd>main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#[get("by-id/{id}")]<br/>fn bookmark_by_id(id: web::Path&lt;(i32)&gt;) -&gt; impl Responder {<br/>    format!("{{ \"id\": {}, \"url\": \"https://blog.x5ff.xyz\" }}", id)<br/>}<br/><br/>fn echo_bookmark(req: HttpRequest) -&gt; impl Responder {<br/>    let id: i32 = req.match_info().query("id").parse().unwrap();<br/>    format!("{:?}", id)<br/>}<br/><br/>#[get("/captures/{tail:.*}")]<br/>fn captures(req: HttpRequest) -&gt; Result&lt;fs::NamedFile&gt; {<br/>    let mut root = PathBuf::from("static/");<br/>    let tail: PathBuf = req.match_info().query("tail").parse().unwrap();<br/>    root.push(tail);<br/><br/>    Ok(fs::NamedFile::open(root)?)<br/>}<br/><br/>#[get("from-bitly/{bitlyid}")]<br/>fn bit_ly(req: HttpRequest) -&gt; HttpResponse {<br/>    let bitly_id = req.match_info().get("bitlyid").unwrap();<br/>    let url = req.url_for("bitly", &amp;[bitly_id]).unwrap();<br/>    HttpResponse::Found()<br/>        .header(header::LOCATION, url.into_string())<br/>        .finish()<br/>        .into_body()<br/>}<br/><br/>#[get("/")]<br/>fn bookmarks_index() -&gt; impl Responder {<br/>    format!("Welcome to your quick and easy bookmarking service!")<br/>}</pre>
<ol start="3">
<li>Next, we should also register the handlers with the web server. The following is the <kbd>main</kbd> function for <kbd>main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(|| {<br/>        App::new()<br/>            .wrap(middleware::Logger::default())<br/>            .service(<br/>                web::scope("/api")<br/>                .service(<br/>                    web::scope("/bookmarks")<br/>                    .service(captures)<br/>                    .service(bookmark_by_id)<br/>                    .service(bit_ly)<br/>                    .service(web::resource("add/{id}")<br/>                        .name("add") <br/>                        <br/>                        .guard(guard::Any(guard::Put())<br/>                        .or(guard::Post()))<br/>                        .to(echo_bookmark))<br/>            ))<br/>            .service(<br/>                web::scope("/bookmarks")<br/>                    .service(bookmarks_index)<br/>            )<br/>            .external_resource("bitly", "https://bit.ly/{bitly}")<br/>            <br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="4">
<li>Lastly, we should adapt <kbd>Cargo.toml</kbd> to include these new dependencies as well:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>actix-web = "1"<br/>env_logger = "0.6"<br/>actix-files = "0"</pre>
<ol start="5">
<li>Now we can build and run the app using <kbd>cargo run</kbd>. Then, let's see whether we can reach the APIs using <kbd>curl</kbd> or Postman, which should result in a similar logging output to the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/> Finished dev [unoptimized + debuginfo] target(s) in 0.09s<br/> Running `target/debug/api`<br/>[2019-07-17T15:38:14Z INFO actix_web::middleware::logger] 127.0.0.1:50426 "GET /bookmarks/ HTTP/1.1" 200 51 "-" "curl/7.64.0" 0.000655<br/>[2019-07-17T15:40:07Z INFO actix_web::middleware::logger] 127.0.0.1:51386 "GET /api/bookmarks/by-id/10 HTTP/1.1" 200 44 "-" "curl/7.64.0" 0.001103<br/>[2019-07-17T15:40:41Z INFO actix_web::middleware::logger] 127.0.0.1:51676 "GET /api/bookmarks/from-bitly/2NOMT6Q HTTP/1.1" 302 0 "-" "curl/7.64.0" 0.007269<br/>[2019-07-17T15:42:26Z INFO actix_web::middleware::logger] 127.0.0.1:52566 "PUT /api/bookmarks/add/10 HTTP/1.1" 200 2 "-" "curl/7.64.0" 0.000704<br/>[2019-07-17T15:42:33Z INFO actix_web::middleware::logger] 127.0.0.1:52626 "POST /api/bookmarks/add/10 HTTP/1.1" 200 2 "-" "curl/7.64.0" 0.001098<br/>[2019-07-17T15:42:39Z INFO actix_web::middleware::logger] 127.0.0.1:52678 "DELETE /api/bookmarks/add/10 HTTP/1.1" 404 0 "-" "curl/7.64.0" 0.000630<br/>[2019-07-17T15:43:30Z INFO actix_web::middleware::logger] 127.0.0.1:53094 "GET /api/bookmarks/captures/does-not/exist HTTP/1.1" 404 38 "-" "curl/7.64.0" 0.003554<br/>[2019-07-17T15:43:39Z INFO actix_web::middleware::logger] 127.0.0.1:53170 "GET /api/bookmarks/captures/foxes.jpg HTTP/1.1" 200 59072 "-" "curl/7.64.0" 0.013600</pre>
<p style="padding-left: 60px">The following are the <kbd>curl</kbd> requests—they should be easy to replicate with Postman:</p>
<pre style="padding-left: 60px"><strong>$ curl localhost:8081/bookmarks/</strong><br/>Welcome to your quick and easy bookmarking service!⏎ <br/>$ curl localhost:8081/api/bookmarks/by-id/10<br/>{ "id": 10, "url": "https://blog.x5ff.xyz" }⏎<strong> </strong><br/><strong>$ curl -v localhost:8081/api/bookmarks/from-bitly/2NOMT6Q</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; GET /api/bookmarks/from-bitly/2NOMT6Q HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 302 Found<br/>&lt; content-length: 0<br/>&lt; location: https://bit.ly/2NOMT6Q<br/>&lt; date: Wed, 17 Jul 2019 15:40:45 GMT<br/>&lt;<strong> </strong><br/><strong>$ curl -X PUT localhost:8081/api/bookmarks/add/10</strong><br/>10⏎ <br/><strong>$ curl -X POST localhost:8081/api/bookmarks/add/10</strong><br/>10⏎<strong> </strong><br/><strong>$ curl -v -X DELETE localhost:8081/api/bookmarks/add/10</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; DELETE /api/bookmarks/add/10 HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 404 Not Found<br/>&lt; content-length: 0<br/>&lt; date: Wed, 17 Jul 2019 15:42:51 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact<br/><strong>$ curl localhost:8081/api/bookmarks/captures/does-not/exist</strong><br/>No such file or directory (os error 2)⏎ 17:43:31<br/><strong>$ curl localhost:8081/api/bookmarks/captures/foxes.jpg</strong><br/><strong>W</strong>arning: Binary output can mess up your terminal. Use "--output -" to tell <br/>Warning: curl to output it to your terminal anyway, or consider "--output <br/>Warning: &lt;FILE&gt;" to save to a file.</pre>
<p>That's it, but there is a lot to unpack so let's see why this works the way it does.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Designing <em>good</em> APIs is hard and requires a good grasp of what's possible—especially with new frameworks and languages. <kbd>actix-web</kbd> has proven itself to be a versatile tool that proficiently uses types to achieve great results. <em>Step 1</em> sets this up by importing a few types and traits.</p>
<p>Only in <em>step 2</em> and <em>step 3</em> does it get more interesting. Here, we define the various handlers in almost all of the ways <kbd>actix-web</kbd> allows us to, by either using the attribute that wraps a function into a factory (underneath it's all asynchronous actors; check out <em>Handle asynchronous messages with actors</em> in <a href="eb7f566a-00ca-4e6c-bc05-4e9d00bf8c56.xhtml">Chapter 4</a>, <em>Fearless Concurrency</em> ) or letting the <kbd>web::resource()</kbd> type do that. Either way, every handler function has a route associated with it and will be called in parallel. The routes also contain parameters that can be specified using a <kbd>{}</kbd> syntax that also allows regular expression (see the route containing <kbd>"{tail:.*}" - a</kbd> shorthand that receives the path's remainder under the <kbd>tail</kbd> key.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Don't let users directly access files on your filesystem as we did here. This is a bad idea in many ways, but most importantly offers a way to execute potentially any file in the filesystem. A better way is to provide a white list of abstracted files—for example, Base64 (<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding">https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding</a>)-encoded—using an independent key: for example, a UUID (<a href="https://tools.ietf.org/html/rfc4122">https://tools.ietf.org/html/rfc4122</a>).</p>
<p>If a function provides an input parameter of the <kbd>Path&lt;T&gt;</kbd> type, then <kbd>T</kbd> is what's checked for in the corresponding path variable. Therefore, if a function header expects <kbd>i32</kbd>, the request will fail for anyone trying to pass a string. You can verify that yourself with the <kbd>bookmarks/by-id/{id}</kbd> path. As an alternative to <kbd>Path&lt;T&gt;</kbd>, you can also receive the entire <kbd>HttpRequest</kbd> (<a href="https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html">https://docs.rs/actix-web/1.0.3/actix_web/struct.HttpRequest.html</a>) as a parameter and extract the required information with the <kbd>.query()</kbd> function. Both the <kbd>echo_bookmark</kbd> and <kbd>bit_ly</kbd> functions demonstrate how to use these. </p>
<p>The responses behave similarly. <kbd>actix-web</kbd> provides a <kbd>Responder</kbd> trait that is implemented for standard types such as <kbd>String</kbd> (along with the correct response content type as far as we saw), which makes the handler more readable. Again, returning an <kbd>HttpResponse</kbd> type provides more finely controllable returns. Additionally, there are results and similar types that are automatically converted into appropriate responses, but showing all of these would go beyond the scope of this book. Check out the <kbd>actix-web</kbd> documentation to find out more. </p>
<p>One downside to the attributes is the fact that only one of them can go on top of a function—so how can we reuse a function for two different <kbd>HTTP</kbd> methods? <kbd>echo_bookmark</kbd> is registered to respond to the input ID only on <kbd>PUT</kbd> and <kbd>POST</kbd>, not on <kbd>DELETE</kbd>, <kbd>HEAD</kbd>, <kbd>GET</kbd>, and more. This is done by guards that forward a request only if a condition is met. Check out the docs (<a href="https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html">https://docs.rs/actix-web/1.0.3/actix_web/guard/index.html</a>) for more.</p>
<p><em>Step 4</em> shows adaptations to <kbd>Cargo.toml</kbd> to make it all work and, in <em>step 5</em><em>,</em> we get to try out the web service. If you take some time to observe the <kbd>curl</kbd> responses, we receive the expected results. <kbd>curl</kbd> also does not follow redirects by default, hence the <kbd>HTTP</kbd> response code, <kbd>302</kbd>, with the location header set pointing to where I would go. This redirect is provided by an external resource that <kbd>actix-web</kbd> provides, which is useful for these situations.</p>
<p>Now that we have learned more about designing APIs in <kbd>actix-web</kbd>, let's move on to the next recipe.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">Handling JSON payloads</h1>
                
            
            
                
<p>After learning how to create APIs, we need to pass data back and forth. While the path provides one method to do that, anything a little more sophisticated (for example, a long list of things) will quickly show the limitations of these methods. This is why other formats are typically used to structure the data—JSON (<a href="http://json.org/">http://json.org/</a>) is the most popular for web services. In this chapter, we are going to use the previous API and enhance it by handling and returning JSON. </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's set up a Rust binary project using <kbd>cargo new json-handling</kbd>. Since we are going to serve stuff on the local port <kbd>8081</kbd>, make sure that the port is accessible as well. Additionally, a program such as <kbd>curl</kbd> or Postman is required to test the web service.</p>
<p>Finally, open the entire directory with VS Code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Perform the following steps to implement this recipe:</p>
<ol>
<li>In <kbd>src/main.rs</kbd>, we are going to add the imports first:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate actix_web;<br/><br/>use actix_web::{<br/>    guard, http::Method, middleware, web, App, HttpResponse, HttpServer,<br/>};<br/>use serde_derive::{Deserialize, Serialize};<br/>use std::env;</pre>
<ol start="2">
<li>Next, let's create some handler functions along with a serializable JSON type. Add the following code to <kbd>src/main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Debug, Clone, Serialize, Deserialize)]<br/>struct Bookmark {<br/>    id: i32,<br/>    url: String,<br/>}<br/><br/>#[get("by-id/{id}")]<br/>fn bookmarks_by_id(id: web::Path&lt;(i32)&gt;) -&gt; HttpResponse {<br/>    let bookmark = Bookmark {<br/>        id: *id,<br/>        url: "https://blog.x5ff.xyz".into(),<br/>    };<br/>    HttpResponse::Ok().json(bookmark)<br/>}<br/><br/>fn echo_bookmark(bookmark: web::Json&lt;Bookmark&gt;) -&gt; HttpResponse {<br/>    HttpResponse::Ok().json(bookmark.clone())<br/>}</pre>
<ol start="3">
<li>Lastly, we are registering the handlers with the web server in the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(|| {<br/>        App::new().wrap(middleware::Logger::default()).service(<br/>            web::scope("/api").service(<br/>                web::scope("/bookmarks")<br/>                    .service(bookmarks_by_id)<br/>                    .service(<br/>                        web::resource("add/{id}")<br/>                            .name("add")<br/>                            .guard(guard::Any(guard::Put()).<br/>                             or(guard::Post()))<br/>                            .to(echo_bookmark),<br/>                    )<br/>                    .default_service(web::route().method<br/>                     (Method::GET)),<br/>            ),<br/>        )<br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="4">
<li>We also need to specify the dependencies in <kbd>Cargo.toml</kbd>. Replace the existing dependencies with the following:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>actix-web = "1"<br/>serde = "1"<br/>serde_derive = "1"<br/>env_logger = "0.6"</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Then, we can see whether it works by running <kbd>cargo run</kbd> and issuing requests with <kbd>curl</kbd> from a different Terminal. The commands and their responses should look as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -d "{\"id\":10,\"url\":\"https://blog.x5ff.xyz\"}" localhost:8081/api/bookmarks/add/10</strong><br/>Content type error⏎<strong> </strong><br/><strong>$ curl -d "{\"id\":10,\"url\":\"https://blog.x5ff.xyz\"}" -H "Content-Type: application/json" </strong>localhost:8081/api/bookmarks/add/10<br/>{"id":10,"url":"https://blog.x5ff.xyz"}⏎<strong> </strong><br/><strong>$ curl localhost:8081/api/bookmarks/by-id/1</strong><br/>{"id":1,"url":"https://blog.x5ff.xyz"}⏎ </pre>
<p style="padding-left: 60px">Meanwhile, the logging output of <kbd>cargo run</kbd> shows the requests from the server side:</p>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.08s<br/>     Running `target/debug/json-handling`<br/>[2019-07-13T17:06:22Z INFO actix_web::middleware::logger] 127.0.0.1:48880 "POST /api/bookmarks/add/10 HTTP/1.1" 400 63 "-" "curl/7.64.0" 0.001955<br/>[2019-07-13T17:06:51Z INFO actix_web::middleware::logger] 127.0.0.1:49124 "POST /api/bookmarks/add/10 HTTP/1.1" 200 39 "-" "curl/7.64.0" 0.001290<br/>[2019-07-18T06:34:18Z INFO actix_web::middleware::logger] 127.0.0.1:54900 "GET /api/bookmarks/by-id/1 HTTP/1.1" 200 39 "-" "curl/7.64.0" 0.001636</pre>
<p>This was quick and easy, right? Let's see how it works.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Adding JSON handling to an <kbd>actix-web</kbd> web service is easy—thanks to the deep integration of the popular <kbd>serde</kbd> crate (<a href="https://crates.io/crates/serde">https://crates.io/crates/serde</a>). After some imports in <em>step 1</em>, we declare a <kbd>Bookmark</kbd> struct as <kbd>Serialize</kbd> and <kbd>Deserialize</kbd> in <em>step 2</em>, which enables <kbd>serde</kbd> to generate and parse JSON for this data type. </p>
<p class="mce-root"/>
<p>The change in the handler functions is also minimal since returning and ingesting JSON is a very common task. The required function to return a JSON payload with the response is attached to the <kbd>HttpResponse</kbd> factory method that does everything, including setting the appropriate content type. On the ingest part, there is a <kbd>web::Json&lt;T&gt;</kbd> type to take care of deserializing and checking whatever is forwarded into the request handler. We can rely on the framework to do most of the heavy lifting here as well.</p>
<p>The registering of the handlers in <em>step 3</em> is no different from previous recipes; the JSON input is only declared in the handler function. There are more variations in the <kbd>actix-web</kbd> docs (<a href="https://actix.rs/docs/request/#json-request">https://actix.rs/docs/request/#json-request</a>) and their examples (<a href="https://github.com/actix/examples/tree/master/json">https://github.com/actix/examples/tree/master/json</a>). Similarly, <em>step 4</em> contains the required dependencies we have also used in other recipes. </p>
<p> In <em>step 5</em>, we run the whole project and see how it works: if we pass JSON, the input <kbd>content-type</kbd> header has to be set to the appropriate mime type (<kbd>application/json</kbd>); the return values have this header set as well (and the <kbd>content-length</kbd> header) so browsers or other programs can easily work with the results. </p>
<p>Let's move on and look at another recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Web error handling</h1>
                
            
            
                
<p>The various layers of web services make error handling tricky, even without security requirements: what to communicate and when? Should an error bubble up only to be handled at the last minute or earlier? What about cascades? In this recipe, we will uncover some options to do that elegantly in <kbd>actix-web</kbd>.</p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's set up a Rust binary project using <kbd>cargo new web-errors</kbd>. Since we are going to serve stuff on the local port <kbd>8081</kbd>, make sure that the port is accessible as well. Additionally, a program such as <kbd>curl</kbd> or Postman is required to test the web service.</p>
<p>Finally, open the entire directory with VS Code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>You are just a few steps away from understanding error handling with <kbd>actix-web</kbd>:</p>
<ol>
<li>In <kbd>src/main.rs</kbd>, we are going to add the basic imports:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate actix_web;<br/>use failure::Fail;<br/><br/>use actix_web::{ http, middleware, web, App, HttpResponse, HttpServer, error<br/>};<br/>use serde_derive::{Deserialize, Serialize};<br/>use std::env;</pre>
<ol start="2">
<li>As a next step, we are going to define our error types and augment them with attributes to make the types known to the framework:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Fail, Debug)]<br/>enum WebError {<br/>    #[fail(display = "Invalid id '{}'", id)]<br/>    InvalidIdError { id: i32 },<br/>    #[fail(display = "Invalid request, please try again later")]<br/>    RandomInternalError,<br/>}<br/><br/>impl error::ResponseError for WebError {<br/>    fn error_response(&amp;self) -&gt; HttpResponse {<br/>        match *self {<br/>            WebError::InvalidIdError { .. } =&gt; HttpResponse::new(http::StatusCode::BAD_REQUEST),<br/>            WebError::RandomInternalError =&gt; HttpResponse::new(http::StatusCode::INTERNAL_SERVER_ERROR)<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>Then, we add the handler function to <kbd>src/main.rs</kbd> and register it in <kbd>main()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Debug, Clone, Serialize, Deserialize)]<br/>struct Bookmark {<br/>    id: i32,<br/>    url: String,<br/>}<br/><br/>#[get("by-id/{id}")]<br/>fn bookmarks_by_id(id: web::Path&lt;(i32)&gt;) -&gt; Result&lt;HttpResponse, WebError&gt; {<br/>    if *id &lt; 10 {<br/>        Ok(HttpResponse::Ok().json(Bookmark {<br/>            id: *id,<br/>            url: "https://blog.x5ff.xyz".into(),<br/>        }))<br/>    }<br/>    else {<br/>        Err(WebError::InvalidIdError { id: *id })<br/>    }<br/>}<br/><br/>fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(|| {<br/>        App::new()<br/>            .wrap(middleware::Logger::default())<br/>            .service(<br/>                web::scope("/bookmarks")<br/>                    .service(bookmarks_by_id)<br/>            )<br/>            .route(<br/>                "/underconstruction",<br/>                web::get().to(|| Result::&lt;HttpResponse, <br/>                WebError&gt;::Err(WebError::RandomInternalError)),<br/>            )<br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="4">
<li>To import the dependencies, we also have to adapt <kbd>Cargo.toml</kbd>:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>actix-web = "1"<br/>serde = "1"<br/>serde_derive = "1"<br/>env_logger = "0.6"<br/>failure = "0"</pre>
<ol start="5">
<li>To finish this recipe, let's see how everything works together with <kbd>cargo run</kbd> and <kbd>curl</kbd>. Here is the server output after the requests have been handled:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>  Compiling web-errors v0.1.0 (Rust-Cookbook/Chapter08/web-errors)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 7.74s<br/>     Running `target/debug/web-errors`<br/>[2019-07-19T17:33:43Z INFO actix_web::middleware::logger] 127.0.0.1:46316 "GET /bookmarks/by-id/1 HTTP/1.1" 200 38 "-" "curl/7.64.0" 0.001529<br/>[2019-07-19T17:33:47Z INFO actix_web::middleware::logger] 127.0.0.1:46352 "GET /bookmarks/by-id/100 HTTP/1.1" 400 16 "-" "curl/7.64.0" 0.000952<br/>[2019-07-19T17:33:54Z INFO actix_web::middleware::logger] 127.0.0.1:46412 "GET /underconstruction HTTP/1.1" 500 39 "-" "curl/7.64.0" 0.000275</pre>
<p style="padding-left: 60px">The following is what the requests look like with <kbd>curl</kbd>'s verbose mode:</p>
<pre style="padding-left: 60px"><strong>$ curl -v localhost:8081/bookmarks/by-id/1</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; GET /bookmarks/by-id/1 HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 200 OK<br/>&lt; content-length: 38<br/>&lt; content-type: application/json<br/>&lt; date: Fri, 19 Jul 2019 17:33:43 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact<br/>{"id":1,"url":"https://blog.x5ff.xyz"}⏎ </pre>
<p style="padding-left: 60px">Requesting the wrong ID returns an appropriate HTTP status code as well:</p>
<pre style="padding-left: 60px"><strong>$ curl -v localhost:8081/bookmarks/by-id/100</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; GET /bookmarks/by-id/100 HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 400 Bad Request<br/>&lt; content-length: 16<br/>&lt; content-type: text/plain<br/>&lt; date: Fri, 19 Jul 2019 17:33:47 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact<br/>Invalid id '100'⏎</pre>
<p style="padding-left: 60px">Just as expected, a request to <kbd>/underconstruction</kbd> yields an HTTP 500 error (internal server error):</p>
<pre style="padding-left: 60px"><strong>$ curl -v localhost:8081/underconstruction</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; GET /underconstruction HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 500 Internal Server Error<br/>&lt; content-length: 39<br/>&lt; content-type: text/plain<br/>&lt; date: Fri, 19 Jul 2019 17:33:54 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact<br/>Invalid request, please try again later⏎ </pre>
<p>Since that worked well, let's see how it works.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>actix-web</kbd> uses an error trait to convert Rust errors into <kbd>HttpResponses</kbd>. This trait is automatically implemented for a range of default errors but only by responding with the default <em>Internal Server Error</em> message. </p>
<p>In <em>step 1</em> and <em>step 2</em>, we are setting up custom errors so that we can return messages that are relevant to what the user is currently doing (or trying to do). As with other errors (see <a href="898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml">Chapter 5</a>, <em>Handling Errors and Other Results</em>), we are using enums to provide an umbrella to match error variations to. Each of the variants is augmented with an attribute that provides a corresponding error message with a format string—an ability provided by the <kbd>failure</kbd> crate (<a href="https://crates.io/crates/failure">https://crates.io/crates/failure</a>). The message here is a last-resort type message for a response code 500 (the default). This HTTP response code, along with the body of the error—such as an HTML page—can be customized by implementing the <kbd>actix_web::error::ResponseError</kbd> trait. Whichever <kbd>HttpResponse</kbd> is supplied using the <kbd>error_response()</kbd> function will be returned to the client. </p>
<p>If you call the function yourself, then the <kbd>#[fail(display="...")]</kbd> message won't be attached. Always use Rust's <kbd>Result</kbd> enum to communicate errors to <kbd>actix_web</kbd>.</p>
<p><em>Step 3</em> defines the handler functions of the web service and, since it uses a JSON response, a struct for serializing the information. In this example, we are also using the arbitrary number 10 as a cutoff point for returning an error—using a Rust <kbd>Result</kbd> enum. This provides a framework-agnostic way to handle bad outcomes just as if we were working with plain Rust. The second route, <kbd>/underconstruction</kbd>, provides an insight into how <kbd>actix-web</kbd> routes can be implemented: as a closure. Since this immediately returns an error, we have to explicitly tell the compiler about the return types and that it's a <kbd>Result</kbd> enum that could either be <kbd>HttpResponse</kbd> or <kbd>WebError</kbd>. We then directly return the latter. <em>Step 4</em> shows the required dependencies and tells us we have to include the failure crate. In the last step, we are running the code and testing it by issuing <kbd>curl</kbd> requests and checking the logs on the server side. That's nothing too complex, right? If you want to go deeper, also check out the <kbd>actix-web</kbd> docs (<a href="https://actix.rs/docs/errors/">https://actix.rs/docs/errors/</a>).</p>
<p>Let's move on to the next recipe. </p>


            

            
        
    </div>
<div><h1 class="header-title">Rendering HTML templates</h1>
                
            
            
                
<p>While JSON is a very human-readable format and easy to work with, many people still prefer a more interactive experience—such as websites. While this is not native to <kbd>actix-web</kbd>, some template engines provide seamless integration to minimize the calls required to assemble and output HTML. The major difference compared to simply delivering a static site is that template engines render variable output and Rust code into an augmented HTML page to produce content adapted to whatever the application's state is. In this recipe, we are taking a look at <strong>Yet Another Rust Template Engine</strong> (<strong>Yarte</strong>) (<a href="https://crates.io/crates/yarte">https://crates.io/crates/yarte</a>) and its integration with <kbd>actix-web</kbd>.  </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a Rust binary project using <kbd>cargo new html-templates</kbd> and make sure that port <kbd>8081</kbd> is accessible from the localhost. After creating the project directory, you'll have to create some additional folders and files. The image files inside the static directory can be any image, as long as there is a Base64-encoded version of it available as a text file. Use an online service or the Base64 binary (<a href="https://linux.die.net/man/1/base64">https://linux.die.net/man/1/base64</a> on Linux) to create your own (you'll have to change the names in the code accordingly) or use ours from the repository. The <kbd>.hbs</kbd> files will be filled (created) in this recipe:</p>
<pre>html-templates/<br/>├── Cargo.toml<br/>├── src<br/>│   └── main.rs<br/>├── static<br/>│   ├── packtpub.com.b64<br/>│   ├── packtpub.com.png<br/>│   ├── placeholder.b64<br/>│   ├── placeholder.png<br/>│   ├── x5ff.xyz.b64<br/>│   └── x5ff.xyz.png<br/>└── templates<br/>    ├── index.hbs<br/>    └── partials<br/>        └──bookmark.hbs</pre>
<p class="mce-root">Finally, open the entire directory with VS Code.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create templated web pages in just a few steps:</p>
<ol>
<li>First, let's add some code to <kbd>src/main.rs</kbd>. Replace the default snippet with the following (note: the Base64-encoded string in <kbd>PLACEHOLDER_IMG</kbd> is abbreviated here. Get the full Base64-encoded image at <a href="https://blog.x5ff.xyz/other/placeholder.b64">https://blog.x5ff.xyz/other/placeholder.b64</a>):</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate actix_web;<br/><br/>use actix_web::{middleware, web, App, HttpServer, Responder};<br/>use chrono::prelude::*;<br/>use std::env;<br/>use yarte::Template;<br/><br/>const PLACEHOLDER_IMG: &amp;str =<br/>    "iVBORw0KGgoAAAANS[...]s1NR+4AAAAASUVORK5CYII=";<br/><br/>#[derive(Template)]<br/>#[template(path = "index.hbs")]<br/>struct IndexViewModel {<br/>    user: String,<br/>    bookmarks: Vec&lt;BookmarkViewModel&gt;,<br/>}<br/><br/>#[derive(Debug, Clone)]<br/>struct BookmarkViewModel {<br/>    timestamp: Date&lt;Utc&gt;,<br/>    url: String,<br/>    mime: String,<br/>    base64_image: String,<br/>}</pre>
<p style="padding-left: 60px">After adjusting <kbd>src/main.rs</kbd>, add the required dependencies to <kbd>Cargo.toml</kbd>:</p>
<pre style="padding-left: 60px">[dependencies] <br/>actix-web = "1"<br/>serde = "1"<br/>serde_derive = "1"<br/>env_logger = "0.6"<br/>base64 = "0.10.1"<br/>yarte = {version = "0", features=["with-actix-web"]}<br/>chrono = "0.4"⏎ <br/></pre>
<ol start="2">
<li>After declaring the templates, we need to register a handler to serve them as well:</li>
</ol>
<pre style="padding-left: 60px">#[get("/{name}")]<br/>pub fn index(name: web::Path&lt;(String)&gt;) -&gt; impl Responder {<br/>    let user_name = name.as_str().into();</pre>
<p style="padding-left: 60px">First, let's add the bookmark data for the recognized user:</p>
<pre>    if &amp;user_name == "Claus" {<br/>        IndexViewModel {<br/>            user: user_name,<br/>            bookmarks: vec![<br/>                BookmarkViewModel {<br/>                    timestamp: Utc.ymd(2019, 7, 20),<br/>                    url: "https://blog.x5ff.xyz".into(),<br/>                    mime: "image/png".into(),<br/>                    base64_image: std::fs::read_to_string<br/>                    ("static/x5ff.xyz.b64")<br/>                        .unwrap_or(PLACEHOLDER_IMG.into()),<br/>                },<br/>                BookmarkViewModel {<br/>                    timestamp: Utc.ymd(2017, 9, 1),<br/>                    url: "https://microsoft.com".into(),<br/>                    mime: "image/png".into(),<br/>                    base64_image: std::fs::read_to_string<br/>                    ("static/microsoft.com.b64")<br/>                        .unwrap_or(PLACEHOLDER_IMG.into()),<br/>                },<br/>                BookmarkViewModel {<br/>                    timestamp: Utc.ymd(2019, 2, 2),<br/>                    url: "https://www.packtpub.com/".into(),<br/>                    mime: "image/png".into(),<br/>                    base64_image: std::fs::read_to_string<br/>                    ("static/packtpub.com.b64")<br/>                        .unwrap_or(PLACEHOLDER_IMG.into()),<br/>                },<br/>            ],<br/>        }</pre>
<p style="padding-left: 60px">For everyone else (unrecognized users), we can simply return an empty vector:</p>
<pre style="padding-left: 60px">    } else {<br/>        IndexViewModel {<br/>            user: user_name,<br/>            bookmarks: vec![],<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Finally, let's start the server in the <kbd>main</kbd> function:</p>
<pre style="padding-left: 60px">fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(|| {<br/>        App::new()<br/>            .wrap(middleware::Logger::default())<br/>            .service(web::scope("/bookmarks").service(index))<br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="3">
<li>The code is ready, but we still lack templates. This is where we add some content to the <kbd>.hbs</kbd> files. First, let's add code to <kbd>templates/index.hbs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;<br/>&lt;/head&gt;</pre>
<p style="padding-left: 60px">After the head, we need an HTML body that marks up the data:</p>
<pre style="padding-left: 60px">&lt;body&gt;<br/>    &lt;div class="container"&gt;<br/>        &lt;div class="row"&gt;<br/>            &lt;div class="col-lg-12 pb-3"&gt;<br/>                &lt;h1&gt;Welcome {{ user }}.&lt;/h1&gt;<br/>                &lt;h2 class="text-muted"&gt;Your bookmarks:&lt;/h2&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/><br/>        {{#if bookmarks.is_empty() }}<br/>        &lt;div class="row"&gt;<br/>            &lt;div class="col-lg-12"&gt;<br/>            No bookmarks :(<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>        {{~/if}}<br/>        <br/>        {{#each bookmarks}}<br/>            &lt;div class="row {{# if index % 2 == 1 }} bg-light text-<br/>            dark {{/if }} mt-2 mb-2"&gt;<br/>            {{&gt; partials/bookmark }}<br/>            &lt;/div&gt;<br/>        {{~/each}}<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<ol start="4">
<li>We are calling a partial inside this last template, so let's add some code to it as well. Open <kbd>templates/partials/bookmark.hbs</kbd> and insert the following:</li>
</ol>
<pre style="padding-left: 60px">&lt;div class="col-lg-2"&gt;<br/>    &lt;img class="rounded img-fluid p-1" src="img/>    {{ base64_image }}"&gt; &lt;/div&gt;<br/>&lt;div class="col-lg-10"&gt;<br/>    &lt;a href="{{ url }}"&gt;<br/>        &lt;h3&gt;{{ url.replace("https://", "") }}&lt;/h3&gt;<br/>    &lt;/a&gt;<br/>    &lt;i class="text-muted"&gt;Added {{ timestamp.format("%Y-%m-<br/>    %d").to_string() }}&lt;/i&gt;<br/>&lt;/div&gt;</pre>
<p class="mce-root"/>
<ol start="5">
<li>It's time to try this out! Use <kbd>cargo run</kbd> to start the server logging output and open a browser window at <kbd>localhost:8081/bookmarks/Hans</kbd> as well as <kbd>localhost:8081/bookmarks/Claus</kbd> to see whether it works. Here is what <kbd>cargo run</kbd> shows after the browser window has been opened at the URLs:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling html-templates v0.1.0 (Rust-Cookbook/Chapter08/html-templates)<br/> Finished dev [unoptimized + debuginfo] target(s) in 2m 38s<br/>     Running `target/debug/html-templates`<br/>[2019-07-20T16:36:06Z INFO actix_web::middleware::logger] 127.0.0.1:50060 "GET /bookmarks/Claus HTTP/1.1" 200 425706 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" 0.013246<br/>[2019-07-20T16:37:34Z INFO actix_web::middleware::logger] 127.0.0.1:50798 "GET /bookmarks/Hans HTTP/1.1" 200 821 "-" "Mozilla/5.0 (X11; Fedora; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36" 0.000730</pre>
<p style="padding-left: 60px">The following are the results for an unrecognized user:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b92368b6-0067-49e0-863f-17be693eb176.png"/></p>
<p style="padding-left: 60px" class="CDPAlignLeft CDPAlign">For a recognized user, the system returns the appropriate content:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ce12f078-f0c7-4980-ae72-957f06fd6698.png"/></p>
<p>Let's find out why this works.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In many languages, creating a template engine is somewhat like an introduction tutorial—which is probably where the name Yarte comes from. While the choices are many, <kbd>actix-web</kbd> provides examples with three other engines as well; we recommend checking them out in their GitHub repository (<a href="https://github.com/actix/examples">https://github.com/actix/examples</a>). <em>Step 1</em> of this recipe already covers some of the important work: importing stuff and declaring the view models (as in the MVVM pattern: <a href="https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/">https://blogs.msdn.microsoft.com/msgulfcommunity/2013/03/13/understanding-the-basics-of-mvvm-design-pattern/</a>). Yarte provides macro attributes that associate a particular model with a template file—and it automatically finds the <kbd>templates</kbd> folder. If that does not suit your project, they allow you to configure the framework accordingly. Find out more on their website (<a href="https://yarte.netlify.com/">https://yarte.netlify.com/</a>). We are using a nested model, where the inner struct does not need its own associated template. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In <em>step 2</em>, we are registering the handler function under the <kbd>/bookmarks</kbd> scope and the <kbd>/{name}</kbd> path, which leads to the URL: <kbd>/bookmarks/{name}</kbd>. <kbd>actix-web</kbd> is strict in checking the routes, so <kbd>/bookmarks/{name}<strong>/</strong></kbd> is going to return an error (404). The handler function returns a small list of bookmarks for the name Claus but not for anyone else, which—in a more realistic scenario—would come out of a database. Regardless, we are using this hardcoded version, and we added the logger middleware so we can see what's going on. We are also using a constant for the placeholder image, which you can download at <a href="https://blog.x5ff.xyz/other/placeholder.b64">https://blog.x5ff.xyz/other/placeholder.b64</a>.</p>
<p>The templates we are defining in <em>step 3</em> are the main difference between engines. Using the well-known <kbd>{{ rust-code }}</kbd> notation, we can augment regular HTML to generate more sophisticated output. There are loops of all kinds, conditionals, variables, and partials. Partials are important because they let you split the view parts into reusable components, which don't even have to be HTML/Yarte templates but can be any text.</p>
<p>The compilation process pulls in these templates, combining them with the types we declared earlier—with an important consequence. Currently, changing the template requires the <kbd>main.rs</kbd> file to be recompiled, reflect the changes, so using touch or similar to set the modified date of <kbd>src/main.rs</kbd> is recommended. After that, <kbd>cargo</kbd> behaves as if there was a change to <kbd>src/main.rs</kbd>.</p>
<p><em>Step 4</em> implements the partial that shows each bookmark, similarly to the index template in <em>step 3</em>. Only in <em>step 5</em> do we run and look at the results: a simple website showing the list of associated bookmarks for when a user is recognized (read: has data associated with the name) and when a user is not recognized. The minimal design is achieved by using the popular Bootstrap CSS framework (<a href="https://getbootstrap.com">https://getbootstrap.com</a>).</p>
<p>Now, let's move on to the next recipe. </p>


            

            
        
    </div>
<div><h1 class="header-title">Using an ORM to save data to a database</h1>
                
            
            
                
<p>Opinions about object-relational mappers vary considerably: their use was strongly encouraged when SQL databases stored all of the World's data but they quickly fell out of favor when it was actually the whole World's data. Typically these frameworks provide a trade-off between ease of use, language integration, and scalability. While it's true that querying terabytes of data requires a fundamentally different approach, simple CRUD-type business applications work well with frameworks that do the heavy lifting for you and—most importantly—are somewhat independent of the actual database they connect to. Rust's macros come in very handy here—they allow the ORM framework to do these things largely at compile time, so it's memory-safe, type-safe, and fast. Let's see how it's done.</p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a Rust binary project using <kbd>cargo new orm</kbd> and make sure that port <kbd>8081</kbd> is accessible from the localhost. To access the services, get a program such as <kbd>curl</kbd> or Postman to execute <kbd>POST</kbd>, <kbd>GET</kbd>, and more type web requests, as well as a program to create and manage SQLite (<a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a>) databases (for example, sqlitebrowser: <a href="https://github.com/sqlitebrowser/sqlitebrowser">https://github.com/sqlitebrowser/sqlitebrowser</a>). </p>
<p>Using a SQLite database manager, create a new database, <kbd>bookmarks.sqlite</kbd>, in a folder, <kbd>db</kbd>. Then, add a table that follows this schema:</p>
<pre>CREATE TABLE bookmarks(id TEXT PRIMARY KEY, url TEXT);</pre>
<p>Next, we are going to use the <kbd>libsqlite3</kbd> library and headers in the project. On Linux, WSL, and macOS, install the appropriate packages from the package repository. On Ubuntu and the WSL, you can use something such as <kbd>apt-get install libsqlite3-dev</kbd>. For other distributions and macOS, please use your preferred package manager to install <kbd>libsqlite3</kbd> and its headers.</p>
<p>Native Windows 10 users may have to download the <kbd>dll</kbd> binaries from <a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a> and place them into the project directory. However, using Linux/macOS is highly recommended. </p>
<p>Finally, open the entire directory with VS Code. </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Get your database queries running in just a few steps:</p>
<ol>
<li>In <kbd>src/main.rs</kbd>, we are going to add the basic imports:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate diesel;<br/>mod models;<br/>mod schema;<br/><br/>use actix_web::{middleware, web, App, Error, HttpResponse, HttpServer};<br/><br/>use std::env;<br/><br/>use diesel::prelude::*;<br/>use diesel::sqlite::SqliteConnection;<br/>use futures::Future;<br/>use models::{Bookmark, NewBookmark};<br/>use serde_derive::{Deserialize, Serialize};</pre>
<ol start="2">
<li>Let's set up some more helper types and a constant for the connection string in <kbd>main.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">// Helpers<br/>const SQLITE_DB_URL: &amp;str = "db/bookmarks.sqlite";<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>struct WebBookmark {<br/>    url: String,<br/>}<br/><br/>fn connect(db_url: &amp;str) -&gt; SqliteConnection {<br/>    SqliteConnection::establish(&amp;SQLITE_DB_URL)<br/>     .expect(&amp;format!("Error connecting to {}", db_url))<br/>}</pre>
<ol start="3">
<li>We are going to need some handlers as well, so let's add them to the file, starting with retrieving bookmarks by their IDs:</li>
</ol>
<pre style="padding-left: 60px">// Handlers<br/>fn bookmarks_by_id(req_id: web::Path&lt;(String)&gt;) -&gt; impl <br/> Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        bookmarks<br/>            .filter(id.eq(req_id.as_str()))<br/>            .limit(1)<br/>            .load::&lt;Bookmark&gt;(&amp;conn)<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">To find out all IDs, we also want to have a handler that returns all bookmarks:</p>
<pre style="padding-left: 60px">fn all_bookmarks() -&gt; impl Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        bookmarks.load::&lt;Bookmark&gt;(&amp;conn)<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">Next, let's see whether we can add some bookmarks:</p>
<pre style="padding-left: 60px">fn bookmarks_add(<br/>    bookmark: web::Json&lt;WebBookmark&gt;,<br/>     ) -&gt; impl Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        let new_id = format!("{}", uuid::Uuid::new_v4());<br/>        let new_bookmark = NewBookmark {<br/>            id: &amp;new_id,<br/>            url: &amp;bookmark.url,<br/>        };<br/>        diesel::insert_into(bookmarks)<br/>            .values(&amp;new_bookmark)<br/>            .execute(&amp;conn)<br/>            .map(|_| new_id)<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">What's missing for almost full CRUD is the <kbd>delete</kbd> function:</p>
<pre style="padding-left: 60px">fn bookmarks_delete(<br/>    req_id: web::Path&lt;(String)&gt;,<br/>     ) -&gt; impl Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        diesel::delete(bookmarks.filter(id.eq(req_id.as_str())))<br/>         .execute(&amp;conn)<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">Lastly, we tie them all together in the <kbd>main</kbd> function that starts the server and attaches these handlers:</p>
<pre style="padding-left: 60px">fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(move || {<br/>        App::new().wrap(middleware::Logger::default()).service(<br/>            web::scope("/api").service(<br/>                web::scope("/bookmarks")<br/>                    .service(web::resource("/all").route(web::get()<br/>                    .to_async(all_bookmarks)))<br/>                    .service(<br/>                        web::resource("by-id/{id}").route(web<br/>                        ::get().to_async(bookmarks_by_id)),<br/>                    )<br/>                    .service(<br/>                        web::resource("/")<br/>                            .data(web::JsonConfig::default())      <br/>                            .route(web::post().to_async<br/>                            (bookmarks_add)),<br/>                    )<br/>                    .service(<br/>                        web::resource("by-<br/>                        id/{id}").route(web::delete()<br/>                        .to_async(bookmarks_delete)),<br/>                    ),<br/>            ),<br/>        )<br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="4">
<li>So, where are the models? They are in their own file, <kbd>src/models.rs</kbd>. Create it and add the following content:</li>
</ol>
<pre style="padding-left: 60px">use crate::schema::bookmarks;<br/>use serde_derive::Serialize;<br/><br/>#[derive(Debug, Clone, Insertable)]<br/>#[table_name = "bookmarks"]<br/>pub struct NewBookmark&lt;'a&gt; {<br/>    pub id: &amp;'a str,<br/>    pub url: &amp;'a str,<br/>}<br/><br/>#[derive(Serialize, Queryable)]<br/>pub struct Bookmark {<br/>    pub id: String,<br/>    pub url: String,<br/>}</pre>
<ol start="5">
<li>There is still another import that we have not yet created: <kbd>src/schema.rs</kbd>. Create that file as well with the following code:</li>
</ol>
<pre style="padding-left: 60px">table! {<br/>    bookmarks (id) {<br/>        id -&gt; Text,<br/>        url -&gt; Text,<br/>    }<br/>}</pre>
<ol start="6">
<li>As usual, we need to adapt <kbd>Cargo.toml</kbd> to download the dependencies:</li>
</ol>
<pre>[dependencies]<br/>actix-web = "1"<br/>serde = "1"<br/>serde_derive = "1"<br/>env_logger = "0.6"<br/>diesel = {version = "1.4", features = ["sqlite"] }<br/>uuid = { version = "0.7", features = ["serde", "v4"] }<br/>futures = "0.1"</pre>
<ol start="7">
<li>This should set everything up to run the web service with <kbd>cargo run</kbd> and observe the logging output (after the requests):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.16s<br/>     Running `target/debug/orm`<br/>[2019-07-20T19:33:33Z INFO actix_web::middleware::logger] 127.0.0.1:54560 "GET /api/bookmarks/all HTTP/1.1" 200 2 "-" "curl/7.64.0" 0.004737<br/>[2019-07-20T19:33:52Z INFO actix_web::middleware::logger] 127.0.0.1:54722 "POST /api/bookmarks/ HTTP/1.1" 200 1 "-" "curl/7.64.0" 0.017087<br/>[2019-07-20T19:33:55Z INFO actix_web::middleware::logger] 127.0.0.1:54750 "GET /api/bookmarks/all HTTP/1.1" 200 77 "-" "curl/7.64.0" 0.002248<br/>[2019-07-20T19:34:11Z INFO actix_web::middleware::logger] 127.0.0.1:54890 "GET /api/bookmarks/by-id/9b2a4264-3db6-4c50-88f1-807b20b5841e HTTP/1.1" 200 77 "-" "curl/7.64.0" 0.003298<br/>[2019-07-20T19:34:23Z INFO actix_web::middleware::logger] 127.0.0.1:54992 "DELETE /api/bookmarks/by-id/9b2a4264-3db6-4c50-88f1-807b20b5841e HTTP/1.1" 200 1 "-" "curl/7.64.0" 0.017980<br/>[2019-07-20T19:34:27Z INFO actix_web::middleware::logger] 127.0.0.1:55030 "GET /api/bookmarks/all HTTP/1.1" 200 2 "-" "curl/7.64.0" 0.000972</pre>
<p style="padding-left: 60px">We can interact with the web service with <kbd>curl</kbd>, and here are the expected calls and output:</p>
<pre style="padding-left: 60px"><strong>$ curl localhost:8081/api/bookmarks/all</strong><br/>[]⏎<br/><strong>$ curl -d "{\"url\":\"https://blog.x5ff.xyz\"}" -H "Content-Type: application/json" localhost:8081/api/bookmarks/</strong><br/>"9b2a4264-3db6-4c50-88f1-807b20b5841e"⏎<br/><strong>$ curl localhost:8081/api/bookmarks/all</strong><br/>[{"id":"9b2a4264-3db6-4c50-88f1-807b20b5841e","url":"https://blog.x5ff.xyz"}]⏎<br/><strong>$ curl localhost:8081/api/bookmarks/by-id/9b2a4264-3db6-4c50-88f1-807b20b5841e</strong><br/>[{"id":"9b2a4264-3db6-4c50-88f1-807b20b5841e","url":"https://blog.x5ff.xyz"}]⏎<br/><strong>$ curl -X "DELETE" localhost:8081/api/bookmarks/by-id/9b2a4264-3db6-4c50-88f1-807b20b5841e</strong><br/>1⏎<br/><strong>$ curl localhost:8081/api/bookmarks/all</strong><br/>[]⏎</pre>
<p>Let's see how this works.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>diesel-rs</kbd> is Rust's most well-known database connection framework and provides a fast, type-safe, and easy-to-use experience with mapping database tables. This is, again, possible thanks to the power of macros, which enable the creation of zero-cost abstractions at compile time. However, there is a trade-off for a few things and it's important to learn how to use the framework. </p>
<p>SQLite does not have a very rigid type system. This is why we get away with using a generic type for strings called text. Other databases may have more nuanced types. Check out SQLite3 types (<a href="https://www.sqlite.org/datatype3.html">https://www.sqlite.org/datatype3.html</a>) for more information. </p>
<p>In <em>step 1</em>, we are preparing the imports—nothing too interesting but you'll notice the declaration of <kbd>models.rs</kbd> and <kbd>schema.rs</kbd>. One step further, in <em>step 2</em> we see a connection string (actually just a file path) constant that we'll use to connect to the database in the connect function. Additionally, we are making a JSON web service so we create the transfer object type, <kbd>WebBookmark</kbd>. We are creating these handlers in <em>step 3</em>, one for adding, retrieving (all and by ID), and deleting a bookmark entity. </p>
<p>All of these handlers return a <kbd>Future</kbd> object and run asynchronously. While handlers always run asynchronously (they are actors), these return the type explicitly since they use a synchronous section to connect to the database—<kbd>diesel-rs</kbd> is not thread-safe right now. This synchronous section is implemented using a <kbd>web::block</kbd> statement that returns a result that is mapped onto <kbd>Future</kbd> and an appropriate <kbd>HttpResponse</kbd> type. In the case of the <kbd>bookmarks_add</kbd> handler, it returns the newly created ID as a JSON string, while <kbd>bookmarks_delete</kbd> returns the number of rows affected by the delete. All of the handlers return a 500 in the case of an error. </p>
<p>If you want to know how to use connection pooling and properly manage those, check out the <kbd>actix-web</kbd> example for diesel (<a href="https://github.com/actix/examples/tree/master/diesel">https://github.com/actix/examples/tree/master/diesel</a>). It uses Rust's <kbd>r2d2</kbd> crate (<a href="https://github.com/sfackler/r2d2">https://github.com/sfackler/r2d2</a>).</p>
<p><em>Step 3</em> also registers these functions with their respective routes. The <kbd>by-id</kbd> route accepts two different methods (<kbd>GET</kbd> and <kbd>DELETE</kbd>) and, thanks to the asynchronous nature of the <kbd>bookmarks_add</kbd> function, the data has to be declared to explicitly declare <kbd>JsonConfig</kbd> to automatically parse JSON input. All of the registrations are done using the <kbd>to_async</kbd> method as well, which makes the attribute method impossible to use. </p>
<p>Only in <em>step 4</em> and <em>step 5</em> are we creating <kbd>diesel-rs</kbd>-specific code. <kbd>models.rs</kbd> is a file that contains all of our models, and both of them are abstractions for a row in the table, but the <kbd>NewBookmark</kbd> type takes care of inserting new objects (the <kbd>table_name</kbd> and <kbd>Insertable</kbd> attributes attach it to the DSL),  while <kbd>Bookmark</kbd> is returned to the user (diesel's <kbd>Queryable</kbd> and Serde's <kbd>Serialize</kbd> enable that). <kbd>schema.rs</kbd> contains a macro call declaring the table name (<kbd>bookmarks</kbd>), its primary key (<kbd>id</kbd>), and its columns (<kbd>id</kbd> and <kbd>url</kbd>) along with their datatypes as understood by diesel. There are many more types; check out diesel's in-depth explanation of <kbd>table!</kbd> (<a href="https://diesel.rs/guides/schema-in-depth/">https://diesel.rs/guides/schema-in-depth/</a>). </p>
<p><em>Step 6</em> shows how <kbd>diesel-rs</kbd> works with different databases; all of them are features that have to be declared. Additionally, diesel has a CLI for database migrations and other fun stuff, so check out its getting started guide (<a href="https://diesel.rs/guides/getting-started/">https://diesel.rs/guides/getting-started/</a>) for more information. In <em>step 7</em>, we finally get to run the web service and insert/query some of the data.</p>
<p>However, let's move on to do more advanced stuff with the ORM framework. </p>


            

            
        
    </div>
<div><h1 class="header-title">Running advanced queries using an ORM</h1>
                
            
            
                
<p>One major downside of ORMs is typically the complexity of doing things that are outside the happy path. SQL—the language relational databases use—is standardized but its types are not always compatible with what the application is doing. In this recipe, we'll explore a few ways to run more advanced queries in Rust's <kbd>diesel-rs.</kbd> </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a Rust binary project using <kbd>cargo new advanced-orm</kbd> and make sure that port <kbd>8081</kbd> is accessible from the localhost. To access the services, get a program such as <kbd>curl</kbd> or Postman to execute <kbd>POST</kbd>, <kbd>GET</kbd>, and more type web requests, as well as a program to create and manage SQLite (<a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a>) databases (for example, sqlitebrowser: <a href="https://github.com/sqlitebrowser/sqlitebrowser">https://github.com/sqlitebrowser/sqlitebrowser</a>). </p>
<p>You can reuse and expand the code from the previous recipe (<em>Using an ORM to save data to a database</em>) if you ensure you update the database tables.</p>
<p>Using a SQLite database manager, create a new database, <kbd>bookmarks.sqlite</kbd>, in a folder, <kbd>db</kbd>. Then, add tables that follow these schemas:</p>
<pre>CREATE TABLE bookmarks(id TEXT PRIMARY KEY, url TEXT, added TEXT);<br/>CREATE TABLE comments(id TEXT PRIMARY KEY, bookmark_id TEXT, comment TEXT);</pre>
<p>Next, we are going to use the <kbd>libsqlite3</kbd> library and headers in the project. On Linux, WSL, and macOS, install the appropriate packages from the package repository. On Ubuntu and the WSL, you can use something like <kbd>apt-get install libsqlite3-dev</kbd>.</p>
<p>Native Windows 10 users may have to download the <kbd>dll</kbd> binaries from <a href="https://www.sqlite.org/download.html">https://www.sqlite.org/download.html</a> and place them into the project directory. However, using Linux/macOS is highly recommended. </p>
<p>Finally, open the entire directory with VS Code. </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Use templates in just a few steps:</p>
<ol>
<li><kbd>src/main.rs</kbd> is going to contain the handlers and main function. Let's start by adding some helper types and functions:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate diesel;<br/>mod models;<br/>mod schema;<br/><br/>use actix_web::{middleware, web, App, Error, HttpResponse, HttpServer};<br/><br/>use std::env;<br/><br/>use crate::schema::{date, julianday};<br/>use chrono::prelude::*;<br/>use diesel::prelude::*;<br/>use diesel::sqlite::SqliteConnection;<br/>use futures::Future;<br/>use serde_derive::{Deserialize, Serialize};</pre>
<p style="padding-left: 60px">After some imports, let's set up the helpers:</p>
<pre style="padding-left: 60px">// Helpers<br/>const SQLITE_DB_URL: &amp;str = "db/bookmarks.sqlite";<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>struct WebBookmark {<br/>    url: String,<br/>    comment: Option&lt;String&gt;,<br/>}<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>struct WebBookmarkResponse {<br/>    id: String,<br/>    added: String,<br/>    url: String,<br/>    comment: Option&lt;String&gt;,<br/>}<br/><br/>fn connect(db_url: &amp;str) -&gt; SqliteConnection {<br/>    SqliteConnection::establish(&amp;SQLITE_DB_URL).expect(&amp;format!("Error connecting to {}", db_url))<br/>}</pre>
<p class="mce-root"/>
<ol start="2">
<li>A new handler will fetch bookmarks with a Julian date. Let's add it along with some other, well-known handlers:</li>
</ol>
<pre style="padding-left: 60px">fn bookmarks_as_julian_by_date(<br/>    at: web::Path&lt;(String)&gt;,<br/>    ) -&gt; impl Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        bookmarks<br/>            .select((id, url, julianday(added)))<br/>            .filter(date(added).eq(at.as_str()))<br/>            .load::&lt;models::JulianBookmark&gt;(&amp;conn)<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">Adding bookmarks is one of these well-known handlers:</p>
<pre style="padding-left: 60px">fn bookmarks_add(<br/>    bookmark: web::Json&lt;WebBookmark&gt;,<br/>    ) -&gt; impl Future&lt;Item = HttpResponse, <br/>    Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/>        use self::schema::comments::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        let new_id = format!("{}", uuid::Uuid::new_v4());<br/>        let now = Utc::now().to_rfc3339();<br/>        let new_bookmark = models::NewBookmark {<br/>            id: &amp;new_id,<br/>            url: &amp;bookmark.url,<br/>            added: &amp;now,<br/>        };<br/><br/>        if let Some(comment_) = &amp;bookmark.comment {<br/>            let new_comment_id = format!("{}", <br/>            uuid::Uuid::new_v4());<br/>            let new_comment = models::NewComment {<br/>                comment_id: &amp;new_comment_id,<br/>                bookmark_id: &amp;new_id,<br/>                comment: &amp;comment_,<br/>            };<br/>            let _ = diesel::insert_into(comments)<br/>                .values(&amp;new_comment)<br/>                .execute(&amp;conn);<br/>        }<br/><br/>        diesel::insert_into(bookmarks)<br/>            .values(&amp;new_bookmark)<br/>            .execute(&amp;conn)<br/>            .map(|_| new_id)<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">Next, deleting bookmarks is an important handler:</p>
<pre style="padding-left: 60px">fn bookmarks_delete(<br/>    req_id: web::Path&lt;(String)&gt;,<br/>    ) -&gt; impl Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/>        use self::schema::comments::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        diesel::delete(bookmarks.filter(id.eq(req_id.as_str())))<br/>            .execute(&amp;conn)<br/>            .and_then(|_| {<br/>                diesel::delete(comments.filter(bookmark_id.eq<br/>                (req_id.as_str()))).execute(&amp;conn)<br/>            })<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<ol start="3">
<li>Now that we can add and delete comments and bookmarks, all we have to do is fetch them all at once:</li>
</ol>
<pre style="padding-left: 60px">fn all_bookmarks() -&gt; impl Future&lt;Item = HttpResponse, Error = Error&gt; {<br/>    web::block(move || {<br/>        use self::schema::bookmarks::dsl::*;<br/>        use self::schema::comments::dsl::*;<br/><br/>        let conn = connect(&amp;SQLITE_DB_URL);<br/>        bookmarks<br/>            .left_outer_join(comments)<br/>            .load::&lt;(models::Bookmark, Option&lt;models::Comment&gt;)&gt;<br/>            (&amp;conn)<br/>            .map(<br/>                |bookmarks_: Vec&lt;(models::Bookmark, <br/>                Option&lt;models::Comment&gt;)&gt;| {<br/>                    let responses: Vec&lt;WebBookmarkResponse&gt; = <br/>                    bookmarks_<br/>                        .into_iter()<br/>                        .map(|(b, c)| WebBookmarkResponse {<br/>                            id: b.id,<br/>                            url: b.url,<br/>                            added: b.added,<br/>                            comment: c.map(|c| c.comment),<br/>                        })<br/>                        .collect();<br/>                    responses<br/>                },<br/>            )<br/>    })<br/>    .then(|res| match res {<br/>        Ok(obj) =&gt; Ok(HttpResponse::Ok().json(obj)),<br/>        Err(_) =&gt; Ok(HttpResponse::InternalServerError().into()),<br/>    })<br/>}</pre>
<p style="padding-left: 60px">Lastly, we wire everything up in <kbd>main()</kbd>:</p>
<pre style="padding-left: 60px">fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(move || {<br/>        App::new().wrap(middleware::Logger::default()).service(<br/>            web::scope("/api").service(<br/>                web::scope("/bookmarks")<br/>                    .service(web::resource("/all").route<br/>                    (web::get().to_async(all_bookmarks)))<br/>                    .service(<br/>                        web::resource("added_on/{at}/julian")<br/>                            .route(web::get().to_async<br/>                            (bookmarks_as_julian_by_date)),<br/>                    )<br/>                    .service(<br/>                        web::resource("/")<br/>                            .data(web::JsonConfig::default())<br/>                            .route(web::post().to_async<br/>                            (bookmarks_add)),<br/>                    )<br/>                    .service(<br/>                        web::resource("by-                    <br/>                        id/{id}").route(web::delete().<br/>                        to_async(bookmarks_delete)),<br/>                    ),<br/>            ),<br/>        )<br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="4">
<li>To save comments alongside bookmarks, we had to expand the schema and models as well. Create (or edit) <kbd>src/schema.rs</kbd> with the following content:</li>
</ol>
<pre style="padding-left: 60px">use diesel::sql_types::Text;<br/>joinable!(comments -&gt; bookmarks (bookmark_id));<br/>allow_tables_to_appear_in_same_query!(comments, bookmarks);<br/><br/>sql_function! {<br/>    fn julianday(t: Text) -&gt; Float;<br/>}<br/>sql_function! {<br/>    fn date(t: Text) -&gt; Text;<br/>}<br/><br/>table! {<br/>    bookmarks (id) {<br/>        id -&gt; Text,<br/>        url -&gt; Text,<br/>        added -&gt; Text,<br/>    }<br/>}<br/><br/>table! {<br/>    comments (comment_id) {<br/>        comment_id -&gt; Text,<br/>        bookmark_id -&gt; Text,<br/>        comment -&gt; Text,<br/>    }<br/>}</pre>
<ol start="5">
<li>Next, create or update <kbd>src/models.rs</kbd> to create the Rust representation of these types:</li>
</ol>
<pre style="padding-left: 60px">use crate::schema::{bookmarks, comments};<br/>use serde_derive::Serialize;<br/><br/>#[derive(Debug, Clone, Insertable)]<br/>#[table_name = "bookmarks"]<br/>pub struct NewBookmark&lt;'a&gt; {<br/>    pub id: &amp;'a str,<br/>    pub url: &amp;'a str,<br/>    pub added: &amp;'a str,<br/>}<br/><br/>#[derive(Debug, Serialize, Queryable)]<br/>pub struct Bookmark {<br/>    pub id: String,<br/>    pub url: String,<br/>    pub added: String,<br/>}<br/><br/>#[derive(Serialize, Queryable)]<br/>pub struct JulianBookmark {<br/>    pub id: String,<br/>    pub url: String,<br/>    pub julian: f32,<br/>}<br/><br/>#[derive(Debug, Serialize, Queryable)]<br/>pub struct Comment {<br/>    pub bookmark_id: String,<br/>    pub comment_id: String,<br/>    pub comment: String,<br/>}<br/><br/>#[derive(Debug, Clone, Insertable)]<br/>#[table_name = "comments"]<br/>pub struct NewComment&lt;'a&gt; {<br/>    pub bookmark_id: &amp;'a str,<br/>    pub comment_id: &amp;'a str,<br/>    pub comment: &amp;'a str,<br/>}</pre>
<ol start="6">
<li>To import the dependencies, we also have to adapt <kbd>Cargo.toml</kbd>:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>actix-web = "1"<br/>serde = "1"<br/>serde_derive = "1"<br/>env_logger = "0.6"<br/>diesel = {version = "1.4", features = ["sqlite"] }<br/>uuid = { version = "0.7", features = ["serde", "v4"] }<br/>futures = "0.1"<br/>chrono = "0.4"</pre>
<ol start="7">
<li>To finish this recipe, let's see how everything works together with <kbd>cargo run</kbd> and <kbd>curl</kbd>. The requests should respond in line with the following logging output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl http://localhost:8081/api/bookmarks/all</strong><br/>[]⏎<strong> </strong><br/><strong>$ curl -d "{\"url\":\"https://blog.x5ff.xyz\"}" -H "Content-Type: application/json" </strong>localhost:8081/api/bookmarks/<br/>"db5538f4-e2f9-4170-bc38-02af42e6ef59"⏎<strong> </strong><br/><strong>$ curl -d "{\"url\":\"https://www.packtpub.com\", \"comment\": \"Great books\"}" -H "Content-Type:       <br/>  application/json" localhost:8081/api/bookmarks/</strong><br/>"5648b8c3-635e-4d55-9592-d6dfab59b32d"⏎<strong> </strong><br/><strong>$ curl http://localhost:8081/api/bookmarks/all</strong><br/>[{<br/>    "id": "db5538f4-e2f9-4170-bc38-02af42e6ef59",<br/>    "added": "2019-07-23T10:32:51.020749289+00:00",<br/>    "url": "https://blog.x5ff.xyz",<br/>    "comment": null<br/> },<br/> {<br/>    "id": "5648b8c3-635e-4d55-9592-d6dfab59b32d",<br/>    "added": "2019-07-23T10:32:59.899292263+00:00",<br/>    "url": "https://www.packtpub.com",<br/>    "comment": "Great books"<br/> }]⏎<strong> </strong><br/><strong>$ curl http://localhost:8081/api/bookmarks/added_on/2019-07-23/julian</strong><br/>[{<br/>    "id": "db5538f4-e2f9-4170-bc38-02af42e6ef59",<br/>    "url": "https://blog.x5ff.xyz",<br/>    "julian": 2458688.0<br/>},<br/>{<br/>    "id": "5648b8c3-635e-4d55-9592-d6dfab59b32d",<br/>    "url": "https://www.packtpub.com",<br/>    "julian": 2458688.0<br/>}]⏎ </pre>
<p style="padding-left: 60px">Here are the server logs generated by the requests, printed to the Terminal that <kbd>cargo run</kbd> runs in:</p>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling advanced-orm v0.1.0 (Rust-Cookbook/Chapter08/advanced-orm)<br/> Finished dev [unoptimized + debuginfo] target(s) in 4.75s<br/> Running `target/debug/advanced-orm`<br/>[2019-07-23T10:32:36Z INFO actix_web::middleware::logger] 127.0.0.1:39962 "GET /api/bookmarks/all HTTP/1.1" 200 2 "-" "curl/7.64.0" 0.004323<br/>[2019-07-23T10:32:51Z INFO actix_web::middleware::logger] 127.0.0.1:40094 "POST /api/bookmarks/ HTTP/1.1" 200 38 "-" "curl/7.64.0" 0.018222<br/>[2019-07-23T10:32:59Z INFO actix_web::middleware::logger] 127.0.0.1:40172 "POST /api/bookmarks/ HTTP/1.1" 200 38 "-" "curl/7.64.0" 0.025890<br/>[2019-07-23T10:33:06Z INFO actix_web::middleware::logger] 127.0.0.1:40226 "GET /api/bookmarks/all HTTP/1.1" 200 287 "-" "curl/7.64.0" 0.001803<br/>[2019-07-23T10:34:18Z INFO actix_web::middleware::logger] 127.0.0.1:40844 "GET /api/bookmarks/added_on/2019-07-23/julian HTTP/1.1" 200 194 "-" "curl/7.64.0" 0.001653</pre>
<p>Behind the scenes, a lot is going on. Let's find out what.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Working with <kbd>diesel-rs</kbd> requires a good understanding of how it works internally to achieve the desired results. Check out the previous recipe (<em>Using an ORM to save data to a database</em>) for some details on the basics. In this recipe, we are diving straight into the more advanced stuff. </p>
<p>After some basic setup in <em>step 1</em>, <em>step 2</em> creates a new handler that fetches all bookmarks added on a particular day and returns the date as a Julian date (<a href="https://en.wikipedia.org/wiki/Julian_day">https://en.wikipedia.org/wiki/Julian_day</a>). The calculation is done using one of SQLite's few scalar functions: <kbd>juliandate()</kbd> (<a href="https://www.sqlite.org/lang_datefunc.html">https://www.sqlite.org/lang_datefunc.html</a>). So, how did we get the function into Rust? <em>Step 4</em> shows the <kbd>diesel-rs</kbd> way: by using a <kbd>sql_function!</kbd> macro (<a href="https://docs.diesel.rs/diesel/macro.sql_function.html">https://docs.diesel.rs/diesel/macro.sql_function.html</a>) that maps the data types and output appropriately. Since we are mapping a pre-existing function here, there are no further steps required (this should work the same for stored procedures). </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Another aspect that <em>step 2</em> covers is inserting into and deleting from multiple tables, which is easy thanks to SQLite's disabled referential integrity constraint (<a href="https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php">https://www.w3resource.com/sql/joins/joining-tables-through-referential-integrity.php</a>). If this constraint is enforced, take a look at the <kbd>diesel-rs</kbd> transactions (<a href="https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction">https://docs.diesel.rs/diesel/connection/trait.Connection.html#method.transaction</a>). <em>Step 3</em> goes on to show how to retrieve this data—using a left outer join. Left joins take every row from the left side (<kbd>bookmarks</kbd> if the join looks as follows: <kbd>bookmarks LEFT JOIN comments</kbd>) and try to match it to rows in the table on the right, which means we get every bookmark regardless of whether they have comments or not. To map this result set, we have to provide a corresponding data type to parse to, which <kbd>diesel-rs</kbd> expects to be <kbd>(Bookmark, Option&lt;Comment&gt;)</kbd>. Since the <kbd>left_join()</kbd> call does not mention which columns to join on, how does the framework know? Again, in <em>step 4</em>, we declare the two tables as <kbd>joinable</kbd> via two macros: <kbd>joinable</kbd> (<a href="https://docs.diesel.rs/diesel/macro.joinable.html">https://docs.diesel.rs/diesel/macro.joinable.html</a>) and <kbd>allow_tables_to_appear_in_same_query</kbd> (<a href="https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html">https://docs.diesel.rs/diesel/macro.allow_tables_to_appear_in_same_query.html</a>). After the results are fetched, we map them to a <kbd>Serializable</kbd> combined type to hide this implementation detail from the user. </p>
<p>Only in <em>step 4</em> and <em>step 5</em> do we take care of mapping out the database tables and rows for diesel—nothing too surprising here. The <kbd>Queryable</kbd> attribute is important for <kbd>diesel-rs</kbd> to map tuples to types—regardless of the actual table. For more ad hoc queries, we could work with tuples directly as well. <em>Step 6</em> takes care of the dependencies.</p>
<p><em>Step 7</em> runs the server and avid readers will have noticed one thing: compilation takes longer than usual. We suspect that <kbd>diesel-rs</kbd> is doing a lot of work behind the scenes, creating type-safe code to keep the dynamic runtime overhead low. However, this may significantly factor into bigger projects, but once compiled, the types help to avoid errors and make the service work smoothly. </p>
<p>We formatted the <kbd>curl</kbd> output to make it more readable and the output works just as expected. <kbd>serde</kbd> provides consistent serialization and deserialization of JSON objects; thus, the <kbd>comment</kbd> field is optional on input but is rendered as <kbd>null</kbd> on output. </p>
<p>While <kbd>diesel-rs</kbd> tries to abstract many database operations, it uses a <kbd>sql_query</kbd> interface (<a href="https://docs.diesel.rs/diesel/fn.sql_query.html">https://docs.diesel.rs/diesel/fn.sql_query.html</a>) to work with other SQL statements as well. However, more complex group by aggregations are not yet supported—even in the raw SQL interface—which is unfortunate. You can follow the progress on GitHub (<a href="https://github.com/diesel-rs/diesel/issues/210">https://github.com/diesel-rs/diesel/issues/210</a>).</p>
<p>Now that we know more about running queries with <kbd>diesel-rs</kbd>, let's move on to the next recipe. </p>


            

            
        
    </div>
<div><h1 class="header-title">Authentication on the web</h1>
                
            
            
                
<p>Running web services safely on public interfaces is itself challenge and a lot of things need to be taken care of. While many details fall within the job description of a security engineer, developers should adhere to at least a minimum set of best practices so they rightfully earn the trust of their users. At the start, there is transport encryption (TLS), which is something we did not include in any recipes in this chapter since reverse proxies and load balancers provide amazing and simple integration for this (and let's encrypt: <a href="https://letsencrypt.org/">https://letsencrypt.org/</a> provides free certificates). This chapter focuses on using the <kbd>actix-web</kbd> middleware infrastructure to authenticate requests via JWT (<a href="https://jwt.io/">https://jwt.io/</a>) at the application layer.</p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a Rust binary project using <kbd>cargo new authentication</kbd> and make sure that port <kbd>8081</kbd> is accessible from the localhost. To access the services, get a program such as <kbd>curl</kbd> or Postman to execute <kbd>POST</kbd>, <kbd>GET</kbd>, and more type web requests.</p>
<p>Finally, open the entire directory with VS Code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Authenticate your users in just a few steps:</p>
<ol>
<li>In <kbd>src/main.rs</kbd>, we start by declaring the required imports:</li>
</ol>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate actix_web;<br/>mod middlewares;<br/>use actix_web::{http, middleware, web, App, HttpResponse, HttpServer, Responder};<br/>use jsonwebtoken::{encode, Header};<br/>use middlewares::Claims;<br/>use serde_derive::{Deserialize, Serialize};<br/>use std::env;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>With that out of the way, we can take care of the more relevant bits. Let's declare a few basics for authentication and a handler that we want to access:</li>
</ol>
<pre style="padding-left: 60px">const PASSWORD: &amp;str = "swordfish";<br/>pub const TOKEN_SECRET: &amp;str = "0fd2af6f";<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>struct Login {<br/>    password: String,<br/>}<br/><br/>#[get("/secret")]<br/>fn authed() -&gt; impl Responder {<br/>    format!("Congrats, you are authenticated")<br/>}</pre>
<ol start="3">
<li>Next, we need a handler to log users in and create the token if they provide the expected password, as well as the <kbd>main()</kbd> function to set everything up: </li>
</ol>
<pre style="padding-left: 60px">fn login(login: web::Json&lt;Login&gt;) -&gt; HttpResponse {<br/>    // TODO: have a proper security concept<br/>    if &amp;login.password == PASSWORD {<br/>        let claims = Claims {<br/>            user_id: "1".into(),<br/>        };<br/>        encode(&amp;Header::default(), &amp;claims, TOKEN_SECRET.as_ref())<br/>            .map(|token| {<br/>                HttpResponse::Ok()<br/>                    .header(http::header::AUTHORIZATION, format!<br/>                    ("Bearer {}", token))<br/>                    .finish()<br/>            })<br/>            .unwrap_or(HttpResponse::InternalServerError().into())<br/>    } else {<br/>        HttpResponse::Unauthorized().into()<br/>    }<br/>}<br/><br/>fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    env::set_var("RUST_LOG", "actix_web=debug");<br/>    env_logger::init();<br/>    HttpServer::new(|| {<br/>        App::new()<br/>            .wrap(middleware::Logger::default())<br/>            .wrap(middlewares::JwtLogin)<br/>            .service(authed)<br/>            .service(web::resource("/login").route(web::post().to(login)))<br/>    })<br/>    .bind("127.0.0.1:8081")?<br/>    .run()<br/>}</pre>
<ol start="4">
<li>The <kbd>wrap()</kbd> call in the <kbd>main()</kbd> function already gives away some details—we are going to need middleware to take care of authentication. Let's create a new file, <kbd>src/middlewares.rs</kbd>, with the following code:</li>
</ol>
<pre style="padding-left: 60px">use actix_service::{Service, Transform};<br/>use actix_web::dev::{ServiceRequest, ServiceResponse};<br/>use actix_web::{http, Error, HttpResponse};<br/>use futures::future::{ok, Either, FutureResult};<br/>use futures::Poll;<br/>use jsonwebtoken::{decode, Validation};<br/>use serde_derive::{Deserialize, Serialize};<br/><br/>#[derive(Debug, Serialize, Deserialize)]<br/>pub struct Claims {<br/>    pub user_id: String,<br/>}<br/><br/>pub struct JwtLogin;<br/><br/>impl&lt;S, B&gt; Transform&lt;S&gt; for JwtLogin<br/>where<br/>    S: Service&lt;Request = ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,<br/>    S::Future: 'static,<br/>{<br/>    type Request = ServiceRequest;<br/>    type Response = ServiceResponse&lt;B&gt;;<br/>    type Error = Error;<br/>    type InitError = ();<br/>    type Transform = JwtLoginMiddleware&lt;S&gt;;<br/>    type Future = FutureResult&lt;Self::Transform, Self::InitError&gt;;<br/><br/>    fn new_transform(&amp;self, service: S) -&gt; Self::Future {<br/>        ok(JwtLoginMiddleware { service })<br/>    }<br/>}</pre>
<ol start="5">
<li>In the code in <em>step 4</em>, we see another struct that needs implementation: <kbd>JwtLoginMiddleware</kbd>. Let's add it to <kbd>src/middlewares.rs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">pub struct JwtLoginMiddleware&lt;S&gt; {<br/>    service: S,<br/>}<br/><br/>impl&lt;S, B&gt; Service for JwtLoginMiddleware&lt;S&gt;<br/>where<br/>    S: Service&lt;Request = ServiceRequest, Response = <br/>    ServiceResponse&lt;B&gt;, Error = Error&gt;,<br/>    S::Future: 'static,<br/>{<br/>    type Request = ServiceRequest;<br/>    type Response = ServiceResponse&lt;B&gt;;<br/>    type Error = Error;<br/>    type Future = Either&lt;S::Future, FutureResult&lt;Self::Response, <br/>    Self::Error&gt;&gt;;<br/><br/>    fn poll_ready(&amp;mut self) -&gt; Poll&lt;(), Self::Error&gt; {<br/>        self.service.poll_ready()<br/>    }</pre>
<p style="padding-left: 60px">The most important code can be found in the call function implementation where the request is passed through to apply the middleware (and authenticate the token):</p>
<pre>    fn call(&amp;mut self, req: ServiceRequest) -&gt; Self::Future {<br/>        if req.path() == "/login" {<br/>            Either::A(self.service.call(req))<br/>        } else {<br/>            if let Some(header_value) = <br/>            req.headers().get(http::header::AUTHORIZATION) {<br/>                let token = header_value.to_str().unwrap().<br/>                replace("Bearer", "");<br/>                let mut validation = Validation::default();<br/>                validation.validate_exp = false; // our logins don't <br/>                // expire<br/>                if let Ok(_) =<br/>                    decode::&lt;Claims&gt;(&amp;token.trim(), <br/>                    crate::TOKEN_SECRET.as_ref(), &amp;validation)<br/>                {<br/>                    Either::A(self.service.call(req))<br/>                } else {<br/>                    Either::B(ok(<br/>                        req.into_response(HttpResponse::Unauthorized()<br/>                        .finish().into_body())<br/>                    ))<br/>                }<br/>            } else {<br/>                Either::B(ok(<br/>                    req.into_response(HttpResponse::Unauthorized().<br/>                    finish().into_body())<br/>                ))<br/>            }<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>Before we can run the server, we also have to update <kbd>Cargo.toml</kbd> with the current dependencies:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>actix-web = "1"<br/>serde = "1"<br/>serde_derive = "1"<br/>env_logger = "0.6"<br/>jsonwebtoken = "6"<br/>futures = "0.1"<br/>actix-service = "0.4"</pre>
<ol start="7">
<li>Exciting—let's try it out! Start the server with <kbd>cargo run</kbd> and issue some <kbd>curl</kbd> requests:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling authentication v0.1.0 (Rust-Cookbook/Chapter08/authentication)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 6.07s<br/>     Running `target/debug/authentication`<br/>[2019-07-22T21:28:07Z INFO actix_web::middleware::logger] 127.0.0.1:33280 "POST /login HTTP/1.1" 401 0 "-" "curl/7.64.0" 0.009627<br/>[2019-07-22T21:28:13Z INFO actix_web::middleware::logger] 127.0.0.1:33334 "POST /login HTTP/1.1" 200 0 "-" "curl/7.64.0" 0.009191<br/>[2019-07-22T21:28:21Z INFO actix_web::middleware::logger] 127.0.0.1:33404 "GET /secret HTTP/1.1" 200 31 "-" "curl/7.64.0" 0.000784<br/><br/></pre>
<p style="padding-left: 60px">The following is the <kbd>curl</kbd> output for each request. First, the unauthorized request:</p>
<pre style="padding-left: 60px"><strong>$ curl -v localhost:8081/secret</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; GET /secret HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; <br/>&lt; HTTP/1.1 401 Unauthorized<br/>&lt; content-length: 0<br/>&lt; date: Mon, 22 Jul 2019 21:27:48 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact</pre>
<p style="padding-left: 60px">Next, we try to log in using an invalid password:</p>
<pre style="padding-left: 60px"><strong>$ curl -d "{\"password\":\"a-good-guess\"}" -H "Content-Type: application/json" <br/>  http://localhost:8081/login -v</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; POST /login HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; Content-Type: application/json<br/>&gt; Content-Length: 27<br/>&gt; <br/>* upload completely sent off: 27 out of 27 bytes<br/>&lt; HTTP/1.1 401 Unauthorized<br/>&lt; content-length: 0<br/>&lt; date: Mon, 22 Jul 2019 21:28:07 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact</pre>
<p style="padding-left: 60px">Then, we use the real password and receive a token back:</p>
<pre style="padding-left: 60px"><strong>$ curl -d "{\"password\":\"swordfish\"}" -H "Content-Type: application/json" <br/>  http://localhost:8081/login -v</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; POST /login HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; Content-Type: application/json<br/>&gt; Content-Length: 24<br/>&gt; <br/>* upload completely sent off: 24 out of 24 bytes<br/>&lt; HTTP/1.1 200 OK<br/>&lt; content-length: 0<br/>&lt; authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMSJ9.V_Po0UCGZqNmbXw0hYozeFLsNpjTZeSh8wcyELavx-c<br/>&lt; date: Mon, 22 Jul 2019 21:28:13 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact</pre>
<p style="padding-left: 60px">With this token in the <kbd>authorization</kbd> header (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization</a>), we can then access the secret resource:</p>
<pre style="padding-left: 60px"><br/><strong>$ curl -H "authorization: Bearer <br/>  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMSJ9.V_Po0UCGZqNmbXw0hYozeFLsNpjTZeSh8wcyELavx-  <br/>  c" http://localhost:8081/secret -v</strong><br/>* Trying ::1...<br/>* TCP_NODELAY set<br/>* connect to ::1 port 8081 failed: Connection refused<br/>* Trying 127.0.0.1...<br/>* TCP_NODELAY set<br/>* Connected to localhost (127.0.0.1) port 8081 (#0)<br/>&gt; GET /secret HTTP/1.1<br/>&gt; Host: localhost:8081<br/>&gt; User-Agent: curl/7.64.0<br/>&gt; Accept: */*<br/>&gt; authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMSJ9.V_Po0UCGZqNmbXw0hYozeFLsNpjTZeSh8wcyELavx-c<br/>&gt; <br/>&lt; HTTP/1.1 200 OK<br/>&lt; content-length: 31<br/>&lt; content-type: text/plain; charset=utf-8<br/>&lt; date: Mon, 22 Jul 2019 21:28:21 GMT<br/>&lt; <br/>* Connection #0 to host localhost left intact<br/>Congrats, you are authenticated⏎<strong> </strong></pre>
<p>Let's pull back the curtain and see how it works.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>JWTs are a great way to provide authentication combined with authorization in a web application. As demonstrated on the official website, a JWT consists of three parts: </p>
<ul>
<li>The header, providing meta-information about the token</li>
<li>Its payload, which is where the information is sent (JSON-serialized)</li>
<li>A signature to guarantee that the token wasn't changed in transport</li>
</ul>
<p>These parts are Base64-encoded and joined with <kbd>.</kbd> to form a single string. This string is put into the <kbd>authorization</kbd> header of an HTTP request (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization</a>). One important remark is that TLS is mandatory for this kind of authentication since the headers as well as everything else are sent in plaintext—everyone would be able to see the token. </p>
<p>The payload can contain anything you wish to carry back and forth as user information. However, there are special fields as well: <kbd>iss</kbd>, <kbd>sub</kbd>, and <kbd>exp</kbd>. <kbd>iss</kbd> provides the issuer's credentials (in whichever way), <kbd>sub</kbd> is the subject, and <kbd>exp</kbd> is the expiration timestamp. This is because JWTs can be used to authenticate via federation, that is, third-party services, as well. For this implementation, we are using a crate called <kbd>jsonwebtoken</kbd> (<a href="https://github.com/Keats/jsonwebtoken">https://github.com/Keats/jsonwebtoken</a>).</p>
<p>In <em>step 1</em>, we are simply setting up the imports—nothing special here. Only <em>step 2</em> provides something interesting: a hardcoded password (<strong>BAD</strong> security practice, but good enough for demonstration) as well as a hardcoded secret (also <strong>BAD</strong>). Real applications can use a secret store for the secret (for example, Azure Key Vault: <a href="https://azure.microsoft.com/en-in/services/key-vault/">https://azure.microsoft.com/en-in/services/key-vault/</a>) and a hash stored in a database for the password. In the same step, we are also declaring the input data structure for logging in—we care only about the password—as well as the handler for the path/secret, which should only work once we are logged in. </p>
<p>The following step creates the handler for logging in: if the password matches, the handler creates a new token containing the payload data (a struct called <kbd>Claims</kbd>) and the HMAC (<a href="https://searchsecurity.techtarget.com/definition/Hash-based-Message-Authentication-Code-HMAC">https://searchsecurity.techtarget.com/definition/Hash-based-Message-Authentication-Code-HMAC</a>) algorithm (HS256 by default) used to sign the token, and returns it. The handlers are then registered with the <kbd>App</kbd> instance, together with the new JWT authentication middleware implemented in the following steps. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><em>Step 4</em> and <em>step 5</em> take care of creating the middleware for validating JWT tokens. <em>Step 4</em> contains the <kbd>Claims</kbd> type mentioned previously; however, the rest of the code is a largely required boilerplate if the request and response types remains default. If we wanted to retrieve user information to pass to the handlers, we would look into defining custom requests. Only in <em>step 5</em> are we implementing the important part: the <kbd>call()</kbd> function. This function is called before every request is processed and decides whether to continue or stop propagating it. Obviously, the <kbd>/login</kbd> route is the exception and will always be passed on the handlers. </p>
<p>Every other route has to contain a header field called <kbd>authorization</kbd> and a type called <kbd>Bearer</kbd>, along with the token, for example, (truncated) <kbd>authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJ[...]8wcyELavx-c</kbd>. The <kbd>call()</kbd> function extracts the token and tries to decode it with its secret. If that works, the call is forwarded to the handler; if not, the user is clearly not authorized to access the resource—the same happens if there is no authorization header at all. <kbd>jsonwebtoken</kbd> validates the <kbd>exp</kbd> field by default as well (our <kbd>Claims</kbd> type does not have this), which is what we are turning off for this example. For brevity, we used <kbd>unwrap()</kbd> when parsing the header's bytes into a string. However, this can crash the thread if unknown bytes are encountered.</p>
<p>The return types here are imported from the <kbd>futures</kbd> library (<a href="https://docs.rs/futures/">https://docs.rs/futures/</a>) and provide the <kbd>Either</kbd> type (<a href="https://docs.rs/futures/0.1.28/futures/future/enum.Either.html">https://docs.rs/futures/0.1.28/futures/future/enum.Either.html</a>) as well as the <kbd>ok()</kbd> function (<a href="https://docs.rs/futures/0.1.28/futures/future/fn.ok.html">https://docs.rs/futures/0.1.28/futures/future/fn.ok.html</a>). Check their documentation to learn more.</p>
<p><em>Step 6</em> simply declares the additional dependencies, and in <em>step 7</em>, we get to run the server! Check the <kbd>curl</kbd> requests first—can you see what's off? Requests without authorization are blocked <em>before</em> logging happens. Additionally, we have marked the important bits in bold. </p>
<p>This concludes this chapter. We hope you enjoyed the web programming recipes. The next chapter covers something a lot closer to the metal: systems programming.</p>


            

            
        
    </div></body></html>