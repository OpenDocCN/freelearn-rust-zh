<html><head></head><body>
		<div id="_idContainer132">
			<h1 id="_idParaDest-158"><em class="italic"><a id="_idTextAnchor236"/>Chapter 11</em>: Further Resources and What's Next?</h1>
			<p>If you have worked your way through this entire book, reading and writing code in every section, that's fantastic! I don't believe there's a better way to learn the material, and now you have a functioning game. In addition, you probably spent a lot of time debugging when you made mistakes, tweaking when you wanted to have fun, and puzzling over the stranger bits that weren't explained as well as I'd like to think. However, you might still be wondering if you really learned anything, or if you just copied/pasted what I had without understanding it. Don't worry – that's normal, and that is why we're going to do a little bit of a review.</p>
			<p>In this chapter, we'll cover the following:</p>
			<ul>
				<li>A challenging review</li>
				<li>Further resources</li>
			</ul>
			<p>After this chapter is completed, you'll have validated what you have learned, and I hope to see your games on the web!</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor237"/>Technical requirements</h1>
			<p>There is a small amount of code in this chapter, found at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_11</a>. </p>
			<p>The final version of the game is also available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly</a>, and the deployed production version of the game is at <a href="https://rust-games-webassembly.netlify.app/">https://rust-games-webassembly.netlify.app/</a>. </p>
			<p>To complete the challenge, you'll need the latest version of the assets at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3JVabRg">https://bit.ly/3JVabRg</a></p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor238"/>A challenging review</h1>
			<p>Reviewing code in a book is a strange concept; after all, you can just flip back to the earlier chapters to review what you've learned, so why bother to reiterate that now? At the same time, I've taught a lot of classes, and if there's one thing that's consistent, it's that sometimes smart students sit quietly, listen, nod, and then leave the classroom without understanding anything that you've just said. The only way to get an understanding is to take the knowledge we've practiced so far and build something upon it. Fortunately, we have just the thing.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor239"/>What happened to the dog?</h2>
			<p>In <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, we did a quick game design session where we described how our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) would <a id="_idIndexMarker947"/>be chasing his dog, who was startled by a cat. Yet, in the proceeding nine chapters, there has been no sign of the dog. Simply put, adding the dog, and a cat, requires very little that you don't already know how to do and would have been redundant. Adding them will be a great way to reinforce what you've done and perhaps learn a new trick or two along the way. To add the dog will require a few steps, intentionally outlined here at a high level:</p>
			<ol>
				<li>Get the <a id="_idIndexMarker948"/>dog sprite sheet into the game: You'll need to take the sprite sheet, found in the <strong class="source-inline">sprite_sheets</strong> folder in the assets with the name <strong class="source-inline">dog_sheet</strong>. That's the dog in his running animation, ready to be put into place. Look at <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, to remind yourself how that works.</li>
			</ol>
			<p>Add a dog <strong class="source-inline">struct</strong>: There will need to be a dog <strong class="source-inline">struct</strong> in the game as one of the many game objects. It will look similar to the <strong class="source-inline">RedHatBoy</strong> object, which, as you've probably guessed, means you are likely to need a state machine, as we covered in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>. What would you use a state machine for? To make sure that the dog goes to the right at the start of the game, only to have him turn around and run back to RHB when RHB crashes. You would have states for running right and running left. The dog should also hold still right at the beginning, making sure to only take off after a moment, after which RHB gives chase.</p>
			<ol>
				<li value="2">Extend<a id="_idIndexMarker949"/> the <strong class="source-inline">WalkTheDogStateMachine</strong>: For the dog to hold still, and for RHP to ignore user commands, you're going to need to extend <strong class="source-inline">WalkTheDogStateMachine</strong> beyond the <strong class="source-inline">Ready</strong> state. We covered all of this in <a href="B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185"><em class="italic">Chapter 8</em></a>, <em class="italic">Adding a UI</em>.</li>
			</ol>
			<p>Of course, that's a simple way to add the dog, but this being a video game, you're only limited by your imagination. Probably the simplest thing to do would be to have the dog run off screen, and then run back after RHB falls over. You can also keep the dog on screen and have him safely navigate the platforms the same way that the player attempts to. That will mean a few more changes.</p>
			<ol>
				<li value="3">Add hints to the endless runner: In <a href="B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating an Endless Runner</em>, we created segments of the game based on where the player was and a random value. Each segment can also have "hints" for the dog, so it knows when to jump to get around the various obstacles.</li>
				<li>Make sure the dog barks: As a dog owner, there's one thing I know about them – they are not <em class="italic">silent</em>. Our dog should make noise, such as barking, using the same technology we covered in <a href="B17151_07_Final_PG_ePub.xhtml#_idTextAnchor166"><em class="italic">Chapter 7</em></a>, <em class="italic">Sound Effects and Music</em>. You can also add some running sound effects, as well as a crash when the user fails to get by a platform or hits a rock.</li>
				<li>Keeping score: The game doesn't really keep score, and it could. It uses a time-based model, racking up points the longer the player stays alive and adding bonuses every time the player completes a jump on a platform or slides under a box. There are a ton of choices. You'll keep that score in the <strong class="source-inline">Game</strong> object we initially implemented in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, and display it using the same technology we used in <a href="B17151_08_Final_PG_ePub.xhtml#_idTextAnchor185"><em class="italic">Chapter 8</em></a>, <em class="italic">Adding a UI</em>.</li>
				<li>Using slide: The tiles sprite sheet has a lot more graphics than just the little islands and the rock we've used so far. We've also got a slide animation, but we don't have <a id="_idIndexMarker950"/>anything short enough to slide under. Using the techniques from <a href="B17151_06_Final_PG_ePub.xhtml#_idTextAnchor139"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating an Endless Runner</em>, set up a segment that the player can slide under.</li>
			</ol>
			<p>It's a cliché, but the limits are really your imagination. Years ago, I taught a workshop on HTML5 game development where I provided the students with an <em class="italic">Asteroids</em> clone to start with. One of them returned the next week with a Mario-like platformer! </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Remember that each chapter of this book is reachable from a Git tag at the repository <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly</a>. In addition, the main branch contains the entire game, including my solutions to these challenges as they are completed. If you purchased this book early enough, you can even see me work on them live at <a href="http://www.twitch.tv/paytonrules">www.twitch.tv/paytonrul<span id="_idTextAnchor240"/>es</a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor241"/>Further resources</h1>
			<p>After working through this game and completing some of the challenges that I just mentioned, maybe you want to go even bigger with your next game. I hope you do. You can add particle effects, explosions, or an online scorekeeping system. You can also use this framework as the start of a completely original game. You can also decide to use this game as an introduction and start a completely new game of your own using a completely different framework. This section is meant to show you just a few of the options available to<a id="_idIndexMarker951"/> you now if you want to keep making games, especially with Rust and WebAssem<a id="_idTextAnchor242"/>bly.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor243"/>Using JavaScript libraries</h2>
			<p>This <a id="_idIndexMarker952"/>entire game has been written using Rust as our language of choice, effectively discarding the entire JavaScript ecosystem. That's been a deliberate choice, but it's not the only one. We could also have called into a Rust Wasm library from an existing JavaScript framework or could have used <strong class="source-inline">wasm-bindgen</strong> to enable calling out to a JavaScript library or framework from Rust code. The first is more practical, and a great way to introduce Rust into an existing JavaScript project. The second one is more<a id="_idIndexMarker953"/> fun, so naturally, we'll be taking a brief peek at that one, with an example written using PixiJS.</p>
			<h3>PixiJS </h3>
			<p><strong class="bold">PixiJS</strong> (<a href="https://pixijs.com/">https://pixijs.com/</a>) is a <a id="_idIndexMarker954"/>popular and productive JavaScript <a id="_idIndexMarker955"/>framework for making games and visualizations in JavaScript. It <a id="_idIndexMarker956"/>has a Canvas and WebGL-backed renderer, and it's a great way to get high-performance 2D graphics without writing WebGL shaders yourself. It supports a ton of<a id="_idIndexMarker957"/> cool features and is a lot faster than using the Canvas as we did in our game. It has screenshots like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer129">
					<img alt="Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)" src="image/Figure_11.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – A textured mesh (https://bit.ly/3JkhbXw)</p>
			<p>It is also a lot more complicated than our engine, which is one reason why this book does not use it, but it's great to try on your <em class="italic">next</em> game. To use JavaScript libraries from Rust code, you need to import functions using the <strong class="source-inline">wasm-bindgen</strong> library, as follows:</p>
			<p class="source-code">#[derive(Serialize, Deserialize)]</p>
			<p class="source-code">struct Options {</p>
			<p class="source-code">    width: f32,</p>
			<p class="source-code">    height: f32,</p>
			<p class="source-code">}</p>
			<p class="source-code">#[wasm_bindgen]</p>
			<p class="source-code">extern "C" {</p>
			<p class="source-code">    type Application;</p>
			<p class="source-code">    type Container;</p>
			<p class="source-code">    #[wasm_bindgen(method, js_name = "addChild")]</p>
			<p class="source-code">    fn add_child(this: &amp;Container, child: &amp;Sprite);</p>
			<p class="source-code">    #[wasm_bindgen(constructor, js_namespace = PIXI)]</p>
			<p class="source-code">    fn new(dimens: &amp;JsValue) -&gt; Application;</p>
			<p class="source-code">    #[wasm_bindgen(method, getter)]</p>
			<p class="source-code">    fn view(this: &amp;Application) -&gt; HtmlCanvasElement;</p>
			<p class="source-code">    #[wasm_bindgen(method, getter)]</p>
			<p class="source-code">    fn stage(this: &amp;Application) -&gt; Container;</p>
			<p class="source-code">    type Sprite;</p>
			<p class="source-code">    #[wasm_bindgen(static_method_of = Sprite, js_namespace </p>
			<p class="source-code">        = PIXI)]</p>
			<p class="source-code">    fn from(name: &amp;JsValue) -&gt; Sprite;</p>
			<p class="source-code">}</p>
			<p class="source-code">// This is like the `main` function, except for JavaScript.</p>
			<p class="source-code">#[wasm_bindgen(start)]</p>
			<p class="source-code">pub fn main_js() -&gt; Result&lt;(), JsValue&gt; {</p>
			<p class="source-code">    let app = Application::new(</p>
			<p class="source-code">        &amp;JsValue::from_serde(&amp;Options {</p>
			<p class="source-code">            width: 640.0,</p>
			<p class="source-code">            height: 360.0,</p>
			<p class="source-code">        })</p>
			<p class="source-code">        .unwrap(),</p>
			<p class="source-code">    );</p>
			<p class="source-code">    let body = </p>
			<p class="source-code">        browser::document().unwrap().body().unwrap();</p>
			<p class="source-code">    body.append_child(&amp;app.view()).unwrap();</p>
			<p class="source-code">    let sprite = </p>
			<p class="source-code">        Sprite::from(&amp;JsValue::from_str("Stone.png"));</p>
			<p class="source-code">    app.stage().add_child(&amp;sprite);</p>
			<p class="source-code">    console_error_panic_hook::set_once();</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p>I've hidden the <strong class="source-inline">use</strong> declarations, but <a id="_idIndexMarker958"/>this is a version of <strong class="source-inline">lib.rs</strong> from our game that just uses PixiJS to render a static screen. It's not much fun yet, but it's enough to demonstrate <a id="_idIndexMarker959"/>how, using the <strong class="source-inline">wasm_bindgen</strong> macro and the <strong class="source-inline">extern "C" struct</strong>, you can import any JavaScript functions into your Rust library that you may want to use. This allows you to use arbitrary JavaScript code in your Rust program, with a little bit of glue code to wire the parts together. In fact, this is exactly how <strong class="source-inline">web_sys</strong>, which we've been using all over the place, works.</p>
			<p>In order to use all that Pixi code, you'll need to add a reference to the <strong class="source-inline">pixi.js</strong> JavaScript library, and a quick and dirty way to do this is to add the following to <strong class="source-inline">index.html</strong>:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">  &lt;meta charset="UTF-8"&gt;</p>
			<p class="source-code">  &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;</p>
			<p class="source-code">  &lt;link rel="stylesheet" href="styles.css" type="text/css"</p>
			<p class="source-code">      media=         "screen"&gt;</p>
			<p class="source-code">  &lt;link rel="preload" as="image" href="Button.svg"&gt;</p>
			<p class="source-code">  &lt;link rel="preload" as="font" href=</p>
			<p class="source-code">  "kenney_future_narrow-webfont.woff2"&gt;</p>
			<p class="source-code">  <strong class="bold">&lt;script src="https://pixijs.download/release/pixi.js"&gt;</strong></p>
			<p class="source-code"><strong class="bold">  &lt;/script&gt;</strong></p>
			<p class="source-code">&lt;/head&gt;</p>
			<p class="source-code">...</p>
			<p>In a professional deployment environment, you'd probably want to use WebPack to bundle the JavaScript with your own source code, but this works for now. I've also removed our canvas element from the HTML because Pixi provides its own. </p>
			<p>In the <a id="_idIndexMarker960"/>Rust code, I was able to import the <strong class="source-inline">PIXI.Application</strong>, <strong class="source-inline">PIXI.Container</strong>, and <strong class="source-inline">PIXI.Sprite</strong> types from <strong class="source-inline">pixi.js</strong>, and I've also pulled in quite a few functions associated with them. This allowed me to <a id="_idIndexMarker961"/>use them in <strong class="source-inline">main_js</strong>, just like native Rust code. The example here is not professional, using <strong class="source-inline">unwrap</strong> all over the place, but it successfully creates a PixiJS application and then creates <strong class="source-inline">Sprite</strong> from a file we already had in our game. Then, it adds it to <strong class="source-inline">stage</strong>, which is a PixiJS concept that you can think of as the canvas. This code leads to a screen that looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer130">
					<img alt="Figure 11.2 – A rock&#13;&#10;" src="image/Figure_11.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – A rock</p>
			<p>Okay, it doesn't look like<a id="_idIndexMarker962"/> much, but the point is that you can use PixiJS in a Rust project by declaring the types you need using <strong class="source-inline">wasm-bindgen</strong>. We won't be covering all that here, but the docs for <strong class="source-inline">wasm-bindgen</strong> are extremely thorough at <a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html">https://rustwasm.github.io/wasm-bindgen/reference/attributes/index.html</a>.</p>
			<p>More importantly, maybe you don't like PixiJS, and you want to use <strong class="bold">PhaserJS</strong>; the same <a id="_idIndexMarker963"/>principle applies! You can use any of the great frameworks available to JavaScript programmers for game development, such <a id="_idIndexMarker964"/>as <strong class="bold">Three.JS </strong>and <strong class="bold">Babylon3D</strong>, provided <a id="_idIndexMarker965"/>you can include <a id="_idIndexMarker966"/>them in your WebAssembly project. But what if you don't want to use JavaScript at all but still want t<a id="_idTextAnchor244"/>o run on the web?</p>
			<h3>Macroquad</h3>
			<p><strong class="bold">Macroquad</strong> (<a href="https://macroquad.rs/">https://macroquad.rs/</a>) is one of <a id="_idIndexMarker967"/>many game development <a id="_idIndexMarker968"/>libraries written in Rust. The<a id="_idIndexMarker969"/> authors refer to it as a "<strong class="bold">game library</strong>", which is a way of saying it's not as fully featured as an entire framework, but it's more featured than just writing to the HTML Canvas element, as we did in our game. It supports WebAssembly out of the box, without writing any JavaScript. An example of the code in Macroquad is shown here:</p>
			<p class="source-code">use macroquad::prelude::*;</p>
			<p class="source-code">#[macroquad::main("BasicShapes")]</p>
			<p class="source-code">async fn main() {</p>
			<p class="source-code">    loop {</p>
			<p class="source-code">        clear_background(RED);</p>
			<p class="source-code">        draw_line(40.0, 40.0, 100.0, 200.0, 15.0, BLUE);</p>
			<p class="source-code">        draw_rectangle(screen_width() / 2.0 - 60.0, 100.0,</p>
			<p class="source-code">            120.0, 60.0, GREEN);</p>
			<p class="source-code">        draw_circle(screen_width() - 30.0, screen_height() </p>
			<p class="source-code">            - 30.0, 15.0, YELLOW);</p>
			<p class="source-code">        draw_text("HELLO", 20.0, 20.0, 20.0, DARKGRAY);</p>
			<p class="source-code">        next_frame().await</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This very <a id="_idIndexMarker970"/>simple example will compile and run on the web simply by specifying the target with <strong class="source-inline">cargo build --target wasm32-unknown-unknown</strong> – no JavaScript, no problem. Macroquad<a id="_idIndexMarker971"/> is great, but it's not really a full engine. So, what if you<a id="_idTextAnchor245"/> want that experience?</p>
			<h3>Bevy</h3>
			<p>Another <a id="_idIndexMarker972"/>choice with more features is <strong class="bold">Bevy</strong> (<a href="https://bevyengine.org/">https://bevyengine.org/</a>), which<a id="_idIndexMarker973"/> has <a id="_idIndexMarker974"/>been extremely popular since its initial announcement and supports WebAssembly. Its "Hello World" is very different from the Macroquad version and resembles the following:</p>
			<p class="source-code">use bevy::prelude::*;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    App::new().add_system(hello_world_system).run();</p>
			<p class="source-code">}</p>
			<p class="source-code">fn hello_world_system() {</p>
			<p class="source-code">    println!("hello world");</p>
			<p class="source-code">}</p>
			<p>The most unique part of this system is the <strong class="source-inline">add_system</strong> function, which allows you to add "systems" to the Bevy engine. Bevy uses a modern Entity Component System for its development, which is meant to aid in structuring your program as well as performance. It's gaining popularity extremely rapidly and moving faster than its documentation can keep up with. Currently, if you're looking to learn how to use Bevy for 2D and 3D games, your best bet is to get involved with the community here: <a href="https://bevyengine.org/community/">https://bevyengine.org/community/</a>. If you do, you'll be rewarded, as Bevy is a very advanced engine, but it doesn't have an <a id="_idIndexMarker975"/>editor such as Unity3D or Unreal. If you're looking for that, fortunately, you have an excellent option.</p>
			<h3>Godot </h3>
			<p>My first experiences with <a id="_idIndexMarker976"/>game development in Rust were using the<a id="_idIndexMarker977"/> Godot <a id="_idIndexMarker978"/>game engine (<a href="https://godotengine.org">https://godotengine.org</a>). Godot is a truly free and open source engine that's popular with hobbyists and professional game developers alike. It comes with its own built-in language, GDScript, out of<a id="_idIndexMarker979"/> the box but is also able to use Rust through its GDNative wrappers. Originally devised to allow the use of C and C++, GDNative works extremely well with Rust. It has a thriving community of its own, and you can download it <a id="_idIndexMarker980"/>here: <a href="https://godot-rust.github.io">https://godot-rust.github.io</a>.</p>
			<p>Using Godot will mean getting a fully featured 2D and 3D engine that's capable of competing with Unity3D at its best. It's possible that the entire time you were reading this book, you wanted to see a proper commercial game engine such as this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer131">
					<img alt="Figure 11.3 – A Godot game engine" src="image/Figure_11.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – A Godot game engine</p>
			<p>If so, Godot is the one for you. To see an example Godot program written in Rust, you can see the one I wrote at <a href="https://github.com/paytonrules/Aircombat">https://git<span id="_idTextAnchor246"/>hub.com/paytonrules/Aircombat</a>.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor247"/>Summary</h1>
			<p>The website <a href="https://arewegameyet.rs">https://arewegameyet.rs</a> asks the question, "<em class="italic">Is Rust ready for game development?</em>" and answers with, "<em class="italic">Almost.</em>" Respectfully, because it's a really cool site, I disagree. We have all of the tools that JavaScript developers had a few years ago, with all the advantages of an excellent type system and Wasm. We have far more tools than developers have had for most of game development history, and while we may not have our Unity or Unreal yet, we have everything we need to <em class="italic">build our own</em>. So, go out there, build your own games, extend the engine, and have fun! I hope I hear from you with far better games than this one. If you need help, want to show off your games, or just want to hang out with like-minded people, you can find me on the Rustacean Station Discord at <a href="https://discord.gg/cHc3Gyc">https://discord.gg/cHc3Gyc</a>. You can always find me as <strong class="source-inline">@paytonrules</strong> on Twitter, and I'd be really excited to hear from you.</p>
		</div>
	</body></html>