["```rs\n// A simple macro without arguments\nmacro_rules! one_plus_one {\n    () => { 1 + 1 };\n}\n```", "```rs\nfn main() {\n    println!(\"1 + 1 = {}\", one_plus_one!());\n}\n```", "```rs\n// A simple pattern matching argument\nmacro_rules! one_and_one {\n (plus) => { 1 + 1 };\n (minus) => { 1 - 1 };\n (mult) => { 1 * 1 };\n}\n```", "```rs\n    println!(\"1 + 1 = {}\", one_and_one!(plus));\n    println!(\"1 - 1 = {}\", one_and_one!(minus));\n    println!(\"1 * 1 = {}\", one_and_one!(mult));\n```", "```rs\nmod macros {\n    #[macro_export]\n    macro_rules! two_plus_two {\n        () => { 2 + 2 };\n    }\n}\n```", "```rs\nfn main() {\n    println!(\"1 + 1 = {}\", one_plus_one!());\n    println!(\"1 + 1 = {}\", one_and_one!(plus));\n    println!(\"1 - 1 = {}\", one_and_one!(minus));\n    println!(\"1 * 1 = {}\", one_and_one!(mult));\n    println!(\"2 + 2 = {}\", two_plus_two!());\n}\n```", "```rs\n$ cargo run\n Compiling custom-macros v0.1.0 (Rust-Cookbook/Chapter06/custom-\n  macros)\n Finished dev [unoptimized + debuginfo] target(s) in 0.66s\n Running `target/debug/custom-macros`\n1 + 1 = 2\n1 + 1 = 2\n1 - 1 = 0\n1 * 1 = 1\n2 + 2 = 4\n```", "```rs\nmacro_rules! strange_patterns {\n    (The pattern must match precisely) => { \"Text\" };\n    (42) => { \"Numeric\" };\n    (;<=,<=;) => { \"Alpha\" };\n}\n```", "```rs\n    #[test]\n    fn test_strange_patterns() {\n        assert_eq!(strange_patterns!(The pattern must match \n        precisely), \"Text\");\n        assert_eq!(strange_patterns!(42), \"Numeric\");\n        assert_eq!(strange_patterns!(;<=,<=;), \"Alpha\");\n    }\n```", "```rs\nmacro_rules! compare {\n    ($x:literal => $y:block) => { $x == $y };\n}\n```", "```rs\n    #[test]\n    fn test_compare() {\n        assert!(compare!(1 => { 1 }));\n    }\n```", "```rs\n#[derive(Debug)]\npub struct Response(usize);\npub fn register_handler(method: &str, path: &str, handler: &Fn() -> Response ) {}\n\nmacro_rules! web {\n    (GET $path:literal => $b:block) => { \n     register_handler(\"GET\", $path, &|| $b) };\n    (POST $path:literal => $b:block) => { \n     register_handler(\"POST\", $path, &|| $b) };\n}\n```", "```rs\n    use super::*;\n\n    #[test]\n    fn test_web() {\n        web!(GET \"/\" => { Response(200) });\n        web!(POST \"/\" => { Response(403) });\n    } \n```", "```rs\n$ cargo test\n   Compiling matching v0.1.0 (Rust-Cookbook/Chapter06/matching)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running target/debug/deps/matching-124bc24094676408\n\nrunning 3 tests\ntest tests::test_compare ... ok\ntest tests::test_strange_patterns ... ok\ntest tests::test_web ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests matching\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nHello World!\n```", "```rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n```", "```rs\n    println!(\"a vec: {:?}\", vec![1, 2, 3]);\n    println!(\"concat: {}\", concat!(0, 'x', \"5ff\"));\n    println!(\"MyStruct stringified: {}\", stringify!(MyStruct(10)));\n    println!(\"some random word stringified: {}\", stringify!\n     (helloworld));\n\n```", "```rs\n#[derive(Debug)]\nstruct MyStruct(usize);\n```", "```rs\n    println!(\"Running on Windows? {}\", cfg!(windows));\n    println!(\"From a file: {}\", include_str!(\"a.txt\"));\n    println!(\"$PATH: {:?}\", option_env!(\"PATH\")); \n```", "```rs\n    eprintln!(\"Oh no!\");\n    debug_assert!(true);\n```", "```rs\n$ cargo run\n   Compiling std-macros v0.1.0 (Rust-Cookbook/Chapter06/std-macros)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n     Running `target/debug/std-macros`\nHello, world!\na vec: [1, 2, 3]\nconcat: 0x5ff\nMyStruct stringified: MyStruct ( 10 )\nsome random word stringified: helloworld\nRunning on Windows? false\nFrom a file: Hello World!\n$PATH: Some(\"/home/cm/.cargo/bin:/home/cm/.cargo/bin:/home/cm/.cargo/bin:/usr/local/bin:/usr/bin:/bin:/home/cm/.cargo/bin:/home/cm/Apps:/home/cm/.local/bin:/home/cm/.cargo/bin:/home/cm/Apps:/home/cm/.local/bin\")\nOh no!\n```", "```rs\n// Repeat the statement that was passed in n times\nmacro_rules! n_times {\n    // `()` indicates that the macro takes no argument.\n    ($n: expr, $f: block) => {\n        for _ in 0..$n {\n            $f()\n        }\n    }\n}\n```", "```rs\n// Declare a function in a macro!\nmacro_rules! make_fn {\n    ($i: ident, $body: block) => {\n        fn $i () $body\n    } \n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_n_times() {\n        let mut i = 0;\n        n_times!(5, {\n            i += 1;\n        });\n        assert_eq!(i, 5);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_failing_make_fn() {\n        make_fn!(fail, {assert!(false)});\n        fail();\n    }\n\n    #[test]\n    fn test_make_fn() {\n        make_fn!(fail, {assert!(false)});\n        // nothing happens if we don't call the function\n    }\n}\n```", "```rs\nmacro_rules! default_enum {\n    ($name: ident, $($variant: ident => $val:expr),+) => {\n        #[derive(Eq, PartialEq, Clone, Debug)]\n        pub enum $name {\n            Invalid,\n            $($variant = $val),+\n        }\n\n        impl Default for $name {\n            fn default() -> Self { $name::Invalid }\n        }\n    };\n}\n```", "```rs\n    #[test]\n    fn test_default_enum() {\n        default_enum!(Colors, Red => 0xFF0000, Blue => 0x0000FF);\n        let color: Colors = Default::default();\n        assert_eq!(color, Colors::Invalid);\n        assert_eq!(Colors::Red as i32, 0xFF0000);\n        assert_eq!(Colors::Blue as i32, 0x0000FF);     \n    }\n```", "```rs\n$ cargo test\nCompiling custom-designators v0.1.0 (Rust-Cookbook/Chapter06/code-generation)\nwarning: function is never used: `fail`\n  --> src/lib.rs:20:9\n   |\n20 | fn $i () $body\n   | ^^^^^^^^^^^^^^\n...\n56 | make_fn!(fail, {assert!(false)});\n   | --------------------------------- in this macro invocation\n   |\n   = note: #[warn(dead_code)] on by default\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n     Running target/debug/deps/custom_designators-ebc95554afc8c09a\n\nrunning 4 tests\ntest tests::test_default_enum ... ok\ntest tests::test_make_fn ... ok\ntest tests::test_failing_make_fn ... ok\ntest tests::test_n_times ... ok\n\ntest result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests custom-designators\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n#![allow(unused_macros)]\n\nmacro_rules! print_debug {\n    (stdout, $($o:expr),*) => {\n        $(print!(\"{:?}\", $o));*;\n        println!();\n    };\n    (error, $($o:expr),*) => {\n        $(eprint!(\"{:?}\", $o));*;\n        eprintln!();\n    };\n    ($stream:expr, $($o:expr),*) => {\n        $(let _ = write!($stream, \"{:?}\", $o));*;\n        let _ = writeln!($stream);\n    }\n}\n```", "```rs\n    use std::io::Write;\n\n    #[test]\n    fn test_printer() {\n        print_debug!(error, \"hello std err\");\n        print_debug!(stdout, \"hello std out\");\n        let mut v = vec![];\n        print_debug!(&mut v, \"a\");\n        assert_eq!(v, vec![34, 97, 34, 10]);\n\n    }\n```", "```rs\n    macro_rules! mock {\n        ($type: ty, $name: ident, $ret_val: ty, $val: block) => {\n            pub trait $name {\n                fn $name(&self) -> $ret_val;\n            }\n\n            impl $name for $type {\n                fn $name(&self) -> $ret_val $val\n            }\n        };\n        ($name: ident, $($variant: ident => $type:ty),+) => {\n            #[derive(PartialEq, Clone, Debug)]\n            struct $name {\n                $(pub $variant: $type),+\n            }\n        };\n    }\n```", "```rs\n    mock!(String, hello, &'static str, { \"Hi!\" });\n    mock!(HelloWorld, greeting => String, when => u64);\n\n    #[test]\n    fn test_mock() {\n        let mystr = \"Hello\".to_owned();\n        assert_eq!(mystr.hello(), \"Hi!\");\n\n        let g = HelloWorld { greeting: \"Hello World\".to_owned(), \n        when: 1560887098 };\n\n        assert_eq!(g.greeting, \"Hello World\");\n        assert_eq!(g.when, 1560887098);\n    }\n```", "```rs\n$ cargo test -- --nocapture\nCompiling macro-overloading v0.1.0 (Rust-Cookbook/Chapter06\n /macro-overloading)\nwarning: trait `hello` should have an upper camel case name\n  --> src/lib.rs:53:19\n   |\n53 | mock!(String, hello, &'static str, { \"Hi!\" });\n   | ^^^^^ help: convert the identifier to upper camel case: `Hello`\n   |\n   = note: #[warn(non_camel_case_types)] on by default\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.56s\n     Running target/debug/deps/macro_overloading-bd8b38e609ddd77c\n\nrunning 2 tests\n\"hello std err\"\n\"hello std out\"\ntest tests::test_mock ... ok\ntest tests::test_printer ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests macro-overloading\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\n#![allow(unused_macros)]\n\nmacro_rules! set {\n ( $( $item:expr ),* ) => {\n        {\n            let mut s = HashSet::new();\n            $(\n                s.insert($item);\n            )*\n            s\n        }\n    };\n}\n```", "```rs\nmacro_rules! dto {\n    ($name: ident, $($variant: ident => $type:ty),+) => {\n        #[derive(PartialEq, Clone, Debug)]\n        pub struct $name {\n            $(pub $variant: $type),+\n        }\n\n        impl $name {\n            pub fn new($($variant:$type),+) -> Self {\n                $name {\n                    $($variant: $variant),+\n                }\n             }\n        }\n    };\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use std::collections::HashSet;\n\n    #[test]\n    fn test_set() {\n        let actual = set!(\"a\", \"b\", \"c\", \"a\");\n        let mut desired = HashSet::new();\n        desired.insert(\"a\");\n        desired.insert(\"b\");\n        desired.insert(\"c\");\n        assert_eq!(actual, desired); \n    }\n}\n```", "```rs\n    #[test]\n    fn test_dto() {\n        dto!(Sensordata, value => f32, timestamp => u64);\n        let s = Sensordata::new(1.23f32, 123456);\n        assert_eq!(s.value, 1.23f32); \n        assert_eq!(s.timestamp, 123456); \n    }\n```", "```rs\n$ cargo test\n Compiling parameter-ranges v0.1.0 (Rust-Cookbook/Chapter06\n  /parameter-ranges)\n  Finished dev [unoptimized + debuginfo] target(s) in 1.30s\n  Running target/debug/deps/parameter_ranges-7dfb9718c7ca3bc4\n\nrunning 2 tests\ntest tests::test_dto ... ok\ntest tests::test_set ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests parameter-ranges\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // The `tt` (token tree) designator is used for\n    // operators and tokens.\n    ($a:ident, $b: ident, $func:ident) => (\n        assert_eq!($a.len(), $b.len(),\n                \"{:?}: dimension mismatch: {:?} {:?}\",\n                stringify!($func),\n                ($a.len(),),\n                ($b.len(),));\n    )\n}\n```", "```rs\nmacro_rules! op {\n    ($func:ident, $bound:ident, $method:ident) => (\n        pub fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut \n        Vec<T>, ys: &Vec<T>) {\n            assert_equal_len!(xs, ys, $func);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                *x = $bound::$method(*x, *y);\n            }\n        }\n    )\n}\n```", "```rs\nop!(add_assign, Add, add);\nop!(mul_assign, Mul, mul);\nop!(sub_assign, Sub, sub);\n```", "```rs\n#[cfg(test)]\nmod test {\n\n    use std::iter;\n    macro_rules! test {\n        ($func: ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = \n                    iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = \n                    iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = \n                    iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        }\n    }\n\n    // Test `add_assign`, `mul_assign` and `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}\n```", "```rs\n$ cargo test\n Compiling dry-macros v0.1.0 (Rust-Cookbook/Chapter06/dry-macros)\n  Finished dev [unoptimized + debuginfo] target(s) in 0.64s\n  Running target/debug/deps/dry_macros-bed1682b386b41c3\n\nrunning 3 tests\ntest test::add_assign ... ok\ntest test::mul_assign ... ok\ntest test::sub_assign ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests dry-macros\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```"]