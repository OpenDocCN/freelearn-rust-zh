- en: '*Chapter 6*: Creating an Endless Runner'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Red Hat Boy** (**RHB**) can run, jump on a platform, and even crash into
    a rock and fall over. But once he starts running to his right, he just goes off
    the screen and is never seen again. There isn''t much to it, and if you wait long
    enough, the game even crashes with a buffer overflow error. In this chapter, we''ll
    make our game truly endless by generating new scenes as RHB runs that contain
    new obstacles and challenges. They will even contain randomness, and it all starts
    with RHB staying in one place! It''s a real trick.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring for endless running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a functioning endless runner and be
    able to create obstacles for RHB to hop over and slide under.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need all the assets at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets).
    Just like in the previous chapters, you can find the source code at [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_6).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/35pES1T](https://bit.ly/35pES1T)'
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run RHB left to right with an infinite background, we have two choices,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally generate a background, based on a pattern or mathematical formula.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Hanna-Barbera technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first option may appear more interesting or dynamic, the Hanna-Barbera
    technique is much simpler, and it's what we'll be using for Walk the Dog. What
    is the Hanna-Barbera technique? Well, for starters, it may not even go by that
    name, but that's what I'm calling it. Hanna-Barbera was an animation studio that
    ran a series of very popular cartoons from the '50s through to the '90s, including
    Tom and Jerry, The Flintstones, Scooby-Doo, Yogi Bear, and many more. If you were
    a child in any of those decades, you would wake up to "Saturday morning cartoons,"
    which were dominated by Hanna-Barbera properties. While the studio was known for
    their beloved characters, they were also known for cutting costs. They produced
    a lot of cartoons and needed to maximize the ways they could create them quickly
    and cheaply.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common traits of Hanna-Barbera cartoons was a repeating background.
    At the end of an episode of Yogi Bear, for example, Ranger Smith would start chasing
    Yogi Bear across Jellystone park. However, if you looked closely, Jellystone park
    appeared to have the same series of trees repeating (see [https://bit.ly/3BNuNXZ](https://bit.ly/3BNuNXZ)
    for an example). This money-saving technique is going to work great for our endless
    runner. We''ll use the same background element we''re using now and move it to
    the left as RHB runs to the right. Immediately after, it will become a copy of
    the same background, making two `Image` elements with the same source image. Once
    the first image moves completely off screen, we''ll move it so that it''s to the
    right of the second image. These two backgrounds will loop, creating the illusion
    of the background moving forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Sliding the canvas over the background'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Sliding the canvas over the background
  prefs: []
  type: TYPE_NORMAL
- en: This technique relies on three things. The first is that the background has
    to be seamless so that there is no visible seam between the two images. Fortunately,
    our background was built for this and it will work fine. The second is that the
    canvas window needs to be smaller than the background so that the entire background
    is never shown on screen. If we do this, then the first background can go entirely
    off screen to the left and then be moved to the right of the second background,
    all without any noticeable gaps or tearing. This is because this all happens outside
    the window's boundaries. I like to think of it as being offstage in a play, then
    scrambling over to the right-hand side behind the curtain.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we must use another illusion and freeze the main character in place.
    Instead of moving the character from left to right on the screen, the objects
    will move right to left, almost as if on a treadmill. Visually, this will look
    the same as if the character were running, and it has the advantage of fixing
    a bug where if the player keeps running right, their *x* position eventually overflows
    (becomes bigger than the i16 we are using to hold it) and the game crashes. We'll
    have to adjust our brains by changing the *x* velocity from what we expect, but
    once you get used to it, you'll find that it works quite easily. Let's get started
    with our scrolling background.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For another example of this technique, go to [https://bit.ly/3BPNBGc](https://bit.ly/3BPNBGc),
    which explains how this works in a game that continuously moves up, such as Doodle
    Jump.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing RHB in x
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can scroll the background as much as we want, but if we continue to simultaneously
    move RHB to the right at the same time, the effect will be having him run at double
    speed. Instead, we want RHB to run in place while the rocks and platforms move
    toward him as if they were on a conveyor belt. At the end of this section, we
    will see RHB run to the right into an empty white void as everything passes past
    him as if he were running past the end of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start in the `game::red_hat_boy_states` module and not update `x` in
    the `update` method of `RedHatBoyContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, RHB will run in place, with nothing moving around him. We
    are keeping `velocity` as is because that value is going to be used by the rest
    of the code base. For ease of use, we''ll add a few methods. First, let''s add
    an accessor to the `RedHatBoy` implementation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function works similar to several of our other accessors for `RedHatBoy`,
    making it easier to get at the `context` values. Next, let''s add a new implementation
    – `Walk` for the `Walk` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Walk` implementation is only available when the `WalkTheDog` enum is in
    the `Loaded` state and it flips `walking_speed` of `boy`. While `boy` is moving
    to the right, this means everything else is moving to the left. Now, in the `update`
    function of `WalkTheDog`, we can use that value to move everything else to the
    left. Right after updating `walk.boy`, we can update the `stone` and `platform`
    positions so that they match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a compiler error because `stone` doesn''t have a `move_horizontally`
    function. `Stone` is of the `Image` type and can be found in the `engine` module,
    while `position` on `Image` is private. We''ll keep things that way, and instead
    add `move_horizontally` to the `Image` implementation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Two things may bother you about this code. The first is that we are directly
    manipulating `position` on `Platform` but used a method on `Image`. This inconsistency
    is a *smell* that tells us that something isn't right with our code – in this
    case, `stone` and `platform` have two different interfaces to modify their positions,
    even though the code has been duplicated. For now, we'll leave this as is, but
    it's a hint regarding changes we may want to make later. The other is that we're
    updating the `bounding_box` and `position` values with the same thing. That's
    a refactoring we'll leave for the next section (putting a `position` on `Rect
    Point`), although you can do it now if you're feeling ambitious.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Code smell is a programming term that was coined by Kent Beck and popularized
    by Martin Fowler in his book *Refactoring*. If you're getting paid money to program,
    gaming or not, you should check this book out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should see RHB running in place as the rock and platform move beneath
    him:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Where did the rock go?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Where did the rock go?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to restart the server if changes don't seem to be showing up. I
    had to when deleting code, for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start moving the background by matching the `stone` and `platform` movement
    in the `update` function of `WalkTheDogupdate`. This change will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This small change will mean that RHB can now walk off the edge of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Look, the empty void!](img/Figure_6.03_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Look, the empty void!
  prefs: []
  type: TYPE_NORMAL
- en: However, we don't want this, so let's learn how to use two tiling backgrounds
    to simulate an infinite one.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get an infinite background, we''ll need two background images instead of
    one. We''ll start by storing `background` as an array instead of just one `Image`
    in `Walk`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause several compiler errors because `backgrounds` doesn''t exist;
    even if it did, the code expects it to be an `Imagearray`. Fortunately, the errors
    largely make sense and we can figure out what needs to be done. Moving once again
    to `initialize` in the `Game` implementation, let''s set up an array of `backgrounds`
    instead of just one when initializing `Walk`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's a little more going on here compared to our previous changes, so let's
    go through this code in more detail. The first thing we do is get the `width`
    property of `background`. This is the temporary variable that we created when
    we loaded `HtmlImageElement`, not the `background` property that's attached to
    `Walk` that we have been using. We have done this to prevent a borrow-after-move
    error during the initialization of `Walk`. Then. we made `Walk` take an array
    of `Image` objects, making sure to clone the `background` property the first time
    we create it. Finally, we made sure to position the second `Image` at `background_width`
    so that it will be lined up to the right of the first background, off screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we still aren''t done with compiler errors. This is because the background
    is being updated and drawn. We''ll make the simplest changes we can so that we
    can start compiling and running again. First, replace the `move_horizontally`
    code we just wrote in the `update` function with the following code, which loops
    through all the backgrounds and moves them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you use `iter_mut` so that `background` is mutable. Note that you''ll
    need to bind `walk.velocity()` to a temporary variable; otherwise, you''ll get
    a compiler error saying `cannot borrow ''*walk'' as immutable because it is also
    borrowed as mutable`. Now, you can update the `draw` function to draw all the
    backgrounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are looping through `backgrounds` again and drawing them, relying
    on the canvas to only show the backgrounds that are on screen. If you play the
    game while running this code, you''ll see that RHB runs farther but doesn''t run
    infinitely. This is because we aren''t cycling the backgrounds. If you run the
    game for long enough, you''ll see that the game also crashes with a buffer overflow
    error, but we''ll fix that in the next section. First, we need to get the backgrounds
    cycling. We can do that by replacing the loop in the `update` function with code
    that explicitly destructures the array, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start by replacing the `for` loop with `let [first_background, second_background]
    = &mut walk.backgrounds;` to get access to both backgrounds. Then, we move them
    both to the left, the same as we did in the loop, and we check whether the right-hand
    side of the image is negative. This means that the image is off screen, so we
    can go ahead and move it to the right-hand side of the other background. If you
    type this in, it won''t compile because `set_x` and `right` don''t exist on the
    `Image` struct. Open the `engine` module again so that we can add those to `Image`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added a `set_x` function that updates `position` and `bounding_box`,
    just like we did previously, and we had `move_horizontally` call it to avoid duplication.
    We also added a `right` function that calculates the right-hand side of `bounding_box`
    based on the current position. With that, RHB now runs to the right, forever!
    Well, until the buffer overflows and it crashes. Fortunately, we'll take care
    of that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for endless running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you've properly noticed a pattern. Every time we add a new feature,
    we start by refactoring the old code to make it easier to add it. This is generally
    a good practice in most forms of software development, and we'll be following
    that same pattern now. We identified a couple of code smells while creating the
    infinite background, so let's clean those up now, starting with dealing with all
    those casts.
  prefs: []
  type: TYPE_NORMAL
- en: f32 versus i16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We had to cast values several times to go from `i16` to `f32` and back again.
    This isn''t a safe operation; the maximum of `f32` is orders of magnitude larger
    than the maximum of `i16`, so there''s the potential for our program to crash
    on a big `f32`. `HtmlImageElement` uses `u32` types, so all the casting to make
    the compiler shut up isn''t even correct. We have two choices here:'
  prefs: []
  type: TYPE_NORMAL
- en: Take our data types (such as `Rect` and `Point`) and make them match `HtmlImageElement`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `Rect` and any other domain object to be our preferred, smaller, type and
    cast to the larger type on demand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I suppose we've been using the second choice so far – that is, cast at random
    to get the compiler to compile – but that's hardly ideal. While the first option
    is tempting as we won't have any casts, I prefer `Rect` and `Point` to be as small
    as possible, so we'll set those up to use `i16` as their values. This is more
    than large enough for any of our game objects, and the smaller size is potentially
    beneficial for performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The WebAssembly specification does not have an `i32` type, so an `i32` would
    be just as effective here. It also doesn't have an unsigned type, so it may be
    worth profiling to see which type is fastest. For our purposes, we'll go with
    the smallest reasonable size – `i16`. As a professor I once had would say, "We
    got to the moon on 16 bits!"
  prefs: []
  type: TYPE_NORMAL
- en: To get started with this approach, change all the fields in `engine::Rect` to
    be `i16` instead of `f32`. Then, follow the compiler errors. Start by getting
    it to compile, casting `i16` to `f32` as necessary. After getting it to compile
    and run again, look for anywhere we can cast from `i16` to `f32`, and remove it
    if possible. This will include looking at the `Land` event in the `Event` enum,
    which holds an `f32`, and switching it to an `i16`. Finally, look for anywhere
    you cast to `i16`, and see whetherit's still necessary. It will end up being in
    a lot of places but it shouldn't be too painful; in the end, there should only
    be a few necessary casts left. Do this slowly and carefully so that you don't
    get stuck as you work through the errors.
  prefs: []
  type: TYPE_NORMAL
- en: A more useful Rect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Rect` implementation only contains the `intersects` method, but there
    are two very useful methods it could use: `right` and `bottom`. If you look at
    the method we just wrote on `Image`, you will see that it''s a natural fit for
    a `right` function. Let''s go ahead and add it to `Rect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `right` and `bottom` methods will prevent that addition logic from
    getting smeared across the game logic. We''ve also refactored `intersects` to
    use these new methods. Now, let''s go back to the `Image` code we just wrote and
    update it to use the new `right` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While we're in `Image`, let's deal with the duplication of `position` and `bounding_box`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Rect's position
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An image containing a bounding_box `Rect` and a position `Point` is an accident
    that occurred due to our code evolving. So, the question is, which one do we want
    to keep? We could always keep `bounding_box` for the image, which would mean constructing
    a `Point` every time we draw because we need that for the `draw_entire_element`
    call. We could also create a `Dimens` structure that just has `width` and `height`,
    and construct a `Rect` every time we need it on the update. While I doubt that
    the cost of creating those objects is going to be noticeable, the fact that it's
    on every frame is bothersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll do instead is give `Rect` a `position` field – after all, that''s
    what the `x` and `y` coordinates of `Rect` are. This is a seemingly minor change
    but with far-reaching implications because we constantly initialize `Rect` with
    `x` and `y`. Fortunately, we can use the compiler to make this simpler for us.
    We''ll start by changing `Rect` to hold a `position` field, instead of `x` and
    `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `position` is going to cause compiler errors all over the place, as
    expected. We know that we frequently want to both access the `x` and `y` values
    and create a `Rect` using `x` and `y`, so to make it easier to work with, we''ll
    add two `factory` methods for `Rect`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we fix `Rect` everywhere, we will stop creating a `Rect` directly
    and instead use the new constructor methods. We''ll also add getters for `x` and
    `y` because we access those frequently, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This gives you most of the tools you will need to fix the compiler errors. I
    won't reproduce all of them, because there are quite a few and it's repetitive.
    There are two examples you can use to make take care of all but one error. The
    first is replacing every reference to `.x` or `.y` with references to the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you do that in the `intersects` method of `Rect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s the same but with `x` and `y` replaced with `x()` and
    `y()`. In addition to seeing errors while accessing `x` or `y`, you''ll see errors
    around creating `Rect` because the `position` field isn''t specified. You''ll
    want to replace creating `Rect` directly with using one of the constructor methods,
    as shown here in the implementation of `Image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking care of those compiler errors, which will show up in both the `engine`
    and `game` modules, will leave you with only one remaining failure. This can be
    found in the `set_x` method of `Image`. This is because we need to set the `bounding_box.x`
    value. Rather than using `position.x`, which will compile but expose us to errors
    if the internals of `Rect` change again, we''ll add a setter to the `Rect` implementation,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `Image`, we can fix the last compiler error by using `set_x`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the code is inconsistent when it uses setters versus
    when it uses public variables directly. In general, my rule of thumb is that dumb
    structures such as `Rect` don't need setters and getters, especially if we keep
    them immutable. However, if the internal structure changes, which it did here,
    then it's time to add an abstraction to hide the internals. This change, from
    `x` and `y` to a position, demonstrated the necessity of the setter after all.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should see RHB running to the right and jumping on and off
    the platform again. Make sure you check out this behavior each time you get to
    a successful compile since it is easy to make a mistake as you make a large number
    of small changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve prepared `Rect` to hold a `position`, we can remove the duplication
    of that data in `Image`. We''ll start by removing `position` from the `Image`
    struct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s follow the compiler and remove all references to `position` in
    the `Image` implementation. Fortunately, there are no longer any references to
    `position` outside of the `Image` implementation, so we can do this by making
    a few quick changes. These changes are shown here. Note how wherever we previously
    used `position`, we are now using `bounding_box.position` or `bounding_box.x()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've removed the duplication on `Image`, we're ready to get all of
    the obstacles in a level into one shared `trait` so that we can use them all in
    one list. Doing that will allow us to fix a bug that occurs when the buffer overflows
    due to running infinitely and prepare the code for dynamically adding many shared
    segments. Let's get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Obstacle traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the stone and the platform are separate objects on the `Walk` struct.
    If we want to add more obstacles to the game, we must add more fields to this
    struct. This is an issue if we want to have an endlessly generated list of things
    to jump over and slide under. What we''d like to do instead is keep a list of
    `Obstacles`, go through each one, and check what to do when `RedHatBoy` intersects
    them. Why do we want to do that? Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: It will eliminate the duplication for knocking out RHB, and eliminate *future*
    duplication that we'd have to create to continue with our current pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to treat each `Obstacle` as the same so that we can create obstacles
    on the fly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be able to remove any obstacles that have gone off screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll start by creating an `Obstacle` trait in the `game` module, with one
    new method named `check_intersection` and two that exist already on `Platform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Why these three methods? `stone` and `platform` are both going to implement
    `Obstacle`, and we''ll need to loop through them, `draw` them, and move them.
    So, that''s why the trait contains `move_horizontally` and `draw`. The new method,
    `check_intersection`, exists because a `platform` lets you land on it, whereas
    a `stone` doesn''t. So, we''ll need an abstraction that can handle intersections
    differently depending on the type of `Obstacle`. Now that we''ve created our `trait`,
    we can implement it on the `Platform` structure. We can start by pulling `draw`
    out of the `Platform` implementation and creating a `move_horizontally` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: I've elided the implementation of `draw` here because this method does not change.
    Meanwhile, `move_horizontally` mimics the code that is currently in `update`,
    which we identified as a code smell earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add the `check_intersection` function, which currently exists
    in the `update` method of `WalkTheDog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The version that''s been implemented for `Platform` should be very similar,
    without the references to `walk`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is largely the same but with one fairly significant optimization:
    instead of looping through every bounding box in `Platform`, this code uses `find`
    to get the first bounding box that''s intersected. If there is one (`if let Some(box_to_land_on)`),
    then we handle the collision. This prevents redundant checks after a collision
    is found. The rest of the code is a little bit shorter without the references
    to `walk`, which is nice. Now, we need to replace `Platform` in `Walk` with a
    reference to it on the heap, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We do have an alternative to using a trait object here, which would be using
    an enum containing every type of obstacle, just like we did with our state machine.
    The tradeoff to using dynamic dispatch, via the `dyn` keyword, is that a lookup
    table is stored in memory. The benefit of this is that we write less boilerplate
    code, and the code doesn't need to be updated every time we add an obstacle. In
    this case, I think `trait` works better in the same way that an enum works better
    for a state machine, but it's worth keeping that in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will cause two compiler errors that we can fix by making small changes.
    In the `initialize` method of `WalkTheDog`, we are not setting `platform` correctly
    when we create `Walk`, so let''s make a small change, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only a one-line change that involves replacing `platform` with `platform:
    Box::new(platform)`. The other fix is something you''ll remember being a smell
    – setting the position on `x` directly when `stone` uses a method called `move_horizontally`.
    This is why we created that method on the `Obstacle` trait on the `Platform` struct.
    This change can be found in the `update` function for `WalkTheDog`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Having both `platform` and `stone` have a `move_horizontally` function is a
    sign that those interfaces can be brought together, which we''ll do in a moment.
    Finally, we must replace the code that we moved into `check_intersection` with
    a call to that function. Just a little further down the `update` function, you''ll
    want to update the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The call to `check_intersection` goes before the check to see whether you've
    crashed into a stone and after the background updates. You may notice that the
    code for checking for collisions with a stone is different, in the sense that
    `boy` is always knocked out when you collide with it, but is it also conceptually
    the same because you are, once again, checking for a collision with an obstacle
    and then doing something. This is why we need to turn `stone`, which is currently
    an `Image type`, into an `Obstacle` type. But what type should it be?
  prefs: []
  type: TYPE_NORMAL
- en: Barriers versus platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need another type of `Obstacle` that cannot be landed on, and right now a
    `stone` is an `Image`. Adding features to `Image` isn't appropriate because an
    `Obstacle trait` is a `game` concept and `Image` is part of `engine`. Instead,
    we'll create a type of `Obstacle` that always causes the user to crash into it,
    called `Barrier`, and turn `stone` into that. It's a very dangerous stone.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a `Barrier` struct and implementing the `Obstacle`
    trait with placeholders, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: I generated this skeleton with `rust-analyzer` while using the `add-missing-members`
    action. In my editor (emacs), this is as simple as typing `c v`. In Visual Studio
    Code, simply click the lightbulb and choose `todo!` macro throws a runtime exception
    if this code is called without any implementation, and it is meant to signal temporary
    code that is there to please the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Right now, all `Barrier` objects have to be an `Image`, whereas a `Platform`
    uses a sprite sheet. You may want to use sprite sheets for everything, or even
    one sprite sheet for everything, and that's fine – better, even. We'll leave things
    as is here because we've redesigned this application enough already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we fill in all those `todo!` blocks, let''s add a typical `new` method
    to create the `Barrier` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can fill in the functions. The `draw` and `move_horizontally` functions
    can delegate to `Image`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The final function, `check_intersection`, will be a little different. Unlike
    a `Platform`, which `boy` can land on, a `Barrier` is always crashed into. The
    code for this already exists in the `update` method of `WalkTheDog` because it''s
    what we used for `stone`. Let''s mimic that implementation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`Barrier` isn''t being used anywhere yet. So, we could start by changing `stone`
    from an `Image` into a `Barrier`. However, we''re going to go a little further
    than that. We''re going to create a list in `Walk` that contains *all* the `Obstacle`
    types. This will let us reduce the amount of specific code in `Walk`, and it will
    make it far simpler to generate new obstacles on the fly. Remember that''s what
    we''re refactoring for. Let''s make our list and add it to the `Walk` struct,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''ve removed `platform` and `stone` from `Walk`, we''ll need to
    update the rest of its implementation and replace direct references to `stone`
    and `platform` with references to the `Obstacle` vector. This doesn''t mean we
    won''t ever mention `platform` and `stone` again; we still have to load the image
    and sprite sheet, but we''ll only mention it once. Once again, we''ll look at
    the compiler error messages, which are complaining a lot about the `initialize`,
    `update`, and `draw` methods in `WalkTheDog`. Let''s start by making changes to
    the `initialize` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re only changing the construction of the `Walk` construct, replacing the
    references to `stone` and `platform` by initializing the `obstacles` vector. The
    first item in the vector is now a `Barrier` but that''s just the `stone` object
    that we created earlier wrapped in the new `Barrier` struct. The second is the
    `platform` object that we created previously. Everything has to be in a `Box`
    so that we can use the `Obstacle` trait. The next few changes we''ll make must
    be done in the `update` method. We''ll rearrange the code a little bit to update
    `boy` first, then our backgrounds, and finally our `obstacles`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be no direct references to `stone` or `platform` in `update`.
    Now, the code for checking for the movement of obstacles and whether they intersect
    should only be four lines long and be at the bottom of the `update` method – and
    that''s generously counting the closing brace. Make sure you use the `iter_mut`
    method since we are mutating `obstacle` in the loop. One of the ways we can tell
    that we are moving in the right direction in our design is that we''re writing
    *less* code that works with *more* things. Finally, we will need to draw all our
    `obstacles`, which can be handled by updating the `draw` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we can use `for_each` and a plain `iter()`. As you may have guessed,
    when we want to add more obstacles to the screen, we will just add them to the
    `obstacles` list. At this point, the code should be working again; RHB should
    hop his way over a platform and a stone and then crash into it. Now, all we need
    to take care of is the crash that occurs if we let RHB keep running. We'll handle
    that next.
  prefs: []
  type: TYPE_NORMAL
- en: Removing obstacles as they go off screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you let RHB run to the right for long enough, you''ll see a crash message
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is from the log in the browser. Here, the images move farther
    and farther to the left until they eventually reach the maximum length of the
    signed 16-bit integer. This is happening because we''re never removing an obstacle
    from the obstacles Vec when they go off screen, and we should. Let''s add a line
    of code to the `update` function that goes right before we move and collide with
    the obstacles, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `retain` function will keep any `obstacles` that match the predicate that''s
    been passed in. In this case, this will happen if the rightmost point of the obstacle
    is to the right of the left edge of the screen. This means we''re looping through
    the list of obstacles twice. If we were using the nightly build of Rust, we could
    use the `drain_filter` function to avoid that, but our `obstacles` list should
    never be long enough for that to be an issue. For this code to compile, you''ll
    need to add one more method to the `Obstacle` trait – the `right` method for the
    rightmost point of `Obstacle`. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will need to be added to both the `Platform` and `Barrier` implementations
    of `Obstacle`. `Barrier` can just delegate to the image it''s holding, `Platform`
    is a little trickier because it has more than one box. We want to use the right
    edge of the last bounding box, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code gets the last bounding box with `last` and unwraps it since `last`
    returns an `Option`. We don't want to return a `Result` and then force everybody
    to use a `Result`, so we are using `unwrap_or(&Rect::default())` to return an
    empty `Rect` when `Platform` has no bounding boxes. One empty bounding box is
    effectively the same as no bounding boxes. Then, we get the rightmost value of
    the last `Rect` with `right`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rect` doesn''t have a default implementation yet, so we''ll need to add a
    `#[derive(Default)]` annotation to the `Rect` and `Point` structures in `engine`.
    The annotation automatically implements the `Default` trait for a `struct` by
    using the default value of every field in that `struct`. `Point` will need the
    annotation because it is in the `Rectstructure`, so for the macro to work for
    `Rect`, it must also work for `Point`. Fortunately, there''s no real harm in adding
    this to them.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, you can let RHB run for as long as he wants, with no buffer overflow.
    Now, we need to give RHB many platforms to jump on. We will start by sharing the
    sprite sheet. Let's dig into this last piece of refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a sprite sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each `Platform` has a reference to an `Image` and a `Sheet` that we've casually
    been referring to as "the sprite sheet." When we start generating more `Platform`
    objects, we'll want to share a reference to the sheet. So, the time has come to
    add a `SpriteSheetstruct` to our engine to enable that. Let's open the `engine`
    module and add that new concept.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sprite sheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by creating a `struct` that holds both `HtmlImageElement` and
    `Sheet` in the `engine` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create an implementation that will wrap the common behaviors of
    the sheet that we''re using in `Platform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'I initially considered having `draw` take the name of the `cell` property we
    were drawing, but right now, our `Platform` draws more than one `cell` at a time,
    and we want to keep that functionality. Let''s replace `HtmlImageElement` and
    `Sheet` in `Platform` with the `SpriteSheet` field, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to import `SpriteSheet` from the `engine` module. Now, you can
    follow the compiler to simplify `Platform` by removing references to `Sheet` and
    `HtmlImageElement` and just using `SpriteSheet`. In particular, you''ll need to
    change the `new` function so that it takes one `SpriteSheet` instead of the two
    parameters. The following code shows how this can be initialized in the `initialize`
    method of `WalkTheDog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The rest of `Platform` can be modified to fit the new interface. Note how you
    no longer need to say `frames` and can just call `sheet.cell`. The `draw` method
    will now delegate to `self.sheet.draw` and pass it the `renderer` instead of an
    `Image`. This structure is small and wouldn't be worth the effort if we didn't
    want to share the same `SpriteSheet` across multiple `Platform` objects. But we
    do want to share one `SpriteSheet`, instead of duplicating that memory everywhere.
    Due to this, we need to make it possible to share it.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a sprite sheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To share `SpriteSheet` across more than one `Platform`, we'll need to store
    it somewhere that all of the platforms can point to, and designate something to
    be the owner of `SpriteSheet`. We could give `SpriteSheet` a `static` lifetime,
    and make it global, but that would mean making it an `Option` since it's not available
    until `initialize` is used. Instead, we'll store a reference-counted version of
    `SpriteSheet` in the `Walk` structure. This is a tradeoff since we'll be using
    reference counting instead of ownership to track when we should delete `SpriteSheet`,
    but in exchange, we'll only be duplicating the pointer in memory instead of an
    entire `SpriteSheet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `obstacle_sheet` to the `Walk` struct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll need to make sure you add `use std::rc::Rc` to the top of the `game`
    module. We''ll also need to make sure that `Platform` can take a reference-counted
    `SpriteSheet` instead of taking ownership of `SpriteSheet`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re replacing `SpriteSheet` with `Rc<SpriteSheet>`. This leaves us
    with one last modification we need to make – we must initialize the `Walk` struct
    and set up `obstacle_sheet` and the platform, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Two sections change in `initialize`. First, after we call `fetch_json` to get
    `tiles.json`, we use that to create a reference-counted `SpriteSheet` named `sprite_sheet`
    with `Rc::new`. Note that we've replaced `let platform_sheet` with `let tiles`
    because that's a better name – it's loading `tiles.json` after all. Then, when
    we create `platform` with `Platform::new`, we pass it a clone of the created sprite
    `_sheet`. Previously, this was done inline, but we're going to need `sprite_sheet`
    again in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when we're creating the `Walk` struct, we need to pass that created sheet
    to the `obstacle_sheet` field. This doesn't need to be cloned because `Walk` is
    the ultimate owner of `sprite_sheet`, so `sprite_sheet` can be moved into it.
    This will increment the reference counter and will not clone the entire `SpriteSheet`.
    We will need to clone `obstacle_sheet` every time we create a `Platform` to ensure
    the references are counted correctly, but don't worry about this – the compiler
    will force us to do this.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we're now ready to reevaluate how our `Platform` object works. Currently,
    it can only create one `Platform`, but there's no reason it can't create many
    things the player can stand on. We'll want that as we generate levels. We'll do
    that next.
  prefs: []
  type: TYPE_NORMAL
- en: Many different platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current `Platform` struct assumes it''s using the same three cells in the
    sprite sheet, including calculating the bounding boxes. So, to allow many kinds
    of platforms to be used, we''ll need to pass in the cells we want to be rendered
    from the sheet, and we''ll need to pass in custom bounding boxes for each potential
    `Platform`. For example, imagine that you wanted to take the provided tileset
    (`tiles.json`) and arrange them into a little cliff:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Look out below!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B17151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Look out below!
  prefs: []
  type: TYPE_NORMAL
- en: This would require passing the `11`, `2`, and `3` platform tiles. Those tiles
    aren't arranged horizontally or neatly, and the bounding boxes don't match our
    other platform. When we create this platform, we'll need to look up the tile dimensions
    in `tiles.json` and work out the bounding boxes from the provided dimensions manually.
    This means changing the way `Platform` works so that it's less specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by changing the `Platform` struct so that it can hold the bounding
    boxes and a list of the sprites, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re changing `Platform` to make it less specific, we''re also going
    to introduce an optimization: `Platform` will hold the sprite cells instead of
    looking them up every time they are drawn. There are two optimizations here because
    we are also storing the bounding boxes for `Platform` instead of calculating them
    every time they''re created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This change will break pretty much everything in the implementation of `Platform`,
    most notably the `new` constructor, which will need to take a list of sprite names
    and bounding boxes and then convert the sprite names into cells, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This isn't the entire `new` method, just the beginning. We started by changing
    the signature so that it takes four parameters. `sheet` and `position` were already
    there but the `new` method now takes a list of sprite names as a reference to
    an array of string slices. You can take a `Vec` of `String` objects, but it's
    a lot nicer to use the reference to string slices because it's much easier to
    call it. Clippy will also object to the code taking a `Vec<String>`, which we
    will cover in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing,
    Debugging, and Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do in the constructor is to use an iterator to look up every
    `Cell` in the sprite sheet via the `filter_map` call. We use `filter_map` instead
    of `map` because `sheet.cell` can return `None`, so we''ll need to skip any invalid
    sprite names. `filter_map` combines `filter` and `map` to automatically reject
    any options that have a value of `None` but `map` the inner value if it is present.
    The `cloned` method on `Option` will return an `Option<T>` for any `Option<&T>`
    by cloning the inner value. We use this to take ownership of the inner `Cell`.
    Let''s continue with our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We continue by taking the passed-in bounding boxes, which are of the `&[Rect]`
    type, and converting them into a `Vec<Rect>` to be owned by the `Platform` struct.
    However, instead of just calling `collect` or `to_owned`, we take each `Rect`
    and adjust its `position` by the actual `position` of `Platform`. So, `bounding_boxes`
    will need to be passed in relative to its image, where the image starts at `(0,0)`.
    Imagine that the image you're drawing is positioned in the top-left corner. The
    bounding boxes are then "drawn" around them, skipping any transparency that's
    relative to the top-left corner. Then, everything is moved to the right spot in
    the game. That's the mental model I use to prevent confusion when I'm specifying
    the bounding boxes later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Rust has some pretty good tools for functional-style programming, such as `filter`
    and `map`. It's worth getting to know them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Having four parameters is a lot for a constructor, so you should probably consider
    replacing this code with the `Builder` pattern. We did not do this here because
    it would distract from the topic at hand, but it is a worthwhile code improvement.
    For an example of this, take a look at the unofficial *Rust Design Patterns* book
    here: `https://bit.ly/3GKxMld`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also need to change the function for retrieving `bounding_boxes`, which
    gets a lot smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was a lot easier! Make sure you return a reference to `Vec` and
    not a `Vec`.instance We don''t need to make any more calculations here; `Platform`
    is being passed its bounding boxes. The rest of the implementation for `Platform`
    won''t be so easy, as we''ll need to modify `move_horizontally` and `draw` to
    account for these changes. The change that needs to be made to `move_horizontally`
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The original code only moved position because `bounding_boxes` was calculated
    on demand. Now that `bounding_boxes` is stored on `Platform`, this needs to be
    adjusted every time we move `Platform`. Otherwise, you'll have images for `Platform`
    in one place, the bounding boxes in another, and very strange bugs. Ask me how
    I know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s update the `draw` function for the new structure. Whereas the
    original implementation assumed that it was three cells wide and looked up each
    cell on each draw, the new implementation will loop through every cell and draw
    it individually. It will also need to account for the width of each cell. So,
    if the cells are `50` pixels wide, then the first cell will be positioned at `0`,
    the second at `50`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This isn't my favorite code in the world, but it gets the job done. It starts
    by creating a local, temporary `x` that will calculate the offset from `position`
    for each `Cell`. Then, it loops through the sprites, drawing each one but adjusting
    them for both `position` and `x`. Note how, in the destination `Rect`, we advance
    the `x` position with `self.position.x + x`. This ensures each `cell` is drawn
    to the right of the previous one. Finally, we calculate the next `x` position
    based on the width of `cell`. This implementation of `draw` does not use the `destination_box`
    method, which means nobody uses it, and you can safely delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This code assumes that `width` is variable but `height` is constant and that
    the sprites move from left to right. Here, a two-level platform would need to
    be constructed with two platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '`Platform` should now work with any list of sprites that we can construct it
    with. Now, all we need to do is initialize `Platform` properly in `WalkTheDog::initialize`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With that, `Platform` has been created with two more parameters – the list of
    tiles and the list of bounding boxes – making up the platform we've had all along.
    Notice that we can now pass in a simple array of strings for the names of the
    sprites. This is because we accept the `&[&str]` type as a parameter instead of
    a `Vec<String>`. You may be wondering where I got the three bounding box rectangles
    from. After all, previously, we were calculating them in the `bounding_boxes`
    method, using offsets. I simply looked in `tiles.json` and did the math, factoring
    in the offsets we used earlier. These are the same measurements as the bounding
    boxes were when we calculated them. You may also be wondering why these don't
    use constants, especially after I extolled the virtues of using constants in [*Chapter
    5*](B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114), *Collision Detection*. That's
    because we're going to create those in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be back to where you started – with RHB waiting to
    jump over a rock. Now, we are ready to create a stream of dynamic segments. At
    the end of the next section, you'll have the constructs you will need for an endless
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The initial screen we''ve been looking at for so long, with RHB jumping from
    a stone onto a platform, is what we''re going to call a "segment." It''s not a
    technical term, just a concept we''ve made up for the sake of generating them.
    As RHB moves to the right (that is, when all the obstacles move to the left),
    we''ll generate new segments to the right, which is just off screen. We''ll create
    these as segments so that we can control what is generated and how they fit together.
    Think of it like this: if we generated obstacles at random, then our platforms
    would look messy and would arrange themselves in an unbeatable fashion, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – A truly random level](img/Figure_6.05_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – A truly random level
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what we'll do is create a segment where the first one looks exactly
    like our one platform and one rock, and have them string together via a "timeline"
    value that's stored in `Walk`. This timeline will represent the right-hand side
    of the last segment in `x`. As that value gets closer to the edge of the screen,
    we'll generate another new segment and move the timeline back out. With this approach,
    RHB will be able to run for as long as we like, and we will have the freedom of
    a level designer. We will be able to create segments that are both easy and hard
    to navigate, though we'll need to make sure they all interlock and can be beaten.
    This is the fun part!
  prefs: []
  type: TYPE_NORMAL
- en: Creating one segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start by taking the introductory screen and creating it as a segment.
    Let's do this by creating a new file called `segments.rs`, making sure to add
    `mod segments` to the `lib.rs` file. This module isn't created for the typical
    software design reasons; usually, it's because `game.rs` is getting pretty long
    and these segments are closer to being levels than they are true code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `game.rs` can be broken down into a module with separate files
    using a directory with a `mod.rs` file. We're not doing this here because I find
    it gets harder to explain where new code goes – at least in book form – when we
    have a large number of files. If you are comfortable with doing this, then feel
    free to break this down into smaller chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each segment will be a function that returns a list of obstacles. Let''s create
    a public function in `segments.rs` that returns the same list that the game is
    initialized with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Look, constants! We want the segments module to look as data-driven as possible,
    so we'll be using constants throughout this file. This section of code doesn't
    compile because the `create_floating_platform` function doesn't exist yet, but
    it does the same things that the corresponding code in the `initialize` method
    of `WalkTheDog` does. The only differences are that it uses the `create_floating_platform`
    function, which doesn't exist, and some constants that also do not exist.
  prefs: []
  type: TYPE_NORMAL
- en: The function itself takes `HtmlImageElement` from `stone` and `Rc<SpriteSheet>`
    to create `Barrier` and `Platform`, respectively, but it also takes an `offset_x
    value`. That's because while the first `Barrier` and `Platform` may be at `150`
    and `200`, respectively, in the future, we'll want those to be that many pixels
    away from the timeline. It returns a vector of obstacles, which we can use in
    the `initialize` method of `WalkTheDog` and anywhere else that we generate segments.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we used an `Rc` for `SpriteSheet` but just take ownership
    of `HtmlImageElement`, which may need to be cloned when it's called. Nice catch!
    You may wish to consider making `HtmlImageElement` an `Rc` as well. `HtmlImageElement`
    is small enough that it's probably fine if we clone it, but it may be worth investigating
    in [*Chapter 9*](B17151_09_Final_PG_ePub.xhtml#_idTextAnchor203), *Testing, Debugging,
    and Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by creating the function that''s missing – that is, `create_floating_platform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty small function in that it just delegates to the `Platform`
    constructor and passes along important information. As you can see, there are
    two new constants to go along with the others in `stone_and_platform`. I told
    you that the constants would come back!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use `Rect::new_from_x_y` when you're declaring `FLOATING_PLATFORM_BOUNDING_BOXES`,
    you'll need to declare it and `Rect::new` as `pub const fn`.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the segments module consists of constants and `use` statements.
    You can infer the values for all the constants from the code we used earlier,
    or just check out [https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs](https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/blob/chapter_6/src/segments.rs).
    Reproducing that code here would amount to padding. By putting all the values
    in constants, the code looks increasingly data-driven, with functions just returning
    the data we want for every segment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to serialize these segments into JSON using `serde` and then read
    them in from JSON files instead of having the levels be written in Rust code.
    This is an experiment that you can undertake; I prefer the Rust code version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve filled in the constants and the `use` statements, you can use
    the new `stone_and_platform` function in the `initialize` method of `WalkTheDog`.
    Yeah, that one again. Let''s replace the hardcoded list of obstacles with a call
    to this new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you import `stone_and_platform` from `segments`! Now that we've got
    a function to create the initial scene, we can add a timeline and start generating
    scenes again and again. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that this puts a circular dependency between `segments`
    and `game`. You're right. To fix this, take anything that `segments` depends on
    that is in `game` and put it in another module that both `game` and `segments`
    depend on. This has been left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to initialize the timeline at the width of a segment. We can calculate
    this by finding the right-most point in the list of obstacles, and we''ll use
    those cool functional constructs we used earlier. This will be a standalone function
    that we can keep in the `game` module, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This function goes through a `vec` of `Obstacle` and gets its `right` value.
    Then, it uses the `max_by` function to figure out the maximum value on the right.
    Finally, it uses `unwrap_or` because while `max_by` can technically return `None`,
    if it does that here, then we have completely screwed up and may as well shove
    all the graphics onto the leftmost part of the screen. Now that we have this function,
    we can add a `timeline` value to the `Walk` struct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We also added a reference to `HtmlImageElement` because we''ll need that later.
    We will now initialize `Walk` – yes, we''re back in that function again – with
    `stone` and `timeline`. We''ll have to tweak the code slightly to deal with the
    borrow checker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we bind `starting_obstacles` and `timeline` before we initialize `Walk`
    since we wouldn't be able to get `timeline` as we've moved `obstacles` already.
    Note how we now clone `stone` when we pass it into `stone_and_platform`. We'll
    need to do this from now on because each `Barrier` obstacle owns an `Image` and,
    ultimately, its `HtmlImageElement`. Finally, we pass `stone` and `timeline` into
    the `Walk` struct. Now that we have a `timeline field` we can update it, by moving
    the rightmost edge of the generated obstacles to the left on each update, and
    respond to it by generating more obstacles as necessary. Our `Canvas` is still
    `600` pixels wide, so let's say that if there are no obstacles at the rightmost
    point past `1000`, we need to generate more.
  prefs: []
  type: TYPE_NORMAL
- en: 'These changes belong in the `update` method of `WalkTheDog`, at the end of
    the update logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: After moving the obstacles, we check whether `walk.timeline` is `< TIMELINE_MINIMUM`,
    which is set to `1000` at the top of the module. If it is, we create another `stone_and_platform`
    segment at `walk.timeline + OBSTACLE_BUFFER`, which is another constant that's
    set to `20`. Why `20`? We needed a little buffer to make sure the segments weren't
    right on top of each other, and `20` seemed fine. You could use a larger number
    or none at all. Then, we update `walk.timeline` to the `rightmost` point of the
    new obstacles, and we append those obstacles to the list, ready to be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `walk.timeline` is beyond `TIMELINE_MINIMUM`, we simply decrease it by RHB''s
    walking speed until the next update. Upon adding this code, you should see something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – As one platform ends, another beckons](img/Figure_6.06_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – As one platform ends, another beckons
  prefs: []
  type: TYPE_NORMAL
- en: That's right – you have an endless runner! So, how come we're only halfway through
    this book? Well, our runner is a little dull, seeing as it only has the same two
    objects over and over again. How about we add some randomness and creativity with
    multiple segments?
  prefs: []
  type: TYPE_NORMAL
- en: Creating segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating random segments means using the random library to choose a different
    segment each time one is needed. Let''s start by extracting the code we wrote
    previously into a function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: '`WalkTheDog` has a bad case of `WalkTheDog` and into `Walk`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `Walk` can generate the next segment, we''ll use the `random` crate
    from [*Chapter 1*](B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015), *Hello WebAssembly*,
    to choose the next segment. Of course, we only have one segment, so that won''t
    mean much. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to add `use rand::prelude::*;` at the top of the file. This generates
    a random number between `0` and, well, `0`. Then, it matches that value and generates
    the selected segment, which in this case will always be `stone_and_platform`.
    There''s a default case here, but that''s just to quiet the compiler – it can''t
    happen. I''ll create a second segment called `platform_and_stone` that is the
    same as the first one except it flips the position of `stone` and `platform`,
    and then puts the platform higher by using the `HIGH_PLATFORM` constant we created
    earlier. Now, the `generate_next_segment` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see that I get two segments, both of which are called in the
    same way. Make sure `gen_range` now generates a number from `0` to `2`. Upon running
    this code, I get to see a new segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Who moved that rock?](img/Figure_6.07_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Who moved that rock?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to copy/paste the preceding code, it won''t work since you don''t
    have `platform_and_stone`. This hasn''t been included here because you have all
    the knowledge you need to create your *own* segments. You can start by copying/pasting
    `stone_and_platform` and tweaking its values. Then, you can try creating platforms
    with the sprite sheet. Remember that you''re not limited to just the three images
    in our sprite sheet. The entire sheet looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The sprite sheet](img/Figure_6.08_B17151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: You can use this to make larger platforms, steps, and even cliffs. Try making
    a few different shapes. Try making smaller platforms by skipping the middle tile
    in the platform we've been using. RHB can slide; can you make something for him
    to slide under?
  prefs: []
  type: TYPE_NORMAL
- en: For a real challenge, take a look at the water sprites. Currently, RHB can't
    fall through the ground since we're using a `FLOOR` variable, but what if we didn't?
    Could RHB drown? Fall off a cliff, perhaps? It's time to become a game designer!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time for a confession. If you're like me, a programmer, that means you're
    probably sitting in a room with a bunch of books like this one behind you. Of
    those books, you've probably only opened half of them, and you've probably only
    read one or two of them cover-to-cover. Harry Potter notwithstanding.
  prefs: []
  type: TYPE_NORMAL
- en: Great news! At this point, you've made an endless runner. It's got no sound,
    the collision boxes are pretty big (have you tried to go under a platform yet?),
    and there's no menu system, but at this point, you have a game. You have the skeleton
    to make it more fun as you play around, and you're welcome to use this to make
    even larger or completely different endless runners. I wouldn't hold it against
    you if you stopped following along at this point, because you've learned a ton.
  prefs: []
  type: TYPE_NORMAL
- en: But if you do decide to stick around for the next chapter, we'll be adding a
    requirement for immersion that's required for any game – *sound*. Don't you want
    to hear what RHB sounds like?
  prefs: []
  type: TYPE_NORMAL
