<html><head></head><body>
        

                            
                    Assessments
                
            
            
                
<h1 id="uuid-eb328e74-f266-4d80-b3d4-6e9d32366d65" class="mce-root">Chapter 1</h1>
<ol>
<li>Yes, it is <em>The Rust Programming Language</em> by Steve Klabnik and Carol Nichols.</li>
<li>In 2015, it was long 64 bits (or 8 bytes). At the end of 2018, it was long 128 bits (or 16 bytes).</li>
<li>They are networking, command-line applications, WebAssembly, and embedded software.</li>
<li>It checks for non-idiomatic syntax and suggests changes to code for better maintainability.</li>
<li>It converts a 2015 edition project to a 2018 edition project.</li>
<li>Add this dependency to the <kbd>Cargo.toml</kbd> file: </li>
</ol>
<pre style="color: black;padding-left: 60px">rand = "0.6"</pre>
<p style="padding-left: 60px" class="mce-root">Then, add this code to the <kbd>main.rs</kbd> file: </p>
<pre style="color: black;padding-left: 60px">use rand::prelude::*;<br/>fn main() {<br/>    let mut rng = thread_rng();<br/>    let mut numbers = vec![];<br/>    for _ in 0..10 {<br/>        numbers.push(rng.gen_range(100_f32, 400_f32));<br/>    }<br/>    println!("{:?} ", numbers)<br/>}</pre>
<ol start="7">
<li>With the dependency used in the previous question, add this code to the <kbd>main.rs</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">use rand::prelude::*;<br/>fn main() {<br/>    let mut rng = thread_rng();<br/>    let mut numbers = vec![];<br/>    for _ in 0..10 {<br/>        numbers.push(rng.gen_range(100_i32, 401_i32));<br/>    }<br/>    println!("{:?} ", numbers)<br/>}</pre>
<ol start="8">
<li>Add this dependency to the <kbd>Cargo.toml</kbd> file: </li>
</ol>
<pre style="padding-left: 60px">lazy_static = "1.2"</pre>
<p style="padding-left: 60px">Then, insert this code into the <kbd>main.rs</kbd> file: </p>
<pre style="padding-left: 60px">use lazy_static::lazy_static;<br/>lazy_static! {<br/>    static ref SQUARES_FROM_1_TO_200: Vec&lt;u32&gt; = {<br/>        let mut v = vec![];<br/>        for i in 1.. {<br/>            let ii = i * i;<br/>            if ii &gt; 200 { break; }<br/>            v.push(ii);<br/>        }<br/>        v<br/>    };<br/>}<br/>fn main() {<br/>    println!("{:?}", *SQUARES_FROM_1_TO_200);<br/>}</pre>
<ol start="9">
<li>First, add this dependency to the <kbd>Cargo.toml</kbd> file: </li>
</ol>
<pre style="padding-left: 60px">log = "0.4"<br/>env_logger = "0.6"</pre>
<p style="padding-left: 60px">Then, insert this code into the <kbd>main.rs</kbd> file and execute <kbd>RUST_LOG=warn cargo run</kbd>:</p>
<pre style="padding-left: 60px">#[macro_use]<br/>extern crate log;<br/>fn main() {<br/>    env_logger::init();<br/>    warn!("Warning message");<br/>    info!("Information message");<br/>}</pre>
<ol start="10">
<li>Add this dependency to the <kbd>Cargo.toml</kbd> file: </li>
</ol>
<pre style="padding-left: 60px">structopt = "0.2"</pre>
<p style="padding-left: 60px">Then, add this code to the <kbd>main.rs</kbd> file: </p>
<pre style="padding-left: 60px">use structopt::StructOpt;<br/>#[derive(StructOpt, Debug)]<br/>struct Opt {<br/>    #[structopt(short = "l", long = "level")]<br/>    level: u32,<br/>}<br/><br/>fn main() {<br/>    let options = Opt::from_args();<br/>    if options.level &lt; 1 || options.level &gt; 20 {<br/>        println!("Invalid level (1 to 20 is expected): {}", options.level);<br/>    } else {<br/>        println!("Level is {}", options.level);<br/>    }<br/>}</pre>
<h1 id="uuid-e2ac6684-6cbe-41cb-b1cc-53228953d7fc" class="mce-root">Chapter 2</h1>
<ol>
<li>Because changes applied by software lose all the comments inserted by the user and sort the items in alphabetical order.</li>
<li>Dynamically typed parsing is better when you are not sure which fields will be present in the file and you want to allow some missing fields. Statically typed parsing is better when you want to discard files that do not respect the expected format.</li>
<li>A derive from <kbd>Serialize</kbd> is needed when you want to send (write) a data structure out of your software. A derive from <kbd>Deserialize</kbd> is needed when you want to receive (read) a data structure.</li>
<li>This is a format in which fields are indented to show the structure of the data visually.</li>
<li>Because it minimizes the use of memory by loading data into memory a little at a time.</li>
<li>SQLite is better when you want to save disk space, memory space, start up time, and sometimes also throughput. PostgreSQL is better when you have complex security needs, or when your data must be accessible for several users at a time.</li>
<li>This is a reference to a slice of references to objects that can be converted to <kbd>ToSql</kbd>.</li>
<li>This replaces the parameters in a SQL <kbd>SELECT</kbd> statement and then creates and returns an iterator on the rows selected by that statement.</li>
<li>The <kbd>get</kbd> function reads a value; the <kbd>set</kbd> function writes a value.</li>
<li>Let's use a local instance of Redis, already containing the association <em>aKey =&gt; a string</em>. Add this dependency to the <kbd>Cargo.toml</kbd> file: </li>
</ol>
<pre style="color: black;padding-left: 60px">redis = "0.16"</pre>
<p style="padding-left: 60px" class="mce-root">Then, add this code to the <kbd>main.rs</kbd> file:</p>
<pre style="color: black;padding-left: 60px">use redis::Commands;<br/><br/>fn main() -&gt; redis::RedisResult&lt;()&gt; {<br/>    let id = std::env::args().nth(1).unwrap();<br/><br/>    let client = redis::Client::open("redis://localhost/")?;<br/>    let mut conn = client.get_connection()?;<br/><br/>    if let Ok(value) = conn.get::&lt;_, String&gt;(&amp;id) {<br/>        println!("Value of '{}' is '{}'.", id, value);<br/>    } else {<br/>        println!("Id '{}' not found.", id);<br/>    }<br/>    Ok(())<br/>}</pre>
<h1 id="uuid-82a8d998-5b0a-49c5-a1dc-80c3c2bc3137" class="mce-root">Chapter 3</h1>
<ol>
<li><kbd>GET</kbd> requests a resource to be downloaded; <kbd>PUT</kbd> sends some data to replace existing data; <kbd>POST</kbd> sends some data that the server should consider as new; <kbd>DELETE</kbd> requests the removal of a resource.</li>
<li>The Curl utility.</li>
<li>The handler declares an argument, such as <kbd>info: Path&lt;(String,)&gt;</kbd>, and then the value of the <kbd>&amp;info.0</kbd> expression is a reference to the first URI parameter.</li>
<li>By using the <kbd>content_type</kbd> method of the <kbd>HttpResponse</kbd> type – for example, <kbd>HttpResponse::Ok().content_type("application/json")</kbd>.</li>
<li>Using a pseudo-random number generator, you generate a large integer number, format it as a string, and append that string to a prefix. Then, you try to create a new file having that name. If such creation fails because another file exists with that name, you try to generate another filename, until you find an unused combination.</li>
<li>To cache information that can be obtained again using any request, but for which it would be costly to do so.</li>
<li>Because the state is shared by all requests, and Actix web uses several threads to handle the requests, and so the state must be thread-safe. The typical way of declaring a thread-safe object in Rust is to encapsulate it in a Mutex object.</li>
</ol>
<ol start="8">
<li>Because the server may have to wait for the arrival of data from a database, the filesystem, or another process. During such a wait, it can serve other requests. Multithreading is another possible solution, but that yields an inferior performance.</li>
<li>It chains another future to the current one. The second closure will be executed asynchronously after the first one has finished.</li>
<li><kbd>serde</kbd>, to serialize anything; <kbd>serde_derive</kbd>, to automatically implement serialization for some data types; and <kbd>serde_json</kbd> to automatically implement serialization for JSON data.</li>
</ol>
<h1 id="uuid-8fa1ab9c-8f5b-4e3b-ae3e-40e14684f658" class="mce-root">Chapter 4</h1>
<ol>
<li>The possible strategies for creating HTML code containing variable parts are as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px"><strong>Code only</strong>: You have a programming language source file that contains a lot of statements that print strings to create the desired HTML page.</li>
<li style="padding-left: 30px"><strong>HTML with tags</strong>: You write an HTML file containing the desired constant HTML elements and the desired constant text, but it also contains some statements enclosed in specific markers.</li>
<li style="padding-left: 30px"><strong>HTML templates</strong>: You write HTML templates containing tags and application code that fills those tags.</li>
</ul>
<ol start="2">
<li>Double braces are used – for example, <kbd>{{id}}</kbd>.</li>
<li>The <kbd>{%</kbd> and <kbd>%}</kbd> markers are used, as shown here:</li>
</ol>
<pre style="color: black;padding-left: 60px">{%if person%}Id: {{person.id}}\<br/>{%else%}No person\<br/>{%endif%}</pre>
<ol start="4">
<li>First, an object of the <kbd>tera::Context</kbd> type is created, and then, the necessary name-value associations are added to such an object, using its <kbd>insert</kbd> method. Finally, that context is passed as an argument to the <kbd>render</kbd> method of the Tera engine.</li>
<li>At an architectural level, a request can be thought of as a data manipulation command, or as a request to get a document to display in the browser. Traditionally, the two kinds of requests were merged in a data manipulation command whose response is the new content of the current page.</li>
</ol>
<ol start="6">
<li>Because some parts (the metadata, the scripts, the styles, and possibly the page header and footer) do not change during the session or change rarely. Other parts (usually the central part, or a smaller part) change with any click from the user. By reloading only the part that changes, the app has better performance and usability.</li>
<li>The loading of all template files happens at runtime, and so the template's subtree must be deployed.</li>
<li>The built-in JavaScript <kbd>XMLHttpRequest</kbd> class can be instantiated, and such instances have methods to send HTTP requests. </li>
<li>It should be stored in a global JavaScript variable inside the current web page in the web browser.</li>
<li>A handler can have an argument of the <kbd>BasicAuth</kbd> type that encapsulates the authorization header of the HTTP request. Such an object has the <kbd>user_id</kbd> and <kbd>password</kbd> methods.</li>
</ol>
<h1 id="uuid-5a68e78b-b5a7-483d-9173-1f1b8df68e36" class="mce-root">Chapter 5</h1>
<ol>
<li>It is a standard machine language-like programming language, accepted by all major web browsers. It can be more efficient than JavaScript, but is more portable than other machine language-like programming languages.</li>
<li>It is an architectural pattern for interactive software. It uses the concepts of <em>model</em>, meaning the data structure that contains the state of the application; <em>view</em>, meaning the code that uses the current value of the model to display the contents of a window or a portion of a window; and <em>controller</em>, meaning the code that is activated by user actions on the window, updating the value of the model and activating the view refresh.</li>
<li>The specific version of the MVC implementation used by Yew and the Elm language is based on a collection of programmer-defined possible events, named <em>messages</em>. When the view detects such a possible event, the controller is notified by a message that's associated with the kind of event.</li>
<li>The Yew components are the instances of an MVC pattern. Every triple model-view-controller is a component.</li>
<li>The Yew properties are the data that any parent component passes to its child component when it creates them. They are needed to share data in a hierarchy of components.</li>
</ol>
<ol start="6">
<li>You create two Yew components – one that handles the inner section and one that handles the header and footer – and that one contains the other component as its child.</li>
<li>Callbacks are callable objects that a component passes as properties to one of its child components to let it access features of the parent component.</li>
<li>You pass it as a property, encapsulating it into an object of the <kbd>std::rc::Rc&lt;std::cell::RefCell&gt;</kbd> type.</li>
<li>Because if you keep it only in a local variable, it is destroyed when the function in which it is created ends. To ensure it survives until the arrival of the response from the server, this object must be kept in a structure that lives longer.</li>
<li>In your model, you declare an object of the <kbd>DialogService</kbd> type, and you use its <kbd>alert</kbd> and <kbd>confirm</kbd> methods.</li>
<li>It is left to the reader. I've created an example in the book's GitHub repo.</li>
</ol>
<h1 id="uuid-3e01803c-b6a3-423b-9b20-fa48485df6eb" class="mce-root">Chapter 6</h1>
<ol>
<li>It is an architecture of interactive software, used mainly in games. At periodic intervals, the framework checks the status of input devices, modifies the model accordingly, and then invokes the draw routine. Its advantage is that it better corresponds to a situation in which input devices have continuous input, such as a key being pressed for some time, or screen output changing continuously, even if the user does nothing.</li>
<li>When input events are discrete, such as a mouse click on a button or text typed into a box, and when output happens only because of a user action.</li>
<li>Continuous simulation software, industrial machine monitoring software, or multimedia software.</li>
<li>To draw a shape, you call the <kbd>draw_ex</kbd> method of the current window. The first argument of that method describes the shape to draw; it may be an instance of the <kbd>Triangle</kbd>, <kbd>Rectangle</kbd>, or <kbd>Circle</kbd> type.</li>
<li>In the <kbd>update</kbd> function, you can check the state of any key of the keyboard. For example, the <kbd>window.keyboard()[Key::Right].is_down()</kbd> expression returns <kbd>true</kbd> if the right-arrow key is pressed.</li>
<li>The model must implement the <kbd>State</kbd> trait. In that trait, the <kbd>update</kbd> method is the controller, and the <kbd>draw</kbd> method is the view.</li>
</ol>
<ol start="7">
<li>Quicksilver has two rates, one for the <kbd>update</kbd> method and one for the <kbd>draw</kbd> method. They have default values, but if you want to change them, set the <kbd>update_rate</kbd> and <kbd>draw_rate</kbd> fields of the <kbd>Settings</kbd> structure passed to the <kbd>run</kbd> function that starts the application. </li>
<li>You start to load a font by calling the <kbd>Font::load(filename)</kbd> function, you start to load a sound by calling the <kbd>Sound::load(filename)</kbd> function, and so on. Such calls return a future waiting for the actual asset to load. Then, you call the <kbd>Asset::new</kbd> function, specifying the future as its argument. The first time it is used, it will wait for the complete loading of the asset. The assets must be in a folder named <kbd>static</kbd> at the root of the project.</li>
<li>After having loaded a recorded sound asset in a variable, you may call the <kbd>play_sound</kbd> function, and pass that asset as an argument.</li>
<li>After having loaded a font asset in a variable, in the <kbd>draw</kbd> method,  you may call the <kbd>execute</kbd> method of that asset, which waits for the complete loading of the font, and then you call the <kbd>render</kbd> method of the loaded asset to draw the text in an image. Then, you can draw that image on the window by calling the <kbd>draw</kbd> method of the window.</li>
</ol>
<h1 id="uuid-bf2647b6-c792-4a80-afe5-7007bae409ce" class="mce-root">Chapter 7</h1>
<ol>
<li>A vector is an entity that can be added to another vector and can be multiplied by a number. It is senseless to add two points or to multiply a point by a number.</li>
<li>In geometry, a vector is a translation or displacement; a point is a position.</li>
<li>Because some events are discrete. For example, when I click on a button, I am not interested in how many milliseconds the mouse is pressed; I just want to get one click event. If I type a word, I want to get just one character input for every key pressed.</li>
<li>Because assets are usually loaded only at application startup, or when a level is entered or exited.</li>
<li>The optional <kbd>key_down_event</kbd>, <kbd>key_up_event</kbd>, <kbd>mouse_button_down_event</kbd>, and <kbd>mouse_button_up_event</kbd> methods can be defined for the <kbd>EventHandler</kbd> trait.  Such methods register in the model that they have been called (that is, that the corresponding events have happened in the time frame). Then, the <kbd>update</kbd> method checks and resets such settings in the model.</li>
<li>It is a set of shapes to draw. To draw a shape, first, you build a new <kbd>Mesh</kbd> instance, then you add shapes to it (rectangles, triangles, and so on), and then you can draw that mesh on the screen.</li>
</ol>
<ol start="7">
<li>The general way is to create a <kbd>MeshBuilder</kbd> instance by using <kbd>MeshBuilder::new()</kbd>; add shapes to that builder, with its methods (<kbd>rectangle</kbd>, <kbd>polygon</kbd>, and so on); and then call the <kbd>build</kbd> method, which returns a <kbd>Mesh</kbd> instance. But there are shorter ways, such as the <kbd>Mesh::new_circle</kbd> function, which returns a <kbd>Mesh</kbd> instance containing a single circle.</li>
<li>The <kbd>update</kbd> method is always called at top speed, but it checks the internal timer repeatedly to execute its body only the desired number of times.  </li>
<li>The <kbd>draw</kbd> function uses as arguments the context to receive the drawing, the mesh to draw, and a <kbd>DrawParam</kbd> structure. This structure can contain the geometric transformation to apply to the mesh while drawing it.</li>
<li>The <kbd>audio::Source</kbd> objects have several methods, including the <kbd>play</kbd> and <kbd>play_detached</kbd> methods. The first one automatically stops the previous sound before playing the specified one; the second one overlaps its sound with existing ones.</li>
</ol>
<h1 id="uuid-1479746f-820e-4570-baa2-f739c895b366" class="mce-root">Chapter 8</h1>
<ol>
<li>Regular languages are ones that can be defined by a regular expression, which is a combination of three operators: concatenation, alternation, and repetition. Context-free languages are ones that can contain regular operators, plus matching symbols (such as parentheses). Context-dependent languages are those in which the validity of any expression may depend on any other expression defined previously.</li>
<li>It is a set of rules in which the program is a symbol, and every symbol is defined as the concatenation or alternation of symbols or characters.</li>
<li>It is a program that gets as input a formal definition of a programming language and generates as output a compiler, which is a program that parses (or even compiles to machine language) programs written in the language specified by that formal definition.</li>
<li>It is a function that takes as input one or more parsers and returns a parser that combines the input parsers in some way.</li>
<li>Because, before the 2018 edition of Rust, the Rust language did not allow functions that returned functions without encapsulating them in an allocated object. The feature that allows a function to be returned with no allocation is named <kbd>impl Trait</kbd>.</li>
</ol>
<ol start="6">
<li>The <kbd>tuple</kbd> parser combinator gets a fixed sequence of parsers and returns a parser that applies them in sequence. The <kbd>alt</kbd> parser combinator gets a fixed sequence of parsers and returns a parser that applies them alternatively. The <kbd>map</kbd> parser combinator gets a parser and a closure and returns a parser that applies that parser and then uses the closure to transform its output.</li>
<li>Lexical analysis, syntax analysis, semantic analysis, and interpretation.</li>
<li>Lexical analysis, syntax analysis, semantic analysis, generation of intermediate code, optimization of intermediate code, generation of relocatable machine code, and linking.</li>
<li>When an identifier is defined, the symbol table is needed to check that such a name has not been defined yet in the current scope, if the language does not allow the shadowing of an identifier. When an identifier is used, the symbol table is needed to check that such a name has already been defined and that it has a type compatible with the usage.</li>
<li>When an identifier is defined, the symbol table is needed to store the initial value of the identifier. When an identifier is used, the symbol table is needed to get or set the value associated with such an identifier.</li>
</ol>
<h1 id="uuid-3cd664ca-20e5-420e-95bd-0eba4b1caafa" class="mce-root">Chapter 9</h1>
<ol>
<li>Possible uses:</li>
</ol>
<ul>
<li style="padding-left: 30px">To run a binary program for a computer when that computer is not available</li>
<li style="padding-left: 30px">To debug or analyze a binary program when its source code is not available</li>
<li style="padding-left: 30px">To disassemble machine code</li>
<li style="padding-left: 30px">To translate a binary program into another machine language</li>
<li style="padding-left: 30px">To translate a binary program into a high-level programming language</li>
</ul>
<ol start="2">
<li>It is the main data register. It is the default source and destination of any instruction.</li>
<li>It is the main address register. It contains the address of the next instruction that will be fetched and executed.</li>
<li>One reason is that the use of numbers is more error-prone than the use of names. The other is that when an instruction or a variable is added or removed, the addresses of all the following instructions or variables change, and so a lot of addresses in code must be incremented or decremented.</li>
</ol>
<ol start="5">
<li>Defining a variant for every instruction type. The name of the variant is the symbolic name of the instruction, and its parameters are the types of the operands of the instruction.</li>
<li>Little-endian notation is where the low byte of a word has a lower memory address, and big-endian notation is where the high byte has a lower memory address.</li>
<li>For a parser that accepts text, the input is a reference to a string slice, with an <kbd>&amp;str</kbd> type, while for a parser that accepts binary data, the input is a reference to a slice of bytes, with an <kbd>&amp;[u8]</kbd> type.</li>
<li>The rules to be respected are as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px">It begins with a little-endian word containing the size of the process in bytes.</li>
<li style="padding-left: 30px">After the initial word, there is a sequence of valid machine language instructions, with no interleaved spaces or data.</li>
<li style="padding-left: 30px">The <kbd>Terminate</kbd> instruction occurs once—and only once—as the last instruction so that it marks the end of the sequence of instructions. After this, there is only data left.</li>
<li style="padding-left: 30px">No statement writes on the instructions; only the data can be changed. So, the program is not self-modifying; put differently, the program instructions are the same as the process instructions.</li>
</ul>
<ol start="9">
<li>Because a 16-bit number can be usefully regarded sometimes as a pair of bytes and sometimes as a single number. Hexadecimal format satisfies both requirements because every pair of hexadecimal digits is a byte, and the whole four-digit sequence is a 16-bit number.</li>
<li>By encapsulating it in a new type and then implementing the <kbd>Debug</kbd> trait for the type.</li>
</ol>
<h1 id="uuid-2f323f41-bd3a-4c74-831f-e60e9e69b154" class="mce-root">Chapter 10</h1>
<ol>
<li>It is an extension of the Linux operating system kernel that can be added or removed at runtime.</li>
<li>The C programming language, with GCC extensions.</li>
<li>It is a memory-only log area to which every kernel module can write. When a kernel module writes to it, a bracket-enclosed timestamp is added at the beginning of every line; this is the number of seconds and microseconds since the start of the kernel. </li>
</ol>
<ol start="4">
<li><kbd>ModInfo</kbd> prints some information about a Linux module file; <kbd>LsMod</kbd> prints the list of all the currently loaded modules; <kbd>InsMod</kbd> loads a Linux module from the specified file and adds it to the running kernel; and <kbd>RmMod</kbd> unloads the specified module from the running Linux kernel.</li>
<li>Because the <kbd>#![no_std]</kbd> directive prevents the use of the standard heap allocator and of all the standard types that use it. This directive is required as any kernel module needs a custom allocator.</li>
<li>It is a directive to the linker to keep the exact name of the following function so that the kernel can find that function by name.</li>
<li>It specifies that the function-calling convention must be the one normally used by the C language.</li>
<li>They are two entry points of the module: the <kbd>init_module</kbd> function is invoked by the kernel when the module is loaded, and the <kbd>cleanup_module</kbd> function is invoked by the kernel when the module is unloaded.</li>
<li><kbd>__register_chrdev</kbd> is used to register a character device in the kernel; <kbd>__unregister_chrdev</kbd> is used to deregister it.</li>
<li>The <kbd>_copy_to_user</kbd> function.</li>
</ol>


            

            
        
    </body></html>