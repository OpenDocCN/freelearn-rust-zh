["```rs\nfn download_parse(url: &str) {\n    let task = download(url)\n               .and_then(|data| parse_html(data))\n               .and_then(|link| process_link(link))\n               .map_err(|e| OurErr(e));\n    Core.run(task);\n}\n```", "```rs\npub trait Generator {\n    type Yield;\n    type Return;\n    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>; \n}\n```", "```rs\npub enum GeneratorState<Y, R> {\n    Yielded(Y),\n    Complete(R)\n}\n```", "```rs\n// appendix/collatz-generator/src/main.rs\n\n#![feature(generators, generator_trait)]\n\nuse std::ops::{Generator, GeneratorState};\nuse std::env;\n\nfn main() {\n    let input = env::args()\n        .nth(1)\n        .expect(\"Please provide only one argument\")\n        .parse::<u64>()\n        .expect(\"Could not convert input to integer\");\n\n    // The given expression will evaluate to our generator\n    let mut generator = || {\n        let end = 1u64;\n        let mut current: u64 = input;\n        while current != end {\n            yield current;\n            if current % 2 == 0 {\n                current /= 2;\n            } else {\n                current = 3 * current + 1;\n            }\n        }\n        return end;\n    };\n\n    loop {\n        // The resume call can have two results. If we have an\n        // yielded value, we print it. If we have a completed\n        // value, we print it and break from the loop (this is\n        // the return case)\n        match generator.resume() {\n            GeneratorState::Yielded(el) => println!(\"{}\", el),\n            GeneratorState::Complete(el) => {\n                println!(\"{}\", el);\n                break;\n            }\n        }\n    }\n}\n```", "```rs\n$ cargo run 10\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/collatz-generator 10`\n10\n5\n16\n8\n4\n2\n1\n```", "```rs\n[package]\nname = \"collatz-may\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nmay = \"0.2.0\"\ngenerator = \"0.6\"\n```", "```rs\n// appendix/collatz-may/src/main.rs\n\n#![feature(conservative_impl_trait)]\n\n#[macro_use]\nextern crate generator;\n#[macro_use]\nextern crate may;\n\nuse std::env;\nuse generator::Gn;\n\n// Returns a generator as an iterator\nfn collatz_generator(start: u64) -> impl Iterator<Item = u64> {\n    Gn::new_scoped(move |mut s| {\n        let end = 1u64;\n        let mut current: u64 = start;\n        while current != end {\n            s.yield_(current);\n            if current % 2 == 0 {\n                current /= 2;\n            } else {\n                current = 3 * current + 1;\n            }\n        }\n        s.yield_(end);\n        done!();\n    })\n}\n\n// A regular function returning result in a vector\nfn collatz(start: u64) -> Vec<u64> {\n    let end = 1u64;\n    let mut current: u64 = start;\n    let mut result = Vec::new();\n    while current != end {\n        result.push(current);\n        if current % 2 == 0 {\n            current /= 2;\n        } else {\n            current = 3 * current + 1;\n        }\n    }\n    result.push(end);\n    result\n}\n\nfn main() {\n    let input = env::args()\n        .nth(1)\n        .expect(\"Please provide only one argument\")\n        .parse::<u64>()\n        .expect(\"Could not convert input to integer\");\n\n    // Using the go! macro\n    go!(move || {\n        println!(\"{:?}\", collatz(input));\n    }).join()\n        .unwrap();\n\n    // results is a generator expression that we can\n    // iterate over\n    let results = collatz_generator(input);\n    for result in results {\n        println!(\"{}\", result);\n    }\n}\n```", "```rs\n$ cargo run 10\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/collatz-may 10`\n[10, 5, 16, 8, 4, 2, 1]\n10\n5\n16\n8\n4\n2\n1\n```", "```rs\n[package]\nname = \"may-http\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nmay_minihttp = { git = \"https://github.com/Xudong-Huang/may_minihttp.git\" }\nmay = \"0.2.0\"\nnum_cpus = \"1.7.0\"\n```", "```rs\n// appendix/may-http/src/main.rs\n\nextern crate may;\nextern crate may_minihttp;\nextern crate num_cpus;\n\nuse std::io;\nuse may_minihttp::{HttpServer, HttpService, Request, Response};\nuse std::{thread, time};\n\nfn heavy_work() -> String {\n    let duration = time::Duration::from_millis(100);\n    thread::sleep(duration);\n    \"done\".to_string()\n}\n\n#[derive(Clone, Copy)]\nstruct Echo;\n\n// Implementation of HttpService for our service struct Echo\n// This implementation defines how content should be served\nimpl HttpService for Echo {\n    fn call(&self, req: Request) -> io::Result<Response> {\n        let mut resp = Response::new();\n        match (req.method(), req.path()) {\n            (\"GET\", \"/data\") => {\n                let b = heavy_work();\n                resp.body(&b).status_code(200, \"OK\");\n            }\n            (&_, _) => {\n                resp.status_code(404, \"Not found\");\n            }\n        }\n        Ok(resp)\n    }\n}\n\nfn main() {\n    // Set the number of IO workers to the number of cores\n    may::config().set_io_workers(num_cpus::get());\n    let server = HttpServer(Echo).start(\"0.0.0.0:3000\").unwrap();\n    server.join().unwrap();\n}\n```", "```rs\n$ cargo run\n   Compiling may-http v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/may-http)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.57 secs\n     Running `target/debug/may-http`\nIncoming request <HTTP Request GET /data>\nIncoming request <HTTP Request GET /data>\n^C\n```", "```rs\n$ curl http://127.0.0.1:3000/data\ndone\n```", "```rs\n#[async]\nfn download(url: &str) -> io::Result<Data> {\n    ...\n}\n\n#[async]\nfn parse_html(data: &Data) -> io::Result<Links> {\n    ...\n}\n\n#[async]\nfn process_links(links: &Links) -> io::Result<bool> {\n    ...\n}\n\n#[async]\nfn download_parse(url: &str) -> io::Result<bool> {\n    let data = await!(download(url));\n    let links = await!(parse_html(data));\n    let result = await!(process_links(links));\n    Ok(result)\n}\n\nfn main() {\n    let task = download_parse(\"foo.bar\");\n    Core.run(task).unwrap();\n}\n```", "```rs\n[package]\nname = \"hyper-async-await\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nhyper = \"0.11.7\"\nfutures = \"0.1.17\"\nnet2 = \"0.2.31\"\ntokio-core = \"0.1.10\"\nnum_cpus = \"1.0\"\nfutures-await = \"0.1.0\"\n```", "```rs\n// appendix/hyper-async-await/src/main.rs\n\n#![feature(proc_macro, conservative_impl_trait, generators)]\n\nextern crate futures_await as futures;\nextern crate hyper;\nextern crate net2;\nextern crate tokio_core;\nextern crate num_cpus;\n\nuse futures::prelude::*;\nuse net2::unix::UnixTcpBuilderExt;\nuse tokio_core::reactor::Core;\nuse tokio_core::net::TcpListener;\nuse std::{thread, time};\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse hyper::{Get, StatusCode};\nuse hyper::header::ContentLength;\nuse hyper::server::{Http, Service, Request, Response};\nuse futures::future::FutureResult;\nuse std::io;\n\n// Our blocking function that waits for a random\n// amount of time and then returns a fixed string\nfn heavy_work() -> String {\n    let duration = time::Duration::from_millis(100);\n    thread::sleep(duration);\n    \"done\".to_string()\n}\n\n#[derive(Clone, Copy)]\nstruct Echo;\n\n// Service implementation for the Echo struct\nimpl Service for Echo {\n    type Request = Request;\n    type Response = Response;\n    type Error = hyper::Error;\n    type Future = FutureResult<Response, hyper::Error>;\n\n    fn call(&self, req: Request) -> Self::Future {\n        futures::future::ok(match (req.method(), req.path()) {\n            (&Get, \"/data\") => {\n                let b = heavy_work().into_bytes();\n                Response::new()\n                    .with_header(ContentLength(b.len() as u64))\n                    .with_body(b)\n            }\n            _ => Response::new().with_status(StatusCode::NotFound),\n        })\n    }\n}\n\n// Sets up everything and runs the event loop\nfn serve(addr: &SocketAddr, protocol: &Http) {\n    let mut core = Core::new().unwrap();\n    let handle = core.handle();\n    let listener = net2::TcpBuilder::new_v4()\n        .unwrap()\n        .reuse_port(true)\n        .unwrap()\n        .bind(addr)\n        .unwrap()\n        .listen(128)\n        .unwrap();\n    let listener = TcpListener::from_listener\n    (listener, addr, &handle).unwrap();\n    let server = async_block! {\n        #[async]\n        for (socket, addr) in listener.incoming() {\n            protocol.bind_connection(&handle, socket, addr, Echo);\n        }\n        Ok::<(), io::Error>(())\n    };\n    core.run(server).unwrap();\n}\n\nfn start_server(num: usize, addr: &str) {\n    let addr = addr.parse().unwrap();\n\n    let protocol = Arc::new(Http::new());\n    {\n        for _ in 0..num - 1 {\n            let protocol = Arc::clone(&protocol);\n            thread::spawn(move || serve(&addr, &protocol));\n        }\n    }\n    serve(&addr, &protocol);\n}\n\nfn main() {\n    start_server(num_cpus::get(), \"0.0.0.0:3000\");\n}\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hyper-server-faster`\n```", "```rs\n$ curl http://127.0.0.1:3000/data\ndone$ curl http://127.0.0.1:3000/data\ndone$\n```", "```rs\n$ cargo new --bin rayon-search\n```", "```rs\n[package]\nname = \"rayon-search\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nrayon = \"0.9.0\"\n```", "```rs\n// appendix/rayon-search/src/main.rs\n\nextern crate rayon;\n\nuse std::fmt::Debug;\nuse rayon::scope;\n\n// Parallel binary search, searches the two halves in parallel\nfn binary_search_rayon<T: Ord + Send + Copy + Sync + Debug>(src: &mut [T], el: T) -> bool {\n    src.sort();\n    let mid = src.len() / 2;\n    let srcmid = src[mid];\n    if src.len() == 1 && src[0] != el {\n        return false;\n    }\n    if el == srcmid {\n        true\n    } else {\n        let mut left_result = false;\n        let mut right_result = false;\n        let (left, right) = src.split_at_mut(mid);\n        scope(|s| if el < srcmid {\n            s.spawn(|_| left_result = binary_search_rayon(left, el))\n        } else {\n            s.spawn(|_| right_result = binary_search_rayon(right, el))\n        });\n        left_result || right_result\n    }\n}\n\n// Non-parallel binary search, goes like this:\n// 1\\. Sort input\n// 2\\. Find middle point, return if middle point is target\n// 3\\. If not, recursively search left and right halves\nfn binary_search_recursive<T: Ord + Send + Copy>(src: &mut [T], el: T) -> bool {\n    src.sort();\n    let mid = src.len() / 2;\n    let srcmid = src[mid];\n    if src.len() == 1 && src[0] != el {\n        return false;\n    }\n    if el == srcmid {\n        true\n    } else {\n        let (left, right) = src.split_at_mut(mid);\n        if el < srcmid {\n            binary_search_recursive(left, el)\n        } else {\n            binary_search_recursive(right, el)\n        }\n    }\n}\n\nfn main() {\n    let mut v = vec![100, 12, 121, 1, 23, 35];\n    println!(\"{}\", binary_search_recursive(&mut v, 5));\n    println!(\"{}\", binary_search_rayon(&mut v, 5));\n    println!(\"{}\", binary_search_rayon(&mut v, 100));\n}\n```", "```rs\n$ cargo run\n   Compiling rayon-search v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/rayon-search)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.88 secs\n     Running `target/debug/rayon-search`\nfalse\nfalse\ntrue\n```", "```rs\n$ cargo new --bin rayon-parallel\n```", "```rs\n[package]\nname = \"rayon-parallel\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nrayon = \"0.9.0\"\nrustc-test = \"0.3.0\"\n```", "```rs\n// appendix/rayon-parallel/src/main.rs\n\n#![feature(test)]\n\nextern crate rayon;\nextern crate test;\n\nuse rayon::prelude::*;\n\n// This function uses a parallel iterator to\n// iterate over the input vector, filtering\n// elements that are even and then squares the remaining\nfn filter_parallel(src: Vec<u64>) -> Vec<u64> {\n    src.par_iter().filter(|x| *x % 2 != 0)\n    .map(|x| x * x)\n    .collect()\n}\n\n// This function does exactly the same operation\n// but uses a regular, sequential iterator\nfn filter_sequential(src: Vec<u64>) -> Vec<u64> {\n    src.iter().filter(|x| *x % 2 != 0)\n    .map(|x| x * x)\n    .collect()\n}\n\nfn main() {\n    let nums_one = (1..10).collect();\n    println!(\"{:?}\", filter_sequential(nums_one));\n\n    let nums_two = (1..10).collect();\n    println!(\"{:?}\", filter_parallel(nums_two));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[bench]\n    fn bench_filter_sequential(b: &mut Bencher) {\n        b.iter(|| filter_sequential((1..1000).collect::<Vec<u64>>()));\n    }\n\n    #[bench]\n    fn bench_filter_parallel(b: &mut Bencher) {\n        b.iter(|| filter_parallel((1..1000).collect::<Vec<u64>>()));\n    }\n}\n```", "```rs\n$ cargo run\n   Compiling rayon-parallel v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/rayon-parallel)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.65 secs\n     Running `target/debug/rayon-parallel`\n[1, 9, 25, 49, 81]\n[1, 9, 25, 49, 81]\n```", "```rs\n$ cargo bench\n    Finished release [optimized] target(s) in 0.0 secs\n     Running target/release/deps/rayon_parallel-333850e4b1422ead\n\nrunning 2 tests\ntest tests::bench_filter_parallel ... bench: 92,630 ns/iter (+/- 4,942)\ntest tests::bench_filter_sequential ... bench: 1,587 ns/iter (+/- 269)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out\n```", "```rs\n$ cargo new --bin pest-example\n```", "```rs\n[package]\nname = \"pest-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\npest = \"^1.0\"\npest_derive = \"^1.0\"\n```", "```rs\n// src/appendix/pest-example/src/grammar.pest\n\nnewline = { \"\\n\" }\ncarriage_return = { \"\\r\" }\nspace = { \" \" }\nget = { \"GET\" }\npost = { \"POST\" }\nsep = { \"/\" }\nversion = { \"HTTP/1.1\" }\nchars = { 'a'..'z' | 'A'..'Z' }\nrequest = { get | post }\n\nident_list = _{ request ~ space ~ sep ~ chars+ ~ sep ~ space ~ version ~ carriage_return ~ newline }\n```", "```rs\n// src/appendix/pest-example/src/main.rs\n\nextern crate pest;\n#[macro_use]\nextern crate pest_derive;\n\nuse pest::Parser;\n\n#[derive(Parser)]\n#[grammar = \"grammar.pest\"]\n// Unit struct that will be used as the parser\nstruct RequestParser;\n\nfn main() {\n    let get = RequestParser::parse(Rule::ident_list, \"GET /foobar/ HTTP/1.1\\r\\n\")\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    for pair in get {\n        println!(\"Rule: {:?}\", pair.as_rule());\n        println!(\"Span: {:?}\", pair.clone().into_span());\n        println!(\"Text: {}\", pair.clone().into_span().as_str());\n    }\n\n    let _ = RequestParser::parse(Rule::ident_list, \"WRONG /foobar/\n    HTTP/1.1\\r\\n\")\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n}\n```", "```rs\n$ cargo run\n   Compiling pest-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/chapter4/pest-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs\n     Running `target/debug/pest-example`\nRule: request\nSpan: Span { start: 0, end: 3 }\nText: GET\nRule: space\nSpan: Span { start: 3, end: 4 }\nText:\nRule: sep\nSpan: Span { start: 4, end: 5 }\nText: /\nRule: chars\nSpan: Span { start: 5, end: 6 }\nText: f\nRule: chars\nSpan: Span { start: 6, end: 7 }\nText: o\nRule: chars\nSpan: Span { start: 7, end: 8 }\nText: o\nRule: chars\nSpan: Span { start: 8, end: 9 }\nText: b\nRule: chars\nSpan: Span { start: 9, end: 10 }\nText: a\nRule: chars\nSpan: Span { start: 10, end: 11 }\nText: r\nRule: sep\nSpan: Span { start: 11, end: 12 }\nText: /\nRule: space\nSpan: Span { start: 12, end: 13 }\nText:\nRule: version\nSpan: Span { start: 13, end: 21 }\nText: HTTP/1.1\nRule: carriage_return\nSpan: Span { start: 21, end: 22 }\nText:\nRule: newline\nSpan: Span { start: 22, end: 23 }\nText:\n\nthread 'main' panicked at ' --> 1:1\n  |\n1 | WRONG /foobar/ HTTP/1.1\n  | ^---\n  |\n  = expected request', src/main.rs:21:29\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n```", "```rs\n$ cargo new --bin bitflags-example\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"bitflags-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nbitflags = \"1.0\"\n```", "```rs\n// appendix/bitflags-example/src/main.rs\n\n#[macro_use]\nextern crate bitflags;\n\n// This macro defines a struct that holds our\n// flags. This also defines a number of convinience\n// methods on the struct.\nbitflags! {\n    struct Flags: u32 {\n        const X = 0b00000001;\n        const Y = 0b00000010;\n    }\n}\n\n// We define a custom trait to print a\n// given bitflag in decimal\npub trait Format {\n    fn decimal(&self);\n}\n\n// We implement our trait for the Flags struct\n// which is defined by the bitflags! macro\nimpl Format for Flags {\n    fn decimal(&self) {\n        println!(\"Decimal: {}\", self.bits());\n    }\n}\n\n// Main driver function\nfn main() {\n    // A logical OR of two given bitflags\n    let flags = Flags::X | Flags::Y;\n\n    // Prints the decimal representation of\n    // the logical OR\n    flags.decimal();\n\n    // Same as before\n    (Flags::X | Flags::Y).decimal();\n\n    // Prints one individual flag in decimal\n    (Flags::Y).decimal();\n\n    // Examples of the convenience methods mentioned\n    // earlier. The all method gets the current state\n    // as a human readable string. The contain method\n    // returns a bool indicating if the given bitflag\n    // has the other flag.\n    println!(\"Current state: {:?}\", Flags::all());\n    println!(\"Contains X? {:?}\", flags.contains(Flags::X));\n}\n```", "```rs\n$ cargo run\n   Compiling bitflags-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/bitflags-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs\n     Running `target/debug/bitflags-example`\nDecimal: 3\nDecimal: 3\nDecimal: 2\nCurrent state: X | Y\nContains X? true\n```", "```rs\n$ cargo new --bin url-example\n```", "```rs\n$ cat Cargo.toml\n[package]\nname = \"url-example\"\nversion = \"0.1.0\"\nauthors = [\"Foo <foo@bar.com>\"]\n\n[dependencies]\nurl = \"1.6.0\"\n```", "```rs\n// appendix/url-example/src/main.rs\n\nextern crate url;\n\nuse url::Url;\n\nfn main() {\n    // We are parsing a gitlab URL. This one happens to be using\n    // git and https, a given username/password and a fragment\n    // pointing to one line in the source\n    let url = Url::parse(\"git+https://foo:bar@gitlab.com/gitlab-org/gitlab-ce/blob/master/config/routes/development.rb#L8\").unwrap();\n\n    // Prints the scheme\n    println!(\"Scheme: {}\", url.scheme());\n\n    // Prints the username\n    println!(\"Username: {}\", url.username());\n\n    // Prints the password\n    println!(\"Password: {}\", url.password().unwrap());\n\n    // Prints the fragment (everything after the #)\n    println!(\"Fragment: {}\", url.fragment().unwrap());\n\n    // Prints the host\n    println!(\"Host: {:?}\", url.host().unwrap());\n}\n```", "```rs\n$ cargo run\n   Compiling url-example v0.1.0 (file:///Users/Abhishek/Desktop/rust-book/src/appendix/url-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.58 secs\n     Running `target/debug/url-example`\nScheme: git+https\nUsername: foo\nPassword: bar\nFragment: L8\nHost: Domain(\"gitlab.com\")\n```"]