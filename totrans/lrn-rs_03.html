<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Input and Output</h1>
                
            
            <article>
                
<p class="calibre1">Up to this point, we've only seen data coming from our examples, and then only using the <kbd class="calibre10">println!</kbd> macro function. While the <kbd class="calibre10">println!</kbd> macro is very useful, we really need to look at output. We also need to know how to get data in, and once the data is in, we have to check that the type entered is the type required.</p>
<p class="calibre1">In this chapter, we will be covering the following topics:</p>
<ul class="calibre12">
<li class="calibre13">Examining ways of outputting data</li>
<li class="calibre13">Examining how to get data into an application</li>
<li class="calibre13">Starting your program with command-line arguments</li>
<li class="calibre13">Discussing how a method in Rust is different from a method in other languages</li>
<li class="calibre13">A brief introduction to the standard library</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Functions and methods in Rust</h1>
                
            
            <article>
                
<p class="calibre1">When we look at C++ or C#, a method is a programming unit within a class that does a specific task. A method in Rust is a function attached to compound data structures, or structs. These methods have access to the data of the object using the self parameter. They are defined in an <kbd class="calibre10">impl</kbd> block, as shown in the following example (a fuller example is given in the source examples):</p>
<pre class="calibre21">struct Point { 
    x: f64, 
    y: f64 
} 
 
impl Point { 
    fn origin() -&gt; Point { 
        Point {x: 0.0, y: 0.0 } 
    } 
 
    fn new(my_x: f64, my_y: f64) -&gt; Point { 
        Point { x: my_x, y: my_y } 
    } 
} </pre>
<p class="calibre1">Here, we defined a struct, <kbd class="calibre10">Point</kbd>, for points in 2D space. Then, we defined two constructor methods for that struct: origin for making a new point in location <kbd class="calibre10">0</kbd>,<kbd class="calibre10">0</kbd> and another for making a new arbitrary point.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The difference between println! and println</h1>
                
            
            <article>
                
<p class="calibre1">Up to this point, we've used <kbd class="calibre10">println!</kbd> for outputting text. This is fine, but consider what <kbd class="calibre10">println!</kbd> does. Whenever you see a <kbd class="calibre10">!</kbd> mark, it symbolizes a macro. Macros are used when some part of the function needs to be executed at compile time, rather than at runtime.</p>
<p class="calibre1">Consider the following:</p>
<pre class="calibre21">println!("{}", a); 
Console.WriteLine("{0}", a); </pre>
<p class="calibre1">In C#, the preceding snippet will output a line with the value of <kbd class="calibre10">a</kbd> on the line. In this case, <kbd class="calibre10">a</kbd> can be of any type that supports conversion to a formatted output. The same applies to Rust. A line is output with the value of <kbd class="calibre10">a</kbd>.</p>
<p class="calibre1">The <kbd class="calibre10">println!</kbd> macro is actually implemented in the Rust standard library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to the standard library</h1>
                
            
            <article>
                
<p class="calibre1">To be able to understand where <kbd class="calibre10">println!</kbd> comes from, we need to take a brief look at the Rust Standard Library. If you're familiar with C, C++, or C# (or any of the other languages commonly used), you'll have used something like this:</p>
<pre class="calibre21">#include &lt;stdio.h&gt; 
#include &lt;stdlib&gt; 
using System.Collections.Generic; </pre>
<p class="calibre1">These are standard libraries that the compiler comes with, and which the developer can optionally include. They contain many useful procedures, functions, and methods, all designed to make development simpler so that you don't need to keep reinventing the wheel when you need to do a common task.</p>
<p class="calibre1">A similar system exists in Rust in the form of crates. The std crate contains the Rust Standard Library, and it is by default included in every other crate. This means that you can use functionality from there without extra steps.</p>
<p class="calibre1">The crates are further separated into module hierarchies, with a double colon <kbd class="calibre10">::</kbd> being a separator for the paths. So, for example, <kbd class="calibre10">std::fmt</kbd> is the <kbd class="calibre10">fmt</kbd> module inside the <kbd class="calibre10">std</kbd> module. It contains string formatting and printing functionality. For instance, the <kbd class="calibre10">println!</kbd> macro that we have used already is there.</p>
<p class="calibre1">So why don't we have to write <kbd class="calibre10">std::fmt::println!</kbd> every time we use the <kbd class="calibre10">println!</kbd> macro? Because <kbd class="calibre10">println!</kbd> is one of the many standard macros which are imported to every namespace automatically.</p>
<p class="calibre1">You can also import things to the current namespace yourself, to save yourself some keystrokes. This is done by the use keyword. Here's an example that uses the <kbd class="calibre10">HashMap</kbd> collection type from the standard library, without using the use keyword:</p>
<pre class="calibre21">let mut my_hashmap: std::collections::HashMap&lt;String, u8&gt; =  
    std::collections::HashMap::new(); 
my_hashmap.insert("one".to_owned(), 1); </pre>
<p class="calibre1">Spelling out the full namespace explicitly every time is possible, but as you can see, the noise-to-signal ratio is a bit poorer. Importing the <kbd class="calibre10">HashMap</kbd> into the current namespace can help. This piece of code is equivalent to the previous:</p>
<pre class="calibre21">use std::collections::HashMap; 
let mut my_hashmap: HashMap&lt;String, u8&gt; = HashMap::new(); 
my_hashmap.insert("one".to_owned(), 1); </pre>
<p class="calibre1">Rust's library system is a bit different from other languages, and may therefore be a bit of a stumbling block for newcomers. I found it a useful tidbit to realize that use clauses are not required to make code visible and callable: they just import a namespace into the current namespace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The libraries</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">std</kbd> libraries define the primitives we have already encountered (<kbd class="calibre10">array</kbd>, different sized floats and integers, <kbd class="calibre10">String</kbd>, and so on), but also contain a number of other modules. They also define the commonly used macros (such as <kbd class="calibre10">write!</kbd> and <kbd class="calibre10">println!</kbd>).</p>
<p class="calibre1">For the purposes of this chapter, we will cover only <kbd class="calibre10">std::io</kbd>, <kbd class="calibre10">std::fs,</kbd> and <kbd class="calibre10">std::fmt</kbd>. These deal with input/output, the filesystem, and formatting. The <kbd class="calibre10">io</kbd> and <kbd class="calibre10">fs</kbd> modules will be dealt with later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Controlling the output formatting</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">std::fmt</kbd> module provides the developer with a range of utilities for formatting and printing strings. Let's start with the <kbd class="calibre10">format!</kbd> macro. This macro returns a string.</p>
<p class="calibre1">We have seen that if we use <kbd class="calibre10">println!</kbd>(<kbd class="calibre10">Hello {}</kbd>, <kbd class="calibre10">myString</kbd>), the code will print the contents of <kbd class="calibre10">myString</kbd> after the <kbd class="calibre10">Hello</kbd>. The <kbd class="calibre10">format!</kbd> macro works pretty much the same, just that it returns the formatted string instead of outputting it. In fact, <kbd class="calibre10">println!</kbd> essentially uses <kbd class="calibre10">format!</kbd> itself under the hood.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Positioning the output</h1>
                
            
            <article>
                
<p class="calibre1">One of the more useful extensions in C# is <kbd class="calibre10">string.Format(...);.</kbd> This allows for a string to be constructed based on parameters at particular positions. For example, the following statement constructs a string where the parameter at a position after the string literal is inserted into the string (here, the letter <kbd class="calibre10">B</kbd> is inserted twice in the middle of the string and then at the end):</p>
<pre class="calibre21">var myString = string.Format("Hello {0}, I am a {1}{1}{2} computer model {1}", name, "B", "C"); </pre>
<p class="calibre1">Rust also supports this form, but with the difference that the positioning may be omitted.</p>
<p class="calibre1">Consider the following examples:</p>
<pre class="calibre21">format!("{} {}", 2, 10); // output 2 10 
format!("{1} {} {0} {}", "B", "A"); </pre>
<p class="calibre1">The first example is what we've seen before. The format string gets filled with the parameters on the right, in order.</p>
<p class="calibre1">In the second example, it would seem that we're asking for four parameters, but have only supplied two. The way this works is that the positional arguments are ignored when filling in the non-positional arguments. Indexing, as is usual in programming, starts at zero. This is how the arguments are processed:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">{1}</kbd> inserts the second parameter <kbd class="calibre10">A</kbd></li>
<li class="calibre13"><kbd class="calibre10">{}</kbd> inserts the first parameter <kbd class="calibre10">B</kbd></li>
<li class="calibre13"><kbd class="calibre10">{0}</kbd> inserts the first parameter <kbd class="calibre10">B</kbd></li>
<li class="calibre13"><kbd class="calibre10">{}</kbd> inserts the second parameter <kbd class="calibre10">A</kbd></li>
</ul>
<p class="calibre1">Therefore, the output is going to be <span>A B B A</span>.</p>
<p class="calibre1">The following are the two important rules governing the positional parameters:</p>
<ol class="calibre16">
<li value="1" class="calibre13">All of the arguments within the quotes must be used. Failure to do so will result in a compiler error.</li>
<li value="2" class="calibre13">You can refer to the same argument as many times as you like within the format string.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Named parameters</h1>
                
            
            <article>
                
<p class="calibre1">As shown in the formatting table, it is possible to use a named parameter. The operation of these is similar to a positional parameter; the difference, though, is that a named parameter is used. This is very useful in ensuring that the value output in the string is the correct parameter.</p>
<p class="calibre1">It is perfectly acceptable to use an empty parameter within a formatted string when using a named parameter, for example:</p>
<pre class="calibre21">format!("{b} {a} {} {t}", b = "B", a = 'a', t = 33); </pre>
<p class="calibre1">The rules for handling non-positional parameters alongside named parameters are similar to the rules for positional parameters: the named parameters are ignored when figuring out the positions. This will, therefore, give the output <span>B a B 33</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Specifying the argument types</h1>
                
            
            <article>
                
<p class="calibre1">As with much of the string handling in the C family of languages, it is possible to create a string based on a format string (for example, <kbd class="calibre10">{0:##.###}</kbd> would give a formatted output of the form <span>xy.abc</span>).</p>
<p class="calibre1">Similar things can be done in Rust, as follows:</p>
<pre class="calibre21">let my_number = format!("{:.3}", 3.1415927); </pre>
<p class="calibre1">In the format string, the colon says we're requesting formatting for the value. Dot and <kbd class="calibre10">3</kbd> says that we want the number formatted to three decimal points. The formatter rounds the value for us, so the output will be <span>3.142.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Formatting traits</h1>
                
            
            <article>
                
<p class="calibre1">Formatting traits determine how the output of the format will be produced. They are all used in the same way: <kbd class="calibre10">{:trait_name}.</kbd></p>
<p class="calibre1">The following are the current traits available:</p>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Format string</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Trait</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Meaning</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Example</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Display</p>
</td>
<td class="calibre7">
<p class="calibre1">A human-readable representation. Not all things implement Display.</p>
</td>
<td class="calibre7">
<p class="calibre1">123 =&gt; "123"</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:?}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Debug</p>
</td>
<td class="calibre7">
<p class="calibre1">An internal representation. Almost everything implements Debug.</p>
</td>
<td class="calibre7">
<p class="calibre1">b"123" =&gt; [49, 50, 51]</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:b}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Binary</p>
</td>
<td class="calibre7">
<p class="calibre1">Converts a number into binary</p>
</td>
<td class="calibre7">
<p class="calibre1">123 =&gt; "1111011"</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:x}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">LowerHex</p>
</td>
<td class="calibre7">
<p class="calibre1">Hex in lowercase</p>
</td>
<td class="calibre7">
<p class="calibre1">123 =&gt; 7b</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:X}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">UpperHex</p>
</td>
<td class="calibre7">
<p class="calibre1">Hex in uppercase</p>
</td>
<td class="calibre7">
<p class="calibre1">123 =&gt; 7B</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:e}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">LowerExp</p>
</td>
<td class="calibre7">
<p class="calibre1">Number with exponential, lowercase</p>
</td>
<td class="calibre7">
<p class="calibre1">123.0 =&gt; 1.23e2</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:E}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">UpperExp</p>
</td>
<td class="calibre7">
<p class="calibre1">Number with exponential, uppercase</p>
</td>
<td class="calibre7">
<p class="calibre1">123.0 =&gt; 1.23E2</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">{:p}</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Pointer</p>
</td>
<td class="calibre7">
<p class="calibre1">Pointer location</p>
</td>
<td class="calibre7">
<p class="calibre1">&amp;123 =&gt; 0x55b3fbe72980 (may point to a different address on every run)</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1">Similarly, the output can be formatted with formatting parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Formatting parameters</h1>
                
            
            <article>
                
<p class="calibre1">There are essentially four formatting parameters available. They are listed in the following table:</p>
<table class="calibre4">
<tbody class="calibre5">
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Parameter</strong></p>
</td>
<td class="calibre7">
<p class="calibre1"><strong class="calibre8">Use</strong></p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">Fill</kbd>/<kbd class="calibre10">Alignment</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Used in conjunction with the <kbd class="calibre10">Width</kbd> parameter. Essentially, this will add extra characters if the output is smaller than the width.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">Sign</kbd>/<kbd class="calibre10">#</kbd>/<kbd class="calibre10">0</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Flags for the formatter being used:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">Sign</kbd> indicates that the sign should always be outputted (numeric values only). If the value is positive, the <kbd class="calibre10">+</kbd> sign will never show; similarly, a <kbd class="calibre10">-</kbd> will only show for a <kbd class="calibre10">Signed</kbd> value.</li>
<li class="calibre13"><kbd class="calibre10"><em class="calibre9">#</em></kbd> indicates that an alternate form of printing will be used. Normally, if <kbd class="calibre10">{:x}</kbd> is used, the lowercase hex format is used. By using <kbd class="calibre10">#x</kbd>, the argument is preceded with <kbd class="calibre10">0x</kbd>.</li>
<li class="calibre13"><kbd class="calibre10">0</kbd> is used to pad a result with the <kbd class="calibre10">0</kbd> character. It is sign-aware.</li>
</ul>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">Width</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">Specifies how the output should be represented. For example, if you have a float calculation that has to be outputted to four decimal places, and the result only comes to two decimal places, the width formatter (in conjunction with the fill formatting parameter) will create the required filled output.</p>
</td>
</tr>
<tr class="calibre6">
<td class="calibre7">
<p class="calibre1"><kbd class="calibre10">Precision</kbd></p>
</td>
<td class="calibre7">
<p class="calibre1">For anything non-numeric, the precision is the maximum width. For example, if you have a maximum width of five and a string containing eight characters, it will be truncated after five characters. It is ignored for integers. For floating point types, it indicates the number of decimal points after the point:</p>
<p class="calibre1"> </p>
<ul class="calibre12">
<li class="calibre13"><span>Integer </span><kbd class="calibre10">.N:</kbd><span>: In this case, </span><kbd class="calibre10">N</kbd><span> is the precision.</span></li>
<li class="calibre13">Integer followed by a <kbd class="calibre10">$ (.N$:)</kbd>: This uses the format argument <kbd class="calibre10">N</kbd> as the precision. The argument must be a <kbd class="calibre10">usize</kbd>.</li>
<li class="calibre13"><kbd class="calibre10">.*:</kbd>: This means that the contents of the <kbd class="calibre10">{}</kbd> is associated with two format inputs. The first holds the <kbd class="calibre10">usize</kbd> precision, the second holds the value to be printed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="calibre1"> </p>
<p class="calibre1">Examples of all of these formatters are in the source code examples for this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting information in</h1>
                
            
            <article>
                
<p class="calibre1">Up to this point, we have concentrated on getting information out from a Rust program rather than entering information.</p>
<p class="calibre1">Input is done via the <kbd class="calibre10">std::io</kbd> module, getting a reader using the <kbd class="calibre10">io::stdin()</kbd> function, and then calling <kbd class="calibre10">read_line</kbd> on that reader. We put the inputted data into a dynamically growing <kbd class="calibre10">String</kbd>, which needs to be mutable.</p>
<p class="calibre1">A simple example for inputting would look like this:</p>
<pre class="calibre21">// 03/readline/src/main.rs<br class="calibre2"/>use std::io; 
fn main() {     
    let reader: io::Stdin = io::stdin(); 
    let mut input_text: String = String::new(); 
 
    reader.read_line(&amp;mut input_text).expect("Reading failed"); 
    println!("Read {}", input_text); 
} </pre>
<p class="calibre1">We can see Rust's error handling in action in the previous code. The <kbd class="calibre10">read_line</kbd> method returns a result type, which means that the operation could have failed. The result type encapsulates two generic types inside itself, which in the case of <kbd class="calibre10">read_line</kbd> are <kbd class="calibre10">usize</kbd> (for reporting how many bytes were read in) and <kbd class="calibre10">io::Error</kbd> (for reporting any errors during input). The actual read String is placed in the first argument of the function, in this case <kbd class="calibre10">input_text</kbd>.</p>
<p class="calibre1">On that result type, our example calls the <kbd class="calibre10">expect</kbd> method. It expects that everything went fine, and returns the first value (the <kbd class="calibre10">usize</kbd> in this case). If there were errors, the <kbd class="calibre10">expect</kbd> method prints reading failed to the standard output and exits the program.</p>
<p class="calibre1">This is not the only way to handle result types, but it's a common one in cases where we expect things to usually work out fine.</p>
<p class="calibre1">Another way to handle the error is to explicitly call the <kbd class="calibre10">is_err</kbd> method on the result. It returns a boolean, like this:</p>
<pre class="calibre21">    let result: Result&lt;usize, io::Error&gt; = reader.read_line(&amp;mut input_text); 
    if result.is_err() { 
        println!("failed to read from stdin"); 
        return; 
    } </pre>
<p class="calibre1">If we wish to further parse the entry into another type, we can use the <kbd class="calibre10">parse</kbd> method.</p>
<p class="calibre1">For instance, say we'd like to get an <kbd class="calibre10">i32</kbd> from the input. The <kbd class="calibre10">read_line</kbd> method includes a carriage return in the input data, so we need to get rid of that using the <kbd class="calibre10">trim</kbd> method before parsing:</p>
<pre class="calibre21">    let trimmed = input_text.trim(); 
    let option: Option&lt;i32&gt; = trimmed.parse::&lt;i32&gt;().ok(); </pre>
<p class="calibre1">For the sake of this example, this final line converts the result type into an <kbd class="calibre10">Option</kbd> using the <kbd class="calibre10">ok</kbd> method. Option is a simplified version of result. This is a useful library and it can have one of two results: <kbd class="calibre10">Some</kbd> or <kbd class="calibre10">None</kbd>.</p>
<p class="calibre1">Here, if the entry result is <kbd class="calibre10">None</kbd>, the value is not an integer, whereas <kbd class="calibre10">Some</kbd> would be an integer:</p>
<pre class="calibre21">match option { 
        Some(i) =&gt; println!("your integer input: {}", i), 
        None =&gt; println!("this was not an integer: {}", trimmed) 
    }; 
 </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Command-line arguments</h1>
                
            
            <article>
                
<p class="calibre1">When a program is started, it can be started with or without arguments. These arguments are normally fed in as parameters when the program is called. A simple example of this is starting the manual application (found on many BSD and Linux machines):</p>
<pre class="calibre21">man ffmpeg </pre>
<p class="calibre1">In the preceding statement, <kbd class="calibre10">man</kbd> is the name of the program or script to be called with the argument <kbd class="calibre10">ffmpeg</kbd>. Similarly, take a look at the following example for Windows users:</p>
<div class="cdpaligncenter"><img class="image-border13" src="../images/00028.jpeg"/></div>
<p class="calibre1"><kbd class="calibre10">Notepad</kbd> is the program name with the first argument being the file to read in (in this example, the file doesn't exist, so the UI asks if you wish to create it).</p>
<p class="calibre1">It is not uncommon for one program to load another program to perform a task.</p>
<p class="calibre1">In C, the parameter list for main is given as follows:</p>
<pre class="calibre21">int main(int argc, char *argv[])</pre>
<p class="calibre1"><kbd class="calibre10">argc</kbd> is the maximum number of arguments with <kbd class="calibre10">argv</kbd> holding the arguments. Here, the program name is <kbd class="calibre10">argv[0]</kbd>, so all additional arguments start at 1.</p>
<p class="calibre1">Rust's <kbd class="calibre10">main</kbd> takes no arguments like this. Command-line parameters are available through the standard library <kbd class="calibre10">std::env::args</kbd> (environment arguments). For simplicity, it is convenient to store the arguments in <kbd class="calibre10">Vec&lt;String&gt;</kbd>, because <kbd class="calibre10">env::args</kbd> returns an iterator that yields a <kbd class="calibre10">String</kbd>.</p>
<p class="calibre1">No parameters are passed into <kbd class="calibre10">main</kbd> directly:</p>
<pre class="calibre21">// 03/args/src/main.rs<br class="calibre2"/>use std::env; 
fn main() { 
    let args: Vec&lt;String&gt; = env::args().collect(); 
    println!("There was {:?} arguments passed in. They were {:?}.", args.len() - 1, &amp;args[1..]); 
} </pre>
<p class="calibre1">The <kbd class="calibre10">collect</kbd> method converts the iterator into a vector, making it possible to access it by indexing. Without it, we would have to go through the arguments one by one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling files</h1>
                
            
            <article>
                
<p class="calibre1">The final part of our tour of getting information in and out of a program is using files. As far as Rust is concerned, a file is just another stream, with the exception that this stream goes elsewhere.</p>
<p class="calibre1">It is important when using anything to do with files that the <kbd class="calibre10">try!</kbd> macro is used to trap all errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reading from a file</h1>
                
            
            <article>
                
<p class="calibre1">Here, we are going to use <kbd class="calibre10">std::io</kbd>, <kbd class="calibre10">std::io::prelude::*</kbd> and <kbd class="calibre10">std::fs::File</kbd>. <kbd class="calibre10">std::io</kbd> is the standard input/output library, the <kbd class="calibre10">*</kbd> after prelude means to use anything in the prelude library, and <kbd class="calibre10">std::fs</kbd> is the filesystem library.</p>
<div class="packt_infobox">Filesystem calls are very platform-specific; Windows users use the likes of <kbd class="calibre22">C://Users/Paul/Documents/My Documents</kbd> for the user's home directory, whereas Linux and macOS machines would use <kbd class="calibre22">~/</kbd> for the user's home directory. If a path is not given for a file, the program will assume the file is in the same directory in which the binary resides.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Loading a file</h1>
                
            
            <article>
                
<p class="calibre1">To open a file, we use <kbd class="calibre10">File::open(filename)</kbd>. We can catch exceptions using the <kbd class="calibre10">try!</kbd> macro or <kbd class="calibre10">match</kbd>, as follows:</p>
<pre class="calibre21">let file = try!(File::open("my_file.txt")) </pre>
<p class="calibre1">Or the following can be used:</p>
<pre class="calibre21">let file = match File::open("my_file.txt") { 
    Ok(file) =&gt; file, 
    Err(..) =&gt; panic!("boom"), 
} </pre>
<p class="calibre1">If the file is available to open, <kbd class="calibre10">File::open</kbd> will grant read permissions to the file. To load the file, we create a <kbd class="calibre10">BufReader</kbd> based on the file:</p>
<pre class="calibre21">let mut reader = BufReader::new(&amp;file); 
let buffer_string = &amp;mut String::new(); 
reader.read_line(buffer_string); 
println!("Line read in: {}", buffer_string); </pre>
<p class="calibre1">Once the file has been read, the stream can be explicitly closed with <kbd class="calibre10">reader.close()</kbd>. However, Rust's resource management system guarantees that the file will be closed when its binding goes out of scope, so this is not mandatory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing a file</h1>
                
            
            <article>
                
<p class="calibre1">Writing to a file is a two-step process: opening the file (possibly creating it if it didn't exist before) and then the writing of the file. This is very similar to how writing to a file in the C family of languages is carried out.</p>
<p class="calibre1">You can create a file for writing in a single call to <kbd class="calibre10">std::fs::<span>File::create</span></kbd>. The <kbd class="calibre10">open</kbd> method in the same namespace opens a file for reading. If you need more fine-tuned permissions, <kbd class="calibre10">std::fs::OpenOptions::new</kbd> creates an object through which you can tweak the parameters and then open the file.</p>
<p class="calibre1">As with any file operation, anything could fail, so the result should always be checked:</p>
<pre class="calibre21">let file: Result&lt;File,Error&gt; = options.open(path); 
 </pre>
<p class="calibre1">As mentioned before, Rust uses a generic type, <kbd class="calibre10">Result&lt;T,U&gt;</kbd> , quite frequently as an error-trapping mechanism. It encapsulates two values: the left-hand side value is used when the operation succeeds, and the right-hand side value is used when it does not succeed.</p>
<p class="calibre1">Once we have completed the file creation, we can move on to writing to the file.</p>
<p class="calibre1">First, we check the results of the <kbd class="calibre10">Result</kbd> comparison. If an error hasn't been thrown there was no error, and we can then create a <kbd class="calibre10">BufWriter</kbd>:</p>
<pre class="calibre21">let mut writer = BufWriter::new(&amp;file); 
writer.write_all(b"hello text file\n"); </pre>
<p class="calibre1">We don't need to flush the buffer, as <kbd class="calibre10">write_all</kbd> will do that for us (it calls <kbd class="calibre10">flush()</kbd> once completed). If you don't use <kbd class="calibre10">write_all</kbd>, then you need to call <kbd class="calibre10">flush()</kbd> to ensure the buffer is cleared.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The use of expect</h1>
                
            
            <article>
                
<p class="calibre1">Rust contains a very useful function called <kbd class="calibre10">expect</kbd>. This method is used with any form of call that has an <kbd class="calibre10">Option</kbd> or a <kbd class="calibre10">Result</kbd> type (for example, <kbd class="calibre10">Result</kbd> in the file-writing example has the options of <kbd class="calibre10">File</kbd> or <kbd class="calibre10">Error</kbd>). It works by moving the value out of the option and returning it. If the <kbd class="calibre10">option</kbd>/<kbd class="calibre10">result</kbd> type contains an error, the <kbd class="calibre10">expect</kbd> call stops your program and prints out the error message.</p>
<p class="calibre1">For example, the following statement will return either <kbd class="calibre10">File</kbd> or <kbd class="calibre10">Error</kbd> into <kbd class="calibre10">file</kbd>:</p>
<pre class="calibre21">let file: Result&lt;File, Error&gt; = options.open("my_file.txt").expect("Opening the file failed"); </pre>
<p class="calibre1">A shorter form is available in the <kbd class="calibre10">unwrap</kbd> method. This is the same as the <kbd class="calibre10">expect</kbd> method, but it doesn't print out anything in case of a failure. In general, <kbd class="calibre10">Some(a).unwrap()</kbd> will return <kbd class="calibre10">a</kbd>.</p>
<p class="calibre1"><kbd class="calibre10">Expect</kbd> is usually favored instead of <kbd class="calibre10">unwrap</kbd>, since the full error message makes it easier to find where the error came from.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">XML and Rust</h1>
                
            
            <article>
                
<p class="calibre1">As Rust is well suited to running on servers, it seems appropriate that we consider XML, and how it is handled within Rust.</p>
<p class="calibre1">Thankfully, Rust comes with a crate called <kbd class="calibre10">Xml</kbd>, which works in a way similar to how standard streams are read and written.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reading a file</h1>
                
            
            <article>
                
<p class="calibre1">As with a standard file, we first have to open the file and create a reader:</p>
<pre class="calibre21">let file = File::open("my_xmlfile.xml").unwrap();<br class="calibre2"/>let reader =BufferedReader::new(file);</pre>
<p class="calibre1">Next, we start the reading. Unlike a normal reader, we use <kbd class="calibre10">EventReader</kbd>. This provides a number of events (such as <kbd class="calibre10">StartElement</kbd>, <kbd class="calibre10">EndElement,</kbd> and <kbd class="calibre10">Error</kbd>), which are required for reading in from the differing nodes:</p>
<pre class="calibre21">let mut xml_parser = EventReader::new(reader); </pre>
<p class="calibre1">Next, we iterate through the file, as follows:</p>
<pre class="calibre21">for e in xml_parser.events() { 
     match e { 
         StartElement { name, .. } =&gt; { 
              println!("{}", name); 
         } 
         EndElement {name} =&gt; { 
             println!("{}", name); 
         } 
         Error(e) =&gt; { 
             println!("Error in file: {}", e); 
      } 
      _ =&gt; {} 
   } 
} </pre>
<p class="calibre1">In the preceding snippet, <kbd class="calibre10">_ =&gt; {}</kbd> essentially means that you don't care what is left, do something with it (in this case, the something is nothing). You will see the symbol <kbd class="calibre10">_</kbd> quite a bit in Rust. Commonly, it is used in loops where the variable being acted on is never used, for example:</p>
<pre class="calibre21">for _ in something() {...} </pre>
<p class="calibre1">We aren't going to use the iterator; we just need something to enable the iteration to go to the next value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing a file</h1>
                
            
            <article>
                
<p class="calibre1">Writing an XML file is far more complex than reading. Here, we have to explicitly use <kbd class="calibre10">XmlEvent</kbd> and <kbd class="calibre10">EventWriter</kbd>. We also use <kbd class="calibre10">EmitterConfig,</kbd> which does as the name suggests, that is, creates a configuration and then uses it. <kbd class="calibre10">EventWriter</kbd>, <kbd class="calibre10">EmitterConfig,</kbd> and <kbd class="calibre10">XmlEvent</kbd> are all part of <kbd class="calibre10">xml::writer</kbd>.</p>
<p class="calibre1">Let us first consider the main function. First, create the file and two references, one to <kbd class="calibre10">stdin</kbd> and one to <kbd class="calibre10">stdout</kbd>, as follows:</p>
<pre class="calibre21">let mut file = File::create("myxml_file.xml).unwrap(); 
let mut output = io::stdout(); 
let mut input = io::stdin(); </pre>
<p class="calibre1">Next, we create the writer via <kbd class="calibre10">EmitterConfig:</kbd></p>
<pre class="calibre21">let mut writer = EmitterConfig::new().preform_indent(true).create_writer(&amp;mut file); </pre>
<p class="calibre1">We now have the writer set up. <kbd class="calibre10">perform_indent</kbd> tells the writer to indent each node when true.</p>
<p class="calibre1">Finally, we create a loop and write the XML. You will notice a call to <kbd class="calibre10">handle_event</kbd>; we will deal with this shortly:</p>
<pre class="calibre21">loop { 
    print!("&gt; "); 
    output.flush().unwrap(); 
    let mut line = String::new(); 
    match input.readline(&amp;mut line) { 
         Ok(0) =&gt; break, 
         Ok(_) =&gt; match handle_event(&amp;mut writer, line) { 
              Ok(_) =&gt; {} 
              Err(e) =&gt; panic!("XML write error: {}", e) 
         } 
         Err(e) =&gt; panic!("Input error: {}", e); 
    } 
} </pre>
<p class="calibre1">The definition of the function <kbd class="calibre10">handle_event</kbd> is a bit more advanced than we have seen until now:</p>
<pre class="calibre21">fn handle_event&lt;W: Write&gt;(w: &amp;mut EventWriter&lt;W&gt;, line: String) -&gt; Result&lt;()&gt; { </pre>
<p class="calibre1">In C#, the preceding definition would be something similar, and would be written as follows:</p>
<pre class="calibre21">Result handle_result&lt;T&gt;(EventWriter&lt;T&gt; w, string line) where T:Write </pre>
<p class="calibre1">We pass a type (be it a <kbd class="calibre10">class</kbd>, <kbd class="calibre10">string</kbd>, <kbd class="calibre10">i32,</kbd> or anything else for that matter) to the function to use as a parameter. In this case, we are using <kbd class="calibre10">std::io::Write</kbd> for the <kbd class="calibre10">EventWriter</kbd> to use.</p>
<p class="calibre1">The function itself has nothing special. We start by trimming the string to remove any whitespace or returns:</p>
<pre class="calibre21">let line = line.trim(); </pre>
<p class="calibre1">We now use <kbd class="calibre10">XmlEvent</kbd> to generate the code:</p>
<pre class="calibre21">let event: XmlEvent = if line.starts_with("+") &amp;&amp; line.len() &gt; 1 { 
    XmlEvent::start_element(&amp;line[1..]).into() 
} else if line.starts_with("-") { 
    XmlEvent::end_element().into() 
} else { 
    XmlEvent::characters(&amp;line).into() 
   }; 
    w.write(&amp;line).into(); 
} </pre>
<p class="calibre1"><kbd class="calibre10">into()</kbd> converts the pointer to the structure (known as <kbd class="calibre10">self</kbd>). In this case, it takes (say) <kbd class="calibre10">XmlEvent::characters(&amp;line),</kbd> and sends it back into the line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">We have covered quite a lot of material in this chapter, and you should feel more at home with handling strings, XML, and files, which can be used to add further functionality to your code. Please feel free to examine the examples supplied for this chapter.</p>
<p class="calibre1">In the next chapter, we will have a look at loops, recursion, and branching.</p>


            </article>

            
        </section>
    </body></html>