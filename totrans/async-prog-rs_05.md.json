["```rs\nmov rax, rsp\n```", "```rs\nrax    # 64 bit register (8 bytes)\neax    # 32 low bits of the \"rax\" register\nax     # 16 low bits of the \"rax\" register\nah     # 8 high bits of the \"ax\" part of the \"rax\" register\nal     # 8 low bits of the \"ax\" part of the \"rax\" register\n```", "```rs\ncargo init\n```", "```rs\nuse core::arch::asm;\n```", "```rs\nconst SSIZE: isize = 48;\n```", "```rs\n#[derive(Debug, Default)]\n#[repr(C)]\nstruct ThreadContext {\n    rsp: u64,\n}\n```", "```rs\nfn hello() -> ! {\n    println!(\"I LOVE WAKING UP ON A NEW STACK!\");\n    loop {}\n}\n```", "```rs\nunsafe fn gt_switch(new: *const ThreadContext) {\n    asm!(\n        \"mov rsp, [{0} + 0x00]\",\n        \"ret\",\n        in(reg) new,\n    );\n}\n```", "```rs\nunsafe gt_switch(new: *const ThreadContext)\n```", "```rs\nasm!(\n```", "```rs\n\"mov rsp, [{0} + 0x00]\",\n```", "```rs\nin(reg) new,\n```", "```rs\nfn main() {\n    let mut ctx = ThreadContext::default();\n    let mut stack = vec![0_u8; SSIZE as usize];\n    unsafe {\n        let stack_bottom = stack.as_mut_ptr().offset(SSIZE);\n        let sb_aligned = (stack_bottom as usize & !15) as *mut u8;\n        std::ptr::write(sb_aligned.offset(-16) as *mut u64, hello as u64);\n        ctx.rsp = sb_aligned.offset(-16) as u64;\n        gt_switch(&mut ctx);\n    }\n}\n```", "```rs\nFinished dev [unoptimized + debuginfo] target(s) in 0.58s\nRunning `target\\debug\\a-stack-swap`\nI LOVE WAKING UP ON A NEW STACK!\n```", "```rs\nfor i in 0..SSIZE {\n    println!(\"mem: {}, val: {}\",\n    sb_aligned.offset(-i as isize) as usize,\n    *sb_aligned.offset(-i as isize))\n}\n```", "```rs\nmem: 2643866716720, val: 0\nmem: 2643866716719, val: 0\nmem: 2643866716718, val: 0\nmem: 2643866716717, val: 0\nmem: 2643866716716, val: 0\nmem: 2643866716715, val: 0\nmem: 2643866716714, val: 0\nmem: 2643866716713, val: 0\nmem: 2643866716712, val: 0\nmem: 2643866716711, val: 0\nmem: 2643866716710, val: 0\nmem: 2643866716709, val: 127\nmem: 2643866716708, val: 247\nmem: 2643866716707, val: 172\nmem: 2643866716706, val: 15\nmem: 2643866716705, val: 29\nmem: 2643866716704, val: 240\nmem: 2643866716703, val: 0\nmem: 2643866716702, val: 0\nmem: 2643866716701, val: 0\nmem: 2643866716700, val: 0\nmem: 2643866716699, val: 0\n...\nmem: 2643866716675, val: 0\nmem: 2643866716674, val: 0\nmem: 2643866716673, val: 0\nI LOVE WAKING UP ON A NEW STACK!\n```", "```rs\n#![feature(naked_functions)]\nuse std::arch::asm;\nconst DEFAULT_STACK_SIZE: usize = 1024 * 1024 * 2;\nconst MAX_THREADS: usize = 4;\nstatic mut RUNTIME: usize = 0;\n```", "```rs\npub struct Runtime {\n    threads: Vec<Thread>,\n    current: usize,\n}\n#[derive(PartialEq, Eq, Debug)]\nenum State {\n    Available,\n    Running,\n    Ready,\n}\nstruct Thread {\n    stack: Vec<u8>,\n    ctx: ThreadContext,\n    state: State,\n}\n#[derive(Debug, Default)]\n#[repr(C)]\nstruct ThreadContext {\n    rsp: u64,\n    r15: u64,\n    r14: u64,\n    r13: u64,\n    r12: u64,\n    rbx: u64,\n    rbp: u64,\n}\n```", "```rs\nimpl Thread {\n    fn new() -> Self {\n        Thread {\n            stack: vec![0_u8; DEFAULT_STACK_SIZE],\n            ctx: ThreadContext::default(),\n            state: State::Available,\n        }\n    }\n}\n```", "```rs\nimpl Runtime {\n  pub fn new() -> Self {\n    let base_thread = Thread {\n      stack: vec![0_u8; DEFAULT_STACK_SIZE],\n      ctx: ThreadContext::default(),\n      state: State::Running,\n    };\n    let mut threads = vec![base_thread];\n    let mut available_threads: Vec<Thread> = (1..MAX_THREADS).map(|_| Thread::new()).collect();\n    threads.append(&mut available_threads);\n    Runtime {\n      threads,\n      current: 0,\n    }\n  }\n```", "```rs\n    pub fn init(&self) {\n        unsafe {\n            let r_ptr: *const Runtime = self;\n            RUNTIME = r_ptr as usize;\n        }\n    }\n```", "```rs\n    pub fn run(&mut self) -> ! {\n        while self.t_yield() {}\n        std::process::exit(0);\n    }\n```", "```rs\n    fn t_return(&mut self) {\n        if self.current != 0 {\n            self.threads[self.current].state = State::Available;\n            self.t_yield();\n        }\n    }\n```", "```rs\n    #[inline(never)]\n    fn t_yield(&mut self) -> bool {\n        let mut pos = self.current;\n        while self.threads[pos].state != State::Ready {\n            pos += 1;\n            if pos == self.threads.len() {\n                pos = 0;\n            }\n            if pos == self.current {\n                return false;\n            }\n        }\n        if self.threads[self.current].state != State::Available {\n            self.threads[self.current].state = State::Ready;\n        }\n        self.threads[pos].state = State::Running;\n        let old_pos = self.current;\n        self.current = pos;\n        unsafe {\n            let old: *mut ThreadContext = &mut self.threads[old_pos].ctx;\n            let new: *const ThreadContext = &self.threads[pos].ctx;\n            asm!(\"call switch\", in(\"rdi\") old, in(\"rsi\") new, clobber_abi(\"C\"));\n        }\n        self.threads.len() > 0\n    }\n```", "```rs\npub fn spawn(&mut self, f: fn()) {\n    let available = self\n        .threads\n        .iter_mut()\n        .find(|t| t.state == State::Available)\n        .expect(\"no available thread.\");\n    let size = available.stack.len();\n    unsafe {\n        let s_ptr = available.stack.as_mut_ptr().offset(size as isize);\n        let s_ptr = (s_ptr as usize & !15) as *mut u8;\n        std::ptr::write(s_ptr.offset(-16) as *mut u64, guard as u64);\n        std::ptr::write(s_ptr.offset(-24) as *mut u64, skip as u64);\n        std::ptr::write(s_ptr.offset(-32) as *mut u64, f as u64);\n        available.ctx.rsp = s_ptr.offset(-32) as u64;\n    }\n    available.state = State::Ready;\n}\n} // We close the `impl Runtime` block here\n```", "```rs\nfn guard() {\n    unsafe {\n        let rt_ptr = RUNTIME as *mut Runtime;\n        (*rt_ptr).t_return();\n    };\n}\n```", "```rs\n#[naked]\nunsafe extern \"C\" fn skip() {\n    asm!(\"ret\", options(noreturn))\n}\n```", "```rs\npub fn yield_thread() {\n    unsafe {\n        let rt_ptr = RUNTIME as *mut Runtime;\n        (*rt_ptr).t_yield();\n    };\n}\n```", "```rs\n#[naked]\n#[no_mangle]\nunsafe extern \"C\" fn switch() {\n    asm!(\n        \"mov [rdi + 0x00], rsp\",\n        \"mov [rdi + 0x08], r15\",\n        \"mov [rdi + 0x10], r14\",\n        \"mov [rdi + 0x18], r13\",\n        \"mov [rdi + 0x20], r12\",\n        \"mov [rdi + 0x28], rbx\",\n        \"mov [rdi + 0x30], rbp\",\n        \"mov rsp, [rsi + 0x00]\",\n        \"mov r15, [rsi + 0x08]\",\n        \"mov r14, [rsi + 0x10]\",\n        \"mov r13, [rsi + 0x18]\",\n        \"mov r12, [rsi + 0x20]\",\n        \"mov rbx, [rsi + 0x28]\",\n        \"mov rbp, [rsi + 0x30]\",\n        \"ret\", options(noreturn)\n    );\n}\n```", "```rs\n0x00[rdi] # 0\n0x08[rdi] # 8\n0x10[rdi] # 16\n0x18[rdi] # 24\n```", "```rs\nfn main() {\n    let mut runtime = Runtime::new();\n    runtime.init();\n    runtime.spawn(|| {\n        println!(\"THREAD 1 STARTING\");\n        let id = 1;\n        for i in 0..10 {\n            println!(\"thread: {} counter: {}\", id, i);\n            yield_thread();\n        }\n        println!(\"THREAD 1 FINISHED\");\n    });\n    runtime.spawn(|| {\n        println!(\"THREAD 2 STARTING\");\n        let id = 2;\n        for i in 0..15 {\n            println!(\"thread: {} counter: {}\", id, i);\n            yield_thread();\n        }\n        println!(\"THREAD 2 FINISHED\");\n    });\n    runtime.run();\n}\n```", "```rs\nFinished dev [unoptimized + debuginfo] target(s) in 2.17s\nRunning `target/debug/green_threads`\nTHREAD 1 STARTING\nthread: 1 counter: 0\nTHREAD 2 STARTING\nthread: 2 counter: 0\nthread: 1 counter: 1\nthread: 2 counter: 1\nthread: 1 counter: 2\nthread: 2 counter: 2\nthread: 1 counter: 3\nthread: 2 counter: 3\nthread: 1 counter: 4\nthread: 2 counter: 4\nthread: 1 counter: 5\nthread: 2 counter: 5\nthread: 1 counter: 6\nthread: 2 counter: 6\nthread: 1 counter: 7\nthread: 2 counter: 7\nthread: 1 counter: 8\nthread: 2 counter: 8\nthread: 1 counter: 9\nthread: 2 counter: 9\nTHREAD 1 FINISHED.\nthread: 2 counter: 10\nthread: 2 counter: 11\nthread: 2 counter: 12\nthread: 2 counter: 13\nthread: 2 counter: 14\nTHREAD 2 FINISHED.\n```"]