<html><head></head><body>
		<div><h1 id="_idParaDest-22"><em class="italic"><a id="_idTextAnchor022"/>Chapter 2</em>: Understanding Emscripten</h1>
			<p>In this chapter, we will learn about <strong class="bold">Emscripten</strong>, which is a toolchain to convert C/C++ code into a WebAssembly module. </p>
			<p>Emscripten consists of two components:</p>
			<ul>
				<li>Emscripten compiler frontend</li>
				<li><strong class="bold">Emscripten SDK</strong> (<strong class="bold">emsdk</strong>)</li>
			</ul>
			<p>The <strong class="bold">Clang</strong> compiler frontend<a id="_idIndexMarker033"/> compiles C/C++ code into<a id="_idTextAnchor023"/> <strong class="bold">LLVM intermediate representation</strong> (<strong class="bold">LLVM IR</strong>) and then uses the LLVM backend<a id="_idIndexMarker034"/> to convert the LLVM IR into native code. The Clang compiler is fast, uses little memory, and is compatible with <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>). Emscripten is similar to Clang; the former produces <a id="_idTextAnchor024"/>a <em class="italic">wasm</em> binary while the latter produces a <em class="italic">native</em> binary. The <strong class="bold">Emscripten compiler frontend</strong> (<strong class="bold">emcc</strong>) is the compiler frontend<a id="_idIndexMarker035"/> that converts C/C++ into LLVM IR (both binary and human-readable form) and into the WebAssembly binary <a id="_idTextAnchor025"/>or <em class="italic">asm.js</em>, such as JavaScript.</p>
			<p class="figure-caption">  </p>
			<div><div><img src="img/Figure_2.1_B14844.jpg" alt="Figure 2.1 – Emscripten compiler frontend&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Emscripten compiler fronten<a id="_idTextAnchor026"/>d</p>
			<p><strong class="bold">emsdk</strong> helps manage and maintain<a id="_idIndexMarker036"/> the Emscripten toolchain components and set up the runtime/terminal environment to run emcc.</p>
			<p>In this chapter, we will learn how to install Emscripten. Then, we will use Emscripten to generate asm.js, a WebAssembly module that runs on Node.js and the browser. After that, we will explore the emsdk tool. Finally, we will explore various optimizations provided by Emscripten. We will cover the following topics in this chapter:</p>
			<ul>
				<li>Installing Emscripten using emsdk</li>
				<li>Generating asm.js using Emscripten</li>
				<li>Running Hello World with Emscripten <a id="_idTextAnchor027"/>in Node.js</li>
				<li>Running Hello World with Emscripten in the browser</li>
				<li>Exploring other options in emsdk</li>
				<li>Understanding various levels of optimizations<p class="callout-heading">Did You Know?</p><p class="callout">asm.js is a subset of JavaScript that is optimized to run at near-native performance in the browser. The asm.js spec was not accepted by all browser vendors. asm.js has evolved into WebAssembly.</p></li>
			</ul>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>We will be showing how to set up Emscripten in this chapter, for which you will require the following installed on your system: </p>
			<ul>
				<li>Python &gt;= 3.7 </li>
				<li>Node.js &gt; 12.18<p class="callout-heading">Note </p><p class="callout">emsdk comes prebundled with a compatible Node.js version. </p></li>
			</ul>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor029"/>Installing Emscripten using emsdk</h1>
			<p>emsdk provides an easy way<a id="_idIndexMarker037"/> to install, manage, and switch versions of the Emscripten<a id="_idIndexMarker038"/> toolchain. emsdk takes care of setting up the environment, tools, and SDK required for compiling C/C++ to LLVM IR and then to JavaScript in the form of asm.js or the WebAssembly binary. </p>
			<p>Let's install Emscripten and start hacking:</p>
			<ol>
				<li>Clone the e<a id="_idTextAnchor030"/>msdk repo and go into the <code>emsdk</code> folder:<pre><strong class="bold">$ git clone https://github.com/emscripten-core/emsdk</strong>
<strong class="bold">$ cd emsdk</strong></pre></li>
				<li>To install emsdk on the machine, run the following command: </li>
			</ol>
			<p>For *nix users, use the following:</p>
			<pre><strong class="bold">$ ./emsdk install latest</strong></pre>
			<p>For Windows users, use the following:</p>
			<pre><strong class="bold">$ emsdk install latest</strong></pre>
			<p class="callout-heading">Note </p>
			<p class="callout">The preceding command might take a while to run; it will build and set up the entire toolchain.  </p>
			<p>Next, we will activate the latest emsdk. The activation updates the local shell with the necessary environment references and makes the latest SDK active for the user in the current shell. It writes the path and other necessary information for the Emscripten toolchain to work under the user's home directory in a file called <code>.emscripten</code>:</p>
			<ol>
				<li value="3">To activate the installed emsdk, run the following command:</li>
			</ol>
			<p>For *nix users, use the following:</p>
			<pre><strong class="bold"> $ ./emsdk activate latest</strong></pre>
			<p>For Windows users, use the following:</p>
			<pre><strong class="bold"> $ emsdk activate latest</strong></pre>
			<ol>
				<li value="4">Now it is time to make sure the configurations<a id="_idIndexMarker039"/> and paths are activated<a id="_idIndexMarker040"/> by running the following:</li>
			</ol>
			<p>For *nix users, use the following:</p>
			<pre><strong class="bold"> $ source ./emsdk_env.sh</strong></pre>
			<p>For Windows users, use the following:</p>
			<pre><strong class="bold"> $ emsdk_env.bat</strong></pre>
			<p>Congrats, the Emscripten toolchain is installed! Updating the toolchain with emsdk is as easy as installing it.</p>
			<p>To update, run the following command:</p>
			<p>For *nix users, use the following:</p>
			<pre>$ ./emsdk update</pre>
			<p>For Windows users, use the following:</p>
			<pre>$ emsdk update</pre>
			<p>emsdk sets up the following paths inside the Emscripten configuration file. The Emscripten configuration file (<code>.emscripten</code>) is in the home folder. It consists of the following:</p>
			<ul>
				<li><code>LLVM_ROOT</code> – specifies the path of the LLVM Clang compiler</li>
				<li><code>NODE_JS</code> – specifies the path of Node.js</li>
				<li><code>BINARYEN_ROOT</code> – specifies the optimizer for the Emscripten compiler</li>
				<li><code>EMSCRIPTEN_ROOT</code> – specifies the path of the Emscripten compiler</li>
			</ul>
			<p>We can check whether the installation of emcc was successful by using the following command:</p>
			<pre> $ emcc --version</pre>
			<p>Now that we have finished installing the Emscripten compiler, let's go ahead and use it.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor031"/>Generating asm.js using Emscripten</h1>
			<p>We will use Emscripten to port C/C++ programs<a id="_idIndexMarker041"/> into asm.js or the WebAssembly binary<a id="_idIndexMarker042"/> and then run them inside the JavaScript engine.  </p>
			<p class="callout-heading">Note </p>
			<p class="callout">Programming languages such as Lua and Python have a C/C++ runtime. With Emscripten, we can port the runtime as a WebAssembly module and execute them inside the JavaScript engine. This makes it easy to run Lua/Python code on the JavaScript engine. Thus, Emscripten and WebAssembly allow the running of native code in the JavaScript engine.</p>
			<p>First, let's create a <code>sum.cpp</code> file:</p>
			<pre> // sum.cpp
extern "C" {
  unsigned sum(unsigned a, unsigned b) {
      return a + b;
  }
}</pre>
			<p>Consider <code>extern "C"</code> as something like an <em class="italic">export</em> mechanism. All the functions inside are available as an exported function without any changes to their name. Then, we define the normal <code>sum</code> function that takes in two numbers and returns a number.</p>
			<p>In order to generate the asm.js like JavaScript code from <code>sum.cpp</code>, use the following command:</p>
			<pre>$ emcc -O1 ./sum.cpp -o sum.html -s WASM=0 -s EXPORTED_FUNCTIONS='["_sum"]'</pre>
			<p class="callout-heading">Note </p>
			<p class="callout">If you are running emcc for the first time, it might take a few seconds to complete. Subsequent runs will be faster.</p>
			<p>We pass in the <code>-O1</code> option to the emcc compiler, instructing the compiler<a id="_idIndexMarker043"/> to produce less-optimized code (we will see more options to optimize later in this chapter). Next, we pass the file<a id="_idIndexMarker044"/> to be converted, that is, <code>sum.cpp</code>. Then, with the <code>-o</code> flag, we provide the desired name for the output, which is <code>sum.html</code>. </p>
			<p>Finally, we send in more information to the emcc compiler using the <code>-s</code> flag. The <code>-s</code> flag takes in a key and value as their arguments. The emcc compiler generates the WebAssembly module by default. <code>WASM=0</code> instructs the compiler to generate asm.js like JavaScript instead of WebAssembly.</p>
			<p>Then, we specify the exported functions using the <code>EXPORTED_FUNCTIONS</code> option. The <code>EXPORTED_FUNCTIONS</code> option takes an array of arguments. In order to export the <code>sum</code> function, we specify <code>_sum</code>.</p>
			<p>This will generate the following code:</p>
			<pre>function _sum($0,$1) {
    $0 = $0|0;
    $1 = $1|0;
    var $2 = 0, label = 0, sp = 0;
    sp = STACKTOP;
    $2 = (($1) + ($0))|0;
   return ($2|0);
}</pre>
			<p class="callout-heading"> Note </p>
			<p class="callout"><code>|0</code> specifies the type as a number. </p>
			<p>Now open <code>sum.html</code> in a browser and open the developer console. In order to call the exported function, we will run the following expression in the console:</p>
			<pre> ccall("sum", "number", "number, number", [10, 20])
// outputs 30</pre>
			<p><code>ccall</code> is the way to call the exported function<a id="_idIndexMarker045"/> from C/C++ code via JavaScript. The function takes<a id="_idIndexMarker046"/> in the name of the function, the type of the return value, types of arguments, and then the input arguments as an array. This will invoke the <code>sum</code> function to produce the result. We will see more about <code>ccall</code> and <code>cwrap</code> in later chapters. But for now, consider <code>ccall</code> a way to call the C function.</p>
			<p>Find out more about the Emscripten source at <a href="https://github.com/emscripten-core/emscripten">https://github.com/emscripten-core/emscripten</a>.</p>
			<p>So far, we have seen how to generate asm.js files using emscripten. Let us use emscripten to create a WebAssembly Module to run on Node.js.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>Running Hello World with Emscripten in Node.js</h1>
			<p>In this section, we will see how to convert C/C++ code<a id="_idIndexMarker047"/> into the WebAssembly binary via Emscripten<a id="_idIndexMarker048"/> and run it along with Node.js.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If the terminal errors out with <em class="italic">emcc command not found</em>, your terminal environment might have been reset. To set up the environment, run the following command from inside the <code>emsdk</code> folder: </p>
			<p class="callout"><strong class="bold">source ./emsdk_env.sh </strong></p>
			<p>Let's follow the tradition of Brian Kernighan, by writing "Hello, world" with a slight twist. Let's do a "Hello, Web":</p>
			<ol>
				<li value="1">First, we create a <code>hello_web.c</code> file:<pre><strong class="bold">$ touch hello_web.c</strong></pre></li>
				<li>Launch your favorite editor and add the following code:<pre> #include &lt;stdio.h&gt;
 
int main() {
    printf("Hello, Web!\n");
    return 0;
}</pre></li>
			</ol>
			<p>It is a simple C program with a <code>main</code> function. The <code>main</code> function is the entry point during the runtime. When this code<a id="_idIndexMarker049"/> is compiled and executed<a id="_idIndexMarker050"/> using Clang (<code>clang sum.c &amp;&amp; ./a.out</code>), "Hello, Web!" is printed. Now, instead of Clang (or any other compiler), let's compile the code with emcc.</p>
			<ol>
				<li value="3">We enter the following command to compile the code with emcc:<pre><strong class="bold"> $ emcc hello_web.c</strong></pre></li>
			</ol>
			<p>Once completed, the following files are generated:</p>
			<ul>
				<li><code>a.out.js</code></li>
				<li><code>a.out.wasm</code></li>
			</ul>
			<p>The generated JavaScript file is huge. It has more than 2,000 lines and is 109 KB in size. We will learn how to optimize the file size later in this chapter.</p>
			<ol>
				<li value="4">Let's run the generated JavaScript file using Node and that will print out "Hello, Web!":<pre><strong class="bold">$ node a.out.js</strong>
<strong class="bold">Hello, Web!</strong></pre></li>
			</ol>
			<p>Congratulations! You just ran your first WebAssembly binary!</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Binary size matters in the world of browsers. It won't matter if your algorithm runs in nanoseconds if you have a huge chunk of code. The browser waits till it receives all the necessary information before it starts to parse and compile. So, it is mandatory to check the file size. <em class="italic">Closure Compiler</em> helps to minimize<a id="_idIndexMarker051"/> the byte code size further. Closure Compiler not only reduces the code size but also tries to make the code more efficient.</p>
			<p>The generated JavaScript file contains its own runtime<a id="_idIndexMarker052"/> and configuration needed for the JavaScript engine to execute the WebAssembly<a id="_idIndexMarker053"/> module inside the JavaScript engine. The generated JavaScript file creates a JavaScript module and initializes code for both browsers and Node.js:</p>
			<ul>
				<li>In Node.js, the generated JavaScript file creates a module by reading the file from the local filesystem. It gets the arguments passed to the node command and sets them up in the module created.</li>
				<li>In browsers, the generated JavaScript file creates a module by framing a request and fetches it as bytes from a URL. The browser fetches the WebAssembly binary from the hosted server or location and then instantiates the module.</li>
			</ul>
			<p>The generated JavaScript file also creates a stack, memory, import, and export sections. We will deep dive into those sections later in this book.</p>
			<p>This generated JavaScript file is called a <em class="italic">binding file</em>. The main function of the binding file<a id="_idIndexMarker054"/> is to create or set an environment that enables executing a WebAssembly module inside the JavaScript engine. The binding file acts as a translator between JavaScript and WebAssembly. All the values are passed in and out via this binding file.</p>
			<p>When the JavaScript file is executed via node, it does the following.</p>
			<p>The JavaScript engine first loads the module and then sets up the constants and various functions that are required for WebAssembly to execute. Then, the module checks where the code is being executed, whether the module is inside the browser or in the `Node` environment. Based on that, it fetches the file. Since we are running the WebAssembly Module via the node here, it fetches the file from the local filesystem. Then, the module is checked for any arguments provided for the call. If not, the JavaScript engine will check whether there are any unhandled/uncaught exceptions. The JavaScript engine then maps the <code>print out</code>/<code>print err</code> function to the console. The JavaScript engine checks whether the module loaded has all the required access and global variables and imports are available for execution.</p>
			<p>The module goes on to initialize the stack and other required constants as well as the decoder and encoder for decoding and encoding the buffer, respectively. The encoder is responsible for translating the JavaScript values into WebAssembly-understandable values. The decoder is responsible for translating the WebAssembly values into JavaScript-understandable values. </p>
			<p>The Node.js runtime<a id="_idIndexMarker055"/> then checks the availability<a id="_idIndexMarker056"/> of the file and then initializes the file. The module is checked for all the WebAssembly-related function availability. Once everything is initialized and the module contains all the functions required, we will call the <code>run</code> function.</p>
			<p>The <code>run</code> function instantiates the WebAssembly binary. In this case, since we have defined the <code>main</code> function in C, the binding file calls the <code>main</code> function straight away when instantiated.</p>
			<p>The binding file contains the <code>ccall</code> function. The <code>ccall</code> function is an interface to the underlying function defined in C:</p>
			<pre>function ccall(ident, returnType, argTypes, args, opts)  {
  // the code is elided
}</pre>
			<p>The <code>ccall</code> function accepts the following arguments:</p>
			<ul>
				<li><code>ident</code> – The function to call; it is the function identifier defined in C.</li>
				<li><code>returnType</code> – The return type of the function.</li>
				<li><code>argTypes</code> – The argument types.</li>
				<li><code>args</code> – The arguments that are passed along with the function call.</li>
				<li><code>opts</code> – Any other options that are required.</li>
			</ul>
			<p>The JavaScript module exports the <code>cwrap</code> function in addition to <code>ccall</code>. <code>cwrap</code> is a wrapper function around the <code>ccall</code> function. While <code>ccall</code> is a function invocation, <code>cwrap</code> provides a function that invokes <code>ccall</code>:</p>
			<pre> function cwrap(ident, returnType, argTypes, opts) {
    return function() {
        return ccall(ident, returnType, argTypes,
          arguments, opts);
    }
}</pre>
			<p>The WebAssembly file generated<a id="_idIndexMarker057"/> consists of binary opcode to instruct the runtime<a id="_idIndexMarker058"/> to print "Hello, Web!". The WebAssembly file starts with <code>00 61 73 6d 01 00 00 00</code>.</p>
			<p>Find out more about WebAssembly<a id="_idIndexMarker059"/> specifications at <a href="https://webassembly.github.io/spec/">https://webassembly.github.io/spec/</a>.</p>
			<p>So far, we have seen how to generate a WebAssembly module to run on Node.js. Let us use emscripten to create a WebAssembly Module to run in the browser.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor033"/>Running Hello World with Emscripten in the browser</h1>
			<p>In this section, we will see how to convert C/C++ code into the WebAssembly<a id="_idIndexMarker060"/> binary via Emscripten and run<a id="_idIndexMarker061"/> it in the browser.</p>
			<p class="callout-heading"> Note </p>
			<p class="callout">If the terminal says that the <code>emcc</code> command is not found, it is highly likely that you have missed setting up the environment variables. To set up the environment variables, run the following command from inside the <code>emsdk</code> folder: <code>source ./emsdk_env.sh</code></p>
			<p>Let's use the same code example used in the <em class="italic">Generating asm.js using Emscripten</em> section . Now, instead of just running emcc, let's pass the <code>-o</code> option and instruct emcc to generate the <code>.html</code> file:</p>
			<pre>$ emcc hello_web.c -o helloweb.html</pre>
			<p>Once completed, the following files are generated:</p>
			<ul>
				<li><code>helloweb.js</code></li>
				<li><code>helloweb.wasm</code></li>
				<li><code>helloweb.html</code></li>
			</ul>
			<p>Similar to the Node example, the generated JavaScript file is huge. We will learn how to optimize the file size later in this chapter.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The <code>-o</code> option ensures all the files generated have the name <code>helloweb</code>.</p>
			<p>In order to run the generated HTML file<a id="_idIndexMarker062"/> in the browser, we will need a web<a id="_idIndexMarker063"/> server. The web server serves the HTML file over the HTTP protocol. Explaining web servers<a id="_idIndexMarker064"/> and how they work is beyond the scope of this book; refer to <a href="https://en.wikipedia.org/wiki/Web_server">https://en.wikipedia.org/wiki/Web_server</a> for more details.</p>
			<p>Python provides an easy way to run the web server. In order to run the web server using Python, run the following command:</p>
			<pre>$ python -m http.server &lt;port number&gt;</pre>
			<p>Open <code>http://localhost:&lt;port number&gt;</code> to see WebAssembly in action in the browser.</p>
			<p class="figure-caption">  </p>
			<div><div><img src="img/Figure_2.2_B14844.jpg" alt="Figure 2.2 – Browser running WebAssembly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Browser running WebAssembly</p>
			<p>When the JavaScript file is executed via the browser, it prints out <code>run</code> function. The <code>run</code> function instantiates the WebAssembly binary. In this case, since we have defined the <code>main</code> function in C, the binding file calls the <code>main</code> function straight away when instantiated.</p>
			<p>Emscripten<a id="_idIndexMarker067"/> also provides <code>emrun</code> to run HTML files. Check out <a href="https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html">https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html</a> for more information.</p>
			<p>Find out more about deploying<a id="_idIndexMarker068"/> Emscripten-compiled pages at <a href="https://emscripten.org/docs/compiling/Deploying-Pages.html">https://emscripten.org/docs/compiling/Deploying-Pages.html</a>.</p>
			<p>We have used Emscripten to generate the WebAssembly module. Let's go ahead and explore what else the emsdk can do.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor034"/>Exploring other options in emsdk </h1>
			<p>emsdk is a single-stop shop for installing, maintaining, and managing all the tools and toolchains required<a id="_idIndexMarker069"/> for using Emscripten. emsdk makes it easier to bootstrap the environment, upgrade to the latest versions, switch to various versions, change or configure various tools, and so on.</p>
			<p>The <code>emsdk</code> command is available inside the <code>emsdk</code> folder. Go to the <code>emsdk</code> folder and run the <code>emsdk</code> command. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">For all the commands in this chapter, for *nix systems, use <code>./emsdk</code>, and for Windows, use <code>emsdk</code>. </p>
			<p>To find the various options available in the <code>emsdk</code> command, run the following command:</p>
			<pre>$ ./emsdk --help
emsdk: Available commands:
emsdk list [--old] [--uses] - To list down the tools
emsdk update - To update the emsdk to the latest version.
emsdk update-tags - To fetch the latest tags from the GitHub 
  repository.
emsdk install - To install the tools and SDK.
emsdk uninstall - To uninstall the tools and SDK installed 
  previously.
emsdk activate - To activate the currently installed version.</pre>
			<p>An <code>emsdk</code> command takes the following format: </p>
			<pre>emsdk &lt;option&gt; &lt;Tool / SDK &gt; --&lt;flags&gt;</pre>
			<p>The <code>emsdk</code> command<a id="_idIndexMarker070"/> consists of the following: </p>
			<ul>
				<li><code>&lt;option&gt;</code></li>
			</ul>
			<p>This can be one of the following: list, update, update-tags, install, uninstall, or activate. </p>
			<ul>
				<li><code>&lt;Tool/SDK&gt;</code></li>
			</ul>
			<p>This refers to libraries and it includes Emscripten and LLVM. <code>SDK</code> refers to emsdk itself.</p>
			<ul>
				<li><code>--&lt;flags&gt;</code></li>
			</ul>
			<p>This refers to various configuration options. </p>
			<p>Let us explore each of the options and flags that emsdk command supports.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor035"/>Listing the tools and SDK</h2>
			<p>Here, we show how to list the tools<a id="_idIndexMarker071"/> and SDK that are available with emsdk. Run the following command:</p>
			<pre>$ ./emsdk list
 
The *recommended* precompiled SDK download is 2.0.6 
  (4ba921c8c8fe2e8cae071ca9889d5c27f5debd87).
 
To install/activate it, use one of:
        latest                  [default (llvm) backend]
        latest-fastcomp         [legacy (fastcomp) backend]
 
Those are equivalent to installing/activating the following:
         2.0.6             INSTALLED
         2.0.6-fastcomp
 
All recent (non-legacy) installable versions are:
         2.0.6    INSTALLED
         ...
 
The additional following precompiled SDKs are also available 
  for download:
         sdk-fastcomp-1.38.31-64bit
 
The following SDKs can be compiled from source:
         sdk-upstream-master-64bit
          ...
The following precompiled tool packages are available for 
  download:
        ...
     *     node-12.18.1-64bit         INSTALLED
     *     python-3.7.4-2-64bit       INSTALLED
           emscripten-1.38.30
        ...
The following tools can be compiled from source:
           llvm
           clang
           emscripten
           binaryen
 
Items marked with * are activated for the current user.
 
To access the historical archived versions, type 'emsdk list 
  --old'
 
Run "git pull" followed by "./emsdk update-tags" to pull 
  in the latest list.</pre>
			<p><code>emsdk list</code> lists all tool packages<a id="_idIndexMarker072"/> and SDKs that are available. This list of tools and SDKs includes the last few versions of LLVM, Clang, Emscripten, and Binaryen. They even have Node versions 8 and 12 and Python 3.7. emsdk maintains and manages <code>emsdk</code>. This means that we need to know the information about the current version that we are using and how to update it. The <code>emsdk list</code> command also provides more detail on the SDK components along with a list of those compiled from the sources.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor036"/>Managing the tools and SDK</h2>
			<p>emsdk provides an option<a id="_idIndexMarker073"/> to install, update, and uninstall the tools and SDK.</p>
			<p>In order to install the tools, SDK, or emsdk itself, use the following:</p>
			<pre>$ ./emsdk install &lt;tool / SDK to install&gt;</pre>
			<p>To install the latest version of the SDK, you can run the following:</p>
			<pre>./emsdk install latest</pre>
			<p class="callout-heading">Note </p>
			<p class="callout"><code>latest</code> refers to the latest version of emsdk.</p>
			<p>To install multiple tools with the <code>emsdk install</code> command, use the following:</p>
			<pre>./emsdk install &lt;tool1&gt; &lt;tool2&gt; &lt;tool3&gt;</pre>
			<p>You can also specify multiple<a id="_idIndexMarker074"/> options for the <code>install</code> command. You can pass in options to the <code>install</code> command like this:</p>
			<pre> ./emsdk install [options] &lt;tools / SDK&gt;</pre>
			<p>The various <code>options</code> available are as follows:</p>
			<ul>
				<li>Number of cores to build</li>
				<li>Type of build</li>
				<li>Activation of tools and SDK</li>
				<li>Uninstallation </li>
			</ul>
			<h3>Number of cores to build</h3>
			<p>The initial setup will take a long time to build and install<a id="_idIndexMarker075"/> the required tools and SDK. Based on your requirements, you can control the number of cores that you need for building and installing the required tools and SDK:</p>
			<pre>./emsdk install -j&lt;number of cores to use for building&gt; &lt;tools 
  / SDK&gt;</pre>
			<h3>Type of build</h3>
			<p>You instruct <code>emsdk</code> on what type of build<a id="_idIndexMarker076"/> is to be used to make LLVM perform:</p>
			<pre>./emsdk install --build=&lt;type&gt; &lt;tools / SDK&gt;</pre>
			<p><code>type</code> accepts the following options:</p>
			<ul>
				<li> Debug<ul><li>This type is used for debugging.</li><li>It generates Symbol files.</li><li>The end build will not produce optimized, fast code.</li></ul></li>
				<li>Release<ul><li>This type will generate optimized, fast code.</li></ul></li>
				<li>MinSizeRel<ul><li>This type is the same as Release.</li><li>This type will minimize the size and maximize the speed.</li><li>This uses optimization options such as <code>-O1</code> (minimize size) and <code>-O2</code> (maximize speed).</li></ul></li>
				<li>RelWithDebInfo<ul><li>This type is the same as Release.</li><li>This type<a id="_idIndexMarker077"/> will also generate Symbol files. That will help in debugging.</li></ul></li>
			</ul>
			<h3>Activation of the tools and SDK</h3>
			<p>After the tools and SDK<a id="_idIndexMarker078"/> are installed, we can activate different versions to use them. The <code>activate</code> command generates the necessary configuration files mapping the path, with the built executables.</p>
			<p>To activate the tools and SDK, run the following:</p>
			<pre>./emsdk activate &lt;tools / SDK to activate&gt;</pre>
			<p>The <code>activate</code> command accepts a few options; they are as follows:</p>
			<ul>
				<li><code>--embedded</code> – This option makes sure all the built files, configuration, cache, and temporary files are located inside the directory in which the emsdk command is located.</li>
			</ul>
			<p>If not specified, this command will move the configuration file to the user's home directory.</p>
			<ul>
				<li><code>--build=&lt;type&gt;</code> – Similar to the type of build that LLVM supports. For example, Debug, Release, MinSizeRel, RelWithDebInfo.</li>
			</ul>
			<h3>Uninstallation of the tools and SDK</h3>
			<p>To uninstall<a id="_idIndexMarker079"/> the tools and SDK, we can run the following:</p>
			<pre>./emsdk uninstall &lt; tools / SDK to uninstall&gt; </pre>
			<p>Find out more about<a id="_idIndexMarker080"/> the tools at <a href="https://emscripten.org/docs/tools_reference/index.html">https://emscripten.org/docs/tools_reference/index.html</a>.</p>
			<p>We have explored how emsdk helps us to manage tools and SDKs; let's go ahead and explore various optimizations provided by Emscripten.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor037"/>Understanding various levels of optimizations</h1>
			<p>C/C++ programs are compiled and converted<a id="_idIndexMarker081"/> into native code via Clang or the GCC compiler. Clang or the GCC compiler converts the C/C++ program based on the target. Target here refers to the end machine where the code is executed. emcc has the Clang compiler built in. The emcc compiler is responsible for converting the C or C++ source code into LLVM byte code.</p>
			<p>In this section, we will see how to improve the optimization and code size of the generated WebAssembly binary code. </p>
			<p>To improve the efficiency and generated code size, the Emscripten compiler has the following options:</p>
			<ul>
				<li>Optimizations</li>
				<li>Closure Compiler</li>
			</ul>
			<p>Lets talk about optimizations first.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor038"/>Optimizations</h2>
			<p>The goal of the compiler is to reduce the cost of compilation, that is, the compile time. With the <code>-O</code> optimization flag, the compiler<a id="_idIndexMarker082"/> tries to improve the code size and/or the performance at the expense of the compile time. In terms of compiler optimizations, code size and performance are mutually exclusive. The faster the compile time, the lower the optimization. To specify the optimization, we use the <code>-O&lt;0/1/2/3/s/z&gt;</code> flag. Each of the options includes various assertions, code size optimizations, and code performance optimizations, along with others.</p>
			<p> The following are the various optimizations available:</p>
			<ul>
				<li><code>-O0</code> – This is the default option<a id="_idIndexMarker083"/> and a perfect starter to experiment. This option means "no optimizations." This optimization level compiles the fastest and generates the most debuggable code. This is a basic optimization level. This option tries to inline functions. </li>
				<li><code>-O1</code> – This option adds simple optimizations and tries to generate a minimum code size. This option removes runtime assertions in the generated code and builds slower than the <code>-O0</code> option. This option also tries to simplify the loops.</li>
				<li><code>-O2</code> – This option adds further optimizations than <code>-O1</code>. It is slower than <code>-O1</code> but generates code that is more optimized than the <code>-O1</code> option. This option optimizes the code based on JavaScript optimization and removes code that is not part of JavaScript modules. This option removes the inline functions and the <code>vectorize-loop</code> option is set. This option adds a moderate level of optimization. This option also adds dead code elimination.</li>
			</ul>
			<p>Vectorization will instruct the processor to do the operation in chunks rather than doing it one by one.</p>
			<ul>
				<li> <code>-O3</code> – This option adds more options, takes more time to compile, and generates more optimized code than the <code>-O2</code> option.</li>
			</ul>
			<p>This option produces optimal production-ready code. This option is like <code>-O2</code>, except that it enables optimizations that take longer to perform or that may generate larger code (in an attempt to make the program run faster).</p>
			<ul>
				<li> <code>-Os</code> – This option is similar to <code>-O2</code>. It adds extra optimizations and reduces the code size. Reducing the code size in turn decreases the performance. This option generates smaller code than <code>-O2</code>.</li>
				<li> <code>-Oz</code> – This option is similar to <code>-Os</code> but reduces the code size even further. This option takes more compile time to generate the binary code.</li>
			</ul>
			<p>We will now explore the various optimization options provided by Emscripten:</p>
			<ol>
				<li value="1">First, we create<a id="_idIndexMarker084"/> a C file called <code>optimization_check</code>:<pre><strong class="bold">$ touch optimization_check.c</strong></pre></li>
				<li>Then, open your favorite editor and add the following code. The following is a simple C file with a <code>main</code> function and a couple of other functions:<pre>#include &lt;stdio.h&gt;
 int addSame(int a) {
    return a + a;
}
 
int add(int a, int b) {
    return a + b;
}
 
int main() {
    printf("Hello, Web!\n");
 
    int a;
    int sum = 0;
    /* for loop execution */
    for( a = 0; a &lt; 20; a = a + 1 ){
       sum = sum + a;
    }
     addSame(sum);
     add(1, 2);
     return 0;
}</pre></li>
				<li>We then compile<a id="_idIndexMarker085"/> this into WebAssembly code using emcc:<pre><strong class="bold">$ time emcc optimization_check.c</strong>
<strong class="bold">emcc optimization_check.c  0.32s user 0.14s system </strong>
<strong class="bold">  90% cpu 0.514 total</strong></pre></li>
				<li>Then, check the sizes of the file generated:<pre><strong class="bold"> $ l</strong>
<strong class="bold">324B optimization_check.c</strong>
<strong class="bold">13K a.out.wasm</strong>
<strong class="bold">109K a.out.js</strong></pre></li>
			</ol>
			<p>We can see that the WebAssembly file generated is about 13 KB and it took a total of 0.514 seconds to compile. That is a fast compilation but the code size is huge.</p>
			<p>In the world of compilers, the faster the compilation, the bigger the code size and the slower the execution speed will be.</p>
			<ol>
				<li value="5">Now, let's optimize it further using the <code>-O1</code> option:<pre><strong class="bold">$ time emcc -O1 optimization_check.c</strong>
<strong class="bold">emcc -O1 optimization_check.c  0.31s user 0.13s system</strong>
<strong class="bold">  86% cpu 0.519 total</strong></pre></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<pre><strong class="bold">$ l</strong>
<strong class="bold">324B optimization_check.c</strong>
<strong class="bold">3.4K a.out.wasm</strong>
<strong class="bold">59K a.out.js</strong></pre>
			<p>The WebAssembly file<a id="_idIndexMarker086"/> generated is about 3.4 KB (3.8 times less than the <code>-O0</code> version) and it took almost the same time, around 0.519 seconds.</p>
			<ol>
				<li value="6">Now, let's optimize it further using the <code>-O2</code> option:<pre><strong class="bold">$ time emcc -O2 optimization_check.c</strong>
<strong class="bold">emcc -O2 optimization_check.c  0.53s user 0.16s system</strong>
<strong class="bold">  111% cpu 0.620 total</strong></pre></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<pre><strong class="bold">$ l</strong>
<strong class="bold">324B optimization_check.c</strong>
<strong class="bold">2K a.out.wasm</strong>
<strong class="bold">20K a.out.js</strong></pre>
			<p>The WebAssembly file generated is about 2 KB (~6.5 times less than <code>-O0</code>) and it took around 0.62 seconds.</p>
			<ol>
				<li value="7">Now, let's optimize it further using the <code>-O3</code> option:<pre><strong class="bold">$ time emcc -O3 --profiling optimization_check.c</strong>
<strong class="bold">emcc -O3 --profiling optimization_check.c  1.03s user</strong>
<strong class="bold">  0.21s system 110% cpu 1.117 total</strong></pre></li>
			</ol>
			<p>Find out more about<a id="_idIndexMarker087"/> the <code>--profiling</code> flag at <a href="https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling">https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling</a>.</p>
			<p>Check the sizes of the file generated:</p>
			<pre><strong class="bold">$ l</strong>
<strong class="bold">324B optimization_check.c</strong>
<strong class="bold">2.0K a.out.wasm</strong>
<strong class="bold">17K a.out.js</strong></pre>
			<p>The WebAssembly file generated is the same size as <code>-02</code> but the generated JavaScript file is 3 KB less, and it took around 1.117 seconds to compile.</p>
			<ol>
				<li value="8">Now, let's optimize<a id="_idIndexMarker088"/> it further using the <code>-Os</code> option:<pre><strong class="bold">$ time emcc -Os optimization_check.c</strong>
<strong class="bold">emcc -Os optimization_check.c  1.03s user 0.22s system</strong>
<strong class="bold">  46% cpu 2.655 total</strong></pre></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<pre><strong class="bold">$ l</strong>
<strong class="bold">324B optimization_check.c</strong>
<strong class="bold">1.7K a.out.wasm</strong>
<strong class="bold">14K a.out.js</strong></pre>
			<p>The WebAssembly file generated is about 1.7 KB (~7.5 times less than <code>-O0</code>) and it took almost 2.655 seconds.</p>
			<ol>
				<li value="9">Now, let's optimize it further using the <code>-Oz</code> option:<pre><strong class="bold">$ time emcc -Oz optimization_check.c</strong>
<strong class="bold">emcc -Oz optimization_check.c  1.03s user 0.21s system</strong>
<strong class="bold">  110% cpu 1.123 total</strong></pre></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<pre><strong class="bold">$ l</strong>
<strong class="bold">324B optimization_check.c</strong>
<strong class="bold">1.7K a.out.wasm</strong>
<strong class="bold">14K a.out.js</strong></pre>
			<p>The WebAssembly file generated<a id="_idIndexMarker089"/> is about 1.7 KB (~7.5 times less than <code>-O0</code>) and it took around 1.123 seconds. </p>
			<p>Next, we'll see an alternative means provided by the Emscripten compiler for improving the efficiency and reducing the generated code size: Closure Compiler</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor039"/>Closure Compiler</h2>
			<p>Closure Compiler is a tool for compiling JavaScript<a id="_idIndexMarker090"/> to better JavaScript. It parses, analyzes, removes<a id="_idIndexMarker091"/> dead code, rewrites, and minimizes JavaScript. Further optimizations on the generated binding JavaScript file and WebAssembly module are done using Closure Compiler. With Closure Compiler, we can do better optimizations on Emscripten code. To optimize the WebAssembly module and JavaScript further, we can use <code>--closure &lt;optimization type&gt;</code>.</p>
			<p>The <code>optimization</code> type has the following options:</p>
			<ul>
				<li><code>--closure 0</code> – This option adds no Closure Compiler optimizations.</li>
				<li><code>--closure 1</code> – This option reduces the generated JavaScript code size. This option does not optimize the asm.js and WebAssembly binary. This adds an additional compilation step that increases the compilation time.</li>
				<li><code>--closure 2</code> – This option optimizes JavaScript, asm.js, and not the WebAssembly binary and reduces the code size of the file drastically for asm.js.</li>
			</ul>
			<p>We will use the <code>–closure 1</code> option to optimize the WebAssembly binary along with the<code>–O3/s</code> Emscripten optimization options:</p>
			<pre>$ time emcc -O3 --closure 1 optimization_check.c
emcc -O3 --closure 1 optimization_check.c  2.40s user 0.42s 
  system 105% cpu 2.681 total</pre>
			<p>The file sizes generated are as follows:</p>
			<pre> $ l
324B optimization_check.c
1.8K a.out.wasm
6.5K a.out.js</pre>
			<p>Along with <code>emcc –O3</code>, we pass <code>–closure 1</code> to further optimize the generated files. Closure Compiler reduces the size of the JavaScript file<a id="_idIndexMarker092"/> by 50% when compared to the <code>emcc -O3</code> option and it took 2.681 seconds to compile:</p>
			<pre>time emcc -Os --closure 1 optimization_check.c
emcc -Os --closure 1 optimization_check.c  2.53s user 0.42s 
  system 106% cpu 2.778 total</pre>
			<p>Let's list the files in the current folder <a id="_idIndexMarker093"/>to check the generated files and their size:</p>
			<pre>$ l
324B optimization_check.c
1.7K a.out.wasm
6.5K a.out.js</pre>
			<p>Along with <code>emcc –Os</code>, we pass <code>–closure 1</code> to further optimize the generated binary. Closure Compiler reduces the <code>.wasm</code> file a little bit more with the <code>emcc -Os</code> option, and it took 2.778 seconds to compile.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">When optimizing for size, try to use both <code>-O3</code> or <code>-Os</code> along with <code>--closure 1</code> to optimize both JavaScript and the WebAssembly module. </p>
			<p>Check out more various options<a id="_idIndexMarker094"/> and flags at <a href="https://emscripten.org/docs/tools_reference/emcc.html">https://emscripten.org/docs/tools_reference/emcc.html</a> <a href="https://clang.llvm.org/docs/CommandGuide/clang.html">https://clang.llvm.org/docs/CommandGuide/clang.html</a>.</p>
			<p>Find out more about various<a id="_idIndexMarker095"/> available optimization options at <a href="https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017">https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017</a>.</p>
			<p>Learn more about<a id="_idIndexMarker096"/> Closure Compiler at <a href="https://developers.google.com/closure/compiler">https://developers.google.com/closure/compiler</a>.</p>
			<p>Find out more about optimizing<a id="_idIndexMarker097"/> large code bases with Emscripten at <a href="https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases">https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases</a>.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor040"/>Summary</h1>
			<p>In this chapter, we learned how to install and use Emscripten to compile C/C++ into a WebAssembly module. We also explored the emsdk tool and various levels of optimizations when generating the WebAssembly module. In the next chapter, we will explore the WebAssembly module.</p>
		</div>
	</body></html>