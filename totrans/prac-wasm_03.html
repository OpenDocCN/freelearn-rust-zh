<html><head></head><body>
		<div id="_idContainer010">
			<h1 id="_idParaDest-22"><em class="italic"><a id="_idTextAnchor022"/>Chapter 2</em>: Understanding Emscripten</h1>
			<p>In this chapter, we will learn about <strong class="bold">Emscripten</strong>, which is a toolchain to convert C/C++ code into a WebAssembly module. </p>
			<p>Emscripten consists of two components:</p>
			<ul>
				<li>Emscripten compiler frontend</li>
				<li><strong class="bold">Emscripten SDK</strong> (<strong class="bold">emsdk</strong>)</li>
			</ul>
			<p>The <strong class="bold">Clang</strong> compiler frontend<a id="_idIndexMarker033"/> compiles C/C++ code into<a id="_idTextAnchor023"/> <strong class="bold">LLVM intermediate representation</strong> (<strong class="bold">LLVM IR</strong>) and then uses the LLVM backend<a id="_idIndexMarker034"/> to convert the LLVM IR into native code. The Clang compiler is fast, uses little memory, and is compatible with <strong class="bold">GNU Compiler Collection</strong> (<strong class="bold">GCC</strong>). Emscripten is similar to Clang; the former produces <a id="_idTextAnchor024"/>a <em class="italic">wasm</em> binary while the latter produces a <em class="italic">native</em> binary. The <strong class="bold">Emscripten compiler frontend</strong> (<strong class="bold">emcc</strong>) is the compiler frontend<a id="_idIndexMarker035"/> that converts C/C++ into LLVM IR (both binary and human-readable form) and into the WebAssembly binary <a id="_idTextAnchor025"/>or <em class="italic">asm.js</em>, such as JavaScript.</p>
			<p class="figure-caption">  </p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_2.1_B14844.jpg" alt="Figure 2.1 – Emscripten compiler frontend&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Emscripten compiler fronten<a id="_idTextAnchor026"/>d</p>
			<p><strong class="bold">emsdk</strong> helps manage and maintain<a id="_idIndexMarker036"/> the Emscripten toolchain components and set up the runtime/terminal environment to run emcc.</p>
			<p>In this chapter, we will learn how to install Emscripten. Then, we will use Emscripten to generate asm.js, a WebAssembly module that runs on Node.js and the browser. After that, we will explore the emsdk tool. Finally, we will explore various optimizations provided by Emscripten. We will cover the following topics in this chapter:</p>
			<ul>
				<li>Installing Emscripten using emsdk</li>
				<li>Generating asm.js using Emscripten</li>
				<li>Running Hello World with Emscripten <a id="_idTextAnchor027"/>in Node.js</li>
				<li>Running Hello World with Emscripten in the browser</li>
				<li>Exploring other options in emsdk</li>
				<li>Understanding various levels of optimizations<p class="callout-heading">Did You Know?</p><p class="callout">asm.js is a subset of JavaScript that is optimized to run at near-native performance in the browser. The asm.js spec was not accepted by all browser vendors. asm.js has evolved into WebAssembly.</p></li>
			</ul>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>We will be showing how to set up Emscripten in this chapter, for which you will require the following installed on your system: </p>
			<ul>
				<li>Python &gt;= 3.7 </li>
				<li>Node.js &gt; 12.18<p class="callout-heading">Note </p><p class="callout">emsdk comes prebundled with a compatible Node.js version. </p></li>
			</ul>
			<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor029"/>Installing Emscripten using emsdk</h1>
			<p>emsdk provides an easy way<a id="_idIndexMarker037"/> to install, manage, and switch versions of the Emscripten<a id="_idIndexMarker038"/> toolchain. emsdk takes care of setting up the environment, tools, and SDK required for compiling C/C++ to LLVM IR and then to JavaScript in the form of asm.js or the WebAssembly binary. </p>
			<p>Let's install Emscripten and start hacking:</p>
			<ol>
				<li>Clone the e<a id="_idTextAnchor030"/>msdk repo and go into the <strong class="source-inline">emsdk</strong> folder:<p class="source-code"><strong class="bold">$ git clone https://github.com/emscripten-core/emsdk</strong></p><p class="source-code"><strong class="bold">$ cd emsdk</strong></p></li>
				<li>To install emsdk on the machine, run the following command: </li>
			</ol>
			<p>For *nix users, use the following:</p>
			<p class="source-code"><strong class="bold">$ ./emsdk install latest</strong></p>
			<p>For Windows users, use the following:</p>
			<p class="source-code"><strong class="bold">$ emsdk install latest</strong></p>
			<p class="callout-heading">Note </p>
			<p class="callout">The preceding command might take a while to run; it will build and set up the entire toolchain.  </p>
			<p>Next, we will activate the latest emsdk. The activation updates the local shell with the necessary environment references and makes the latest SDK active for the user in the current shell. It writes the path and other necessary information for the Emscripten toolchain to work under the user's home directory in a file called <strong class="source-inline">.emscripten</strong>:</p>
			<ol>
				<li value="3">To activate the installed emsdk, run the following command:</li>
			</ol>
			<p>For *nix users, use the following:</p>
			<p class="source-code"><strong class="bold"> $ ./emsdk activate latest</strong></p>
			<p>For Windows users, use the following:</p>
			<p class="source-code"><strong class="bold"> $ emsdk activate latest</strong></p>
			<ol>
				<li value="4">Now it is time to make sure the configurations<a id="_idIndexMarker039"/> and paths are activated<a id="_idIndexMarker040"/> by running the following:</li>
			</ol>
			<p>For *nix users, use the following:</p>
			<p class="source-code"><strong class="bold"> $ source ./emsdk_env.sh</strong></p>
			<p>For Windows users, use the following:</p>
			<p class="source-code"><strong class="bold"> $ emsdk_env.bat</strong></p>
			<p>Congrats, the Emscripten toolchain is installed! Updating the toolchain with emsdk is as easy as installing it.</p>
			<p>To update, run the following command:</p>
			<p>For *nix users, use the following:</p>
			<p class="source-code">$ ./emsdk update</p>
			<p>For Windows users, use the following:</p>
			<p class="source-code">$ emsdk update</p>
			<p>emsdk sets up the following paths inside the Emscripten configuration file. The Emscripten configuration file (<strong class="source-inline">.emscripten</strong>) is in the home folder. It consists of the following:</p>
			<ul>
				<li><strong class="source-inline">LLVM_ROOT</strong> – specifies the path of the LLVM Clang compiler</li>
				<li><strong class="source-inline">NODE_JS</strong> – specifies the path of Node.js</li>
				<li><strong class="source-inline">BINARYEN_ROOT</strong> – specifies the optimizer for the Emscripten compiler</li>
				<li><strong class="source-inline">EMSCRIPTEN_ROOT</strong> – specifies the path of the Emscripten compiler</li>
			</ul>
			<p>We can check whether the installation of emcc was successful by using the following command:</p>
			<p class="source-code"> $ emcc --version</p>
			<p>Now that we have finished installing the Emscripten compiler, let's go ahead and use it.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor031"/>Generating asm.js using Emscripten</h1>
			<p>We will use Emscripten to port C/C++ programs<a id="_idIndexMarker041"/> into asm.js or the WebAssembly binary<a id="_idIndexMarker042"/> and then run them inside the JavaScript engine.  </p>
			<p class="callout-heading">Note </p>
			<p class="callout">Programming languages such as Lua and Python have a C/C++ runtime. With Emscripten, we can port the runtime as a WebAssembly module and execute them inside the JavaScript engine. This makes it easy to run Lua/Python code on the JavaScript engine. Thus, Emscripten and WebAssembly allow the running of native code in the JavaScript engine.</p>
			<p>First, let's create a <strong class="source-inline">sum.cpp</strong> file:</p>
			<p class="source-code"> // sum.cpp</p>
			<p class="source-code">extern "C" {</p>
			<p class="source-code">  unsigned sum(unsigned a, unsigned b) {</p>
			<p class="source-code">      return a + b;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Consider <strong class="source-inline">extern "C"</strong> as something like an <em class="italic">export</em> mechanism. All the functions inside are available as an exported function without any changes to their name. Then, we define the normal <strong class="source-inline">sum</strong> function that takes in two numbers and returns a number.</p>
			<p>In order to generate the asm.js like JavaScript code from <strong class="source-inline">sum.cpp</strong>, use the following command:</p>
			<p class="source-code">$ emcc -O1 ./sum.cpp -o sum.html -s WASM=0 -s EXPORTED_FUNCTIONS='["_sum"]'</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you are running emcc for the first time, it might take a few seconds to complete. Subsequent runs will be faster.</p>
			<p>We pass in the <strong class="source-inline">-O1</strong> option to the emcc compiler, instructing the compiler<a id="_idIndexMarker043"/> to produce less-optimized code (we will see more options to optimize later in this chapter). Next, we pass the file<a id="_idIndexMarker044"/> to be converted, that is, <strong class="source-inline">sum.cpp</strong>. Then, with the <strong class="source-inline">-o</strong> flag, we provide the desired name for the output, which is <strong class="source-inline">sum.html</strong>. </p>
			<p>Finally, we send in more information to the emcc compiler using the <strong class="source-inline">-s</strong> flag. The <strong class="source-inline">-s</strong> flag takes in a key and value as their arguments. The emcc compiler generates the WebAssembly module by default. <strong class="source-inline">WASM=0</strong> instructs the compiler to generate asm.js like JavaScript instead of WebAssembly.</p>
			<p>Then, we specify the exported functions using the <strong class="source-inline">EXPORTED_FUNCTIONS</strong> option. The <strong class="source-inline">EXPORTED_FUNCTIONS</strong> option takes an array of arguments. In order to export the <strong class="source-inline">sum</strong> function, we specify <strong class="source-inline">_sum</strong>.</p>
			<p>This will generate the following code:</p>
			<p class="source-code">function _sum($0,$1) {</p>
			<p class="source-code">    $0 = $0|0;</p>
			<p class="source-code">    $1 = $1|0;</p>
			<p class="source-code">    var $2 = 0, label = 0, sp = 0;</p>
			<p class="source-code">    sp = STACKTOP;</p>
			<p class="source-code">    $2 = (($1) + ($0))|0;</p>
			<p class="source-code">   return ($2|0);</p>
			<p class="source-code">}</p>
			<p class="callout-heading"> Note </p>
			<p class="callout"><strong class="source-inline">|0</strong> specifies the type as a number. </p>
			<p>Now open <strong class="source-inline">sum.html</strong> in a browser and open the developer console. In order to call the exported function, we will run the following expression in the console:</p>
			<p class="source-code"> ccall("sum", "number", "number, number", [10, 20])</p>
			<p class="source-code">// outputs 30</p>
			<p><strong class="source-inline">ccall</strong> is the way to call the exported function<a id="_idIndexMarker045"/> from C/C++ code via JavaScript. The function takes<a id="_idIndexMarker046"/> in the name of the function, the type of the return value, types of arguments, and then the input arguments as an array. This will invoke the <strong class="source-inline">sum</strong> function to produce the result. We will see more about <strong class="source-inline">ccall</strong> and <strong class="source-inline">cwrap</strong> in later chapters. But for now, consider <strong class="source-inline">ccall</strong> a way to call the C function.</p>
			<p>Find out more about the Emscripten source at <a href="https://github.com/emscripten-core/emscripten">https://github.com/emscripten-core/emscripten</a>.</p>
			<p>So far, we have seen how to generate asm.js files using emscripten. Let us use emscripten to create a WebAssembly Module to run on Node.js.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>Running Hello World with Emscripten in Node.js</h1>
			<p>In this section, we will see how to convert C/C++ code<a id="_idIndexMarker047"/> into the WebAssembly binary via Emscripten<a id="_idIndexMarker048"/> and run it along with Node.js.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If the terminal errors out with <em class="italic">emcc command not found</em>, your terminal environment might have been reset. To set up the environment, run the following command from inside the <strong class="source-inline">emsdk</strong> folder: </p>
			<p class="callout"><strong class="bold">source ./emsdk_env.sh </strong></p>
			<p>Let's follow the tradition of Brian Kernighan, by writing "Hello, world" with a slight twist. Let's do a "Hello, Web":</p>
			<ol>
				<li value="1">First, we create a <strong class="source-inline">hello_web.c</strong> file:<p class="source-code"><strong class="bold">$ touch hello_web.c</strong></p></li>
				<li>Launch your favorite editor and add the following code:<p class="source-code"> #include &lt;stdio.h&gt;</p><p class="source-code"> </p><p class="source-code">int main() {</p><p class="source-code">    printf("Hello, Web!\n");</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
			</ol>
			<p>It is a simple C program with a <strong class="source-inline">main</strong> function. The <strong class="source-inline">main</strong> function is the entry point during the runtime. When this code<a id="_idIndexMarker049"/> is compiled and executed<a id="_idIndexMarker050"/> using Clang (<strong class="source-inline">clang sum.c &amp;&amp; ./a.out</strong>), "Hello, Web!" is printed. Now, instead of Clang (or any other compiler), let's compile the code with emcc.</p>
			<ol>
				<li value="3">We enter the following command to compile the code with emcc:<p class="source-code"><strong class="bold"> $ emcc hello_web.c</strong></p></li>
			</ol>
			<p>Once completed, the following files are generated:</p>
			<ul>
				<li><strong class="source-inline">a.out.js</strong></li>
				<li><strong class="source-inline">a.out.wasm</strong></li>
			</ul>
			<p>The generated JavaScript file is huge. It has more than 2,000 lines and is 109 KB in size. We will learn how to optimize the file size later in this chapter.</p>
			<ol>
				<li value="4">Let's run the generated JavaScript file using Node and that will print out "Hello, Web!":<p class="source-code"><strong class="bold">$ node a.out.js</strong></p><p class="source-code"><strong class="bold">Hello, Web!</strong></p></li>
			</ol>
			<p>Congratulations! You just ran your first WebAssembly binary!</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Binary size matters in the world of browsers. It won't matter if your algorithm runs in nanoseconds if you have a huge chunk of code. The browser waits till it receives all the necessary information before it starts to parse and compile. So, it is mandatory to check the file size. <em class="italic">Closure Compiler</em> helps to minimize<a id="_idIndexMarker051"/> the byte code size further. Closure Compiler not only reduces the code size but also tries to make the code more efficient.</p>
			<p>The generated JavaScript file contains its own runtime<a id="_idIndexMarker052"/> and configuration needed for the JavaScript engine to execute the WebAssembly<a id="_idIndexMarker053"/> module inside the JavaScript engine. The generated JavaScript file creates a JavaScript module and initializes code for both browsers and Node.js:</p>
			<ul>
				<li>In Node.js, the generated JavaScript file creates a module by reading the file from the local filesystem. It gets the arguments passed to the node command and sets them up in the module created.</li>
				<li>In browsers, the generated JavaScript file creates a module by framing a request and fetches it as bytes from a URL. The browser fetches the WebAssembly binary from the hosted server or location and then instantiates the module.</li>
			</ul>
			<p>The generated JavaScript file also creates a stack, memory, import, and export sections. We will deep dive into those sections later in this book.</p>
			<p>This generated JavaScript file is called a <em class="italic">binding file</em>. The main function of the binding file<a id="_idIndexMarker054"/> is to create or set an environment that enables executing a WebAssembly module inside the JavaScript engine. The binding file acts as a translator between JavaScript and WebAssembly. All the values are passed in and out via this binding file.</p>
			<p>When the JavaScript file is executed via node, it does the following.</p>
			<p>The JavaScript engine first loads the module and then sets up the constants and various functions that are required for WebAssembly to execute. Then, the module checks where the code is being executed, whether the module is inside the browser or in the `Node` environment. Based on that, it fetches the file. Since we are running the WebAssembly Module via the node here, it fetches the file from the local filesystem. Then, the module is checked for any arguments provided for the call. If not, the JavaScript engine will check whether there are any unhandled/uncaught exceptions. The JavaScript engine then maps the <strong class="source-inline">print out</strong>/<strong class="source-inline">print err</strong> function to the console. The JavaScript engine checks whether the module loaded has all the required access and global variables and imports are available for execution.</p>
			<p>The module goes on to initialize the stack and other required constants as well as the decoder and encoder for decoding and encoding the buffer, respectively. The encoder is responsible for translating the JavaScript values into WebAssembly-understandable values. The decoder is responsible for translating the WebAssembly values into JavaScript-understandable values. </p>
			<p>The Node.js runtime<a id="_idIndexMarker055"/> then checks the availability<a id="_idIndexMarker056"/> of the file and then initializes the file. The module is checked for all the WebAssembly-related function availability. Once everything is initialized and the module contains all the functions required, we will call the <strong class="source-inline">run</strong> function.</p>
			<p>The <strong class="source-inline">run</strong> function instantiates the WebAssembly binary. In this case, since we have defined the <strong class="source-inline">main</strong> function in C, the binding file calls the <strong class="source-inline">main</strong> function straight away when instantiated.</p>
			<p>The binding file contains the <strong class="source-inline">ccall</strong> function. The <strong class="source-inline">ccall</strong> function is an interface to the underlying function defined in C:</p>
			<p class="source-code">function ccall(ident, returnType, argTypes, args, opts)  {</p>
			<p class="source-code">  // the code is elided</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ccall</strong> function accepts the following arguments:</p>
			<ul>
				<li><strong class="source-inline">ident</strong> – The function to call; it is the function identifier defined in C.</li>
				<li><strong class="source-inline">returnType</strong> – The return type of the function.</li>
				<li><strong class="source-inline">argTypes</strong> – The argument types.</li>
				<li><strong class="source-inline">args</strong> – The arguments that are passed along with the function call.</li>
				<li><strong class="source-inline">opts</strong> – Any other options that are required.</li>
			</ul>
			<p>The JavaScript module exports the <strong class="source-inline">cwrap</strong> function in addition to <strong class="source-inline">ccall</strong>. <strong class="source-inline">cwrap</strong> is a wrapper function around the <strong class="source-inline">ccall</strong> function. While <strong class="source-inline">ccall</strong> is a function invocation, <strong class="source-inline">cwrap</strong> provides a function that invokes <strong class="source-inline">ccall</strong>:</p>
			<p class="source-code"> function cwrap(ident, returnType, argTypes, opts) {</p>
			<p class="source-code">    return function() {</p>
			<p class="source-code">        return ccall(ident, returnType, argTypes,</p>
			<p class="source-code">          arguments, opts);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The WebAssembly file generated<a id="_idIndexMarker057"/> consists of binary opcode to instruct the runtime<a id="_idIndexMarker058"/> to print "Hello, Web!". The WebAssembly file starts with <strong class="source-inline">00 61 73 6d 01 00 00 00</strong>.</p>
			<p>Find out more about WebAssembly<a id="_idIndexMarker059"/> specifications at <a href="https://webassembly.github.io/spec/">https://webassembly.github.io/spec/</a>.</p>
			<p>So far, we have seen how to generate a WebAssembly module to run on Node.js. Let us use emscripten to create a WebAssembly Module to run in the browser.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor033"/>Running Hello World with Emscripten in the browser</h1>
			<p>In this section, we will see how to convert C/C++ code into the WebAssembly<a id="_idIndexMarker060"/> binary via Emscripten and run<a id="_idIndexMarker061"/> it in the browser.</p>
			<p class="callout-heading"> Note </p>
			<p class="callout">If the terminal says that the <strong class="source-inline">emcc</strong> command is not found, it is highly likely that you have missed setting up the environment variables. To set up the environment variables, run the following command from inside the <strong class="source-inline">emsdk</strong> folder: <strong class="source-inline">source ./emsdk_env.sh</strong></p>
			<p>Let's use the same code example used in the <em class="italic">Generating asm.js using Emscripten</em> section . Now, instead of just running emcc, let's pass the <strong class="source-inline">-o</strong> option and instruct emcc to generate the <strong class="source-inline">.html</strong> file:</p>
			<p class="source-code">$ emcc hello_web.c -o helloweb.html</p>
			<p>Once completed, the following files are generated:</p>
			<ul>
				<li><strong class="source-inline">helloweb.js</strong></li>
				<li><strong class="source-inline">helloweb.wasm</strong></li>
				<li><strong class="source-inline">helloweb.html</strong></li>
			</ul>
			<p>Similar to the Node example, the generated JavaScript file is huge. We will learn how to optimize the file size later in this chapter.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The <strong class="source-inline">-o</strong> option ensures all the files generated have the name <strong class="source-inline">helloweb</strong>.</p>
			<p>In order to run the generated HTML file<a id="_idIndexMarker062"/> in the browser, we will need a web<a id="_idIndexMarker063"/> server. The web server serves the HTML file over the HTTP protocol. Explaining web servers<a id="_idIndexMarker064"/> and how they work is beyond the scope of this book; refer to <a href="https://en.wikipedia.org/wiki/Web_server">https://en.wikipedia.org/wiki/Web_server</a> for more details.</p>
			<p>Python provides an easy way to run the web server. In order to run the web server using Python, run the following command:</p>
			<p class="source-code">$ python -m http.server &lt;port number&gt;</p>
			<p>Open <strong class="source-inline">http://localhost:&lt;port number&gt;</strong> to see WebAssembly in action in the browser.</p>
			<p class="figure-caption">  </p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_2.2_B14844.jpg" alt="Figure 2.2 – Browser running WebAssembly&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Browser running WebAssembly</p>
			<p>When the JavaScript file is executed via the browser, it prints out <strong class="bold">Hello, Web!</strong> as output. The only difference<a id="_idIndexMarker065"/> is instead of loading the WASM file<a id="_idIndexMarker066"/> from the filesystem, it loads it via XHR. Once everything is initialized and the module consists of all the functions required, we will call the <strong class="source-inline">run</strong> function. The <strong class="source-inline">run</strong> function instantiates the WebAssembly binary. In this case, since we have defined the <strong class="source-inline">main</strong> function in C, the binding file calls the <strong class="source-inline">main</strong> function straight away when instantiated.</p>
			<p>Emscripten<a id="_idIndexMarker067"/> also provides <strong class="source-inline">emrun</strong> to run HTML files. Check out <a href="https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html">https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html</a> for more information.</p>
			<p>Find out more about deploying<a id="_idIndexMarker068"/> Emscripten-compiled pages at <a href="https://emscripten.org/docs/compiling/Deploying-Pages.html">https://emscripten.org/docs/compiling/Deploying-Pages.html</a>.</p>
			<p>We have used Emscripten to generate the WebAssembly module. Let's go ahead and explore what else the emsdk can do.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor034"/>Exploring other options in emsdk </h1>
			<p>emsdk is a single-stop shop for installing, maintaining, and managing all the tools and toolchains required<a id="_idIndexMarker069"/> for using Emscripten. emsdk makes it easier to bootstrap the environment, upgrade to the latest versions, switch to various versions, change or configure various tools, and so on.</p>
			<p>The <strong class="source-inline">emsdk</strong> command is available inside the <strong class="source-inline">emsdk</strong> folder. Go to the <strong class="source-inline">emsdk</strong> folder and run the <strong class="source-inline">emsdk</strong> command. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">For all the commands in this chapter, for *nix systems, use <strong class="source-inline">./emsdk</strong>, and for Windows, use <strong class="source-inline">emsdk</strong>. </p>
			<p>To find the various options available in the <strong class="source-inline">emsdk</strong> command, run the following command:</p>
			<p class="source-code">$ ./emsdk --help</p>
			<p class="source-code">emsdk: Available commands:</p>
			<p class="source-code">emsdk list [--old] [--uses] - To list down the tools</p>
			<p class="source-code">emsdk update - To update the emsdk to the latest version.</p>
			<p class="source-code">emsdk update-tags - To fetch the latest tags from the GitHub </p>
			<p class="source-code">  repository.</p>
			<p class="source-code">emsdk install - To install the tools and SDK.</p>
			<p class="source-code">emsdk uninstall - To uninstall the tools and SDK installed </p>
			<p class="source-code">  previously.</p>
			<p class="source-code">emsdk activate - To activate the currently installed version.</p>
			<p>An <strong class="source-inline">emsdk</strong> command takes the following format: </p>
			<p class="source-code">emsdk &lt;option&gt; &lt;Tool / SDK &gt; --&lt;flags&gt;</p>
			<p>The <strong class="source-inline">emsdk</strong> command<a id="_idIndexMarker070"/> consists of the following: </p>
			<ul>
				<li><strong class="source-inline">&lt;option&gt;</strong></li>
			</ul>
			<p>This can be one of the following: list, update, update-tags, install, uninstall, or activate. </p>
			<ul>
				<li><strong class="source-inline">&lt;Tool/SDK&gt;</strong></li>
			</ul>
			<p>This refers to libraries and it includes Emscripten and LLVM. <strong class="source-inline">SDK</strong> refers to emsdk itself.</p>
			<ul>
				<li><strong class="source-inline">--&lt;flags&gt;</strong></li>
			</ul>
			<p>This refers to various configuration options. </p>
			<p>Let us explore each of the options and flags that emsdk command supports.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor035"/>Listing the tools and SDK</h2>
			<p>Here, we show how to list the tools<a id="_idIndexMarker071"/> and SDK that are available with emsdk. Run the following command:</p>
			<p class="source-code">$ ./emsdk list</p>
			<p class="source-code"> </p>
			<p class="source-code">The *recommended* precompiled SDK download is 2.0.6 </p>
			<p class="source-code">  (4ba921c8c8fe2e8cae071ca9889d5c27f5debd87).</p>
			<p class="source-code"> </p>
			<p class="source-code">To install/activate it, use one of:</p>
			<p class="source-code">        latest                  [default (llvm) backend]</p>
			<p class="source-code">        latest-fastcomp         [legacy (fastcomp) backend]</p>
			<p class="source-code"> </p>
			<p class="source-code">Those are equivalent to installing/activating the following:</p>
			<p class="source-code">         2.0.6             INSTALLED</p>
			<p class="source-code">         2.0.6-fastcomp</p>
			<p class="source-code"> </p>
			<p class="source-code">All recent (non-legacy) installable versions are:</p>
			<p class="source-code">         2.0.6    INSTALLED</p>
			<p class="source-code">         ...</p>
			<p class="source-code"> </p>
			<p class="source-code">The additional following precompiled SDKs are also available </p>
			<p class="source-code">  for download:</p>
			<p class="source-code">         sdk-fastcomp-1.38.31-64bit</p>
			<p class="source-code"> </p>
			<p class="source-code">The following SDKs can be compiled from source:</p>
			<p class="source-code">         sdk-upstream-master-64bit</p>
			<p class="source-code">          ...</p>
			<p class="source-code">The following precompiled tool packages are available for </p>
			<p class="source-code">  download:</p>
			<p class="source-code">        ...</p>
			<p class="source-code">     *     node-12.18.1-64bit         INSTALLED</p>
			<p class="source-code">     *     python-3.7.4-2-64bit       INSTALLED</p>
			<p class="source-code">           emscripten-1.38.30</p>
			<p class="source-code">        ...</p>
			<p class="source-code">The following tools can be compiled from source:</p>
			<p class="source-code">           llvm</p>
			<p class="source-code">           clang</p>
			<p class="source-code">           emscripten</p>
			<p class="source-code">           binaryen</p>
			<p class="source-code"> </p>
			<p class="source-code">Items marked with * are activated for the current user.</p>
			<p class="source-code"> </p>
			<p class="source-code">To access the historical archived versions, type 'emsdk list </p>
			<p class="source-code">  --old'</p>
			<p class="source-code"> </p>
			<p class="source-code">Run "git pull" followed by "./emsdk update-tags" to pull </p>
			<p class="source-code">  in the latest list.</p>
			<p><strong class="source-inline">emsdk list</strong> lists all tool packages<a id="_idIndexMarker072"/> and SDKs that are available. This list of tools and SDKs includes the last few versions of LLVM, Clang, Emscripten, and Binaryen. They even have Node versions 8 and 12 and Python 3.7. emsdk maintains and manages <strong class="source-inline">emsdk</strong>. This means that we need to know the information about the current version that we are using and how to update it. The <strong class="source-inline">emsdk list</strong> command also provides more detail on the SDK components along with a list of those compiled from the sources.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor036"/>Managing the tools and SDK</h2>
			<p>emsdk provides an option<a id="_idIndexMarker073"/> to install, update, and uninstall the tools and SDK.</p>
			<p>In order to install the tools, SDK, or emsdk itself, use the following:</p>
			<p class="source-code">$ ./emsdk install &lt;tool / SDK to install&gt;</p>
			<p>To install the latest version of the SDK, you can run the following:</p>
			<p class="source-code">./emsdk install latest</p>
			<p class="callout-heading">Note </p>
			<p class="callout"><strong class="source-inline">latest</strong> refers to the latest version of emsdk.</p>
			<p>To install multiple tools with the <strong class="source-inline">emsdk install</strong> command, use the following:</p>
			<p class="source-code">./emsdk install &lt;tool1&gt; &lt;tool2&gt; &lt;tool3&gt;</p>
			<p>You can also specify multiple<a id="_idIndexMarker074"/> options for the <strong class="source-inline">install</strong> command. You can pass in options to the <strong class="source-inline">install</strong> command like this:</p>
			<p class="source-code"> ./emsdk install [options] &lt;tools / SDK&gt;</p>
			<p>The various <strong class="source-inline">options</strong> available are as follows:</p>
			<ul>
				<li>Number of cores to build</li>
				<li>Type of build</li>
				<li>Activation of tools and SDK</li>
				<li>Uninstallation </li>
			</ul>
			<h3>Number of cores to build</h3>
			<p>The initial setup will take a long time to build and install<a id="_idIndexMarker075"/> the required tools and SDK. Based on your requirements, you can control the number of cores that you need for building and installing the required tools and SDK:</p>
			<p class="source-code">./emsdk install -j&lt;number of cores to use for building&gt; &lt;tools </p>
			<p class="source-code">  / SDK&gt;</p>
			<h3>Type of build</h3>
			<p>You instruct <strong class="source-inline">emsdk</strong> on what type of build<a id="_idIndexMarker076"/> is to be used to make LLVM perform:</p>
			<p class="source-code">./emsdk install --build=&lt;type&gt; &lt;tools / SDK&gt;</p>
			<p><strong class="source-inline">type</strong> accepts the following options:</p>
			<ul>
				<li> Debug<ul><li>This type is used for debugging.</li><li>It generates Symbol files.</li><li>The end build will not produce optimized, fast code.</li></ul></li>
				<li>Release<ul><li>This type will generate optimized, fast code.</li></ul></li>
				<li>MinSizeRel<ul><li>This type is the same as Release.</li><li>This type will minimize the size and maximize the speed.</li><li>This uses optimization options such as <strong class="source-inline">-O1</strong> (minimize size) and <strong class="source-inline">-O2</strong> (maximize speed).</li></ul></li>
				<li>RelWithDebInfo<ul><li>This type is the same as Release.</li><li>This type<a id="_idIndexMarker077"/> will also generate Symbol files. That will help in debugging.</li></ul></li>
			</ul>
			<h3>Activation of the tools and SDK</h3>
			<p>After the tools and SDK<a id="_idIndexMarker078"/> are installed, we can activate different versions to use them. The <strong class="source-inline">activate</strong> command generates the necessary configuration files mapping the path, with the built executables.</p>
			<p>To activate the tools and SDK, run the following:</p>
			<p class="source-code">./emsdk activate &lt;tools / SDK to activate&gt;</p>
			<p>The <strong class="source-inline">activate</strong> command accepts a few options; they are as follows:</p>
			<ul>
				<li><strong class="source-inline">--embedded</strong> – This option makes sure all the built files, configuration, cache, and temporary files are located inside the directory in which the emsdk command is located.</li>
			</ul>
			<p>If not specified, this command will move the configuration file to the user's home directory.</p>
			<ul>
				<li><strong class="source-inline">--build=&lt;type&gt;</strong> – Similar to the type of build that LLVM supports. For example, Debug, Release, MinSizeRel, RelWithDebInfo.</li>
			</ul>
			<h3>Uninstallation of the tools and SDK</h3>
			<p>To uninstall<a id="_idIndexMarker079"/> the tools and SDK, we can run the following:</p>
			<p class="source-code">./emsdk uninstall &lt; tools / SDK to uninstall&gt; </p>
			<p>Find out more about<a id="_idIndexMarker080"/> the tools at <a href="https://emscripten.org/docs/tools_reference/index.html">https://emscripten.org/docs/tools_reference/index.html</a>.</p>
			<p>We have explored how emsdk helps us to manage tools and SDKs; let's go ahead and explore various optimizations provided by Emscripten.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor037"/>Understanding various levels of optimizations</h1>
			<p>C/C++ programs are compiled and converted<a id="_idIndexMarker081"/> into native code via Clang or the GCC compiler. Clang or the GCC compiler converts the C/C++ program based on the target. Target here refers to the end machine where the code is executed. emcc has the Clang compiler built in. The emcc compiler is responsible for converting the C or C++ source code into LLVM byte code.</p>
			<p>In this section, we will see how to improve the optimization and code size of the generated WebAssembly binary code. </p>
			<p>To improve the efficiency and generated code size, the Emscripten compiler has the following options:</p>
			<ul>
				<li>Optimizations</li>
				<li>Closure Compiler</li>
			</ul>
			<p>Lets talk about optimizations first.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor038"/>Optimizations</h2>
			<p>The goal of the compiler is to reduce the cost of compilation, that is, the compile time. With the <strong class="source-inline">-O</strong> optimization flag, the compiler<a id="_idIndexMarker082"/> tries to improve the code size and/or the performance at the expense of the compile time. In terms of compiler optimizations, code size and performance are mutually exclusive. The faster the compile time, the lower the optimization. To specify the optimization, we use the <strong class="source-inline">-O&lt;0/1/2/3/s/z&gt;</strong> flag. Each of the options includes various assertions, code size optimizations, and code performance optimizations, along with others.</p>
			<p> The following are the various optimizations available:</p>
			<ul>
				<li><strong class="source-inline">-O0</strong> – This is the default option<a id="_idIndexMarker083"/> and a perfect starter to experiment. This option means "no optimizations." This optimization level compiles the fastest and generates the most debuggable code. This is a basic optimization level. This option tries to inline functions. </li>
				<li><strong class="source-inline">-O1</strong> – This option adds simple optimizations and tries to generate a minimum code size. This option removes runtime assertions in the generated code and builds slower than the <strong class="source-inline">-O0</strong> option. This option also tries to simplify the loops.</li>
				<li><strong class="source-inline">-O2</strong> – This option adds further optimizations than <strong class="source-inline">-O1</strong>. It is slower than <strong class="source-inline">-O1</strong> but generates code that is more optimized than the <strong class="source-inline">-O1</strong> option. This option optimizes the code based on JavaScript optimization and removes code that is not part of JavaScript modules. This option removes the inline functions and the <strong class="source-inline">vectorize-loop</strong> option is set. This option adds a moderate level of optimization. This option also adds dead code elimination.</li>
			</ul>
			<p>Vectorization will instruct the processor to do the operation in chunks rather than doing it one by one.</p>
			<ul>
				<li> <strong class="source-inline">-O3</strong> – This option adds more options, takes more time to compile, and generates more optimized code than the <strong class="source-inline">-O2</strong> option.</li>
			</ul>
			<p>This option produces optimal production-ready code. This option is like <strong class="source-inline">-O2</strong>, except that it enables optimizations that take longer to perform or that may generate larger code (in an attempt to make the program run faster).</p>
			<ul>
				<li> <strong class="source-inline">-Os</strong> – This option is similar to <strong class="source-inline">-O2</strong>. It adds extra optimizations and reduces the code size. Reducing the code size in turn decreases the performance. This option generates smaller code than <strong class="source-inline">-O2</strong>.</li>
				<li> <strong class="source-inline">-Oz</strong> – This option is similar to <strong class="source-inline">-Os</strong> but reduces the code size even further. This option takes more compile time to generate the binary code.</li>
			</ul>
			<p>We will now explore the various optimization options provided by Emscripten:</p>
			<ol>
				<li value="1">First, we create<a id="_idIndexMarker084"/> a C file called <strong class="source-inline">optimization_check</strong>:<p class="source-code"><strong class="bold">$ touch optimization_check.c</strong></p></li>
				<li>Then, open your favorite editor and add the following code. The following is a simple C file with a <strong class="source-inline">main</strong> function and a couple of other functions:<p class="source-code">#include &lt;stdio.h&gt;</p><p class="source-code"> int addSame(int a) {</p><p class="source-code">    return a + a;</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">int add(int a, int b) {</p><p class="source-code">    return a + b;</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">int main() {</p><p class="source-code">    printf("Hello, Web!\n");</p><p class="source-code"> </p><p class="source-code">    int a;</p><p class="source-code">    int sum = 0;</p><p class="source-code">    /* for loop execution */</p><p class="source-code">    for( a = 0; a &lt; 20; a = a + 1 ){</p><p class="source-code">       sum = sum + a;</p><p class="source-code">    }</p><p class="source-code">     addSame(sum);</p><p class="source-code">     add(1, 2);</p><p class="source-code">     return 0;</p><p class="source-code">}</p></li>
				<li>We then compile<a id="_idIndexMarker085"/> this into WebAssembly code using emcc:<p class="source-code"><strong class="bold">$ time emcc optimization_check.c</strong></p><p class="source-code"><strong class="bold">emcc optimization_check.c  0.32s user 0.14s system </strong></p><p class="source-code"><strong class="bold">  90% cpu 0.514 total</strong></p></li>
				<li>Then, check the sizes of the file generated:<p class="source-code"><strong class="bold"> $ l</strong></p><p class="source-code"><strong class="bold">324B optimization_check.c</strong></p><p class="source-code"><strong class="bold">13K a.out.wasm</strong></p><p class="source-code"><strong class="bold">109K a.out.js</strong></p></li>
			</ol>
			<p>We can see that the WebAssembly file generated is about 13 KB and it took a total of 0.514 seconds to compile. That is a fast compilation but the code size is huge.</p>
			<p>In the world of compilers, the faster the compilation, the bigger the code size and the slower the execution speed will be.</p>
			<ol>
				<li value="5">Now, let's optimize it further using the <strong class="source-inline">-O1</strong> option:<p class="source-code"><strong class="bold">$ time emcc -O1 optimization_check.c</strong></p><p class="source-code"><strong class="bold">emcc -O1 optimization_check.c  0.31s user 0.13s system</strong></p><p class="source-code"><strong class="bold">  86% cpu 0.519 total</strong></p></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<p class="source-code"><strong class="bold">$ l</strong></p>
			<p class="source-code"><strong class="bold">324B optimization_check.c</strong></p>
			<p class="source-code"><strong class="bold">3.4K a.out.wasm</strong></p>
			<p class="source-code"><strong class="bold">59K a.out.js</strong></p>
			<p>The WebAssembly file<a id="_idIndexMarker086"/> generated is about 3.4 KB (3.8 times less than the <strong class="source-inline">-O0</strong> version) and it took almost the same time, around 0.519 seconds.</p>
			<ol>
				<li value="6">Now, let's optimize it further using the <strong class="source-inline">-O2</strong> option:<p class="source-code"><strong class="bold">$ time emcc -O2 optimization_check.c</strong></p><p class="source-code"><strong class="bold">emcc -O2 optimization_check.c  0.53s user 0.16s system</strong></p><p class="source-code"><strong class="bold">  111% cpu 0.620 total</strong></p></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<p class="source-code"><strong class="bold">$ l</strong></p>
			<p class="source-code"><strong class="bold">324B optimization_check.c</strong></p>
			<p class="source-code"><strong class="bold">2K a.out.wasm</strong></p>
			<p class="source-code"><strong class="bold">20K a.out.js</strong></p>
			<p>The WebAssembly file generated is about 2 KB (~6.5 times less than <strong class="source-inline">-O0</strong>) and it took around 0.62 seconds.</p>
			<ol>
				<li value="7">Now, let's optimize it further using the <strong class="source-inline">-O3</strong> option:<p class="source-code"><strong class="bold">$ time emcc -O3 --profiling optimization_check.c</strong></p><p class="source-code"><strong class="bold">emcc -O3 --profiling optimization_check.c  1.03s user</strong></p><p class="source-code"><strong class="bold">  0.21s system 110% cpu 1.117 total</strong></p></li>
			</ol>
			<p>Find out more about<a id="_idIndexMarker087"/> the <strong class="source-inline">--profiling</strong> flag at <a href="https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling">https://emscripten.org/docs/tools_reference/emcc.html#emcc-profiling</a>.</p>
			<p>Check the sizes of the file generated:</p>
			<p class="source-code"><strong class="bold">$ l</strong></p>
			<p class="source-code"><strong class="bold">324B optimization_check.c</strong></p>
			<p class="source-code"><strong class="bold">2.0K a.out.wasm</strong></p>
			<p class="source-code"><strong class="bold">17K a.out.js</strong></p>
			<p>The WebAssembly file generated is the same size as <strong class="source-inline">-02</strong> but the generated JavaScript file is 3 KB less, and it took around 1.117 seconds to compile.</p>
			<ol>
				<li value="8">Now, let's optimize<a id="_idIndexMarker088"/> it further using the <strong class="source-inline">-Os</strong> option:<p class="source-code"><strong class="bold">$ time emcc -Os optimization_check.c</strong></p><p class="source-code"><strong class="bold">emcc -Os optimization_check.c  1.03s user 0.22s system</strong></p><p class="source-code"><strong class="bold">  46% cpu 2.655 total</strong></p></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<p class="source-code"><strong class="bold">$ l</strong></p>
			<p class="source-code"><strong class="bold">324B optimization_check.c</strong></p>
			<p class="source-code"><strong class="bold">1.7K a.out.wasm</strong></p>
			<p class="source-code"><strong class="bold">14K a.out.js</strong></p>
			<p>The WebAssembly file generated is about 1.7 KB (~7.5 times less than <strong class="source-inline">-O0</strong>) and it took almost 2.655 seconds.</p>
			<ol>
				<li value="9">Now, let's optimize it further using the <strong class="source-inline">-Oz</strong> option:<p class="source-code"><strong class="bold">$ time emcc -Oz optimization_check.c</strong></p><p class="source-code"><strong class="bold">emcc -Oz optimization_check.c  1.03s user 0.21s system</strong></p><p class="source-code"><strong class="bold">  110% cpu 1.123 total</strong></p></li>
			</ol>
			<p>Check the sizes of the file generated:</p>
			<p class="source-code"><strong class="bold">$ l</strong></p>
			<p class="source-code"><strong class="bold">324B optimization_check.c</strong></p>
			<p class="source-code"><strong class="bold">1.7K a.out.wasm</strong></p>
			<p class="source-code"><strong class="bold">14K a.out.js</strong></p>
			<p>The WebAssembly file generated<a id="_idIndexMarker089"/> is about 1.7 KB (~7.5 times less than <strong class="source-inline">-O0</strong>) and it took around 1.123 seconds. </p>
			<p>Next, we'll see an alternative means provided by the Emscripten compiler for improving the efficiency and reducing the generated code size: Closure Compiler</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor039"/>Closure Compiler</h2>
			<p>Closure Compiler is a tool for compiling JavaScript<a id="_idIndexMarker090"/> to better JavaScript. It parses, analyzes, removes<a id="_idIndexMarker091"/> dead code, rewrites, and minimizes JavaScript. Further optimizations on the generated binding JavaScript file and WebAssembly module are done using Closure Compiler. With Closure Compiler, we can do better optimizations on Emscripten code. To optimize the WebAssembly module and JavaScript further, we can use <strong class="source-inline">--closure &lt;optimization type&gt;</strong>.</p>
			<p>The <strong class="source-inline">optimization</strong> type has the following options:</p>
			<ul>
				<li><strong class="source-inline">--closure 0</strong> – This option adds no Closure Compiler optimizations.</li>
				<li><strong class="source-inline">--closure 1</strong> – This option reduces the generated JavaScript code size. This option does not optimize the asm.js and WebAssembly binary. This adds an additional compilation step that increases the compilation time.</li>
				<li><strong class="source-inline">--closure 2</strong> – This option optimizes JavaScript, asm.js, and not the WebAssembly binary and reduces the code size of the file drastically for asm.js.</li>
			</ul>
			<p>We will use the <strong class="source-inline">–closure 1</strong> option to optimize the WebAssembly binary along with the<strong class="source-inline">–O3/s</strong> Emscripten optimization options:</p>
			<p class="source-code">$ time emcc -O3 --closure 1 optimization_check.c</p>
			<p class="source-code">emcc -O3 --closure 1 optimization_check.c  2.40s user 0.42s </p>
			<p class="source-code">  system 105% cpu 2.681 total</p>
			<p>The file sizes generated are as follows:</p>
			<p class="source-code"> $ l</p>
			<p class="source-code">324B optimization_check.c</p>
			<p class="source-code">1.8K a.out.wasm</p>
			<p class="source-code">6.5K a.out.js</p>
			<p>Along with <strong class="source-inline">emcc –O3</strong>, we pass <strong class="source-inline">–closure 1</strong> to further optimize the generated files. Closure Compiler reduces the size of the JavaScript file<a id="_idIndexMarker092"/> by 50% when compared to the <strong class="source-inline">emcc -O3</strong> option and it took 2.681 seconds to compile:</p>
			<p class="source-code">time emcc -Os --closure 1 optimization_check.c</p>
			<p class="source-code">emcc -Os --closure 1 optimization_check.c  2.53s user 0.42s </p>
			<p class="source-code">  system 106% cpu 2.778 total</p>
			<p>Let's list the files in the current folder <a id="_idIndexMarker093"/>to check the generated files and their size:</p>
			<p class="source-code">$ l</p>
			<p class="source-code">324B optimization_check.c</p>
			<p class="source-code">1.7K a.out.wasm</p>
			<p class="source-code">6.5K a.out.js</p>
			<p>Along with <strong class="source-inline">emcc –Os</strong>, we pass <strong class="source-inline">–closure 1</strong> to further optimize the generated binary. Closure Compiler reduces the <strong class="source-inline">.wasm</strong> file a little bit more with the <strong class="source-inline">emcc -Os</strong> option, and it took 2.778 seconds to compile.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">When optimizing for size, try to use both <strong class="source-inline">-O3</strong> or <strong class="source-inline">-Os</strong> along with <strong class="source-inline">--closure 1</strong> to optimize both JavaScript and the WebAssembly module. </p>
			<p>Check out more various options<a id="_idIndexMarker094"/> and flags at <a href="https://emscripten.org/docs/tools_reference/emcc.html">https://emscripten.org/docs/tools_reference/emcc.html</a><span class="hidden"> </span><a href="https://clang.llvm.org/docs/CommandGuide/clang.html">https://clang.llvm.org/docs/CommandGuide/clang.html</a>.</p>
			<p>Find out more about various<a id="_idIndexMarker095"/> available optimization options at <a href="https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017">https://docs.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=vs-2017</a>.</p>
			<p>Learn more about<a id="_idIndexMarker096"/> Closure Compiler at <a href="https://developers.google.com/closure/compiler">https://developers.google.com/closure/compiler</a>.</p>
			<p>Find out more about optimizing<a id="_idIndexMarker097"/> large code bases with Emscripten at <a href="https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases">https://emscripten.org/docs/optimizing/Optimizing-Code.html#very-large-codebases</a>.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor040"/>Summary</h1>
			<p>In this chapter, we learned how to install and use Emscripten to compile C/C++ into a WebAssembly module. We also explored the emsdk tool and various levels of optimizations when generating the WebAssembly module. In the next chapter, we will explore the WebAssembly module.</p>
		</div>
	</body></html>