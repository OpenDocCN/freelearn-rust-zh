<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Creating a Desktop Two-Dimensional Game Using ggez
                </header>
            
            <article>
                
<p><span>In the preceding chapter, we saw how to build interactive software based on the animation-loop architecture (typically, animated games) for desktops or for web browsers from a single set of source codes using the <kbd>quicksilver</kbd> framework. </span>A drawback of this approach is that many input/output functions available on the desktop are not available on web browsers, and so a framework for web browsers does not <span>necessarily</span><span> </span><span>provide</span><span> as </span><span>many features</span><span> to </span><span>desktop applications</span><span> that are offered on desktop platforms</span><span>, such as file storage</span><span>.</span></p>
<p class="mce-root">In addition, when using the animation-loop architecture, it is quite awkward to get discrete input, such as mouse clicks, typed letters, or digits. For this, an event-driven architecture is more appropriate.</p>
<p class="mce-root">In this chapter, another application framework will be introduced—the <kbd>ggez</kbd> framework. This handles both animation-loop and discrete events, but at the time of writing, it <span>only</span><span> </span><span>supports two-dimensional desktop applications.</span></p>
<p class="mce-root">In the previous chapter, we saw that to compute the position and orientation of various graphical objects, some analytical geometry and trigonometry is required. For more complex applications, these mathematical computations can become overwhelming. To simplify the code, it is useful to encapsulate positions in point objects and translations in vector objects, and so in this chapter, we will look at how to perform these <span>encapsulations</span>. The <kbd>nalgebra</kbd> mathematical library helps us to do this and will be introduced in this chapter, too.</p>
<p><span>The following topics will be covered in this chapter:</span></p>
<ul>
<li>Understanding linear algebra</li>
<li>Implementing the <kbd>gg_ski</kbd> project</li>
<li><span>Implementing </span>the <kbd>gg_silent_slalom</kbd> project</li>
<li><span>Implementing </span>the <kbd>gg_assets_slalom</kbd> project</li>
<li><span>Implementing </span>the <kbd>gg_whac</kbd> project</li>
</ul>
<p><span>In particular, you will see the implementation of the same three projects we looked at in the previous chapter (</span><kbd>gg_ski</kbd><span>, </span><kbd>gg_silent_slalom</kbd><span>, and </span><kbd>gg_assets_slalom</kbd><span>) to demonstrate the animation loop, as well as a</span> Whac-A-Mole <span>game (<kbd>gg_whac</kbd>) to demonstrate the handling of discrete events. </span></p>
<h1 id="uuid-b3bc28f1-fe80-4041-94a6-d8cb7318165d">Technical requirements</h1>
<p>This chapter uses references to the animation-loop architecture and the slalom game implemented in the preceding chapter. The <kbd>ggez</kbd> framework requires (for correctly rendering graphical objects) the OpenGL 3.2 API to be well supported by the operating system. Therefore, old operating systems such as Windows XP cannot be used.</p>
<p><span>The complete source code for this chapter is found in the <kbd>Chapter07</kbd></span><span> </span><span>folder</span><span> of the repository at </span><a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers</a><span>.</span></p>
<div class="packt_tip"><span>macOS users may struggle to install </span><kbd>coreaudio-sys</kbd><span>. Upgrading the patch version of </span><kbd>coreaudio-sys</kbd><span> to <kbd>0.2.3</kbd> resolves this issue.</span></div>
<h1 id="uuid-94977b81-1d62-4c33-bbd4-ea5e9b99a92c">Project overview</h1>
<p>In this chapter, we will <span>first</span><span> </span><span>look at what linear algebra </span><span>is</span><span> </span><span>and why it is useful to describe and manipulate the objects drawn in any </span><span>graphical </span><span>game. Then, we will look at how to use the</span> <kbd>nalgebra</kbd> <span>library to perform linear algebra operations in our programs.</span></p>
<p>After that, we will recreate the same projects used in the previous chapter, but using the <kbd>nalgebra</kbd> <span>library and the </span><kbd>ggez</kbd><span> framework instead of the <kbd>quicksilver</kbd> framework.</span> <kbd>gg_ski</kbd> is a rewrite of <kbd>ski</kbd>, <kbd>gg_silent_slalom</kbd><span> is a rewrite of <kbd>silent_slalom</kbd>, and </span><kbd><span>gg_</span>assets_slalom</kbd><span> is a rewrite of <kbd>assets_slalom</kbd></span><span>.</span></p>
<p>At the end of the chapter, we will look at the implementation of a completely different game with the <kbd>gg_whac</kbd><span> </span><span>project</span><span> to see how to handle discrete events in an architecture that mixes the animation loop with an event-driven architecture. This will </span><span>also</span><span> </span><span>show how widgets (such as buttons) can be created and added to a window.</span></p>
<h1 id="uuid-4940df74-3b9e-43d8-bf93-29bc281d354b">Understanding linear algebra</h1>
<p>Linear algebra is the sector of mathematics regarding systems of first-degree equations, such as the following:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c865534e-7942-46fb-a5cb-2a43c0c5f797.png" style="width:6.75em;height:2.42em;"/></p>
<p class="mce-root">This system of equations has a solution to certain values (that is, <img class="fm-editor-equation" src="assets/62e199f2-55af-4a4b-93d8-a8d2c310a1e0.png" style="width:7.25em;height:1.50em;"/>). I<span>n addition to being useful for solving systems of equations, t</span><span>he concepts and methods of linear algebra are also useful for representing and manipulating geometrical entities.</span></p>
<p class="mce-root">In particular, any position on a plane can be represented by two coordinates, <em>x</em> and <em>y</em>, and any <span>position</span> in space can be represented by three coordinates, <em>x</em>, <em>y</em>, and <em>z</em>. In addition, any translation of a <span>position</span> on a plane can be represented by two coordinates, <em>Δx</em> and <em><span>Δ</span>y</em>, and any translation of a <span>position</span> in space can be represented by three coordinates, <em><span>Δx</span></em>, <em><span>Δ</span>y</em>, and <em><span>Δ</span>z</em>.</p>
<p class="mce-root">For example, consider two <span>position</span>s on a plane:</p>
<ul>
<li class="mce-root"><em>p<sub>1</sub></em>: Its coordinates are <em>x = 4, y = 7.</em></li>
<li class="mce-root"><em><span>p</span><sub>2</sub></em>: Its coordinates are <em>x = 10, y = 16.</em></li>
</ul>
<p class="mce-root">Consider two translations on that plane:</p>
<ul>
<li class="mce-root"><em>t<sub>1</sub></em>: Its coordinates are <img class="fm-editor-equation" src="assets/b9b71b1b-4a16-47c9-a86d-dd1d42c531cd.png" style="width:8.00em;height:1.25em;"/>.</li>
<li class="mce-root"><em><span>t</span><sub>2</sub></em>: Its coordinates are <img class="fm-editor-equation" src="assets/255887c4-c5f8-4c26-a38c-5169b37fb204.png" style="width:7.83em;height:1.08em;"/> .</li>
</ul>
<p class="mce-root">You can say that if you translate the <em>p<sub>1</sub></em> position by the <em>t<sub>1</sub></em> translation, you get to the <em><span>p</span><sub>2</sub></em> position. The computation is done by adding the corresponding coordinates: <em>p<sub>1x</sub> + t<sub>1x</sub> = p<sub>2x</sub></em> (or, in numbers, 4 + 6 = 10) and <em>p<sub>1y</sub><span> </span>+ t<sub>1y</sub><span> </span>= p<sub>2y</sub></em> (or, in numbers, 7 + 9 = 16).</p>
<p class="mce-root">If you apply two translations <span>sequentially</span><span> </span><span>to the <em>p<sub>1</sub></em></span><span> </span><span>position</span><span>—the <em>t<sub>1</sub></em></span><span> translation and the <em>t<sub>2</sub></em></span><span> translation—then you will obtain another </span><span>position</span><span> (say, <em>p<sub>3</sub></em></span><span>). You will also obtain the same result if you first sum the two translations (by summing their components memberwise) and then </span><span>applying the resulting translation to <em>p<sub>1</sub></em></span><span>.</span></p>
<p class="mce-root">So, for the <em>x</em> coordinate, we have <em>(p<sub>1x</sub> + t<sub>1x</sub>) + t<sub>2x</sub> = p<sub>1x</sub> + (t<sub>1x</sub> + t<sub>2x</sub>)</em> and a similar equation also holds for the <em>y</em> coordinate. So, translations can be added. You can add a translation to another one by summing their respective coordinates, instead, it does not make sense to add one<span> </span><span>position</span> to another<span> </span><span>position</span>.</p>
<p class="mce-root">You can simplify your geometric computations by applying the computations to the<span> </span><span>position</span> and translation entities themselves using the following formula:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c06b35b1-a5ee-4926-94df-fa46632a036f.png" style="width:12.92em;height:1.17em;"/></p>
<p class="mce-root">In linear algebra, there are two concepts that can be applied to these sorts of operations:</p>
<ul>
<li class="mce-root"><strong>Vectors</strong>: <span>An algebraic </span><em>vector</em><span> is a tuple of numbers that can be added to another vector, obtaining another vector, which is what is needed to <em>represent translations</em>.</span></li>
<li class="mce-root"><strong>Points</strong>: <span>An algebraic </span><em>point</em><span> is a tuple of numbers that cannot be added to another point, but that can be incremented by a vector, thereby obtaining another point, which is what is needed to <em>represent a</em></span><em><span> </span></em><span><em>position</em>.</span></li>
</ul>
<p class="mce-root">Therefore, linear algebraic <em>N-dimensional vectors</em> are fit to represent <em>translations</em> in an <em>N</em>-dimensional geometric space, whereas <span>linear algebraic <em>N-dimensional points</em> are fit to represent <em>positions</em> in an <em>N</em>-dimensional geometric space</span>.</p>
<p class="mce-root">The <kbd>nalgebra</kbd> library (pronounced <em>en-algebra</em>) is a collection of to many algebraic algorithms that provide implementations for these kinds of two-dimensional point and vector types, and so it will be used in all of the following projects.</p>
<p class="mce-root">Using this library, you can write the following program, which shows which operations are allowed and which are forbidden, using vectors and points:</p>
<pre>use nalgebra::{Point2, Vector2};<br/>fn main() {<br/>    let p1: Point2&lt;f32&gt; = Point2::new(4., 7.);<br/>    let p2: Point2&lt;f32&gt; = Point2::new(10., 16.);<br/>    let v: Vector2&lt;f32&gt; = Vector2::new(6., 9.);<br/>    <br/>    assert!(p1.x == 4.);<br/>    assert!(p1.y == 7.);<br/>    assert!(v.x == 6.);<br/>    assert!(v.y == 9.);<br/>    <br/>    assert!(p1 + v == p2);<br/>    assert!(p2 - p1 == v);<br/>    assert!(v + v - v == v);<br/>    assert!(v == (2. * v) / 2.);<br/>    <br/>    //let _ = p1 + p2;<br/>    let _ = 2. * p1;<br/>}</pre>
<p class="mce-root">The first three statements of the <kbd>main</kbd> function create two two-dimensional points and one two-dimensional vector whose coordinates are <kbd>f32</kbd> numbers. This sort of inner numeric type can often be <em>inferred</em>, but here it is specified for clarity.</p>
<p class="mce-root">The next four statements show that both the <kbd>Point2</kbd> and <kbd>Vector2</kbd><span> </span><span>types </span><span>contain the </span><kbd>x</kbd> <span>and</span> <kbd>y</kbd><span> </span><span>fields</span><span>, initialized by the arguments of the</span> <kbd>new</kbd> <span>function. So, the</span> <kbd>Point2</kbd> <span>and</span> <kbd>Vector2</kbd> <span>types look quite similar, and actually many libraries and many developers use just one type to store both</span><span> </span><span>position</span><span>s and translations.</span></p>
<p class="mce-root">However, these types differ for the allowed operations. The following four statements show which<span> operations can be carried out:</span></p>
<ul>
<li class="mce-root"><span>Sum a vector to a point (<kbd>p1 + v</kbd>), o</span>btaining another point.</li>
<li class="mce-root">Subtract two points (<kbd>p2 - p1</kbd>), obtaining a vector.</li>
<li class="mce-root">Sum two vectors or subtract two vectors (<kbd>v + v - v</kbd>), obtaining a vector in both cases.</li>
<li class="mce-root">Multiply a vector by a number or divide a vector by a number (<kbd>(2. * v) / 2.</kbd>), obtaining a vector in both cases.</li>
</ul>
<p class="mce-root">There are some operations allowed on vectors that shouldn't be allowed on points (because they make no sense for them), which the last two statements show. You cannot add two points (<kbd>p1 + p2</kbd>) and actually, this operation is commented out to prevent a compilation error. You shouldn't multiply a point by a number (<kbd>2. * p1</kbd>), although, for some reason, the <kbd>nalgebra</kbd> library allows this.</p>
<div class="mce-root packt_infobox">If you want to learn more about the <kbd>nalgebra</kbd> library, you can find its documentation at <a href="https://www.nalgebra.org/">https://www.nalgebra.org/</a>.</div>
<p class="mce-root">Now that we have looked at a good way to handle geometric coordinates using the <kbd>nalgebra</kbd> library, let's see how to use them in game applications.</p>
<h1 id="uuid-946fd827-d5fa-47c0-b407-100960cce193">Implementing the gg_ski project</h1>
<p>The first three projects in this chapter are just a rewrite of the three projects covered in the preceding chapter but are converted so that they use the <kbd>ggez</kbd> framework and the <kbd>nalgebra</kbd> library instead. They are as follows:</p>
<ul>
<li>The <kbd>ski</kbd> project has become <kbd>gg_ski</kbd>.</li>
<li>The <kbd>silent_slalom</kbd> project has become <kbd>gg_silent_slalom</kbd>.</li>
<li>The <kbd>assets_slalom</kbd> project has become <kbd>gg_assets_slalom</kbd>.</li>
</ul>
<p>Each project's behavior is very similar to its respective project in <a href="72504b4f-2094-4890-9e99-a9251f38c538.xhtml">Chapter 6</a>, <em>Creating a WebAssembly Game Using Quicksilver</em>, and so you can go back to that chapter to see the screenshots accompanying each one. For all <span>three projects, <kbd>gg_ski</kbd>, <kbd>gg_silent_slalom</kbd>, and <kbd>gg_assets_slalom</kbd>,</span> the <kbd>Cargo.toml</kbd> file has the following change. Instead of the <kbd>quicksilver</kbd> dependency, there are the following dependencies:</p>
<pre class="mce-root">ggez = "0.5"<br/>nalgebra = "0.18"</pre>
<p>The term <kbd>ggez</kbd> (pronounced <em>G. G. easy</em>) is a slang term used by multiplayer online gamers. </p>
<p class="mce-root">The <kbd>ggez</kbd> framework was <span>admittedly</span><span> </span><span>inspired by the <strong>LÖVE game framework</strong></span><span>. The main difference between them lies in the programming languages. LÖVE is implemented in C++ and is programmable in Lua, while</span> <kbd>ggez</kbd> <span>is both implemented and programmable in Rust.</span></p>
<p class="mce-root">Now, let's compare the <kbd>main.rs</kbd> source code of the <kbd>ski</kbd> project to that of the <kbd>gg_ski</kbd> project.</p>
<h2 id="uuid-e8d5b29a-3a6f-4556-9e0f-7bc6e082ce31">The main function</h2>
<p>At the end of the file, there is the <kbd>main</kbd> function, which prepares the context for the game and then runs the game:</p>
<pre>fn main() -&gt; GameResult {<br/>    let (context, animation_loop) = &amp;mut ContextBuilder::new<br/>     ("slalom", "ggez")<br/>        .window_setup(conf::WindowSetup::default().title("Slalom"))<br/>        .window_mode(conf::WindowMode::default().dimensions(SCREEN_WIDTH, <br/>          SCREEN_HEIGHT))<br/>        .add_resource_path("static")<br/>        .build()?;<br/>    let game = &amp;mut Screen::new(context)?;<br/>    event::run(context, animation_loop, game)<br/>}</pre>
<p>In this function, you can see that, when you use the <kbd>ggez</kbd> framework, you don't just run the model. First, you should create three objects:</p>
<ul>
<li>A context, which, in our case, is a window. It is assigned to the <kbd>context</kbd> variable.</li>
<li>An animation loop, which animates that context. It <span>is assigned to the </span><kbd>animation_loop</kbd><span> variable.</span></li>
<li>The model, in our case, is of <span><kbd>Screen</kbd> </span>type. It is assigned to the <kbd>game</kbd> variable.</li>
</ul>
<p class="mce-root">After creating these objects, you can call the <kbd>run</kbd> function with these three objects as arguments.</p>
<p class="mce-root">To create the context and the animation loop, a <kbd>ContextBuilder</kbd> object is first created by calling the <kbd>ContextBuilder::new</kbd> function; then, this builder is modified by calling its methods—<kbd>window_setup</kbd>, <kbd>window_mode</kbd>, and <kbd>add_resource_path</kbd>. Finally, the call to the <kbd>build</kbd> method returns both a context and an animation loop.</p>
<p class="mce-root">However, notice the following things:</p>
<ul>
<li class="mce-root">The call to <kbd>new</kbd> specifies a name for the app (<kbd>"slalom"</kbd>) and a name for its creator (<kbd>"ggez"</kbd>).</li>
<li class="mce-root">The call to <kbd>window_setup</kbd> specifies the text in the title bar of the window (<kbd>"Slalom"</kbd>).</li>
<li class="mce-root">The call to <kbd>window_mode</kbd> specifies the desired size of the window.</li>
<li class="mce-root">The call to <kbd>add_resource_path</kbd> specifies the name of the folder that will contain the assets loaded at runtime (<kbd>"static"</kbd>), even if we are not going to use assets in this project.</li>
</ul>
<p class="mce-root">Regarding the <kbd>Screen</kbd> model, notice that it is created using the <kbd>new</kbd> method, and so we will have to provide this method; however, we could use any other name for this sort of creation method.</p>
<h2 id="uuid-651d4902-d4d6-411c-a77a-0879f7ba4fcc">Patterns of input handling</h2>
<p>Both <kbd>quicksilver</kbd> and <kbd>ggez</kbd> adopt an animation loop-based <span><strong>Model-View-Controller</strong> (</span><strong>MVC</strong><span>)</span> pattern. This is done by requiring the model to implement a trait that has two required methods:</p>
<ul>
<li><kbd>update</kbd> is the controller.</li>
<li><kbd>draw</kbd> is the view.</li>
</ul>
<p>Both frameworks run an implicit loop that periodically (many times per second) <span>calls the following:</span></p>
<ul>
<li><span>The controller to update the model, using possible input data and the preceding values of the model</span></li>
<li><span>The view to update the screen, using the updated values of the model</span></li>
</ul>
<p class="mce-root">However, there is a substantial difference in the technique used by these frameworks to get input. <kbd>quicksilver</kbd> is a complete animation loop-oriented framework. The controller (or the <kbd>update</kbd> function) gets input accessing the state of input devices—it can check where the mouse is and which mouse buttons and keyboard keys are being pressed.</p>
<p class="mce-root">Instead, <kbd>ggez</kbd> input handling is event-driven because it captures input device <em>transitions</em>, not input device <em>states</em>. There are several kinds of possible input device transitions:</p>
<ul>
<li>A movement of the mouse (<em>mouse moves</em>)</li>
<li class="mce-root">A press of a mouse button (<em>mouse button down</em>)</li>
<li class="mce-root">A release of a pressed mouse button (<em>mouse button up</em>)</li>
<li class="mce-root">A press of keyboard key (<em>key down</em>)</li>
<li class="mce-root">A release of a pressed keyboard key (<em>key up</em>)</li>
</ul>
<p class="mce-root">In <kbd>ggez</kbd>, for each of these possible input device transitions, the trait declares an optional handler routine that can be implemented for the model by the application code. These routines are called <kbd>mouse_motion_event</kbd>, <kbd>mouse_button_down_event</kbd>, <kbd>mouse_button_up_event</kbd>, <kbd>key_down_event</kbd>, and <kbd>key_up_event</kbd>.</p>
<p class="mce-root">If an event happens in an animation-loop time frame, the corresponding handlers are invoked just before the <kbd>update</kbd> function is invoked. In these event handlers, the application code should store (<span>in the</span><span> model) </span>the <span>information gathered from the event</span>, such as which key has been pressed or in which position the mouse has been moved. Then, the <kbd>update</kbd> function can process this input data to prepare the information needed by the view.</p>
<p class="mce-root">To better understand these techniques, consider, as an example, the following sequence of events or timeline:</p>
<ul>
<li class="mce-root">The <kbd>update</kbd> function is invoked 10 times per second—that is, once every tenth of a second—so, frames per second = 10.</li>
<li class="mce-root">The user presses the <em>A</em> key at <kbd>0.020</kbd> seconds and releases it 50 milliseconds later at <kbd>0.070</kbd> seconds, and then they press the <em>B</em> key at <kbd>0.140</kbd> seconds and release it 240 milliseconds later at <kbd>0.380</kbd> seconds.</li>
</ul>
<p class="mce-root">For <kbd>quicksilver</kbd>, we have the following timeline:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 13%"><strong>At time</strong></td>
<td style="width: 26.0606%"><strong>Input device state</strong></td>
<td style="width: 146.939%"><strong>Input processing in the<span> </span>update<span> </span>function</strong></td>
</tr>
<tr>
<td style="width: 13%"><kbd>0.0</kbd></td>
<td style="width: 26.0606%">No key is pressed.</td>
<td style="width: 146.939%">Nothing.</td>
</tr>
<tr>
<td style="width: 13%"><kbd>0.1</kbd></td>
<td style="width: 26.0606%"><span><span><span>No key is </span></span></span><span><span>pressed.</span></span></td>
<td style="width: 146.939%"><span>Nothing.</span></td>
</tr>
<tr>
<td style="width: 13%"><kbd>0.2</kbd></td>
<td style="width: 26.0606%"><span><span><span>The <em>B</em> key is</span></span></span><span><span> pressed.</span></span></td>
<td style="width: 146.939%"><span>The <em>B</em> key is processed.</span></td>
</tr>
<tr>
<td style="width: 13%"><kbd>0.3</kbd></td>
<td style="width: 26.0606%"><span><span><span>The <em>B</em> key is</span></span></span><span><span> pressed.</span></span></td>
<td style="width: 146.939%"><span>The <em>B</em> key is processed.</span></td>
</tr>
<tr>
<td style="width: 13%"><kbd>0.4</kbd></td>
<td style="width: 26.0606%"><span><span>No key is</span></span><span> pressed.</span></td>
<td style="width: 146.939%"><span>Nothing.</span></td>
</tr>
<tr>
<td style="width: 13%"><kbd>0.5</kbd></td>
<td style="width: 26.0606%"><span><span>No key is</span></span><span> pressed.</span></td>
<td style="width: 146.939%"><span>Nothing.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">For <kbd>ggez</kbd>, we have <span>the following timeline</span>:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 10%"><strong>At time</strong></td>
<td style="width: 51.2935%"><strong>Input events</strong></td>
<td style="width: 125.707%"><strong>Input <span>processing</span> in the</strong><span> </span><strong>update function</strong></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0.0</kbd></td>
<td style="width: 51.2935%">No input events.</td>
<td style="width: 125.707%"><span>No key info is stored in the model.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0.1</kbd></td>
<td style="width: 51.2935%">
<p class="mce-root"><span>The <kbd>key_down_event</kbd> function is invoked with the <em>A</em> key as an argument. It stores the <em>A</em> key in the model.</span></p>
<p><span>The <kbd>key_up_event</kbd> function is invoked with the <em>A</em> key as an argument. It does nothing.</span></p>
</td>
<td style="width: 125.707%"><span>The <em>A</em> key is read from the model. It is processed and reset.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0.2</kbd></td>
<td style="width: 51.2935%"><span>The <kbd>key_down_event</kbd> function is invoked with the <em>B</em> key as an argument. It stores the <em>B</em> key in the model.</span></td>
<td style="width: 125.707%"><span>The <em>B</em> key is read from the model. It is processed and reset.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0.3</kbd></td>
<td style="width: 51.2935%"><span>No input events.</span></td>
<td style="width: 125.707%"><span>No key info is stored in the model.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0.4</kbd></td>
<td style="width: 51.2935%"><span>The <kbd>key_up_event</kbd> function is invoked with the <em>B</em> key as an argument. It does nothing.</span></td>
<td style="width: 125.707%"><span>No key info is stored in the model.</span></td>
</tr>
<tr>
<td style="width: 10%"><kbd>0.5</kbd></td>
<td style="width: 51.2935%"><span>No input events.</span></td>
<td style="width: 125.707%"><span>No key info is stored in the model.</span></td>
</tr>
</tbody>
</table>
<p class="mce-root">Notice that for <kbd>quicksilver</kbd>, the <em>A</em> key has never been pressed, while the <em>B</em> key has been pressed twice. This can be good for continuous events, such as using a joystick, but not for discrete events, such as clicking a command button or typing text into a textbox.</p>
<p class="mce-root">However, <kbd>quicksilver</kbd> has the advantage of capturing all simultaneous events. For example, <kbd><span>q</span><span>uicksilver</span></kbd><span> can easily handle</span> <span>a chord, which is when several keys are continually pressed at the same time</span><span>.</span></p>
<p class="mce-root">Instead, for <kbd>ggez</kbd>, as long as only one key is pressed in a time frame, all key presses are <span>handled</span> the appropriate number of times. This is expected for buttons and textboxes; however, chords are not handled correctly. The only key combinations handled by <kbd>ggez</kbd> are those involving the <em>Shift</em>, <em>Ctrl</em>, and <em>Alt</em><span> </span><span>special keys</span><span>.</span></p>
<h2 id="uuid-5536f26d-4493-4bd0-b0eb-2c18d2366199">Input handling in the gg_ski project</h2>
<p>Among the many events that can be captured by a <kbd>ggez</kbd> application, the <kbd>gg_ski</kbd> game captures only two events—the press of the right or left arrow keys and their release. The handling of these events stores the relevant input information in the model so that the <kbd>update</kbd> function can use it. Therefore, the model must contain some additional fields, with respect to those contained for the <kbd>quicksilver</kbd> <kbd>ski</kbd> project.</p>
<p class="mce-root">So, we <span>now</span><span> </span><span>have a model that contains some fields updated by the event functions, to be used by the</span> <kbd>update</kbd> <span>function, and some other fields updated by the</span> <kbd>update</kbd> <span>function, to be used by the</span> <kbd>draw</kbd> <span>function. To distinguish these input fields, it's better to encapsulate them in a structure defined as follows:</span></p>
<pre class="mce-root"><span>struct InputState {</span><br/><span>    to_turn: f32,</span><br/><span>    started: bool,</span><br/><span>}</span></pre>
<p class="mce-root">The <kbd>to_turn</kbd> field indicates that the user has pressed an arrow key to change the direction of the ski. If only the left key is pressed, the direction angle should be decremented, and so the value of this field should be <kbd>-1.0</kbd>. If only the right key is pressed, the direction angle should be incremented, and so the value of this field should be <kbd>1.0</kbd>. If the user has not pressed any arrow key, the direction should remain unchanged, and so the value of this field should be <kbd>0.0</kbd>.</p>
<p class="mce-root">The <kbd>started</kbd> field indicates that the race has started. It is not used in this project. An instance of this structure is added to the model using the following line:</p>
<pre class="mce-root">input: InputState,</pre>
<p class="mce-root">The capture of key presses is done through the following code:</p>
<pre class="mce-root">fn key_down_event(<br/>    &amp;mut self,<br/>    _ctx: &amp;mut Context,<br/>    keycode: KeyCode,<br/>    _keymod: KeyMods,<br/>    _repeat: bool,<br/>) {<br/>    match keycode {<br/>        KeyCode::Left =&gt; { self.input.to_turn = -1.0; }<br/>        KeyCode::Right =&gt; { self.input.to_turn = 1.0; }<br/>        _ =&gt; (),<br/>    }<br/>}</pre>
<p class="mce-root">The <kbd>keycode</kbd> argument specifies which key has been pressed. If the left or the right arrow keys have been pressed, the <kbd>to_turn</kbd> field is set to <kbd>-1.0</kbd> or to <kbd>+1.0</kbd>, respectively. Any other keys that are pressed are ignored.</p>
<p class="mce-root">Capturing the release of the keys is done through the following code:</p>
<pre class="mce-root">fn key_up_event(&amp;mut self, _ctx: &amp;mut Context, keycode: KeyCode, _keymod: KeyMods) {<br/>    match keycode {<br/>        KeyCode::Left | KeyCode::Right =&gt; {<br/>            self.input.to_turn = 0.0;<br/>        }<br/>        _ =&gt; (),<br/>    }<br/>}</pre>
<p class="mce-root">If the left or the right arrow keys are released, the <kbd>to_turn</kbd> field is set to <kbd>0.0</kbd> to stop the change of direction. The release of any other key is ignored.</p>
<h2 id="uuid-cd1d7163-6247-4f0a-8067-a1bcf9fd9151">Other differences with quicksilver</h2>
<p>Between <kbd>quicksilver</kbd> and <kbd>ggez</kbd>, in addition to the described conceptual differences, there are some minor differences, which I have covered in the following subsections.</p>
<h3 id="uuid-c9a2774c-3f80-4618-b44f-1fbbea79fa1d">Name of the trait</h3>
<p>The name of the trait to be implemented by the model is <kbd>State</kbd> for <kbd>quicksilver</kbd> and <kbd>EventHandler</kbd> for <kbd>ggez</kbd>. So, for <kbd>quicksilver</kbd> we had the following line:</p>
<pre>impl State for Screen {</pre>
<p>But in <kbd>ggez</kbd>, we have the following:</p>
<pre>impl EventHandler for Screen {</pre>
<h3 id="uuid-74ae8a1b-d62f-452f-84b3-17ea5c7912d5">The type of context</h3>
<p>Using both <kbd>quicksilver</kbd> and <kbd>ggez</kbd>, you need to implement the <kbd>update</kbd> method and the <kbd>draw</kbd> method. Both of these methods receive an argument<span> </span><span>for both frameworks</span><span> that describes the input/output context. This context is the object used to receive interactive input (by the </span><kbd>update</kbd><span> method) and to emit graphical output (by the </span><kbd>draw</kbd><span> method).</span></p>
<p>However, for <kbd>quicksilver</kbd> the type of this context argument is <kbd>Window</kbd>, as in the following function signatures:</p>
<pre>fn update(&amp;mut self, window: &amp;mut Window) -&gt; Result&lt;()&gt; {<br/>...<br/>fn draw(&amp;mut self, window: &amp;mut Window) -&gt; Result&lt;()&gt; {</pre>
<p><span>For </span><kbd>ggez</kbd><span>, it is </span><kbd>Context</kbd><span>. So, now we have the following signatures:</span></p>
<pre>fn update(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {<br/>...<br/>fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult {</pre>
<h3 id="uuid-638a8630-7fbd-41ee-9b7d-9d8b422e4c20">The new method</h3>
<p>The <kbd>State</kbd> trait of <kbd>quicksilver</kbd> requires the implementation of the <kbd>new</kbd> method, used by the framework to create the model instance. The <kbd>EventHandler</kbd> trait of <kbd>ggez</kbd> has no such method because the model instance is created explicitly by application code in the <kbd>main</kbd> function, as we have seen.</p>
<h3 id="uuid-9a27f409-7582-485a-b232-057a6e73d479">The angle's unit of measurement</h3>
<p>While <kbd>quicksilver</kbd> rotation angles must be specified in degrees, <kbd>ggez</kbd> rotation angles must be specified in radians, and so angular constants and variables are specified in these units of measurement. So, now we have the following lines:</p>
<pre>const STEERING_SPEED: f32 = 110. / 180. * PI; // in radians/second<br/>const MAX_ANGLE: f32 = 75. / 180. * PI; // in radians</pre>
<h3 id="uuid-872b495a-2df1-4e1d-b8ab-e89dbd3badc1">How to specify the FPS rate</h3>
<p><span>To specify the desired</span> <strong>Frames Per Second</strong> (<span><strong>FPS</strong>) rate, two parameters are specified in the</span> <kbd>main</kbd> <span>function</span> <span>when using <kbd>quicksilver</kbd>,</span><span> whereas <kbd>ggez</kbd> uses another technique. For <kbd>ggez</kbd>, the</span> <kbd>update</kbd> <span>function is always invoked 60 times per second (if possible), but the application code can simulate a different rate by writing the following body of the</span> <kbd>update</kbd> <span>function:</span></p>
<pre style="color: black">const DESIRED_FPS: u32 = 25;<br/>while timer::check_update_time(ctx, DESIRED_FPS) {<br/>    ...<br/>}</pre>
<p><span>The purpose of this code is to ensure that the body of the</span> <kbd>while</kbd><span> loop is executed with the specified rate, which in this case is <kbd>25</kbd> frames per second. Let's see how this is accomplished.<br/></span></p>
<p><span>The required rate</span> <span>specified </span><span>in our code means that the body should be executed once every <em>1000 / 25 = 40 </em>milliseconds. When the</span> <kbd>update</kbd> <span>function is executed, if less than 40 milliseconds have elapsed since the preceding execution, the</span> <kbd>check_update_time</kbd> <span>function returns</span> <kbd>false</kbd><span>, and so the body of the <kbd>while</kbd> loop is not executed this time. It is likely that even at the next </span><kbd>update</kbd><span> call, not enough time will have elapsed, and so the</span> <kbd>check_update_time</kbd> <span>function will return</span> <kbd>false</kbd> <span>again. In a later execution, when at least 40 milliseconds have elapsed since the last time the body was executed,</span> <kbd>true</kbd><span> will be returned, and so the body will be executed.</span></p>
<p><span>This allows a rate that is lower than 60 FPS. However, there is another feature. If a frame, for some reason, takes longer than the allotted time—say, 130 milliseconds—causing the animation to stutter, then the</span> <kbd>check_update_time</kbd> <span>function returns</span> <kbd>true</kbd> <span>several times in a row to make up for the lost time.</span></p>
<p>Of course, you cannot obtain the desired rate if every frame is so slow to take too much time. Tough, as long as your frames are processed within the required time, this technique ensures that the average frame rate will be the specified one.</p>
<p>To say that the actual average rate approximates the desired rate<span>, it is enough that the average time taken by a frame is less than the one allotted for a frame.</span> <span>Instead, if your frames take, on average, 100 milliseconds, the actual frame rate will be 10 FPS.</span></p>
<h3 id="uuid-46c195e6-94c6-4d09-8764-b5c7dde73b9f">Handling the ski steering</h3>
<p><span>The ski steering is handled differently in</span><span> the body of the</span><span> </span><kbd>update</kbd><span> </span><span>loop</span><span>. In the</span> <kbd>ski</kbd><span> project, the</span> <kbd>steer</kbd> <span>function is </span><span>only</span><span> </span><span>called if an arrow key is kept pressed down at that time. Instead, in the</span> <kbd>gg_sky</kbd> <span>project, the following statement is always executed:</span></p>
<pre style="color: black">self.steer(self.input.to_turn);</pre>
<p>The <kbd>steer</kbd> function is called at any time frame, passing the <span>value</span><span> set before by the input handling methods. If this value is <kbd>0</kbd>, the ski doesn't steer.</span></p>
<h3 id="uuid-b7073835-126f-467f-89bf-5cb5f7f660b8">Computation of new position and speed</h3>
<p>In addition, the body of the <kbd>update</kbd> function now contains the following statements:</p>
<pre style="color: black">let now = timer::time_since_start(ctx);<br/>self.period_in_sec = (now - self.previous_frame_time)<br/>    .as_millis() as f32 / 1000.;<br/>self.previous_frame_time = now;</pre>
<p>Their purpose is to compute the correct kinematics of the ski. In mechanics, to compute a position variation (<img class="fm-editor-equation" src="assets/f8bdcdfb-b580-4d95-b963-a6c1da93a2fb.png" style="width:1.42em;height:1.08em;"/>), you have to multiply the current speed (also called <strong>velocity</strong>, <em>v</em>) by the time elapsed since the previous frame (<img class="fm-editor-equation" src="assets/2de95eed-7834-4bac-8d45-52416eaf488e.png" style="width:1.42em;height:1.00em;"/>). This results in the following equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/94c8e1ad-c647-489c-b25f-26a56f31c4be.png" style="width:5.92em;height:1.17em;"/></p>
<p>To compute a speed variation (<img class="fm-editor-equation" src="assets/a5bc6524-13ce-4da6-9434-20778f84594a.png" style="width:1.58em;height:1.00em;"/>), you have to multiply the current acceleration (<em>a</em>) by the time elapsed since the preceding frame (<img class="fm-editor-equation" src="assets/8d645a85-0f7a-4d27-8179-8d85a46c24b6.png" style="width:1.25em;height:0.92em;"/>), which <span>results in the following equation:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/fc23c985-1aaf-4a48-8e24-ddc75239e617.png" style="width:5.92em;height:1.17em;"/></p>
<p>So, to compute the position variation and the speed variation, we need the time elapsed since the preceding frame. The <kbd>ggez</kbd> framework provides the <kbd>timer::time_since_start</kbd> function, which returns the duration since the start of the application. We subtract<span> the time of the preceding frame</span><span> from the duration to obtain the time elapsed between the two frames. The duration</span><span> is then converted into seconds. Finally, the current time is saved, to be used in the next frame computation.</span></p>
<h3 id="uuid-414d378f-4e79-4e4b-9b74-558a54b19663">Drawing the background</h3>
<p>The MVC view implemented by the <kbd>draw</kbd> method draws the white background by using the following statement:</p>
<pre style="color: black">graphics::clear(ctx, graphics::WHITE);</pre>
<p>Now, let's check how to draw the composite shapes. </p>
<h3 id="uuid-03ab2100-5a88-492f-9918-a846c74f5fab">Drawing composite shapes</h3>
<p><span>To draw a composite shape, instead of individually </span><span>drawing all of its</span> <span>components, first create a</span><span> </span><kbd>Mesh</kbd><span> object, which is a composite shape containing all the component shapes, and then draw the </span><kbd>Mesh</kbd><span> object. To create a</span> <kbd>Mesh</kbd><span> object, the</span> <kbd>MeshBuilder</kbd> <span>class is used with this code: </span></p>
<pre style="color: black">let ski = graphics::MeshBuilder::new()<br/>    .rectangle(<br/>        DrawMode::fill(),<br/>        Rect {<br/>            x: -SKI_WIDTH / 2.,<br/>            y: SKI_TIP_LEN,<br/>            w: SKI_WIDTH,<br/>            h: SKI_LENGTH,<br/>        },<br/>        [1., 0., 1., 1.].into(),<br/>    )<br/>    .polygon(<br/>        DrawMode::fill(),<br/>        &amp;[<br/>            Point2::new(-SKI_WIDTH / 2., SKI_TIP_LEN),<br/>            Point2::new(SKI_WIDTH / 2., SKI_TIP_LEN),<br/>            Point2::new(0., 0.),<br/>        ],<br/>        [0.5, 0., 1., 1.].into(),<br/>    )?<br/>    .build(ctx)?;</pre>
<p>Let's now check what this code does:</p>
<ol>
<li class="mce-root"><span>First, the</span> <kbd>new</kbd> <span>function creates a </span><kbd>MeshBuilder</kbd> <span>object. </span></li>
<li class="mce-root"><span>Then, the methods instruct these mesh builders how to create the mesh components. </span><span>The</span> <kbd>rectangle</kbd> <span>method explains how to create a rectangle, which will be the ski body, and the <kbd>polygon</kbd> method explains how to create a polygon, which will be the ski tip. The features of the rectangle are its draw mode (<kbd>DrawMode::fill()</kbd>), its position and size (<kbd>x</kbd>, <kbd>y</kbd>, <kbd>w</kbd>, and <kbd>h</kbd>), and its color (<kbd>1., 0., 1., 1.</kbd>). The features of the polygon are its draw mode, the list of its vertices, and its color. It has just three vertices, so it is a triangle.</span></li>
<li class="mce-root">Then, the <kbd>build</kbd> <span>method creates and returns the specified mesh. Notice that the method calls ending with a question mark are fallible and that the colors are specified by the quadruple red-green-blue-alpha model, where each number is in the range <kbd>0</kbd> to <kbd>1</kbd>.</span></li>
</ol>
<p>To draw a mesh, the following statement is used:</p>
<pre>graphics::draw(<br/>    ctx,<br/>    &amp;ski,<br/>    graphics::DrawParam::new()<br/>        .dest(Point2::new(<br/>            SCREEN_WIDTH / 2. + self.ski_across_offset,<br/>            SCREEN_HEIGHT * 15. / 16. - SKI_LENGTH / 2.<br/>                - SKI_TIP_LEN,<br/>        ))<br/>        .rotation(self.direction),<br/>)?;</pre>
<p><span>This <kbd>draw</kbd> method is not the same as the <kbd>draw</kbd> method that defines the view of the MVC architecture. This is found in the <kbd>ggez::graphics</kbd> module, while the containing method (the view) is part of the <kbd>ggez::event::EventHandler</kbd> trait.</span></p>
<p>The first argument of the <kbd>graphics::draw</kbd> method—<kbd>ctx</kbd>—is the context on which we are drawing. The second argument—<kbd>&amp;ski</kbd>—is the mesh we are drawing. The third argument is a collection of parameters, encapsulated in a <kbd>DrawParam</kbd> object. This type allows us to specify numerous parameters, two of which are specified as follows:</p>
<ul>
<li>The point to draw the mesh, specified using the <kbd>dest</kbd> method</li>
<li>The angle (in radians) by which the mesh must be rotated, specified using the <kbd>rotation</kbd> method</li>
</ul>
<p>So, we have now seen how to draw on the screen. However, after calling these statements, nothing actually appears on the screen because the statements just prepare the output off-screen. To get the output, a finalization statement is needed, which is described in the next section.</p>
<h3 id="uuid-63644eab-cbef-465b-8963-28e6df939685">Ending the draw method</h3>
<p>The view (that is, the <kbd>draw</kbd> method) should end with the following statements:</p>
<pre>graphics::present(ctx)?;<br/>timer::yield_now();</pre>
<p class="mce-root">In the typical double-buffering technique used by OpenGL, all the <kbd>ggez</kbd> drawing operations do not output graphics directly on the screen but in a hidden buffer. The <kbd>present</kbd> function quickly swaps the shown screen buffer with the hidden drawn buffer, with the effect of <span>immediately</span><span> </span><span>displaying the scene and avoiding the flicker that could appear otherwise. The last statement tells the operating system to stop using the CPU for this process until the next frame must be drawn. By doing this, if the processing of a frame is quicker than a time frame, the application avoids using 100% of the CPU cycles.</span></p>
<p>So, we have finished examining the <kbd>gg_ski</kbd> project. In the next section, we will examine how the <kbd>gg_silent_slalom</kbd> project builds on this project to create a slalom game with no sound or text.</p>
<h1 id="uuid-7517670b-26e7-4b64-8362-2aef7b3f0b29">Implementing the gg_silent_slalom project</h1>
<p>In this section, we will examine the <kbd>gg_silent_slalom</kbd> project, which is an implementation of the <kbd>ggez</kbd> framework of the <kbd>gg_silent_slalom</kbd> game presented in the preceding chapter. Here, we will <span>only</span><span> </span><span>examine the differences between the</span> <kbd>gg_ski</kbd> <span>project and the </span><kbd>silent_slalom</kbd> <span>pro</span><span>ject.</span></p>
<p>As we saw in the preceding section, <kbd>ggez</kbd> handles input as events. In this project, two other key events are handled—<kbd>Space</kbd> and <kbd>R</kbd>:</p>
<pre>KeyCode::Space =&gt; {<br/>    self.input.started = true;<br/>}<br/>KeyCode::R =&gt; {<br/>    self.input.started = false;<br/>}</pre>
<p>The spacebar is used to command the start of the race, and so it sets<span> </span><span>the</span><span> </span><kbd>started</kbd><span> </span><span>flag</span><span> to</span> <kbd>true</kbd><span>. The</span> <em>R</em> <span>key is used to reposition the ski at the beginning of the slope, and so it sets</span><span> the </span><kbd>started</kbd><span> flag</span><span> to</span> <kbd>false</kbd><span>.</span></p>
<p>This flag is then used in the <kbd>update</kbd> method, as in the following code:</p>
<pre>match self.mode {<br/>    Mode::Ready =&gt; {<br/>        if self.input.started {<br/>            self.mode = Mode::Running;<br/>        }<br/>    }</pre>
<p>When in <kbd>Ready</kbd> mode, instead of directly checking the keyboard state, the <kbd>started</kbd> flag is checked. The computation of speed and acceleration takes into account the time that has actually elapsed since the preceding frame computation:</p>
<pre>self.forward_speed = (self.forward_speed<br/>    + ALONG_ACCELERATION * self.period_in_sec * self.direction.cos())<br/>    * DRAG_FACTOR.powf(self.period_in_sec);</pre>
<p>To compute the new forward speed, the acceleration along the slope (<kbd>ALONG_ACCELERATION</kbd>) is projected on the ski direction using the cosine function (<kbd>self.direction.cos()</kbd>), and then the result is multiplied by the elapsed time (<kbd>self.period_in_sec</kbd>) to get the speed increment.</p>
<p>The incremented speed is then multiplied by a factor that is less than <kbd>1</kbd> to take friction into account. This factor is the <kbd>DRAG_FACTOR</kbd> constant for a time of 1 second. To get the decrease factor for the actual time elapsed, the exponential function must be used (<kbd>powf</kbd>).</p>
<p>To compute the new horizontal position of the ski tip, the following statement is executed:</p>
<pre>self.ski_across_offset +=<br/>    self.forward_speed * self.period_in_sec * self.direction.sin();</pre>
<p>This multiplies the speed (<kbd>self.forward_speed</kbd>) by the time elapsed (<kbd>self.period_in_sec</kbd>) to obtain the space increment. This increment is projected on the horizontal direction using the sine function (<kbd>self.direction.sin()</kbd>) to get the horizontal position variation.</p>
<p>A similar computation is performed to compute the movement along the slope, which is <span>actually</span><span> </span><span>the offset of the position of the gates as the ski is </span><span>always</span><span> </span><span>drawn at the same</span> <em>Y</em> <span>coordinate.</span></p>
<p>To draw the poles of the gates in the <kbd>draw</kbd> method, first, two meshes are created by using the following statements:</p>
<pre>let normal_pole = graphics::Mesh::new_circle(<br/>    ctx,<br/>    DrawMode::fill(),<br/>    Point2::new(0., 0.),<br/>    GATE_POLE_RADIUS,<br/>    0.05,<br/>    [0., 0., 1., 1.].into(),<br/>)?;<br/>let finish_pole = graphics::Mesh::new_circle(<br/>    ctx,<br/>    DrawMode::fill(),<br/>    Point2::new(0., 0.),<br/>    GATE_POLE_RADIUS,<br/>    0.05,<br/>    [0., 1., 0., 1.].into(),<br/>)?;</pre>
<p>Here, the meshes are created directly without using a <kbd>MeshBuilder</kbd> object. The <kbd>new_circle</kbd> method requires <span>the context, the fill mode, the center, the radius, a tolerance, and the color</span><span> as parameters. Tolerance is a trade-off between performance and graphic quality. The former mesh is used to draw all the poles, except those of the finish gate, and the latter mesh is used to draw the poles </span><span>of the finish gate.</span></p>
<p>Then, <span>these meshes are drawn to show all </span>the poles using statements such as the following:</p>
<pre>graphics::draw(<br/>    ctx,<br/>    pole,<br/>    (Point2::new(SCREEN_WIDTH / 2. + gate.0, gates_along_pos),),<br/>)?;</pre>
<p>Here, the third argument (with the <kbd>DrawParam</kbd> type) is specified in a simple but somewhat obscure way; it is a tuple containing just one element. This element is interpreted as the position where the mesh will be drawn, corresponding to the <kbd>dest</kbd> method call seen in the preceding section.</p>
<p>So, we have now also seen the peculiarities of the <kbd>gg_silent_slalom</kbd> project. In the next section, we will look at the <span><kbd>gg_assets_slalom</kbd> project, which adds sound and text to our p</span><span>roject.</span></p>
<h1 id="uuid-a40f041f-e948-4cb8-b1c5-05b7718392b6">Implementing<span> t</span>he gg_assets_slalom project</h1>
<p>In this chapter, we will examine the <kbd>gg_assets_slalom</kbd> project, which is an implementation of the <kbd>ggez</kbd> framework of the <kbd>assets_slalom</kbd> game presented in the preceding chapter. Here, we will <span>only</span><span> </span><span>examine the differences between the</span> <kbd>gg_silent_slalom</kbd> <span>project and the </span><kbd>assets_slalom</kbd> <span>proj</span><span>ect.</span></p>
<p>The main difference is found in how the assets are loaded. The assets of these projects are of two kinds—fonts and sounds. To encapsulate these assets, instead of using objects with the <kbd>Asset&lt;Font&gt;</kbd> and <kbd>Asset&lt;Sound&gt;</kbd> types, <kbd>ggez</kbd> uses objects with the <kbd>graphics::Font</kbd> and <kbd>audio::Source</kbd> types, respectively. These assets are loaded into the constructor of the model. For example, the constructor of the <kbd>Screen</kbd> object contains the following statements:</p>
<pre>font: Font::new(ctx, "/font.ttf")?,<br/>whoosh_sound: audio::Source::new(ctx, "/whoosh.ogg")?,</pre>
<p>The first one loads<span> </span>a file containing a <kbd>TrueType</kbd> font<span> </span><span>for the</span><span> </span><kbd>ctx</kbd><span> </span><span>context</span><span> and returns an object encapsulating this font. The second one loads (for the</span> <kbd>ctx</kbd> <span>context) a file containing an OGG sound and returns an object encapsulating this sound. Both files must be present in the</span> <kbd>asset</kbd> <span>folder that was specified in the</span> <kbd>main</kbd> <span>function using the </span><kbd>add_resource_path</kbd> <span>method, and they must be in one of the supported formats.</span></p>
<p>There is an important difference in how <kbd>quicksilver</kbd> and <kbd>ggez</kbd> load their assets. <kbd>q</kbd><span><kbd>uicksilver</kbd> loads them asynchronously, creating future objects whose access function must ensure that the asset is loaded. On the other hand, <kbd>ggez</kbd> is synchronous; when it loads the assets, it blocks the application until the assets are completely loaded. The objects created are not future objects, and so they can be used immediately.</span></p>
<p>Because it uses future objects, <kbd>quicksilver</kbd> is more sophisticated, but this <span>sophistication is</span> <span>probably</span><span> </span><span>useless on a desktop application because, provided your application has no more than a few megabytes of assets, loading them from local storage is quite fast, and so </span><span>some </span><span>blocking</span><span> </span><span>statements at application startup are not going to be inconvenient. Of course, to prevent slowing down animations, the assets must be loaded only at application startup, when changing the level of a game, or when the game is ending. Once an asset is loaded, it is immediately available.</span></p>
<p>The easiest asset to use is sound. To play a sound, the following function is defined:</p>
<pre>fn play_sound(sound: &amp;mut audio::Source, volume: f32) {<br/>    sound.set_volume(volume);<br/>    let _ = sound.play_detached();<br/>}</pre>
<p>Its first argument is the <kbd>sound</kbd> asset and the second argument is the desired <kbd>volume</kbd> level. This function simply sets the volume and then plays the sound using the <kbd>play_detached</kbd> method. This method overlaps the new sound with any other sounds that are already playing. There is also a <kbd>play</kbd> method, which automatically stops playing the old sounds before starting the new one.</p>
<p>To play a fixed-volume sound, such as one that signals the failure to enter a gate, the following statement is used:</p>
<pre>play_sound(&amp;mut self.bump_sound, 1.);</pre>
<p>In addition, to make a sound proportional to the speed, the following statement is used:</p>
<pre>play_sound(&amp;mut self.whoosh_sound, self.forward_speed * 0.005);</pre>
<p class="mce-root">The font is quite easy to use, too:</p>
<pre>let text = graphics::Text::new((elapsed_shown_text, self.font, 16.0));<br/>graphics::draw(ctx, &amp;text, (Point2::new(4.0, 4.0), graphics::BLACK))?;</pre>
<p>The first statement creates a text shape by calling the <kbd>new</kbd> function. It has a tuple<span> with three fields</span><span> </span><span>as an argument</span><span>:</span></p>
<ul>
<li>The string to print (<kbd>elapsed_shown_text</kbd>)</li>
<li>The scalable font object to use for this text (<kbd>self.font</kbd>)</li>
<li>The desired size of the generated text (<kbd>16.0</kbd>)</li>
</ul>
<p>The second statement draws the created text shape on the <kbd>ctx</kbd> context. This statement specifies a tuple that will be converted to a <kbd>DrawParam</kbd> value<span> </span><span>as a third parameter</span><span>. The specified sub-arguments are the destination point (</span><kbd>Point2::new(4.0, 4.0)</kbd><span>) and the color to use (</span><kbd>graphics::BLACK</kbd><span>).</span></p>
<p>So, we have now covered the whole game. In the next section, we will look at another game, which uses mouse clicks and other kinds of assets—images.</p>
<h1 id="uuid-b64ba92a-9795-4a05-89ec-ee37faa78cbf">Implementing<span> t</span>he gg_whac project</h1>
<p>In this section, we will examine the <kbd>gg_whac</kbd> project, which is an implementation in the <kbd>ggez</kbd> framework <span>of the famous</span> <strong>Whack-A-Mole<span> </span></strong><span>arcade game</span><span>. First of all</span><span>, let's try to play it.</span></p>
<p>After running <kbd>cargo run --release</kbd> in the <kbd>gg_whac</kbd> folder, the following window will appear, which shows a lawn:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eb92e5c9-1f75-4275-bb78-e3dc6baa4d3e.png" style="width:40.50em;height:31.58em;"/></p>
<p>For those of you who aren't familiar with this game, here are the rules. When you click on the <span class="packt_screen">Start</span> button, the following things happen:</p>
<ol>
<li>The <span class="packt_screen">Start</span> button disappears.</li>
<li>The countdown begins at the top left from <span class="packt_screen">40</span> seconds to <span class="packt_screen">0</span>.</li>
<li><span>A nice mole pops up in a random position of the lawn.</span></li>
<li>The mouse cursor becomes a barred circle.</li>
<li><span>If you move your mouse cursor over the mole, it becomes a cross and a big mallet appears; this mallet can be dragged by the mouse as long as you remain over the mole.</span></li>
</ol>
<p><span>Your window should look similar to the following:</span></p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/b971420a-927d-4040-aedf-18b8cfe6d402.png" style="width:42.67em;height:33.25em;"/></span></p>
<p>If you click the main mouse button when the mouse cursor hovers over the mole, the mole disappears and another one appears in another position. In the meantime, a counter tells you how many moles you have managed to whack. When the countdown reaches <span class="packt_screen">0</span>, you are presented with your score.</p>
<h2 id="uuid-5c05418b-1e8e-4d92-9850-8a0839d02899">The assets</h2>
<p>To understand the behavior of this application, first, let's look at the content of the <kbd>assets</kbd> folder:</p>
<ul>
<li><kbd>cry.ogg</kbd> is the sound produced by the mole when it pops up out of the lawn.</li>
<li><kbd>click.ogg</kbd> is the sound of the mallet when it hits the mole.</li>
<li><kbd>bump.ogg</kbd> is the sound <span>of the mallet when it </span>hits the lawn but misses the mole.</li>
<li><kbd>two_notes.ogg</kbd> is the jingle produced when the game ends because the countdown has elapsed.</li>
<li><kbd>font.ttf</kbd> is the font used for all the visible text.</li>
<li><kbd>mole.png</kbd> is the image of the moles.</li>
<li><kbd>mallet.png</kbd> <span>is the image of the mallet.</span></li>
<li><kbd>lawn.jpg</kbd> is the image used to fill the background.</li>
<li><kbd>button.png</kbd> is the image used for the <span class="packt_screen">Start</span> button.</li>
</ul>
<p>We already saw, in the preceding section, how to load and use sounds and fonts. Here, there is a new kind of asset—images. Images are declared by statements such as the following:</p>
<pre>lawn_image: graphics::Image,</pre>
<p>They are loaded, at application initialization time, by statements such as the following:</p>
<pre>lawn_image: graphics::Image::new(ctx, "/lawn.jpg")?</pre>
<p>They are displayed by statements such as the following:</p>
<pre>graphics::draw(ctx, &amp;self.lawn_image, lawn_params)?;</pre>
<p>Here, the <kbd>lawn_params</kbd><span> </span><span>argument</span><span>, with a type of </span><kbd>DrawParam</kbd><span>, can specify a position, a scale, a rotation, and even a crop.</span></p>
<h2 id="uuid-ac69d8b5-bc1b-40e6-bd75-052d026e8818">The general structure of the application and events</h2>
<p>Now, let's examine the structure of the source code. Like the preceding projects we have seen in this chapter, this project does the following:</p>
<ul>
<li>Defines some constants</li>
<li>Defines a model with the <kbd>struct Screen</kbd> type</li>
<li>Implements the <kbd>EventHandler</kbd> trait with its required <kbd>update</kbd> and <kbd>draw</kbd> methods and its optional <kbd>mouse_button_down_event</kbd> and <kbd>mouse_button_up_event</kbd> methods</li>
<li>Defines the <kbd>main</kbd> function</li>
</ul>
<p>The most important field of the model is <kbd>mode</kbd>, whose type is defined by the following code:</p>
<pre>enum Mode {<br/>    Ready,<br/>    Raising,<br/>    Lowering,<br/>}</pre>
<p>The initial mode is <kbd>Ready</kbd>, where the countdown is stopped and the game is ready to start. When the game is running, there are the following states:</p>
<ul>
<li>No mole appears.</li>
<li>One mole rises from the ground.</li>
<li>One mole rises and waits to be hit.</li>
<li>A blow of the mallet is about to hit the mole.</li>
<li>The mole that has been hit lowers into the ground.</li>
</ul>
<p>Well, actually, the first state does not exists, because as soon as the game starts, a mole pops up, and also, as soon as you hit a mole, another mole pops up. The second and third states are represented by <kbd>Mode::Raising</kbd>. Simply put, <span>when the mole reaches its full height, it </span>is not raised.</p>
<p>The fourth and fifth states are <span>represented by </span><kbd>Mode::Lowering</kbd><span>. Simply put, the mole lowers simultaneously with the mallet.</span></p>
<p><span>Regarding the input operations, it should be noted that for the</span> <kbd>EventHandler</kbd> <span>trait, no key handling methods are implemented as this game does not use the keyboard. Instead, it uses the mouse, and so there is the following code:</span></p>
<pre>fn mouse_button_down_event(&amp;mut self, _ctx: &amp;mut Context,<br/>    button: MouseButton, x: f32, y: f32) {<br/>    if button == MouseButton::Left {<br/>        self.mouse_down_at = Some(Point2::new(x, y));<br/>    }<br/>}<br/><br/>fn mouse_button_up_event(&amp;mut self, _ctx: &amp;mut Context,<br/>    button: MouseButton, x: f32, y: f32) {<br/>    if button == MouseButton::Left {<br/>        self.mouse_up_at = Some(Point2::new(x, y));<br/>    }<br/>}</pre>
<p>The first method is invoked when a mouse button is pressed and the second one is invoked when a mouse button is released.</p>
<p>The third argument of these methods (<kbd>button</kbd>) is an enum indicating which button has been pressed; <kbd>MouseButton::Left</kbd> actually represents the main mouse button.</p>
<p>The fourth and fifth arguments of these methods (<kbd>x</kbd> and <kbd>y</kbd>) are the coordinates of the position of the mouse when its button has been pressed. Their unit of measurement is pixels and the origin of their coordinate system is the top-left vertex of the context, which in our case is the client area of the window.</p>
<p>Only the main mouse button is handled. When it is pressed, the point representing the current mouse position is stored in the <kbd>mouse_down_at</kbd> field of the model, and when it is released, it is stored in the <kbd>mouse_up_at</kbd> field of the model.</p>
<p>These fields are defined in the model<span> </span><span>in the following way</span><span>:</span></p>
<pre>    mouse_down_at: Option&lt;Point2&gt;,<br/>    mouse_up_at: Option&lt;Point2&gt;,</pre>
<p>Their value is initialized to <kbd>None</kbd> and is <span>only</span><span> </span><span>set to a</span> <kbd>Point2</kbd> <span>value by the preceding code; it is reset to</span> <kbd>None</kbd> <span>as soon as these events are processed by the</span> <kbd>update</kbd> <span>method. So, each mouse event is only processed once.</span></p>
<h2 id="uuid-0cdf289c-134d-4cc1-b4f7-2e693a7e0cdd">Other fields of the model</h2>
<p>In addition to the fields that we have already described, the model has the following other fields:</p>
<pre>start_time: Option&lt;Duration&gt;,<br/>active_mole_column: usize,<br/>active_mole_row: usize,<br/>active_mole_position: f32,<br/>n_hit_moles: u32,<br/>random_generator: ThreadRng,<br/>start_button: Button,</pre>
<p>The <kbd>start_time</kbd> field <span>is used to show the current remaining time during the game and to show the <span class="packt_screen">Game finished</span></span><span> </span><span>text</span><span> when the game ends. It </span><span>is initialized to</span> <kbd>None</kbd><span>, and then any time the</span> <span class="packt_screen">Start</span><span> button is pressed, the current time is stored in it.</span></p>
<p>The moles do not appear in totally random positions. The lawn is covertly organized into three rows and five columns. A mole appears in 1 of these 15 positions, chosen at <span>random. The <kbd>active_mole_column</kbd> and <kbd>active_mole_row</kbd> fields contain the zero-based column and the row of the currently displayed mole.</span></p>
<p><span>The <kbd>active_mole_position</kbd> field contains the fraction of the appearance of the current mole. A <kbd>0</kbd> value means that the mole is totally hidden. A value of <kbd>1</kbd> means that the image of the mole (representing a part of its body) has completely appeared. </span>The <kbd>n_hit_moles</kbd> field counts how many moles have been hit.</p>
<p>The <kbd>random_generator</kbd> field is a pseudo-random number generator used to generate the position of the next mole to show. Finally, <kbd>start_button</kbd> is a field representing the <span class="packt_screen">Start</span> button. However, its type is not defined in a library. It is defined in this application, as we are going to explain.</p>
<h2 id="uuid-4bec9fcb-09ac-43a0-a048-d6df2073b448">Defining a widget</h2>
<p>Business applications have windows full of small, interactive graphical elements, such as buttons and textboxes. These elements are usually named <strong>controls</strong> by Microsoft Windows documentation and <strong>widgets</strong> (from window objects) in Unix-like environments. Defining widgets using graphics primitives is a rather complex feat, so if you want to develop a business application, you should <span>probably</span><span> </span><span>use a library that defines a set of widgets.</span></p>
<p>Neither the Rust standard library nor the <kbd>ggez</kbd> framework defines widgets. However, if you need just a few very simple widgets, you can develop them yourself, such as the button we will develop for this project. Let's see how this is implemented.</p>
<p>First of all, there is a definition of the <kbd>Button</kbd> type that can be instantiated for any button you want to add to your window:</p>
<pre>struct Button {<br/>    base_image: Rc&lt;graphics::Image&gt;,<br/>    bounding_box: Rect,<br/>    drawable_text: graphics::Text,<br/>}</pre>
<p>Our button is just an image resized as we want with text centered on it. This image is the same for all the buttons, and so it <span>should be shared throughout the program t</span>o save memory. This is why the <kbd>base_image</kbd> field is a reference-counted pointer to an image.</p>
<p>The <kbd>bounding_box</kbd> field indicates the desired position and size of the button. The image will be stretched or shrunk to fit this size. The <kbd>drawable_text</kbd> field is a text shape that will be drawn over the image of the button as its caption. The <kbd>Button</kbd> type implements several methods:</p>
<ul>
<li><kbd>new</kbd> to create a new button</li>
<li><kbd>contains</kbd> to check whether a given point is inside the button</li>
<li><kbd>draw</kbd> to display itself in the specified context</li>
</ul>
<p>The <kbd>new</kbd> method has many arguments:</p>
<pre>fn new(<br/>    ctx: &amp;mut Context,<br/>    caption: &amp;str,<br/>    center: Point2,<br/>    font: Font,<br/>    base_image: Rc&lt;graphics::Image&gt;,<br/>) -&gt; Self {</pre>
<p>The <kbd>caption</kbd> argument is the text to display inside the button. The <kbd>center</kbd> argument is the desired position of the center of the button. The <kbd>font</kbd> and <kbd>base_image</kbd> <span>arguments </span>are the font and image to use.</p>
<p>To create our button, the following expression is used:</p>
<pre>start_button: Button::new(<br/>    ctx,<br/>    "Start",<br/>    Point2::new(600., 40.),<br/>    font,<br/>    button_image.clone(),<br/>),</pre>
<p>It specifies <kbd>"Start"</kbd> as the caption, a width of <kbd>600</kbd> pixels, and a height of <kbd>40</kbd> pixels.</p>
<p>To draw the button, first, we check whether the main mouse button is currently pressed using this expression:</p>
<pre>mouse::button_pressed(ctx, MouseButton::Left)</pre>
<p>By doing this, it is possible to make the button appear like it is being pressed to give visual feedback of the button's operation. Then, we check whether the mouse cursor is inside the button using this expression:</p>
<pre>rect.contains(mouse::position(ctx))</pre>
<p>This turns the color of the button caption red when the mouse hovers over the button to show the user that the button can be clicked on. So, we have now looked at the most interesting parts of this project, which ends our look into the <kbd>ggez</kbd> framework.</p>
<h1 id="uuid-52df2cb4-930e-43f8-8529-d18be1a21cb3" class="mce-root">Summary</h1>
<p class="mce-root">We have seen how to build two-dimensional games for the desktop using the <kbd>ggez</kbd> framework. This framework not only allows us to structure the application according to the animation-loop architecture and the MVC architectural pattern but also to get discrete input events. In addition, we have seen why a linear algebra library can be useful for graphical applications.</p>
<p class="mce-root">We created and looked at four apps—<kbd>gg_ski</kbd>, <kbd>gg_silent_slalom</kbd>, <kbd><span>gg_</span>assets_slalom</kbd>, and <kbd><span>gg_whac</span></kbd>.</p>
<p>In particular, we learned h<span>ow to build a graphical desktop app using the</span> <kbd>ggez</kbd><span> framework, which is structured according to the MVC architecture, and </span><span>how to implement both an animation-loop </span><span>architecture </span><span>and an event-driven architecture, possibly in the same window. Additionally, we also learned to </span><span>draw graphical elements on a web page using</span><span> </span><kbd>ggez</kbd>, as well as <span>loading and using static resources using</span> <kbd>ggez</kbd><span>. At the end of the chapter, we </span><span>encapsulated two-dimensional points and vectors in a structure and saw how to manipulate them using the</span> <kbd>nalgebra</kbd> <span>library.</span></p>
<p class="mce-root">In the next chapter, we will look at a completely different technology: parsing. Parsing text files is useful for many purposes, in particular for interpreting or compiling a source code program. We will take a look at the <kbd>nom</kbd> library, which makes parsing tasks easier.</p>
<h1 id="uuid-6fc36164-3542-430d-b497-79a545fa5b68" class="mce-root">Questions</h1>
<ol>
<li class="mce-root">What is the difference between a vector and a point in linear algebra?</li>
<li class="mce-root">What are the geometrical concepts corresponding to <span>algebraic</span> vectors and points?</li>
<li class="mce-root">Why can capturing events be useful, even in an animation loop-oriented application?</li>
<li>Why can loading synchronous assets be a good idea in a desktop game?</li>
<li>How does <kbd>ggez</kbd> get input from the keyboard and mouse?</li>
<li>What are the meshes used in the <kbd>ggez</kbd> framework?</li>
</ol>
<ol start="7">
<li>How can you build a <kbd>ggez</kbd> mesh?</li>
<li>How do you obtain a desired animation frame rate using <kbd>ggez</kbd>?</li>
<li>How do you draw a mesh in the desired position using <kbd>ggez</kbd>, with the desired scale and rotation values?</li>
<li>How do you play sound using <kbd>ggez</kbd>? </li>
</ol>
<h1 id="uuid-e9f1325d-a747-4be1-bf0c-5cfb3cfbf0e5" class="mce-root">Further reading</h1>
<p class="mce-root">The <kbd>ggez</kbd> project can be downloaded from <a href="https://github.com/ggez/ggez">https://github.com/ggez/ggez</a>. This repository contains many example projects, including a complete asteroid arcade game.</p>


            </article>

            
        </section>
    </body></html>