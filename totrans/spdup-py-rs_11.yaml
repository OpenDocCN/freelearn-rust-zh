- en: '*Chapter 11*: Best Practices for Integrating Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17720_10__Final_SK_ePub.xhtml#_idTextAnchor182), *Injecting
    Rust into a Python Flask App*, we managed to fuse our Rust code with a Python
    web application. In this final chapter, we will wrap up what we have covered in
    the book with best practices. These practices are not essential to fuse Rust with
    Python; however, they will help us in avoiding pitfalls when building bigger packages
    in Rust. When it comes to best practices, we can Google search the topic *SOLID
    principles*, which will give us loads of free information on how to keep code
    generally clean. But instead of regurgitating these principles, we will cover
    concepts that are specific to using Rust and Python together. We will learn how
    to keep the Rust/Python implementation as simple as possible if the requirements
    are not too demanding. We will also understand what Python and Rust excel in when
    it comes to computational tasks and Python interfaces. We then investigate traits
    in Rust and how they can help us organize and structure our structs. Finally,
    we look into keeping it simple when we want data parallelism with the Rayon crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping our Rust implementation simple by piping data to and from Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving the interface a native feel with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using traits as opposed to objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping data-parallelism simple with Rayon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering these topics will enable us to avoid pitfalls when building bigger
    packages that are more complex. We will also be able to build Rust solutions for
    smaller projects faster as we will learn that we do not have to rely on Python
    setup tools and installation with `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and data for this chapter can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_eleven)'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping our Rust implementation simple by piping data to and from Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered everything we need to integrate Rust into our Python system.
    We can build Rust packages that can be installed using `pip` and use them in Docker
    when integrating with a web application. However, reaching for a setup tool can
    be too much effort if the problem being solved is small and simple. For instance,
    if in a situation we were merely opening a **comma-separated values** (**CSV**)
    file full of numbers in Python, calculating the Fibonacci numbers, and then writing
    them in another file, then it would make sense to just write the program in Rust.
    However, we do not start building a Rust package with Python setup tools if we
    have a more complicated Python standalone script that just needs a simple speedup
    with Rust—it is still just a standalone script. Instead, we pipe data. This means
    we pass data from a Python script to a Rust standalone binary and back to a Python
    script for computing Fibonacci numbers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.01_B17720.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Process of a basic pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the same speed as the Rust Fibonacci calculation package without
    having to use any setup tools, we must carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a Python script that formulates the numbers for calculation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Rust file that accepts the numbers, calculates the Fibonacci numbers,
    and returns the calculated numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build another Python script that accepts the calculated numbers and prints them
    out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we will be able to have a simple pipeline. While each file is isolated
    and we can build in any order, it makes sense to start with *Step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Python script that formulates the numbers for calculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we will just hardcode the input numbers that we are passing
    into our pipeline, but nothing is stopping you from reading your data from files
    or taking in numbers from command-line arguments. In our `input.py` file, we can
    write to `stdout` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, if we run this script with the Python interpreter, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can now move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Rust file that accepts the numbers, calculates the Fibonacci numbers,
    and returns the calculated numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our Rust file, we must have everything contained in the file to keep it
    as simple as possible. We can span it over multiple files if needed, but for a
    simple calculation, keeping it all in one file is good enough. In our `fib.rs`
    file, we initially import what we need and define our Fibonacci function with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is nothing new; we are merely going to use `std::io`
    to get the numbers piped into the file, and then calculate the Fibonacci number,
    sending it to the next file in the pipeline with the following `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we define `stdin` to receive the numbers sent to the
    Rust program, and `stdout` to send out the calculated Fibonacci numbers. We then
    loop through the lines sent into the Rust program and then parse each line at
    an integer. We then calculate the Fibonacci number and then send it using the
    macro that we imported with the `io` prelude. With this, we can now compile our
    Rust file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile our Rust file. We can now run both files, piping the data
    from the Python file to the compiled Rust code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the numbers from the `python input.py` command get piped
    into the Rust code returning the calculated Fibonacci numbers. With this, we can
    now move on to the final step, where we get the calculated Fibonacci numbers from
    the Rust code and print them out.
  prefs: []
  type: TYPE_NORMAL
- en: Building another Python script that accepts the calculated numbers and prints
    them out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `output.py` file is very straightforward. It takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a `try` block because the start and the end of the data passed into
    the last Python script will have empty lines, and they will fail when we try to
    convert them into integers. We then print out the data with `"receiving: {processed_number}"`
    added to the last script to make it clear that it is the `output.py` file printing
    out the numbers. This gives us the printout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time how long it takes for the pipeline to run using the `time` command.
    If we compare this to pure Python with the example numbers that we have used,
    pure Python will be faster. However, we know that Rust is much faster than pure
    Python code. Because the `pure_python.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the same numbers to the pipeline gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that our pipeline is much faster. The gap between Rust and
    pure Python will just get larger as the numbers increase and become more numerous.
    We can see here that this is a lot easier with fewer moving parts. If our program
    is simple, then we keep the construction and use of Rust simple.
  prefs: []
  type: TYPE_NORMAL
- en: Giving the interface a native feel with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is an object-oriented language. When we are building our Rust packages,
    we need to keep the friction of adoption low. The adoption of Rust packages would
    be better if we keep our interfaces as objects. Most Python packages have object
    interfaces. Calculations are done with inputs, and the Python object has a range
    of functions and attributes that give us the results of those calculations. While
    we did cover creating classes in Rust with `pyo3` macros in [*Chapter 6*](B17720_06_Final_SK_ePub.xhtml#_idTextAnchor100),
    *Working with Python Objects in Rust*, in the *Constructing our custom Python
    objects in Rust* section, it is advised that we understand the pros and cons of
    doing this. We remember that classes written in Rust are faster. However, the
    freedom of inheritance and metaclassing with pure Python is useful. As a result,
    it is best to leave the construction and organization of the object interface
    in pure Python. Any calculations that need to be done can be done in Rust. To
    demonstrate this, we can use the simple physics example of a particle''s **two-dimensional**
    (**2D**) trajectory, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Simple 2D physics trajectory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.02_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Simple 2D physics trajectory
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that the initial velocity is denoted as *V0*. The projection
    on the *x* axis is denoted by *Vx*, and the projection on the *y* axis is denoted
    by *Vy*. The dashed line is the particle at every point in time. Time here is
    another dimension. Our equations for each position in time and the endpoint in
    time (when it hits the ground) are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17720_11_001.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B17720_11_002.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B17720_11_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *g* is the constant for gravity. We also want to know the position of
    the particle at a certain point in time. We do this by calculating the last point
    in time, then looping through all the time points between zero and the last point
    in time, calculating the `x` and `y` coordinates. All we would need is the initial
    velocity in `x` and `y`. The loop through with the position calculations would
    all be done in Rust. The dictionary where all the keys are all the times and all
    the values are tuples of `x` and `y` is housed in the Python object. We could
    write one function that processes all the times and returns a dictionary in Rust
    called `calculate_coordinates`. Using it in our Python class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The user would just have to import the `Particle` object, initialize it with
    the initial velocity in the `x` and `y` coordinates, and then input times to get
    the coordinates. To plot all the positions for a particle, we would use our class
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This is intuitive to Python. We have kept all our number crunching in Rust to
    get that speed, but we have managed to keep all of our interfaces, including accessing
    times and positions in Python. As a result, a developer using this package would
    not know that it is written in Rust—they would just appreciate that it is fast.
    We can drive home the benefits of keeping the formation and access to data 100%
    in Python while doing all the calculations in Rust with metaclassing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our particle system, we could load a lot of data for the initial velocities
    of particles. As a result, our system would calculate the trajectories for a range
    of particles that we load. However, if we load two particles with the same initial
    velocities, they will both have the same trajectories. Considering this, it would
    not make sense for us to calculate the trajectory for both particles. To avoid
    this, we do not need to store anything in a file or database for reference; we
    just need to implement a flyweight design pattern. This is where we check the
    parameters passed into the object. If they are the same as the previous instance,
    we just return the previous instance. The flyweight pattern is defined with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we combine the initial velocities to define a key, and
    then check to see if there is already an instance with these velocities. If there
    is, we return the instance from our `_instances` dictionary. If not, we create
    a new instance and insert it into our `_instances` dictionary. Our particles will
    then take the form of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, our particles will now adhere to the flyweight pattern. We can test this
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this will give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the two particles that have the same initial velocities
    have the same memory address, so it works.
  prefs: []
  type: TYPE_NORMAL
- en: We can initialize these particles anywhere and this design pattern will apply,
    ensuring that we do not perform duplicate calculations. Considering that we are
    writing Python extensions in Rust, the flyweight pattern really shows us how much
    control we get with how the interface is called, used, and displayed. Even though
    we have built our interfaces in Python, this does not mean that we do not have
    to structure our Rust code. This brings us on to the next section, in which we
    discuss how to lean into traits as opposed to objects when it comes to structuring
    our Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Using traits as opposed to objects
  prefs: []
  type: TYPE_NORMAL
- en: 'As a Python developer, it is tempting to build structs that inherit via the
    composition of other structs. **Object-oriented programming** (**OOP**) is well
    supported in Python; however, there are many reasons why Rust is favored, and
    one of them is traits. As seen in the following screenshot, traits enable us to
    separate data from behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Difference between traits and objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.03_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Difference between traits and objects
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a lot of flexibility as the data and behavior are decoupled,
    enabling us to slot behavior in and out of structs as we need. Structs can have
    a portfolio of traits without giving us disadvantages arising from multiple inheritance.
    To demonstrate this, we are going to create a basic doctor, patient, nurse program
    so that we can see how different structs can have different traits, allowing them
    to move through functions. We are going to see how traits affect the way we lay
    out code over multiple files. Our program will have the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'With this structure, the flow of our code will take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_11.04_B17720.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Code flow of a simple trait-based program
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can see that our code is decoupled. Our traits go into all the
    other files to define the behavior of those files. To build this program, we must
    carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining traits—building traits for our structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining struct behavior with traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing traits through functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing structs with common traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our program in the `main.rs` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we can start by defining our traits in the first subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Defining traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start defining traits, we must conceptualize the types of people
    in our program that we are defining behavior for. They are laid out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Patient**: This person does not have any clinical skills, but actions are
    performed on them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nurse**: This person has clinical skills but cannot prescribe or diagnose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nurse practitioner**: This person has clinical skills and can prescribe but
    cannot diagnose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced nurse practitioner**: This person has clinical skills and can prescribe
    and diagnose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Doctor**: This person has clinical skills and can prescribe and diagnose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we can see here is that they are all humans. Therefore, they are all able
    to speak and introduce themselves. So, in our `traits.rs` file, we can create
    a `Speak` trait with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'If a struct implements this trait, it will have to create its own `introduce`
    function with the same return and input parameters. We can also see that everyone
    apart from the patient has clinical skills. To accommodate this, we can implement
    a clinical skills trait with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have defined the most common attributes for each clinician.
    Only two people—the doctor and the advanced nurse practitioner—can diagnose and
    prescribe. However, all of them can administer medication. We can implement this
    trait for all clinicians and then overwrite specifics. We must note that because
    the doctor and advanced nurse practitioner have the same possibilities in terms
    of diagnosing and prescribing, we can create another trait for this to prevent
    repeating ourselves, and a trait for the patient with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: We have now defined all the traits that we need. We can start using them to
    define our people in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Defining struct behavior with traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we define any structs, we must import our traits into our `people.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have all our traits, so we can define our people in the program with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Sadly, there is some repetition here. This is also going to happen with our
    `Speak` trait; however, it is important to keep these structs separate as we will
    slot traits into them later, so we need them to be decoupled. We can implement
    our `Speak` trait for each person with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'We can continue this pattern and implement `Speak` traits for all the people
    structs. Now this is done, we can implement our clinical skills and patient role
    traits for our people with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that our people structs have the following traits:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Patient` struct has the standard `PatientRole` trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Nurse` struct has the standard `ClinicalSkills` trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NursePractitioner` struct has the standard `ClinicialSkills` trait with
    the `can_prescribe` function overwritten to return `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have our clinical skills applied to our standard clinicians, we
    can now apply our advanced traits with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Here, we apply the `AdvancedMedical` trait to our `Doctor` and `AdvancedNursePractitioner`
    structs. However, we know that these structs are also clinicians. We need them
    to have clinical skills. Therefore, we implement `ClinicalSkills` for the `AdvancedMedical`
    trait. We then overwrite the `can_prescribe` and `can_diagnose` functions to `true`.
    Therefore, doctors and advanced nurse practitioners have both `ClinicalSkills`
    and `AdvancedMedical` traits and can diagnose and prescribe. With this, our people
    structs are ready to be passed into functions. We will do this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Passing traits through functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform actions such as updating a database or sending data to a server,
    we are going to pass our people structs through functions where clinicians can
    act on patients. To do this, we must import our traits in our `actions.rs` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first action is to admit a patient. This can be done by anyone with clinical
    skills. Considering this, we can define this action with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that our clinician being passed in is anything with a `ClinicalSkills`
    trait, which means all our clinician structs. However, it must be noted that we
    are also passing in `&Box<dyn PatientRole>` for the patient. This is because we
    will be using a patient list when passing in patients. We can have multiple patients
    assigned to a clinician. We will explore why we are using `&Box<dyn PatientRole>`
    in the next subsection when we define our patient list struct. The next action
    is to diagnose a patient, which is defined with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, it makes sense to have the `AdvancedMedical` trait to diagnose. If we
    try to pass in a `Nurse` or `NursePractitioner` struct, the program will fail
    to compile due to mismatching traits. We can then have a prescribe medication
    action, which takes the form of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `ClinicalSkills` trait is accepted but the code will
    throw an error if the clinician cannot prescribe. This is because our `NursePractitioner`
    struct can prescribe. We could also make a third intermediate trait and apply
    it to doctor, advanced, and normal nurse practitioners. However, this is just
    one check as opposed to implementing a new trait for all three clinician structs.
    Our last action is that of administering medication and discharging the patient,
    which can be done by all our clinician structs; therefore, it takes the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: We can now pass our people structs through a range of actions, with our compiler
    refusing to compile if we pass through the wrong person struct into the function.
    In the next subsection, we will be storing structs with traits in a patient list.
  prefs: []
  type: TYPE_NORMAL
- en: Storing structs with common traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to a patient list, it is tempting to just store patient structs
    in a vector. However, this does not give us much flexibility. For instance, let''s
    say that our system is deployed, and one of the nurses in the hospital is sick
    and must be admitted. We could allow this by implementing the `PatientRole` trait
    to the `Nurse` struct without having to rewrite anything else. We might also need
    to expand the different types of patients, adding more structs such as `ShortStayPatient`,
    or `CriticallySickPatient`. Because of this, we store our patients with the `PatientRole`
    trait in our `objects.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: We must wrap our structs in a box because we do not know the size at compile
    time. Different structs of different sizes can implement the same trait. A `Box`
    is a pointer on the heap memory. Because we know the size of pointers, we know
    the size of memory being added to the vector at compile time. The `dyn` keyword
    is used to define that it is a trait that we are referring to. Managing to access
    the struct directly in the `patients` vector is not going to happen, as again,
    we do not know the size of the struct. Therefore, we access the data of the struct
    via the `get_name` function in the `PatientRole` trait in our action functions.
    Traits are also pointers. We can still build functions such as constructors for
    our struct. However, when it comes to our `Patient` struct being passed through
    an action function that we created, our `PatientRole` trait acts as an interface
    between our `Patient` struct and our `admit_function` function. We now have everything
    we need, so we can move on to our next subsection to put it all together and run
    it in our `main.rs` file.
  prefs: []
  type: TYPE_NORMAL
- en: Running our traits in the main file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running all our code together is straightforward and safe. Here''s what we
    need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import all we need in our `main.rs` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `main` function, we can now define the two nurses and doctors for our
    clinic for the day with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then get our patient list, and it turns out that the four horsemen have
    turned up for their treatment, as seen in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then loop through our patients, getting our doctors and nurses to care for
    them with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the end of our `main` function. Running it would give us the following
    printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have finished our exercise in using traits in Rust. Hopefully,
    with this, you see the flexibility and decoupling we get when we use traits. However,
    we must remember that this approach cannot be supported if we were to build an
    interface with our Python system. If we were to build an interface, this could
    be done with the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we swapped the functions in the `ClinicalSkills` trait
    for attributes. We would be able to pass our `NurseClass` struct with traits into
    a function which calls the `ClinicalSkills` functions. The results from the `ClinicalSkills`
    functions can then be passed into the constructor for our `NurseClass` struct.
    Our `NurseClass` struct can then be passed out to our Python system.
  prefs: []
  type: TYPE_NORMAL
- en: OOP has its merits and should be used when coding in Python. However, Rust has
    given us a new approach that is flexible and decoupled. It may take a while to
    get your head around traits, however, they are worth it. It's advised that you
    keep working with traits in your Rust code to get the advantages of using traits.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping data-parallelism simple with Rayon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B17720_03_Final_SK_ePub.xhtml#_idTextAnchor046), *Understanding
    Concurrency* we processed our Fibonacci numbers in parallel. While it was interesting
    to look into concurrency, when we are building our own applications, we should
    lean on other crates to reduce the complexity of our application. This is where
    the `rayon` crate comes in. This will enable us to loop through numbers to be
    calculated and process them in parallel. In order to do this, we initially have
    to define the crate in the `Cargo.toml` file as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if we do not import the macros with `use rayon::prelude::*;` our compiler
    will refuse to compile when we try and turn a standard vector into a parallel
    iterator. With these macros, we can execute parallel Fibonacci calculations with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, we can see that we define a standard Fibonacci number function.
    We then get a vector of input numbers and convert it into a parallel iterator
    with the `into_par_iter` function. We then map our Fibonacci function to this
    parallel iterator. After this, we collect the results. Therefore, printing `numbers`
    will give us `[8, 13, 21, 34, 55]`. And that''s it! We have coded parallel code,
    and we have kept it simple with the `rayon` crate. However, we must remember that
    there is a cost to set up this parallelization. If we were only going to use the
    numbers in the example, a normal loop would be faster. However, if the numbers
    and size of the array increase, the benefits of `rayon` start to show. For instance,
    if we were to have a vector of numbers to be calculated ranging from 6 to 33,
    we will get the time difference as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Time taken for a loop 6 -> 33 Fib numbers to be taken in microseconds'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.05_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Time taken for a loop 6 -> 33 Fib numbers to be taken in microseconds
  prefs: []
  type: TYPE_NORMAL
- en: '[left = Rayon right = normal loop]'
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have a simple approach to parallelizing our calculations which
    will keep our complexity and mistakes down.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we went over best practices for implementing Rust in our Python
    systems. We initially started by keeping it simple. We saw that we could leverage
    the speed of Rust without any setup tools or installing a package thanks to piping
    data to and from our Rust binary with Python. This is a useful technique to have
    and is not just limited to Python and Rust. In fact, you can pipe data between
    any language.
  prefs: []
  type: TYPE_NORMAL
- en: If you are writing a basic program, then data piping should be the first thing
    you should do. This way, you reduce the number of moving parts and speed up development.
    A simple Bash script could compile the Rust file and run the process. However,
    as the program complexity increases, you can go for setup tools and import your
    Rust code directly into your Python code, utilizing what you covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to the importance of leveraging Python's object support with
    a metaclass to lean on Python for our interfaces without Rust packages. Python
    is a mature language that is very expressive. It makes sense to use the best of
    Python and the best of Rust when building our packages by using Python for the
    interfaces and Rust for the calculations. We finally covered how to utilize traits
    as opposed to forcing Rust to have an object-orientated approach with inheritance
    via composition. The result is more decoupling and flexibility. Finally, we kept
    our parallel processing code simple with third-party crates which will increase
    our productivity and reduce the complexity of our code, and in turn, reduce mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: We have now come to the end of the book. There is always more to learn; however,
    you now have a full tool belt. You not only have a handle on the fastest memory-safe
    language that is cutting-edge, but you can also fuse it with the widely used Python
    language in an efficient way, installing it with `pip`. Not only can you do this
    for Python scripts, but you can also wrap up Rust extensions in Docker, enabling
    you to use Rust in Python web applications. Therefore, you do not have to wait
    for your company and projects to rewrite and adopt Rust. Instead, you can plug
    Rust into an already established project tomorrow. I am nothing short of excited
    about what you will do with this in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Object-Oriented Python* by *Steven Lott* (2019) (*Packt Publishing*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Rust* by *Rahul Sharma*, *Vesa Kaihlavirta* (2018) (*Packt Publishing*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
