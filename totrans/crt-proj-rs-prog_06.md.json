["```rs\ncargo run --release\n```", "```rs\ncargo web start --release\n```", "```rs\nconst SCREEN_WIDTH: f32 = 800.;\nconst SCREEN_HEIGHT: f32 = 600.;\nconst SKI_WIDTH: f32 = 10.;\nconst SKI_LENGTH: f32 = 50.;\nconst SKI_TIP_LEN: f32 = 20.;\nconst STEERING_SPEED: f32 = 3.5;\nconst MAX_ANGLE: f32 = 75.;\n```", "```rs\nstruct Screen {\n    ski_across_offset: f32,\n    direction: f32,\n}\n```", "```rs\nOk(Screen {\n    ski_across_offset: 0.,\n    direction: 0.,\n})\n```", "```rs\nif window.keyboard()[Key::Right].is_down() {\n    self.steer(1.);\n}\nif window.keyboard()[Key::Left].is_down() {\n    self.steer(-1.);\n}\nOk(())\n```", "```rs\nself.direction += STEERING_SPEED * side;\nif self.direction > MAX_ANGLE {\n    self.direction = MAX_ANGLE;\n}\nelse if self.direction < -MAX_ANGLE {\n    self.direction = -MAX_ANGLE;\n}\n```", "```rs\nwindow.clear(Color::WHITE)?;\n```", "```rs\nwindow.draw_ex(&Rectangle::new((\n    SCREEN_WIDTH / 2\\. + self.ski_across_offset - SKI_WIDTH / 2.,\n    SCREEN_HEIGHT * 15\\. / 16\\. - SKI_LENGTH / 2.),\n    (SKI_WIDTH, SKI_LENGTH)),\n    Background::Col(Color::PURPLE),\n    Transform::translate(Vector::new(0, - SKI_LENGTH / 2\\. - SKI_TIP_LEN)) *\n        Transform::rotate(self.direction) *\n        Transform::translate(Vector::new(0, SKI_LENGTH / 2\\. \n         + SKI_TIP_LEN)),\n    0);\n```", "```rs\nrun::<Screen>(\"Ski\",\n    Vector::new(SCREEN_WIDTH, SCREEN_HEIGHT), Settings {\n        draw_rate: 40.,\n        update_rate: 40.,\n        ..Settings::default()\n    }\n);\n```", "```rs\nconst N_GATES_IN_SCREEN: usize = 3;\nconst GATE_POLE_RADIUS: f32 = 4.;\nconst GATE_WIDTH: f32 = 150.;\nconst SKI_MARGIN: f32 = 12.;\nconst ALONG_ACCELERATION: f32 = 0.06;\nconst DRAG_FACTOR: f32 = 0.02;\nconst TOTAL_N_GATES: usize = 8;\n```", "```rs\nenum Mode {\n    Ready,\n    Running,\n    Finished,\n    Failed,\n}\n```", "```rs\ngates: Vec<(f32, f32)>,\nforward_speed: f32,\ngates_along_offset: f32,\nmode: Mode,\nentered_gate: bool,\ndisappeared_gates: usize,\n```", "```rs\nfn get_random_gate(gate_is_at_right: bool) -> (f32, f32) {\n    let mut rng = thread_rng();\n    let pole_pos = rng.gen_range(-GATE_WIDTH / 2., SCREEN_WIDTH / 2\\. -\n        GATE_WIDTH * 1.5);\n    if gate_is_at_right {\n        (pole_pos, pole_pos + GATE_WIDTH)\n    } else {\n        (-pole_pos - GATE_WIDTH, -pole_pos)\n    }\n}\n```", "```rs\nmatch self.mode {\n    Mode::Ready => {\n        if window.keyboard()[Key::Space].is_down() {\n            self.mode = Mode::Running;\n        }\n    }\n```", "```rs\nMode::Running => {\n    let angle = deg_to_rad(self.direction);\n    self.forward_speed +=\n        ALONG_ACCELERATION * angle.cos() - DRAG_FACTOR \n         * self.forward_speed;\n    let along_speed = self.forward_speed * angle.cos();\n    self.ski_across_offset += self.forward_speed * angle.sin();\n```", "```rs\nif self.ski_across_offset < -SCREEN_WIDTH / 2\\. + SKI_MARGIN {\n    self.ski_across_offset = -SCREEN_WIDTH / 2\\. + SKI_MARGIN;\n}\nif self.ski_across_offset > SCREEN_WIDTH / 2\\. - SKI_MARGIN {\n    self.ski_across_offset = SCREEN_WIDTH / 2\\. - SKI_MARGIN;\n}\n```", "```rs\nself.gates_along_offset += along_speed;\nlet max_gates_along_offset = SCREEN_HEIGHT / N_GATES_IN_SCREEN as f32;\nif self.gates_along_offset > max_gates_along_offset {\n    self.gates_along_offset -= max_gates_along_offset;\n    self.disappeared_gates += 1;\n}\n```", "```rs\nlet ski_tip_along = SCREEN_HEIGHT * 15\\. / 16\\. - SKI_LENGTH / 2\\. - SKI_TIP_LEN;\nlet ski_tip_across = SCREEN_WIDTH / 2\\. + self.ski_across_offset;\nlet n_next_gate = self.disappeared_gates;\nlet next_gate = &self.gates[n_next_gate];\nlet left_pole_offset = SCREEN_WIDTH / 2\\. + next_gate.0 + GATE_POLE_RADIUS;\nlet right_pole_offset = SCREEN_WIDTH / 2\\. + next_gate.1 - GATE_POLE_RADIUS;\nlet next_gate_along = self.gates_along_offset + SCREEN_HEIGHT\n    - SCREEN_HEIGHT / N_GATES_IN_SCREEN as f32;\n```", "```rs\nif ski_tip_along <= next_gate_along {\n    if !self.entered_gate {\n        if ski_tip_across < left_pole_offset || \n         ski_tip_across > right_pole_offset {\n            self.mode = Mode::Failed;\n        } else if self.disappeared_gates == TOTAL_N_GATES - 1 {\n            self.mode = Mode::Finished;\n        }\n        self.entered_gate = true;\n    }\n} else {\n    self.entered_gate = false;\n}\n```", "```rs\nMode::Failed | Mode::Finished => {\n    if window.keyboard()[Key::R].is_down() {\n        *self = Screen::new().unwrap();\n    }\n}\n```", "```rs\nfor i_gate in self.disappeared_gates..self.disappeared_gates + N_GATES_IN_SCREEN {\n    if i_gate >= TOTAL_N_GATES {\n        break;\n    }\n```", "```rs\nlet pole_color = Background::Col(if i_gate == TOTAL_N_GATES - 1 {\n    Color::GREEN\n} else {\n    Color::BLUE\n});\n```", "```rs\nlet gates_along_pos = self.gates_along_offset\n    + SCREEN_HEIGHT / N_GATES_IN_SCREEN as f32\n        * (self.disappeared_gates + N_GATES_IN_SCREEN - 1 - i_gate) as f32;\n```", "```rs\nwindow.draw(\n    &Circle::new(\n        (SCREEN_WIDTH / 2\\. + gate.0, gates_along_pos),\n        GATE_POLE_RADIUS,\n    ),\n    pole_color,\n);\n```", "```rs\nconst MIN_TIME_DURATION: f64 = 0.1;\n```", "```rs\nelapsed_sec: f64,\nelapsed_shown_sec: f64,\nfont_style: FontStyle,\nfont: Asset<Font>,\nwhoosh_sound: Asset<Sound>,\nbump_sound: Asset<Sound>,\nclick_sound: Asset<Sound>,\ntwo_notes_sound: Asset<Sound>,\n```", "```rs\nfn play_sound(sound: &mut Asset<Sound>, volume: f32) {\n    let _ = sound.execute(|sound| {\n        sound.set_volume(volume);\n        let _ = sound.play();\n        Ok(())\n    });\n}\n```", "```rs\nplay_sound(&mut self.whoosh_sound, self.forward_speed * 0.1);\n\n```", "```rs\nelapsed_sec: 0.,\nelapsed_shown_sec: 0.,\nfont_style: FontStyle::new(16.0, Color::BLACK),\nfont: Asset::new(Font::load(\"font.ttf\")),\nwhoosh_sound: Asset::new(Sound::load(\"whoosh.ogg\")),\nbump_sound: Asset::new(Sound::load(\"bump.ogg\")),\nclick_sound: Asset::new(Sound::load(\"click.ogg\")),\ntwo_notes_sound: Asset::new(Sound::load(\"two_notes.ogg\")),\n```", "```rs\nplay_sound(&mut self.click_sound, 1.)\n```", "```rs\nself.elapsed_sec += window.update_rate() / 1000.;\nif self.elapsed_sec - self.elapsed_shown_sec >= MIN_TIME_DURATION {\n    self.elapsed_shown_sec = self.elapsed_sec;\n}\n```", "```rs\nlet elapsed_shown_text = format!(\n    \"Elapsed time: {:.2} s,\\n\\\n     Speed: {:.2} pixel/s,\\n\\\n     Remaining gates: {}\\n\\\n     Use Left and Right arrow keys to change direction.\\n\\\n     {}\",\n    self.elapsed_shown_sec,\n    self.forward_speed * 1000f32 / window.update_rate() as f32,\n    TOTAL_N_GATES - self.disappeared_gates - if self.entered_gate { 1 } else { 0 },\n    match self.mode {\n        Mode::Ready => \"Press Space to start.\",\n        Mode::Running => \"\",\n        Mode::Finished => \"Finished: Press R to reset.\",\n        Mode::Failed => \"Failed: Press R to reset.\",\n    }\n);\n```", "```rs\nlet style = self.font_style;\nself.font.execute(|font| {\n    let image = font.render(&elapsed_shown_text, &style).unwrap();\n    window.draw(&image.area(), Img(&image));\n    Ok(())\n})?;\n```"]