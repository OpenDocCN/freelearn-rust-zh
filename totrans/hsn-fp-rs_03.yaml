- en: Functional Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: Data structures are the second most basic building blocks of programming, following
    control flow. After early languages developed control flow structures, it quickly
    became apparent that simple variable labels were insufficient for developing complex
    programs. Data structures have evolved from the basic concept of a sized datum
    stored at an address to the concept of strings and arrays, followed by mixed structures,
    and finally collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是编程的第二个最基本构建块，仅次于控制流。在早期语言开发控制流结构之后，很快就很明显，简单的变量标签不足以开发复杂程序。数据结构已经从存储在地址上的固定大小数据的基本概念演变为字符串和数组，然后是混合结构，最后是集合。
- en: In this chapter, we will revisit the project introduced in [Chapter 2](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml), *Functional
    Control Flow*. The project requirements have expanded to accommodate feedback
    from the potential client. There are also specific performance targets that must
    be met due to competition from a rival developer. To help our business succeed,
    we must now improve the previous simulation and ensure that it meets customer
    demand and performance targets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾在[第2章](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml)中介绍的项目，即*函数式控制流*。由于潜在客户反馈，项目需求已经扩展以适应。由于竞争对手的开发，还必须满足特定的性能目标。为了帮助我们的业务成功，我们现在必须改进之前的模拟，并确保它满足客户需求和性能目标。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Adjusting to changing the scope of the project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应项目范围的变更
- en: Reformatting code to support multiple use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新格式化代码以支持多个用例
- en: Using appropriate data structures to gather, store, and process data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的数据结构来收集、存储和处理数据
- en: Organizing code into traits and data classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码组织到特性和数据类中
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要使用 Rust 的最新版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每章的 `README.md` 文件中也包含了具体的安装和构建说明。
- en: Adjusting to changing the scope of the project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应项目范围的变更
- en: You can't plan for everything. You also probably don't want to try to plan for
    everything. Flexible software development and emphasizing robust, logically independent
    components will reduce work when a requirement or dependency inevitably changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能为所有事情都做计划。你也可能不想尝试为所有事情都做计划。灵活的软件开发和强调健壮、逻辑上独立的组件，当需求或依赖不可避免地发生变化时，可以减少工作量。
- en: Gathering new project requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集新的项目需求
- en: 'After an initial demonstration, your team has received comments and feedback
    from the potential client. Watching the simulation, the elevator seems to often
    pass and go back up to floors before stopping. The client expressed concern that
    this would be not only inefficient, but also uncomfortable or irritable for passengers.
    To win the contract, the client wants to see improvements and evidence showing
    that:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步演示之后，您的团队收到了潜在客户的评论和反馈。观看模拟时，电梯似乎经常在停止前经过并返回楼层。客户表示担忧，这不仅效率低下，而且对乘客来说可能是不舒适或烦躁的。为了赢得合同，客户希望看到改进和证据，以证明：
- en: The ride is comfortable and reliably direct
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘坐体验舒适且可靠直接
- en: The ride moves efficiently from each source to each destination floor
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电梯从每个源头高效地移动到每个目标楼层
- en: Additionally, you have learned that a competitor has submitted a separate proposal.
    The competitor specifically claims that its elevator control system maintains
    acceleration within comfortable levels, velocity within safe bounds, and reaches
    destinations accurately within 20% of physical theoretical limits. No specific
    numbers were provided, and no simulation was demonstrated, but the client seemed
    very convinced, along with the assurance that the project will cost 10% less.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还了解到竞争对手提交了一份单独的提案。竞争对手具体声称其电梯控制系统保持加速度在舒适水平，速度在安全范围内，并在物理理论极限的20%内准确到达目的地。没有提供具体数字，也没有演示模拟，但客户似乎非常确信，并保证项目成本将降低10%。
- en: Architecting a change map from requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从需求构建变更图
- en: After receiving feedback and new expectations, we must convert these demands
    into a plan of action. The simulation needs to be updated and additional tools
    will need to be built. Let's review the new information and architect a solution
    to meet the new requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到反馈和新期望后，我们必须将这些需求转化为行动计划。需要更新模拟，并需要构建额外的工具。让我们回顾新信息，并设计一个解决方案以满足新的需求。
- en: Translating expectations into requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将期望转化为需求
- en: 'Reviewing the feedback, it is clear that there are two perspectives that need
    to be addressed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 审查反馈，很明显需要解决两个观点：
- en: A competitor has made specific claims that our company will need to outperform
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争对手提出了具体的主张，我们的公司需要超越
- en: The client has explicit expectations to address concerns from the first demonstration
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户对第一次演示中的担忧有明确的期望
- en: 'The specific claims from the competitor can be listed as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争对手的具体主张可以列出如下：
- en: Acceleration is within comfortable bounds
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度在舒适范围内
- en: Velocity is within safe bounds
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度在安全范围内
- en: Trip time from any floor to any other floor is within 20% of physical theoretical
    limits
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从任何楼层到任何其他楼层的行程时间在物理理论极限的20%以内
- en: The software is 10% cheaper
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该软件便宜10%
- en: We will delegate the price negotiation to our sales team, but otherwise we need
    to adjust our software to outperform the other three claims. If we can meet these
    requirements and provide adequate supporting evidence, then this should also address
    most of the client's explicit concerns.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把价格谈判委托给我们的销售团队，但除此之外，我们需要调整我们的软件以超越其他三个主张。如果我们能够满足这些要求并提供充分的证据，那么这也应该解决客户的大部分明确担忧。
- en: Additionally, the client was specifically concerned about the elevator passing
    the destination floor and needing to back up. We should address this behavior
    and confirm that it does not occur in simulations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，客户特别关注电梯通过目标楼层并需要倒退的行为。我们应该解决这个问题，并确认在模拟中不会发生这种行为。
- en: 'It is clear at this point that the previous motor control logic is inadequate.
    After brainstorming, your team develops two possible improvements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显之前的电机控制逻辑是不够的。在头脑风暴后，您的团队开发了两种可能的改进：
- en: Use a variable acceleration/deceleration calculation, rather than on/off adjustment
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可变加速度/减速度计算，而不是开/关调整
- en: Reduce the update interval to permit faster and, thus, more precise decisions
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少更新间隔以允许更快且更精确的决策
- en: Translating requirements into a change map
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将需求转化为变更图
- en: 'Given the various new requirements, it seems appropriate to split the previous
    simulation code into different libraries and executables. We will create a separate
    module for each of the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到各种新的要求，将之前的模拟代码拆分为不同的库和可执行文件似乎是合适的。我们将为以下每个创建一个单独的模块：
- en: A physics simulator
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个物理模拟器
- en: A motor control
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电机控制
- en: An executable to run the simulation for demonstration
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于演示模拟的可执行文件
- en: An executable to further analyze the simulation
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于进一步分析模拟的可执行文件
- en: The physics simulator should accept a generic motor controller and a measurement
    accumulator. The measurement accumulator provided will accept readings of velocity,
    acceleration, and all other information available to the simulator. The motor
    controller provided will accept similar readings of velocity and so on, and produce
    an output of the desired voltage to motors. The resulting function will be responsible
    for accurately simulating the physical operation of any specified elevator and
    building.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 物理模拟器应接受一个泛型电机控制器和一个测量累加器。提供的测量累加器将接受速度、加速度和模拟器可用的所有其他信息的读数。提供的电机控制器将接受类似的速度等读数，并产生对电机所需的电压输出。该函数将负责准确模拟任何指定电梯和建筑的物理操作。
- en: The motor control will couple with the simulator, or eventually the actual elevator,
    to use available information to decide how to operate the elevator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 电机控制将与模拟器或最终的实际电梯连接，以使用可用信息来决定如何操作电梯。
- en: The simulation executable will wrap the physics simulator and motor control
    to create a program equivalent to the simulation from [Chapter 2](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml),
    *Functional Control Flow*. Additionally, all recorded information from the simulation
    should be saved to a file for further detailed analysis.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟可执行文件将包装物理模拟器和电机控制，以创建与第 2 章 [功能控制流](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml)中的模拟等效的程序。此外，所有记录的模拟信息都应保存到文件中，以进行进一步详细分析。
- en: The analysis executable should accept the simulator trace file and check that
    all performance requirements have been met. Additionally, any analysis that would
    be useful for development purposes will be added here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 分析可执行文件应接受模拟器跟踪文件并检查是否满足所有性能要求。此外，任何对开发目的有用的分析都将在此处添加。
- en: Mapping requirements directly to code
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将需求直接映射到代码
- en: It is not always desirable to go through the full process of creating a dependency
    graph and pseudo code for each project or change. Here, we will transition directly
    from the preceding plan to the following code stubs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是希望为每个项目或变更经历创建依赖图和伪代码的完整过程。在这里，我们将直接从先前的计划过渡到以下代码片段。
- en: Writing the physics simulator
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写物理模拟器
- en: The physics simulator in `src/physics.rs` is responsible for modeling the physics
    and layout of the building and elevator operations. The simulator will be provided
    with one object to handle motor control and another to handle data collection.
    The physics simulator module will define traits for each of those interfaces,
    and the motor control and data collection objects should implement each `trait`,
    respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/physics.rs` 中的物理模拟器负责模拟建筑和电梯的物理和布局。模拟器将提供一个对象来处理电机控制，另一个对象来处理数据收集。物理模拟器模块将为每个接口定义特质，电机控制和数据收集对象应分别实现每个
    `trait`。'
- en: Let's start by defining some of the type declarations for the `physics` module.
    First, let's look at a key interface—the direct motor input. Until this point,
    we have assumed that motor input will have simple voltage control that we can
    represent as a positive or negative floating point integer. This definition is
    problematic, mainly in the sense that all references to this type will reference
    `f64`. This type specifies a very specific data representation with no room for
    adjustment. If we litter our code with references to this type, then any changes
    will require us to go back and edit every one of the references.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义 `physics` 模块的一些类型声明开始。首先，让我们看看一个关键接口——直接电机输入。到目前为止，我们一直假设电机输入将具有简单的电压控制，我们可以将其表示为正或负浮点整数。这种定义是有问题的，主要是在于所有对此类型的引用都将引用
    `f64`。此类型指定了一种非常具体的数据表示，没有调整的余地。如果我们用此类型的引用充斥我们的代码，那么任何更改都需要我们回过头来编辑每一个引用。
- en: Instead, for the motor input type, let's provide a name for the type. This could
    be an alias for the `f64` type, which would solve the immediate concern. Though
    this is acceptable, we will choose to be even more explicit with the type definition
    and provide `enum` cases for up and down. The `enum` type, also known as a **tagged
    union**, is useful to define data that may have multiple structures or use cases.
    Here, the constructors are identical, but the meaning of each voltage field is
    opposite.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对于电机输入类型，我们为该类型提供一个名称。这可以是对`f64`类型的别名，这将解决当前的问题。尽管这是可以接受的，但我们将选择更明确地定义类型并提供向上和向下的`enum`情况。`enum`类型，也称为**标签联合体**，用于定义可能具有多种结构或用例的数据。在这里，构造函数是相同的，但每个电压字段的意义是相反的。
- en: Furthermore, when interacting with the `MotorInput` type, we should avoid assuming
    any internal structure. This minimizes our exposure to future interface changes
    that may change because `MotorInput` defines an interface with a currently unknown
    physical component. We will be responsible for software compatibility with that
    interface. So, to abstract any interaction with `MotorInput`, we will use traits
    instead. Traits that do not define intrinsic behavior of a type, but rather associated
    behavior, are sometimes called **data classes**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当与`MotorInput`类型交互时，我们应该避免假设任何内部结构。这最小化了我们未来接口变化的风险，这些变化可能是因为`MotorInput`定义了一个具有当前未知物理组件的接口。我们将负责与该接口的软件兼容性。因此，为了抽象与`MotorInput`的任何交互，我们将使用特性。那些不定义类型内在行为，而是定义相关行为的特性有时被称为**数据类**。
- en: 'Here is the `enum` and a data class defining the calculation of force derived
    from an input:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`enum`和一个定义从输入推导出力的数据类的示例：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let''s define the elevator information. We will create an `ElevatorSpecification`,
    which describes the structure of the building and elevator. We also require an
    `ElevatorState` to hold information regarding the current elevator status. To
    clarify usage of floor requests, we will also create an alias for `FloorRequests` vectors
    to make the meaning explicit. We will choose to use a `struct` instead of tuples
    here to create explicit field names. Otherwise, structs and tuples are interchangeable
    for storing miscellaneous data. The definitions are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义电梯信息。我们将创建一个`ElevatorSpecification`，它描述了建筑和电梯的结构。我们还需要一个`ElevatorState`来保存有关当前电梯状态的信息。为了明确楼层请求的使用，我们还将为`FloorRequests`向量创建一个别名，使其意义明确。在这里，我们选择使用`struct`而不是元组来创建明确的字段名称。否则，`struct`和元组可以互换用于存储杂项数据。定义如下：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The traits for `MotorController` and `DataRecorder` are almost identical. The
    only difference is that polling a `MotorController` expects a `MotorInput` to
    be returned. Here, we choose to use `init` methods instead of constructors to
    permit additional external initialization of each resource. For example, it may
    be necessary for `DataRecorder` to open files or other resources to be accessed
    during simulation. Here are the `trait` definitions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotorController`和`DataRecorder`的特性几乎相同。唯一的区别是轮询`MotorController`期望返回一个`MotorInput`。在这里，我们选择使用`init`方法而不是构造函数来允许对每个资源的额外外部初始化。例如，`DataRecorder`可能需要在模拟期间打开文件或其他资源。以下是`trait`定义：'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To simulate the physics of the elevator, we will reproduce the central loop
    of the simulation from [Chapter 2](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml), *Functional
    Control Flow*. Some of the state has been organized into structures instead of
    loose variables. Motor control decisions have been delegated to the `MotorController`
    object. Output and data recording has been delegated to the `DataRecorder`. There
    is also a new parameter field to specify the elevator''s carriage weight. With
    all of these generalizations, the code becomes as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟电梯的物理特性，我们将从[第2章](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml)的模拟中心循环中复制，*功能控制流*。一些状态已经被组织成结构而不是松散的变量。电机控制决策已经委托给`MotorController`对象。输出和数据记录已经委托给`DataRecorder`。还有一个新的参数字段来指定电梯的载重。有了所有这些概括，代码如下：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After declaring the state and calculating time-dependent variables, we add
    the elevator control logic:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明状态和计算时间相关变量之后，我们添加电梯控制逻辑：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Writing the motor controller
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写电机控制器
- en: The motor controllers in `src/motor.rs` will be responsible for making decisions
    regarding how much force to generate from the motor. The physics driver will supply
    current state information regarding all known measurements of location, velocity,
    and so on. Currently, the motor controller uses only the most current information
    to make control decisions. However, this may change in the future, in which case
    the controller may store past measurements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/motor.rs`中的电机控制器将负责决定从电机产生多少力。物理驱动器将提供有关所有已知测量值（如位置、速度等）的当前状态信息。目前，电机控制器仅使用最新信息做出控制决策。然而，这可能在将来发生变化，在这种情况下，控制器可能会存储过去的测量值。'
- en: 'Extracting the same control algorithm from the previous chapter, the new `MotorController`
    definition becomes as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章提取相同的控制算法，新的`MotorController`定义如下：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After establishing basic constants and values, we need to determine the target
    acceleration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定基本常数和值之后，我们需要确定目标加速度：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After determining the target acceleration, it should be converted into a `MotorInput`
    value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 确定目标加速度后，应将其转换为`MotorInput`值：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's write a second controller, implementing the proposed improvements.
    We will compare the two controllers later in the simulation. The first suggestion
    was to reduce the polling interval. This change must be made in the physics simulator,
    so we will measure its effect, but we will not tie it to the motor controller.
    The second suggestion was to smooth the acceleration curve.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写第二个控制器，实现所提出的改进。我们将在模拟的后期比较这两个控制器。第一个建议是减少轮询间隔。此更改必须在物理模拟器中完成，因此我们将测量其效果，但不会将其与电机控制器绑定。第二个建议是平滑加速度曲线。
- en: 'After consideration, we realized that the change in acceleration (also called
    **jerk**) is what made people uncomfortable, more so than small acceleration forces.
    Understanding this, we will permit faster acceleration so long as the jerk remains
    small. We will replace the current target acceleration calculation with the following
    constraints and objectives:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 经过考虑，我们意识到加速度（也称为**jerk**）的变化是让人感到不适的原因，比小的加速度力更甚。理解这一点后，只要加速度变化率保持小，我们将允许更快的加速度。我们将用以下约束和目标替换当前的目标加速度计算：
- en: Maximum jerk = `0.2` m/s³
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大加速度变化率 = `0.2` m/s³
- en: Maximum acceleration = `2.0` m/s²
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大加速度 = `2.0` m/s²
- en: Maximum velocity = `5.0` m/s
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大速度 = `5.0` m/s
- en: 'Target change in acceleration:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标加速度变化：
- en: 0.2 if accelerating up
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果加速，则输出0.2
- en: -0.2 if accelerating down
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果减速，则输出-0.2
- en: 0.0 if at stable velocity
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处于稳定速度，则输出0.0
- en: 'The resulting controller becomes as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果控制器如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After determining basic constants and values, we can calculate a target acceleration:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 确定基本常数和值后，我们可以计算目标加速度：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After determining a target acceleration, we should calculate a target force:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确定目标加速度后，我们应该计算目标力：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Writing the executable to run a simulation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写运行模拟的可执行文件
- en: 'The executable to run a simulation, contained in `src/lib.rs`, consists of
    all input and configuration from the previous chapter''s simulation. Here is the
    harness used to configure and run a simulation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模拟的可执行文件，包含在`src/lib.rs`中，由上一章模拟的所有输入和配置组成。以下是配置和运行模拟所使用的工具：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After establishing the simulation state and reading the input configuration,
    we run the simulation:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立模拟状态并读取输入配置后，我们运行模拟：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `DataRecorder` implementation, also in `src/lib.rs`, is responsible for
    outputting real-time information as well as summary information. Additionally,
    we will serialize and store the simulation data in a log file. Notice the use
    of the `lifetime` parameter along with the parameterized `trait`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataRecorder`实现，同样在`src/lib.rs`中，负责输出实时信息以及汇总信息。此外，我们还将序列化和存储模拟数据到日志文件中。注意使用`lifetime`参数以及参数化的`trait`：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `DataRecorder` is responsible for not only recording simulation data to
    logs, but also for printing statistics to the Terminal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataRecorder`不仅负责将模拟数据记录到日志中，还负责将统计数据打印到终端：'
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `DataRecorder` is also responsible for printing a summary at the end of
    the simulation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataRecorder`还负责在模拟结束时打印汇总信息：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Writing the executable to analyze a simulation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可执行文件以分析模拟
- en: 'The analysis executable in `src/analyze.rs` should look at the log file and
    confirm that all requirements are satisfied—namely the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/analyze.rs`中的分析可执行文件应查看日志文件并确认所有要求都已满足——即以下内容：'
- en: Jerk is under `0.2` m/s³
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度变化率（也称为**jerk**）小于`0.2` m/s³
- en: Acceleration is under `2.0` m/s²
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度低于 `2.0` m/s²
- en: Velocity is under `5.0` m/s
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度低于 `5.0` m/s
- en: The elevator does not back up during trips
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电梯在行程中不会倒退
- en: All trips are completed within 20% of the physical theoretical limit
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有行程都在物理理论极限的 20% 以内完成
- en: 'The program design here will be to pass through the log file and check that
    all values are within the specified limits. There also needs to be a directional
    flag to alert us to backup events. When a trip completes, we will then compare
    the elapsed time to the theoretical limit. If any requirement is not satisfied,
    we will fail immediately and print some basic information. The code is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 程序设计将是遍历日志文件并检查所有值是否在指定的限制内。还需要一个方向标志来提醒我们备份事件。当行程完成后，我们将比较经过的时间与理论极限。如果任何要求未满足，我们将立即失败并打印一些基本信息。代码如下：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After initializing the analysis state, we will go through the lines in the
    log to calculate the statistics:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化分析状态后，我们将遍历日志中的行以计算统计数据：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The analysis validates some requirements as it is processing the file; other
    requirements must be validated only after the entire log has been processed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分析在处理文件时验证一些要求；其他要求必须在处理完整个日志后才能验证：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running simulations and analyzing data
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行模拟和分析数据
- en: 'After running a simulation with `SimpleMotorController`, we gather an initial
    simulation log. A simulation log will be saved in JSON form thanks to the handy
    SerDe library. There should be an initial elevator specification, followed by
    an elevator state, for each iteration of the simulator. The `simulation.log` will
    end up looking something like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `SimpleMotorController` 模拟后，我们收集初始模拟日志。由于方便的 SerDe 库，模拟日志将以 JSON 格式保存。对于模拟器的每次迭代，都应该有一个初始电梯规范，然后是一个电梯状态。`simulation.log`
    最终看起来可能如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This serialized output was created by our SerDe serialization library. There
    are several steps for implementing serialization using SerDe and it is very informative
    of how complex libraries work. To use SerDe for JSON serialization and deserialization,
    we must do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列化输出是由我们的 SerDe 序列化库创建的。使用 SerDe 实现序列化的步骤有几个，这对了解复杂库的工作方式非常有信息量。为了使用 SerDe
    进行 JSON 序列化和反序列化，我们必须执行以下操作：
- en: 'Add SerDe to dependencies in `Cargo.toml` as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将 SerDe 添加到 `Cargo.toml` 依赖项中：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add `macro_use` directives and `extern crate` imports to the project root:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `macro_use` 指令和 `extern crate` 导入添加到项目根目录：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Derive `Serialize` and `Deserialize` traits for data that will be serialized.
    To derive traits with macro manipulations on declarations, the `derive` directive
    is used. For each macro in the directive, a corresponding procedural macro is
    expected. Consider the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为将要序列化的数据推导 `Serialize` 和 `Deserialize` 特性。为了在声明上进行宏操作以推导特性，使用 `derive` 指令。对于指令中的每个宏，都期望有一个相应的过程宏。考虑以下代码：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Serialize data as needed. In `lib.rs`, we serialize `ElevatorSpecification`
    and `ElevatorState structs`. Type hints are often necessary, as the type system
    doesn''t like guessing:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要序列化数据。在 `lib.rs` 中，我们序列化 `ElevatorSpecification` 和 `ElevatorState` 结构体。类型提示通常是必要的，因为类型系统不喜欢猜测：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Deserialize data as needed. In `analyze.rs`, we deserialize lines into `ElevatorSpecification`
    and `ElevatorState` structs. Type hints are often necessary, as the type system
    doesn''t like guessing:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要反序列化数据。在 `analyze.rs` 中，我们将行反序列化到 `ElevatorSpecification` 和 `ElevatorState`
    结构体中。类型提示通常是必要的，因为类型系统不喜欢猜测：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: SerDe supports many built-in types to serialize and deserialize. These roughly
    correspond to all types that JSON permits, with additional structs permitted through
    type hints.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SerDe 支持许多内置类型以进行序列化和反序列化。这些大致对应于 JSON 允许的所有类型，通过类型提示允许额外的结构体。
- en: 'Looking through `simulation.log`, we can find most of the built-in types:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `simulation.log`，我们可以找到大多数内置类型：
- en: '**Integer types**: Integer types become direct JSON integers:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数类型**：整数类型变为直接的 JSON 整数：'
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Floating point types**: Floating point integers become direct JSON floats:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点类型**：浮点整数变为直接的 JSON 浮点数：'
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Strings**: Rust strings are also translated directly into JSON equivalents:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串**：Rust 字符串也被直接翻译成 JSON 等效项：'
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Vectors and arrays**: Rust collections are sometimes serialized in unexpected
    ways. For the most part, vector types are translated directly into JSON arrays;
    containing the serialized version of whatever the vector contains:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量和数组**：Rust 集合有时以意想不到的方式序列化。大多数情况下，向量类型被直接翻译成 JSON 数组；包含向量包含的序列化版本：'
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Tuples**: Tuples are serialized into JSON arrays, however, the compiler typically
    requires a type hint to understand how to serialize/deserialize these types:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：元组被序列化为 JSON 数组，然而，编译器通常需要一个类型提示来理解如何序列化和反序列化这些类型：'
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Structs**: Rust structs are translated directly into JSON objects. This always
    succeeds because Rust field names are valid object keys, as follows:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构体**：Rust 结构体直接转换为 JSON 对象。这总是成功的，因为 Rust 字段名是有效的对象键，如下所示：'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Tagged unions**: Tagged unions are a slightly strange case. The `union` constructor
    is converted into a JSON object like any other struct. The `union` tag, however,
    is also given its own struct, wrapping the `union` constructor in a separate object.
    Type hints are very much necessary for the compiler to serialize/deserialize correctly
    here:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签联合**：标签联合是一个稍微有些奇怪的情况。`union` 构造函数被转换成与任何其他结构体一样的 JSON 对象。然而，`union` 标签也被赋予了自己的结构体，将
    `union` 构造函数包裹在一个单独的对象中。类型提示在这里对于编译器正确地序列化和反序列化是非常必要的：'
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**HashMap**: Rust HashMaps are an odd case for serialization. The library attempts
    to convert them to JSON objects. However, not all HashMap keys can be serialized.
    Therefore, some serialization may fail and require custom serializers:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashMap**：Rust 的 HashMap 在序列化方面是一个特殊案例。库尝试将它们转换为 JSON 对象。然而，并非所有 HashMap
    键都可以序列化。因此，某些序列化可能会失败，需要自定义序列化器：'
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Some types are difficult to serialize, including time structures such as `Instant`.
    Despite this difficulty in processing certain datatypes, the SerDe library is
    very stable, fast, and indispensable when storing and loading data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型难以序列化，包括时间结构，如 `Instant`。尽管处理某些数据类型存在困难，但 SerDe 库在存储和加载数据时非常稳定、快速且不可或缺。
- en: 'Running the analysis program, we can confirm that this motor controller is
    insufficient for meeting current project requirements:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行分析程序，我们可以确认这个电机控制器不足以满足当前项目要求：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Switching to `SmoothMotorController`, we can see that all specifications are
    met:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 `SmoothMotorController`，我们可以看到所有规格都符合要求：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we outlined the steps to address changes to the project scope
    and new specifications. We focused on how to write robust code that will encourage
    reuse in further additional projects or refinements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了处理项目范围变更和新规格的步骤。我们专注于如何编写健壮的代码，这将鼓励在未来的额外项目或改进中重用。
- en: Using a wide variety of data structures helps to organize our project and data.
    The code should be self-documenting whenever possible. Additionally, typesafe
    code can enforce some assumptions about code to block incorrect input and inappropriate
    usage. Through the use of data classes, we also learned how to extend existing
    data structures to support new uses. We also used data classes as an interface
    to defer assumptions about project elements that were uncertain.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种数据结构有助于组织我们的项目和数据。代码应尽可能实现自文档化。此外，类型安全的代码可以强制一些关于代码的假设，以阻止错误的输入和不适当的用法。通过使用数据类，我们还学会了如何扩展现有的数据结构以支持新的用途。我们还使用数据类作为接口来推迟对项目元素不确定性的假设。
- en: In the next chapter, we will learn about parameterization and generics. We will
    perform an in-depth code review along with case analysis.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习参数化和泛型。我们将进行深入的代码审查和案例分析。
- en: Questions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a good library to serialize and deserialize data?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个库适合序列化和反序列化数据？
- en: What do the hashtag derive lines in front of the struct declarations in `physics.rs`
    do?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `physics.rs` 中结构声明前的哈希标签派生行有什么作用？
- en: Which comes first in parameterized declarations—lifetimes or traits?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数化声明中，先声明生命周期还是特质？
- en: In a `trait` implementation, what is the difference between parameters on the
    `impl`, `trait`, or type?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `trait` 实现中，`impl`、`trait` 或类型上的参数有什么区别？
- en: What is the difference between a `trait` and a data class?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`trait` 和数据类之间有什么区别？'
- en: How should you declare that a package has multiple binaries?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该如何声明一个包有多个可执行文件？
- en: How do you declare a structure field as private?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何声明一个结构体字段为私有？
