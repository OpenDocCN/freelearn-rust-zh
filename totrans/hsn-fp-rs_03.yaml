- en: Functional Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are the second most basic building blocks of programming, following
    control flow. After early languages developed control flow structures, it quickly
    became apparent that simple variable labels were insufficient for developing complex
    programs. Data structures have evolved from the basic concept of a sized datum
    stored at an address to the concept of strings and arrays, followed by mixed structures,
    and finally collections.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will revisit the project introduced in [Chapter 2](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml), *Functional
    Control Flow*. The project requirements have expanded to accommodate feedback
    from the potential client. There are also specific performance targets that must
    be met due to competition from a rival developer. To help our business succeed,
    we must now improve the previous simulation and ensure that it meets customer
    demand and performance targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting to changing the scope of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reformatting code to support multiple use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using appropriate data structures to gather, store, and process data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing code into traits and data classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting to changing the scope of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can't plan for everything. You also probably don't want to try to plan for
    everything. Flexible software development and emphasizing robust, logically independent
    components will reduce work when a requirement or dependency inevitably changes.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering new project requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After an initial demonstration, your team has received comments and feedback
    from the potential client. Watching the simulation, the elevator seems to often
    pass and go back up to floors before stopping. The client expressed concern that
    this would be not only inefficient, but also uncomfortable or irritable for passengers.
    To win the contract, the client wants to see improvements and evidence showing
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: The ride is comfortable and reliably direct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ride moves efficiently from each source to each destination floor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you have learned that a competitor has submitted a separate proposal.
    The competitor specifically claims that its elevator control system maintains
    acceleration within comfortable levels, velocity within safe bounds, and reaches
    destinations accurately within 20% of physical theoretical limits. No specific
    numbers were provided, and no simulation was demonstrated, but the client seemed
    very convinced, along with the assurance that the project will cost 10% less.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting a change map from requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After receiving feedback and new expectations, we must convert these demands
    into a plan of action. The simulation needs to be updated and additional tools
    will need to be built. Let's review the new information and architect a solution
    to meet the new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Translating expectations into requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reviewing the feedback, it is clear that there are two perspectives that need
    to be addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: A competitor has made specific claims that our company will need to outperform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client has explicit expectations to address concerns from the first demonstration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The specific claims from the competitor can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Acceleration is within comfortable bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velocity is within safe bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trip time from any floor to any other floor is within 20% of physical theoretical
    limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software is 10% cheaper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will delegate the price negotiation to our sales team, but otherwise we need
    to adjust our software to outperform the other three claims. If we can meet these
    requirements and provide adequate supporting evidence, then this should also address
    most of the client's explicit concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the client was specifically concerned about the elevator passing
    the destination floor and needing to back up. We should address this behavior
    and confirm that it does not occur in simulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is clear at this point that the previous motor control logic is inadequate.
    After brainstorming, your team develops two possible improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a variable acceleration/deceleration calculation, rather than on/off adjustment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the update interval to permit faster and, thus, more precise decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating requirements into a change map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the various new requirements, it seems appropriate to split the previous
    simulation code into different libraries and executables. We will create a separate
    module for each of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A physics simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A motor control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An executable to run the simulation for demonstration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An executable to further analyze the simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The physics simulator should accept a generic motor controller and a measurement
    accumulator. The measurement accumulator provided will accept readings of velocity,
    acceleration, and all other information available to the simulator. The motor
    controller provided will accept similar readings of velocity and so on, and produce
    an output of the desired voltage to motors. The resulting function will be responsible
    for accurately simulating the physical operation of any specified elevator and
    building.
  prefs: []
  type: TYPE_NORMAL
- en: The motor control will couple with the simulator, or eventually the actual elevator,
    to use available information to decide how to operate the elevator.
  prefs: []
  type: TYPE_NORMAL
- en: The simulation executable will wrap the physics simulator and motor control
    to create a program equivalent to the simulation from [Chapter 2](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml),
    *Functional Control Flow*. Additionally, all recorded information from the simulation
    should be saved to a file for further detailed analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The analysis executable should accept the simulator trace file and check that
    all performance requirements have been met. Additionally, any analysis that would
    be useful for development purposes will be added here.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping requirements directly to code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not always desirable to go through the full process of creating a dependency
    graph and pseudo code for each project or change. Here, we will transition directly
    from the preceding plan to the following code stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the physics simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The physics simulator in `src/physics.rs` is responsible for modeling the physics
    and layout of the building and elevator operations. The simulator will be provided
    with one object to handle motor control and another to handle data collection.
    The physics simulator module will define traits for each of those interfaces,
    and the motor control and data collection objects should implement each `trait`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining some of the type declarations for the `physics` module.
    First, let's look at a key interface—the direct motor input. Until this point,
    we have assumed that motor input will have simple voltage control that we can
    represent as a positive or negative floating point integer. This definition is
    problematic, mainly in the sense that all references to this type will reference
    `f64`. This type specifies a very specific data representation with no room for
    adjustment. If we litter our code with references to this type, then any changes
    will require us to go back and edit every one of the references.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, for the motor input type, let's provide a name for the type. This could
    be an alias for the `f64` type, which would solve the immediate concern. Though
    this is acceptable, we will choose to be even more explicit with the type definition
    and provide `enum` cases for up and down. The `enum` type, also known as a **tagged
    union**, is useful to define data that may have multiple structures or use cases.
    Here, the constructors are identical, but the meaning of each voltage field is
    opposite.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, when interacting with the `MotorInput` type, we should avoid assuming
    any internal structure. This minimizes our exposure to future interface changes
    that may change because `MotorInput` defines an interface with a currently unknown
    physical component. We will be responsible for software compatibility with that
    interface. So, to abstract any interaction with `MotorInput`, we will use traits
    instead. Traits that do not define intrinsic behavior of a type, but rather associated
    behavior, are sometimes called **data classes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `enum` and a data class defining the calculation of force derived
    from an input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the elevator information. We will create an `ElevatorSpecification`,
    which describes the structure of the building and elevator. We also require an
    `ElevatorState` to hold information regarding the current elevator status. To
    clarify usage of floor requests, we will also create an alias for `FloorRequests` vectors
    to make the meaning explicit. We will choose to use a `struct` instead of tuples
    here to create explicit field names. Otherwise, structs and tuples are interchangeable
    for storing miscellaneous data. The definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The traits for `MotorController` and `DataRecorder` are almost identical. The
    only difference is that polling a `MotorController` expects a `MotorInput` to
    be returned. Here, we choose to use `init` methods instead of constructors to
    permit additional external initialization of each resource. For example, it may
    be necessary for `DataRecorder` to open files or other resources to be accessed
    during simulation. Here are the `trait` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To simulate the physics of the elevator, we will reproduce the central loop
    of the simulation from [Chapter 2](bf10aff4-ca84-44a7-a982-b156c9cde41e.xhtml), *Functional
    Control Flow*. Some of the state has been organized into structures instead of
    loose variables. Motor control decisions have been delegated to the `MotorController`
    object. Output and data recording has been delegated to the `DataRecorder`. There
    is also a new parameter field to specify the elevator''s carriage weight. With
    all of these generalizations, the code becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the state and calculating time-dependent variables, we add
    the elevator control logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Writing the motor controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motor controllers in `src/motor.rs` will be responsible for making decisions
    regarding how much force to generate from the motor. The physics driver will supply
    current state information regarding all known measurements of location, velocity,
    and so on. Currently, the motor controller uses only the most current information
    to make control decisions. However, this may change in the future, in which case
    the controller may store past measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting the same control algorithm from the previous chapter, the new `MotorController`
    definition becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After establishing basic constants and values, we need to determine the target
    acceleration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After determining the target acceleration, it should be converted into a `MotorInput`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's write a second controller, implementing the proposed improvements.
    We will compare the two controllers later in the simulation. The first suggestion
    was to reduce the polling interval. This change must be made in the physics simulator,
    so we will measure its effect, but we will not tie it to the motor controller.
    The second suggestion was to smooth the acceleration curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'After consideration, we realized that the change in acceleration (also called
    **jerk**) is what made people uncomfortable, more so than small acceleration forces.
    Understanding this, we will permit faster acceleration so long as the jerk remains
    small. We will replace the current target acceleration calculation with the following
    constraints and objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum jerk = `0.2` m/s³
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum acceleration = `2.0` m/s²
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum velocity = `5.0` m/s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target change in acceleration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.2 if accelerating up
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: -0.2 if accelerating down
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.0 if at stable velocity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting controller becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After determining basic constants and values, we can calculate a target acceleration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After determining a target acceleration, we should calculate a target force:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Writing the executable to run a simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The executable to run a simulation, contained in `src/lib.rs`, consists of
    all input and configuration from the previous chapter''s simulation. Here is the
    harness used to configure and run a simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After establishing the simulation state and reading the input configuration,
    we run the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataRecorder` implementation, also in `src/lib.rs`, is responsible for
    outputting real-time information as well as summary information. Additionally,
    we will serialize and store the simulation data in a log file. Notice the use
    of the `lifetime` parameter along with the parameterized `trait`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataRecorder` is responsible for not only recording simulation data to
    logs, but also for printing statistics to the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataRecorder` is also responsible for printing a summary at the end of
    the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Writing the executable to analyze a simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The analysis executable in `src/analyze.rs` should look at the log file and
    confirm that all requirements are satisfied—namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Jerk is under `0.2` m/s³
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceleration is under `2.0` m/s²
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velocity is under `5.0` m/s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elevator does not back up during trips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All trips are completed within 20% of the physical theoretical limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The program design here will be to pass through the log file and check that
    all values are within the specified limits. There also needs to be a directional
    flag to alert us to backup events. When a trip completes, we will then compare
    the elapsed time to the theoretical limit. If any requirement is not satisfied,
    we will fail immediately and print some basic information. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing the analysis state, we will go through the lines in the
    log to calculate the statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The analysis validates some requirements as it is processing the file; other
    requirements must be validated only after the entire log has been processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Running simulations and analyzing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After running a simulation with `SimpleMotorController`, we gather an initial
    simulation log. A simulation log will be saved in JSON form thanks to the handy
    SerDe library. There should be an initial elevator specification, followed by
    an elevator state, for each iteration of the simulator. The `simulation.log` will
    end up looking something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This serialized output was created by our SerDe serialization library. There
    are several steps for implementing serialization using SerDe and it is very informative
    of how complex libraries work. To use SerDe for JSON serialization and deserialization,
    we must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add SerDe to dependencies in `Cargo.toml` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `macro_use` directives and `extern crate` imports to the project root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Derive `Serialize` and `Deserialize` traits for data that will be serialized.
    To derive traits with macro manipulations on declarations, the `derive` directive
    is used. For each macro in the directive, a corresponding procedural macro is
    expected. Consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Serialize data as needed. In `lib.rs`, we serialize `ElevatorSpecification`
    and `ElevatorState structs`. Type hints are often necessary, as the type system
    doesn''t like guessing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Deserialize data as needed. In `analyze.rs`, we deserialize lines into `ElevatorSpecification`
    and `ElevatorState` structs. Type hints are often necessary, as the type system
    doesn''t like guessing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: SerDe supports many built-in types to serialize and deserialize. These roughly
    correspond to all types that JSON permits, with additional structs permitted through
    type hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through `simulation.log`, we can find most of the built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer types**: Integer types become direct JSON integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Floating point types**: Floating point integers become direct JSON floats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Strings**: Rust strings are also translated directly into JSON equivalents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Vectors and arrays**: Rust collections are sometimes serialized in unexpected
    ways. For the most part, vector types are translated directly into JSON arrays;
    containing the serialized version of whatever the vector contains:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Tuples**: Tuples are serialized into JSON arrays, however, the compiler typically
    requires a type hint to understand how to serialize/deserialize these types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Structs**: Rust structs are translated directly into JSON objects. This always
    succeeds because Rust field names are valid object keys, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Tagged unions**: Tagged unions are a slightly strange case. The `union` constructor
    is converted into a JSON object like any other struct. The `union` tag, however,
    is also given its own struct, wrapping the `union` constructor in a separate object.
    Type hints are very much necessary for the compiler to serialize/deserialize correctly
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**HashMap**: Rust HashMaps are an odd case for serialization. The library attempts
    to convert them to JSON objects. However, not all HashMap keys can be serialized.
    Therefore, some serialization may fail and require custom serializers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Some types are difficult to serialize, including time structures such as `Instant`.
    Despite this difficulty in processing certain datatypes, the SerDe library is
    very stable, fast, and indispensable when storing and loading data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the analysis program, we can confirm that this motor controller is
    insufficient for meeting current project requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Switching to `SmoothMotorController`, we can see that all specifications are
    met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we outlined the steps to address changes to the project scope
    and new specifications. We focused on how to write robust code that will encourage
    reuse in further additional projects or refinements.
  prefs: []
  type: TYPE_NORMAL
- en: Using a wide variety of data structures helps to organize our project and data.
    The code should be self-documenting whenever possible. Additionally, typesafe
    code can enforce some assumptions about code to block incorrect input and inappropriate
    usage. Through the use of data classes, we also learned how to extend existing
    data structures to support new uses. We also used data classes as an interface
    to defer assumptions about project elements that were uncertain.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about parameterization and generics. We will
    perform an in-depth code review along with case analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a good library to serialize and deserialize data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the hashtag derive lines in front of the struct declarations in `physics.rs`
    do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which comes first in parameterized declarations—lifetimes or traits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a `trait` implementation, what is the difference between parameters on the
    `impl`, `trait`, or type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a `trait` and a data class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you declare that a package has multiple binaries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you declare a structure field as private?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
