["```rs\ncargo new --lib imagecli && cd imagecli\n```", "```rs\nuse std::fs;\n\nfn main() {\n    let entries = fs::read_dir(\"/tmp\").unwrap();\n    for entry in entries {\n        if let Ok(entry) = entry {\n            println!(\"{:?}\", entry.path());\n        }\n    }\n}\n```", "```rs\nuse std::time::SystemTime;\nfn main() {\n    let _now = SystemTime::now();\n}\n```", "```rs\nuse std::thread::sleep;\nuse std::time::{Duration, Instant};\nfn main() {\n    let now = Instant::now();\n    sleep(Duration::new(3, 0));\n    println!(\"{:?}\", now.elapsed().as_secs());\n}\n```", "```rs\n    .env file (instead of setting them in the console), so let's add a popular crate for this purpose, called dotenv, in Cargo.toml:\n\n    ```", "```rs\n\n    Depending on when you are reading this book, you may have a later version of this tool available, which you may choose to use.\n    ```", "```rs\n    use dotenv::dotenv;\n    use std::env;\n    fn main() {\n    dotenv().ok();\n    for (key, value) in env::vars() {\n        println!(\"{}:{}\", key, value);\n    }\n    }\n    ```", "```rs\n    dotenv().ok();\n    ```", "```rs\n    size=small\n    mode=single\n    srcfolder=/home/bob/images/image1.jpg \n    ```", "```rs\n    .env file printed out, along with the others associated with the process.\n    ```", "```rs\n    println!(\"Value of size is {}\",   \n        env::var(\"size\").unwrap());\n    ```", "```rs\n    use std::env;\n    fn main() {\n        for argument in env::args() {\n            println!(\"{}\", argument);\n        }\n    }\n    ```", "```rs\n    use std::env;\n    fn main() {\n        let args: Vec<String> = env::args().collect();\n        let size = &args[1];\n        let mode = &args[2];\n        let source_folder = &args[3];\n        println!(\n            \"Size:{},mode:{},source folder: {}\",\n            size, mode, source_folder\n        );\n    }\n    ```", "```rs\nSize:small,mode:all,source folder: /tmp\n```", "```rs\n[dependencies]\nimage = \"0.23.12\"\nstructopt = \"0.3.20\"\n```", "```rs\npub fn get_image_files(src_folder: PathBuf) -> \n    Result<Vec<PathBuf>, ImagixError> {\n    let entries = fs::read_dir(src_folder)\n        .map_err(|e| ImagixError::UserInputError(\"Invalid \n            source folder\".to_string()))?\n        .map(|res| res.map(|e| e.path()))\n        .collect::<Result<Vec<_>, io::Error>>()?\n        .into_iter()\n        .filter(|r| {\n            r.extension() == Some(\"JPG\".as_ref())\n                || r.extension() == Some(\"jpg\".as_ref())\n                || r.extension() == Some(\"PNG\".as_ref())\n                || r.extension() == Some(\"png\".as_ref())\n        })\n        .collect();\n    Ok(entries)\n}\n```", "```rs\nfn resize_image(size: u32, src_folder: &mut PathBuf) -> \n    Result<(), ImagixError> {\n    // Construct destination filename with .png extension\n    let new_file_name = src_folder\n        .file_stem()\n        .unwrap()\n        .to_str()\n        .ok_or(std::io::ErrorKind::InvalidInput)\n        .map(|f| format!(\"{}.png\", f));\n```", "```rs\n// Construct path to destination folder i.e. create /tmp \n// under source folder if not exists\nlet mut dest_folder = src_folder.clone();\ndest_folder.pop();\ndest_folder.push(\"tmp/\");\nif !dest_folder.exists() {\n    fs::create_dir(&dest_folder)?;\n}\ndest_folder.pop();\ndest_folder.push(\"tmp/tmp.png\");\ndest_folder.set_file_name(new_file_name?.as_str());\n```", "```rs\nlet timer = Instant::now();\nlet img = image::open(&src_folder)?;\nlet scaled = img.thumbnail(size, size);\nlet mut output = fs::File::create(&dest_folder)?;\nscaled.write_to(&mut output, ImageFormat::Png)?;\nprintln!(\n    \"Thumbnailed file: {:?} to size {}x{} in {}. Output \n     file   \n     in {:?}\", \n     src_folder, \n     size,\n     size,\n     Elapsed::from(&timer), \n     dest_folder\n    );\n    Ok(())\n}\n```", "```rs\npub fn get_stats(src_folder: PathBuf) -> Result<(usize, \n    f64), ImagixError> {\n    let image_files = get_image_files\n        (src_folder.to_path_buf())?;\n    let size = image_files\n        .iter()\n        .map(move |f| f.metadata().unwrap().len())\n        .sum::<u64>();\n    Ok((image_files.len(), (size / 1000000) as f64))\n}\n```", "```rs\npub enum ImagixError {\n    FileIOError(String),\n    UserInputError(String),\n    ImageResizingError(String),\n    FormatError(String),\n}\n```", "```rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_single_image_resize() {\n        let mut path = PathBuf::from(\"/tmp/images/\n            image1.jpg\");\n        let destination_path = PathBuf::from(\n            \"/tmp/images/tmp/image1.png\");\n        match process_resize_request(SizeOption::Small, \n            Mode::Single, &mut path) {\n            Ok(_) => println!(\"Successful resize of single      \n                image\"),\n            Err(e) => println!(\"Error in single image: \n                {:?}\", e),\n        }\n        assert_eq!(true, destination_path.exists());\n    }\n    #[test]\n    fn test_multiple_image_resize() {\n        let mut path = PathBuf::from(\"/tmp/images/\");\n        let _res = process_resize_request(\n            SizeOption::Small, Mode::All, &mut path);\n        let destination_path1 = PathBuf::from(\n            \"/tmp/images/tmp/image1.png\");\n        let destination_path2 = PathBuf::from(\n            \"/tmp/images/tmp/image2.png\");\n        assert_eq!(true, destination_path1.exists());\n        assert_eq!(true, destination_path2.exists());\n    }\n}\n```", "```rs\ncargo test \n```", "```rs\n    mod imagix;\n    use ::imagix::error::ImagixError;\n    use ::imagix::resize::{process_resize_request, Mode,  \n        SizeOption};\n    use ::imagix::stats::get_stats;\n    use std::path::PathBuf;\n    use std::str::FromStr;\n    use structopt::StructOpt;\n    // Define commandline arguments in a struct\n    ```", "```rs\n    #[derive(StructOpt, Debug)]\n    #[structopt(\n        name = \"resize\",\n        about = \"This is a tool for image resizing and \n            stats\",\n        help = \"Specify subcommand resize or stats. For \n            help, type imagecli resize --help or \n            imagecli stats --help\"\n    )]\n    enum Commandline {\n        #[structopt(help = \"\n              Specify size(small/medium/large),\n              mode(single/all) and srcfolder\")]\n        Resize {\n            #[structopt(long)]\n            size: SizeOption,\n            #[structopt(long)]\n            mode: Mode,\n            #[structopt(long, parse(from_os_str))]\n            srcfolder: PathBuf,\n        },\n        #[structopt(help = \"Specify srcfolder\")]\n        Stats {\n            #[structopt(long, parse(from_os_str))]\n            srcfolder: PathBuf,\n        },\n    }\n    ```", "```rs\n    fn main() {\n        let args: Commandline = Commandline::from_args();\n        match args {\n            Commandline::Resize {\n                size,\n                mode,\n                mut srcfolder,\n            } => {\n                match process_resize_request(size, mode, \n                    &mut src_folder) {\n                    Ok(_) => println!(\"Image resized    \n                        successfully\"),\n                    Err(e) => match e {\n                        ImagixError::FileIOError(e) => \n                            println!(\"{}\", e),\n                        ImagixError::UserInputError(e) => \n                            println!(\"{}\", e),\n                        ImagixError::ImageResizingError(e)     \n                            => println!(\"{}\", e),\n                        _ => println!(\"Error in \n                            processing\"),\n                    },\n                };\n            }\n            Commandline::Stats { srcfolder } => match \n                get_stats(srcfolder) {\n                Ok((count, size)) => println!(\n                    \"Found {:?} image files with aggregate \n                    size of {:?} MB\",\n                    count, size\n                ),\n                Err(e) => match e {\n                    ImagixError::FileIOError(e) => \n                        println!(\"{}\", e),\n                    ImagixError::UserInputError(e) =>    \n                        println!(\"{}\", e),\n                    _ => println!(\"Error in processing\"),\n                },\n            },\n        }\n    }\n    ```", "```rs\n     cargo build --release \n    ```", "```rs\n    cargo run --release resize --size medium --mode single --srcfolder <path-to-image-file>\n    ```", "```rs\n    cargo run --release resize --size small --mode all --srcfolder <path-to-image-file>\n    ```", "```rs\n    cargo run --release  stats --srcfolder <path-to-image-folder>\n    ```"]