- en: Generics and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameterization, also known as **generics** or **polymorphism**, is the third
    most significant language feature following control flow and data structures.
    Parameterization addresses the copy-and-paste problem of early languages. This
    feature permits the *don't repeat yourself* principle of good program design.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how parameterization can help us design robust
    programs that evolve with change rather than fight against change. No new project
    requirements will be introduced. This chapter will be entirely reflective, looking
    at how the project is currently structured, how can it be improved, and how parameterization
    can specifically help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the learning outcomes of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generalized algebraic datatypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric lifetimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding ambiguous method resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Staying productive during downtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be some time before the client makes a final decision regarding negotiation
    and potential acceptance of your project proposal. During that time, your management
    has encouraged you to take this time to review your work and make preparations
    for integrating the elevator controller into a real elevator.
  prefs: []
  type: TYPE_NORMAL
- en: You do not know much about direct elevator control interfaces, and the client
    specifically mentioned that there may be multiple subcontractors designing each
    of the different elevators. Making assumptions at this point may lead to wasted
    effort so, instead, you decide to reconsider your code and look for opportunities
    to remove any assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterization and use of trait interfaces should help achieve this goal of
    abstraction. During this downtime, you decide to have the team learn about parameterization
    and consider how it can be applied to improve this project or later projects.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are a facility to write code for multiple contexts with different types,
    and parameterization allows the programmer to write code that makes fewer assumptions
    about the data structures and code segments involved in the code's definition.
    For example, a very ambiguous concept would be the concept of addition. When a
    programmer writes `a + b`, what does that mean? In Rust, the `Add` trait can be
    implemented for just about any type. As long as there is an implementation for
    the `Add` trait in scope that is compatible with the types of `a` and `b`, then
    this trait will define the operation. In this pattern, we can write generic code
    that defines a concept in its most abstract terms, allowing for later definitions
    of data and methods to interface with that code without change.
  prefs: []
  type: TYPE_NORMAL
- en: A major example of completely generic code are built-in container data structures.
    Vectors and HashMaps must necessarily know the types of the objects they store.
    However, it would be very limiting if any assumptions were made about the underlying
    data structure or methods for the stored items. Therefore, parameterization of
    containers allows the container and its methods to explicitly declare trait bounds
    that are expected from stored types. All other characteristics of the stored item
    will be parameterized.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics refers to the practice of parameterizing classes in object-oriented
    programming languages. Rust does not have an exact equivalent of classes. However,
    the concept of datatypes paired with a trait is very similar to a class if used
    in that sense. So, in Rust, generics would refer to the parameterization of datatypes
    and traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing a common example from OOP, let''s look at the animal kingdom. In the
    following code, we will define some animals and actions that they can take. First,
    let''s define two animals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define an `animal trait` and its implementations. All animals will
    have the `max_speed` method. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined the Rust equivalent of interfaces from OOP. However,
    we have not parameterized anything, so nothing here should be considered generic.
    We will add the following code, a trait defining the concept of an animal chasing
    a toy. First, we will define the concept of a toy. This will follow the same OOP-like
    pattern as in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two traits, each having two possible implementations. Let''s define
    an action for an animal chasing a toy. More than one possible animal has been
    defined, and more than one possible toy, so we will need to use a generic definition.
    The struct definition also constrains each parameter with a trait bound, which
    adds additional information to the `struct`; now, we can guarantee that each animal
    will implement the `Animal` trait and similarly, each toy will implement `Toy`.
    We will also define some associated logic that uses the parameterized traits''
    methods. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have defined a generic `struct` and `trait` that accepts types,
    knowing only some limited information regarding the traits of each object. Multiple
    traits, or none, can be specified to declare all expected interfaces. Multiple
    traits or lifetime bounds can be declared with the `'l + Trait1 + Trait2` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating parametric polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common application of parameterization are for functions. For the same
    reasons that we would want to parameterize data structures or traits, we also
    should consider parameterization of functions. Parameterizing functions is called
    **parametric polymorphism**. Polymorphism is Greek for multiple forms or, sometimes
    in modern usage, it can mean multiple arrows. The word indicates that one function
    has multiple implementations or multiple ground type signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple example of a parametric function, we can imagine a generic multiply
    by three function. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `raise_by_three` function does not know what `Mul` does. `Mul` is
    a trait and abstract behavior, which also specifies an associated type, `Output`.
    It is not possible to generically raise `x.pow(3)` here because `x` may not be
    a numerical type. At the very least, we do not know whether `x` is a floating
    type or an integral type. So instead, we use the available `Mul` trait to multiply
    `x` three times. This may seem like a strange thing to do, but the concept becomes
    clearer in context.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider the application in regard to floating and integral types. This
    usage is straightforward but does not seem very useful yet. We already have a
    working `raise by three` expression, as long as we know and have the original
    floating or integral type. So, why wouldn''t we just use the built-in expression?
    First, let''s just compare the two options in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option seems much more preferable, and it is. However, the second
    option also assumes we know the full type of `u64` or `f64` for each argument.
    Let''s look at what happens if we erase some type information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we lose access to the underlying types, we are quickly restricted in regard
    to what operations we can perform. Generic programming is great in the respect
    that it can reduce work in the long term; however, it also requires very explicit
    declaration and implementation of all interfaces that are used. Here, you can
    see that we must declare `Copy` as a trait bound, meaning the ability to copy a
    variable from one memory location to another. Another low-level trait is `Sized`,
    which indicates that a datum has a known constant size at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `HashMap` declaration, we can see why this abstraction is
    often necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each hash key must implement `Hash` and `Eq`, meaning it must be hashable and
    comparable. Other than that, no traits are expected and thus the whole data structure
    remains very generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as functions can be parameterized, functions as arguments can also be
    parameterized. There are two general forms of functions as parameters—closures
    and function pointers. Function pointers are not permitted to carry state. Closures
    can carry state but have a variable size which is independent of their declared
    type. Function pointers can be promoted to closures automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Closures can also be parameterized in a similar fashion. This case is a bit
    more common. If you are wondering whether to use a function pointer or a closure,
    use the closure. Function pointers can always be promoted to closures. Also, this
    code introduces the `where` syntax; `where` clauses permit trait bounds to be
    declared in a more readable form. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how easy it is to wrap a function pointer into a closure. Closures
    are a good abstraction and very powerful when used correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating generalized algebraic datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is desirable to have the type system carry more information than
    normal. If we look at the process of compilation, types occupy a space between
    the program code and the program executable. The code can take the form of text
    files before compilation or an abstract syntax tree such as those manipulated
    by Rust macros. Program executables consist of the resulting combination of all
    Rust primitives like expressions, functions, datatypes, traits, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Right in the middle, it is possible to introduce a new concept called **algebraic
    data types **(**ADTs**). ADTs are technically an extension of Rust primitives,
    though it is important to note how much extra type information is used for ADTs.
    This technique involves preserving extra type information into the executable.
    Extra run time decision-making is a step towards dynamic typing and foregoes optimizations
    available to static compilation. The result is a somewhat less efficient programming
    primitive, but also a primitive that can describe concepts that are otherwise
    difficult to approach.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one example—deferred computation. When we describe a relation
    of different values and expressions, we normally just write this code into the
    program directly. However, what would we do if we wanted to separate the code
    step from the execution step? To accomplish this, we start building something
    called a **domain-specific language**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a concrete example, consider that you are building a JIT (dynamically compiled) interpreter
    for JavaScript. The Mozilla project has several projects dedicated to JS engines
    built in Rust ([https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/](https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/)).
    This is a real application for which Rust is well-suited. To use an ADT in a JIT
    compiled interpreter, we want two things:'
  prefs: []
  type: TYPE_NORMAL
- en: To evaluate ADT expressions directly within the interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compile ADT expressions if selected for compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, any part of our JavaScript expressions can either be interpreted or compiled
    at any time. If an expression is compiled, then we want all further evaluations
    to use the compiled version. The key to implementing this cleanly is to put some
    extra weight on the type system. These heavy type definitions are the essence
    of the ADT concept. Here is a definition of a very small subset of JavaScript
    using an ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that each intermediate expression has enough information to
    be evaluated, but also has enough information to be compiled. We could have easily
    wrapped the `Add` or `Mul` operator into closures, but that would disallow JIT optimization.
    We need to maintain the full representation here in order to permit JIT compilation.
    Also, note the indirection between each point where the program decides whether
    to evaluate an expression or to call into compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement an evaluation program for each expression form.
    We could break this into traits, or define the evaluation as one larger function.
    To keep the functional style, we will define a single function. To evaluate an
    expression, we will use a pattern match on the `JSJITorExpr` expression. This
    JIT expression breaks down into either a code address which is run by calling
    the `jump` function or an expression which must be evaluated dynamically. This
    pattern gives us the best of both worlds, mixing compiled code and interpreted
    code together. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Another example of the ADT concept is in heterogeneous lists. Heterogeneous
    lists are not like other generic containers, such as vectors. Rust vectors are
    homogeneous, meaning all items are required to have the same type. By comparison,
    a heterogeneous list can have any mix of types of elements. This may sound like
    a tuple, but tuples have a fixed length and flat type signature. Similarly, heterogeneous
    lists must have a length and type signature known at compile time, but that knowledge
    can be achieved incrementally. Heterogeneous lists are permitted to work with
    partial knowledge of the list type, parameterizing the knowledge that they do
    not need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example implementation of a heterogeneous list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how this definition intentionally uses a trait to obscure type information,
    without which, such a definition would be impossible. A declaration of an `HList`
    would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Rust can be a bit rigid with regards to type checking, at times. However, there
    are also many workarounds that permit complex behavior that might seem impossible
    at first.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating parametric lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lifetimes can get complicated quickly. For example, when a lifetime is used
    as a parameter, it is called a **parametric lifetime**. To cover the most common
    problems, we will break down the lifetime concept into four distinct concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Lifetimes on ground types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetimes on generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetimes on traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetime subtyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining lifetimes on ground types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ground type is a type with no parameters. Defining lifetimes on ground types
    is the simplest possible case. All traits, fields, size, and any other information
    is directly available for group types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function declaring a lifetime on a ground type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Declaring lifetimes is often unnecessary. Other times, declaring lifetimes is
    necessary. The inference rules are complicated and are sometimes extended, so
    we will ignore that part for now.
  prefs: []
  type: TYPE_NORMAL
- en: Defining lifetimes on generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declaring lifetimes on generic types requires one additional consideration.
    All generic types that have a specified lifetime must be parameterized as having
    that lifetime. The parameter declaration must be compatible with how the parameter
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The struct definition uses the parameter `T` having a lifetime of `''a`; however,
    the parameter `T` is not required to have a lifetime compatible with `''a`.  The
    parameter `T` must be constrained by its own lifetime. By doing this, the code
    becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that the parameter `T` has an explicit bound compatible with `'a`, the code
    will compile.
  prefs: []
  type: TYPE_NORMAL
- en: Defining lifetimes on traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When defining, implementing, and instantiating an object implementing a trait,
    it is possible that both the object and trait will require a lifetime. Usually,
    it is possible to infer the lifetime of the trait from the lifetime of the object.
    When this is not possible, the programmer must declare a lifetime for the trait,
    which is compatible with all other constraints. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Defining lifetime subtyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to have a single object that requires a long lifetime for itself
    but also needs a shorter lifetime for some of its components or methods. This
    can be accomplished by parameterizing multiple lifetimes. This usually works well
    unless the lifetimes come into conflict. The following is an example of multiple
    lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Investigating parametric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, it shouldn''t be surprising to learn that all datatype declarations
    can be parameterized. It should be noted that when declaring parameterized datatypes,
    the lifetime parameters must be located ahead of the generic parameters. Refer
    to the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also seen how traits can be parameterized. However, what happens when
    a datatype and a trait both need parameters for implementation? There is a special
    syntax for that, involving three parameter lists, and it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more special case that we should mention, and that is the case
    of method ambiguity. When multiple traits are implemented for a single type, it
    is possible for there to be multiple methods with the same name. To access the
    different methods, it becomes necessary to specify what `trait` is intended to
    be used when called. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the method, we must use something called the **universal function call
    syntax**. There are two forms of the syntax, one short—the other longer. The short
    form is usually sufficient for resolving all but the most complicated of situations.
    Here is an example to match the preceding type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are also several less documented syntax forms ([https://matematikaadit.github.io/posts/rust-turbofish.html](https://matematikaadit.github.io/posts/rust-turbofish.html))
    syntax forms available for various scenarios where parameters need to be explicitly
    provided. Rust does not currently have direct type ascription currently, so hints
    for the compiler are provided as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Applying parameterization concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored the concepts of generics and parameterization. Let's scan through
    the project to see if any concepts would be appropriate to use.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parametric data allows us to declare only the minimal amount of semantic information
    required. Instead of specifying a type, we can specify a generic parameter having
    a trait. Let''s start by looking at `physics.rs` type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remember, where we used `physics.rs` when we designed the new `MotorInput`
    implementation, we should notice a problem. We wanted to abstract `MotorInput`
    behavior behind a trait; however, `ElevatorState` specifies a specific implementation.
    Let''s redefine `ElevatorState` to use a generic type for `motor_input`. The parameter
    should implement all traits of `MotorInput`, and will, therefore, become as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This may look acceptable at first glance, but now the `MotorInput` parameter
    and all traits must be declared along with every mention of any type that wraps
    `MotorInput` or `ElevatorState`. We get an explosion of parameters. There must
    be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter explosion, in this case, would look like the following, at every
    type declaration, trait declaration, implementation, function, or expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is all just for one parameter! Fortunately, there is another solution to
    this problem. The technique uses something called **trait objects**. A trait object
    is an object implementing a trait but having no known type at compile time. Trait
    objects, because they have no concrete type, do not need to be parameterized.
    The downside of trait objects are that they cannot be sized, and therefore must
    usually be handled indirectly through a Box or some other sized container. Any
    attempt to size a trait object will result in a compiler error. Similarly, any
    trait that has a static method, or is otherwise not object-safe, cannot be used
    with a trait object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the `MotorInput` and `ElevatorState` objects to use trait objects
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare that a `MotorInput` trait has two subtraits specifying the
    behavior. Our `ElevatorState` declaration does not require a parameter; however,
    the `MotorInput` trait object must be wrapped in a `Box`. This layer of indirection
    is required due to the inability of the compiler to size the `MotorInput` trait
    object for compilation. Also, because `MotorInput` does not implement `Sized`,
    it cannot use the `Clone` or `serde` macros. Some of our code needs to be changed
    to accommodate this, but it is not overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing functions and trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our motor controllers, we make another baseless assumption about the motor.
    Namely, that a flat force will be generated per voltage input. The suspect code
    in the motor controllers looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The assumption may be wrong with respect to the motor being more or less efficient
    than assumed. Also, the assumption that generated force will be linear with respect
    to voltage is unlikely. To satisfy the requirements of our motor controller and
    the physics simulation, we require one function that will consider the physical
    motor being used and convert the voltage to force. Similarly, we need the inverse
    function to convert the target force to target voltage. We can write these plainly
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nice to look at, but it doesn''t fit into the goal of abstracting the
    concept of a physical motor. We should define these functions as methods on an
    interface. This way, we can use the trait object pattern again to abstract away
    the type of motor, as well as the type parameter for the motor. The code becomes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `Motor` trait and an implementation, we can integrate this
    definition with the `ElevatorSpecification` struct. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we lose the ability to use certain derive macros, but the type signature
    is much cleaner at least. The usage in the motor controllers now supports multiple
    motors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there are some potential tradeoffs between different types of
    parameterization or generic behavior. On one hand, parameters can quickly become
    overwhelming to keep track of. On the other, side trait objects break many languages
    with features such as derive macros, anything that is not object-safe, requiring
    a concrete type, and so on. Choosing the right tool is an important decision that
    requires weighing the merits of each option.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric traits and implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have successfully implemented `Motor` and `MotorInput` as trait objects.
    However, we sacrificed nice things like `Clone`, `Serialize`, `Deserialize`, and
    `Debug` to accomplish this. Can we reclaim those functionalities?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s try to duplicate the functionality. We will call these bundled
    traits `ElevatorStateClone` and `ElevatorSpecificationClone`. The signatures should
    look something like the following (the trait implementations are available in
    the `src/physics.rs` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These traits provide the bare minimum functionality to get us back to where
    we were previously with serialization and copy semantics. The major downside is
    that each definition is quite verbose. Additionally, the serialization turns into
    a tuple, rather than going directly back and forth between the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what precisely is the problem with trait objects? We know that they must
    be wrapped in `Box` types to circumvent the unknown size. Is this the problem?
    Here is a program to test this theory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `Box` types can be serialized. The problem, then, must be with the trait
    object. Let''s try the same thing with a trait object to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When compiling this last snippet, we get the error, `` the trait `serde::Deserialize<'_>`
    is not implemented for `T` ``. So, we can see that the individual structs `S1`
    and `S2` both implement `Deserialize`, but that information is obscured. The trait
    object `T` itself must implement `Deserialize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the first attempt at serializing the trait object `T`, we can follow
    the instructions for writing custom serialization. The result should be something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit of a mess, but the important parts are that we want to write
    `S1` or `S2` to the serializer and check for those tags to deserialize. Essentially,
    what we are trying to create is a side enum to exist just for the purpose of serialization.
    Somehow, the serializer needs to know whether `T` is an `S1` or `S2` through the
    interface, so why not, in turn, provide a method on `T` that will return an enum?
    Enums are also serializable with macros, so we could pass that automatic serialization
    through to `T`. Let''s try that, starting with the type and trait definitions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is no issue in permitting a method on a trait object
    that turns the object into an enum. This relation is natural and provides an escape
    hatch to convert back and forth between the trait objects and its internal representation.
    Now, to implement serialization, we just need to wrap and unwrap the enum serializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That wasn't so bad, was it? With this technique, we can hide parameters behind
    trait objects while still benefiting from the direct access to data and macro-derived
    traits. There is a little bit of boilerplate here. Luckily though, for each macro,
    the code is almost identical for whatever type you are using. Remember this one;
    it could be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic and deeper concepts of generic and parameterized
    programming. We learned how to add lifetime, type, and trait parameters to declarations
    of types, traits, functions, and implementations. We also examined advanced techniques
    to selectively preserve or obscure type information as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Applying these concepts to the elevator simulation, we observed how parameterization
    and generics can create fully abstract interfaces. By using trait objects, it
    is possible to completely separate trait interfaces from any implementation. We
    also observed the downsides or difficulties of parameterization and generics.
    Excessive use of parameterization can lead to parameter leaks, potentially requiring
    all code that interfaces with an interface to also become parameterized itself.
    On the other hand, we observed the difficulty associated with erasing type information
    using trait objects. Choosing the right amount of information to preserve is important.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about applied project structure with complex
    requirements. The client will respond to the project proposal and your team will
    respond to new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an algebraic datatype?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is polymorphism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is parametric polymorphism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a ground type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is universal function call syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the possible type signatures of a trait object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two ways to obscure type information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a subtrait declared?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
