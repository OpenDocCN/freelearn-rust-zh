- en: Generics and Polymorphism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameterization, also known as **generics** or **polymorphism**, is the third
    most significant language feature following control flow and data structures.
    Parameterization addresses the copy-and-paste problem of early languages. This
    feature permits the *don't repeat yourself* principle of good program design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how parameterization can help us design robust
    programs that evolve with change rather than fight against change. No new project
    requirements will be introduced. This chapter will be entirely reflective, looking
    at how the project is currently structured, how can it be improved, and how parameterization
    can specifically help.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the learning outcomes of this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generalized algebraic datatypes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric lifetimes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding parametric traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding ambiguous method resolution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Staying productive during downtime
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be some time before the client makes a final decision regarding negotiation
    and potential acceptance of your project proposal. During that time, your management
    has encouraged you to take this time to review your work and make preparations
    for integrating the elevator controller into a real elevator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You do not know much about direct elevator control interfaces, and the client
    specifically mentioned that there may be multiple subcontractors designing each
    of the different elevators. Making assumptions at this point may lead to wasted
    effort so, instead, you decide to reconsider your code and look for opportunities
    to remove any assumptions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Parameterization and use of trait interfaces should help achieve this goal of
    abstraction. During this downtime, you decide to have the team learn about parameterization
    and consider how it can be applied to improve this project or later projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Learning about generics
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are a facility to write code for multiple contexts with different types,
    and parameterization allows the programmer to write code that makes fewer assumptions
    about the data structures and code segments involved in the code's definition.
    For example, a very ambiguous concept would be the concept of addition. When a
    programmer writes `a + b`, what does that mean? In Rust, the `Add` trait can be
    implemented for just about any type. As long as there is an implementation for
    the `Add` trait in scope that is compatible with the types of `a` and `b`, then
    this trait will define the operation. In this pattern, we can write generic code
    that defines a concept in its most abstract terms, allowing for later definitions
    of data and methods to interface with that code without change.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种编写适用于不同类型上下文的代码的设施，参数化允许程序员编写对涉及代码定义的数据结构和代码段做出较少假设的代码。例如，一个非常模糊的概念将是加法概念。当程序员编写`a
    + b`时，这意味着什么？在Rust中，可以为几乎任何类型实现`Add`特质。只要存在与`a`和`b`的类型兼容的`Add`特质的实现，则此特质将定义操作。在这种模式中，我们可以编写以最抽象的术语定义概念的泛型代码，允许稍后定义的数据和方法与该代码接口而无需更改。
- en: A major example of completely generic code are built-in container data structures.
    Vectors and HashMaps must necessarily know the types of the objects they store.
    However, it would be very limiting if any assumptions were made about the underlying
    data structure or methods for the stored items. Therefore, parameterization of
    containers allows the container and its methods to explicitly declare trait bounds
    that are expected from stored types. All other characteristics of the stored item
    will be parameterized.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完全泛型代码的一个主要例子是内置的容器数据结构。向量和HashMap必须必然知道它们存储的对象的类型。然而，如果对底层数据结构或存储项的方法有任何假设，这将非常限制性。因此，容器的参数化允许容器及其方法显式声明期望从存储类型中获得的特征界限。存储项的所有其他特征都将被参数化。
- en: Investigating generics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查泛型
- en: Generics refers to the practice of parameterizing classes in object-oriented
    programming languages. Rust does not have an exact equivalent of classes. However,
    the concept of datatypes paired with a trait is very similar to a class if used
    in that sense. So, in Rust, generics would refer to the parameterization of datatypes
    and traits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是指参数化面向对象编程语言中的类。Rust没有类的确切等效物。然而，如果从那种意义上使用，数据类型与特质的组合概念与类非常相似。因此，在Rust中，泛型将指数据类型和特质的参数化。
- en: 'Choosing a common example from OOP, let''s look at the animal kingdom. In the
    following code, we will define some animals and actions that they can take. First,
    let''s define two animals:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以面向对象编程（OOP）的常见示例，让我们看看动物王国。在以下代码中，我们将定义一些动物和它们可以执行的动作。首先，让我们定义两种动物：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s define an `animal trait` and its implementations. All animals will
    have the `max_speed` method. Here is the code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`动物特征`及其实现。所有动物都将具有`max_speed`方法。以下是代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we have defined the Rust equivalent of interfaces from OOP. However,
    we have not parameterized anything, so nothing here should be considered generic.
    We will add the following code, a trait defining the concept of an animal chasing
    a toy. First, we will define the concept of a toy. This will follow the same OOP-like
    pattern as in the preceding code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了Rust中面向对象编程（OOP）接口的等效物。然而，我们没有对任何东西进行参数化，因此这里不应该有任何泛型内容。我们将添加以下代码，一个定义动物追逐玩具概念的特质。首先，我们将定义玩具的概念。这将遵循与前面代码相同的面向对象模式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we have two traits, each having two possible implementations. Let''s define
    an action for an animal chasing a toy. More than one possible animal has been
    defined, and more than one possible toy, so we will need to use a generic definition.
    The struct definition also constrains each parameter with a trait bound, which
    adds additional information to the `struct`; now, we can guarantee that each animal
    will implement the `Animal` trait and similarly, each toy will implement `Toy`.
    We will also define some associated logic that uses the parameterized traits''
    methods. The code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个特质，每个特质都有两种可能的实现。让我们定义一个动物追逐玩具的动作。已经定义了多个可能的动物和多个可能的玩具，因此我们需要使用泛型定义。结构定义还通过特质界限约束每个参数，这为`struct`添加了额外的信息；现在，我们可以保证每个动物都将实现`Animal`特质，同样，每个玩具也将实现`Toy`。我们还将定义一些使用参数化特质方法的关联逻辑。以下是代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, we have defined a generic `struct` and `trait` that accepts types,
    knowing only some limited information regarding the traits of each object. Multiple
    traits, or none, can be specified to declare all expected interfaces. Multiple
    traits or lifetime bounds can be declared with the `'l + Trait1 + Trait2` syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Investigating parametric polymorphism
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common application of parameterization are for functions. For the same
    reasons that we would want to parameterize data structures or traits, we also
    should consider parameterization of functions. Parameterizing functions is called
    **parametric polymorphism**. Polymorphism is Greek for multiple forms or, sometimes
    in modern usage, it can mean multiple arrows. The word indicates that one function
    has multiple implementations or multiple ground type signatures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple example of a parametric function, we can imagine a generic multiply
    by three function. Here is the implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `raise_by_three` function does not know what `Mul` does. `Mul` is
    a trait and abstract behavior, which also specifies an associated type, `Output`.
    It is not possible to generically raise `x.pow(3)` here because `x` may not be
    a numerical type. At the very least, we do not know whether `x` is a floating
    type or an integral type. So instead, we use the available `Mul` trait to multiply
    `x` three times. This may seem like a strange thing to do, but the concept becomes
    clearer in context.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider the application in regard to floating and integral types. This
    usage is straightforward but does not seem very useful yet. We already have a
    working `raise by three` expression, as long as we know and have the original
    floating or integral type. So, why wouldn''t we just use the built-in expression?
    First, let''s just compare the two options in code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second option seems much more preferable, and it is. However, the second
    option also assumes we know the full type of `u64` or `f64` for each argument.
    Let''s look at what happens if we erase some type information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After we lose access to the underlying types, we are quickly restricted in regard
    to what operations we can perform. Generic programming is great in the respect
    that it can reduce work in the long term; however, it also requires very explicit
    declaration and implementation of all interfaces that are used. Here, you can
    see that we must declare `Copy` as a trait bound, meaning the ability to copy a
    variable from one memory location to another. Another low-level trait is `Sized`,
    which indicates that a datum has a known constant size at compile time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `HashMap` declaration, we can see why this abstraction is
    often necessary:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each hash key must implement `Hash` and `Eq`, meaning it must be hashable and
    comparable. Other than that, no traits are expected and thus the whole data structure
    remains very generic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as functions can be parameterized, functions as arguments can also be
    parameterized. There are two general forms of functions as parameters—closures
    and function pointers. Function pointers are not permitted to carry state. Closures
    can carry state but have a variable size which is independent of their declared
    type. Function pointers can be promoted to closures automatically:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Closures can also be parameterized in a similar fashion. This case is a bit
    more common. If you are wondering whether to use a function pointer or a closure,
    use the closure. Function pointers can always be promoted to closures. Also, this
    code introduces the `where` syntax; `where` clauses permit trait bounds to be
    declared in a more readable form. Here is the code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see how easy it is to wrap a function pointer into a closure. Closures
    are a good abstraction and very powerful when used correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Investigating generalized algebraic datatypes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is desirable to have the type system carry more information than
    normal. If we look at the process of compilation, types occupy a space between
    the program code and the program executable. The code can take the form of text
    files before compilation or an abstract syntax tree such as those manipulated
    by Rust macros. Program executables consist of the resulting combination of all
    Rust primitives like expressions, functions, datatypes, traits, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Right in the middle, it is possible to introduce a new concept called **algebraic
    data types **(**ADTs**). ADTs are technically an extension of Rust primitives,
    though it is important to note how much extra type information is used for ADTs.
    This technique involves preserving extra type information into the executable.
    Extra run time decision-making is a step towards dynamic typing and foregoes optimizations
    available to static compilation. The result is a somewhat less efficient programming
    primitive, but also a primitive that can describe concepts that are otherwise
    difficult to approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one example—deferred computation. When we describe a relation
    of different values and expressions, we normally just write this code into the
    program directly. However, what would we do if we wanted to separate the code
    step from the execution step? To accomplish this, we start building something
    called a **domain-specific language**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'For a concrete example, consider that you are building a JIT (dynamically compiled) interpreter
    for JavaScript. The Mozilla project has several projects dedicated to JS engines
    built in Rust ([https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/](https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/)).
    This is a real application for which Rust is well-suited. To use an ADT in a JIT
    compiled interpreter, we want two things:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: To evaluate ADT expressions directly within the interpreter
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compile ADT expressions if selected for compilation
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, any part of our JavaScript expressions can either be interpreted or compiled
    at any time. If an expression is compiled, then we want all further evaluations
    to use the compiled version. The key to implementing this cleanly is to put some
    extra weight on the type system. These heavy type definitions are the essence
    of the ADT concept. Here is a definition of a very small subset of JavaScript
    using an ADT:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we can see that each intermediate expression has enough information to
    be evaluated, but also has enough information to be compiled. We could have easily
    wrapped the `Add` or `Mul` operator into closures, but that would disallow JIT optimization.
    We need to maintain the full representation here in order to permit JIT compilation.
    Also, note the indirection between each point where the program decides whether
    to evaluate an expression or to call into compiled code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement an evaluation program for each expression form.
    We could break this into traits, or define the evaluation as one larger function.
    To keep the functional style, we will define a single function. To evaluate an
    expression, we will use a pattern match on the `JSJITorExpr` expression. This
    JIT expression breaks down into either a code address which is run by calling
    the `jump` function or an expression which must be evaluated dynamically. This
    pattern gives us the best of both worlds, mixing compiled code and interpreted
    code together. The code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another example of the ADT concept is in heterogeneous lists. Heterogeneous
    lists are not like other generic containers, such as vectors. Rust vectors are
    homogeneous, meaning all items are required to have the same type. By comparison,
    a heterogeneous list can have any mix of types of elements. This may sound like
    a tuple, but tuples have a fixed length and flat type signature. Similarly, heterogeneous
    lists must have a length and type signature known at compile time, but that knowledge
    can be achieved incrementally. Heterogeneous lists are permitted to work with
    partial knowledge of the list type, parameterizing the knowledge that they do
    not need.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example implementation of a heterogeneous list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice how this definition intentionally uses a trait to obscure type information,
    without which, such a definition would be impossible. A declaration of an `HList`
    would look like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rust can be a bit rigid with regards to type checking, at times. However, there
    are also many workarounds that permit complex behavior that might seem impossible
    at first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Investigating parametric lifetimes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lifetimes can get complicated quickly. For example, when a lifetime is used
    as a parameter, it is called a **parametric lifetime**. To cover the most common
    problems, we will break down the lifetime concept into four distinct concepts:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Lifetimes on ground types
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetimes on generic types
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetimes on traits
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetime subtyping
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining lifetimes on ground types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A ground type is a type with no parameters. Defining lifetimes on ground types
    is the simplest possible case. All traits, fields, size, and any other information
    is directly available for group types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function declaring a lifetime on a ground type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declaring lifetimes is often unnecessary. Other times, declaring lifetimes is
    necessary. The inference rules are complicated and are sometimes extended, so
    we will ignore that part for now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Defining lifetimes on generic types
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declaring lifetimes on generic types requires one additional consideration.
    All generic types that have a specified lifetime must be parameterized as having
    that lifetime. The parameter declaration must be compatible with how the parameter
    is used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that will fail:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The struct definition uses the parameter `T` having a lifetime of `''a`; however,
    the parameter `T` is not required to have a lifetime compatible with `''a`.  The
    parameter `T` must be constrained by its own lifetime. By doing this, the code
    becomes as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that the parameter `T` has an explicit bound compatible with `'a`, the code
    will compile.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Defining lifetimes on traits
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When defining, implementing, and instantiating an object implementing a trait,
    it is possible that both the object and trait will require a lifetime. Usually,
    it is possible to infer the lifetime of the trait from the lifetime of the object.
    When this is not possible, the programmer must declare a lifetime for the trait,
    which is compatible with all other constraints. The code is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining lifetime subtyping
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to have a single object that requires a long lifetime for itself
    but also needs a shorter lifetime for some of its components or methods. This
    can be accomplished by parameterizing multiple lifetimes. This usually works well
    unless the lifetimes come into conflict. The following is an example of multiple
    lifetimes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Investigating parametric types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, it shouldn''t be surprising to learn that all datatype declarations
    can be parameterized. It should be noted that when declaring parameterized datatypes,
    the lifetime parameters must be located ahead of the generic parameters. Refer
    to the following code for this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have also seen how traits can be parameterized. However, what happens when
    a datatype and a trait both need parameters for implementation? There is a special
    syntax for that, involving three parameter lists, and it looks like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is one more special case that we should mention, and that is the case
    of method ambiguity. When multiple traits are implemented for a single type, it
    is possible for there to be multiple methods with the same name. To access the
    different methods, it becomes necessary to specify what `trait` is intended to
    be used when called. Here is an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To call the method, we must use something called the **universal function call
    syntax**. There are two forms of the syntax, one short—the other longer. The short
    form is usually sufficient for resolving all but the most complicated of situations.
    Here is an example to match the preceding type definitions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are also several less documented syntax forms ([https://matematikaadit.github.io/posts/rust-turbofish.html](https://matematikaadit.github.io/posts/rust-turbofish.html))
    syntax forms available for various scenarios where parameters need to be explicitly
    provided. Rust does not currently have direct type ascription currently, so hints
    for the compiler are provided as necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Applying parameterization concepts
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored the concepts of generics and parameterization. Let's scan through
    the project to see if any concepts would be appropriate to use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing data
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parametric data allows us to declare only the minimal amount of semantic information
    required. Instead of specifying a type, we can specify a generic parameter having
    a trait. Let''s start by looking at `physics.rs` type declarations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we remember, where we used `physics.rs` when we designed the new `MotorInput`
    implementation, we should notice a problem. We wanted to abstract `MotorInput`
    behavior behind a trait; however, `ElevatorState` specifies a specific implementation.
    Let''s redefine `ElevatorState` to use a generic type for `motor_input`. The parameter
    should implement all traits of `MotorInput`, and will, therefore, become as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This may look acceptable at first glance, but now the `MotorInput` parameter
    and all traits must be declared along with every mention of any type that wraps
    `MotorInput` or `ElevatorState`. We get an explosion of parameters. There must
    be a better way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter explosion, in this case, would look like the following, at every
    type declaration, trait declaration, implementation, function, or expression:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is all just for one parameter! Fortunately, there is another solution to
    this problem. The technique uses something called **trait objects**. A trait object
    is an object implementing a trait but having no known type at compile time. Trait
    objects, because they have no concrete type, do not need to be parameterized.
    The downside of trait objects are that they cannot be sized, and therefore must
    usually be handled indirectly through a Box or some other sized container. Any
    attempt to size a trait object will result in a compiler error. Similarly, any
    trait that has a static method, or is otherwise not object-safe, cannot be used
    with a trait object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the `MotorInput` and `ElevatorState` objects to use trait objects
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we declare that a `MotorInput` trait has two subtraits specifying the
    behavior. Our `ElevatorState` declaration does not require a parameter; however,
    the `MotorInput` trait object must be wrapped in a `Box`. This layer of indirection
    is required due to the inability of the compiler to size the `MotorInput` trait
    object for compilation. Also, because `MotorInput` does not implement `Sized`,
    it cannot use the `Clone` or `serde` macros. Some of our code needs to be changed
    to accommodate this, but it is not overwhelming.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing functions and trait objects
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our motor controllers, we make another baseless assumption about the motor.
    Namely, that a flat force will be generated per voltage input. The suspect code
    in the motor controllers looks like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The assumption may be wrong with respect to the motor being more or less efficient
    than assumed. Also, the assumption that generated force will be linear with respect
    to voltage is unlikely. To satisfy the requirements of our motor controller and
    the physics simulation, we require one function that will consider the physical
    motor being used and convert the voltage to force. Similarly, we need the inverse
    function to convert the target force to target voltage. We can write these plainly
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is nice to look at, but it doesn''t fit into the goal of abstracting the
    concept of a physical motor. We should define these functions as methods on an
    interface. This way, we can use the trait object pattern again to abstract away
    the type of motor, as well as the type parameter for the motor. The code becomes
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After declaring the `Motor` trait and an implementation, we can integrate this
    definition with the `ElevatorSpecification` struct. The result is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, we lose the ability to use certain derive macros, but the type signature
    is much cleaner at least. The usage in the motor controllers now supports multiple
    motors:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that there are some potential tradeoffs between different types of
    parameterization or generic behavior. On one hand, parameters can quickly become
    overwhelming to keep track of. On the other, side trait objects break many languages
    with features such as derive macros, anything that is not object-safe, requiring
    a concrete type, and so on. Choosing the right tool is an important decision that
    requires weighing the merits of each option.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Parametric traits and implementations
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have successfully implemented `Motor` and `MotorInput` as trait objects.
    However, we sacrificed nice things like `Clone`, `Serialize`, `Deserialize`, and
    `Debug` to accomplish this. Can we reclaim those functionalities?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s try to duplicate the functionality. We will call these bundled
    traits `ElevatorStateClone` and `ElevatorSpecificationClone`. The signatures should
    look something like the following (the trait implementations are available in
    the `src/physics.rs` file):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These traits provide the bare minimum functionality to get us back to where
    we were previously with serialization and copy semantics. The major downside is
    that each definition is quite verbose. Additionally, the serialization turns into
    a tuple, rather than going directly back and forth between the correct type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what precisely is the problem with trait objects? We know that they must
    be wrapped in `Box` types to circumvent the unknown size. Is this the problem?
    Here is a program to test this theory:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So, `Box` types can be serialized. The problem, then, must be with the trait
    object. Let''s try the same thing with a trait object to see what happens:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When compiling this last snippet, we get the error, `` the trait `serde::Deserialize<'_>`
    is not implemented for `T` ``. So, we can see that the individual structs `S1`
    and `S2` both implement `Deserialize`, but that information is obscured. The trait
    object `T` itself must implement `Deserialize`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the first attempt at serializing the trait object `T`, we can follow
    the instructions for writing custom serialization. The result should be something
    like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a bit of a mess, but the important parts are that we want to write
    `S1` or `S2` to the serializer and check for those tags to deserialize. Essentially,
    what we are trying to create is a side enum to exist just for the purpose of serialization.
    Somehow, the serializer needs to know whether `T` is an `S1` or `S2` through the
    interface, so why not, in turn, provide a method on `T` that will return an enum?
    Enums are also serializable with macros, so we could pass that automatic serialization
    through to `T`. Let''s try that, starting with the type and trait definitions,
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we can see that there is no issue in permitting a method on a trait object
    that turns the object into an enum. This relation is natural and provides an escape
    hatch to convert back and forth between the trait objects and its internal representation.
    Now, to implement serialization, we just need to wrap and unwrap the enum serializers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That wasn't so bad, was it? With this technique, we can hide parameters behind
    trait objects while still benefiting from the direct access to data and macro-derived
    traits. There is a little bit of boilerplate here. Luckily though, for each macro,
    the code is almost identical for whatever type you are using. Remember this one;
    it could be useful.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic and deeper concepts of generic and parameterized
    programming. We learned how to add lifetime, type, and trait parameters to declarations
    of types, traits, functions, and implementations. We also examined advanced techniques
    to selectively preserve or obscure type information as desired.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Applying these concepts to the elevator simulation, we observed how parameterization
    and generics can create fully abstract interfaces. By using trait objects, it
    is possible to completely separate trait interfaces from any implementation. We
    also observed the downsides or difficulties of parameterization and generics.
    Excessive use of parameterization can lead to parameter leaks, potentially requiring
    all code that interfaces with an interface to also become parameterized itself.
    On the other hand, we observed the difficulty associated with erasing type information
    using trait objects. Choosing the right amount of information to preserve is important.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about applied project structure with complex
    requirements. The client will respond to the project proposal and your team will
    respond to new requirements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an algebraic datatype?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is polymorphism?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is parametric polymorphism?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a ground type?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is universal function call syntax?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the possible type signatures of a trait object?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two ways to obscure type information?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a subtrait declared?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
