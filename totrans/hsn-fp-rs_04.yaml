- en: Generics and Polymorphism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型和多态性
- en: Parameterization, also known as **generics** or **polymorphism**, is the third
    most significant language feature following control flow and data structures.
    Parameterization addresses the copy-and-paste problem of early languages. This
    feature permits the *don't repeat yourself* principle of good program design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化，也称为**泛型**或**多态性**，是继控制流和数据结构之后的第三大重要语言特性。参数化解决了早期语言中的复制粘贴问题。此功能允许遵循“不要重复自己”的良好程序设计原则。
- en: In this chapter, we will look at how parameterization can help us design robust
    programs that evolve with change rather than fight against change. No new project
    requirements will be introduced. This chapter will be entirely reflective, looking
    at how the project is currently structured, how can it be improved, and how parameterization
    can specifically help.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨参数化如何帮助我们设计能够随变化而演化的稳健程序，而不是与变化作斗争。不会引入新的项目需求。本章将完全反思，查看项目当前的结构，如何改进，以及参数化如何具体帮助。
- en: 'The following are the learning outcomes of this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的学习成果如下：
- en: Understanding generalized algebraic datatypes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解泛化代数数据类型
- en: Understanding parametric polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解参数化多态性
- en: Understanding parametric lifetimes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解参数化生命周期
- en: Understanding parametric traits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解参数化特性
- en: Understanding ambiguous method resolution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模糊方法解析
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要Rust的最近版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rust安装指南](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[《RUST函数式编程实战》](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每章的`README.md`文件中也包含了具体的安装和构建说明。
- en: Staying productive during downtime
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在空闲时间保持生产力
- en: There will be some time before the client makes a final decision regarding negotiation
    and potential acceptance of your project proposal. During that time, your management
    has encouraged you to take this time to review your work and make preparations
    for integrating the elevator controller into a real elevator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户就谈判和可能接受你的项目提案做出最终决定之前，将有一段时间。在这段时间里，你的管理层鼓励你利用这段时间回顾你的工作，并为将电梯控制器集成到真实电梯中做好准备。
- en: You do not know much about direct elevator control interfaces, and the client
    specifically mentioned that there may be multiple subcontractors designing each
    of the different elevators. Making assumptions at this point may lead to wasted
    effort so, instead, you decide to reconsider your code and look for opportunities
    to remove any assumptions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你对直接电梯控制接口了解不多，客户特别提到可能有多个分包商设计不同的电梯。在这个阶段做出假设可能会导致浪费精力，因此，你决定重新考虑你的代码，寻找消除任何假设的机会。
- en: Parameterization and use of trait interfaces should help achieve this goal of
    abstraction. During this downtime, you decide to have the team learn about parameterization
    and consider how it can be applied to improve this project or later projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 特性接口的参数化和使用有助于实现这一抽象目标。在这段时间内，你决定让团队学习参数化，并考虑如何将其应用于改进本项目或后续项目。
- en: Learning about generics
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解泛型
- en: Generics are a facility to write code for multiple contexts with different types,
    and parameterization allows the programmer to write code that makes fewer assumptions
    about the data structures and code segments involved in the code's definition.
    For example, a very ambiguous concept would be the concept of addition. When a
    programmer writes `a + b`, what does that mean? In Rust, the `Add` trait can be
    implemented for just about any type. As long as there is an implementation for
    the `Add` trait in scope that is compatible with the types of `a` and `b`, then
    this trait will define the operation. In this pattern, we can write generic code
    that defines a concept in its most abstract terms, allowing for later definitions
    of data and methods to interface with that code without change.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种编写适用于不同类型上下文的代码的设施，参数化允许程序员编写对涉及代码定义的数据结构和代码段做出较少假设的代码。例如，一个非常模糊的概念将是加法概念。当程序员编写`a
    + b`时，这意味着什么？在Rust中，可以为几乎任何类型实现`Add`特质。只要存在与`a`和`b`的类型兼容的`Add`特质的实现，则此特质将定义操作。在这种模式中，我们可以编写以最抽象的术语定义概念的泛型代码，允许稍后定义的数据和方法与该代码接口而无需更改。
- en: A major example of completely generic code are built-in container data structures.
    Vectors and HashMaps must necessarily know the types of the objects they store.
    However, it would be very limiting if any assumptions were made about the underlying
    data structure or methods for the stored items. Therefore, parameterization of
    containers allows the container and its methods to explicitly declare trait bounds
    that are expected from stored types. All other characteristics of the stored item
    will be parameterized.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完全泛型代码的一个主要例子是内置的容器数据结构。向量和HashMap必须必然知道它们存储的对象的类型。然而，如果对底层数据结构或存储项的方法有任何假设，这将非常限制性。因此，容器的参数化允许容器及其方法显式声明期望从存储类型中获得的特征界限。存储项的所有其他特征都将被参数化。
- en: Investigating generics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查泛型
- en: Generics refers to the practice of parameterizing classes in object-oriented
    programming languages. Rust does not have an exact equivalent of classes. However,
    the concept of datatypes paired with a trait is very similar to a class if used
    in that sense. So, in Rust, generics would refer to the parameterization of datatypes
    and traits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是指参数化面向对象编程语言中的类。Rust没有类的确切等效物。然而，如果从那种意义上使用，数据类型与特质的组合概念与类非常相似。因此，在Rust中，泛型将指数据类型和特质的参数化。
- en: 'Choosing a common example from OOP, let''s look at the animal kingdom. In the
    following code, we will define some animals and actions that they can take. First,
    let''s define two animals:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以面向对象编程（OOP）的常见示例，让我们看看动物王国。在以下代码中，我们将定义一些动物和它们可以执行的动作。首先，让我们定义两种动物：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s define an `animal trait` and its implementations. All animals will
    have the `max_speed` method. Here is the code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`动物特征`及其实现。所有动物都将具有`max_speed`方法。以下是代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we have defined the Rust equivalent of interfaces from OOP. However,
    we have not parameterized anything, so nothing here should be considered generic.
    We will add the following code, a trait defining the concept of an animal chasing
    a toy. First, we will define the concept of a toy. This will follow the same OOP-like
    pattern as in the preceding code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了Rust中面向对象编程（OOP）接口的等效物。然而，我们没有对任何东西进行参数化，因此这里不应该有任何泛型内容。我们将添加以下代码，一个定义动物追逐玩具概念的特质。首先，我们将定义玩具的概念。这将遵循与前面代码相同的面向对象模式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we have two traits, each having two possible implementations. Let''s define
    an action for an animal chasing a toy. More than one possible animal has been
    defined, and more than one possible toy, so we will need to use a generic definition.
    The struct definition also constrains each parameter with a trait bound, which
    adds additional information to the `struct`; now, we can guarantee that each animal
    will implement the `Animal` trait and similarly, each toy will implement `Toy`.
    We will also define some associated logic that uses the parameterized traits''
    methods. The code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个特质，每个特质都有两种可能的实现。让我们定义一个动物追逐玩具的动作。已经定义了多个可能的动物和多个可能的玩具，因此我们需要使用泛型定义。结构定义还通过特质界限约束每个参数，这为`struct`添加了额外的信息；现在，我们可以保证每个动物都将实现`Animal`特质，同样，每个玩具也将实现`Toy`。我们还将定义一些使用参数化特质方法的关联逻辑。以下是代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, we have defined a generic `struct` and `trait` that accepts types,
    knowing only some limited information regarding the traits of each object. Multiple
    traits, or none, can be specified to declare all expected interfaces. Multiple
    traits or lifetime bounds can be declared with the `'l + Trait1 + Trait2` syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经定义了一个通用的 `struct` 和 `trait`，它接受类型，只知道一些关于每个对象特质的有限信息。可以指定多个特质或没有任何特质来声明所有预期的接口。可以使用
    `'l + Trait1 + Trait2` 语法来声明多个特质或生命周期界限。
- en: Investigating parametric polymorphism
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探究参数多态
- en: Another common application of parameterization are for functions. For the same
    reasons that we would want to parameterize data structures or traits, we also
    should consider parameterization of functions. Parameterizing functions is called
    **parametric polymorphism**. Polymorphism is Greek for multiple forms or, sometimes
    in modern usage, it can mean multiple arrows. The word indicates that one function
    has multiple implementations or multiple ground type signatures.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个参数化的常见应用是函数。出于我们想要参数化数据结构或特质的原因，我们也应该考虑函数的参数化。函数的参数化被称为**参数多态**。多态在希腊语中意为多种形式，有时在现代用法中，它也可以意味着多个箭头。这个词表明一个函数有多个实现或多个基类型签名。
- en: 'For a simple example of a parametric function, we can imagine a generic multiply
    by three function. Here is the implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个参数化函数的简单示例，我们可以想象一个泛型乘以三的函数。以下是实现：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `raise_by_three` function does not know what `Mul` does. `Mul` is
    a trait and abstract behavior, which also specifies an associated type, `Output`.
    It is not possible to generically raise `x.pow(3)` here because `x` may not be
    a numerical type. At the very least, we do not know whether `x` is a floating
    type or an integral type. So instead, we use the available `Mul` trait to multiply
    `x` three times. This may seem like a strange thing to do, but the concept becomes
    clearer in context.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`raise_by_three` 函数不知道 `Mul` 做什么。`Mul` 是一个特质和抽象行为，它还指定了一个关联类型，`Output`。在这里无法泛型地提升
    `x.pow(3)`，因为 `x` 可能不是数值类型。至少，我们不知道 `x` 是浮点类型还是整型。因此，我们使用可用的 `Mul` 特质将 `x` 乘以三次。这看起来可能有些奇怪，但在上下文中这个概念会变得清晰。
- en: 'First, consider the application in regard to floating and integral types. This
    usage is straightforward but does not seem very useful yet. We already have a
    working `raise by three` expression, as long as we know and have the original
    floating or integral type. So, why wouldn''t we just use the built-in expression?
    First, let''s just compare the two options in code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑应用于浮点型和整型。这种用法很简单，但似乎还没有什么用处。我们已经有了一个工作的 `raise by three` 表达式，只要我们知道并拥有原始的浮点型或整型。那么，我们为什么不直接使用内置的表达式呢？首先，让我们比较两种选项的代码：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second option seems much more preferable, and it is. However, the second
    option also assumes we know the full type of `u64` or `f64` for each argument.
    Let''s look at what happens if we erase some type information:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择似乎更可取，而且确实是。然而，第二种选择也假设我们知道每个参数的 `u64` 或 `f64` 的完整类型。让我们看看如果我们擦除一些类型信息会发生什么：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After we lose access to the underlying types, we are quickly restricted in regard
    to what operations we can perform. Generic programming is great in the respect
    that it can reduce work in the long term; however, it also requires very explicit
    declaration and implementation of all interfaces that are used. Here, you can
    see that we must declare `Copy` as a trait bound, meaning the ability to copy a
    variable from one memory location to another. Another low-level trait is `Sized`,
    which indicates that a datum has a known constant size at compile time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们失去对底层类型的访问后，我们很快就会在可以执行的操作方面受到限制。泛型编程在长期减少工作量方面很出色；然而，它也要求非常明确地声明和实现所有使用的接口。在这里，你可以看到我们必须将
    `Copy` 声明为特质界限，这意味着能够将变量从一个内存位置复制到另一个位置。另一个低级特质是 `Sized`，它表示数据在编译时有一个已知的常量大小。
- en: 'If we look at the `HashMap` declaration, we can see why this abstraction is
    often necessary:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `HashMap` 的声明，我们可以看到为什么这种抽象通常是必要的：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each hash key must implement `Hash` and `Eq`, meaning it must be hashable and
    comparable. Other than that, no traits are expected and thus the whole data structure
    remains very generic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个哈希键必须实现 `Hash` 和 `Eq`，这意味着它必须是可哈希的且可比较的。除此之外，没有其他特质被期望，因此整个数据结构保持非常通用。
- en: 'Just as functions can be parameterized, functions as arguments can also be
    parameterized. There are two general forms of functions as parameters—closures
    and function pointers. Function pointers are not permitted to carry state. Closures
    can carry state but have a variable size which is independent of their declared
    type. Function pointers can be promoted to closures automatically:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如函数可以被参数化一样，作为参数的函数也可以被参数化。函数作为参数有两种一般形式——闭包和函数指针。函数指针不允许携带状态。闭包可以携带状态，但大小是独立于其声明的类型的。函数指针可以自动提升为闭包：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Closures can also be parameterized in a similar fashion. This case is a bit
    more common. If you are wondering whether to use a function pointer or a closure,
    use the closure. Function pointers can always be promoted to closures. Also, this
    code introduces the `where` syntax; `where` clauses permit trait bounds to be
    declared in a more readable form. Here is the code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包也可以以类似的方式参数化。这种情况更为常见。如果你在考虑是否使用函数指针或闭包，请使用闭包。函数指针总是可以被提升为闭包。此外，这段代码引入了 `where`
    语法；`where` 子句允许以更可读的形式声明特质界限。以下是代码：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see how easy it is to wrap a function pointer into a closure. Closures
    are a good abstraction and very powerful when used correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到将函数指针包装成闭包是多么容易。闭包是一个很好的抽象，并且当正确使用时非常强大。
- en: Investigating generalized algebraic datatypes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究泛化代数数据类型
- en: Sometimes, it is desirable to have the type system carry more information than
    normal. If we look at the process of compilation, types occupy a space between
    the program code and the program executable. The code can take the form of text
    files before compilation or an abstract syntax tree such as those manipulated
    by Rust macros. Program executables consist of the resulting combination of all
    Rust primitives like expressions, functions, datatypes, traits, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望类型系统携带比正常更多的信息。如果我们看看编译过程，类型位于程序代码和程序可执行文件之间。代码在编译前可以以文本文件的形式存在，或者像 Rust
    宏那样操作的抽象语法树。程序可执行文件由所有 Rust 原始元素（如表达式、函数、数据类型、特质等）的组合结果组成。
- en: Right in the middle, it is possible to introduce a new concept called **algebraic
    data types **(**ADTs**). ADTs are technically an extension of Rust primitives,
    though it is important to note how much extra type information is used for ADTs.
    This technique involves preserving extra type information into the executable.
    Extra run time decision-making is a step towards dynamic typing and foregoes optimizations
    available to static compilation. The result is a somewhat less efficient programming
    primitive, but also a primitive that can describe concepts that are otherwise
    difficult to approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正在中间，可以引入一个新概念，称为**代数数据类型**（**ADTs**）。技术上，ADTs 是 Rust 原始元素的扩展，尽管重要的是要注意 ADTs
    使用了多少额外的类型信息。这种技术涉及将额外的类型信息保留到可执行文件中。额外的运行时决策是向动态类型迈进的一步，并放弃了静态编译可用的优化。结果是编程原语稍微低效，但也是一个可以描述其他情况下难以接近的概念的原语。
- en: Let's look at one example—deferred computation. When we describe a relation
    of different values and expressions, we normally just write this code into the
    program directly. However, what would we do if we wanted to separate the code
    step from the execution step? To accomplish this, we start building something
    called a **domain-specific language**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子——延迟计算。当我们描述不同值和表达式的关联时，我们通常只是直接将这段代码写入程序中。然而，如果我们想将代码步骤与执行步骤分开，我们会怎么做？为了实现这一点，我们开始构建一个称为**领域特定语言**的东西。
- en: 'For a concrete example, consider that you are building a JIT (dynamically compiled) interpreter
    for JavaScript. The Mozilla project has several projects dedicated to JS engines
    built in Rust ([https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/](https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/)).
    This is a real application for which Rust is well-suited. To use an ADT in a JIT
    compiled interpreter, we want two things:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个具体的例子来说，假设你正在构建一个用于 JavaScript 的 JIT（动态编译）解释器。Mozilla 项目有几个项目是专门针对用 Rust
    构建的 JS 引擎的（[https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/](https://blog.mozilla.org/javascript/2017/10/20/holyjit-a-new-hope/))。这是一个非常适合
    Rust 的实际应用。要在 JIT 编译的解释器中使用 ADT，我们希望得到两件事：
- en: To evaluate ADT expressions directly within the interpreter
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解释器中直接评估 ADT 表达式
- en: To compile ADT expressions if selected for compilation
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果选择了编译 ADT 表达式
- en: 'So, any part of our JavaScript expressions can either be interpreted or compiled
    at any time. If an expression is compiled, then we want all further evaluations
    to use the compiled version. The key to implementing this cleanly is to put some
    extra weight on the type system. These heavy type definitions are the essence
    of the ADT concept. Here is a definition of a very small subset of JavaScript
    using an ADT:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的JavaScript表达式中的任何部分都可以在任何时候被解释或编译。如果一个表达式被编译，那么我们希望所有后续的评估都使用编译版本。实现这一点的关键是给类型系统增加一些额外的权重。这些重型类型定义是ADT概念的精髓。以下是一个使用ADT定义JavaScript非常小子集的示例：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we can see that each intermediate expression has enough information to
    be evaluated, but also has enough information to be compiled. We could have easily
    wrapped the `Add` or `Mul` operator into closures, but that would disallow JIT optimization.
    We need to maintain the full representation here in order to permit JIT compilation.
    Also, note the indirection between each point where the program decides whether
    to evaluate an expression or to call into compiled code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每个中间表达式都有足够的信息来评估，同时也有足够的信息来编译。我们本可以将`Add`或`Mul`运算符包装在闭包中，但这将不允许JIT优化。我们需要在这里保持完整的表示，以便允许JIT编译。此外，请注意程序在决定评估表达式或调用编译代码之间的间接引用。
- en: 'The next step is to implement an evaluation program for each expression form.
    We could break this into traits, or define the evaluation as one larger function.
    To keep the functional style, we will define a single function. To evaluate an
    expression, we will use a pattern match on the `JSJITorExpr` expression. This
    JIT expression breaks down into either a code address which is run by calling
    the `jump` function or an expression which must be evaluated dynamically. This
    pattern gives us the best of both worlds, mixing compiled code and interpreted
    code together. The code is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为每种表达式形式实施一个评估程序。我们可以将其分解为特性，或者定义一个更大的函数作为评估。为了保持函数式风格，我们将定义一个单一函数。为了评估一个表达式，我们将使用对`JSJITorExpr`表达式的模式匹配。这种即时编译表达式可以分解为通过调用`jump`函数运行的代码地址，或者必须动态评估的表达式。这种模式为我们提供了两者的最佳结合，将编译代码和解释代码混合在一起。代码如下：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another example of the ADT concept is in heterogeneous lists. Heterogeneous
    lists are not like other generic containers, such as vectors. Rust vectors are
    homogeneous, meaning all items are required to have the same type. By comparison,
    a heterogeneous list can have any mix of types of elements. This may sound like
    a tuple, but tuples have a fixed length and flat type signature. Similarly, heterogeneous
    lists must have a length and type signature known at compile time, but that knowledge
    can be achieved incrementally. Heterogeneous lists are permitted to work with
    partial knowledge of the list type, parameterizing the knowledge that they do
    not need.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ADT概念的另一个例子是异构列表。异构列表不像其他泛型容器，如向量。Rust向量是同质的，意味着所有项目都必须具有相同的类型。相比之下，异构列表可以包含任何类型的元素混合。这听起来可能像元组，但元组具有固定的长度和平坦的类型签名。同样，异构列表必须具有在编译时已知长度和类型签名，但这种知识可以逐步实现。异构列表允许在部分了解列表类型的情况下工作，参数化它们不需要的知识。
- en: 'Here is an example implementation of a heterogeneous list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个异构列表的示例实现：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice how this definition intentionally uses a trait to obscure type information,
    without which, such a definition would be impossible. A declaration of an `HList`
    would look like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个定义故意使用特性来隐藏类型信息，没有这些信息，这样的定义将是不可能的。一个`HList`的声明看起来如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rust can be a bit rigid with regards to type checking, at times. However, there
    are also many workarounds that permit complex behavior that might seem impossible
    at first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rust在类型检查方面有时可能有点僵化。然而，也有许多解决方案允许复杂的行为，这些行为一开始可能看起来是不可能的。
- en: Investigating parametric lifetimes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查参数化生命周期
- en: 'Lifetimes can get complicated quickly. For example, when a lifetime is used
    as a parameter, it is called a **parametric lifetime**. To cover the most common
    problems, we will break down the lifetime concept into four distinct concepts:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期可能会很快变得复杂。例如，当生命周期用作参数时，它被称为**参数化生命周期**。为了涵盖最常见的问题，我们将生命周期概念分解为四个不同的概念：
- en: Lifetimes on ground types
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础类型上的生命周期
- en: Lifetimes on generic types
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型上的生命周期
- en: Lifetimes on traits
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性上的生命周期
- en: Lifetime subtyping
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期子类型
- en: Defining lifetimes on ground types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在基础类型上定义生命周期
- en: A ground type is a type with no parameters. Defining lifetimes on ground types
    is the simplest possible case. All traits, fields, size, and any other information
    is directly available for group types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基础类型是一个没有参数的类型。在基础类型上定义生命周期是最简单的情况。所有特质、字段、大小以及任何其他信息对于组类型都是直接可用的。
- en: 'Here is a function declaring a lifetime on a ground type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在基础类型上声明生命周期的函数：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declaring lifetimes is often unnecessary. Other times, declaring lifetimes is
    necessary. The inference rules are complicated and are sometimes extended, so
    we will ignore that part for now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 声明生命周期通常是不必要的。有时，声明生命周期是必要的。推断规则很复杂，有时还会扩展，所以我们现在暂时忽略那部分。
- en: Defining lifetimes on generic types
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在泛型类型上定义生命周期
- en: Declaring lifetimes on generic types requires one additional consideration.
    All generic types that have a specified lifetime must be parameterized as having
    that lifetime. The parameter declaration must be compatible with how the parameter
    is used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛型类型上声明生命周期需要考虑一个额外的因素。所有具有指定生命周期的泛型类型都必须参数化为具有该生命周期。参数声明必须与参数的使用方式兼容。
- en: 'Here is an example that will fail:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个会失败的示例：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The struct definition uses the parameter `T` having a lifetime of `''a`; however,
    the parameter `T` is not required to have a lifetime compatible with `''a`.  The
    parameter `T` must be constrained by its own lifetime. By doing this, the code
    becomes as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结构定义使用了具有生命周期`'a`的参数`T`；然而，参数`T`并不需要与`'a`具有兼容的生命周期。参数`T`必须由其自己的生命周期约束。这样做后，代码如下：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that the parameter `T` has an explicit bound compatible with `'a`, the code
    will compile.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，参数`T`具有与`'a`兼容的显式约束，代码将能够编译。
- en: Defining lifetimes on traits
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特质上定义生命周期
- en: 'When defining, implementing, and instantiating an object implementing a trait,
    it is possible that both the object and trait will require a lifetime. Usually,
    it is possible to infer the lifetime of the trait from the lifetime of the object.
    When this is not possible, the programmer must declare a lifetime for the trait,
    which is compatible with all other constraints. The code is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义、实现和实例化实现特质的对象时，对象和特质都可能需要生命周期。通常，可以从对象的生命周期推断出特质的生命周期。当这不可能时，程序员必须声明一个与所有其他约束兼容的特质生命周期。代码如下：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining lifetime subtyping
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义生命周期子类型
- en: 'It is possible to have a single object that requires a long lifetime for itself
    but also needs a shorter lifetime for some of its components or methods. This
    can be accomplished by parameterizing multiple lifetimes. This usually works well
    unless the lifetimes come into conflict. The following is an example of multiple
    lifetimes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能存在一个对象，它本身需要一个较长的生命周期，但同时也需要某些组件或方法具有较短的生命周期。这可以通过参数化多个生命周期来实现。这通常工作得很好，除非生命周期发生冲突。以下是一个多个生命周期的示例：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Investigating parametric types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查参数化类型
- en: 'At this point, it shouldn''t be surprising to learn that all datatype declarations
    can be parameterized. It should be noted that when declaring parameterized datatypes,
    the lifetime parameters must be located ahead of the generic parameters. Refer
    to the following code for this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，了解到所有数据类型声明都可以参数化并不令人惊讶。需要注意的是，在声明参数化数据类型时，生命周期参数必须位于泛型参数之前。以下代码展示了这一点：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have also seen how traits can be parameterized. However, what happens when
    a datatype and a trait both need parameters for implementation? There is a special
    syntax for that, involving three parameter lists, and it looks like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了特质如何进行参数化。然而，当一个数据类型和特质都需要参数来实现时会发生什么？这有一个特殊的语法，涉及三个参数列表，看起来如下：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is one more special case that we should mention, and that is the case
    of method ambiguity. When multiple traits are implemented for a single type, it
    is possible for there to be multiple methods with the same name. To access the
    different methods, it becomes necessary to specify what `trait` is intended to
    be used when called. Here is an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应提及一个特殊情况，那就是方法歧义的情况。当一个类型实现了多个特质时，可能存在多个同名的方法。为了访问不同的方法，在调用时必须指定要使用哪个`trait`。以下是一个示例：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To call the method, we must use something called the **universal function call
    syntax**. There are two forms of the syntax, one short—the other longer. The short
    form is usually sufficient for resolving all but the most complicated of situations.
    Here is an example to match the preceding type definitions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用方法，我们必须使用称为**通用函数调用语法**的东西。该语法有两种形式，一种较短，另一种较长。短形式通常足以解决所有但最复杂的情况。以下是一个与前面的类型定义相匹配的示例：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are also several less documented syntax forms ([https://matematikaadit.github.io/posts/rust-turbofish.html](https://matematikaadit.github.io/posts/rust-turbofish.html))
    syntax forms available for various scenarios where parameters need to be explicitly
    provided. Rust does not currently have direct type ascription currently, so hints
    for the compiler are provided as necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些不太文档化的语法形式（[https://matematikaadit.github.io/posts/rust-turbofish.html](https://matematikaadit.github.io/posts/rust-turbofish.html)）适用于需要显式提供参数的各种场景。目前Rust没有直接的类型注解，因此编译器需要时提供提示。
- en: Applying parameterization concepts
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用参数化概念
- en: We have explored the concepts of generics and parameterization. Let's scan through
    the project to see if any concepts would be appropriate to use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了泛型和参数化的概念。让我们扫描一下项目，看看是否有任何概念适合使用。
- en: Parameterizing data
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化数据
- en: 'Parametric data allows us to declare only the minimal amount of semantic information
    required. Instead of specifying a type, we can specify a generic parameter having
    a trait. Let''s start by looking at `physics.rs` type declarations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化数据允许我们仅声明所需的最小语义信息量。我们不是指定一个类型，而是指定一个具有特质的泛型参数。让我们首先查看`physics.rs`中的类型声明：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we remember, where we used `physics.rs` when we designed the new `MotorInput`
    implementation, we should notice a problem. We wanted to abstract `MotorInput`
    behavior behind a trait; however, `ElevatorState` specifies a specific implementation.
    Let''s redefine `ElevatorState` to use a generic type for `motor_input`. The parameter
    should implement all traits of `MotorInput`, and will, therefore, become as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记得，当我们设计新的`MotorInput`实现时使用了`physics.rs`，我们应该注意到一个问题。我们希望将`MotorInput`的行为抽象在特质之后；然而，`ElevatorState`指定了一个特定的实现。让我们重新定义`ElevatorState`以使用`motor_input`的泛型类型。该参数应该实现`MotorInput`的所有特质，因此将如下所示：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This may look acceptable at first glance, but now the `MotorInput` parameter
    and all traits must be declared along with every mention of any type that wraps
    `MotorInput` or `ElevatorState`. We get an explosion of parameters. There must
    be a better way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这乍一看可能看起来可以接受，但现在`MotorInput`参数和所有特质都必须在提及任何包装`MotorInput`或`ElevatorState`类型的任何地方声明。我们得到了参数的爆炸。必须有一种更好的方法。
- en: 'Parameter explosion, in this case, would look like the following, at every
    type declaration, trait declaration, implementation, function, or expression:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，参数爆炸看起来如下，在每个类型声明、特质声明、实现、函数或表达式中：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is all just for one parameter! Fortunately, there is another solution to
    this problem. The technique uses something called **trait objects**. A trait object
    is an object implementing a trait but having no known type at compile time. Trait
    objects, because they have no concrete type, do not need to be parameterized.
    The downside of trait objects are that they cannot be sized, and therefore must
    usually be handled indirectly through a Box or some other sized container. Any
    attempt to size a trait object will result in a compiler error. Similarly, any
    trait that has a static method, or is otherwise not object-safe, cannot be used
    with a trait object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是针对一个参数！幸运的是，还有另一个解决这个问题的方法。该技术使用一种称为**特质对象**的东西。特质对象是一个实现了特质的对象，但在编译时没有已知类型。由于特质对象没有具体类型，因此不需要参数化。特质对象的缺点是它们不能被大小化，因此通常必须通过Box或其他大小容器间接处理。任何尝试大小化特质对象的行为都会导致编译器错误。同样，任何具有静态方法或不是对象安全的特质都不能与特质对象一起使用。
- en: 'We can rewrite the `MotorInput` and `ElevatorState` objects to use trait objects
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`MotorInput`和`ElevatorState`对象重写为使用特质对象，如下所示：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we declare that a `MotorInput` trait has two subtraits specifying the
    behavior. Our `ElevatorState` declaration does not require a parameter; however,
    the `MotorInput` trait object must be wrapped in a `Box`. This layer of indirection
    is required due to the inability of the compiler to size the `MotorInput` trait
    object for compilation. Also, because `MotorInput` does not implement `Sized`,
    it cannot use the `Clone` or `serde` macros. Some of our code needs to be changed
    to accommodate this, but it is not overwhelming.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个`MotorInput`特质有两个子特质来指定行为。我们的`ElevatorState`声明不需要参数；然而，`MotorInput`特质对象必须被包裹在一个`Box`中。由于编译器无法为`MotorInput`特质对象的大小进行编译，这一层间接性是必需的。此外，因为`MotorInput`没有实现`Sized`，它不能使用`Clone`或`serde`宏。我们需要对一些代码进行修改以适应这一点，但这并不令人难以承受。
- en: Parameterizing functions and trait objects
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化函数和特质对象
- en: 'In our motor controllers, we make another baseless assumption about the motor.
    Namely, that a flat force will be generated per voltage input. The suspect code
    in the motor controllers looks like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电机控制器中，我们对电机做出了另一个无根据的假设。即，每个电压输入将产生一个平坦的力。电机控制器中的可疑代码如下所示：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The assumption may be wrong with respect to the motor being more or less efficient
    than assumed. Also, the assumption that generated force will be linear with respect
    to voltage is unlikely. To satisfy the requirements of our motor controller and
    the physics simulation, we require one function that will consider the physical
    motor being used and convert the voltage to force. Similarly, we need the inverse
    function to convert the target force to target voltage. We can write these plainly
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 关于电机比预期更有效率或更无效率的假设可能是错误的。同样，生成的力与电压成线性关系的假设也不太可能。为了满足我们的电机控制器和物理模拟的要求，我们需要一个函数来考虑所使用的物理电机，并将电压转换为力。同样，我们还需要一个逆函数将目标力转换为目标电压。我们可以简单地按以下方式编写这些函数：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is nice to look at, but it doesn''t fit into the goal of abstracting the
    concept of a physical motor. We should define these functions as methods on an
    interface. This way, we can use the trait object pattern again to abstract away
    the type of motor, as well as the type parameter for the motor. The code becomes
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很棒，但它并不符合抽象物理电机概念的目标。我们应该将这些函数定义为接口上的方法。这样，我们就可以再次使用特质对象模式来抽象电机的类型，以及电机的类型参数。代码如下：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After declaring the `Motor` trait and an implementation, we can integrate this
    definition with the `ElevatorSpecification` struct. The result is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了`Motor`特质及其实现之后，我们可以将这个定义与`ElevatorSpecification`结构体集成。结果是如下所示：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again, we lose the ability to use certain derive macros, but the type signature
    is much cleaner at least. The usage in the motor controllers now supports multiple
    motors:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们失去了使用某些`derive`宏的能力，但至少类型签名要干净得多。现在，电机控制器中的使用支持多个电机：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that there are some potential tradeoffs between different types of
    parameterization or generic behavior. On one hand, parameters can quickly become
    overwhelming to keep track of. On the other, side trait objects break many languages
    with features such as derive macros, anything that is not object-safe, requiring
    a concrete type, and so on. Choosing the right tool is an important decision that
    requires weighing the merits of each option.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在参数化或泛型行为的不同类型之间可能存在一些潜在的权衡。一方面，参数可能会很快变得难以跟踪。另一方面，特质对象破坏了许多具有诸如`derive`宏、非对象安全特性、需要具体类型等功能的语言。选择正确的工具是一个重要的决定，需要权衡每个选项的优点。
- en: Parametric traits and implementations
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化特质和实现
- en: Now, we have successfully implemented `Motor` and `MotorInput` as trait objects.
    However, we sacrificed nice things like `Clone`, `Serialize`, `Deserialize`, and
    `Debug` to accomplish this. Can we reclaim those functionalities?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地将`Motor`和`MotorInput`实现为特质对象。然而，为了实现这一点，我们牺牲了诸如`Clone`、`Serialize`、`Deserialize`和`Debug`等美好的特性。我们能否恢复这些功能？
- en: 'First, let''s try to duplicate the functionality. We will call these bundled
    traits `ElevatorStateClone` and `ElevatorSpecificationClone`. The signatures should
    look something like the following (the trait implementations are available in
    the `src/physics.rs` file):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试复制这些功能。我们将把这些捆绑的特质称为`ElevatorStateClone`和`ElevatorSpecificationClone`。签名可能看起来如下（特质实现可以在`src/physics.rs`文件中找到）：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These traits provide the bare minimum functionality to get us back to where
    we were previously with serialization and copy semantics. The major downside is
    that each definition is quite verbose. Additionally, the serialization turns into
    a tuple, rather than going directly back and forth between the correct type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特质提供了最基本的功能，让我们能够回到之前使用序列化和复制语义的地方。主要的缺点是每个定义都很冗长。此外，序列化变成了一个元组，而不是直接在正确的类型之间来回转换。
- en: 'So, what precisely is the problem with trait objects? We know that they must
    be wrapped in `Box` types to circumvent the unknown size. Is this the problem?
    Here is a program to test this theory:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，特质对象究竟有什么问题呢？我们知道它们必须被`Box`类型包裹以规避未知的大小。这是问题所在吗？这里有一个程序来测试这个理论：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'So, `Box` types can be serialized. The problem, then, must be with the trait
    object. Let''s try the same thing with a trait object to see what happens:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`Box`类型可以序列化。那么，问题肯定出在特质对象上。让我们用特质对象来做同样的尝试，看看会发生什么：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When compiling this last snippet, we get the error, `` the trait `serde::Deserialize<'_>`
    is not implemented for `T` ``. So, we can see that the individual structs `S1`
    and `S2` both implement `Deserialize`, but that information is obscured. The trait
    object `T` itself must implement `Deserialize`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译这个最后的片段时，我们得到错误：“为`T`没有实现`serde::Deserialize<'_>`特质”。因此，我们可以看到单独的结构体`S1`和`S2`都实现了`Deserialize`，但这个信息被隐藏了。特质对象`T`本身必须实现`Deserialize`。
- en: 'Making the first attempt at serializing the trait object `T`, we can follow
    the instructions for writing custom serialization. The result should be something
    like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试序列化特质对象`T`的第一步中，我们可以遵循编写自定义序列化的说明。结果应该是以下类似的内容：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a bit of a mess, but the important parts are that we want to write
    `S1` or `S2` to the serializer and check for those tags to deserialize. Essentially,
    what we are trying to create is a side enum to exist just for the purpose of serialization.
    Somehow, the serializer needs to know whether `T` is an `S1` or `S2` through the
    interface, so why not, in turn, provide a method on `T` that will return an enum?
    Enums are also serializable with macros, so we could pass that automatic serialization
    through to `T`. Let''s try that, starting with the type and trait definitions,
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点乱，但重要的是我们想要将`S1`或`S2`写入序列化器，并检查那些标签以反序列化。本质上，我们试图创建一个仅用于序列化的辅助枚举。某种方式下，序列化器需要知道`T`是`S1`还是`S2`通过接口，所以为什么不反过来提供一个返回枚举的方法呢？枚举也可以通过宏进行序列化，所以我们可以将自动序列化传递给`T`。让我们尝试一下，从类型和特质定义开始，如下所示：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we can see that there is no issue in permitting a method on a trait object
    that turns the object into an enum. This relation is natural and provides an escape
    hatch to convert back and forth between the trait objects and its internal representation.
    Now, to implement serialization, we just need to wrap and unwrap the enum serializers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到允许在特质对象上有一个将对象转换为枚举的方法没有问题。这种关系是自然的，并提供了一个逃生门，可以在特质对象及其内部表示之间来回转换。现在，为了实现序列化，我们只需要包装和展开枚举序列化器：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That wasn't so bad, was it? With this technique, we can hide parameters behind
    trait objects while still benefiting from the direct access to data and macro-derived
    traits. There is a little bit of boilerplate here. Luckily though, for each macro,
    the code is almost identical for whatever type you are using. Remember this one;
    it could be useful.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那并没有那么糟糕，对吧？使用这项技术，我们可以在保持对数据直接访问和宏推导特质优势的同时，将参数隐藏在特质对象后面。这里有一点点样板代码。幸运的是，对于每个宏，无论你使用什么类型，代码几乎都是相同的。记住这一点；它可能很有用。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the basic and deeper concepts of generic and parameterized
    programming. We learned how to add lifetime, type, and trait parameters to declarations
    of types, traits, functions, and implementations. We also examined advanced techniques
    to selectively preserve or obscure type information as desired.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了泛型和参数化编程的基本和深入概念。我们学习了如何向类型、特质、函数和实现声明中添加生命周期、类型和特质参数。我们还考察了根据需要选择性地保留或隐藏类型信息的高级技术。
- en: Applying these concepts to the elevator simulation, we observed how parameterization
    and generics can create fully abstract interfaces. By using trait objects, it
    is possible to completely separate trait interfaces from any implementation. We
    also observed the downsides or difficulties of parameterization and generics.
    Excessive use of parameterization can lead to parameter leaks, potentially requiring
    all code that interfaces with an interface to also become parameterized itself.
    On the other hand, we observed the difficulty associated with erasing type information
    using trait objects. Choosing the right amount of information to preserve is important.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些概念应用于电梯模拟，我们观察到了参数化和泛型如何创建完全抽象的接口。通过使用特质对象，可以完全将特质接口与任何实现分离。我们还观察到了参数化和泛型的缺点或困难。过度使用参数化可能导致参数泄漏，可能需要与接口交互的所有代码本身也变得参数化。另一方面，我们观察到使用特质对象擦除类型信息时的困难。选择保留正确数量的信息很重要。
- en: In the next chapter, we will learn about applied project structure with complex
    requirements. The client will respond to the project proposal and your team will
    respond to new requirements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习具有复杂要求的实际项目结构。客户将对项目提案做出回应，而您的团队将对新的需求做出回应。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is an algebraic datatype?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是代数数据类型？
- en: What is polymorphism?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是多态性？
- en: What is parametric polymorphism?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是参数多态性？
- en: What is a ground type?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基类型？
- en: What is universal function call syntax?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是通用函数调用语法？
- en: What are the possible type signatures of a trait object?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特质对象的可能类型签名有哪些？
- en: What are two ways to obscure type information?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种方法可以隐藏类型信息？
- en: How is a subtrait declared?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明子特质？
