- en: Chapter 4. Structuring Data and Matching Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now we have only used simple data, but to do real programming, more composite
    and structured data values are needed. Among them are flexible arrays and tuples,
    enums, and structs that represent more object-like behavior, similar to that found
    in classical object-oriented languages. Options are another important type that
    are used to ensure that cases where no value is returned are accounted for. Then,
    we will look at pattern matching, which is another typical functional construct
    in Rust. However, we will start by looking more carefully at strings. We will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays, vectors, and slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting input from the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way Rust works with strings differs a bit to how strings work in other
    languages. All strings are valid sequences of Unicode (UTF-8) bytes. They can
    contain null bytes, but they are not null terminated as in C. Rust distinguishes
    two types of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal strings, which we have used until now, are string slices whose type
    is `&str`. The `&` character points out that the string slice is a reference to
    a string. They are immutable and have a fixed size. For example, the following
    bindings declare string slices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we care to explicitly annotate the string variable with its type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `&''static` command denotes that the string is statically allocated. We
    saw this notation earlier in [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*, when we declared global string
    constants. In that case, indicating the type was mandatory, but for a let binding,
    it is superfluous because the compiler infers the type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prints out: `Magician Merlin greets magician Gandalf with Hello,` `世界` `!`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These strings live as long as the program; they have the lifetime of the program,
    which is the static lifetime. They are described in the `std::str` module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A `String` on the other hand can grow dynamically in size (it is in fact a
    buffer), and so it must be allocated on the heap. We can create an empty string
    with the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each time the string grows, it has to be reallocated in the memory. So, for
    example, if you know that it will start out as 25 bytes , you can create the string
    by allocating this amount of memory as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This type is described in the `std::string` module. To convert a string slice
    into a String, use the `to_string` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `to_string()` method can be used to convert any object into a `String` (more
    precisely, any object that implements the `ToString` trait; we will talk about
    traits in the next chapter). This method allocates memory on the heap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If `str3` is a String, then you can make a string slice from it with `&str3`
    or `&str3[..]`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A string slice created this way can be considered as a view into the `String`.
    It is a reference to the interior of the String and making it has no cost involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer this way instead of `to_string()` when comparing strings because using
    `&[..]` doesn''t consume resources while `to_string()` allocates heap memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To build a String, we can use a number of methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` method: This appends a character to the String'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `push_str` method: This appends another string to the String'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see them in action in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to get the characters of a `String` one by one and in order, use
    the `chars()` method. This method returns an `Iterator`, so we can use the for
    in loop (see the *Looping* section of [Chapter 2](part0023.xhtml#aid-LTSU1 "Chapter 2. Using
    Variables and Types"), *Using Variables and Types*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `M - e - r - l - i - n -`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To loop over the parts of a `String` that are separated by whitespace, we can
    use the `split()` method, which also returns an `Iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `q` `/ Level / 1 / is / finished / - / Rise / up / to / Level
    / 2 /`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the first part of a `String` that matches with another string, use
    the `replace` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code allocates new memory for the modified `str5` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write a function that takes a string as an argument, always declare
    it as a string slice, which is a view into the string, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that passing a String `str1` as argument allocates memory,
    so we better pass it as a slice. The easiest and most elegant way to do this is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Consult the documentation at [http://doc.rust-lang.org/std/str/](http://doc.rust-lang.org/std/str/)
    and [http://doc.rust-lang.org/std/string/](http://doc.rust-lang.org/std/string/)
    for more functionality. Here is a schema to see the difference between the two
    string types more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| String | String slice (&str) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mutable – heap memory allocationmodule: std::string | fixed size – view on
    String – reference(&)module: std::str |'
  prefs: []
  type: TYPE_TB
- en: Arrays, vectors, and slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we have a bunch of alien creatures to populate a game level, then we
    would probably want to store their names in a handy list. Rust''s array is just
    what we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To make an array, separate the different items by commas and enclose the whole
    thing within `[ ]` (rectangular brackets). All the items must be of the same type.
    Such an array must be of a fixed size (this must be known at compile time) and
    cannot be changed; this is stored in one contiguous piece of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the items have to be modifiable, declare your array with `let mut`; however,
    even then the number of items cannot change. The aliens array could be of the
    type that is annotated as `[&str; 4]` where the first parameter is the type of
    the items and the second is their number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to initialize an array with three `Zuxus`, that''s easy too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'How would you then make an empty array? This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access individual items with their index, starting from 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The number of items in the array is given by `aliens.len()`; so, how would you
    get the last item? Exactly! By using `aliens[aliens.len() - 1]`. Alternatively,
    this can be found by using `aliens.iter().last().unwrap();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pointers to arrays use automatic dereferencing so that you do not need to use
    `*` explicitly, as demonstrated in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints: `Third item via pointer: Shirack`. What do you think will happen
    when we try to change an item as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you didn't think that Rust would allow this, did you? Unless you
    told it explicitly that aliens can change with let `mut aliens = […];` then it
    is alright!
  prefs: []
  type: TYPE_NORMAL
- en: 'The index is also checked at runtime to be within the array bounds of 0 and
    `aliens.len();` if it is not, the program will crash with a runtime error or panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to go through the items successively one by one and print them out
    or do something useful with them, we can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This works and it gives us the index for each item, which might be useful.
    However, when we use the index to fetch each consecutive item, Rust also has to
    check each time whether we are still within the bounds of the array in memory.
    That''s why this is not very efficient, and in the *Iterators* section of [Chapter
    5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing Code with Higher-order Functions
    and Parametrization"), *Generalizing Code with Higher-order Functions and Parametrization*,
    we will see a much more efficient way by iterating over the items as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop can be written even shorter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, it is more practical to work with a kind of array that can grow (or
    shrink) in size because it is allocated on the heap. Rust provides this through
    the `Vec` vector type from the `std::vec` module. This is a generic type, which
    means that the items can have any `T` type, where `T` is specified in the code;
    for example, we can have vectors of the `Vec<i32>` type or the `Vec<&str>` type.
    To indicate that this is of the generic type, it is written as `Vec<T>`. Again,
    all elements must be of the same `T` type. We can make a vector in two ways, with
    `new()` or with the `vec!` macro. These are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the type is indicated explicitly with `Vec<i32>`; in the
    second case, this is done by giving the first item an `i32` suffix, but this is
    usually optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also make a new vector and allocate an initial memory size to it, which
    can be useful if you know in advance that you will need at least that many items.
    The following initializes a vector for signed integers with a memory allocated
    for 25 integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We need to provide the type here, otherwise the compiler would not be able to
    calculate the amount of memory needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector can also be constructed from an iterator through the `collect()` method
    with a range, such as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'which prints out: `Collected the range into: [0, 1, 2, 3, 4, 5, 6]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexing, getting the length, and looping over a vector works the same as with
    arrays. For example, a `for` loop over a vector can be written simply as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new item to the end of a vector with `push()`, remove the last item with
    `pop()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If a function needs to return many values of the same type, you can make an
    array or vector with these values and return that object.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What would you do if you want to do something with a part of an array or a vector?
    Perhaps, your first idea is to copy that part out to another array, but Rust has
    a safer and more efficient solution; take a slice of the array. No copy is needed,
    instead you get a view into the existing array, similar to how a string slice
    is a view into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose I only need the numbers 42, 47, and 45 from our `magic_numbers`
    vector. Then, I can take the following slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The starting index 1 is the index of 42, the last index 4 points to 54, but
    this item is not included. The `&` shows that we are referencing an existing memory
    allocation. Slices share the following with vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: They are generic and have the `&[T]` type for a `T` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their size does not have to be known at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the first section of this chapter, we saw that the sequence of characters
    in a `String` is given by the `chars()` function. Doesn't this look like an array
    to you? A `String` is backed up by an array if we look at the memory allocation
    of its characters; it is stored as a vector of bytes `Vec<u8>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we can also take a slice of the `&str` type from a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can collect the characters of a slice into a vector and sort them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out `M e i l n r` (capital letters come before small letters in
    the sort order). Here are some other examples of using the `collect()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `split()` takes a closure to determine on which character to split. Both
    the slice types, `&str` and `&[T]`, can be seen as views into `Strings` and vectors
    respectively. The following scheme compares the types that we just encountered
    (`T` denotes a generic type):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Fixed-size(stack allocated) | Slices |   | Dynamic size (growable)(heap allocated)
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | `&str``type: &[u8]` | is a view into | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| array type: `[T;size]` | slice type: `&[T]` | is a view into | Vector type:
    `Vec<T>` |'
  prefs: []
  type: TYPE_TB
- en: 'Perform the following exercise by referring to `Chapter 4/exercises/chars_string.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: Try out whether you can get the first or the fifth character of a string by
    using `[0]` or `[4]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the `bytes()` method with `chars()` on the `let greeting = "Hello,`
    `世界``!";` string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to combine a certain number of values of different types, then
    you can collect them in a tuple, which is enclosed between parentheses (`( )`)
    and separated by commas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `thor` is `(&str, bool, u32)`, that is: the tuple of the item''s
    types. To extract an item on an index, use a dot-syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to extract items to other variables is by *destructuring* the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `Thor has 3500 points of power`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here the `let` statement matches the pattern on the left with the right-hand
    side. The `_` indicates that we are not interested in the second item of `thor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples can only be assigned to one another or compared with each other if they
    are of the same type. A one-element tuple needs to be written: `let one = (1,);`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that needs to return some values of different types can collect
    them in a tuple and return that tuple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call this with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is: `This god Thor has now 10500 strength`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise by referring to the code at `Chapter 4/exercises/tuples_ex.rs)`:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to compare the tuples (2, 'a') and (5, false) and explain the error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an empty tuple. Haven't we encountered this before? So, the unit value
    is in fact an empty tuple!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, you might need to keep several values of possibly different types together
    in your program; for example, the scores of the players. Let us assume that the
    score contains numbers that indicate the health of the players and the level at
    which they are playing. The first thing that you can then do to clarify your code
    is to give these tuples a common name, such as struct Score or better still, you
    can indicate the types of the values: `struct Score(i32, u8)` and we can make
    a score as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'These are called tuple structs because they resemble tuples very much. The
    values contained in them can be extracted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `Health 73 - Level 2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple struct with only one field (called a newtype) gives us the possibility
    to create a new type that is based on an old one so that both have the same memory
    representation. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints: `weight is 250 kilograms`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will still have to remember what these numbers mean and to which
    players they belong. We can make coding much simpler by defining a struct with
    named fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be defined inside `main()` or outside it, although the latter is
    preferred. Now, we can make player instances or objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the curly braces (`{ }`) around the object and the `key: value` syntax.
    The `nname` field is a constant string, and Rust requires that we indicate its
    lifetime, how long this string will be needed in the program. We used the global
    scope, `&''static`, from the *Global constants* section in [Chapter 2](part0023.xhtml#aid-LTSU1
    "Chapter 2. Using Variables and Types"), *Using Variables and Types*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the fields of the instance with the dot-notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The struct variable has to be declared as mutable if the field values can change;
    for example, when the player enters a new level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: By convention, the name of a struct always starts with a capital letter and
    follows CamelCase. It also defines a type of its own, which is composed of the
    types of its items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like tuples, structs can also be destructured in a `let` binding, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `Player Dzenan has health 73`. This shows that you can rename
    fields, reorder them if you want, or leave fields out with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pointers carry out automatic dereferencing when accessing data structure elements,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Structs are quite similar to the records or structs in C or even classes in
    other languages. In [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing
    Code with Higher-order Functions and Parametrization"), *Generalizing Code with
    Higher-order Functions and Parametrization*, we will see how we can define methods
    on structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise by referring to the code in `Chapter 4/exercises/monster.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `Monster` struct with the health and damage fields. Then, make a `Monster`
    and show its condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If something can be only one of a limited number of named values, then define
    it as an enum. For example, if our game needs the compass directions, we could
    define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And then use it as shown in `main()` or another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The enum''s values can also be of other types or structs, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Enums are sometimes called union types or algebraic data types in other languages.
    If we make a `use` function at the start of the code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the type can be shortened, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Enums are really nice to bring clarity in your code, and they are used a lot
    in Rust. To apply them usefully in code, see the *Matching patterns* section of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Result and Option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we look at two kinds of enums that are pervasive in a Rust code. A *Result*
    is a special kind of enum that is defined in the standard library. It is used
    whenever something is executed, that can either end:'
  prefs: []
  type: TYPE_NORMAL
- en: Successfully, then an `Ok` value (of a certain type `T`) is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an error, then an `Err` value (of type `E`) is returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since this situation is so common, provision is made so that the value `T`
    and error `E` types can be as general or generic as possible. The Result enum
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'An *Option* is another enum that is defined in the standard library. It is
    used whenever there is a value, but there can also be a possibility that there
    is no value. For example, suppose our program expects to read a value from the
    console. However, when it is run as a background program by accident, it will
    never get an input value. Rust wants to be on the safe side whenever it is possible,
    so in this case, it is better to read the value as an Option enum with two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Some`, if there is a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`, if there is no value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This value can be of any type `T`, so option again is defined as a generic
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Getting input from the console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we want to capture the nicknames of our players before starting the
    game; how would we do that? Input/output functionality is handled by the `io`
    module in the `std` crate. It has a `stdin()` function to read input from the
    console. This function returns an object of the `Stdin` type, which is a reference
    to the input stream. `Stdin` has a `read_line(buf)` method to read a full line
    of input that ends with a new line character (when the user hits *Enter*). This
    input is read into a String buffer, `buf`. A method is a name for a function that
    is defined for a certain type, and it is called using dot notation, such as `object.method`
    (see [Chapter 5](part0046.xhtml#aid-1BRPS1 "Chapter 5. Generalizing Code with
    Higher-order Functions and Parametrization"), *Generalizing Code with Higher-order
    Functions and Parametrization*).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not good enough for Rust; it gives us the warning, `unused
    result which must be used`. Rust is foremost a safe language and we must be ready
    to cope with everything than can occur. Reading a line might work and supply the
    input value, but it can also fail; for example, if this code was running in the
    background on a machine so that no console was available to get input from.
  prefs: []
  type: TYPE_NORMAL
- en: How will you cope with this? Well, `read_line()` returns a Result value, which
    can either be a real value (an `Ok`) when everything works fine or an error value
    (an `Err`) when there is a problem. To cope with a possible error, we need an
    `ok()` function and an `expect()` function; `ok()` converts the Result into an
    Option value (which contains how many bytes were read) and `expect()` gives this
    value or shows its message when an error occurs. In Rust, a program panics when
    an error occurs that cannot be recovered from, and the string argument from `expect()`
    is displayed to tell us where it occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is written in Rust in a chained form (and is a bit unusual the first time
    you see it) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust allows us to write these successive calls on separate lines, which clarifies
    the code a lot for most people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code from the command line, we get the following conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess why `that''s a mighty name indeed!` appears on a new line? This
    is because the input `buf` still contains a newline character, `\n!` Luckily,
    we have a `trim()` method to remove trailing and leading whitespace from a string.
    If we insert the line shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get a correct output: `Riddick, that''s a mighty name indeed!`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case the input does not succeed, our program will crash with the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How would we read in a positive integer number from the console?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We read the number in from the console in a `buf` String buffer and `trim()`
    the value; `expect()` will show us the message if something goes wrong. However,
    what we have read in is still a `String`, so we must convert the `String` to a
    number.
  prefs: []
  type: TYPE_NORMAL
- en: The `parse()` method tries to convert the input to an unsigned 32-bit integer
    in this case. What it returns is in fact a Result value again; this can either
    be an integer (`Ok<u32>`) or an error (`Err`) when the conversion fails.
  prefs: []
  type: TYPE_NORMAL
- en: We will encounter more examples of Option and Result in the *Generics* section
    of *Chapter 5*, *Generalizing Code with Higher-order Functions and Parametrization*.
  prefs: []
  type: TYPE_NORMAL
- en: Matching patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'But how will we test whether `input_num` from the previous section, which is
    of the Result type, contains a value or not? When the value is an `Ok(T)` function,
    the `unwrap()` function can extract `T` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints: `Unwrap found 42`. However, when the result is an `Err` value,
    this lets the program crash with a panic, which is ``thread ''<main>'' panicked
    at ''called `Result::unwrap()` on an `Err` value''``. This is bad!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, no complex if – else constructs will be enough; we need Rust''s
    magical match here, which has a lot more possibilities than the switch in other
    languages, and is used frequently when handling errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `match` function tests the value of an expression against all possible values.
    Only the code (which can be a block) after the `=>` of the first matching branch
    is executed. All branches are separated by commas. In this case, the same number
    that is given as input is printed out. There is no fall through from one branch
    to the next, so a break statement is not necessary; this enables us to avoid a
    common bug in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to continue working with the return value of `match`, we have to bind
    that value to a variable, which is possible because match itself is an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This `match` extracts the number from `input_num` so that we can compare it
    with other numbers or calculate with it. Both branches must return a value of
    the same type; this is why we returned `0` in the `Err` case (supposing we expect
    a number greater than 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to get the Result or Option value is by using the `if let`
    construct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input_num` function is destructured and if it contains a value `val`,
    this is extracted. In certain cases, this can simplify the code, but you lose
    the exhaustive match check. The same principle can be applied inside a `while`
    loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: With `match`, all possible values must be covered, which is the case if we match
    with a Result, Option (`Some` or `None` is pretty exhaustive), or some other enum
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, look what happens when we test on a string slice for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This `match` on `magician` gives us an error: non-exhaustive patterns: `_`
    not covered. After all, there are other magicians besides "Gandalf" and "Sauron"!
    The compiler even gives us the solution: use an underscore (`_`) for all other
    possibilities; so, this is a complete match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be always on the safe side, use match when testing on the possible values
    of a variable or expression!
  prefs: []
  type: TYPE_NORMAL
- en: 'The left-hand side of a branch can contain several values if they are separated
    by a `|` sign or an inclusive range of values written as start … end. The following
    code snippet shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out: `It is contained in this range`. The matched value can be
    captured in a variable (here `num`) using the `@` symbol as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints: `42 is contained in this range`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matches are even more powerful than this; the expression that is being matched
    can be destructured on the left-hand side, and this can even be combined with
    the `if` conditions that are called *guards*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `This is a demigod called Loki`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that since `demi` is a Boolean, we don't have to write `if demi == true`.
    If you want to do nothing in a branch, then write `=> {}`. Destructuring works
    not only for tuples, like this example, but it can also be applied for structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you move the `_` branch from the last position upwards? See
    an example in `Chapter 4/exercises/pattern_match.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the `..` and `...` notations can be confusing, so here is a summary
    of the situations in Rust 1.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | What works | Does not work |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `for in` | `..` exclusive | `...` |'
  prefs: []
  type: TYPE_TB
- en: '| `Match` | `...` inclusive | `..` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we increased our capabilities for working with composite data
    in Rust, from strings, arrays and vectors, and slices of both, to tuples, structs,
    and enums. We also discovered that pattern matching, combined with destructuring
    and guards, is a very powerful tool for writing clear and elegant code.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will see that functions are much more powerful
    than we expected. Furthermore, we will discover that structs can have methods
    by implementing traits, almost like classes and interfaces in other languages.
  prefs: []
  type: TYPE_NORMAL
