- en: Working with Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing collections as iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `VecDeque`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `HashMap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `HashSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an own iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a slab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Rust** provides a very broad set of collections to use. We will look at most
    of them, see how they''re used, discuss how they''re implemented, and when to
    use and choose them. A big part of this chapter focuses on iterators. Much of
    Rust''s flexibility comes from them, as all collections (and more!) can be used
    as iterators. Learning how to use them is crucial.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we are going to use the *big O notation* to show how
    effective certain algorithms are. In case you don't know it yet, it is a way of
    telling how much longer an algorithm takes when working with more elements. Let's
    look at it briefly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d8a2575-71ea-413d-b7dc-12001272e5c0.png) means that an algorithm is
    going to take the same time, no matter how much data is stored in a collection.
    It doesn''t tell us how fast exactly it is, just that it''s not going to slow
    down with size. This is the realistic ideal for a function. A practical example
    for this is accessing the first number in an infinite list of numbers: no matter
    how many numbers there are, you''re always going to be able to instantly pick
    out the first one.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6bf9ef3-9e89-4e76-aeb5-a125f45e6a12.png) means that an algorithm is
    going to slow down by the same degree for every element. This is not good, but
    still okay. An example for this is printing all data in a `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cf884d4-c07a-4ba2-8d1c-2eaf8363dfa5.png) is really bad. It tells us
    that an algorithm is going to be slower and slower with every element. An example
    of it would be accessing data in a `for` loop nested in another `for` loop over
    the same data.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic collection is the vector, or `Vec` for short. It is essentially
    a variable-length array with a very low overhead. As such, it is the collection
    that you will use most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the command line, jump one folder up with `cd ..` so you're not in `chapter-one`
    anymore. In the next chapters, we are going to assume that you always started
    with this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter-two`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate into the newly-created `chapter-two` folder. For the rest of this chapter,
    we will assume that your command line is currently in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the folder `src`, create a new folder called `bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `vector.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code blocks to the file and run them with `cargo run --bin
    vector`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you can access single elements in a vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few methods apply to the whole vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can split a vector into two and combine them again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You might remember the `splice` method from JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working with very big datasets, you can optimize the performance
    of your vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is going to be a bit longer than the others, because:'
  prefs: []
  type: TYPE_NORMAL
- en: The vector is the most important collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of its core principles, like preallocation, apply to other collections
    as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes methods used on slices, which are also usable by many other collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: A vector can be created [9] by using the constructor pattern we mentioned earlier
    ([Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics,
    Using the Constructor Pattern*), and filled by calling `push` on it for every
    element we want to store [10]. Because this is such a common pattern, Rust provides
    you with a convenient macro called `vec!`[3]. While its end effect is the same,
    the macro is implemented with some nice performance optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the convenience `vec!` provides, other Rustacians have implemented
    similar macros for the other collections, which you can find here: [https://crates.io/crates/maplit.](https://crates.io/crates/maplit)'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to initialize a vector by repeating an element over and over, you
    can use the special calling syntax described in line [52] to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of `push` is `pop`: it removes the last element of the vector,
    and returns it if the vector wasn''t empty before. Because of the memory layout
    of `Vec`, which we are going to look at in the next section, this operation is
    done in ![](img/0eab5654-6646-4a88-b72b-0e4e435476b8.png) complexity. If you don''t
    know what that means, let me rephrase that: it''s pretty fast. This is why vectors
    can be nicely used as **First In, Last Out (FILO)** stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to modify the contents of a vector, `insert`[22],  `remove` [58],
    and `swap` [26] should be self-explanatory. Sometimes, though, you want to access
    a specific element in the vector. You can use `get` to borrow an element at an
    index [40], and `get_mut` to mutate it. Both return an `Option` that only contains
    `Some` element if the index was valid. Most times, though, this fine grade of
    error checking is unnecessary for vector access, as an out-of-bounds index is
    usually not recoverable, and will just be handled by unwrapping the `Option`.
    For this reason, Rust lets you call the `Index` operator, `[]`, on a `Vec` [45].
    This will automatically deduce its mutability and perform an unwrap for you.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of methods that help us work with the entire vector at once.
    `retain` is a very useful one that is also implemented by most other collections
    [64]. It accepts a so-called **predicate**, which is a fancy word for a function
    that returns `true` or `false`. It applies that predicate to every element, and
    only keeps the ones where it returned `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '`dedup` removes all *consecutive* duplicates [74]. This means that for the
    vector `[1, 2, 2, 3, 2, 3]`, `dedup` would result in `[1, 2, 3, 2, 3]`, as only
    the duplicate 2s were consecutive. Always remember this when using it, as it can
    cause bugs that are hard to find. If you want to remove *all* duplicates, you
    need to make them consecutive by sorting the vector first. If your elements are
    comparable, this is as simple as calling `.sort()` [84].'
  prefs: []
  type: TYPE_NORMAL
- en: Using `drain` creates a consuming iterator over your vector, accessing all elements
    and removing them in the process, leaving your vector empty [96]. This is useful
    when you have to *work through* your data and reuse your empty vector again afterwards
    to collect more work.
  prefs: []
  type: TYPE_NORMAL
- en: If you've never seen `splice` in another language, you're probably going to
    feel a bit confused at first about what it does. Let's take a look at it, shall
    we?
  prefs: []
  type: TYPE_NORMAL
- en: '`splice` does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a range. This range will be *removed* from the vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes an iterator. This iterator will be *inserted* into the space left open
    by the removal from the last step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It *returns* the removed elements as an iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle the returned iterator is going to be the topic of the recipe in
    the *Access collections as iterators* section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vector should always be your go-to collection. Internally, it is implemented
    as a continuous chunk of memory stored on the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6cc6a9c-c751-4371-8826-14b279ace5fd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The important keyword here is *continuous*, which means that the memory is
    very cache-friendly. In other words, the vector is pretty fast! The vector even
    allocates a bit of extra memory in case you want to extend it. Be careful, though,
    when inserting a lot of data at the beginning of the vector: the entire stack
    will have to be moved.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end, you can see a bit of *extra capacity*. This is because `Vec` and
    many other collections preallocate a bit of extra memory each time you have to
    move the block, because it has grown too large. This is done in order to prevent
    as many reallocations as possible. You can check the exact amount of total space
    of a vector by calling `capacity`[140] on it. You can influence the preallocation
    by initializing your vector with `with_capacity`[137]. Use it when you have a
    rough idea about how many elements you plan on storing. This can be a big difference
    in capacity when working with big amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: The extra capacity doesn't go away when shortening the vector. If you had a
    vector with a length of 10,000 and a capacity of 100,000 and called `clear` on
    it, you would still have a capacity of 100,000 preallocated. When working on systems
    with memory limitations, like microcontrollers, this can become a problem. The
    solution is calling `shrink_to_fit` periodically on such vectors [143]. This will
    bring the capacity as close as possible to the length, but it is allowed to still
    leave a little bit of preallocated space ready.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to optimize really big vectors is to call `swap_remove` [150]. Normally,
    when removing an element from a vector, all elements after it will be shifted
    to the left in order to preserve continuous memory. This is a lot of work when
    removing the first element in a big vector. If you don't care about the exact
    order of your vector, you can call `swap_remove` instead of `remove`. It works
    by swapping the element that is to be removed with the last element, and adjusting
    the length. This is great, because you don't create a *hole* that needs to be
    filled by shifting, and because swapping memory is a really fast operation in
    today's processors.
  prefs: []
  type: TYPE_NORMAL
- en: Using a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust provides an unusually large functionality for its string. Knowing it can
    save you quite some headache when dealing with raw user input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `string.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to split a string in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Essentially, being a kind of vector, a string can be created the same way by
    combining `new` and `push`; however, because this is really inconvenient, a `string`,
    which is an owned chunk of memory, can be created from a string slice (`&str`),
    which is either a borrowed string or a literal. Both of the ways to do it, that
    are shown in this recipe, are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Out of pure personal preference, we will use the first variant.
  prefs: []
  type: TYPE_NORMAL
- en: Before Rust `1.9`, `to_owned()` was the fastest way to create a string. Now,
    `to_string()` is equally performant and should be preferred, because it offers
    more clarity over what is done. We mention this because many old tutorials and
    guides have not been updated since then, and still use `to_owned()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All strings in Rust are valid Unicode in UTF-8 encoding. This can lead to some
    surprises, as a *character*, as we know it, is an inherently Latin invention.
    For instance, look at languages that have a modifier for a letter—is `ä` an own
    character, or is it merely a variation of `a`? What about languages that allow
    many combinations in extreme? What would that keyboard even look like? For this
    reason, Unicode lets you compose your *characters* from different *Unicode scalar
    values*. With `.chars()`, you can create an iterator that goes through these scalars
    [28]. If you work with non-Latin characters, you might get surprised by this when
    accessing composing characters —`y̆` is not one, but two scalars, `y` and  `̆`
    [36]. You can get around this by using the `Unicode-segmentation` crate, which
    supports iteration over graphemes: [https://crates.io/crates/unicode-segmentation.](https://crates.io/crates/unicode-segmentation)'
  prefs: []
  type: TYPE_NORMAL
- en: When splitting a string on a pattern that is at the beginning, is at the end,
    or occurs multiple times after each other, each instance gets split into an empty
    string `""`[107]. This is especially nasty when splitting on spaces (`' '`). In
    this case, you should use `split_whitespace` instead [110]. Otherwise, `split_terminator`
    will remove the empty strings from the end of the string [68].
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, when we talk about a *pattern* in this recipe, we mean one of three
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: '- A character'
  prefs: []
  type: TYPE_NORMAL
- en: '- A string'
  prefs: []
  type: TYPE_NORMAL
- en: '- A predicate that takes one `char`'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of `String` should not be much of a surprise—it''s just
    a kind of vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f412c3fb-e496-4985-af5b-64a327a58aba.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing collections as iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to one of the most flexible parts of the Rust standard library. Iterators
    are, as the name suggests, a way of applying actions of items in a collection.
    If you come from C#, you will already be familiar with iterators because of Linq.
    Rust's iterators are kind of similar, but come with a more functional approach
    to things.
  prefs: []
  type: TYPE_NORMAL
- en: Because they are an extremely fundamental part of the standard library, we are
    going to dedicate this recipe entirely to a showcase of all the different things
    you can do with them in isolation. For real-world use cases, you can simply continue
    reading the book, as a big portion of the other recipes features iterators in
    some way or another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `iterator.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin iterator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Access individual items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Collect the iterator into a collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Change which items are being iterated over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if an iterator contains an element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Useful operations for numeric items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine iterators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply functions to all items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The real strength of iterators comes from combining them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*This recipe is incredibly important*. No matter what you do, or which library
    you use, it''s going to use iterators somewhere. All of the operations presented
    can be used on any collection and all types that implement the `iterator` trait.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first section, we looked at different ways to create iterators. I mention
    that ranges are *limited* because, in order to be iterable, the range-type has
    to implement `Step`. `char` doesn''t, so you wouldn''t be able to use `''A''..''D''`
    as an iterator. For this reason, in line [209], we iterate over the characters
    as bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We have to set the limit of the range to `b'z' + 1`, because ranges are non-inclusive.
    You might have noticed that this fact makes using ranges confusing sometimes.
    This is why, on the nightly compiler, you can use inclusive ranges ([Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*, *Iterating over an inclusive range*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to our recipe here, though. While iterating, you have the option
    to use `enumerate` in order to get an iteration counter [22]. This is the reason
    that Rust gets away with not supporting traditional, C-style `for` loop syntax.
    You most probably have seen some variation of the following C code in some language
    or another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Rust disallows this, because a range-based `for` loop is almost always cleaner
    to use, which you are going to know if you come from a Python background, as it
    pioneered this restriction. In fact, most programming languages have shifted their
    paradigm to promote range-based loops. In the rare cases where you really actually
    would like to know your iteration count, you can use `enumerate` to emulate this
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'When accessing single items with `nth`[41], you have to keep two things in
    mind:'
  prefs: []
  type: TYPE_NORMAL
- en: It accesses an item by going through all items until it reaches the one you
    want. In the worst case, this is an ![](img/792fb25a-7101-4b90-9b5c-555fc2e85980.png)access.
    If you can, use your collection's native access method (most of the time, this
    would be `.get()`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It consumes the iterator up to the specified index. This means that calling
    `nth` twice with the exact same parameters is going to result in two different
    returned values [54]. Don't let this catch you by surprise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another thing to take note of when using an iterator's various accessors is
    that they all return an `Option` that will be `None` if the iterator has no more
    items left.
  prefs: []
  type: TYPE_NORMAL
- en: 'When collecting an iterator into a collection, the following two forms of annotation
    are completely equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just use the one that you like most. In this book, we stick to the first form
    because of personal preference. The second form, by the way, is called the *turbofish*.
    This is because `::<>` kinda looks like a certain family of fish. Cute, isn't
    it? Both forms are also able to deduce their exact type automatically, so you
    don't need to write `Vec<i32>`. The inner type can be omitted with an underscore
    (`_`), as shown.
  prefs: []
  type: TYPE_NORMAL
- en: '`cycle` [163] takes an iterator and repeats it endlessly. `[1, 2, 3]` would
    become `[1, 2, 3, 1, 2, 3, 1, ...]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`zip` [175] takes two iterators and creates one out of them by putting items
    that are at the same index into a tuple, and then chaining them. If the iterators
    have different sizes, it just ignores the extra items of the longer one. For example,
    `[1, 2, 3]` zipped with `[''a'', ''b'', ''c'', ''d'']` would become `[(1, ''a''),
    (2, ''b''), (3, ''c'')]`, because `''d''` will be thrown away as it has no partner
    to zip with. If you zip two infinite ranges, you will have no problem, as `zip`
    is lazy, which means it will only actually start zipping your iterators when it''s
    really necessary; for example, when using `take` to extract the first few tuples
    [81].'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to mutate all of your items, you can use `map`. It can also be
    used to change the underlying type of the iterator, as shown in line [182]. `for_each`
    is really similar, with one big difference: it doesn''t return anything. It''s
    basically the same as manually using a `for` loop on an iterator. The intended
    use case for it is situations in which you have a lot of chained method calls
    on an iterator, where it can be more elegant to chain `for_each` as well, as a
    kind of *consumer*.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are very often chained together to weave complex transformations together.
    If you find yourself calling many methods on a single iterator, don't worry, as
    this is exactly what you should be doing. On the other hand, when you see yourself
    doing a lot of complicated stuff in a `for` loop, you should probably rewrite
    that code with iterators.
  prefs: []
  type: TYPE_NORMAL
- en: When using `filter_map`[199], you can keep an item by returning it, wrapped
    in `Some`. If you want to filter it out, return `None`. Before that, you're allowed
    to change the item in whatever way you want, which is the `map` part of the deal.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`iter()` creates an iterator that *borrows* items. If you want to create an
    iterator that *consumes* items—for example, takes ownership of them by moving
    them – you can use `into_iter()`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Iterating over an inclusive range* recipe in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a VecDeque
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to insert or remove elements regularly into or from the beginning
    of the vector, your performance might take quite a hit, as it will force the vector
    to reallocate all data that comes after it. This is especially bothersome when
    implementing a queue. For this reason, Rust provides you with the `VecDeque`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `vecdeque.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin vecdeque`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the interface of `VecDeque` is identical to `Vec`. You can even optimize
    them the same way with `with_capacity` and its `swap_remove` equivalents. The
    differences come from the fact that `VecDeque` is more oriented around access
    from both ends. As such, multiple methods from `Vec` that implicitly affect the
    last element have two equivalents in `VecDeque`: one for the front, and one for
    the back. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`push`, which becomes `push_front` [46] and `push_back` [11]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`, which becomes `pop_front` [16] and `pop_back` [55]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swap_remove`, which becomes `remove_front` [78] and `remove_back` [73]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `VecDeque` has the ability to freely append or remove elements from both ends
    in a performant way, which makes it an ideal candidate for a **First In, First
    Out** (**FIFO**) queue [24]. In fact, this is how it's nearly always used.
  prefs: []
  type: TYPE_NORMAL
- en: When you see yourself in a situation where you want to respond to any kind of
    requests in the order they arrive in and remove them again afterwards, a `VecDeque`
    is an ideal tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internally, the `VecDeque` is implemented as a *ring buffer*, also known as
    a *circular buffer*. It''s called like this because it behaves like a circle:
    the end touches the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: It works by allocating a continuous block of memory, like the `Vec`; however,
    where the `Vec` always leaves its extra capacity at the end of the block, the
    `VecDeque` has nothing against leaving spots inside the block empty. It follows
    that when you remove the first element, the `VecDeque` doesn't move all elements
    to the left, but simply leaves the first spot empty. If you then push an element
    into the beginning via `push_front`, it will take the spot freed earlier while
    leaving the elements after it untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The circular catch in the story is that if you have some capacity in the front
    of the block but none in the back while using `push_back`, the `VecDeque` will
    simply use that space to allocate the extra element, leading to the following
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecba1589-7d12-447b-8b59-88bc93e537c1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is great, because you will not have to worry about this at all while using
    it, as its iterating methods hide the implementation by always showing you the
    *correct* order!
  prefs: []
  type: TYPE_NORMAL
- en: Like the vector, `VecDeque` will resize itself and move all its elements into
    a new block when its capacity runs out.
  prefs: []
  type: TYPE_NORMAL
- en: Using a HashMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you imagine a `Vec` as a collection that assigns an index (0, 1, 2, and so
    on) to data, the `HashMap` is a collection that assigns any data to any data.
    It allows you to map arbitrary, hashable data to other arbitrary data. Hashing
    and mapping, that's where the name comes from!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `hashmap.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin hashmap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t need to access both keys and values at the same time, you can
    iterate over either individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the entry API to assign default values to keys if they''re not
    yet in the `HashMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a `HashMap` is a collection to map one type of data to
    another. You do this by calling `insert`, and passing your key and its value [9].
    If the key already had a value, it will be overwritten. This is why `insert` returns
    an `Option`: if there was a value before, it returns the old value [27], or otherwise
    `None`. If you want to make sure that you''re not overwriting anything, make sure
    to check the result of `contains_key` [16] before inserting your value.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `get` and `remove` won't crash when called with an invalid key. Instead,
    they return a `Result`. In the case of `remove`, said `Result` contains the removed
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most collections, you have the options to iterate over your data, by
    borrowing the key-value pairs[43], borrowing the keys while mutating the values
    [49], or moving them all [55]. Due to its nature, `HashMap` additionally allows
    you three more options: borrowing all values [74], mutating all values [80], or
    borrowing all keys [68]. You probably noticed that one combination is missing:
    you cannot mutate a key. Ever. This is part of the contract you sign when using
    a `HashMap`. Further down, where we explain how `HashMap` is implemented, you''re
    going to see that, because the key''s hash is actually an index, mutating a key
    is equivalent to deleting an entry and recreating it. This is reflected nicely
    in the design choice of not letting you modify keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, the `Entry` API lets you access an abstraction of a value
    that might or might not be there. Most of the time, it''s used while being paired
    with `or_insert` in order to insert a default value if the key was not found [88].
    If you want to insert a default value based on a closure, you can use `or_insert_with`.
    Another use for the entry object is to match it against its variants: `Occupied`,
    or `Vacant`. This results in the same thing as calling `get` directly on a key.
    Note that in our example, we had to scope the entry access like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is because `or_insert` returns a mutable reference to a value. If we had
    omitted the scope, the second call of `entry` would have borrowed our `age` object
    at the same time as a mutable reference to it existed, which is an error in Rust's
    borrowing concept in order to guarantee data race-free access to resources.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to fine-tune your `HashMap` for performance, you can call your usual
    friends —`with_capacity` [60], `shrink_to_fit`, and `reserve` are also available
    for it, and work the same way as in other collections.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internally, you can imagine the `HashMap` as being implemented as two vectors:
    a table, and a buffer. Of course, we''re simplifying here; there are actually
    no vectors in the implementation. But this analogy is accurate enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to look at the actual implementation, feel free to do so, as Rust
    is completely open source: [https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs.](https://github.com/rust-lang/rust/blob/master/src/libstd/collections/hash/table.rs)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the background, the buffer stores our values in a sequential fashion. In
    the front, we have a table storing buckets that don''t do much more than point
    to the element they stand for. When you insert a key-value pair, what happens
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: The value gets put in the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key goes through a hashing function and becomes an index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The table creates a bucket at said index that points to the actual value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f00482e-36a3-42ad-8d5d-3c297234858a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rust's hashing algorithm doesn't actually generate unique indices, for performance
    reasons. Instead, Rust uses a clever way to handle hash collisions called **Robin
    Hood bucket stealing** ([http://codecapsule.com/2013/11/11/robin-hood-hashing/](http://codecapsule.com/2013/11/11/robin-hood-hashing/)).
  prefs: []
  type: TYPE_NORMAL
- en: The default hashing algorithm of the standard library has been chosen specifically
    to protect you from HashDoS attacks ([https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/](https://cryptanalysis.eu/blog/2011/12/28/effective-dos-attacks-against-web-application-plattforms-hashdos/)).
    If you want to squeeze out every bit of performance, you can do that, of your
    `HashMap` without caring about this particular risk, or you can specify a custom
    hasher by constructing it with `with_hasher`.
  prefs: []
  type: TYPE_NORMAL
- en: Many people have already implemented various hashers on [crates.io](https://crates.io/),
    so make sure to check them out before rolling with your own solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using a HashSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to describe a `HashSet` is by describing how it''s implemented:
    `HashMap<K, ()>`. It''s just a `HashMap` without any values!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two best reasons to choose a `HashSet` are:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't want to deal with duplicate values at all, as it doesn't even include
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You plan on doing a lot (and I mean a *lot*) of item lookup - that is the question, *Does
    my collection contain this particular item?*. In a vector, this is done in ![](img/c56fbb37-99dd-43e3-ade3-62e3fa3b3bbb.png),
    while a `HashSet` can do it in ![](img/935f6d04-873f-475c-9118-f78c55c2738a.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `hashset.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin hashset`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare different `HashSet`s:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Join two `HashSet`s in various ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a `HashSet` is a kind of `HashMap`, most of its interface is pretty similar.
    The major difference is that the methods that would return a key's value in the
    `HashMap` instead simply return a `bool` on the `HashSet` in order to tell if
    a key already existed or not [14].
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `HashSet` brings a few methods for analyzing two sets [46 to 92]
    and joining them [96 to 131]. If you've ever heard of set theory or Venn diagrams,
    or done a bit of SQL, you're going to recognize it all. Otherwise, I advise you
    to run the example, and study the outputs in combination with the relevant comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some illustrations might help you. For the analytical methods, the dark green
    part is the object of reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10d70a1a-add1-4a70-9aa8-4171a0333bfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the selecting methods, the dark green part is the one that is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e2fe489-c9f3-4564-bdeb-5ccc79a72941.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No big surprises in the implementation of the `HashSet`, since it's exactly
    the same as the `HashMap`, just without any values!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cdac45c-92c6-467d-9886-0dab7038cbaa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an own iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create an infinitely applicable algorithm or a collection-like structure,
    it's really nice to have the dozens of methods that an iterator provides at your
    disposal. For this, you will have to know how to tell Rust to implement them for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the folder `src/bin`, create a file called `own_iterator.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin own_iterator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our little example here, we are going to look at two different uses for
    an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fibonacci()`, which returns an infinite range of the **Fibonacci sequence**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SquaredVec`, which implements a (very) small subset of a `Vec` with a twist:
    it squares all items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Fibonacci sequence is defined as a series of numbers, starting from 0 and
    1, where the next number is the sum of the last two. It starts like this: 0, 1,
    1, 2, 3, 5, 8, 13, 21, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The first two are 0 and 1 per definition. The next one is their sum — *0 + 1
    = 1*. After that comes *1 + 1 = 2*. Then *2 + 1 = 3*. *3 + 2 = 5*. Repeat ad infinitum.
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm can be turned into an iterator by implementing the `Iterator` trait.
    This is pretty simple, as it only expects you to provide the type you're iterating
    over and a single method, `next`, which fetches the next item. If the iterator
    doesn't have any items left, it should return `None`, otherwise `Some`. Our Fibonacci
    iterator always returns `Some` item, which makes it an infinite iterator [31].
  prefs: []
  type: TYPE_NORMAL
- en: Our `SquaredVec`, on the other hand, is more of a collection than an algorithm.
    In lines [37] to [53], we wrap the minimum of the `Vec` interface — we can create
    a `SquaredVec`, and we can fill it. Our type constraints `Mul + Copy` mean that
    the item the user wants to store has to be able to be copied and to be multiplied.
    We need this in order to square it, but it's not relevant for the iterator. `T::Output`
    is just the type that a multiplication would return, which most of the time is
    going to be `T` itself.
  prefs: []
  type: TYPE_NORMAL
- en: We could implement the `Iterator` trait again, but there's an easier option
    that will provide you with even more methods. We can allow our struct to be implicitly
    convertible into a slice `[T]`, which will not only implement `Iterator` for you,
    but also a whole bunch of other methods. Because `Vec` implements it already,
    you can just return it like that [67]. If your underlying collection didn't provide
    a slice conversion, you could still go the same way as before and implement the
    `Iterator` trait manually.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a lot of complex logic to perform in the iterator and want to separate
    it a bit from your collection, you can do so by providing your collection with
    the `IntoIterator` trait instead. This would allow you to return a struct specifically
    made for your iteration, which itself provides the `Iterator` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Using a slab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some algorithms require you to hold access tokens to data that may or may not
    exist. This could be solved in Rust by using  `Vec<Option<T>>`, and treating the
    index of your data as a token. But we can do better! `slab` is an optimized abstraction
    of exactly this concept.
  prefs: []
  type: TYPE_NORMAL
- en: While it is not meant as a general-purpose collection, `slab` can help you a
    lot if you use it in the right places.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that has been generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to slab's crates.io page ([https://crates.io/crates/slab](https://crates.io/crates/slab))
    to check for the newest version, and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the folder `bin`, create a file called `slab.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code, and run it with `cargo run --bin slab`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A slab is very similar to a vector, with one quintessential difference: you
    don''t get to choose your index. Instead, when inserting data [15], you receive
    the data''s index as a kind of *key* that you can use to access it again. It is
    your responsibility to store this key somewhere; otherwise, the only way to retrieve
    your data is by iterating over your slab. The flipside is that you don''t have
    to provide any key either. In contrast to a `HashMap`, you don''t need any hashable
    objects at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A situation in which this is useful is in a connection pool: if you have multiple
    clients who want to access individual resources, you can store said resources
    in a slab and provide the clients with their key as a kind of token.'
  prefs: []
  type: TYPE_NORMAL
- en: This example suits the second use case of a slab really well. Suppose you only
    accept a certain amount of connections at a given time. When accepting a connection,
    you don't care about the exact index, or the way it is stored. Instead, you care
    only that it is stored in a retrievable way, and that it doesn't exceed your limit.
    This fits the bill of the slab quite nicely, which is why most of the time you
    won't be creating a slab with `Slab::new()`, but with `with_capacity`, set to
    a constant upper limit [9].
  prefs: []
  type: TYPE_NORMAL
- en: 'The slab, however, does not impose this limit by itself, as it behaves exactly
    like the vector in the way it handles capacity: as soon as the length exceeds
    the capacity, the slab reallocates all objects to a bigger block of memory and
    ups the capacity. This is why, when dealing with upper bonds, you should insert
    your data with some kind of variation of line [38]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Other valid approaches would be to wrap an insertion in a function that returns
    a `Result`, or an `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A slab is backed by a `Vec<Entry>`. You might remember the `Entry` from our
    recipe about the `HashMap` earlier. It is the same as an `Option`, with the difference
    that its variants are not called `Some(...)` and `None`, but `Occupied(...)` and
    `Vacant`. This means that, in a nutshell, a slab is implemented as a vector with
    holes in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbef86f3-406c-4974-b3a9-5779da64a90e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, in order to guarantee fast occupation of vacant spots, the slab
    keeps a linked list of all vacant entries.
  prefs: []
  type: TYPE_NORMAL
