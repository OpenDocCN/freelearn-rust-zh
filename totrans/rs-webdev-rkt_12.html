<html><head></head><body>
		<div><h1 id="_idParaDest-117"><em class="italic"><a id="_idTextAnchor118"/>Chapter 10</em>: Uploading and Processing Posts</h1>
			<p>In this chapter, we are going to learn how to upload user posts. We will start with the basics of multipart uploads and continue with <code>TempFile</code> to store the uploaded files. After uploading the files, we will implement image processing.</p>
			<p>The next thing we are going to learn about is improving processing using concurrent programming techniques, asynchronous programming, and multithreading. </p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Uploading a text post</li>
				<li>Uploading a photo post</li>
				<li>Processing files asynchronously</li>
				<li>Uploading a video post and process using worker</li>
			</ul>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Technical requirements</h1>
			<p>For this chapter, we have the usual requirements: a Rust compiler, a text editor, a web browser, and a PostgreSQL database server. Aside from those requirements, we are going to process uploaded video files. Download the <strong class="bold">FFmpeg</strong> command line from <a href="https://www.ffmpeg.org/download.html">https://www.ffmpeg.org/download.html</a>. FFmpeg is a multimedia framework to process media files. Make sure you can run FFmpeg on the terminal of your operating system.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10</a>.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Uploading a text post</h1>
			<p>The <a id="_idIndexMarker528"/>first thing we want to upload is a text post because it's the simplest type. When we submit the form in HTML, we can specify the <code>form</code> tag <code>enctype</code> attribute as <code>text/plain</code>, <code>application/x-www-form-urlencoded</code>, or <code>multipart/form-data</code>. We already learned how to process <code>application/x-www-form-urlencoded</code> in the Rocket application when we learned how to create a user. We create a struct and derive <code>FromForm</code> for that struct. Later, in the route handling function, we set a route attribute, such as <code>get</code> or <code>post</code>, and assign the struct in the <code>data</code> annotation.</p>
			<p>The request body for <code>Content-Type="application/x-www-form-urlencoded"</code> is simple: the form keys and values are encoded in key-value tuples separated by <code>&amp;</code>, with an equals sign (<code>=</code>) between the key and the value. If the characters sent are not alphanumeric, they're percent-encoded (<code>%</code>). An example of a form request body is shown here:</p>
			<pre class="source-code">name=John%20Doe&amp;age=18</pre>
			<p>For uploading a file, <code>Content-Type</code> is <code>multipart/form-data</code>, and the body is different. Suppose we have the following HTTP header:</p>
			<pre class="source-code">Content-Type: multipart/form-data; boundary=---------------------------charactersforboundary123</pre>
			<p>The HTTP body can be as follows:</p>
			<pre class="source-code">Content-Type: multipart/form-data; boundary=---------------------------charactersforboundary123</pre>
			<pre class="source-code">Content-Disposition: form-data; name="name"</pre>
			<pre class="source-code">John Doe</pre>
			<pre class="source-code">-----------------------------charactersforboundary123</pre>
			<pre class="source-code">Content-Disposition: form-data; name="upload"; filename="file1.txt"</pre>
			<pre class="source-code">Content-Type: text/plain</pre>
			<pre class="source-code">Lorem ipsum dolor sit amet </pre>
			<pre class="source-code">-----------------------------charactersforboundary123</pre>
			<pre class="source-code">Content-Disposition: form-data; name="other_field"</pre>
			<pre class="source-code">Other field</pre>
			<p>In Rocket, we can process <code>multipart/form-data</code> by using the <code>multer</code> crate. Let's try to implement<a id="_idIndexMarker529"/> uploading using that crate by following these instructions:</p>
			<ol>
				<li>Modify our application by adding these crates into the <code>Cargo.toml</code> dependencies:<pre>multer = "2.0.2"
tokio-util = "0.6.9"</pre></li>
				<li>Add these configurations in <code>Rocket.toml</code> to handle the file upload limit and add a temporary directory to store the uploaded files:<pre>limits = {"file/avif" = "1Mib", "file/gif" = "1Mib", "file/jpg" = "1Mib", "file/jpeg" = "1Mib", "file/png" = "1Mib", "file/svg" = "1Mib", "file/webp" = "1Mib", "file/webm" = "64Mib", "file/mp4" = "64Mib", "file/mpeg4" = "64Mib", "file/mpg" = "64Mib", "file/mpeg" = "64Mib", "file/mov" = "64Mib"}
temp_dir = "/tmp"</pre></li>
				<li>Modify <code>src/views/posts/index.html.tera</code> to add a form where the user can upload a file. Add the following lines after the pagination block:<pre>&lt;form action="/users/{{ user.uuid }}/posts" enctype="multipart/form-data" method="POST"&gt;
  &lt;fieldset&gt;
    &lt;legend&gt;New Post&lt;/legend&gt;
    &lt;div class="row"&gt;
      &lt;div class="col-sm-12 col-md-3"&gt;
        &lt;label for="upload"&gt;Upload file:&lt;/label&gt;
      &lt;/div&gt;
      &lt;div class="col-sm-12 col-md"&gt;
        &lt;input type="file" name="file" accept=" 
        text/plain"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;button type="submit" value="Submit"&gt;Submit&lt;/
    button&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;</pre></li>
				<li>Add<a id="_idIndexMarker530"/> the <code>create()</code> method for <code>Post</code> in the <code>src/models/post.rs</code> file. We want a method to save the <code>Post</code> data into the database. Add the following lines inside the <code>impl Post {}</code> block:<pre>pub async fn create(
    connection: &amp;mut PgConnection,
    user_uuid: &amp;str,
    post_type: PostType,
    content: &amp;str,
) -&gt; Result&lt;Self, OurError&gt; {
    let parsed_uuid = Uuid::parse_str(
    user_uuid).map_err(OurError::from_uuid_error)?;
    let uuid = Uuid::new_v4();
    let query_str = r#"INSERT INTO posts
(uuid, user_uuid, post_type, content)
VALUES
($1, $2, $3, $4)
RETURNING *"#;
    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)
        .bind(uuid)
        .bind(parsed_uuid)
        .bind(post_type)
        .bind(content)
        .fetch_one(connection)
        .await
        .map_err(OurError::from_sqlx_error)?)
}</pre></li>
				<li>We can <a id="_idIndexMarker531"/>remove <code>FromForm</code> as we will not use the placeholder anymore. Remove these lines from <code>src/models/post.rs</code>:<pre><strong class="bold">use rocket::form::FromForm;</strong>
...
#[derive(FromRow<strong class="bold">, FromForm</strong>)]
pub struct Post {...}</pre></li>
				<li>We need the value from the request's <code>Content-Type</code> to get a multipart boundary, but Rocket doesn't have a request guard that can do that. Let's create a type that can handle a raw HTTP <code>Content-Type</code> header. In <code>src/lib.rs</code>, add the following line:<pre>pub mod guards;</pre></li>
			</ol>
			<p>In the <code>src</code> folder, create another folder, named <code>guards</code>, and then create a <code>src/guards/mod.rs</code> file. Inside the file, add the struct to handle the raw HTTP request body:</p>
			<pre>use rocket::request::{FromRequest, Outcome};
pub struct RawContentType&lt;'r&gt;(pub &amp;'r str);</pre>
			<ol>
				<li value="7">Implement <code>FromRequest</code> for <code>RawContent</code> to create a request guard:<pre>#[rocket::async_trait]
impl&lt;'r&gt; FromRequest&lt;'r&gt; for RawContentType&lt;'r&gt; {
    type Error = ();
    async fn from_request(req: &amp;'r rocket::
    Request&lt;'_&gt;) -&gt; Outcome&lt;Self, Self::Error&gt; {
        let header = req.headers().get_one("
        Content-Type").or(Some("")).unwrap();
        Outcome::Success(RawContentType(header))
    }
}</pre></li>
				<li>Rocket<a id="_idIndexMarker532"/> will consider the <code>"/users/delete/&lt;uuid&gt;"</code> route as conflicting with the <code>"/users/&lt;user_uuid&gt;/posts"</code> route. To avoid that problem, we can add <code>rank</code> to the route macro. In <code>src/routes/user.rs</code>, edit the route macro above the <code>delete_user_entry_point()</code> function:<pre>#[post("/users/delete/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", <strong class="bold">rank = 2</strong>)]
pub async fn delete_user_entry_point(...) -&gt; ... {...}</pre></li>
				<li>In <code>src/routes/post.rs</code>, add the required <code>use</code> declaration to implement the handling of the HTTP multipart request:<pre>use crate::guards::RawContentType;
use crate::models::post_type::PostType;
use multer::Multipart;
use rocket::request::FlashMessage;
use rocket::response::{Flash, Redirect};
use rocket::data::{ByteUnit, Data};</pre></li>
				<li>Add a constant to limit the size of the uploaded file:<pre>const TEXT_LIMIT: ByteUnit = ByteUnit::Kibibyte(64); </pre></li>
				<li>Let's <a id="_idIndexMarker533"/>modify the <code>get_posts()</code> function as well to add a <code>flash</code> message if the upload fails or is successful:<pre>pub async fn get_posts(
    ...
    <strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;,</strong>
) -&gt; HtmlResponse {
    <strong class="bold">let flash_message = flash.map(|fm| </strong>
    <strong class="bold">String::from(fm.message()));</strong>
    ...
    let context = context! {<strong class="bold">flash: flash_message</strong>,...};
    Ok(Template::render("posts/index", context))
}</pre></li>
				<li>Now it's time to implement the <code>create_post()</code> function. The first thing we need to do is modify the <code>post</code> route macro and function signature:<pre>#[post("/users/&lt;<strong class="bold">user_uuid</strong>&gt;/posts", format = "<strong class="bold">multipart/form-data</strong>", data = "&lt;<strong class="bold">upload</strong>&gt;"<strong class="bold">, rank = 1</strong>)]
pub async fn create_post(
    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,
    <strong class="bold">user_uuid</strong>: &amp;str,
    <strong class="bold">content_type: RawContentType&lt;'_&gt;,</strong>
    <strong class="bold">upload: Data&lt;'_&gt;,</strong>
) -&gt; <strong class="bold">Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt;</strong> {...}</pre></li>
				<li>Inside<a id="_idIndexMarker534"/> the <code>create_post()</code> function, add a closure that returns an error. We add a closure to avoid repetition. Add the following lines:<pre>let create_err = || {
    Flash::error(
        Redirect::to(format!("/users/{}/posts", 
        user_uuid)),
        "Something went wrong when uploading file",
    )
};</pre></li>
				<li>Under the <code>create_err</code> definition, continue by getting the boundary from the <code>content_type</code> request guard:<pre>let boundary = multer::parse_boundary(content_type.0).map_err(|_| create_err())?;</pre></li>
				<li>For <code>TextPost</code>, we just store the content of the text file in the post's <code>content</code> field. Let's open the request body, process it as a multipart, and define a new variable to store the content of the body. Append the following lines:<pre>let upload_stream = upload.open(TEXT_LIMIT);
let mut multipart = Multipart::new(tokio_util::io::ReaderStream::new(upload_stream), boundary);
let mut text_post = String::new();</pre></li>
				<li>The <a id="_idIndexMarker535"/>next thing we need to do is to iterate the multipart fields. We can iterate multipart fields as follows:<pre>while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {
    let field_name = field.name();
    let file_name = field.file_name();
    let content_type = field.content_type();
    println!(
        "Field name: {:?}, File name: {:?}, 
        Content-Type: {:?}",
        field_name, file_name, content_type
    );
}</pre></li>
			</ol>
			<p>As we only have one field in the form, we can just get the content of the first field and put the value in the <code>text_post</code> variable. Append the following lines:</p>
			<pre>while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {
    while let Some(field_chunk) = 
    field.chunk().await.map_err(|_| create_err())? {
        text_post.push_str(std::str::from_utf8(
        field_chunk.as_ref()).unwrap());
    }
}</pre>
			<ol>
				<li value="17">Finally, after we get the request body content and assign it to <code>text_post</code>, it's time to <a id="_idIndexMarker536"/>store it in the database and return to the <code>posts</code> list page. Append the following lines:<pre>let connection = db.acquire().await.map_err(|_| create_err())?;
Post::create(connection, user_uuid, PostType::Text, &amp;text_post)
    .await
    .map_err(|_| create_err())?;
Ok(Flash::success(
    Redirect::to(format!("/users/{}/posts", 
    user_uuid)),
    "Successfully created post",
))</pre></li>
			</ol>
			<p>Now, try restarting the application and uploading the text file. You should see the content of the text file on the <code>posts</code> list page: </p>
			<div><div><img src="img/Figure_10.1_B16825.jpg" alt="Figure 10.1 – Uploaded text posts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Uploaded text posts</p>
			<p>Now that<a id="_idIndexMarker537"/> we have implemented uploading and processing text files, it is time to move on to uploading and processing photo files.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Uploading a photo post</h1>
			<p>Before Rocket <em class="italic">0.5</em>, uploading multipart files had to be implemented manually, as in the previous section. Starting from Rocket <em class="italic">0.5</em>, there's a <code>rocket::fs::TempFile</code> type that can be used directly to handle uploaded files.</p>
			<p>To handle <a id="_idIndexMarker538"/>processing image files, we can use an <code>image</code> crate. The crate can handle opening and saving various image file formats. The <code>image</code> crate also provides ways to manipulate the image.</p>
			<p>Websites process uploaded media files such as images for various reasons, including reducing disk usage. Some websites reduce the image quality and encode the uploaded images into file format with a default smaller size. In this example, we are going to convert all uploaded images into JPEG files with 75% quality.</p>
			<p>Let's implement uploading image files using the <code>image</code> crate and the <code>TempFile</code> struct by following <a id="_idIndexMarker539"/>these steps:</p>
			<ol>
				<li value="1">Remove <code>multer</code> and <code>tokio-util</code> from <code>Cargo.toml</code>. Then, add the <code>image</code> crate to <code>Cargo.toml</code>:<pre>image = "0.24.0"</pre></li>
				<li>Remove <code>pub mod guards;</code> from <code>src/lib.rs</code> and then remove the <code>src/guards</code> folder.</li>
				<li>Add a struct to handle uploaded files in <code>src/models/post.rs</code>:<pre>use rocket::fs::TempFile;
...
#[derive(Debug, FromForm)]
pub struct NewPost&lt;'r&gt; {
    pub file: TempFile&lt;'r&gt;,
}</pre></li>
				<li>Modify <code>src/views/posts/index.html.tera</code> to include images as accepted files:<pre>...
&lt;input type="file" name="file" accept="text/plain<strong class="bold">,image/*</strong>"&gt;
...</pre></li>
				<li>Remove unused <code>use</code> declarations, <code>TEXT_LIMIT</code> constant, and part of the <code>create_post()</code> function from the boundary variable declaration to the multipart iteration block:<pre>use crate::guards::RawContentType;
use multer::Multipart;
use rocket::data::{ByteUnit, Data};
...
const TEXT_LIMIT: ByteUnit = ByteUnit::Kibibyte(64);
...
let boundary = multer::parse_boundary(content_type.0).map_err(|_| create_err())?;
...until
while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {
...
}</pre></li>
				<li>Add the<a id="_idIndexMarker540"/> required <code>use</code> declarations:<pre>use crate::models::post::{NewPost, Post, ShowPost};
use image::codecs::jpeg::JpegEncoder;
use image::io::Reader as ImageReader;
use image::{DynamicImage, ImageEncoder};
use rocket::form::Form;
use std::fs::File;
use std::io::{BufReader, Read};
use std::ops::Deref;
use std::path::Path;</pre></li>
				<li>We can use the <code>NewPost</code> struct that we created earlier as a regular <code>FromForm</code> deriving struct. Modify the <code>create_post()</code> function signature:<pre>pub async fn create_post<strong class="bold">&lt;'r&gt;</strong>(
    mut db: Connection&lt;DBConnection&gt;,
    user_uuid: &amp;str,
    mut upload: <strong class="bold">Form&lt;NewPost&lt;'r&gt;&gt;,</strong>
) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {...}</pre></li>
				<li>Under the <code>create_err</code> closure declaration, generate a random <code>uuid</code> name for the new name of the uploaded file:<pre>let file_uuid = uuid::Uuid::new_v4().to_string();</pre></li>
				<li>Check <code>Content-Type</code> of the<a id="_idIndexMarker541"/> uploaded file, and if the Temp File cannot determine it, return an error:<pre>if upload.file.content_type().is_none() {
    return Err(create_err());
}</pre></li>
				<li>Find the extension of the uploaded file and create a new filename:<pre>let ext = upload.file.content_type().unwrap().extension().unwrap();
let tmp_filename = format!("/tmp/{}.{}", &amp;file_uuid, &amp;ext);</pre></li>
				<li>Persist the uploaded file in the temporary location:<pre>upload
    .file
    .persist_to(tmp_filename)
    .await
    .map_err(|_| create_err())?;</pre></li>
				<li>Define <code>content</code> and <code>post_type</code> to be saved later:<pre>let mut content = String::new();
let mut post_type = PostType::Text;</pre></li>
				<li>Check the media type of the file. We can separate media types into bitmaps and <code>svg</code> files. For now, we are going to process text and images only. We will process videos in the next section. Append the following lines:<pre>let mt = upload.file.content_type().unwrap().deref();
if mt.is_text() {
} else if mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif() {
} else if mt.is_svg() {
} else {
    return Err(create_err());
}</pre></li>
				<li>We want to<a id="_idIndexMarker542"/> process the text first. Create a vector of byte (<code>u8</code>), open and read the file into the vector, and push the vector into the content String we defined previously. Add these lines inside the <code>mt.is_text()</code> block:<pre>let orig_path = upload.file.path().unwrap().to_string_lossy().to_string();
let mut text_content = vec![];
let _ = File::open(orig_path)
    .map_err(|_| create_err())?
    .read(&amp;mut text_content)
    .map_err(|_| create_err())?;
content.push_str(std::str::from_utf8(&amp;text_content).unwrap());</pre></li>
				<li>Next, we want to process the <code>svg</code> file. For this one, we cannot convert it into a JPEG file; we just want to copy the file into a <code>static</code> folder and create an image path of <code>/assets/random_uuid_filename.svg</code>. Append the following lines<a id="_idIndexMarker543"/> inside the <code>mt.is_svg()</code> block:<pre>post_type = PostType::Photo;
let dest_filename = format!("{}.svg", file_uuid);
content.push_str("/assets/");
content.push_str(&amp;dest_filename);
let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);
upload
    .file
    .move_copy_to(&amp;dest_path)
    .await
    .map_err(|_| create_err())?;</pre></li>
				<li>For bitmap files, we want to convert them into JPEG files. First, we want to define the destination filename. Append the following lines inside the <code>mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif()</code> block:<pre>post_type = PostType::Photo;
let orig_path = upload.file.path().unwrap().to_string_lossy().to_string();
let dest_filename = format!("{}.jpg", file_uuid);
content.push_str("/assets/");
content.push_str(&amp;dest_filename);</pre></li>
				<li>Continuing the bitmap processing, open the file into a buffer and decode the buffer into a binary format that the <code>image</code> crate understands:<pre>let orig_file = File::open(orig_path).map_err(|_| create_err())?;
let file_reader = BufReader::new(orig_file);
let image: DynamicImage = ImageReader::new(file_reader)
    .with_guessed_format()
    .map_err(|_| create_err())?
    .decode()
    .map_err(|_| create_err())?;</pre></li>
				<li>Create <a id="_idIndexMarker544"/>a path for the destination file where we want the JPEG result to be, and create a file at that path. Append the following lines:<pre>let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);
let mut file_writer = File::create(dest_path).map_err(|_| create_err())?;</pre></li>
				<li>We then create a JPEG decoder, specify the JPEG quality and the image attributes, and write the binary format into the destination file. Append the following lines:<pre>let encoder = JpegEncoder::new_with_quality(&amp;mut file_writer, 75);
encoder
    .write_image(
        image.as_bytes(),
        image.width(),
        image.height(),
        image.color(),
    )
    .map_err(|_| create_err())?;</pre></li>
				<li>Finally, we can save the post as in the previous section. Change the <code>Post::create()</code> method as follows:<pre>Post::create(connection, user_uuid, <strong class="bold">post_type</strong>, <strong class="bold">&amp;content</strong>)
...</pre></li>
			</ol>
			<p>We have now finished <a id="_idIndexMarker545"/>creating the routine to upload and process text and image files using <code>TempFile</code> and the <code>image</code> crate. Unfortunately, this process uses a more traditional programming paradigm that can be improved. Let's learn how to process the files asynchronously in the next section.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Processing files asynchronously</h1>
			<p>At the beginning <a id="_idIndexMarker546"/>of computer development, the available resources were usually limited in some way. For example, an older generation CPU can only execute one thing at a time. This makes computing difficult because computer resources must wait for the execution of tasks sequentially. For example, while the CPU is calculating a number, the user cannot input anything using the keyboard.</p>
			<p>Then, people invented operating systems <a id="_idIndexMarker547"/>with a <strong class="bold">scheduler</strong>, which assigns resources to run tasks. The invention of the scheduler led to the <a id="_idIndexMarker548"/>idea of a <strong class="bold">thread</strong>. A thread, or operating system thread, is the smallest sequence of program instructions that can be executed independently by the scheduler.</p>
			<p>Some modern programming languages can generate applications that spawn multiple threads at the same time, and so are<a id="_idIndexMarker549"/> called <strong class="bold">multithreaded</strong> applications.</p>
			<p>Creating multithreaded applications can be a drawback, as creating a thread allocates various resources, such as a memory stack. In certain applications, such as desktop applications, it's suitable to create multiple threads. But, creating multiple threads can be a problem in other applications, such as web applications, where requests and responses come and go quickly.</p>
			<p>There are<a id="_idIndexMarker550"/> techniques to <a id="_idIndexMarker551"/>overcome this problem in multiple ways. Some languages opt to have <strong class="bold">green threads</strong>, or <strong class="bold">virtual threads</strong>, where the language runtime manages a single operating system thread and makes the program behave as if it's multithreaded. Some other languages, such as Javascript and Rust, opt to have <strong class="bold">async/await</strong>, a syntactic <a id="_idIndexMarker552"/>feature that allows execution parts to be suspended and resumed.</p>
			<p>In the previous<a id="_idIndexMarker553"/> section, we used the Rust standard library to open and write files for image processing. The library itself is called blocking because, it waits until all the files have been loaded or written. That is not efficient because I/O operations are slower than CPU operations, and the thread can be used to do other operations. We can improve the program by using asynchronous programming.</p>
			<p>In Rust, we can declare an <code>async</code> function as follows:</p>
			<pre class="source-code">async fn async_task1() {...}</pre>
			<pre class="source-code">async fn async_task2() {...}</pre>
			<p>Any <code>async</code> function returns the <code>std::future::Future</code> trait. By default, running the function does not do anything. We can use <code>async_task1</code> and an executor, such as the <code>futures</code> crate, to run the <code>async</code> function. The following code will behave like regular programming: </p>
			<pre class="source-code">use futures::executor::block_on;</pre>
			<pre class="source-code">async fn async_task1() {...}</pre>
			<pre class="source-code">fn main() {</pre>
			<pre class="source-code">    let wait = async_task1();</pre>
			<pre class="source-code">    block_on(wait); // wait until async_task1 finish</pre>
			<pre class="source-code">}</pre>
			<p>We can use <code>.await</code> after the function usage to not block the thread, as follows:</p>
			<pre class="source-code">async fn combine() {</pre>
			<pre class="source-code">    async_task1().await;</pre>
			<pre class="source-code">    async_task2().await;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn main() {</pre>
			<pre class="source-code">    block_on(combine());</pre>
			<pre class="source-code">}</pre>
			<p>Or, we <a id="_idIndexMarker554"/>can wait for both functions to finish, as in the following:</p>
			<pre class="source-code">async fn combine2() {</pre>
			<pre class="source-code">  let t1 = async_task1();</pre>
			<pre class="source-code">  let t2 = async_task2();</pre>
			<pre class="source-code">  futures::join!(t1, t2);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn main() {</pre>
			<pre class="source-code">  block_on(combine2());</pre>
			<pre class="source-code">}</pre>
			<p>The <code>futures</code> crate is very basic; we can use other runtimes that provide an executor and a scheduler and many other functionalities. There are a couple of competing runtimes in the Rust ecosystem, such as <code>tokio</code>, <code>smol</code>, and <code>async-std</code>. We can use those different runtimes together but it's not very efficient, so it's advised to stick with a single runtime. Rocket itself uses <code>tokio</code> as the runtime for <code>async</code>/<code>await</code>.</p>
			<p>We have used <code>async</code> functions in code before, so let's now use <code>async</code> functions in more depth. Let's convert the previous image processing to use the <code>async</code> programming technique by following these steps:</p>
			<ol>
				<li value="1">Add the crate dependency in <code>Cargo.toml</code>:<pre>tokio = {version = "1.16", features = ["fs", "rt"]}</pre></li>
				<li>If we look at the code that handles uploading, we can see that file-related operations use a standard library, so they are blocking. We want to replace those libraries with Tokio-equivalent <code>async</code> libraries. Remove the <code>use</code> declaration from <code>src/routes/post.rs</code>:<pre>use std::fs::File;
use std::io::{BufReader, Read};</pre></li>
			</ol>
			<p>Then, add these <code>use</code> declarations:</p>
			<pre>use image::error::ImageError;
use std::io::Cursor;
use tokio::fs::File;
use tokio::io::AsyncReadExt;</pre>
			<ol>
				<li value="3">Replace <a id="_idIndexMarker555"/>the content of the <code>mt.is_text()</code> block from the standard library into a Tokio-equivalent library. Find the following lines:<pre>let _ = File::open(orig_path)
    .map_err(|_| create_err())?
    .read(&amp;mut text_content)
    .map_err(|_| create_err())?;</pre></li>
			</ol>
			<p>Replace those lines with the following:</p>
			<pre>let _ = File::open(orig_path)
    <strong class="bold">.await</strong>
    .map_err(|_| create_err())?
    <strong class="bold">.read_to_end</strong>(&amp;mut text_content)
    <strong class="bold">.await</strong>
    .map_err(|_| create_err())?;</pre>
			<ol>
				<li value="4">Next, replace reading the file in the <code>mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif()</code> block. Replace synchronous reading of the file and use a Tokio-equivalent file reading functionality. We want to wrap the result in <code>std::io::Cursor</code> because <code>ImageReader</code> methods require the <code>std::io::Read + std::io:Seek</code> trait, and <code>Cursor</code> is a type that implemented those traits.</li>
			</ol>
			<p>Find the following lines:</p>
			<pre>let orig_file = File::open(orig_path).map_err(|_| create_err())?;
let file_reader = BufReader::new(orig_file);</pre>
			<p>Replace those lines with the following:</p>
			<pre>let orig_file = <strong class="bold">tokio::fs::read</strong>(orig_path).await.map_err(|_| create_err())?;
let <strong class="bold">read_buffer</strong> = <strong class="bold">Cursor</strong>::new(orig_file);</pre>
			<ol>
				<li value="5">Wrap <a id="_idIndexMarker556"/>the image decoding code in <code>tokio::task::spawn_blocking</code>. This function allows synchronous code to run inside the Tokio executor. Find the following lines:<pre>let image: DynamicImage = ImageReader::new(file_reader)
    .with_guessed_format()
    .map_err(|_| create_err())?
    .decode()
    .map_err(|_| create_err())?</pre></li>
			</ol>
			<p>Replace them with the following lines:</p>
			<pre><strong class="bold">let encoded_result: Result&lt;DynamicImage, ()&gt; = tokio::task::spawn_blocking(|| {</strong>
    <strong class="bold">Ok(</strong>ImageReader::new(<strong class="bold">read_buffer</strong>)
        .with_guessed_format()
        .map_err(|_| <strong class="bold">()</strong>)?
        .decode()
        .map_err(|_| <strong class="bold">()</strong>)?)
})
<strong class="bold">.await</strong>
<strong class="bold">.map_err(|_| create_err())?;</strong>
<strong class="bold">let image = encoded_result.map_err(|_| create_err())?;</strong></pre>
			<ol>
				<li value="6">Next, we<a id="_idIndexMarker557"/> want to wrap the JPEG encoding in <code>spawn_blocking</code> as well. We also want to change file writing into a Tokio <code>async</code> function. Find the following lines:<pre>let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);
let mut file_writer = File::create(dest_path).map_err(|_| create_err())?;
JpegEncoder::new_with_quality(&amp;mut file_writer, 75)
    .write_image(
        image.as_bytes(),
        image.width(),
        image.height(),
        image.color(),
    )
    .map_err(|_| create_err())?;</pre></li>
			</ol>
			<p>Replace them with the following lines:</p>
			<pre>let write_result: Result&lt;Vec&lt;u8&gt;, ImageError&gt; = tokio::task::spawn_blocking(move || {
    let mut write_buffer: Vec&lt;u8&gt; = vec![];
    let mut write_cursor = Cursor::new(&amp;mut 
    write_buffer);
    let _ = JpegEncoder::new_with_quality(&amp;mut 
    write_cursor, 75).write_image(
        image.as_bytes(),
        image.width(),
        image.height(),
        image.color(),
    )?;
    Ok(write_buffer)
})
.await
.map_err(|_| create_err())?;
let write_bytes = write_result.map_err(|_| create_err())?;
let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);
tokio::fs::write(dest_path, &amp;write_bytes)
    .await
    .map_err(|_| create_err())?;</pre>
			<p>Now, we can<a id="_idIndexMarker558"/> run the application and try the uploading functionality again. There should be no differences, except it now uses the <code>async</code> function. If there are a lot of requests, an asynchronous application should fare better because the application can use the thread to do other tasks while the application deals with long I/O, such as reading from and writing to a database, dealing with network connections, and handling files, for example.</p>
			<p>There is one more example where the application uses <code>tokio::sync::channel</code> to create another asynchronous channel, and <code>rayon</code> (a crate for data parallelism). You can find this example in the source code for this chapter in the <code>Chapter10/04UploadingPhotoRayon</code> folder.</p>
			<p>In the next section, let's create the handle for uploading videos and processing videos using a worker.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor123"/>Uploading a video post and process using a worker</h1>
			<p>In this section, we <a id="_idIndexMarker559"/>are going to process an uploaded video. Processing an uploaded video is not a trivial task as it can take a lot of time, so even with the <code>async</code> programming technique, the generated response will take a lot of time.</p>
			<p>Another <a id="_idIndexMarker560"/>technique in programming to solve a long processing time is using message passing. We are going to create another thread to process the video. When a<a id="_idIndexMarker561"/> user uploads a video, we will do the following:</p>
			<ol>
				<li value="1">Generate a path to the temporary file.</li>
				<li>Mark the path as unprocessed.</li>
				<li>Store the path to the file in the database.</li>
				<li>Send a message from the main Rocket thread into the thread for processing the video.</li>
				<li>Return the response for uploading the video.</li>
			</ol>
			<p>If the thread to process the video receives a message, it will find the data from the database, process the file, and mark the post as finished.</p>
			<p>If the user requests the <code>posts</code> list or posts while it's still being processed, the user will see the loading image. If the user requests the <code>posts</code> list or posts after the processing is finished, the user will see the correct video in the web browser.</p>
			<p>Rust libraries for video processing are not very mature yet. There are a couple of libraries that can be used to wrap the <code>ffmpeg</code> library, but using the <code>ffmpeg</code> library is complicated, even if it's used in its own language, the C language. One solution is to use the <code>ffmpeg-cli</code> crate, a wrapper for the <code>ffmpeg</code> binary.</p>
			<p>Follow these instructions to process uploaded video files:</p>
			<ol>
				<li value="1">We want to add the <code>ffmpeg-cli</code> crate and the <code>flume</code> crate as dependencies. The <code>flume</code> crate works by generating a channel, a producer, and a consumer. There are similar libraries, such as <code>std::sync::mpsc</code> or <code>crossbeam-channel</code>, which can be used with varying performance and quality. Add the dependencies to <code>Cargo.toml</code>:<pre>flume = "0.10.10"
ffmpeg-cli = "0.1"</pre></li>
				<li>Change<a id="_idIndexMarker562"/> the form to allow uploading video files. Edit <code>src/views/posts/index.html.tera</code>:<pre>&lt;input type="file" name="file" accept="text/plain,image/*<strong class="bold">,video/*</strong>"&gt;</pre></li>
				<li>Find a <a id="_idIndexMarker563"/>placeholder image to show the video is still being <a id="_idIndexMarker564"/>processed. There's a <code>loading.gif</code> example file in the source code for this section in <code>Chapter10/05ProcessingVideo/static/loading.gif</code>.</li>
				<li>Modify the <code>raw_html()</code> method for <code>VideoPost</code> in <code>src/models/video_post.rs</code> to show the <code>loading.gif</code> image if the video is still not processed yet:<pre>fn raw_html(&amp;self) -&gt; String {
<strong class="bold">    if self.0.content.starts_with("loading") {</strong>
<strong class="bold">        return String::from(</strong>
<strong class="bold">            "&lt;figure&gt;&lt;img src=\"/assets/loading.gif\" </strong>
            <strong class="bold">class=\"section media\"/&gt;&lt;/figure&gt;",</strong>
<strong class="bold">        );</strong>
<strong class="bold">    }</strong>
    ...
}</pre></li>
				<li>We want a method for <code>Post</code> to update the content and mark it as permanent. Inside the <code>impl Post{}</code> block in <code>src/models/post.rs</code>, add the following method:<pre>pub async fn make_permanent(
    connection: &amp;mut PgConnection,
    uuid: &amp;str,
    content: &amp;str,
) -&gt; Result&lt;Post, OurError&gt; {
    let parsed_uuid = Uuid::parse_str(uuid).map_err(
    OurError::from_uuid_error)?;
    let query_str = String::from("UPDATE posts SET 
    content = $1 WHERE uuid = $2 RETURNING *");
    Ok(sqlx::query_as::&lt;_, Self&gt;(&amp;query_str)
        .bind(content)
        .bind(&amp;parsed_uuid)
        .fetch_one(connection)
        .await
        .map_err(OurError::from_sqlx_error))?
}</pre></li>
				<li>We want<a id="_idIndexMarker565"/> to create a message that we want to send to the <a id="_idIndexMarker566"/>channel. In <code>src/models/mod.rs</code>, add <a id="_idIndexMarker567"/>a new module:<pre>pub mod worker;</pre></li>
				<li>Then, create a new file, <code>src/models/worker.rs</code>. Create a new <code>Message</code> struct in the file as follows:<pre>pub struct Message {
    pub uuid: String,
    pub orig_filename: String,
    pub dest_filename: String,
}
impl Message {
    pub fn new() -&gt; Self {
        Message {
            uuid: String::new(),
            orig_filename: String::new(),
            dest_filename: String::new(),
        }
    }
}</pre></li>
				<li>Create<a id="_idIndexMarker568"/> a worker<a id="_idIndexMarker569"/> that will be executed when a channel<a id="_idIndexMarker570"/> receives a message. Add a new module in <code>src/lib.rs</code> called <code>worker</code>:<pre>pub mod workers;</pre></li>
				<li>Create a folder named <code>workers</code>. Then, create a new file, <code>src/workers/mod.rs</code>, and add a new video module:<pre>pub mod video;</pre></li>
				<li>Create a new file, <code>src/workers/video.rs</code>, and add the required <code>use</code> declarations:<pre>use crate::models::post::Post;
use crate::models::worker::Message;
use ffmpeg_cli::{FfmpegBuilder, File, Parameter};
use sqlx::pool::PoolConnection;
use sqlx::Postgres;
use std::process::Stdio;
use tokio::runtime::Handle;</pre></li>
				<li>Add the function signature to process the video as follows:<pre>pub fn process_video(connection: &amp;mut PoolConnection&lt;Postgres&gt;, wm: Message) -&gt; Result&lt;(), ()&gt; {...}</pre></li>
				<li>Inside the <code>process_video()</code> function, append these lines to prepare the destination file:<pre>let mut dest = String::from("static/");
dest.push_str(&amp;wm.dest_filename);</pre></li>
				<li>We <a id="_idIndexMarker571"/>want to re-encode all the files into MP4 files and use<a id="_idIndexMarker572"/> the <code>x265</code> codec<a id="_idIndexMarker573"/> for the video file destination. Append these lines to build the parameters for the <code>ffmpeg</code> binary:<pre>let builder = FfmpegBuilder::new()
    .stderr(Stdio::piped())
    .option(Parameter::Single("nostdin"))
    .option(Parameter::Single("y"))
    .input(File::new(&amp;wm.orig_filename))
    .output(
        File::new(&amp;dest)
            .option(Parameter::KeyValue("vcodec", 
            "libx265"))
            .option(Parameter::KeyValue("crf", "28")),
    );</pre></li>
				<li>The next and final step for the worker is to execute the builder. We can make it <code>async</code> too. Append the following lines:<pre>let make_permanent = async {
    let ffmpeg = builder.run().await.unwrap();
    let _ = ffmpeg.process.wait_with_output().
    unwrap();
    let mut display_path = String::from("/assets/");
    display_path.push_str(&amp;wm.dest_filename);
    Post::make_permanent(connection, &amp;wm.uuid, 
    &amp;display_path).await
};
let handle = Handle::current();
Ok(handle
    .block_on(make_permanent)
    .map(|_| ())
    .map_err(|_| ())?)</pre></li>
				<li>The <a id="_idIndexMarker574"/>next<a id="_idIndexMarker575"/> thing we<a id="_idIndexMarker576"/> want to do is to create a thread to receive and process the message. We can add a new thread after we initialize Rocket in <code>src/main.rs</code>. We want to do several things:<ul><li>Initialize a <code>worker</code> thread.</li><li>Initialize a producer (message sender) and a consumer (message receiver).</li><li>Initialize a database pool.</li><li>In the <code>worker</code> thread, the consumer will obtain a connection from the database pool and process the message.</li></ul></li>
			</ol>
			<p>Let's start by adding <code>use</code> declarations in <code>src/main.rs</code>:</p>
			<pre>use our_application::models::worker::Message;
use our_application::workers::video::process_video;
use rocket::serde::Deserialize;
use sqlx::postgres::PgPoolOptions;
use tokio::runtime::Handle;</pre>
			<ol>
				<li value="16">Add the structs<a id="_idIndexMarker577"/> to get the database configuration<a id="_idIndexMarker578"/> from <code>Rocket.toml</code> in <code>src/main.rs</code> after the <code>use</code> declaration:<pre>#[derive(Deserialize)]
struct Config {
    databases: Databases,
}
#[derive(Deserialize)]
struct Databases {
    main_connection: MainConnection,
}
#[derive(Deserialize)]
struct MainConnection {
    url: String,
}</pre></li>
				<li>In the <code>rocket()</code> function after <code>setup_logger()</code>, initialize the <code>flume</code> producer <a id="_idIndexMarker579"/>and consumer as follows:<pre>let (tx, rx) = flume::bounded::&lt;Message&gt;(5);</pre></li>
				<li>Let Rocket manage the <code>tx</code> variable. We also want to assign the generated Rocket object into a variable, because we want to get the database configuration. Find these lines:<pre>rocket::build()
    .attach(DBConnection::init())
    .attach(Template::fairing())
    .attach(Csrf::new())
    .mount(...)</pre></li>
			</ol>
			<p>Replace them with the following lines:</p>
			<pre><strong class="bold">let our_rocket =</strong> rocket::build()
    .attach(DBConnection::init())
    .attach(Template::fairing())
    .attach(Csrf::new())
    <strong class="bold">.manage(tx)</strong>
    .mount(...)<strong class="bold">;</strong></pre>
			<ol>
				<li value="19">After<a id="_idIndexMarker580"/> we get <code>our_rocket</code>, we want to get the database <a id="_idIndexMarker581"/>configuration <a id="_idIndexMarker582"/>and initialize a new database connection pool for the worker. Append the following lines:<pre>let config: Config = our_rocket
    .figment()
    .extract()
    .expect("Incorrect Rocket.toml configuration");
let pool = PgPoolOptions::new()
    .max_connections(5)
    .connect(&amp;config.databases.main_connection.url)
    .await
    .expect("Failed to connect to database");</pre></li>
				<li>Make a thread that will receive and process the message. Also, don't forget that to return <code>our_rocket</code> as a <code>rocket()</code> signature, we require the <code>Rocket&lt;Build&gt;</code> return value. Append the following lines:<pre>tokio::task::spawn_blocking(move || loop {
    let wm = rx.recv().unwrap();
    let handle = Handle::current();
    let get_connection = async { (&amp;pool).
    acquire().await.unwrap() };
    let mut connection = handle.block_on(get_
    connection);
    let _ = process_video(&amp;mut connection, wm);
});
our_rocket</pre></li>
				<li>Now, it's<a id="_idIndexMarker583"/> time to use the managed <code>tx</code> variable to send a<a id="_idIndexMarker584"/> message in the <code>create_post()</code> route<a id="_idIndexMarker585"/> handling function after we create the video. In <code>src/routes/post.rs</code>, add the required <code>use</code> declarations:<pre>use crate::errors::our_error::OurError;
use crate::models::worker::Message;
use flume::Sender;
use rocket::State;</pre></li>
				<li>In the <code>create_post()</code> function, retrieve the <code>Sender&lt;Message&gt;</code> instance managed by Rocket. Add the <code>Sender&lt;Message&gt;</code> instance to the function parameters:<pre>pub async fn create_post&lt;'r&gt;(
    ...
    <strong class="bold">tx: &amp;State&lt;Sender&lt;Message&gt;&gt;,</strong>
)</pre></li>
				<li>Before the <code>if mt.is_text()</code> block, append the following variables:<pre>let mut wm = Message::new();
let mut is_video = false;</pre></li>
				<li>After the <code>if mt.is_svg() {}</code> block, add <a id="_idIndexMarker586"/>a new block to<a id="_idIndexMarker587"/> initialize a temporary<a id="_idIndexMarker588"/> video value and assign the value to the <code>wm</code> variable we have initialized:<pre>else if mt.is_mp4() || mt.is_mpeg() || mt.is_ogg() || mt.is_mov() || mt.is_webm() {
    post_type = PostType::Video;
    let dest_filename = format!("{}.mp4", file_uuid);
    content.push_str("loading/assets/");
    content.push_str(&amp;dest_filename);
    is_video = true;
    wm.orig_filename = upload
        .file
        .path()
        .unwrap()
        .to_string_lossy()
        .to_string()
        .clone();
    wm.dest_filename = dest_filename.clone();
}</pre></li>
				<li>Find the post creation and return value in the following lines:<pre>Post::create(connection, user_uuid, post_type, &amp;content)
    .await
    .map_err(|_| create_err())?;
Ok(Flash::success(
    Redirect::to(format!("/users/{}/posts", 
    user_uuid)),
    "Successfully created post",
))</pre></li>
			</ol>
			<p>Modify this into<a id="_idIndexMarker589"/> the<a id="_idIndexMarker590"/> following <a id="_idIndexMarker591"/>lines:</p>
			<pre>Ok(Post::create(connection, user_uuid, post_type, &amp;content)
    .await
    .and_then(move |post| {
        if is_video {
            wm.uuid = post.uuid.to_string();
            let _ = tx.send(wm).map_err(|_| {
                OurError::new_internal_server_error(
                    String::from("Cannot process 
                    message"),
                    None,
                )
            })?;
        }
        Ok(Flash::success(
            Redirect::to(format!("/users/{}/posts", 
            user_uuid)),
            "Successfully created post",
        ))
    })
    .map_err(|_| create_err())?)</pre>
			<p>Now try <a id="_idIndexMarker592"/>restarting <a id="_idIndexMarker593"/>the <a id="_idIndexMarker594"/>application and uploading the video file; notice the loading page. If the video has been processed, the video should be displayed:</p>
			<div><div><img src="img/Figure_10.2_B16825.jpg" alt="Figure 10.2 – Uploaded video post&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Uploaded video post</p>
			<p>Message passing is a very useful technique to process long-running jobs. Try using this technique if your application requires heavy processing but you need to return responses quickly.</p>
			<p>Some applications use a <a id="_idIndexMarker595"/>more advanced application <a id="_idIndexMarker596"/>called a <strong class="bold">message broker</strong>, which can retry sending<a id="_idIndexMarker597"/> messages, schedule sending messages, send messages to multiple applications, and <a id="_idIndexMarker598"/>much more. Some well-known message broker applications are RabbitMQ, ZeroMQ, and Redis. There are many cloud services providing message broker services as well, such as Google Cloud Pub/Sub. </p>
			<p>Before we complete this chapter, there's one more thing we can do: delete the user post. Try writing the <code>delete_post()</code> function. You can find the sample code in the <code>Chapter10/06DeletingPost</code> folder on GitHub.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor124"/>Summary</h1>
			<p>In this chapter, we have learned several things. </p>
			<p>The first thing we learned is how to process multipart forms in Rocket. After that, we learned how to use <code>TempFile</code> to upload files. Along with uploading photos and videos, we learned how to process the image files and video files.</p>
			<p>We learned more about concurrent programming with <code>async</code>/<code>await</code> and multithreading. We also covered how to create a thread and pass a message to a different thread.</p>
			<p>In the next chapter, we will focus on how to do authentication, authorization, and serving the API from the Rocket application.</p>
		</div>
	</body></html>