<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-117"><em class="italic"><a id="_idTextAnchor118"/>Chapter 10</em>: Uploading and Processing Posts</h1>
			<p>In this chapter, we are going to learn how to upload user posts. We will start with the basics of multipart uploads and continue with <strong class="source-inline">TempFile</strong> to store the uploaded files. After uploading the files, we will implement image processing.</p>
			<p>The next thing we are going to learn about is improving processing using concurrent programming techniques, asynchronous programming, and multithreading. </p>
			<p>In this chapter, we are going to cover these main topics:</p>
			<ul>
				<li>Uploading a text post</li>
				<li>Uploading a photo post</li>
				<li>Processing files asynchronously</li>
				<li>Uploading a video post and process using worker</li>
			</ul>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Technical requirements</h1>
			<p>For this chapter, we have the usual requirements: a Rust compiler, a text editor, a web browser, and a PostgreSQL database server. Aside from those requirements, we are going to process uploaded video files. Download the <strong class="bold">FFmpeg</strong> command line from <a href="https://www.ffmpeg.org/download.html">https://www.ffmpeg.org/download.html</a>. FFmpeg is a multimedia framework to process media files. Make sure you can run FFmpeg on the terminal of your operating system.</p>
			<p>You can find the source code for this chapter at <a href="https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10">https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10</a>.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Uploading a text post</h1>
			<p>The <a id="_idIndexMarker528"/>first thing we want to upload is a text post because it's the simplest type. When we submit the form in HTML, we can specify the <strong class="source-inline">form</strong> tag <strong class="source-inline">enctype</strong> attribute as <strong class="source-inline">text/plain</strong>, <strong class="source-inline">application/x-www-form-urlencoded</strong>, or <strong class="source-inline">multipart/form-data</strong>. We already learned how to process <strong class="source-inline">application/x-www-form-urlencoded</strong> in the Rocket application when we learned how to create a user. We create a struct and derive <strong class="source-inline">FromForm</strong> for that struct. Later, in the route handling function, we set a route attribute, such as <strong class="source-inline">get</strong> or <strong class="source-inline">post</strong>, and assign the struct in the <strong class="source-inline">data</strong> annotation.</p>
			<p>The request body for <strong class="source-inline">Content-Type="application/x-www-form-urlencoded"</strong> is simple: the form keys and values are encoded in key-value tuples separated by <strong class="source-inline">&amp;</strong>, with an equals sign (<strong class="source-inline">=</strong>) between the key and the value. If the characters sent are not alphanumeric, they're percent-encoded (<strong class="source-inline">%</strong>). An example of a form request body is shown here:</p>
			<pre class="source-code">name=John%20Doe&amp;age=18</pre>
			<p>For uploading a file, <strong class="source-inline">Content-Type</strong> is <strong class="source-inline">multipart/form-data</strong>, and the body is different. Suppose we have the following HTTP header:</p>
			<pre class="source-code">Content-Type: multipart/form-data; boundary=---------------------------charactersforboundary123</pre>
			<p>The HTTP body can be as follows:</p>
			<pre class="source-code">Content-Type: multipart/form-data; boundary=---------------------------charactersforboundary123</pre>
			<pre class="source-code">Content-Disposition: form-data; name="name"</pre>
			<pre class="source-code">John Doe</pre>
			<pre class="source-code">-----------------------------charactersforboundary123</pre>
			<pre class="source-code">Content-Disposition: form-data; name="upload"; filename="file1.txt"</pre>
			<pre class="source-code">Content-Type: text/plain</pre>
			<pre class="source-code">Lorem ipsum dolor sit amet </pre>
			<pre class="source-code">-----------------------------charactersforboundary123</pre>
			<pre class="source-code">Content-Disposition: form-data; name="other_field"</pre>
			<pre class="source-code">Other field</pre>
			<p>In Rocket, we can process <strong class="source-inline">multipart/form-data</strong> by using the <strong class="source-inline">multer</strong> crate. Let's try to implement<a id="_idIndexMarker529"/> uploading using that crate by following these instructions:</p>
			<ol>
				<li>Modify our application by adding these crates into the <strong class="source-inline">Cargo.toml</strong> dependencies:<p class="source-code">multer = "2.0.2"</p><p class="source-code">tokio-util = "0.6.9"</p></li>
				<li>Add these configurations in <strong class="source-inline">Rocket.toml</strong> to handle the file upload limit and add a temporary directory to store the uploaded files:<p class="source-code">limits = {"file/avif" = "1Mib", "file/gif" = "1Mib", "file/jpg" = "1Mib", "file/jpeg" = "1Mib", "file/png" = "1Mib", "file/svg" = "1Mib", "file/webp" = "1Mib", "file/webm" = "64Mib", "file/mp4" = "64Mib", "file/mpeg4" = "64Mib", "file/mpg" = "64Mib", "file/mpeg" = "64Mib", "file/mov" = "64Mib"}</p><p class="source-code">temp_dir = "/tmp"</p></li>
				<li>Modify <strong class="source-inline">src/views/posts/index.html.tera</strong> to add a form where the user can upload a file. Add the following lines after the pagination block:<p class="source-code">&lt;form action="/users/{{ user.uuid }}/posts" enctype="multipart/form-data" method="POST"&gt;</p><p class="source-code">  &lt;fieldset&gt;</p><p class="source-code">    &lt;legend&gt;New Post&lt;/legend&gt;</p><p class="source-code">    &lt;div class="row"&gt;</p><p class="source-code">      &lt;div class="col-sm-12 col-md-3"&gt;</p><p class="source-code">        &lt;label for="upload"&gt;Upload file:&lt;/label&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;div class="col-sm-12 col-md"&gt;</p><p class="source-code">        &lt;input type="file" name="file" accept=" </p><p class="source-code">        text/plain"&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;button type="submit" value="Submit"&gt;Submit&lt;/</p><p class="source-code">    button&gt;</p><p class="source-code">  &lt;/fieldset&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Add<a id="_idIndexMarker530"/> the <strong class="source-inline">create()</strong> method for <strong class="source-inline">Post</strong> in the <strong class="source-inline">src/models/post.rs</strong> file. We want a method to save the <strong class="source-inline">Post</strong> data into the database. Add the following lines inside the <strong class="source-inline">impl Post {}</strong> block:<p class="source-code">pub async fn create(</p><p class="source-code">    connection: &amp;mut PgConnection,</p><p class="source-code">    user_uuid: &amp;str,</p><p class="source-code">    post_type: PostType,</p><p class="source-code">    content: &amp;str,</p><p class="source-code">) -&gt; Result&lt;Self, OurError&gt; {</p><p class="source-code">    let parsed_uuid = Uuid::parse_str(</p><p class="source-code">    user_uuid).map_err(OurError::from_uuid_error)?;</p><p class="source-code">    let uuid = Uuid::new_v4();</p><p class="source-code">    let query_str = r#"INSERT INTO posts</p><p class="source-code">(uuid, user_uuid, post_type, content)</p><p class="source-code">VALUES</p><p class="source-code">($1, $2, $3, $4)</p><p class="source-code">RETURNING *"#;</p><p class="source-code">    Ok(sqlx::query_as::&lt;_, Self&gt;(query_str)</p><p class="source-code">        .bind(uuid)</p><p class="source-code">        .bind(parsed_uuid)</p><p class="source-code">        .bind(post_type)</p><p class="source-code">        .bind(content)</p><p class="source-code">        .fetch_one(connection)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(OurError::from_sqlx_error)?)</p><p class="source-code">}</p></li>
				<li>We can <a id="_idIndexMarker531"/>remove <strong class="source-inline">FromForm</strong> as we will not use the placeholder anymore. Remove these lines from <strong class="source-inline">src/models/post.rs</strong>:<p class="source-code"><strong class="bold">use rocket::form::FromForm;</strong></p><p class="source-code">...</p><p class="source-code">#[derive(FromRow<strong class="bold">, FromForm</strong>)]</p><p class="source-code">pub struct Post {...}</p></li>
				<li>We need the value from the request's <strong class="source-inline">Content-Type</strong> to get a multipart boundary, but Rocket doesn't have a request guard that can do that. Let's create a type that can handle a raw HTTP <strong class="source-inline">Content-Type</strong> header. In <strong class="source-inline">src/lib.rs</strong>, add the following line:<p class="source-code">pub mod guards;</p></li>
			</ol>
			<p>In the <strong class="source-inline">src</strong> folder, create another folder, named <strong class="source-inline">guards</strong>, and then create a <strong class="source-inline">src/guards/mod.rs</strong> file. Inside the file, add the struct to handle the raw HTTP request body:</p>
			<p class="source-code">use rocket::request::{FromRequest, Outcome};</p>
			<p class="source-code">pub struct RawContentType&lt;'r&gt;(pub &amp;'r str);</p>
			<ol>
				<li value="7">Implement <strong class="source-inline">FromRequest</strong> for <strong class="source-inline">RawContent</strong> to create a request guard:<p class="source-code">#[rocket::async_trait]</p><p class="source-code">impl&lt;'r&gt; FromRequest&lt;'r&gt; for RawContentType&lt;'r&gt; {</p><p class="source-code">    type Error = ();</p><p class="source-code">    async fn from_request(req: &amp;'r rocket::</p><p class="source-code">    Request&lt;'_&gt;) -&gt; Outcome&lt;Self, Self::Error&gt; {</p><p class="source-code">        let header = req.headers().get_one("</p><p class="source-code">        Content-Type").or(Some("")).unwrap();</p><p class="source-code">        Outcome::Success(RawContentType(header))</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Rocket<a id="_idIndexMarker532"/> will consider the <strong class="source-inline">"/users/delete/&lt;uuid&gt;"</strong> route as conflicting with the <strong class="source-inline">"/users/&lt;user_uuid&gt;/posts"</strong> route. To avoid that problem, we can add <strong class="source-inline">rank</strong> to the route macro. In <strong class="source-inline">src/routes/user.rs</strong>, edit the route macro above the <strong class="source-inline">delete_user_entry_point()</strong> function:<p class="source-code">#[post("/users/delete/&lt;uuid&gt;", format = "application/x-www-form-urlencoded", <strong class="bold">rank = 2</strong>)]</p><p class="source-code">pub async fn delete_user_entry_point(...) -&gt; ... {...}</p></li>
				<li>In <strong class="source-inline">src/routes/post.rs</strong>, add the required <strong class="source-inline">use</strong> declaration to implement the handling of the HTTP multipart request:<p class="source-code">use crate::guards::RawContentType;</p><p class="source-code">use crate::models::post_type::PostType;</p><p class="source-code">use multer::Multipart;</p><p class="source-code">use rocket::request::FlashMessage;</p><p class="source-code">use rocket::response::{Flash, Redirect};</p><p class="source-code">use rocket::data::{ByteUnit, Data};</p></li>
				<li>Add a constant to limit the size of the uploaded file:<p class="source-code">const TEXT_LIMIT: ByteUnit = ByteUnit::Kibibyte(64); </p></li>
				<li>Let's <a id="_idIndexMarker533"/>modify the <strong class="source-inline">get_posts()</strong> function as well to add a <strong class="source-inline">flash</strong> message if the upload fails or is successful:<p class="source-code">pub async fn get_posts(</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">flash: Option&lt;FlashMessage&lt;'_&gt;&gt;,</strong></p><p class="source-code">) -&gt; HtmlResponse {</p><p class="source-code">    <strong class="bold">let flash_message = flash.map(|fm| </strong></p><p class="source-code">    <strong class="bold">String::from(fm.message()));</strong></p><p class="source-code">    ...</p><p class="source-code">    let context = context! {<strong class="bold">flash: flash_message</strong>,...};</p><p class="source-code">    Ok(Template::render("posts/index", context))</p><p class="source-code">}</p></li>
				<li>Now it's time to implement the <strong class="source-inline">create_post()</strong> function. The first thing we need to do is modify the <strong class="source-inline">post</strong> route macro and function signature:<p class="source-code">#[post("/users/&lt;<strong class="bold">user_uuid</strong>&gt;/posts", format = "<strong class="bold">multipart/form-data</strong>", data = "&lt;<strong class="bold">upload</strong>&gt;"<strong class="bold">, rank = 1</strong>)]</p><p class="source-code">pub async fn create_post(</p><p class="source-code">    mut <strong class="bold">db</strong>: Connection&lt;DBConnection&gt;,</p><p class="source-code">    <strong class="bold">user_uuid</strong>: &amp;str,</p><p class="source-code">    <strong class="bold">content_type: RawContentType&lt;'_&gt;,</strong></p><p class="source-code">    <strong class="bold">upload: Data&lt;'_&gt;,</strong></p><p class="source-code">) -&gt; <strong class="bold">Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt;</strong> {...}</p></li>
				<li>Inside<a id="_idIndexMarker534"/> the <strong class="source-inline">create_post()</strong> function, add a closure that returns an error. We add a closure to avoid repetition. Add the following lines:<p class="source-code">let create_err = || {</p><p class="source-code">    Flash::error(</p><p class="source-code">        Redirect::to(format!("/users/{}/posts", </p><p class="source-code">        user_uuid)),</p><p class="source-code">        "Something went wrong when uploading file",</p><p class="source-code">    )</p><p class="source-code">};</p></li>
				<li>Under the <strong class="source-inline">create_err</strong> definition, continue by getting the boundary from the <strong class="source-inline">content_type</strong> request guard:<p class="source-code">let boundary = multer::parse_boundary(content_type.0).map_err(|_| create_err())?;</p></li>
				<li>For <strong class="source-inline">TextPost</strong>, we just store the content of the text file in the post's <strong class="source-inline">content</strong> field. Let's open the request body, process it as a multipart, and define a new variable to store the content of the body. Append the following lines:<p class="source-code">let upload_stream = upload.open(TEXT_LIMIT);</p><p class="source-code">let mut multipart = Multipart::new(tokio_util::io::ReaderStream::new(upload_stream), boundary);</p><p class="source-code">let mut text_post = String::new();</p></li>
				<li>The <a id="_idIndexMarker535"/>next thing we need to do is to iterate the multipart fields. We can iterate multipart fields as follows:<p class="source-code">while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {</p><p class="source-code">    let field_name = field.name();</p><p class="source-code">    let file_name = field.file_name();</p><p class="source-code">    let content_type = field.content_type();</p><p class="source-code">    println!(</p><p class="source-code">        "Field name: {:?}, File name: {:?}, </p><p class="source-code">        Content-Type: {:?}",</p><p class="source-code">        field_name, file_name, content_type</p><p class="source-code">    );</p><p class="source-code">}</p></li>
			</ol>
			<p>As we only have one field in the form, we can just get the content of the first field and put the value in the <strong class="source-inline">text_post</strong> variable. Append the following lines:</p>
			<p class="source-code">while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {</p>
			<p class="source-code">    while let Some(field_chunk) = </p>
			<p class="source-code">    field.chunk().await.map_err(|_| create_err())? {</p>
			<p class="source-code">        text_post.push_str(std::str::from_utf8(</p>
			<p class="source-code">        field_chunk.as_ref()).unwrap());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="17">Finally, after we get the request body content and assign it to <strong class="source-inline">text_post</strong>, it's time to <a id="_idIndexMarker536"/>store it in the database and return to the <strong class="source-inline">posts</strong> list page. Append the following lines:<p class="source-code">let connection = db.acquire().await.map_err(|_| create_err())?;</p><p class="source-code">Post::create(connection, user_uuid, PostType::Text, &amp;text_post)</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| create_err())?;</p><p class="source-code">Ok(Flash::success(</p><p class="source-code">    Redirect::to(format!("/users/{}/posts", </p><p class="source-code">    user_uuid)),</p><p class="source-code">    "Successfully created post",</p><p class="source-code">))</p></li>
			</ol>
			<p>Now, try restarting the application and uploading the text file. You should see the content of the text file on the <strong class="source-inline">posts</strong> list page: </p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_10.1_B16825.jpg" alt="Figure 10.1 – Uploaded text posts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Uploaded text posts</p>
			<p>Now that<a id="_idIndexMarker537"/> we have implemented uploading and processing text files, it is time to move on to uploading and processing photo files.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Uploading a photo post</h1>
			<p>Before Rocket <em class="italic">0.5</em>, uploading multipart files had to be implemented manually, as in the previous section. Starting from Rocket <em class="italic">0.5</em>, there's a <strong class="source-inline">rocket::fs::TempFile</strong> type that can be used directly to handle uploaded files.</p>
			<p>To handle <a id="_idIndexMarker538"/>processing image files, we can use an <strong class="source-inline">image</strong> crate. The crate can handle opening and saving various image file formats. The <strong class="source-inline">image</strong> crate also provides ways to manipulate the image.</p>
			<p>Websites process uploaded media files such as images for various reasons, including reducing disk usage. Some websites reduce the image quality and encode the uploaded images into file format with a default smaller size. In this example, we are going to convert all uploaded images into JPEG files with 75% quality.</p>
			<p>Let's implement uploading image files using the <strong class="source-inline">image</strong> crate and the <strong class="source-inline">TempFile</strong> struct by following <a id="_idIndexMarker539"/>these steps:</p>
			<ol>
				<li value="1">Remove <strong class="source-inline">multer</strong> and <strong class="source-inline">tokio-util</strong> from <strong class="source-inline">Cargo.toml</strong>. Then, add the <strong class="source-inline">image</strong> crate to <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">image = "0.24.0"</p></li>
				<li>Remove <strong class="source-inline">pub mod guards;</strong> from <strong class="source-inline">src/lib.rs</strong> and then remove the <strong class="source-inline">src/guards</strong> folder.</li>
				<li>Add a struct to handle uploaded files in <strong class="source-inline">src/models/post.rs</strong>:<p class="source-code">use rocket::fs::TempFile;</p><p class="source-code">...</p><p class="source-code">#[derive(Debug, FromForm)]</p><p class="source-code">pub struct NewPost&lt;'r&gt; {</p><p class="source-code">    pub file: TempFile&lt;'r&gt;,</p><p class="source-code">}</p></li>
				<li>Modify <strong class="source-inline">src/views/posts/index.html.tera</strong> to include images as accepted files:<p class="source-code">...</p><p class="source-code">&lt;input type="file" name="file" accept="text/plain<strong class="bold">,image/*</strong>"&gt;</p><p class="source-code">...</p></li>
				<li>Remove unused <strong class="source-inline">use</strong> declarations, <strong class="source-inline">TEXT_LIMIT</strong> constant, and part of the <strong class="source-inline">create_post()</strong> function from the boundary variable declaration to the multipart iteration block:<p class="source-code">use crate::guards::RawContentType;</p><p class="source-code">use multer::Multipart;</p><p class="source-code">use rocket::data::{ByteUnit, Data};</p><p class="source-code">...</p><p class="source-code">const TEXT_LIMIT: ByteUnit = ByteUnit::Kibibyte(64);</p><p class="source-code">...</p><p class="source-code">let boundary = multer::parse_boundary(content_type.0).map_err(|_| create_err())?;</p><p class="source-code">...until</p><p class="source-code">while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {</p><p class="source-code">...</p><p class="source-code">}</p></li>
				<li>Add the<a id="_idIndexMarker540"/> required <strong class="source-inline">use</strong> declarations:<p class="source-code">use crate::models::post::{NewPost, Post, ShowPost};</p><p class="source-code">use image::codecs::jpeg::JpegEncoder;</p><p class="source-code">use image::io::Reader as ImageReader;</p><p class="source-code">use image::{DynamicImage, ImageEncoder};</p><p class="source-code">use rocket::form::Form;</p><p class="source-code">use std::fs::File;</p><p class="source-code">use std::io::{BufReader, Read};</p><p class="source-code">use std::ops::Deref;</p><p class="source-code">use std::path::Path;</p></li>
				<li>We can use the <strong class="source-inline">NewPost</strong> struct that we created earlier as a regular <strong class="source-inline">FromForm</strong> deriving struct. Modify the <strong class="source-inline">create_post()</strong> function signature:<p class="source-code">pub async fn create_post<strong class="bold">&lt;'r&gt;</strong>(</p><p class="source-code">    mut db: Connection&lt;DBConnection&gt;,</p><p class="source-code">    user_uuid: &amp;str,</p><p class="source-code">    mut upload: <strong class="bold">Form&lt;NewPost&lt;'r&gt;&gt;,</strong></p><p class="source-code">) -&gt; Result&lt;Flash&lt;Redirect&gt;, Flash&lt;Redirect&gt;&gt; {...}</p></li>
				<li>Under the <strong class="source-inline">create_err</strong> closure declaration, generate a random <strong class="source-inline">uuid</strong> name for the new name of the uploaded file:<p class="source-code">let file_uuid = uuid::Uuid::new_v4().to_string();</p></li>
				<li>Check <strong class="source-inline">Content-Type</strong> of the<a id="_idIndexMarker541"/> uploaded file, and if the Temp File cannot determine it, return an error:<p class="source-code">if upload.file.content_type().is_none() {</p><p class="source-code">    return Err(create_err());</p><p class="source-code">}</p></li>
				<li>Find the extension of the uploaded file and create a new filename:<p class="source-code">let ext = upload.file.content_type().unwrap().extension().unwrap();</p><p class="source-code">let tmp_filename = format!("/tmp/{}.{}", &amp;file_uuid, &amp;ext);</p></li>
				<li>Persist the uploaded file in the temporary location:<p class="source-code">upload</p><p class="source-code">    .file</p><p class="source-code">    .persist_to(tmp_filename)</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| create_err())?;</p></li>
				<li>Define <strong class="source-inline">content</strong> and <strong class="source-inline">post_type</strong> to be saved later:<p class="source-code">let mut content = String::new();</p><p class="source-code">let mut post_type = PostType::Text;</p></li>
				<li>Check the media type of the file. We can separate media types into bitmaps and <strong class="source-inline">svg</strong> files. For now, we are going to process text and images only. We will process videos in the next section. Append the following lines:<p class="source-code">let mt = upload.file.content_type().unwrap().deref();</p><p class="source-code">if mt.is_text() {</p><p class="source-code">} else if mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif() {</p><p class="source-code">} else if mt.is_svg() {</p><p class="source-code">} else {</p><p class="source-code">    return Err(create_err());</p><p class="source-code">}</p></li>
				<li>We want to<a id="_idIndexMarker542"/> process the text first. Create a vector of byte (<strong class="source-inline">u8</strong>), open and read the file into the vector, and push the vector into the content String we defined previously. Add these lines inside the <strong class="source-inline">mt.is_text()</strong> block:<p class="source-code">let orig_path = upload.file.path().unwrap().to_string_lossy().to_string();</p><p class="source-code">let mut text_content = vec![];</p><p class="source-code">let _ = File::open(orig_path)</p><p class="source-code">    .map_err(|_| create_err())?</p><p class="source-code">    .read(&amp;mut text_content)</p><p class="source-code">    .map_err(|_| create_err())?;</p><p class="source-code">content.push_str(std::str::from_utf8(&amp;text_content).unwrap());</p></li>
				<li>Next, we want to process the <strong class="source-inline">svg</strong> file. For this one, we cannot convert it into a JPEG file; we just want to copy the file into a <strong class="source-inline">static</strong> folder and create an image path of <strong class="source-inline">/assets/random_uuid_filename.svg</strong>. Append the following lines<a id="_idIndexMarker543"/> inside the <strong class="source-inline">mt.is_svg()</strong> block:<p class="source-code">post_type = PostType::Photo;</p><p class="source-code">let dest_filename = format!("{}.svg", file_uuid);</p><p class="source-code">content.push_str("/assets/");</p><p class="source-code">content.push_str(&amp;dest_filename);</p><p class="source-code">let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);</p><p class="source-code">upload</p><p class="source-code">    .file</p><p class="source-code">    .move_copy_to(&amp;dest_path)</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| create_err())?;</p></li>
				<li>For bitmap files, we want to convert them into JPEG files. First, we want to define the destination filename. Append the following lines inside the <strong class="source-inline">mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif()</strong> block:<p class="source-code">post_type = PostType::Photo;</p><p class="source-code">let orig_path = upload.file.path().unwrap().to_string_lossy().to_string();</p><p class="source-code">let dest_filename = format!("{}.jpg", file_uuid);</p><p class="source-code">content.push_str("/assets/");</p><p class="source-code">content.push_str(&amp;dest_filename);</p></li>
				<li>Continuing the bitmap processing, open the file into a buffer and decode the buffer into a binary format that the <strong class="source-inline">image</strong> crate understands:<p class="source-code">let orig_file = File::open(orig_path).map_err(|_| create_err())?;</p><p class="source-code">let file_reader = BufReader::new(orig_file);</p><p class="source-code">let image: DynamicImage = ImageReader::new(file_reader)</p><p class="source-code">    .with_guessed_format()</p><p class="source-code">    .map_err(|_| create_err())?</p><p class="source-code">    .decode()</p><p class="source-code">    .map_err(|_| create_err())?;</p></li>
				<li>Create <a id="_idIndexMarker544"/>a path for the destination file where we want the JPEG result to be, and create a file at that path. Append the following lines:<p class="source-code">let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);</p><p class="source-code">let mut file_writer = File::create(dest_path).map_err(|_| create_err())?;</p></li>
				<li>We then create a JPEG decoder, specify the JPEG quality and the image attributes, and write the binary format into the destination file. Append the following lines:<p class="source-code">let encoder = JpegEncoder::new_with_quality(&amp;mut file_writer, 75);</p><p class="source-code">encoder</p><p class="source-code">    .write_image(</p><p class="source-code">        image.as_bytes(),</p><p class="source-code">        image.width(),</p><p class="source-code">        image.height(),</p><p class="source-code">        image.color(),</p><p class="source-code">    )</p><p class="source-code">    .map_err(|_| create_err())?;</p></li>
				<li>Finally, we can save the post as in the previous section. Change the <strong class="source-inline">Post::create()</strong> method as follows:<p class="source-code">Post::create(connection, user_uuid, <strong class="bold">post_type</strong>, <strong class="bold">&amp;content</strong>)</p><p class="source-code">...</p></li>
			</ol>
			<p>We have now finished <a id="_idIndexMarker545"/>creating the routine to upload and process text and image files using <strong class="source-inline">TempFile</strong> and the <strong class="source-inline">image</strong> crate. Unfortunately, this process uses a more traditional programming paradigm that can be improved. Let's learn how to process the files asynchronously in the next section.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Processing files asynchronously</h1>
			<p>At the beginning <a id="_idIndexMarker546"/>of computer development, the available resources were usually limited in some way. For example, an older generation CPU can only execute one thing at a time. This makes computing difficult because computer resources must wait for the execution of tasks sequentially. For example, while the CPU is calculating a number, the user cannot input anything using the keyboard.</p>
			<p>Then, people invented operating systems <a id="_idIndexMarker547"/>with a <strong class="bold">scheduler</strong>, which assigns resources to run tasks. The invention of the scheduler led to the <a id="_idIndexMarker548"/>idea of a <strong class="bold">thread</strong>. A thread, or operating system thread, is the smallest sequence of program instructions that can be executed independently by the scheduler.</p>
			<p>Some modern programming languages can generate applications that spawn multiple threads at the same time, and so are<a id="_idIndexMarker549"/> called <strong class="bold">multithreaded</strong> applications.</p>
			<p>Creating multithreaded applications can be a drawback, as creating a thread allocates various resources, such as a memory stack. In certain applications, such as desktop applications, it's suitable to create multiple threads. But, creating multiple threads can be a problem in other applications, such as web applications, where requests and responses come and go quickly.</p>
			<p>There are<a id="_idIndexMarker550"/> techniques to <a id="_idIndexMarker551"/>overcome this problem in multiple ways. Some languages opt to have <strong class="bold">green threads</strong>, or <strong class="bold">virtual threads</strong>, where the language runtime manages a single operating system thread and makes the program behave as if it's multithreaded. Some other languages, such as Javascript and Rust, opt to have <strong class="bold">async/await</strong>, a syntactic <a id="_idIndexMarker552"/>feature that allows execution parts to be suspended and resumed.</p>
			<p>In the previous<a id="_idIndexMarker553"/> section, we used the Rust standard library to open and write files for image processing. The library itself is called blocking because, it waits until all the files have been loaded or written. That is not efficient because I/O operations are slower than CPU operations, and the thread can be used to do other operations. We can improve the program by using asynchronous programming.</p>
			<p>In Rust, we can declare an <strong class="source-inline">async</strong> function as follows:</p>
			<pre class="source-code">async fn async_task1() {...}</pre>
			<pre class="source-code">async fn async_task2() {...}</pre>
			<p>Any <strong class="source-inline">async</strong> function returns the <strong class="source-inline">std::future::Future</strong> trait. By default, running the function does not do anything. We can use <strong class="source-inline">async_task1</strong> and an executor, such as the <strong class="source-inline">futures</strong> crate, to run the <strong class="source-inline">async</strong> function. The following code will behave like regular programming: </p>
			<pre class="source-code">use futures::executor::block_on;</pre>
			<pre class="source-code">async fn async_task1() {...}</pre>
			<pre class="source-code">fn main() {</pre>
			<pre class="source-code">    let wait = async_task1();</pre>
			<pre class="source-code">    block_on(wait); // wait until async_task1 finish</pre>
			<pre class="source-code">}</pre>
			<p>We can use <strong class="source-inline">.await</strong> after the function usage to not block the thread, as follows:</p>
			<pre class="source-code">async fn combine() {</pre>
			<pre class="source-code">    async_task1().await;</pre>
			<pre class="source-code">    async_task2().await;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn main() {</pre>
			<pre class="source-code">    block_on(combine());</pre>
			<pre class="source-code">}</pre>
			<p>Or, we <a id="_idIndexMarker554"/>can wait for both functions to finish, as in the following:</p>
			<pre class="source-code">async fn combine2() {</pre>
			<pre class="source-code">  let t1 = async_task1();</pre>
			<pre class="source-code">  let t2 = async_task2();</pre>
			<pre class="source-code">  futures::join!(t1, t2);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fn main() {</pre>
			<pre class="source-code">  block_on(combine2());</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">futures</strong> crate is very basic; we can use other runtimes that provide an executor and a scheduler and many other functionalities. There are a couple of competing runtimes in the Rust ecosystem, such as <strong class="source-inline">tokio</strong>, <strong class="source-inline">smol</strong>, and <strong class="source-inline">async-std</strong>. We can use those different runtimes together but it's not very efficient, so it's advised to stick with a single runtime. Rocket itself uses <strong class="source-inline">tokio</strong> as the runtime for <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>.</p>
			<p>We have used <strong class="source-inline">async</strong> functions in code before, so let's now use <strong class="source-inline">async</strong> functions in more depth. Let's convert the previous image processing to use the <strong class="source-inline">async</strong> programming technique by following these steps:</p>
			<ol>
				<li value="1">Add the crate dependency in <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">tokio = {version = "1.16", features = ["fs", "rt"]}</p></li>
				<li>If we look at the code that handles uploading, we can see that file-related operations use a standard library, so they are blocking. We want to replace those libraries with Tokio-equivalent <strong class="source-inline">async</strong> libraries. Remove the <strong class="source-inline">use</strong> declaration from <strong class="source-inline">src/routes/post.rs</strong>:<p class="source-code">use std::fs::File;</p><p class="source-code">use std::io::{BufReader, Read};</p></li>
			</ol>
			<p>Then, add these <strong class="source-inline">use</strong> declarations:</p>
			<p class="source-code">use image::error::ImageError;</p>
			<p class="source-code">use std::io::Cursor;</p>
			<p class="source-code">use tokio::fs::File;</p>
			<p class="source-code">use tokio::io::AsyncReadExt;</p>
			<ol>
				<li value="3">Replace <a id="_idIndexMarker555"/>the content of the <strong class="source-inline">mt.is_text()</strong> block from the standard library into a Tokio-equivalent library. Find the following lines:<p class="source-code">let _ = File::open(orig_path)</p><p class="source-code">    .map_err(|_| create_err())?</p><p class="source-code">    .read(&amp;mut text_content)</p><p class="source-code">    .map_err(|_| create_err())?;</p></li>
			</ol>
			<p>Replace those lines with the following:</p>
			<p class="source-code">let _ = File::open(orig_path)</p>
			<p class="source-code">    <strong class="bold">.await</strong></p>
			<p class="source-code">    .map_err(|_| create_err())?</p>
			<p class="source-code">    <strong class="bold">.read_to_end</strong>(&amp;mut text_content)</p>
			<p class="source-code">    <strong class="bold">.await</strong></p>
			<p class="source-code">    .map_err(|_| create_err())?;</p>
			<ol>
				<li value="4">Next, replace reading the file in the <strong class="source-inline">mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif()</strong> block. Replace synchronous reading of the file and use a Tokio-equivalent file reading functionality. We want to wrap the result in <strong class="source-inline">std::io::Cursor</strong> because <strong class="source-inline">ImageReader</strong> methods require the <strong class="source-inline">std::io::Read + std::io:Seek</strong> trait, and <strong class="source-inline">Cursor</strong> is a type that implemented those traits.</li>
			</ol>
			<p>Find the following lines:</p>
			<p class="source-code">let orig_file = File::open(orig_path).map_err(|_| create_err())?;</p>
			<p class="source-code">let file_reader = BufReader::new(orig_file);</p>
			<p>Replace those lines with the following:</p>
			<p class="source-code">let orig_file = <strong class="bold">tokio::fs::read</strong>(orig_path).await.map_err(|_| create_err())?;</p>
			<p class="source-code">let <strong class="bold">read_buffer</strong> = <strong class="bold">Cursor</strong>::new(orig_file);</p>
			<ol>
				<li value="5">Wrap <a id="_idIndexMarker556"/>the image decoding code in <strong class="source-inline">tokio::task::spawn_blocking</strong>. This function allows synchronous code to run inside the Tokio executor. Find the following lines:<p class="source-code">let image: DynamicImage = ImageReader::new(file_reader)</p><p class="source-code">    .with_guessed_format()</p><p class="source-code">    .map_err(|_| create_err())?</p><p class="source-code">    .decode()</p><p class="source-code">    .map_err(|_| create_err())?</p></li>
			</ol>
			<p>Replace them with the following lines:</p>
			<p class="source-code"><strong class="bold">let encoded_result: Result&lt;DynamicImage, ()&gt; = tokio::task::spawn_blocking(|| {</strong></p>
			<p class="source-code">    <strong class="bold">Ok(</strong>ImageReader::new(<strong class="bold">read_buffer</strong>)</p>
			<p class="source-code">        .with_guessed_format()</p>
			<p class="source-code">        .map_err(|_| <strong class="bold">()</strong>)?</p>
			<p class="source-code">        .decode()</p>
			<p class="source-code">        .map_err(|_| <strong class="bold">()</strong>)?)</p>
			<p class="source-code">})</p>
			<p class="source-code"><strong class="bold">.await</strong></p>
			<p class="source-code"><strong class="bold">.map_err(|_| create_err())?;</strong></p>
			<p class="source-code"><strong class="bold">let image = encoded_result.map_err(|_| create_err())?;</strong></p>
			<ol>
				<li value="6">Next, we<a id="_idIndexMarker557"/> want to wrap the JPEG encoding in <strong class="source-inline">spawn_blocking</strong> as well. We also want to change file writing into a Tokio <strong class="source-inline">async</strong> function. Find the following lines:<p class="source-code">let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);</p><p class="source-code">let mut file_writer = File::create(dest_path).map_err(|_| create_err())?;</p><p class="source-code">JpegEncoder::new_with_quality(&amp;mut file_writer, 75)</p><p class="source-code">    .write_image(</p><p class="source-code">        image.as_bytes(),</p><p class="source-code">        image.width(),</p><p class="source-code">        image.height(),</p><p class="source-code">        image.color(),</p><p class="source-code">    )</p><p class="source-code">    .map_err(|_| create_err())?;</p></li>
			</ol>
			<p>Replace them with the following lines:</p>
			<p class="source-code">let write_result: Result&lt;Vec&lt;u8&gt;, ImageError&gt; = tokio::task::spawn_blocking(move || {</p>
			<p class="source-code">    let mut write_buffer: Vec&lt;u8&gt; = vec![];</p>
			<p class="source-code">    let mut write_cursor = Cursor::new(&amp;mut </p>
			<p class="source-code">    write_buffer);</p>
			<p class="source-code">    let _ = JpegEncoder::new_with_quality(&amp;mut </p>
			<p class="source-code">    write_cursor, 75).write_image(</p>
			<p class="source-code">        image.as_bytes(),</p>
			<p class="source-code">        image.width(),</p>
			<p class="source-code">        image.height(),</p>
			<p class="source-code">        image.color(),</p>
			<p class="source-code">    )?;</p>
			<p class="source-code">    Ok(write_buffer)</p>
			<p class="source-code">})</p>
			<p class="source-code">.await</p>
			<p class="source-code">.map_err(|_| create_err())?;</p>
			<p class="source-code">let write_bytes = write_result.map_err(|_| create_err())?;</p>
			<p class="source-code">let dest_path = Path::new(rocket::fs::relative!("static")).join(&amp;dest_filename);</p>
			<p class="source-code">tokio::fs::write(dest_path, &amp;write_bytes)</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .map_err(|_| create_err())?;</p>
			<p>Now, we can<a id="_idIndexMarker558"/> run the application and try the uploading functionality again. There should be no differences, except it now uses the <strong class="source-inline">async</strong> function. If there are a lot of requests, an asynchronous application should fare better because the application can use the thread to do other tasks while the application deals with long I/O, such as reading from and writing to a database, dealing with network connections, and handling files, for example.</p>
			<p>There is one more example where the application uses <strong class="source-inline">tokio::sync::channel</strong> to create another asynchronous channel, and <strong class="source-inline">rayon</strong> (a crate for data parallelism). You can find this example in the source code for this chapter in the <strong class="source-inline">Chapter10/04UploadingPhotoRayon</strong> folder.</p>
			<p>In the next section, let's create the handle for uploading videos and processing videos using a worker.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor123"/>Uploading a video post and process using a worker</h1>
			<p>In this section, we <a id="_idIndexMarker559"/>are going to process an uploaded video. Processing an uploaded video is not a trivial task as it can take a lot of time, so even with the <strong class="source-inline">async</strong> programming technique, the generated response will take a lot of time.</p>
			<p>Another <a id="_idIndexMarker560"/>technique in programming to solve a long processing time is using message passing. We are going to create another thread to process the video. When a<a id="_idIndexMarker561"/> user uploads a video, we will do the following:</p>
			<ol>
				<li value="1">Generate a path to the temporary file.</li>
				<li>Mark the path as unprocessed.</li>
				<li>Store the path to the file in the database.</li>
				<li>Send a message from the main Rocket thread into the thread for processing the video.</li>
				<li>Return the response for uploading the video.</li>
			</ol>
			<p>If the thread to process the video receives a message, it will find the data from the database, process the file, and mark the post as finished.</p>
			<p>If the user requests the <strong class="source-inline">posts</strong> list or posts while it's still being processed, the user will see the loading image. If the user requests the <strong class="source-inline">posts</strong> list or posts after the processing is finished, the user will see the correct video in the web browser.</p>
			<p>Rust libraries for video processing are not very mature yet. There are a couple of libraries that can be used to wrap the <strong class="source-inline">ffmpeg</strong> library, but using the <strong class="source-inline">ffmpeg</strong> library is complicated, even if it's used in its own language, the C language. One solution is to use the <strong class="source-inline">ffmpeg-cli</strong> crate, a wrapper for the <strong class="source-inline">ffmpeg</strong> binary.</p>
			<p>Follow these instructions to process uploaded video files:</p>
			<ol>
				<li value="1">We want to add the <strong class="source-inline">ffmpeg-cli</strong> crate and the <strong class="source-inline">flume</strong> crate as dependencies. The <strong class="source-inline">flume</strong> crate works by generating a channel, a producer, and a consumer. There are similar libraries, such as <strong class="source-inline">std::sync::mpsc</strong> or <strong class="source-inline">crossbeam-channel</strong>, which can be used with varying performance and quality. Add the dependencies to <strong class="source-inline">Cargo.toml</strong>:<p class="source-code">flume = "0.10.10"</p><p class="source-code">ffmpeg-cli = "0.1"</p></li>
				<li>Change<a id="_idIndexMarker562"/> the form to allow uploading video files. Edit <strong class="source-inline">src/views/posts/index.html.tera</strong>:<p class="source-code">&lt;input type="file" name="file" accept="text/plain,image/*<strong class="bold">,video/*</strong>"&gt;</p></li>
				<li>Find a <a id="_idIndexMarker563"/>placeholder image to show the video is still being <a id="_idIndexMarker564"/>processed. There's a <strong class="source-inline">loading.gif</strong> example file in the source code for this section in <strong class="source-inline">Chapter10/05ProcessingVideo/static/loading.gif</strong>.</li>
				<li>Modify the <strong class="source-inline">raw_html()</strong> method for <strong class="source-inline">VideoPost</strong> in <strong class="source-inline">src/models/video_post.rs</strong> to show the <strong class="source-inline">loading.gif</strong> image if the video is still not processed yet:<p class="source-code">fn raw_html(&amp;self) -&gt; String {</p><p class="source-code"><strong class="bold">    if self.0.content.starts_with("loading") {</strong></p><p class="source-code"><strong class="bold">        return String::from(</strong></p><p class="source-code"><strong class="bold">            "&lt;figure&gt;&lt;img src=\"/assets/loading.gif\" </strong></p><p class="source-code">            <strong class="bold">class=\"section media\"/&gt;&lt;/figure&gt;",</strong></p><p class="source-code"><strong class="bold">        );</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    ...</p><p class="source-code">}</p></li>
				<li>We want a method for <strong class="source-inline">Post</strong> to update the content and mark it as permanent. Inside the <strong class="source-inline">impl Post{}</strong> block in <strong class="source-inline">src/models/post.rs</strong>, add the following method:<p class="source-code">pub async fn make_permanent(</p><p class="source-code">    connection: &amp;mut PgConnection,</p><p class="source-code">    uuid: &amp;str,</p><p class="source-code">    content: &amp;str,</p><p class="source-code">) -&gt; Result&lt;Post, OurError&gt; {</p><p class="source-code">    let parsed_uuid = Uuid::parse_str(uuid).map_err(</p><p class="source-code">    OurError::from_uuid_error)?;</p><p class="source-code">    let query_str = String::from("UPDATE posts SET </p><p class="source-code">    content = $1 WHERE uuid = $2 RETURNING *");</p><p class="source-code">    Ok(sqlx::query_as::&lt;_, Self&gt;(&amp;query_str)</p><p class="source-code">        .bind(content)</p><p class="source-code">        .bind(&amp;parsed_uuid)</p><p class="source-code">        .fetch_one(connection)</p><p class="source-code">        .await</p><p class="source-code">        .map_err(OurError::from_sqlx_error))?</p><p class="source-code">}</p></li>
				<li>We want<a id="_idIndexMarker565"/> to create a message that we want to send to the <a id="_idIndexMarker566"/>channel. In <strong class="source-inline">src/models/mod.rs</strong>, add <a id="_idIndexMarker567"/>a new module:<p class="source-code">pub mod worker;</p></li>
				<li>Then, create a new file, <strong class="source-inline">src/models/worker.rs</strong>. Create a new <strong class="source-inline">Message</strong> struct in the file as follows:<p class="source-code">pub struct Message {</p><p class="source-code">    pub uuid: String,</p><p class="source-code">    pub orig_filename: String,</p><p class="source-code">    pub dest_filename: String,</p><p class="source-code">}</p><p class="source-code">impl Message {</p><p class="source-code">    pub fn new() -&gt; Self {</p><p class="source-code">        Message {</p><p class="source-code">            uuid: String::new(),</p><p class="source-code">            orig_filename: String::new(),</p><p class="source-code">            dest_filename: String::new(),</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create<a id="_idIndexMarker568"/> a worker<a id="_idIndexMarker569"/> that will be executed when a channel<a id="_idIndexMarker570"/> receives a message. Add a new module in <strong class="source-inline">src/lib.rs</strong> called <strong class="source-inline">worker</strong>:<p class="source-code">pub mod workers;</p></li>
				<li>Create a folder named <strong class="source-inline">workers</strong>. Then, create a new file, <strong class="source-inline">src/workers/mod.rs</strong>, and add a new video module:<p class="source-code">pub mod video;</p></li>
				<li>Create a new file, <strong class="source-inline">src/workers/video.rs</strong>, and add the required <strong class="source-inline">use</strong> declarations:<p class="source-code">use crate::models::post::Post;</p><p class="source-code">use crate::models::worker::Message;</p><p class="source-code">use ffmpeg_cli::{FfmpegBuilder, File, Parameter};</p><p class="source-code">use sqlx::pool::PoolConnection;</p><p class="source-code">use sqlx::Postgres;</p><p class="source-code">use std::process::Stdio;</p><p class="source-code">use tokio::runtime::Handle;</p></li>
				<li>Add the function signature to process the video as follows:<p class="source-code">pub fn process_video(connection: &amp;mut PoolConnection&lt;Postgres&gt;, wm: Message) -&gt; Result&lt;(), ()&gt; {...}</p></li>
				<li>Inside the <strong class="source-inline">process_video()</strong> function, append these lines to prepare the destination file:<p class="source-code">let mut dest = String::from("static/");</p><p class="source-code">dest.push_str(&amp;wm.dest_filename);</p></li>
				<li>We <a id="_idIndexMarker571"/>want to re-encode all the files into MP4 files and use<a id="_idIndexMarker572"/> the <strong class="source-inline">x265</strong> codec<a id="_idIndexMarker573"/> for the video file destination. Append these lines to build the parameters for the <strong class="source-inline">ffmpeg</strong> binary:<p class="source-code">let builder = FfmpegBuilder::new()</p><p class="source-code">    .stderr(Stdio::piped())</p><p class="source-code">    .option(Parameter::Single("nostdin"))</p><p class="source-code">    .option(Parameter::Single("y"))</p><p class="source-code">    .input(File::new(&amp;wm.orig_filename))</p><p class="source-code">    .output(</p><p class="source-code">        File::new(&amp;dest)</p><p class="source-code">            .option(Parameter::KeyValue("vcodec", </p><p class="source-code">            "libx265"))</p><p class="source-code">            .option(Parameter::KeyValue("crf", "28")),</p><p class="source-code">    );</p></li>
				<li>The next and final step for the worker is to execute the builder. We can make it <strong class="source-inline">async</strong> too. Append the following lines:<p class="source-code">let make_permanent = async {</p><p class="source-code">    let ffmpeg = builder.run().await.unwrap();</p><p class="source-code">    let _ = ffmpeg.process.wait_with_output().</p><p class="source-code">    unwrap();</p><p class="source-code">    let mut display_path = String::from("/assets/");</p><p class="source-code">    display_path.push_str(&amp;wm.dest_filename);</p><p class="source-code">    Post::make_permanent(connection, &amp;wm.uuid, </p><p class="source-code">    &amp;display_path).await</p><p class="source-code">};</p><p class="source-code">let handle = Handle::current();</p><p class="source-code">Ok(handle</p><p class="source-code">    .block_on(make_permanent)</p><p class="source-code">    .map(|_| ())</p><p class="source-code">    .map_err(|_| ())?)</p></li>
				<li>The <a id="_idIndexMarker574"/>next<a id="_idIndexMarker575"/> thing we<a id="_idIndexMarker576"/> want to do is to create a thread to receive and process the message. We can add a new thread after we initialize Rocket in <strong class="source-inline">src/main.rs</strong>. We want to do several things:<ul><li>Initialize a <strong class="source-inline">worker</strong> thread.</li><li>Initialize a producer (message sender) and a consumer (message receiver).</li><li>Initialize a database pool.</li><li>In the <strong class="source-inline">worker</strong> thread, the consumer will obtain a connection from the database pool and process the message.</li></ul></li>
			</ol>
			<p>Let's start by adding <strong class="source-inline">use</strong> declarations in <strong class="source-inline">src/main.rs</strong>:</p>
			<p class="source-code">use our_application::models::worker::Message;</p>
			<p class="source-code">use our_application::workers::video::process_video;</p>
			<p class="source-code">use rocket::serde::Deserialize;</p>
			<p class="source-code">use sqlx::postgres::PgPoolOptions;</p>
			<p class="source-code">use tokio::runtime::Handle;</p>
			<ol>
				<li value="16">Add the structs<a id="_idIndexMarker577"/> to get the database configuration<a id="_idIndexMarker578"/> from <strong class="source-inline">Rocket.toml</strong> in <strong class="source-inline">src/main.rs</strong> after the <strong class="source-inline">use</strong> declaration:<p class="source-code">#[derive(Deserialize)]</p><p class="source-code">struct Config {</p><p class="source-code">    databases: Databases,</p><p class="source-code">}</p><p class="source-code">#[derive(Deserialize)]</p><p class="source-code">struct Databases {</p><p class="source-code">    main_connection: MainConnection,</p><p class="source-code">}</p><p class="source-code">#[derive(Deserialize)]</p><p class="source-code">struct MainConnection {</p><p class="source-code">    url: String,</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">rocket()</strong> function after <strong class="source-inline">setup_logger()</strong>, initialize the <strong class="source-inline">flume</strong> producer <a id="_idIndexMarker579"/>and consumer as follows:<p class="source-code">let (tx, rx) = flume::bounded::&lt;Message&gt;(5);</p></li>
				<li>Let Rocket manage the <strong class="source-inline">tx</strong> variable. We also want to assign the generated Rocket object into a variable, because we want to get the database configuration. Find these lines:<p class="source-code">rocket::build()</p><p class="source-code">    .attach(DBConnection::init())</p><p class="source-code">    .attach(Template::fairing())</p><p class="source-code">    .attach(Csrf::new())</p><p class="source-code">    .mount(...)</p></li>
			</ol>
			<p>Replace them with the following lines:</p>
			<p class="source-code"><strong class="bold">let our_rocket =</strong> rocket::build()</p>
			<p class="source-code">    .attach(DBConnection::init())</p>
			<p class="source-code">    .attach(Template::fairing())</p>
			<p class="source-code">    .attach(Csrf::new())</p>
			<p class="source-code">    <strong class="bold">.manage(tx)</strong></p>
			<p class="source-code">    .mount(...)<strong class="bold">;</strong></p>
			<ol>
				<li value="19">After<a id="_idIndexMarker580"/> we get <strong class="source-inline">our_rocket</strong>, we want to get the database <a id="_idIndexMarker581"/>configuration <a id="_idIndexMarker582"/>and initialize a new database connection pool for the worker. Append the following lines:<p class="source-code">let config: Config = our_rocket</p><p class="source-code">    .figment()</p><p class="source-code">    .extract()</p><p class="source-code">    .expect("Incorrect Rocket.toml configuration");</p><p class="source-code">let pool = PgPoolOptions::new()</p><p class="source-code">    .max_connections(5)</p><p class="source-code">    .connect(&amp;config.databases.main_connection.url)</p><p class="source-code">    .await</p><p class="source-code">    .expect("Failed to connect to database");</p></li>
				<li>Make a thread that will receive and process the message. Also, don't forget that to return <strong class="source-inline">our_rocket</strong> as a <strong class="source-inline">rocket()</strong> signature, we require the <strong class="source-inline">Rocket&lt;Build&gt;</strong> return value. Append the following lines:<p class="source-code">tokio::task::spawn_blocking(move || loop {</p><p class="source-code">    let wm = rx.recv().unwrap();</p><p class="source-code">    let handle = Handle::current();</p><p class="source-code">    let get_connection = async { (&amp;pool).</p><p class="source-code">    acquire().await.unwrap() };</p><p class="source-code">    let mut connection = handle.block_on(get_</p><p class="source-code">    connection);</p><p class="source-code">    let _ = process_video(&amp;mut connection, wm);</p><p class="source-code">});</p><p class="source-code">our_rocket</p></li>
				<li>Now, it's<a id="_idIndexMarker583"/> time to use the managed <strong class="source-inline">tx</strong> variable to send a<a id="_idIndexMarker584"/> message in the <strong class="source-inline">create_post()</strong> route<a id="_idIndexMarker585"/> handling function after we create the video. In <strong class="source-inline">src/routes/post.rs</strong>, add the required <strong class="source-inline">use</strong> declarations:<p class="source-code">use crate::errors::our_error::OurError;</p><p class="source-code">use crate::models::worker::Message;</p><p class="source-code">use flume::Sender;</p><p class="source-code">use rocket::State;</p></li>
				<li>In the <strong class="source-inline">create_post()</strong> function, retrieve the <strong class="source-inline">Sender&lt;Message&gt;</strong> instance managed by Rocket. Add the <strong class="source-inline">Sender&lt;Message&gt;</strong> instance to the function parameters:<p class="source-code">pub async fn create_post&lt;'r&gt;(</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">tx: &amp;State&lt;Sender&lt;Message&gt;&gt;,</strong></p><p class="source-code">)</p></li>
				<li>Before the <strong class="source-inline">if mt.is_text()</strong> block, append the following variables:<p class="source-code">let mut wm = Message::new();</p><p class="source-code">let mut is_video = false;</p></li>
				<li>After the <strong class="source-inline">if mt.is_svg() {}</strong> block, add <a id="_idIndexMarker586"/>a new block to<a id="_idIndexMarker587"/> initialize a temporary<a id="_idIndexMarker588"/> video value and assign the value to the <strong class="source-inline">wm</strong> variable we have initialized:<p class="source-code">else if mt.is_mp4() || mt.is_mpeg() || mt.is_ogg() || mt.is_mov() || mt.is_webm() {</p><p class="source-code">    post_type = PostType::Video;</p><p class="source-code">    let dest_filename = format!("{}.mp4", file_uuid);</p><p class="source-code">    content.push_str("loading/assets/");</p><p class="source-code">    content.push_str(&amp;dest_filename);</p><p class="source-code">    is_video = true;</p><p class="source-code">    wm.orig_filename = upload</p><p class="source-code">        .file</p><p class="source-code">        .path()</p><p class="source-code">        .unwrap()</p><p class="source-code">        .to_string_lossy()</p><p class="source-code">        .to_string()</p><p class="source-code">        .clone();</p><p class="source-code">    wm.dest_filename = dest_filename.clone();</p><p class="source-code">}</p></li>
				<li>Find the post creation and return value in the following lines:<p class="source-code">Post::create(connection, user_uuid, post_type, &amp;content)</p><p class="source-code">    .await</p><p class="source-code">    .map_err(|_| create_err())?;</p><p class="source-code">Ok(Flash::success(</p><p class="source-code">    Redirect::to(format!("/users/{}/posts", </p><p class="source-code">    user_uuid)),</p><p class="source-code">    "Successfully created post",</p><p class="source-code">))</p></li>
			</ol>
			<p>Modify this into<a id="_idIndexMarker589"/> the<a id="_idIndexMarker590"/> following <a id="_idIndexMarker591"/>lines:</p>
			<p class="source-code">Ok(Post::create(connection, user_uuid, post_type, &amp;content)</p>
			<p class="source-code">    .await</p>
			<p class="source-code">    .and_then(move |post| {</p>
			<p class="source-code">        if is_video {</p>
			<p class="source-code">            wm.uuid = post.uuid.to_string();</p>
			<p class="source-code">            let _ = tx.send(wm).map_err(|_| {</p>
			<p class="source-code">                OurError::new_internal_server_error(</p>
			<p class="source-code">                    String::from("Cannot process </p>
			<p class="source-code">                    message"),</p>
			<p class="source-code">                    None,</p>
			<p class="source-code">                )</p>
			<p class="source-code">            })?;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        Ok(Flash::success(</p>
			<p class="source-code">            Redirect::to(format!("/users/{}/posts", </p>
			<p class="source-code">            user_uuid)),</p>
			<p class="source-code">            "Successfully created post",</p>
			<p class="source-code">        ))</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .map_err(|_| create_err())?)</p>
			<p>Now try <a id="_idIndexMarker592"/>restarting <a id="_idIndexMarker593"/>the <a id="_idIndexMarker594"/>application and uploading the video file; notice the loading page. If the video has been processed, the video should be displayed:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_10.2_B16825.jpg" alt="Figure 10.2 – Uploaded video post&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – Uploaded video post</p>
			<p>Message passing is a very useful technique to process long-running jobs. Try using this technique if your application requires heavy processing but you need to return responses quickly.</p>
			<p>Some applications use a <a id="_idIndexMarker595"/>more advanced application <a id="_idIndexMarker596"/>called a <strong class="bold">message broker</strong>, which can retry sending<a id="_idIndexMarker597"/> messages, schedule sending messages, send messages to multiple applications, and <a id="_idIndexMarker598"/>much more. Some well-known message broker applications are RabbitMQ, ZeroMQ, and Redis. There are many cloud services providing message broker services as well, such as Google Cloud Pub/Sub. </p>
			<p>Before we complete this chapter, there's one more thing we can do: delete the user post. Try writing the <strong class="source-inline">delete_post()</strong> function. You can find the sample code in the <strong class="source-inline">Chapter10/06DeletingPost</strong> folder on GitHub.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor124"/>Summary</h1>
			<p>In this chapter, we have learned several things. </p>
			<p>The first thing we learned is how to process multipart forms in Rocket. After that, we learned how to use <strong class="source-inline">TempFile</strong> to upload files. Along with uploading photos and videos, we learned how to process the image files and video files.</p>
			<p>We learned more about concurrent programming with <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> and multithreading. We also covered how to create a thread and pass a message to a different thread.</p>
			<p>In the next chapter, we will focus on how to do authentication, authorization, and serving the API from the Rocket application.</p>
		</div>
	</body></html>