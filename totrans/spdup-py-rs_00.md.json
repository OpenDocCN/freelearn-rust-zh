["```rs\n    fn main() {\n        println!(\"hello world\");\n    }\n    ```", "```rs\n    rustc hello_world.rs \n    ```", "```rs\n    .\\hello_world.exe\n    ```", "```rs\n    ./hello_world\n    ```", "```rs\n    Cargo.toml file. In order to perform Cargo commands on this application, our terminal is going to have to be in the same directory as the `Cargo.toml` file. The code that we are going to be altering that makes up our application is housed in the `src` directory. Our entry point for the whole application is in the `main.rs` file. In Python, we can have multiple entry points, and we will explore these in [*Chapter 4*](B17720_04_Final_SK_ePub.xhtml#_idTextAnchor062), *Building pip Modules in Python*, where we will build pure Python packages for the first time. If we open the `.gitignore` file, we should have the following:\n\n    ```", "```rs\n\n    This is not a mistake; this is how clean Rust is. Everything that Cargo produces when it comes to compiling, documenting, caching, and so on is all stored in the target directory. \n    ```", "```rs\n    cargo run\n    ```", "```rs\n    target/debug/wealth_manager, and this is then run, resulting in the hello_world.rs output. \n    ```", "```rs\n    ./target/release/ directory under the binary wealth_manager. If we just want to compile our application without running it, we can simply swap the run command for build.\n    ```", "```rs\n[package]\n```", "```rs\nname = \"wealth_manager\"\n```", "```rs\nversion = \"0.1.0\"\n```", "```rs\nauthors = [\"maxwellflitton\"]\n```", "```rs\nedition = \"2018\"\n```", "```rs\n[dependencies]\n```", "```rs\n[dependencies]\n```", "```rs\nserde=\"1.0.117\"\n```", "```rs\nserde_json=\"1.0.59\"\n```", "```rs\nuse serde_json::{json, Value};\n```", "```rs\nfn main() {\n```", "```rs\n    let stock: Value = json!({\n```", "```rs\n        \"name\": \"MonolithAi\",\n```", "```rs\n        \"price\": 43.7,\n```", "```rs\n        \"history\": [19.4, 26.9, 32.5]\n```", "```rs\n    });\n```", "```rs\n    println!(\"first price: {}\", stock[\"history\"][0]);\n```", "```rs\n    println!(\"{}\", stock.to_string());\n```", "```rs\n}\n```", "```rs\nfirst price: 19.4\n```", "```rs\n{\"history\":[19.4,26.9,32.5], \"name\":\"MonolithAi\",\\ \n```", "```rs\n  \"price\":43.7}\n```", "```rs\n/// Adds two numbers together. \n```", "```rs\n/// \n```", "```rs\n/// # Arguments\n```", "```rs\n/// * one (i32): one of the numbers to be added\n```", "```rs\n/// * two (i32): one of the numbers to be added\n```", "```rs\n/// \n```", "```rs\n/// # Returns\n```", "```rs\n/// (i32): the sum of param one and param two\n```", "```rs\n/// \n```", "```rs\n/// # Usage\n```", "```rs\n/// The function can be used by the following code:\n```", "```rs\n/// \n```", "```rs\n/// '''rust\n```", "```rs\n/// result: i32 = add_numbers(2, 5);\n```", "```rs\n/// '''\n```", "```rs\nfn add_numbers(one: i32, two: i32) -> i32 {\n```", "```rs\n    return one + two\n```", "```rs\n}\n```", "```rs\ncargo doc\n```", "```rs\ncargo doc --open\n```", "```rs\n    ├── main.rs\n    └── stocks\n        ├── mod.rs\n        └── structs\n            ├── mod.rs\n            └── stock.rs\n    ```", "```rs\n    pub struct Stock {\n        pub name: String,\n        pub open_price: f32,\n        pub stop_loss: f32,\n        pub take_profit: f32,\n        pub current_price: f32\n    }\n    ```", "```rs\n    impl Stock {\n        pub fn new(stock_name: &str, price: f32) -> \\\n          Stock {\n            return Stock{\n                name: String::from(stock_name), \n                open_price: price,\n                stop_loss: 0.0,\n                take_profit: 0.0,\n                current_price: price\n            }\n        }\n        pub fn with_stop_loss(mut self, value: f32) \\\n          -> Stock {\n            self.stop_loss = value;\n            return self\n        }\n        pub fn with_take_profit(mut self, value: f32) \\\n          -> Stock {\n            self.take_profit = value;\n            return self\n        }\n        pub fn update_price(&mut self, value: f32) {\n            self.current_price = value;\n        }\n    }\n    ```", "```rs\nmod one {\n```", "```rs\n    . . . \n```", "```rs\n}\n```", "```rs\nMod two {\n```", "```rs\n    . . .\n```", "```rs\n}\n```", "```rs\n    mod stocks;\n    use stocks::structs::stock::Stock;\n    fn main() {\n        let stock: Stock = Stock::new(\"MonolithAi\", 36.5);\n        println!(\"here is the stock name: {}\",\\\n          stock.name);\n        println!(\"here is the stock name: {}\",\\\n          stock.current_price);\n    }\n    ```", "```rs\n    here is the stock name: MonolithAi\n    here is the stock name: 36.5\n    ```", "```rs\n    pub fn constructor_shout(stock_name: &str) -> () {\n        println!(\"the constructor for the {} is firing\", \\\n          stock_name);\n    }\n    ```", "```rs\n    pub mod stock;\n    mod utils;\n    ```", "```rs\n    use super::utils::constructor_shout;\n    ```", "```rs\n    pub fn new(stock_name: &str, price: f32) -> Stock {\n        constructor_shout(stock_name);\n        return Stock{\n            name: String::from(stock_name), \n            open_price: price,\n            stop_loss: 0.0,\n            take_profit: 0.0,\n            current_price: price\n        }\n    }\n    ```", "```rs\n    util function that we imported from. If we create another module, we can access our stocks module from it, because the stocks module is defined in the main.rs file.\n    ```", "```rs\n    ├── main.rs\n    └── stocks\n        ├── enums\n        │   ├── mod.rs\n        │   └── order_types.rs\n        ├── mod.rs\n        └── structs\n            ├── mod.rs\n            ├── order.rs\n            └── stock.rs\n    ```", "```rs\n    pub enum OrderType {\n        Short,\n        Long\n    }\n    ```", "```rs\n    pub mod order_types;\n    ```", "```rs\n    use chrono::{Local, DateTime};\n    use super::stock::Stock;\n    use super::super::enums::order_types::OrderType;\n    pub struct Order {\n        pub date: DateTime<Local>,\n        pub stock: Stock,\n        pub number: i32,\n        pub order_type: OrderType\n    }\n    ```", "```rs\n    [dependencies]\n    serde=\"1.0.117\"\n    serde_json=\"1.0.59\"\n    chrono=\"0.4.19\"\n    ```", "```rs\n    impl Order {\n        pub fn new(stock: Stock, number: i32, \\ \n          order_type: OrderType) -> Order {\n          let today: DateTime<Local> = Local::now();\n            return Order{date: today, stock, number, \\\n              order_type}\n        }\n    }\n    ```", "```rs\n        pub fn current_value(&self) -> f32 {\n            return self.stock.current_price * self \\\n              .number as f32\n        }\n    ```", "```rs\n        pub fn current_profit(&self) -> f32 {\n            let current_price: f32 = self.current_value();\n            let initial_price: f32 = self.stock. \\\n              open_price * self.number as f32;\n            match self.order_type {\n              OrderType::Long => return current_price -\\\n                initial_price,\n              OrderType::Short => return initial_price -\\\n                current_price\n            }\n        }\n    ```", "```rs\n    pub mod stock;\n    pub mod order;\n    ```", "```rs\n    pub mod structs;\n    pub mod enums;\n    use structs::stock::Stock;\n    use structs::order::Order;\n    use enums::order_types::OrderType;\n    ```", "```rs\n    pub fn close_order(order: Order) -> f32 {\n        println!(\"order for {} is being closed\", \\\n          &order.stock.name);\n        return order.current_profit()\n    }\n    ```", "```rs\n    pub fn open_order(number: i32, order_type: OrderType,\\ \n                      stock_name: &str, open_price: f32,\\\n                      stop_loss: Option<f32>, \\\n                        take_profit: Option<f32>) -> \\\n                          Order { \\\n        println!(\"order for {} is being made\", \\ \n          &stock_name);              \n        let mut stock: Stock = Stock::new(stock_name, \\ \n          open_price);\n        match stop_loss {\n            Some(value) => stock = \\ \n              stock.with_stop_loss(value),\n            None => {}\n        }\n        match take_profit {\n            Some(value) => stock = \\\n              stock.with_take_profit(value),\n            None => {}\n        }\n        return Order::new(stock, number, order_type)\n    }\n    ```", "```rs\n    mod stocks;\n    use stocks::{open_order, close_order};\n    use stocks::structs::order::Order;\n    use stocks::enums::order_types::OrderType;\n    ```", "```rs\n    println!(\"hello stocks\");\n    let mut new_order: Order = open_order(20, \\\n        OrderType::Long, \"bumper\", 56.8, None, None);\n    ```", "```rs\n    println!(\"the current price is: {}\", \n        &new_order.current_value());\n    println!(\"the current profit is: {}\", \n        &new_order.current_profit());\n    ```", "```rs\n    new_order.stock.update_price(43.1);\n    println!(\"the current price is: {}\", \\ \n        &new_order.current_value());\n    println!(\"the current profit is: {}\", \\ \n        &new_order.current_profit());\n    new_order.stock.update_price(82.7);\n    println!(\"the current price is: {}\", \\\n             &new_order.current_value());\n    println!(\"the current profit is: {}\", \\\n             &new_order.current_profit());\n    ```", "```rs\n    let profit: f32 = close_order(new_order);\n    println!(\"we made {} profit\", profit);\n    ```", "```rs\n    hello stocks\n    the constructor for the bumper is firing\n    the current price is: 1136\n    the current profit is: 0\n    the current price is: 862\n    the current profit is: -274\n    the current price is: 1654\n    the current profit is: 518\n    order for bumper is being closed\n    we made 518 profit\n    ```", "```rs\n    use std::env;\n    use rand::prelude::*;\n    use std::str::FromStr;\n    ```", "```rs\n    let args: Vec<String> = env::args().collect();\n    let action: &String = &args[1];\n    let name: &String = &args[2];\n    let amount: i32 = i32::from_str(&args[3]).unwrap();\n    let price: f32 = f32::from_str(&args[4]).unwrap();\n    ```", "```rs\n    let mut new_order: Order = open_order(amount, \\\n        OrderType::Long, &name.as_str(), price, \\ \n            None, None);\n    ```", "```rs\n    match action.as_str() {\n        \"buy\" => {\n            println!(\"the value of your investment is:\\\n              {}\", new_order.current_value());\n        }\n        \"sell\" => {\n            let mut rng = rand::thread_rng();\n\n            let new_price_ref: f32 = rng.gen(); \n            let new_price: f32 = new_price_ref * 100 as \\\n              f32;\n            new_order.stock.update_price(new_price);\n            let sale_profit: f32 = close_order(new_order);\n            println!(\"here is the profit you made: {}\", \\\n                sale_profit);\n        }\n        _ => {\n            panic!(\"Only 'buy' and 'sell' actions are \\\n              supported\");\n        }\n    }\n    ```", "```rs\n    cargo run sell monolithai 26 23.4\n    ```", "```rs\n    order for monolithai is being made\n    order for monolithai is being closed\n    here is the profit you made: 1825.456\n    ```"]