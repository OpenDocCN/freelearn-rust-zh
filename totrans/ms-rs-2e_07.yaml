- en: Advanced Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite a few concepts we learned in the previous chapters really deserve close
    attention so we can appreciate the design of Rust. Learning these advanced topics
    will also help you further when you need to understand complex code bases. These
    concepts are also helpful when you want to create libraries that provide idiomatic
    Rust APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Type system tidbits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type system tidbits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"An algorithm must be seen to be believed"'
  prefs: []
  type: TYPE_NORMAL
- en: – *Donald Knuth*
  prefs: []
  type: TYPE_NORMAL
- en: Before we go into more dense topics in this chapter, we'll first discuss some
    of the type system tidbits in statically typed programming languages in general,
    with focus on Rust. Some of these topics may already be familiar to you from [Chapter
    1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting Started with Rust*, but
    we're going to dig into the details here.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks and expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite being a mix of statements and expressions, Rust is primarily an expression-oriented
    language. This means that most constructs are expressions that return a value.
    It's also a language that uses C-like braces `{}`, to introduce new scope for
    variables in a program. Let's get these concepts straight before we talk more
    about them later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A **block expression** (hereby referred as blocks) is any item that starts with
    `{` and ends with `}`. In Rust, they include `if else` expressions, match expressions,
    `while` loops, loops, bare `{}` blocks, functions, methods, and closures, and
    all of them return a value which is the last line of the expression. If you put
    a semicolon in the last expression, the block expressions default to a return
    value of the unit `()` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related concept to blocks is the **scope**. A scope is introduced whenever
    a new block is created. When we a new block and create any variable bindings within
    it, the bindings are confined to that scope and any reference to them is valid
    only within the scope bounds. It''s like a new environment for variables to live
    in, isolated from the others. Items such as functions, `impl` blocks, bare blocks,
    if else expressions, match expressions, functions, and closures introduce new
    scope in Rust. Within a block/scope, we can declare structs, enums, modules, traits
    and their implementations, and even blocks. Every Rust program starts with one
    root scope, which is the scope introduced by the `main` function. Within that,
    many nested scopes can be created. The `main` scope becomes the parent scope for
    all inner scopes declared. Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We used a bare block `{}`, to introduce a new inner scope and created a variable
    `a`. Following the end of the scope, we are trying to assign `b` to the value
    of `a`, which comes from the inner scope. Rust throws a compile time error saying
    ``cannot find value `a` in this scope`` . The parent scope from `main` does not
    know anything about `a` as it comes from the inner scope. This property of scopes
    is also used sometimes to control how long we want a reference to be valid, as
    we saw in [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml), *Memory Management
    and Safety*.
  prefs: []
  type: TYPE_NORMAL
- en: But the inner scope can access values from their parent scope. Because of that,
    it is possible to write `34 + b` within our inner scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to expressions. We can benefit from their property of returning
    a value and that they must be of the same type in all branches. This results in
    very concise code. For example, consider this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can use bare blocks to chunk several lines of code together and assign the
    value at the end with an implicit return of the `a + b + c` expression to `precompute`
    as shown previously. Match expressions can also assign and return values from
    their match arms directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Being similar to the `switch` statement in C, match arms in Rust
    do not suffer from the `case fall through` side effect that results in lots of
    bugs in C code.'
  prefs: []
  type: TYPE_NORMAL
- en: The C switch case requires every `case` statement within the `switch` block
    to have a `break` if we want to bail out after running the code in that `case`.
    If the `break` is not present, any `case` statement following that is also executed,
    which is called the fall-through behavior. A match expression, on the other hand,
    is guaranteed to evaluate only one of the match arms.
  prefs: []
  type: TYPE_NORMAL
- en: '`If else` expressions provide the same conciseness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In statement-based languages such as Python*,* you would write something like
    this for the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the Python code, we had to declare `result` beforehand, followed by doing
    separate assignments in the if else branch. Rust is more concise here, with the
    assignment being done as a result of the if else expression. Also, in Python,
    you can forget to assign a value to a variable in either of the branches and the
    variable may be left uninitialized. Rust will report at compile time if you return
    and assign something from the `if` block and either miss or return a different
    type from the `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an added note, Rust also supports declaring uninitialized variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But they need to be initialized before we use them. If an uninitialized variable
    is attempted to be read from later, Rust will forbid that and report at compile
    time that the variable must be initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting Started
    with Rust*, we briefly introduced `let`, which is used to create new variable
    bindings—but `let` is more than that. In fact, `let` is a pattern-matching statement.
    Pattern matching is a construct mostly seen in functional languages such as Haskell
    and allows us to manipulate and make decisions about values based on their internal
    structure or can be used to extract values out of algebraic data types. We had
    already
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first line is `let` in its simplest form and it declares an immutable variable
    binding, `a`. In the second line, we have `mut` after the `let` keyword for `b`
    . `mut` is part of the `let` pattern, which binds `b` mutably to `i32` types in
    this case. `mut` enables `b` to bind again to some other `i32` type. Another keyword
    that''s seen less frequently with `let` is the `ref` keyword. Now, we generally
    use the `&` operator to create a reference/pointer to any value. The other way
    to create a reference to any value is to use the `ref` keyword with `let`. To
    illustrate `ref` and `mut`, we have a snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `items_ref` is a reference created using the usual `&` operator. The next
    line also creates the `items_ref` reference to the same `items` value using `ref`.
    We can confirm, with the `assert_eq!` call following it, that the two pointer
    variables point to the same `items` value. The cast to `*const Items` is used
    to compare whether two pointers point to the same memory location, where `*const
    Items` is a raw pointer type to `Items`. Additionally, by combining `ref` and
    `mut` as shown in the second to last part of the code, we can get a mutable reference
    to any owned value other than the usual way of doing so with the `&mut` operator.
    But we have to use an inner scope to modify `a` from `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Languages using pattern matching are not just limited to having identifiers
    on the left hand side of `` `=` `` but can additionally have patterns referring
    to the structure of types. So, another convenience `let` provides us with is the
    ability to extract values from fields of an algebraic data type, such as a struct
    or enum as new variables. Here, we have a snippet that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created an instance of `Order`, which is bound to `food_order`. Let''s
    assume we got `food_order` from some method call and we want to access the `count`
    and `item` values. We can extract the individual fields, `count` and `item`, directly
    using `let`. `count` and `item` become new variables that hold the corresponding
    field values from the `Order` instance. This is technically called the **destructuring
    syntax** of **`let`**. The way the variables get destructured depends on whether
    the value on the right is an immutable reference, mutable reference, or an owned
    value or by how we reference it on the left-hand side using the `ref` or `mut`
    patterns. In the previous code, it was captured by the value because `food_order`
    owns the `Order` instance and we matched the members on the left-hand side without
    any `ref` or `mut` keyword. If we want to destructure the members by immutable
    reference, we would put an `&` symbol before `food_order` or use `ref` or `mut`
    alternatively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first style is generally preferred as it''s concise. If we want to have
    a mutable reference, we have to place `&mut` after making `food_order` itself
    mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Fields that we don''t care about can be ignored by using the `..`, as shown
    in the code. Also, a slight restriction of `let` destructuring is that we are
    not free to choose the mutability of individual fields. All variables must have
    the the same mutability—either all are immutable or all are mutable. Note that
    `ref` isn''t generally used to declare variable bindings and is mostly used in
    match expressions in cases where we want to match against a value by reference
    because the `&` operator does not work within match arms, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use the inner value from `Person` struct by an immutable reference,
    our intuition would say to use something like `Person(&name)` in the match arm
    to match by reference. But we get this error upon compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/671b0a41-8760-460e-bcd3-0a7d5f440343.png)'
  prefs: []
  type: TYPE_IMG
- en: This gives us a misleading error because `&name` is creating a reference out
    of `name` (`&` is an operator) and the compiler thinks that we want to match against `Person(&String)`
    but the `a` value is actually `Person(String)`. So, in this case `ref` has to
    be used to destructure it as a reference. To make it compile, we change it accordingly
    to `Person(ref name)` on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The destructuring syntax is also applicable to enum types as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have `maybe_item` as a `Container` enum. Combining `if let` and pattern
    matching, we can conditionally assign the value to `has_item` variable using the
    `if let <destructure pattern> = expression {}` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The destructuring syntax can be used in function parameters as well. For example,
    in the case of custom types, such as a struct when used in a function as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `calculate_cost` function has a parameter that's destructured as a struct
    with fields bound to the `items_count` variable. If we want to destructure mutably,
    we add the `mut` keyword before the member field as is the case with the `increment_item`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refutable patterns**: Refutable pattern are `let` patterns where the left-hand
    side and the right-hand side are not compatible for pattern matching and, in those
    cases one has to use the exhaustive match expression instead. Up until now, all
    forms of `let` patterns we''ve seen were irrefutable patterns. Irrefutable means
    that they''re able to properly match against the value on the right side of `''=''`
    as a valid pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But sometimes, pattern matching with `let` may fail because of invalid patterns,
    for example, when matching an enum `Container` that has two variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, we expect `it` to store `56` as the value, after being destructured
    from `item`. If we try compiling this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc30cd83-74e1-4e93-9a81-e4a783a82cfe.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason this match does not succeed is because `Container` has two variants,
    `Item(u64)` and `Empty`. Even though we know that `item` contains the `Item` variant,
    `let` patterns can't rely on this fact, because if `item` is mutable, some code
    can assign an `Empty` variant there later, which would render the destructure
    an undefined operation. We have to cover all possible cases. Destructuring directly
    against a single variant violates the semantics of exhaustive pattern matching
    and hence our match fails.
  prefs: []
  type: TYPE_NORMAL
- en: Loop as an expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Rust, a loop is also an expression that returns `()` by default when we
    `break` out of it. The implication of this is that `loop` can also be used to
    assign value to a variable with `break`. For example, it can be used in something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Following the `break` keyword, we include the value we want to return and this
    gets assigned to `counter` variable when the loop breaks (if at all). This is
    really handy in cases where you assign the value of any variable within the loop
    after breaking from the loop and need to use it afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Type clarity and sign distinction in numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While mainstream languages differentiate between numeric primitives such as
    an integer, a double*,* and a byte*,* a lot of newer languages such as Golang
    have started adding distinction between signed and unsigned numeric types too.
    Rust follows in the same footsteps by distinguishing signed and unsigned numeric
    types, providing them as separate types altogether. From a type-checking perspective,
    this adds another layer of safety to our programs. This allows us to write code
    that exactly specifies its requirements. For example, consider a database connection
    pool struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For languages that provide a common integer type that incorporates both signed
    and unsigned values, you would specify the type of `pool_count` as an integer,
    which can also store negative values. It does not make sense for `pool_count`
    to be negative. With Rust, we can specify this clearly in code by using an unsigned
    type instead, such as `u32` or `usize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more aspect to note about primitive types is that Rust does not perform
    automatic casts when mixing signed and unsigned types in arithmetic operations.
    You have to be explicit about this and cast the value manually. An example of
    an unintended auto cast in C/C++ would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code prints `4294967295`. Here, the difference won't be `-1` on
    subtracting `foo` and `bar`; instead C++ does its own thing without the programmer's
    consent. `int` (signed integer) is auto cast to `uint` (unsigned integer) and
    wraps to a maximum value of `uint` being `4294967295`. This code continues to
    run without complaining about underflow here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translating the same program in Rust, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b15dd415-e0d3-4148-b663-134157d69bc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Rust won't compile this, showing an error message. You have to explicitly cast
    either of the values according to your intent. Also, if we perform overflow/underflow
    operations on two unsigned or signed types, Rust will `panic!()` and abort your
    program when you build and run in `debug` mode. When built in `release` mode,
    it does a wrapping arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: By wrapping arithmetic, we mean that adding `1` to `255` (a `u8`) will result
    in `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Panicking in debug mode is the right thing to do here because if such arbitrary
    values are allowed to propagate to other parts of code, they can taint your business
    logic and introduce further hard-to-track bugs in the program. So, a fail-stop
    approach is better in these cases where the user accidentally performs an overflow/underflow
    operation and this gets caught in debug mode. When the programmer wants to allow
    wrapping semantics on arithmetic operations, then they may choose to ignore the
    panic and proceed to compile in release mode. That's another aspect of safety
    that the language provides you.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type inference is useful in statically typed languages as it makes the code
    easier to write, maintain, and refactor. Rust''s type system can figure out types
    for fields, methods, local variables, and most generic type arguments when you
    don''t specify them. Under the hood, a component of the compiler called the type
    checker uses the *Hindley Milner* type inference algorithm to decide what the
    types of local variables should be. It is a set of rules about establishing types
    of expressions based on their usage. As such, it can infer types based on the
    environment and the way a type is used. One such example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With only the first line initializing the vector, Rust's type checker is unsure
    of what the type for `v` should be. It's only when it reaches the next line, `v.push(2)`,
    that it knows that `v` is of the type, `Vec<i32>`. Now the type of `v` is frozen
    to `Vec<i32>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we added another line, `v.push(2.4f32);`, then the compiler will complain
    of type mismatch as it already had inferred it from the previous line to be of
    `Vec<i32>`. But sometimes, the type checker cannot figure out types of variables
    in complex situations. But with some help from the programmer, the type checker
    is able to infer types. For example, for the next snippet, we read a file `foo.txt`,
    containing some text and read it as bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this gives us this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90d9cd48-e50f-439a-8a16-7073beff3614.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `collect` method on iterators is basically an `aggregator` method. We''ll
    look at iterators later in this chapter. The resulting type it collects into can
    be any collection type. It can either be `LinkedList`, `VecDeque`, or `Vec`. Rust
    does not know what the programmer intends and, due to such ambiguity, it needs
    our help here. We made the following change for the second line in `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Calling `bytes()` returns `Result<u8, std::io::Error>`. After adding some type
    hint as to what to collect into (here, `Vec`), the program compiles fine. Note
    the `_` on the `Result` error variant. It was enough for Rust to hint that we
    need a `Vec` of `Result` of `u8`. The rest, it is able to figure out—the error
    type in `Result` needs to be of `std::io::Error` type. It was able to figure that
    out because there is no such ambiguity here. It gets the information from the
    `bytes()` method signature. Quite smart!
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type aliases are a feature not unique to Rust. C has the `typedef` keyword,
    while Kotlin has `typealias` for the same. They are there to make your code more
    readable and remove the type signature cruft that often piles up in statically
    typed languages, for example, if you have an API from your crate where you return
    a `Result` type, wrapping a complex object as depicted below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for some of the methods, such as `parse_payload`, the type signature
    gets too large to fit in a line. Also, having to type `Result<ParsedPayload<T>,
    ParseError<E>>` every time they are used becomes cumbersome. What if we could
    refer to this type by a simpler name? This is the exact use case type aliases
    serve. They enable us to give another (desirably simpler) name to types with a
    complex type signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can give an alias to the return type of `parse_payload` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it more manageable if we later want to change the actual inner types.
    We can type alias any simple types too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we can use `MyString` anywhere we use `String.` But this doesn''t mean
    that `MyString` is of a different type. During compilation, this just gets substituted/expanded
    to the original type. When creating type aliases for generic types, the type alias
    also needs a generic type parameter (`T`). So aliasing `Vec<Result<Option<T>>>`
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume you have a lifetime in your type, as in `SuperComplexParser<''a>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When creating type aliases for them, we need to specify the lifetime as well,
    as is the case with the `Parser` type alias.
  prefs: []
  type: TYPE_NORMAL
- en: With those type system niceties out of the way, let's talk about strings again!
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml), *Getting Started
    with Rust*, we mentioned that strings are of two types. In this section, we'll
    give a clearer picture on strings, their peculiarities, and how they differ from
    strings in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'While other languages have a pretty straightforward story on string types,
    the `String` type in Rust is one of the tricky and uneasy types to handle. As
    we know, Rust places distinction on whether a value is allocated on the heap or
    on the stack. Due to that, there are two kinds of strings in Rust: owned strings
    (`String`) and borrowed strings (`&str`). Let''s explore both of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Owned strings – String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `String` type comes from the standard library and is a heap-allocated UTF-8
    encoded sequence of bytes. They are simply `Vec<u8>` under the hood but have extra
    methods that are applicable to only strings. They are owned types, which means
    that a variable that holds a `String` value is its owner. You will usually find
    that `String` types can be created in multiple ways, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created four strings in four different ways. All of
    them create the same string type and have the same performance characteristics.
    The first variable, `a`, creates the string by calling the `to_string` method,
    which comes from the `ToString` trait with the string literal, `"Hello"`. A string
    literal such as `"Hello"` by itself also has a type of `&str`. We'll explain them
    when we get to borrowed versions of strings. We then create another string, `b`,
    by calling the `from` method, which is an associated method on `String`. The third
    string `c`, is created by calling a trait method, `to_owned`, from the `ToOwned`
    trait, which is implemented for `&str` types—literal strings. The fourth string,
    `d`, is created by cloning an existing string, `c`. The fourth way of creating
    strings is an expensive operation , which we should avoid as it involves copying
    the underlying bytes by iterating over them.
  prefs: []
  type: TYPE_NORMAL
- en: As `String` is allocated on heap, it can be mutated and can grow at runtime.
    This means that strings have an associated overhead when manipulating them because
    they might possibly get reallocated as you keep adding bytes to them. Heap allocation
    is a relatively expensive operation but, fortunately, the way allocation happens
    for `Vec` (doubled every capacity limit), means this cost is amortized over usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings also have a lot of convenient methods in the standard library. Following
    are the important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String::new()` allocates an empty `String` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String::from(s: &str)` allocates a new `String` type and populates it from
    a string slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String::with_capacity(capacity: usize)` allocates an empty `String` type with
    a preallocated size. This is performant when you know the size of your string
    beforehand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String::from_utf8(vec: Vec<u8>)` tries to allocate a new `String` type from
    `bytestring`. The contents of the parameter must be UTF-8 or this will fail. It
    returns the `Result` wrapper type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `len()` method on string instances gives you the length of the `String` type, taking
    Unicode into account. As an example, a `String` type containing the word `yö`
    has a length of two, even though it takes three bytes in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `push(ch: char)` and `push_str(string: &str)` methods add a character or
    a string slice to the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is, of course, a non-exhaustive list. A complete list of all the operations
    can be found at [https://doc.rust-lang.org/std/string/struct.String.html](https://doc.rust-lang.org/std/string/struct.String.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that uses all of the aforementioned methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With `String` explored, let's look at the borrowed version of strings known
    as string slices or the `&str` type.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowed strings – &str
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also have strings as references called string slices. These are denoted
    by `&str` (pronounced as *stir*), which is a reference to a `str` type. In constrast
    to the `String` type, `str` is a built-in type known to the compiler and is not
    something from the standard library. String slices are created as `&str` by default—a
    pointer to a UTF-8 encoded byte sequence. We cannot create and use values of the
    bare `str` type, as it represents a contiguous sequence of UTF-8 encoded bytes
    with a finite but unknown size. They are technically called unsized types. We'll
    explain unsized types later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`str` can only be created as a reference type. Let''s assume we try to create
    a `str` type forcibly by providing the type signature on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be presented with a confusing error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9213101-fb42-45e3-bab3-5146b26c780e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It says: all local variables must have a statically known size. This basically
    means that every local variable we define using a `let` statement needs to have
    a size as they are allocated on the stack and the stack has a fixed size. As we
    know, all variable declarations go on the stack either as values themselves or
    as pointers to heap allocated types. All stack-allocated values need to have a
    proper size known and, due to this, `str` cannot be initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: '`str` basically means a fixed-sized sequence of strings that''s agnostic to
    the location where it resides. It could either be a reference to a heap-allocated
    string, or it could be a `&''static str` string residing on the data segment of
    the process that lives for the entire duration of the program, which is what the
    `''static` lifetime denotes.'
  prefs: []
  type: TYPE_NORMAL
- en: We can, however, create a borrowed version of `str`, as in `&str`, which is
    what gets created by default when we write a string literal. So string slices
    are only created and used behind a pointer—`&str`. Being a reference, they also
    have different lifetimes associated with them based on the scope of their owned
    variable. One of them is of `'static` lifetime, which is the lifetime of string
    literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'String literals are any sequence of characters you declare within double quotes.
    For example, we create them like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a `get_str_literal` function that returns a string
    literal. We also create a string literal `my_str` in `main`. `my_str` and the
    string returned by `get_str_literal` has the type, `&'static str`. The `'static`
    lifetime annotation denotes that the string stays for the entire duration of the
    program. The `&` prefix says that it's a pointer to the string literal, while
    `str` is the unsized type. Any other `&str` type you encounter are **borrowed
    string slices** of any owned `String` type on the heap. The `&str` types, once
    created, can't be modified as they are created immutable by default.
  prefs: []
  type: TYPE_NORMAL
- en: We can also take a mutable slice to the string, and the type changes to `&mut
    str`, though it's uncommon to use them in this form except with a few methods
    in the standard library. The `&str` type is the recommended type to be used when
    passing strings around, either to functions or to other variables.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing and dicing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All strings in Rust are guaranteed to be UTF-8 by default, and indexing on
    string types in Rust does not work as you would use them in other languages. Let''s
    try accessing the individual characters of our string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'On compiling this, we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12722a16-aaec-4fa4-8a72-9356a58b75cd.png)'
  prefs: []
  type: TYPE_IMG
- en: That's not a very helpful message. But it refers to something called the `Index`
    trait. The `Index` trait is implemented on collection types whose elements can
    be accessed by the indexing operator `[]` using index type as a `usize` value.
    Strings are valid UTF-8-encoded byte sequences and a single byte does not equate
    to a single character. In UTF-8, a single character may also be represented by
    multiple bytes. So, indexing does not work on strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can have slices of strings. This can either be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: But, as is the case with all indexing operation, this panics if the start or
    the end index is not on a valid `char` boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to iterator over all characters of a string is to use the `chars()`
    method, which turns the string into an iterator over its characters. Let''s change
    our code to use `chars` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `chars` method returns characters of the string at proper Unicode boundaries.
    We can also call other iterator methods on this to either skip or get a range
    of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Using strings in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s idiomatic and performant to pass string slices to functions. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To the astute observer, the `say_hello` method also worked with a `&String`
    type. Internally, `&String` automatically coerces to `&str`, due to the type coercion
    trait `Deref` implemented for `&String` to `&str`. This is because `String` implements
    `Deref` for the `str` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see why I stressed the point earlier. A string slice is an acceptable
    input parameter not only for actual string slice references but also for `String`
    references! So, once more: if you need to pass a string to your function, use
    the string slice, `&str`.'
  prefs: []
  type: TYPE_NORMAL
- en: Joining strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another source of confusion when dealing with strings in Rust is when concatenating
    two strings. In other languages, you have a very intuitive syntax for joining
    two strings. You just do `"Foo" + "Bar"` and you get a `"FooBar"`. Not quite the
    case with Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile this, we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb3f608a-3b51-44ff-adf0-11ad37c59fa4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error message is really helpful here. The concatenation operation is a
    two step process. First, you need to allocate a string and then iterate over both
    of them to copy their bytes to this newly allocated string. As such, there''s
    an implicit heap allocation involved, hidden behind the `+` operator. Rust discourages
    implicit heap allocation. Instead, the compiler suggests that we can concatenate
    two string literals by explicitly making the first one an owned string. So our
    code changes, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So we made `foo` a `String` type by calling the `to_string()` method. With that
    change, our code compiles.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between both `String` and `&str` is that `&str` is natively
    recognized by the compiler, while `String` is a custom type from the standard
    library. You could implement your own similar `String` abstraction on top of `Vec<u8>`.
  prefs: []
  type: TYPE_NORMAL
- en: When to use &str versus String ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To a programmer coming to Rust, often the confusion is around which one to
    use. Well, the best practice is to use APIs that take a `&str` type when possible,
    as when the string is already allocated somewhere, you can save copying and allocation
    costs just by referencing that string. Passing `&str` around your program is nearly
    free: it incurs nearly no allocation costs and no copying of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Global values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from variable and type declarations, Rust also allows us to define global
    values that can be accessed from anywhere in the program. They follow the naming
    convention of every letter being uppercase. These are of two kinds: constants
    and statics. There are also constant functions, which can be called to initialize
    these global values. Let''s explore constants first.'
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first form of global values are constants. Here''s how we can define one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We use the `const` keyword to create constants. As constants aren't declared
    with the `let` keyword, specifying types is a must when creating them. Now, we
    can use `HEADER` where we would use the byte literal, `Obj\`.  `b""` is a convenient
    syntax to create a sequence of bytes of the `&'static [u8; n]` type, as in a `'static`
    reference to a fixed-sized array of bytes. Constants represent concrete values
    and don't have any memory location associated with them. They are inlined wherever
    they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Statics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Statics are proper global values, as in they have a fixed memory location and
    exist as a single instance in the whole program. These can also be made mutable.
    However, as global variables are a breeding ground for the nastiest bugs out there,
    there are some safety mechanisms in place. Both reading and writing to statics
    has to be done inside an `unsafe {}` block. Here''s how we crate and use statics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we've declared two statics `BAZ` and `FOO`. We use the `static`
    keyword to create them along with specifying the type explicitly. If we want them
    to be mutable, we add the `mut` keyword after `static`. Statics aren't inlined
    like constants. When we read or write the static values, we need to use an `unsafe`
    block. Statics are generally combined with synchronization primitives for any
    kind of thread-safe use. They are also used to implement global locks and when
    integrating with C libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, if you don't need to rely on singleton property of statics and its
    predefined memory location and just want a concrete value, you should prefer using
    `consts`. They allow the compiler to make better optimizations and are more straightforward
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Compile time functions – const fn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also define constant functions that evaluate their argument during compile
    time. This means that a `const` value declaration can have a value that''s from
    an invocation of a `const` function. `const` functions are pure functions and
    must be reproducible. This means that they cannot take mutable arguments to any
    type. They also cannot include operations that are dynamic such as a heap allocation.
    They can be called in non-const places where they act just like normal functions.
    But when they are called in const contexts, they are evaluated at compile time.
    Here''s how we define a const function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code, we defined a `const` function, `salt`, that takes a `u32` value
    as parameter and does a `xor` operation with the hex value, `0xDEADBEEF`. Const
    functions are quite useful for operations that can be performed at compile time.
    For instance, let''s say you are writing a binary file parser and you need to
    read the first four bytes of the file as an initialization and validation step
    for the parser. The following code demonstrates how we can do this entirely at
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the code, the `read_header` function receives a file as a bytes array using
    the `include_bytes!` macro, which also reads the file at compile time. We then
    pull `4` bytes out of it and return it as a four-element tuple. Without the `const`
    function, all this would be done at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic statics using the lazy_static! macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, global values can only be declared for types that are non-dynamic
    in their initialization and have a known size on the stack at compile time. For
    example, you can''t create a `HashMap` as a static value because it requires a
    heap allocation. Fortunately, we can have `HashMap` and other dynamic collection
    types such as `Vec` as global statics too, using a third-party crate called `lazy_static`.
    This crate exposes the `lazy_static!` macro, which can be used to initialize any
    dynamic type that''s accessible globally from anywhere in the program. Here''s
    a snippet of how to initialize a Vec that can be mutated from multiple threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Items declared within the `lazy_static!` macro are required to implement the
    Sync trait. This means if we want a mutable static, we have to use a multithreaded
    type such as `Mutex` or `RwLock` instead of  `RefCell`. We'll explain these types
    when we get to [Chapter 8](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml), *Concurrency*.
    We'll be using this macro frequently in future chapters. Head over to the crate
    repository to learn more about using `lazy_static`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We glimpsed iterators in [Chapter 1](d9f771cc-9948-4bb5-8ad7-bb6fcbcc62b1.xhtml),
    *Getting Started with Rust*. To recap, an iterator is any ordinary type that can
    walk over elements of a collection type in one of three ways: via `self`, `&self`,
    or  `&mut self`. They are not a new concept and mainstream language such as C++
    and Python have them already though that in Rust, they can appear surprising at
    first due to their form as an associated type trait. Iterators are used quite
    frequently in idiomatic Rust code when dealing with collection types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how they work, let''s look at the definition of the `Iterator`
    trait from the `std::iter` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Iterator` trait is an associated type trait which mandates the two items,
    to be defined for any implementing type. First is the associated type, `Item`,
    which specifies what item the iterator yields. Second is the `next` method, which
    is called every time we need to read a value from the type being iterated over.
    There are also other methods that we''ve omitted here, as they have default implementations.
    To make a type iterable, we only need to specify the `Item` type and implement
    the `next` method and all other methods with default implementations become available
    for the type. In this way, iterators are a really powerful abstraction. You can
    see the full set of default methods at: [https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Iterator` trait has a sibling trait called `IntoIterator`, which is implemented
    by types that want to convert in to an iterator. It provides the `into_iter` method
    that takes the implementing type via `self` and consumes the elements of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `Iterator` trait for a custom type. Identify what you
    want to iterate over in your data type if it''s not a collection. Then, create
    a wrapper struct holding any state of the iterator. Often, we'' will find iterators
    being implemented for some wrapper type that references the collection type''s
    element either by ownership or by an immutable or mutable reference. The methods
    to convert a type in to an iterator are also named conventionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iter()` takes elements by reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iter_mut()` takes mutable reference to elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`into_iter()` takes ownership of the values and consumes the actual type once
    iterated completely. The original collection can no longer be accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The type that implements the `Iterator` trait can be used in a `for` loop and
    under the hood, the next method of the item gets called. Consider the for loop
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would get de-sugared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It' will repeatedly call `a.next()` until it matches a `Some(i)` variant. When
    it matches  `None`, the iteration stops.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand iterators more thoroughly, we''ll implement an iterator that
    generates prime numbers up to a certain limit that''s customizable by the user.
    First, let''s clarify the API expectations that we''ll need from our iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have a type called `Primes` that we can instantiate with the `new` method,
    providing the upper bound on the number of primes to generate. We can call `iter()`
    on this instance to convert it in to an iterator type, which can then be used
    in a `for` loop. With that said, let''s add the `new` and `iter` methods on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iter` method takes the `Primes` type via `&self` and returns a `PrimesIter`
    type containing two fields: `index`, which stores the `index` in the vector, and
    a `computed` field that stores the pre-computed primes in a vector. The `compute_primes`
    method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This function implements the sieve of the eratosthenes algorithm for efficiently
    generating prime numbers up to a given limit. Next, there''s the definition of
    the `PrimesIter` struct along with its `Iterator` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `next` method, we loop and get the next prime number if the value at
    `self.index` is `true` in the `self.computed` `Vec`. If we went past the elements
    in our `computed` Vec, then we return `None` to signify that we are done. Here''s
    the complete code with the main function that generates `100` prime numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Great! Apart from `Vec`, there are a lot of types that implement the `Iterator`
    trait in the standard library, such as `HashMap`, `BTreeMap`, and `VecDeque`.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at some of the advanced types in Rust. Let's first
    start with unsized types.
  prefs: []
  type: TYPE_NORMAL
- en: Unsized types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unsized types are categories of types that are first encountered if one tries
    to create a variable of the type, `str`. We know that we can create and use string
    references only behind references such as `&str`. Let''s see what error message
    we get if we try to create a `str` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error upon compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c64fca4-6cf4-41ab-a462-c38cd22f9e2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, Rust creates a reference type of `str` as `''static str`. The error
    message mentions that all local variables—values that live on the stack—must have
    a statically known size at compile time. This is because the stack memory is finite
    and we cannot have infinite- or dynamic-sized types. Similarly, there are other
    instances of types that are unsized:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[T]`: This is a slice of type, `T`. They can only be used as `&[T]` or `&mut
    [T]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dyn Trait`: This is a trait object. They can only be used as a `&dyn Trait`
    or `&mut dyn Trait` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any struct that has an unsized type as its last field is also considered an
    unsized type as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's `str`, which we already explored. `str` internally is just a `[u8]`
    but with the added guarantee that the bytes are valid UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in Rust also have a concrete type and they differ in terms of their
    argument types and also in their `arity`, as in how many arguments they take,
    as in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Functions in Rust are first class citizens. This means they can be stored in
    variables or passed to other functions or returned from functions. The preceding
    code declares a function `add_two`, which we store in `my_func` and later invoke
    with `3` and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Function types are not to be confused with `Fn` closures as they both have `fn`
    as their type signature prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Never type ! and diverging functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used a macro called `unimplemented!()`, which helps in letting the compiler
    ignore any unimplemented function and to compile our code. This works because
    the unimplemented macro returns something called a never type, denoted by `!`.
  prefs: []
  type: TYPE_NORMAL
- en: Unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For interoperability with C code, Rust also supports the `union` type, which
    maps directly to a C union. Unions are unsafe to read from. Let''s see an example
    of how to create and interact with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We created a union type, `Metric`, that has two fields `rounded` and `precise`,
    and represents some measurement. In `main`, we initialize an instance of it in
    the `a` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can only initialize one of the variables, otherwise the compiler complains
    with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We also had to use unsafe blocks to print fields of our union. Compiling and
    running the previous code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get a garbage value for the uninitialized field, `precise`.
    At the time of writing this book, union types only allow `Copy` types as their
    fields. They share the same memory space with all of their fields, exactly like
    C unions.
  prefs: []
  type: TYPE_NORMAL
- en: Cow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cow is a smart pointer type that provides two versions of strings. It stands
    for Clone on Write. It has the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have the two variants:'
  prefs: []
  type: TYPE_NORMAL
- en: Borrowed that represents the borrowed version of some type B. This B has to
    implement the `ToOwned` trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also owned variant which contains the owned version of the type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type is suitable for cases where one needs to avoid allocations where it's
    not needed. A real world example is the JSON parser crate called `serde_json`.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss some of the advanced traits that are important
    to know when we are dealing with complex code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Sized and ?Sized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Sized` trait is a marker trait that represents types whose sizes are known
    at compile time. It is implemented for most types in Rust except for unsized types.
    All type parameters have an implicit trait bound of `Sized` in their definition.
    We can also specify optional trait bounds using the `?` operator before a trait,
    but the `?` operator with traits only works for marker traits as the time of writing
    this book. It may be extended to other types in future.
  prefs: []
  type: TYPE_NORMAL
- en: Borrow and AsRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are special traits that carry the notion of able to construct a out of
    any type.
  prefs: []
  type: TYPE_NORMAL
- en: ToOwned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This trait is meant to be implemented for types that can be converted in to
    an owned version. For example, the `&str` type has this trait implemented for
    `String`. This means the `&str` type has a method called `to_owned()` on it that
    can convert it in to a `String` type, which is an owned type.
  prefs: []
  type: TYPE_NORMAL
- en: From and Into
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convert one type into another, we have the `From` and `Into` traits. The
    interesting part about both of these traits is that we only need to implement
    the `From` trait and we get the implementation of the `Into` trait for free, because
    of the following impl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Trait objects and object safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object safety is a set of rules and restrictions that does not allow trait
    objects to be constructed. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error upon compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/637e6031-d0a6-4e35-9ffe-ecad5de2e43d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This brings us to the idea of object safety, which is a set of restrictions
    that forbids creating a trait object from a trait. In this example, since our
    type doesn''t have a self reference, it''s not possible to create a trait object
    out of it. In this case, to convert any type into a trait object, methods on the
    type need to be an instance—one that takes `self` by reference. So, we change
    our trait method declaration, `foo`, to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This makes the the compiler happy.
  prefs: []
  type: TYPE_NORMAL
- en: Universal function call syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when you are using a type that has the same set of methods
    as one of its implemented traits. In those situations, Rust provides us with the
    uniform function call syntax that works for calling methods that are either on
    types themselves or come from a trait. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code has two methods with the same name, `drive`. One of them
    is an inherent method and the other comes from the trait, `Driver`. If we compile
    and run this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Well, what if we wanted to call the `Driver` trait's `drive` method? Inherent
    methods on types are given higher priority than other methods with the same name.
    To call a trait method, we can use the **Universal Function Call Syntax** (**UFCS**).
  prefs: []
  type: TYPE_NORMAL
- en: Trait rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traits also have special properties and restrictions, which are important to
    know about when you are using them.
  prefs: []
  type: TYPE_NORMAL
- en: An important property of the type system in the context of traits is the **trait
    coherence** rule. The idea of trait coherence is that there should be exactly
    one implementation of a trait on a type that implements it. This should be quite
    obvious since, with two implementations there would be ambiguity in what to choose
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Another rule that might confuse many about traits is the **orphan rule**. The
    orphan rule, in simple words, states that we cannot implement external traits
    on external types.
  prefs: []
  type: TYPE_NORMAL
- en: To word it in another way, either the trait must be defined by you if you are
    implementing something on an external type, or your type should be defined by
    you when you are implementing an external trait. This rules out the possibility
    of having conflicts in overlapping trait implementations across crates.
  prefs: []
  type: TYPE_NORMAL
- en: Closures in depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know already, closures are a fancier version of functions. They are also
    first-class functions, which means that they can be put into variables or can
    be passed as an argument to functions or even returned from a function. But what
    sets them apart from functions is that they are also aware of the environment
    they are declared within and can reference any variable from their environment.
    The way they reference variables from their environment is determined by how the
    variable is used inside the closure.
  prefs: []
  type: TYPE_NORMAL
- en: A closure, by default, will try to capture the variable in the most flexible
    way possible. Only when the programmer needs a certain way of capturing the value
    will they coerce to the programmer's intent. That won't make much sense unless
    we see different kinds of closures in action. Closures under the hood are anonymous
    structs that implement three traits that represent how closures access their environment.
    We will look at the three traits (ordered from least restrictive to most restrictive)
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Fn closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures that access variables only for read access implement the `Fn` trait.
    Any value they access are as reference types (`&T`). This is the default mode
    of borrowing the closures assumes. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output upon compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `a` variable was still accessible even after invoking the closure as the
    closure used `a` by reference.
  prefs: []
  type: TYPE_NORMAL
- en: FnMut closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the compiler figures out that a closure mutates a value referenced from
    the environment, the closure implements the `FnMut` trait. Adapting the same code
    as before, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The previous closure adds the  `"Alice"` string to `a`. `fn_mut_closure` mutates
    its environment.
  prefs: []
  type: TYPE_NORMAL
- en: FnOnce closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures that take ownership of the data they read from their environment get
    implemented with `FnOnce`. The name signifies that this closure can only be called
    once and, because of that, the variables are available only once. This is the
    least recommended way to construct and use closures, because you cannot use the
    referenced variables later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This fails with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fedfd1b-c35a-4c96-b0de-71bbe8b31a4f.png)'
  prefs: []
  type: TYPE_IMG
- en: But there are use cases where `FnOnce` closures are the only applicable closures.
    One such example is the `thread::spawn` method in the standard library used for
    spawning new threads.
  prefs: []
  type: TYPE_NORMAL
- en: Consts in structs, enums, and traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structs, enums, and traits definitions can also be provided with constant field
    members. They can be used in cases where you need to share a constant among them.
    Take, for example, a scenario where we have a `Circle` trait that''s is meant
    to be implemented by different circular shape types. We can add a `PI` constant
    to the `Circle` trait, which can be shared by any type that has an  `area` property
    and relies on value of `PI` for calculating the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also have consts in structs and enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at some of the advanced aspects of modules.
  prefs: []
  type: TYPE_NORMAL
- en: Modules, paths, and imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust provides us with a lot of flexibility in terms of how we organize our project,
    as we saw in [Chapter 2](41099eaf-eb1e-4f75-bfdd-628152f59b58.xhtml), *Managing
    Projects with Cargo*. Here, we'll go into some of the advanced aspects of modules
    and different ways to introduce more privacy in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do **nested imports** of items from modules. This helps in reducing
    the taken up by imports. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Re-exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Re-exports allows one to selectively expose items from a module. We were already
    using the convenience of reexports when we used the `Option` and `Result` types.
    Re-exports also helps in reducing the import path one has to write if the module
    is created a nested directory containing many submodules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here we have a sub module named `bar.rs` from a cargo project
    we created called `reexports`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bar` is a publicly exposed struct module under `src/foo/bar.rs`. If the
    user wants to use `Bar` in their code, they will have to write something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `use` statement is quite verbose. When you have a lot of nested sub-modules
    in your project, this gets awkward and redundant. Instead, we can reexport `Bar`
    from the `bar` module all of the way to our crate root, like so, in our `foo.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: To re-export, we use the `pub use` keyword. Now we can easily use `Bar` as well
    as using `foo::Bar`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Rust recommends **absolute imports** within root modules. Absolute
    imports are done starting with the `crate` keyword, whereas **relative imports**
    are done using the `self` keyword. When re-exporting sub-modules to their parent
    modules, we might benefit from relative imports, as using absolute imports becomes
    long and redundant.
  prefs: []
  type: TYPE_NORMAL
- en: Selective privacy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The privacy of items in Rust starts at the module level. As a library author,
    to expose things to users from a module, we use the `pub` keyword. But there are
    items that we only want to expose to other modules within the crate, but not to
    the users. In such cases, we can use the `pub(crate)` modifier for the item, which
    allows the item to be exposed only within the crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Advanced match patterns and guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a look at some of the advanced usage of match and
    let patterns. First, let's look at match.
  prefs: []
  type: TYPE_NORMAL
- en: Match guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also use match guards on arms (`if code > 400 || code <= 500`) to match
    on a subset of values. They start with an `if` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced let destructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following complex data that we want to match against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Casting and coercion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Casting is a mechanism of downgrading or upgrading a type to some other type.
    When the casting happens implicitly, it is called coercion. Rust also allows for
    casting types at various levels. The very obvious candidates are primitive numeric
    types. You may have the need to cast a `u8` type to promote to `u64` or to truncate `i64`
    to `i32`. To perform trivial casts, we use the `as` keyword, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not only primitive types—casting is supported at higher-level types too.
    We can also cast a reference of a type to its trait object, if it implements that
    particular trait. So we can do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other classes of casting supported by various pointer types:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a `*mut T` to `*const T`. The other method is forbidden in safe Rust
    and requires an `unsafe` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting  `&T`  in to `*const T` and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also another explicit and unsafe version of casting called `transmutes`
    and, because it's unsafe, it is very dangerous to use when you are unaware of
    the consequences. When used ignorantly, it leads you into situations similar to
    one where you create a pointer from an integer in C.
  prefs: []
  type: TYPE_NORMAL
- en: Types and memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll touch on some aspects and low-level details of types
    in programming languages that are important to know if you are someone writing
    systems software and care about performance.
  prefs: []
  type: TYPE_NORMAL
- en: Memory alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of those aspects of memory management that you will rarely have
    to care about unless performance is a strict requirement. Due to data access latency
    between memory and the processor, when the processor accesses data from memory,
    it does so in a chunk and not byte by byte. This is to help reduce the number
    of memory accesses. This chunk size is called the memory access granularity of
    the CPU. Usually, the chunk sizes are one word (32 bit), two word, four word,
    and so on, and they depend on the target architecture. Due to this access granularity,
    it is desired that the data resides in memory which is aligned to a multiple of
    the word size. If that is not the case, then the CPU has to read and then perform
    left or right shifts on the data bits and discard the unneeded data to read a
    particular value. This wastes CPU cycles. In most cases, the compiler is smart
    enough to figure out the data alignment for us, but in some cases, we need to
    tell it. There are two important terms we need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Word size:** Word size means the number of bits of data processed by the
    microprocessor as a unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory access granularity:** The minimum chunk of data accessed by the CPU
    from the memory bus is called the memory access granularity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types in all programming languages have both a size and an alignment. The
    alignment of primitive types is equal to their size. So, usually, all primitive
    types are aligned and the CPU has no problem doing an aligned read for these.
    But when we create custom data types, compilers usually insert padding between
    our struct fields if they are not aligned to allow the CPU to access memory in
    an aligned manner.
  prefs: []
  type: TYPE_NORMAL
- en: Having known about data type size and alignment, let's explore the `std::mem`
    module from the standard library that allows us to introspect data types and their
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the std::mem module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In regard to types and their size in memory, the `mem` module from the standard
    library provides us with convenient APIs to inspect sizes and alignment of types
    and functionalities for initializing raw memory. Quite a few of these functions
    are unsafe and must only be used when the programmer knows what they are doing.
    We''ll restrict our exploration to these APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size_of` returns the size of a type given via a generic type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size_of_val` returns the size of a value given as a reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Being generic, these methods are meant to be called using the turbofish `::<>`
    operator. We are not actually giving these methods a type as a parameter; we''re
    just explicitly calling them against a type. If we were skeptical about the zero-cost
    claims of some of the preceding generic types, we could use these functions to
    check the overhead. Let''s take a look at some sizes of types in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Another observation that''s important to notice, is the size of various pointers.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We create pointers to a Coordinate struct in a bunch of different ways and
    we print their sizes by casting them as different kind of pointers. Compiling
    and running the code above, gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This clearly shows that trait objects and references to traits are fat pointers
    double the size of a normal pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and deserialization using serde
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serialization and deserialization are important concepts to understand for any
    kind of application needs to transfer or store data in a compact manner. **Serialization**
    is the process by which an in-memory data type can be converted into a sequence
    of bytes, while **deserilization** is the opposite of that, meaning it can read
    data. Many programming languages provide support for converting a data structure
    into a sequence of bytes. The beautiful part about `serde` is that it generates
    the serialization of any supported type at compile time, relying heavily on procedural
    macros. Serialization and deserialization is a zero cost operation with serde
    most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this demo, we''ll explore the `serde` crate to serialize and deserialize
    a user defined type. Let''s create a new project by running `cargo new serde_demo`
    with the following contents in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are the contents in `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: To serialize any native data type to a JSON-like format, we simply need to put
    a derive annotation over our types, which is the case of for our struct, `Foo`.
  prefs: []
  type: TYPE_NORMAL
- en: '`serde` supports a lot of serializers implemented as crates. Popular examples
    are `serde_json`, `bincode` and  `TOML`. More supported formats can be found at:
    [https://github.com/TyOverby/bincode](https://github.com/TyOverby/bincode). These
    serialization implementors, such as the `serde_json` crate, provide methods such
    as `to_string` to convert'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered quite a bit of detail on some of the advanced aspects
    of Rust's type system. We got to know the various traits that make writing ergonomic
    Rust code. We also saw advanced pattern matching constructs. In the end, we looked
    at the serde crate that is blazing fast in performing data serialization. The
    next chapter will be about how to do multiple things at the same time using concurrency.
  prefs: []
  type: TYPE_NORMAL
