["```rs\nname=John%20Doe&age=18\n```", "```rs\nContent-Type: multipart/form-data; boundary=---------------------------charactersforboundary123\n```", "```rs\nContent-Type: multipart/form-data; boundary=---------------------------charactersforboundary123\n```", "```rs\nContent-Disposition: form-data; name=\"name\"\n```", "```rs\nJohn Doe\n```", "```rs\n-----------------------------charactersforboundary123\n```", "```rs\nContent-Disposition: form-data; name=\"upload\"; filename=\"file1.txt\"\n```", "```rs\nContent-Type: text/plain\n```", "```rs\nLorem ipsum dolor sit amet \n```", "```rs\n-----------------------------charactersforboundary123\n```", "```rs\nContent-Disposition: form-data; name=\"other_field\"\n```", "```rs\nOther field\n```", "```rs\n    multer = \"2.0.2\"\n    tokio-util = \"0.6.9\"\n    ```", "```rs\n    limits = {\"file/avif\" = \"1Mib\", \"file/gif\" = \"1Mib\", \"file/jpg\" = \"1Mib\", \"file/jpeg\" = \"1Mib\", \"file/png\" = \"1Mib\", \"file/svg\" = \"1Mib\", \"file/webp\" = \"1Mib\", \"file/webm\" = \"64Mib\", \"file/mp4\" = \"64Mib\", \"file/mpeg4\" = \"64Mib\", \"file/mpg\" = \"64Mib\", \"file/mpeg\" = \"64Mib\", \"file/mov\" = \"64Mib\"}\n    temp_dir = \"/tmp\"\n    ```", "```rs\n    <form action=\"/users/{{ user.uuid }}/posts\" enctype=\"multipart/form-data\" method=\"POST\">\n      <fieldset>\n        <legend>New Post</legend>\n        <div class=\"row\">\n          <div class=\"col-sm-12 col-md-3\">\n            <label for=\"upload\">Upload file:</label>\n          </div>\n          <div class=\"col-sm-12 col-md\">\n            <input type=\"file\" name=\"file\" accept=\" \n            text/plain\">\n          </div>\n        </div>\n        <button type=\"submit\" value=\"Submit\">Submit</\n        button>\n      </fieldset>\n    </form>\n    ```", "```rs\n    pub async fn create(\n        connection: &mut PgConnection,\n        user_uuid: &str,\n        post_type: PostType,\n        content: &str,\n    ) -> Result<Self, OurError> {\n        let parsed_uuid = Uuid::parse_str(\n        user_uuid).map_err(OurError::from_uuid_error)?;\n        let uuid = Uuid::new_v4();\n        let query_str = r#\"INSERT INTO posts\n    (uuid, user_uuid, post_type, content)\n    VALUES\n    ($1, $2, $3, $4)\n    RETURNING *\"#;\n        Ok(sqlx::query_as::<_, Self>(query_str)\n            .bind(uuid)\n            .bind(parsed_uuid)\n            .bind(post_type)\n            .bind(content)\n            .fetch_one(connection)\n            .await\n            .map_err(OurError::from_sqlx_error)?)\n    }\n    ```", "```rs\n    use rocket::form::FromForm;\n    ...\n    #[derive(FromRow, FromForm)]\n    pub struct Post {...}\n    ```", "```rs\n    pub mod guards;\n    ```", "```rs\nuse rocket::request::{FromRequest, Outcome};\npub struct RawContentType<'r>(pub &'r str);\n```", "```rs\n    #[rocket::async_trait]\n    impl<'r> FromRequest<'r> for RawContentType<'r> {\n        type Error = ();\n        async fn from_request(req: &'r rocket::\n        Request<'_>) -> Outcome<Self, Self::Error> {\n            let header = req.headers().get_one(\"\n            Content-Type\").or(Some(\"\")).unwrap();\n            Outcome::Success(RawContentType(header))\n        }\n    }\n    ```", "```rs\n    #[post(\"/users/delete/<uuid>\", format = \"application/x-www-form-urlencoded\", rank = 2)]\n    pub async fn delete_user_entry_point(...) -> ... {...}\n    ```", "```rs\n    use crate::guards::RawContentType;\n    use crate::models::post_type::PostType;\n    use multer::Multipart;\n    use rocket::request::FlashMessage;\n    use rocket::response::{Flash, Redirect};\n    use rocket::data::{ByteUnit, Data};\n    ```", "```rs\n    const TEXT_LIMIT: ByteUnit = ByteUnit::Kibibyte(64); \n    ```", "```rs\n    pub async fn get_posts(\n        ...\n        flash: Option<FlashMessage<'_>>,\n    ) -> HtmlResponse {\n        let flash_message = flash.map(|fm| \n        String::from(fm.message()));\n        ...\n        let context = context! {flash: flash_message,...};\n        Ok(Template::render(\"posts/index\", context))\n    }\n    ```", "```rs\n    #[post(\"/users/<user_uuid>/posts\", format = \"multipart/form-data\", data = \"<upload>\", rank = 1)]\n    pub async fn create_post(\n        mut db: Connection<DBConnection>,\n        user_uuid: &str,\n        content_type: RawContentType<'_>,\n        upload: Data<'_>,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {...}\n    ```", "```rs\n    let create_err = || {\n        Flash::error(\n            Redirect::to(format!(\"/users/{}/posts\", \n            user_uuid)),\n            \"Something went wrong when uploading file\",\n        )\n    };\n    ```", "```rs\n    let boundary = multer::parse_boundary(content_type.0).map_err(|_| create_err())?;\n    ```", "```rs\n    let upload_stream = upload.open(TEXT_LIMIT);\n    let mut multipart = Multipart::new(tokio_util::io::ReaderStream::new(upload_stream), boundary);\n    let mut text_post = String::new();\n    ```", "```rs\n    while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {\n        let field_name = field.name();\n        let file_name = field.file_name();\n        let content_type = field.content_type();\n        println!(\n            \"Field name: {:?}, File name: {:?}, \n            Content-Type: {:?}\",\n            field_name, file_name, content_type\n        );\n    }\n    ```", "```rs\nwhile let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {\n    while let Some(field_chunk) = \n    field.chunk().await.map_err(|_| create_err())? {\n        text_post.push_str(std::str::from_utf8(\n        field_chunk.as_ref()).unwrap());\n    }\n}\n```", "```rs\n    let connection = db.acquire().await.map_err(|_| create_err())?;\n    Post::create(connection, user_uuid, PostType::Text, &text_post)\n        .await\n        .map_err(|_| create_err())?;\n    Ok(Flash::success(\n        Redirect::to(format!(\"/users/{}/posts\", \n        user_uuid)),\n        \"Successfully created post\",\n    ))\n    ```", "```rs\n    image = \"0.24.0\"\n    ```", "```rs\n    use rocket::fs::TempFile;\n    ...\n    #[derive(Debug, FromForm)]\n    pub struct NewPost<'r> {\n        pub file: TempFile<'r>,\n    }\n    ```", "```rs\n    ...\n    <input type=\"file\" name=\"file\" accept=\"text/plain,image/*\">\n    ...\n    ```", "```rs\n    use crate::guards::RawContentType;\n    use multer::Multipart;\n    use rocket::data::{ByteUnit, Data};\n    ...\n    const TEXT_LIMIT: ByteUnit = ByteUnit::Kibibyte(64);\n    ...\n    let boundary = multer::parse_boundary(content_type.0).map_err(|_| create_err())?;\n    ...until\n    while let Some(mut field) = multipart.next_field().await.map_err(|_| create_err())? {\n    ...\n    }\n    ```", "```rs\n    use crate::models::post::{NewPost, Post, ShowPost};\n    use image::codecs::jpeg::JpegEncoder;\n    use image::io::Reader as ImageReader;\n    use image::{DynamicImage, ImageEncoder};\n    use rocket::form::Form;\n    use std::fs::File;\n    use std::io::{BufReader, Read};\n    use std::ops::Deref;\n    use std::path::Path;\n    ```", "```rs\n    pub async fn create_post<'r>(\n        mut db: Connection<DBConnection>,\n        user_uuid: &str,\n        mut upload: Form<NewPost<'r>>,\n    ) -> Result<Flash<Redirect>, Flash<Redirect>> {...}\n    ```", "```rs\n    let file_uuid = uuid::Uuid::new_v4().to_string();\n    ```", "```rs\n    if upload.file.content_type().is_none() {\n        return Err(create_err());\n    }\n    ```", "```rs\n    let ext = upload.file.content_type().unwrap().extension().unwrap();\n    let tmp_filename = format!(\"/tmp/{}.{}\", &file_uuid, &ext);\n    ```", "```rs\n    upload\n        .file\n        .persist_to(tmp_filename)\n        .await\n        .map_err(|_| create_err())?;\n    ```", "```rs\n    let mut content = String::new();\n    let mut post_type = PostType::Text;\n    ```", "```rs\n    let mt = upload.file.content_type().unwrap().deref();\n    if mt.is_text() {\n    } else if mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif() {\n    } else if mt.is_svg() {\n    } else {\n        return Err(create_err());\n    }\n    ```", "```rs\n    let orig_path = upload.file.path().unwrap().to_string_lossy().to_string();\n    let mut text_content = vec![];\n    let _ = File::open(orig_path)\n        .map_err(|_| create_err())?\n        .read(&mut text_content)\n        .map_err(|_| create_err())?;\n    content.push_str(std::str::from_utf8(&text_content).unwrap());\n    ```", "```rs\n    post_type = PostType::Photo;\n    let dest_filename = format!(\"{}.svg\", file_uuid);\n    content.push_str(\"/assets/\");\n    content.push_str(&dest_filename);\n    let dest_path = Path::new(rocket::fs::relative!(\"static\")).join(&dest_filename);\n    upload\n        .file\n        .move_copy_to(&dest_path)\n        .await\n        .map_err(|_| create_err())?;\n    ```", "```rs\n    post_type = PostType::Photo;\n    let orig_path = upload.file.path().unwrap().to_string_lossy().to_string();\n    let dest_filename = format!(\"{}.jpg\", file_uuid);\n    content.push_str(\"/assets/\");\n    content.push_str(&dest_filename);\n    ```", "```rs\n    let orig_file = File::open(orig_path).map_err(|_| create_err())?;\n    let file_reader = BufReader::new(orig_file);\n    let image: DynamicImage = ImageReader::new(file_reader)\n        .with_guessed_format()\n        .map_err(|_| create_err())?\n        .decode()\n        .map_err(|_| create_err())?;\n    ```", "```rs\n    let dest_path = Path::new(rocket::fs::relative!(\"static\")).join(&dest_filename);\n    let mut file_writer = File::create(dest_path).map_err(|_| create_err())?;\n    ```", "```rs\n    let encoder = JpegEncoder::new_with_quality(&mut file_writer, 75);\n    encoder\n        .write_image(\n            image.as_bytes(),\n            image.width(),\n            image.height(),\n            image.color(),\n        )\n        .map_err(|_| create_err())?;\n    ```", "```rs\n    Post::create(connection, user_uuid, post_type, &content)\n    ...\n    ```", "```rs\nasync fn async_task1() {...}\n```", "```rs\nasync fn async_task2() {...}\n```", "```rs\nuse futures::executor::block_on;\n```", "```rs\nasync fn async_task1() {...}\n```", "```rs\nfn main() {\n```", "```rs\n    let wait = async_task1();\n```", "```rs\n    block_on(wait); // wait until async_task1 finish\n```", "```rs\n}\n```", "```rs\nasync fn combine() {\n```", "```rs\n    async_task1().await;\n```", "```rs\n    async_task2().await;\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n    block_on(combine());\n```", "```rs\n}\n```", "```rs\nasync fn combine2() {\n```", "```rs\n  let t1 = async_task1();\n```", "```rs\n  let t2 = async_task2();\n```", "```rs\n  futures::join!(t1, t2);\n```", "```rs\n}\n```", "```rs\nfn main() {\n```", "```rs\n  block_on(combine2());\n```", "```rs\n}\n```", "```rs\n    tokio = {version = \"1.16\", features = [\"fs\", \"rt\"]}\n    ```", "```rs\n    use std::fs::File;\n    use std::io::{BufReader, Read};\n    ```", "```rs\nuse image::error::ImageError;\nuse std::io::Cursor;\nuse tokio::fs::File;\nuse tokio::io::AsyncReadExt;\n```", "```rs\n    let _ = File::open(orig_path)\n        .map_err(|_| create_err())?\n        .read(&mut text_content)\n        .map_err(|_| create_err())?;\n    ```", "```rs\nlet _ = File::open(orig_path)\n    .await\n    .map_err(|_| create_err())?\n    .read_to_end(&mut text_content)\n    .await\n    .map_err(|_| create_err())?;\n```", "```rs\nlet orig_file = File::open(orig_path).map_err(|_| create_err())?;\nlet file_reader = BufReader::new(orig_file);\n```", "```rs\nlet orig_file = tokio::fs::read(orig_path).await.map_err(|_| create_err())?;\nlet read_buffer = Cursor::new(orig_file);\n```", "```rs\n    let image: DynamicImage = ImageReader::new(file_reader)\n        .with_guessed_format()\n        .map_err(|_| create_err())?\n        .decode()\n        .map_err(|_| create_err())?\n    ```", "```rs\nlet encoded_result: Result<DynamicImage, ()> = tokio::task::spawn_blocking(|| {\n    Ok(ImageReader::new(read_buffer)\n        .with_guessed_format()\n        .map_err(|_| ())?\n        .decode()\n        .map_err(|_| ())?)\n})\n.await\n.map_err(|_| create_err())?;\nlet image = encoded_result.map_err(|_| create_err())?;\n```", "```rs\n    let dest_path = Path::new(rocket::fs::relative!(\"static\")).join(&dest_filename);\n    let mut file_writer = File::create(dest_path).map_err(|_| create_err())?;\n    JpegEncoder::new_with_quality(&mut file_writer, 75)\n        .write_image(\n            image.as_bytes(),\n            image.width(),\n            image.height(),\n            image.color(),\n        )\n        .map_err(|_| create_err())?;\n    ```", "```rs\nlet write_result: Result<Vec<u8>, ImageError> = tokio::task::spawn_blocking(move || {\n    let mut write_buffer: Vec<u8> = vec![];\n    let mut write_cursor = Cursor::new(&mut \n    write_buffer);\n    let _ = JpegEncoder::new_with_quality(&mut \n    write_cursor, 75).write_image(\n        image.as_bytes(),\n        image.width(),\n        image.height(),\n        image.color(),\n    )?;\n    Ok(write_buffer)\n})\n.await\n.map_err(|_| create_err())?;\nlet write_bytes = write_result.map_err(|_| create_err())?;\nlet dest_path = Path::new(rocket::fs::relative!(\"static\")).join(&dest_filename);\ntokio::fs::write(dest_path, &write_bytes)\n    .await\n    .map_err(|_| create_err())?;\n```", "```rs\n    flume = \"0.10.10\"\n    ffmpeg-cli = \"0.1\"\n    ```", "```rs\n    <input type=\"file\" name=\"file\" accept=\"text/plain,image/*,video/*\">\n    ```", "```rs\n    fn raw_html(&self) -> String {\n        if self.0.content.starts_with(\"loading\") {\n            return String::from(\n    \"<figure><img src=\\\"/assets/loading.gif\\\" \n                class=\\\"section media\\\"/></figure>\",\n            );\n        }\n        ...\n    }\n    ```", "```rs\n    pub async fn make_permanent(\n        connection: &mut PgConnection,\n        uuid: &str,\n        content: &str,\n    ) -> Result<Post, OurError> {\n        let parsed_uuid = Uuid::parse_str(uuid).map_err(\n        OurError::from_uuid_error)?;\n        let query_str = String::from(\"UPDATE posts SET \n        content = $1 WHERE uuid = $2 RETURNING *\");\n        Ok(sqlx::query_as::<_, Self>(&query_str)\n            .bind(content)\n            .bind(&parsed_uuid)\n            .fetch_one(connection)\n            .await\n            .map_err(OurError::from_sqlx_error))?\n    }\n    ```", "```rs\n    pub mod worker;\n    ```", "```rs\n    pub struct Message {\n        pub uuid: String,\n        pub orig_filename: String,\n        pub dest_filename: String,\n    }\n    impl Message {\n        pub fn new() -> Self {\n            Message {\n                uuid: String::new(),\n                orig_filename: String::new(),\n                dest_filename: String::new(),\n            }\n        }\n    }\n    ```", "```rs\n    pub mod workers;\n    ```", "```rs\n    pub mod video;\n    ```", "```rs\n    use crate::models::post::Post;\n    use crate::models::worker::Message;\n    use ffmpeg_cli::{FfmpegBuilder, File, Parameter};\n    use sqlx::pool::PoolConnection;\n    use sqlx::Postgres;\n    use std::process::Stdio;\n    use tokio::runtime::Handle;\n    ```", "```rs\n    pub fn process_video(connection: &mut PoolConnection<Postgres>, wm: Message) -> Result<(), ()> {...}\n    ```", "```rs\n    let mut dest = String::from(\"static/\");\n    dest.push_str(&wm.dest_filename);\n    ```", "```rs\n    let builder = FfmpegBuilder::new()\n        .stderr(Stdio::piped())\n        .option(Parameter::Single(\"nostdin\"))\n        .option(Parameter::Single(\"y\"))\n        .input(File::new(&wm.orig_filename))\n        .output(\n            File::new(&dest)\n                .option(Parameter::KeyValue(\"vcodec\", \n                \"libx265\"))\n                .option(Parameter::KeyValue(\"crf\", \"28\")),\n        );\n    ```", "```rs\n    let make_permanent = async {\n        let ffmpeg = builder.run().await.unwrap();\n        let _ = ffmpeg.process.wait_with_output().\n        unwrap();\n        let mut display_path = String::from(\"/assets/\");\n        display_path.push_str(&wm.dest_filename);\n        Post::make_permanent(connection, &wm.uuid, \n        &display_path).await\n    };\n    let handle = Handle::current();\n    Ok(handle\n        .block_on(make_permanent)\n        .map(|_| ())\n        .map_err(|_| ())?)\n    ```", "```rs\nuse our_application::models::worker::Message;\nuse our_application::workers::video::process_video;\nuse rocket::serde::Deserialize;\nuse sqlx::postgres::PgPoolOptions;\nuse tokio::runtime::Handle;\n```", "```rs\n    #[derive(Deserialize)]\n    struct Config {\n        databases: Databases,\n    }\n    #[derive(Deserialize)]\n    struct Databases {\n        main_connection: MainConnection,\n    }\n    #[derive(Deserialize)]\n    struct MainConnection {\n        url: String,\n    }\n    ```", "```rs\n    let (tx, rx) = flume::bounded::<Message>(5);\n    ```", "```rs\n    rocket::build()\n        .attach(DBConnection::init())\n        .attach(Template::fairing())\n        .attach(Csrf::new())\n        .mount(...)\n    ```", "```rs\nlet our_rocket = rocket::build()\n    .attach(DBConnection::init())\n    .attach(Template::fairing())\n    .attach(Csrf::new())\n    .manage(tx)\n    .mount(...);\n```", "```rs\n    let config: Config = our_rocket\n        .figment()\n        .extract()\n        .expect(\"Incorrect Rocket.toml configuration\");\n    let pool = PgPoolOptions::new()\n        .max_connections(5)\n        .connect(&config.databases.main_connection.url)\n        .await\n        .expect(\"Failed to connect to database\");\n    ```", "```rs\n    tokio::task::spawn_blocking(move || loop {\n        let wm = rx.recv().unwrap();\n        let handle = Handle::current();\n        let get_connection = async { (&pool).\n        acquire().await.unwrap() };\n        let mut connection = handle.block_on(get_\n        connection);\n        let _ = process_video(&mut connection, wm);\n    });\n    our_rocket\n    ```", "```rs\n    use crate::errors::our_error::OurError;\n    use crate::models::worker::Message;\n    use flume::Sender;\n    use rocket::State;\n    ```", "```rs\n    pub async fn create_post<'r>(\n        ...\n        tx: &State<Sender<Message>>,\n    )\n    ```", "```rs\n    let mut wm = Message::new();\n    let mut is_video = false;\n    ```", "```rs\n    else if mt.is_mp4() || mt.is_mpeg() || mt.is_ogg() || mt.is_mov() || mt.is_webm() {\n        post_type = PostType::Video;\n        let dest_filename = format!(\"{}.mp4\", file_uuid);\n        content.push_str(\"loading/assets/\");\n        content.push_str(&dest_filename);\n        is_video = true;\n        wm.orig_filename = upload\n            .file\n            .path()\n            .unwrap()\n            .to_string_lossy()\n            .to_string()\n            .clone();\n        wm.dest_filename = dest_filename.clone();\n    }\n    ```", "```rs\n    Post::create(connection, user_uuid, post_type, &content)\n        .await\n        .map_err(|_| create_err())?;\n    Ok(Flash::success(\n        Redirect::to(format!(\"/users/{}/posts\", \n        user_uuid)),\n        \"Successfully created post\",\n    ))\n    ```", "```rs\nOk(Post::create(connection, user_uuid, post_type, &content)\n    .await\n    .and_then(move |post| {\n        if is_video {\n            wm.uuid = post.uuid.to_string();\n            let _ = tx.send(wm).map_err(|_| {\n                OurError::new_internal_server_error(\n                    String::from(\"Cannot process \n                    message\"),\n                    None,\n                )\n            })?;\n        }\n        Ok(Flash::success(\n            Redirect::to(format!(\"/users/{}/posts\", \n            user_uuid)),\n            \"Successfully created post\",\n        ))\n    })\n    .map_err(|_| create_err())?)\n```"]