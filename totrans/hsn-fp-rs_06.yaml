- en: Mutability, Ownership, and Pure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性、所有权和纯函数
- en: Rust has introduced some new concepts of its own with respect to object ownership.
    These safeguards protect the developer from certain classes of errors, such as
    double free memory or hanging pointers, but also create constraints that can feel
    unmerited at times. Functional programming may help ease some of this conflict
    by encouraging the use of immutable data and pure functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust在对象所有权方面引入了一些自己的新概念。这些安全措施可以保护开发者免受某些类别的错误，例如双重释放内存或悬挂指针，但有时也会创建一些感觉不合理的约束。函数式编程可能通过鼓励使用不可变数据和纯函数来帮助缓解一些这种冲突。
- en: In this chapter, we will look at a case of ownership gone wrong. You will inherit
    code that has been abandoned as being too difficult to work with. Your job in
    this chapter will be to address the problems that the previous team were unable
    to overcome. To achieve this, you will need to use much of what you have learned
    so far, along with a gained understanding of the specific behaviors and constraints of
    ownership in Rust.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个所有权出错的情况。你将继承已被放弃且难以工作的代码。在本章中，你的任务是解决前一个团队未能克服的问题。为了实现这一点，你需要使用迄今为止所学的大部分知识，以及你对Rust中所有权的特定行为和约束的理解。
- en: 'Learning outcomes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习成果：
- en: Recognizing anti-patterns of complex ownership
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别复杂所有权的反模式
- en: Learning specific rules of complex ownership
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习复杂所有权的具体规则
- en: Using immutable data to prevent anti-patterns of ownership
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变数据来防止所有权的反模式
- en: Using pure functions to prevent anti-patterns of ownership
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯函数来防止所有权的反模式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A recent version of Rust is necessary to run the examples provided:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行提供的示例需要Rust的最近版本：
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
- en: 'This chapter''s code is also available on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每章的`README.md`文件中也包含了具体的安装和构建说明。
- en: Recognizing anti-patterns of ownership
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别所有权的反模式
- en: Consider the following situation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况。
- en: Congratulations, you have inherited legacy code. A previous team responsible
    for developing privileged access modules for elevators has been moved to a different
    project. They successfully developed code libraries to interface with a range
    of microcontrollers. However, while developing the access logic in Rust, they
    found object ownership to be very complicated and were unable to develop software
    that was compatible with Rust.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你继承了遗留代码。负责为电梯开发特权访问模块的前一个团队已被转移到不同的项目。他们成功开发了与一系列微控制器接口的代码库。然而，在用Rust开发访问逻辑时，他们发现对象所有权非常复杂，并且无法开发与Rust兼容的软件。
- en: Your task in this chapter will be to analyze their code, look for possible solutions,
    then create a library to support privileged access for your elevators. To clarify,
    privileged access refers to override codes and keys made available to emergency
    services such as police, firemen, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你的任务将是分析他们的代码，寻找可能的解决方案，然后创建一个库以支持电梯的特权访问。为了明确，特权访问指的是提供给紧急服务（如警察、消防员等）的覆盖代码和密钥。
- en: Inspecting the microcontroller drivers
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查微控制器驱动程序
- en: The microcontroller drivers are written in other languages and exposed to Rust
    through the **foreign function interface** (**FFI**) feature. An FFI is a way
    of connecting Rust code to libraries written in other languages. The following
    are the symbols defined in the foreign library and bindings in `src/magic.rs`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器驱动程序是用其他语言编写的，并通过**外部函数接口**（**FFI**）功能暴露给Rust。FFI是连接Rust代码到用其他语言编写的库的一种方式。以下是在`src/magic.rs`中定义的外部库符号和绑定。
- en: 'This function issues an override code to the library and subsystem, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数向库和子系统发出一个覆盖代码，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When an override code is entered, it will be exposed through this function.
    The higher layers should interpret what the override codes mean to potentially
    enter emergency operation modes or other maintenance functions, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入覆盖代码时，它将通过此函数暴露。上层应解释覆盖代码的含义，以便可能进入紧急操作模式或其他维护功能，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When an override mode has been established and the emergency service worker
    enters a floor, this method will be called. Floor requests from emergency modes
    should take precedence over normal `elevator` operation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立覆盖模式并且紧急服务人员进入楼层时，将调用此方法。紧急模式下的楼层请求应优先于正常的`elevator`操作：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Error codes occurring from the `override` operation will be exposed through
    this function. Issues such as invalid override codes will be presented for higher
    layers to decide how to respond:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`override`操作的错误代码将通过此函数暴露。例如无效的覆盖代码等问题将呈现给上层以决定如何响应：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If an override code is entered, an authorized override session will be created:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入了覆盖代码，将创建一个授权的覆盖会话：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After an override session is complete, it should be freed to release resources
    and reset state:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖会话完成后，应释放资源并重置状态：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If a physical key access is initiated to an elevator, then this method will
    expose the result:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动了电梯的物理密钥访问，则此方法将暴露结果：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a physical key access is initiated by an administrator, then this method
    will expose the result, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管理员启动了物理密钥访问，则此方法将暴露结果，如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function will force the elevator into manual operation mode:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将强制电梯进入手动操作模式：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function will force the elevator into normal operation mode:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将强制电梯进入正常操作模式：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function will reset the elevator state:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将重置电梯状态：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function will perform a timed flashing pattern of lights on the elevator
    control panel:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将在电梯控制面板上执行灯光的定时闪烁模式：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function will toggle the light for a button or other symbol on the elevator
    control panel:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将切换电梯控制面板上按钮或其他符号的灯光：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function will alter the display color of a light on the elevator control
    panel:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将改变电梯控制面板上灯光的显示颜色：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inspecting the type and trait definitions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查类型和特质定义
- en: The Rust type and trait definitions left behind were primarily intended to wrap
    the library interfaces. Let's look quickly through the symbols defined in `src/admin.rs`
    to familiarize ourselves with how the library was intended to work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Rust类型和特质的定义主要目的是封装库接口。让我们快速浏览一下`src/admin.rs`中定义的符号，以便熟悉库的预期工作方式。
- en: Defining the OverrideCode enum
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`OverrideCode`枚举
- en: 'The `OverrideCode` enum gives typesafe definitions and names to the different
    override codes from the linked library. This code associates named enum values
    with the numerical enumerated values returned or sent to the FFI. Notice the syntax
    pattern assigning integer values to each enum element:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverrideCode`枚举为从链接库的不同覆盖代码提供了类型安全的定义和命名。此代码将命名枚举值与返回或发送给FFI的数值枚举值关联。注意分配整数值给每个枚举元素的语法模式：'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Defining the ErrorCode enum
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`ErrorCode`枚举
- en: 'Similar to `OverrideCode`, the `ErrorCode` enum defines typesafe labels for
    each of the library error codes. There is also a helper function to cast integers
    into the enum type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与`OverrideCode`类似，`ErrorCode`枚举为库中的每个错误代码定义了类型安全的标签。还有一个辅助函数可以将整数转换为枚举类型：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Defining the AuthorizedSession struct and deconstructor
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`AuthorizedSession`结构体和析构函数
- en: 'The `AuthorizedSession` struct wraps a session pointer from the library. This
    struct also implements the `Drop` trait, which is called when the object goes
    out of scope. The `free_override_session` call here is very important and should
    be noted as a potential source of problems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizedSession`结构体封装了从库中获取的会话指针。此结构体还实现了`Drop`特质，当对象超出作用域时会被调用。这里`free_override_session`调用非常重要，应作为潜在问题源进行标注：'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Authorizing sessions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权会话
- en: 'To authorize a session, there are three steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 授权会话有三个步骤：
- en: Authorize the session
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权会话
- en: Poll and retrieve the session object
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轮询并检索会话对象
- en: Check for errors
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查错误
- en: 'The results of these functions are `Result` objects, which will be a common
    pattern in this library:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的结果是`Result`对象，这将是本库中常见的模式：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Checking errors and resetting state
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查错误和重置状态
- en: 'There are two simple utility functions available that reset state and check
    for errors. The code wraps the FFI functions in unsafe blocks and converts errors
    into `Result` values. The code is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个简单的实用函数可用于重置状态和检查错误。代码在`unsafe`块中包装FFI函数，并将错误转换为`Result`值。代码如下：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Privileged commands
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特权命令
- en: 'Privileged commands must be authorized before being called, otherwise the command
    will be denied. Errors are checked after each operation and a `Result` value is
    returned:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用之前必须授权特权命令，否则命令将被拒绝。每次操作后都会检查错误，并返回一个`Result`值：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Normal commands
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普通命令
- en: 'Normal commands do not require an authorized session to be called. Errors are
    checked after each call and a `Result` value is returned:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 普通命令不需要授权会话即可调用。每次调用后都会检查错误，并返回一个`Result`值：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Querying library and session state
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询库和会话状态
- en: 'Several functions that query the library and session state are available, mostly
    for debugging purposes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个查询库和会话状态的函数可用，主要用于调试目的：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inspecting the foreign library tests
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查外部库测试
- en: The previous team seemed very confident in the library subsystem that they developed;
    however, they found Rust code difficult to work with. The tests make this problem
    apparent. Two test sets seem to support the notion that the library works as intended,
    but the Rust components fail in edge cases. It will be your responsibility to
    pick up the pieces and salvage the project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的团队似乎非常自信于他们开发的库子系统；然而，他们发现Rust代码难以处理。测试使这个问题明显。两组测试似乎支持库按预期工作的观点，但Rust组件在边缘情况下失败。将责任交给你来收拾残局并挽救项目。
- en: 'Looking at the library tests in `src/tests/magic.rs`, the intended behavior
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`src/tests/magic.rs`中的库测试，预期行为如下：
- en: Override codes are issued to the subsystem through either elevator control panel
    or from the software directly
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖代码通过电梯控制面板或直接从软件发布到子系统
- en: Status information and authorization sessions are accessed through the `poll`
    functions
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`poll`函数访问状态信息和授权会话
- en: Authorization sessions must be freed before others can authorize
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他人可以授权之前，必须释放授权会话
- en: 'In override mode, privileged commands may be issued, such as:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在覆盖模式下，可以发布特权命令，例如：
- en: Change elevator to manual operation
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将电梯切换到手动操作
- en: Use elevator display panel to communicate
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电梯显示屏进行通信
- en: Privileged commands may not be issued without an active session
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有活跃会话，不得发布特权命令
- en: All library tests are passing, confirming the correct behavior of the library
    under the limited conditions tested. It should also be noted that the library
    is a bit obtuse in how it handles state, events, and sessions. These patterns
    are common in linked libraries, but to see the pattern, let's look at the resulting
    code in Rust.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有库测试均通过，确认库在有限测试条件下的正确行为。还应注意的是，库在处理状态、事件和会话方面有点晦涩。这些模式在链接库中很常见，但要看到这些模式，让我们看看Rust中产生的代码：
- en: Issuing override codes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布覆盖代码
- en: 'This set of tests for the FFI functions confirms that issued command codes
    are received by the library:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这组FFI函数测试确认发布的命令代码被库接收：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Accessing status information and sessions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问状态信息和会话
- en: 'These tests confirm that authorizing sessions and releasing sessions works
    correctly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试确认授权会话和释放会话工作正常：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Deactivating active sessions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使活跃会话失效
- en: 'Deactivating active sessions is an error that attempts to authorize two sessions
    simultaneously, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使活跃会话失效是一个尝试同时授权两个会话的错误，如下所示：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is also disallowed to call a free session on the same object twice. Calling
    deconstructors in foreign libraries multiple times is highly discouraged due to
    possible memory corruption:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同一对象上两次调用空闲会话也是不允许的。由于可能发生内存损坏，因此强烈反对在外国库中多次调用析构函数：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Issuing normal commands
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布普通命令
- en: 'Normal commands do not require authorization, so these tests just check that
    the commands are issued and received:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 普通命令不需要授权，因此这些测试只是检查命令是否发布和接收：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Issuing privileged commands
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布特权命令
- en: 'Privileged commands will be allowed if there is an active authorized session:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有活跃的授权会话，将允许发布特权命令：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Denying unauthorized commands
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝未经授权的命令
- en: 'Privileged commands will be denied if there is no active authorized session:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有活跃的授权会话，将拒绝特权命令：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inspecting the Rust tests
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Rust测试
- en: These tests in `src/tests/admin.rs` cover the high-level semantics defined in
    `src/admin.rs`. They cover mostly the same test cases as the lower level tests;
    however, some of these tests fail. To salvage the library, the library should
    be adjusted so that these tests will pass.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在`src/tests/admin.rs`中的测试涵盖了在`src/admin.rs`中定义的高级语义。它们覆盖了与低级测试大致相同的测试用例；然而，其中一些测试失败了。为了挽救库，应该调整库，以便这些测试能够通过。
- en: Rust authorization with sessions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用会话进行Rust授权
- en: 'Here are high-level tests covering the authentication and deactivation of sessions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些高级测试，涵盖了会话的认证和停用：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rust sharing session reference
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust会话引用共享
- en: 'The high-level library supports cloning sessions. Yikes! This could get complicated,
    but the tests are clear as to how it should work:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 高级库支持克隆会话。哎呀！这可能会变得复杂，但测试清楚地说明了它应该如何工作：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Privileged commands
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特权命令
- en: 'Privileged commands should be allowed if there is an active authorized session:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在活动的授权会话，则应允许特权命令：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unprivileged commands
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无权限命令
- en: 'Unprivileged commands should be allowed regardless of authentication:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 无权限命令应不受认证影响而允许：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Denying access to privileged commands
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拒绝访问特权命令
- en: 'Privileged commands should be denied if there is no authorized active session:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有授权的活跃会话，则应拒绝特权命令：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Learning the rules of ownership
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习所有权规则
- en: 'Rust has three rules of ownership:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有三个所有权规则：
- en: Each value in Rust has a variable that's called its **owner**
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust中的每个值都有一个称为其**所有者**的变量
- en: There can only be one owner at a time
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能有一个所有者
- en: When the owner goes out of scope, the value will be dropped
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，其值将被释放
- en: 'In the simplest case, we can define a block with a variable that goes out of
    scope at the end of the block:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，我们可以在块的末尾定义一个超出作用域的变量：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have brushed against the first two rules of ownership and lifetimes in previous
    chapters. However, this is the first chapter in which we have needed to work with
    the third rule—drop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中已经接触到了所有权和生命周期的前两条规则。然而，这是第一次我们需要与第三条规则——释放（drop）——打交道。
- en: When the owner goes out of scope, the value will be dropped
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，其值将被释放
- en: In the preceding code, we can see the simple case where a function block is
    an owner. When the function block exits, the variables are dropped. Ownership
    can also be transferred, so when a value is sent or returned to another block,
    that block will become the new owner. The remaining case is that ownership is
    transferred to an object. When a value is dropped, all children objects are automatically
    dropped as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到函数块作为所有者的简单情况。当函数块退出时，变量将被释放。所有权也可以转移，因此当值被发送或返回到另一个块时，该块将成为新的所有者。剩下的情况是所有权转移到对象。当值被释放时，所有子对象也会自动释放。
- en: 'In the current project, there are three tests failing, all related to the `.clone`
    method on sessions. The failing sessions look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前项目中，有三个测试失败，所有这些都与会话上的`.clone`方法有关。失败的会话看起来如下：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Removing the boilerplate, we can see that each of the three tests follows the
    same pattern:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 移除样板代码后，我们可以看到三个测试都遵循相同的模式：
- en: Open a new block
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的块
- en: Authorize a new session
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权新的会话
- en: Clone the new session
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆新的会话
- en: Confirm that session is authorized
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认会话已授权
- en: Close the block
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭块
- en: Confirm that session is not authorized
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认会话未授权
- en: Confirm that no errors occurred
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认没有发生错误
- en: 'All tests work correctly, other than generating errors that are checked at
    the end of the test. The error code indicates a double free of the session. By
    normal Rust ownership rules, we know that cloned sessions will each be dropped
    individually. This makes sense because `Drop` is implemented for each of the two `AuthorizedSession`
    structs in scope. If we look at the implementation of `Drop` then we can see that
    it naively just calls the foreign library, which will cause the double free error:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都正常工作，除了在测试结束时检查到的错误。错误代码指示会话发生了双重释放。根据正常的Rust所有权规则，我们知道克隆的会话将分别被释放。这很有道理，因为`Drop`为作用域内的两个`AuthorizedSession`结构体都实现了。如果我们查看`Drop`的实现，我们可以看到它只是天真地调用了外部库，这会导致双重释放错误：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Normally, Rust might complain about this careless resource management. However,
    the library uses an unsafe block to wrap the calls to the foreign function. Marking
    code as unsafe turns off many safety checks and encourages the compiler to trust
    the programmer. Calling foreign libraries is inherently unsafe, so this unsafe
    block is still necessary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Rust 可能会抱怨这种粗心的资源管理。然而，库使用一个不安全块来包装对外部函数的调用。将代码标记为不安全会关闭许多安全检查，并鼓励编译器信任程序员。调用外部库本质上是不可安全的，所以这个不安全块仍然是必要的。
- en: The correct behavior here seems to be to free the session only once after all
    cloned sessions have been dropped. This is a good case for `std::rc::Rc`, which
    stands for reference counted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的正确行为似乎是在所有克隆的会话都被释放后只释放会话一次。这是一个很好的 `std::rc::Rc` 用例，它代表引用计数。
- en: '`Rc` works by storing one owned value internal to itself. All owners of an
    `Rc` no longer hold direct ownership over the inner object of the reference counted container.
    To use the inner object, the borrower must ask to borrow a pointer to the inner
    object. Ownership of `Rc` objects will be counted, and when all references containing
    a given value are gone, the value will be dropped.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc` 通过在内部存储一个拥有的值来工作。`Rc` 的所有拥有者不再直接拥有引用计数容器内部的对象。要使用内部对象，借用人必须请求借用内部对象的指针。`Rc`
    对象的所有权将被计数，当所有包含给定值的引用都消失时，该值将被释放。'
- en: 'This built-in functionality provides exactly what we want. Clone multiple times,
    drop once, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内置功能正好提供了我们想要的功能。多次克隆，一次释放，如下所示：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To initialize sessions from raw pointers, we need to wrap them. Otherwise,
    no code needs to change:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从原始指针初始化会话，我们需要将它们包装起来。否则，不需要更改任何代码：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After these small changes, the three remaining tests pass. The library seems
    to be working. The big lesson to learn here is that `Drop` implementations can
    be very sensitive sometimes. Don't assume that multiple drops will be safe. To
    deal with complex situations, we have in the standard library the types `std::rc::Rc`
    and `std::sync::Arc`. `Arc` is a threadsafe version of `Rc`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些小的改动后，剩下的三个测试用例都通过了。看起来库似乎正在正常工作。这里要学到的重大教训是，`Drop` 实现有时可能非常敏感。不要假设多次释放会安全。为了处理复杂的情况，标准库中提供了
    `std::rc::Rc` 和 `std::sync::Arc` 类型。`Arc` 是 `Rc` 的线程安全版本。
- en: Using immutable data
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变数据
- en: After implementing and testing the library with real elevators, you find another
    bug—when someone physically keys into a session, sometimes they get deauthorized
    while still using the elevator. Sometimes is a terrible word to hear in a bug
    report.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用真实电梯实现和测试库之后，你发现另一个bug——当有人物理地进入一个会话时，有时他们在使用电梯的同时被取消授权。在bug报告中，“有时”这个词听起来很糟糕。
- en: Fixing the hard-to-reproduce bug
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复难以重现的bug
- en: 'After way too much searching and researching, you find a test case that reliably
    reproduces the problem:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 经过大量的搜索和研究后，你找到了一个可以可靠地重现问题的测试用例：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Looking at this test case, the first thing we might ask is, why should this
    be permitted?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这个测试用例，我们可能会问的第一个问题是，为什么应该允许这样做？
- en: The problem that we encountered during physical testing was characterized by
    the random deauthorization of valid sessions. What was discovered during investigations
    was that during physically authorized sessions, sometimes software authorized
    sessions would be initiated. A physical authorization is when someone uses a key
    on the elevator to use special commands. Software authorization is any other authorized
    session initiated from the running software, rather than from the elevator hardware.
    This double authorization action violated the double authorization constraint,
    so both sessions were invalidated. The resolution is clearly to permit the first
    authorized session to continue, while rejecting the second authorization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理测试中遇到的问题是由有效会话的随机取消授权所表征的。在调查中发现，在物理授权会话期间，有时会启动软件授权会话。物理授权是当有人使用电梯上的钥匙来使用特殊命令时。软件授权是从运行软件而不是从电梯硬件发起的任何其他授权会话。这个双重授权动作违反了双重授权约束，因此两个会话都被无效化。解决方案显然是允许第一个授权会话继续，同时拒绝第二次授权。
- en: The solution seems fairly direct and straightforward. From `src/admin.rs`, we
    have the ability to check whether any session is authorized from the library,
    then reject the second authorization without calling the library.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案看起来相当直接和简单。从 `src/admin.rs`，我们有能力检查是否有任何会话被授权，然后不调用库就拒绝第二次授权。
- en: 'So, rewriting the authorize commands, we add a check to see whether there is
    already an authorized session. If such a session exists, then this authorization
    fails:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在重写授权命令时，我们添加了一个检查来查看是否已经存在一个授权会话。如果存在这样的会话，则此授权失败：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This change fixes the immediate problem, but causes the double free tests to
    fail, because now there is no error code generated from the library after double
    free. We are essentially protecting the underlying library from double free responsibility,
    so this is a foreseeable consequence. The new tests just remove the last line
    that previously checked for the error code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改解决了立即的问题，但导致双重释放测试失败，因为现在在双重释放后库中没有生成错误代码。我们本质上是在保护底层库免受双重释放的责任，因此这是一个可预见的后果。新的测试只是移除了之前检查错误代码的最后一行：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Preventing hard-to-reproduce bugs
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止难以重现的bug
- en: Rust was specifically designed to avoid hard-to-reproduce bugs like this. Raw
    pointer handling is prevented or strongly discouraged in Rust. A raw pointer is
    like a reference that Rust knows nothing about, and therefore can provide no safety
    guarantees regarding its use. Unfortunately, this bug is internal to a foreign
    library, so our Rust project doesn't have jurisdiction to complain about the root
    problem here. Despite this, there are still good practices that we can follow
    to prevent or limit the occurrence of bugs related to mutation and strange side-effects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Rust被特别设计来避免这种难以重现的bug。在Rust中，原始指针的处理是被阻止或强烈劝阻的。原始指针就像Rust一无所知的引用，因此无法就其使用提供任何安全保证。不幸的是，这个bug是外部库内部的，因此我们的Rust项目没有管辖权来抱怨这里的根本问题。尽管如此，我们仍然可以遵循一些良好的实践来防止或限制与变异和奇怪的副作用相关的bug的发生。
- en: 'The first technique we will recommend is immutability. By default, all variables
    are declared as immutable. This is Rust''s way of not so subtly telling you to
    avoid mutating values if possible, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将推荐的第一个技术是不可变性。默认情况下，所有变量都被声明为不可变。这是Rust以一种不太微妙的方式告诉你，如果可能的话，要避免修改值，如下所示：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Immutable values cannot be borrowed as mutable (by design), so requiring mutability
    for a function parameter will require mutability from each value sent to it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变值不能作为可变借用（按设计），因此要求函数参数的可变性将需要从发送给它的每个值中获取可变性：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Turning an immutable value into a mutable one can be as simple as cloning it
    to create a new identical value; however, as we have seen throughout this chapter,
    the clone is not always a simple operation, an example is shown as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将不可变值转换为可变值可能就像克隆它以创建一个新相同值那样简单；然而，正如我们在本章中看到的，克隆并不总是简单操作，以下是一个示例：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Declaring a variable as immutable does not absolutely prevent all mutation,
    inside or out.  In Rust, immutable variables are permitted to hold interior fields
    with datatypes that are mutable. For example, `std::cell::RefCell` can be used
    to achieve interior mutability over whatever data it holds.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量声明为不可变并不能绝对防止所有变异，无论是内部还是外部。在Rust中，不可变变量允许持有可变数据类型的内部字段。例如，可以使用`std::cell::RefCell`在它持有的任何数据上实现内部可变性。
- en: Despite the exceptions, using immutable by default variables can help prevent
    simple bugs from becoming complex bugs. Don't let your programming style become
    a liability; practice defensive software development.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有例外，但默认使用不可变变量可以帮助防止简单bug变成复杂bug。不要让你的编程风格成为负担；练习防御性软件开发。
- en: Using pure functions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯函数
- en: 'Pure functions are the second technique that we recommend to prevent hard-to-reproduce
    bugs. Pure functions can be thought of as an extension of the avoid side-effects
    principle. The definition of a pure function is a function where the following
    is true:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是我们推荐的第二个技术，用于防止难以重现的bug。纯函数可以被视为避免副作用原则的扩展。纯函数的定义是一个函数，其中以下条件是真实的：
- en: No changes are caused outside of the function (no side-effects)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数外部没有引起任何变化（没有副作用）
- en: The return value does not depend on anything but the function parameters
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值只依赖于函数参数
- en: 'Here are some examples of pure functions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些纯函数的例子：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here are some examples of impure functions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不纯函数的例子：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Rust does not have any language feature that specifically designates a function
    as more or less pure. However, as the preceding examples illustrate, Rust somewhat
    discourages impure functions. Function purity should be regarded as a design pattern
    and is strongly associated with the good functional style.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Rust没有任何语言特性专门指定一个函数是更纯还是更不纯。然而，正如前面的例子所展示的，Rust在一定程度上不鼓励不纯函数。函数的纯度应该被视为一种设计模式，并且与良好的函数式风格紧密相关。
- en: Closures can also be pure or impure in the same fashion as top-level functions.
    As such, function purity becomes a concern when working with higher-level functions.
    Certain patterns of functional programming expect functions to be pure. A good
    example is the memoization pattern that we briefly mentioned in [Chapter 1](9221248a-8815-4394-8042-b2b5bb10cd5e.xhtml),
    *Functional Programming – a Comparison*. Let's compare what can happen to memoization
    if the memoized function is impure.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶级函数一样，闭包也可以是纯的或不纯的。因此，当与高级函数一起工作时，函数的纯度成为一个关注点。某些函数式编程模式期望函数是纯的。一个很好的例子是我们简要提到的[第1章](9221248a-8815-4394-8042-b2b5bb10cd5e.xhtml)中的记忆化模式——“函数式编程——比较”。让我们比较一下，如果记忆化的函数是不纯的，会发生什么。
- en: 'First, here is a reminder of how memoization is supposed to work:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个关于记忆化应该如何工作的提醒：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, let''s look at a memoized impure function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个记忆化的不纯函数：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This first cache example should return the same value every time. The second
    example should not return the same value every time. Semantically, we don't want
    the second example to return stale values; however, this also means that we cannot
    safely cache the results. There is a necessary performance trade-off. There is
    nothing wrong with the purity or impurity of either example here if it is necessary.
    It just means that the second example should not be cached.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个缓存示例应该每次都返回相同的值。第二个示例不应该每次都返回相同的值。从语义上讲，我们不希望第二个示例返回过时的值；然而，这也意味着我们无法安全地缓存结果。这里有一个必要的性能权衡。如果必要的话，这里两个示例的纯度或杂质都没有问题。这仅仅意味着第二个示例不应该被缓存。
- en: 'However, there are also anti-patterns of impurity. Let''s look at another impure
    function that behaves poorly:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在不纯的反模式。让我们看看另一个表现不佳的不纯函数：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, the data itself is impure. Every `tick_tock` moves and drops
    a `TimeBomb`. Eventually, it explodes and our cache doesn't help to protect us.
    Hopefully, you won't need to work with bombshells in your programs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数据本身是不纯的。每次`tick_tock`都会移动和丢弃一个`TimeBomb`。最终，它会爆炸，我们的缓存无法帮助我们保护。希望你在你的程序中不需要处理炸弹。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked with legacy code and foreign libraries in Rust. Rust
    safeguards can be annoying to learn and sometimes burdensome to work with, but
    the alternative of fast and loose coding is also stressful and problematic.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了Rust的遗留代码和外部库。Rust的安全保障可能难以学习，有时使用起来也很繁琐，但快速而松散的编码方式同样令人压力山大且问题重重。
- en: One of the motivations for Rust memory safety rules is the concept of double
    free memory, which we mentioned in this chapter. However, the code presented did
    not involve a real double free of memory. A real double free causes something
    known as undefined behavior. Undefined behavior is a term used in language standards
    to refer to operations that will cause the program to act strangely. Double freed
    memory is typically one of the worst types of undefined behavior, causing memory
    corruption and subsequent crashes or invalid states that are hard to trace back
    to the original cause.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Rust内存安全规则的一个动机是双重释放内存的概念，我们在本章中提到了这一点。然而，展示的代码并没有涉及真正的双重释放内存。真正的双重释放会导致称为未定义行为的现象。未定义行为是语言标准中用来指代会导致程序行为异常的操作的术语。双重释放的内存通常是未定义行为中最糟糕的类型之一，会导致内存损坏和随后的崩溃或难以追踪到原始原因的无效状态。
- en: In the latter half of the chapter, we examined specific Rust design decisions,
    features, and patterns such as ownership, immutability, and pure functions. These
    are Rust's defense mechanisms against undefined behavior and other ills.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们考察了特定的Rust设计决策、特性和模式，例如所有权、不可变性和纯函数。这些都是Rust对抗未定义行为和其他问题的防御机制。
- en: Using Rust safeguards correctly and not circumventing them has many benefits.
    Rust encourages a certain style of programming that benefits the design of larger
    projects. Typically, project architecture follows a more-than-linear bug/complexity
    curve. As a project grows in size, the number of bugs and difficult situations
    will grow at an even faster rate. By locking down common sources of bugs or code
    dependency, it is possible to develop large projects with fewer problems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用Rust的安全措施而不是规避它们有许多好处。Rust鼓励一种有利于大型项目设计的编程风格。通常，项目架构遵循一个超过线性的错误/复杂度曲线。随着项目规模的扩大，错误和困难情况将以更快的速度增长。通过锁定常见的错误来源或代码依赖，可以开发出问题更少的大型项目。
- en: In the next chapter, we will formally explain many functional design patterns.
    This will be a good opportunity to learn the extent to which functional programming
    principles apply and are relevant to Rust. If nothing in the next chapter seems
    cool or useful, then the author has failed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将正式解释许多功能设计模式。这将是一个学习函数式编程原则在Rust中应用程度和相关性很好的机会。如果下一章中没有什么看起来酷或有用，那么作者就失败了。
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does `Rc` stand for?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rc`代表什么？'
- en: What does `Arc` stand for?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Arc`代表什么？'
- en: What is a weak reference?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是弱引用？
- en: Which superpowers are enabled in unsafe blocks?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不安全块中启用了哪些超级能力？
- en: When will an object be dropped?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象何时会被丢弃？
- en: What is the difference between lifetimes and ownership?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生命周期和所有权的区别是什么？
- en: How can you be sure that a function is safe?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确保一个函数是安全的？
- en: What is memory corruption and how would it affect a program?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存损坏是什么，它会如何影响程序？
