- en: Mutability, Ownership, and Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust has introduced some new concepts of its own with respect to object ownership.
    These safeguards protect the developer from certain classes of errors, such as
    double free memory or hanging pointers, but also create constraints that can feel
    unmerited at times. Functional programming may help ease some of this conflict
    by encouraging the use of immutable data and pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at a case of ownership gone wrong. You will inherit
    code that has been abandoned as being too difficult to work with. Your job in
    this chapter will be to address the problems that the previous team were unable
    to overcome. To achieve this, you will need to use much of what you have learned
    so far, along with a gained understanding of the specific behaviors and constraints of
    ownership in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing anti-patterns of complex ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning specific rules of complex ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using immutable data to prevent anti-patterns of ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pure functions to prevent anti-patterns of ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A recent version of Rust is necessary to run the examples provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rust-lang.org/en-US/install.html](https://www.rust-lang.org/en-US/install.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code is also available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST](https://github.com/PacktPublishing/Hands-On-Functional-Programming-in-RUST)'
  prefs: []
  type: TYPE_NORMAL
- en: Specific installation and build instructions are also included in each chapter's
    `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing anti-patterns of ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the following situation.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have inherited legacy code. A previous team responsible
    for developing privileged access modules for elevators has been moved to a different
    project. They successfully developed code libraries to interface with a range
    of microcontrollers. However, while developing the access logic in Rust, they
    found object ownership to be very complicated and were unable to develop software
    that was compatible with Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Your task in this chapter will be to analyze their code, look for possible solutions,
    then create a library to support privileged access for your elevators. To clarify,
    privileged access refers to override codes and keys made available to emergency
    services such as police, firemen, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the microcontroller drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microcontroller drivers are written in other languages and exposed to Rust
    through the **foreign function interface** (**FFI**) feature. An FFI is a way
    of connecting Rust code to libraries written in other languages. The following
    are the symbols defined in the foreign library and bindings in `src/magic.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function issues an override code to the library and subsystem, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When an override code is entered, it will be exposed through this function.
    The higher layers should interpret what the override codes mean to potentially
    enter emergency operation modes or other maintenance functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When an override mode has been established and the emergency service worker
    enters a floor, this method will be called. Floor requests from emergency modes
    should take precedence over normal `elevator` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Error codes occurring from the `override` operation will be exposed through
    this function. Issues such as invalid override codes will be presented for higher
    layers to decide how to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If an override code is entered, an authorized override session will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After an override session is complete, it should be freed to release resources
    and reset state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If a physical key access is initiated to an elevator, then this method will
    expose the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a physical key access is initiated by an administrator, then this method
    will expose the result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will force the elevator into manual operation mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will force the elevator into normal operation mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will reset the elevator state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will perform a timed flashing pattern of lights on the elevator
    control panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will toggle the light for a button or other symbol on the elevator
    control panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will alter the display color of a light on the elevator control
    panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the type and trait definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust type and trait definitions left behind were primarily intended to wrap
    the library interfaces. Let's look quickly through the symbols defined in `src/admin.rs`
    to familiarize ourselves with how the library was intended to work.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the OverrideCode enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `OverrideCode` enum gives typesafe definitions and names to the different
    override codes from the linked library. This code associates named enum values
    with the numerical enumerated values returned or sent to the FFI. Notice the syntax
    pattern assigning integer values to each enum element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Defining the ErrorCode enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to `OverrideCode`, the `ErrorCode` enum defines typesafe labels for
    each of the library error codes. There is also a helper function to cast integers
    into the enum type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Defining the AuthorizedSession struct and deconstructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AuthorizedSession` struct wraps a session pointer from the library. This
    struct also implements the `Drop` trait, which is called when the object goes
    out of scope. The `free_override_session` call here is very important and should
    be noted as a potential source of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Authorizing sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To authorize a session, there are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Authorize the session
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Poll and retrieve the session object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The results of these functions are `Result` objects, which will be a common
    pattern in this library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Checking errors and resetting state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two simple utility functions available that reset state and check
    for errors. The code wraps the FFI functions in unsafe blocks and converts errors
    into `Result` values. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Privileged commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Privileged commands must be authorized before being called, otherwise the command
    will be denied. Errors are checked after each operation and a `Result` value is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Normal commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normal commands do not require an authorized session to be called. Errors are
    checked after each call and a `Result` value is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Querying library and session state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several functions that query the library and session state are available, mostly
    for debugging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the foreign library tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous team seemed very confident in the library subsystem that they developed;
    however, they found Rust code difficult to work with. The tests make this problem
    apparent. Two test sets seem to support the notion that the library works as intended,
    but the Rust components fail in edge cases. It will be your responsibility to
    pick up the pieces and salvage the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the library tests in `src/tests/magic.rs`, the intended behavior
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Override codes are issued to the subsystem through either elevator control panel
    or from the software directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status information and authorization sessions are accessed through the `poll`
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization sessions must be freed before others can authorize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In override mode, privileged commands may be issued, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change elevator to manual operation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use elevator display panel to communicate
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Privileged commands may not be issued without an active session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All library tests are passing, confirming the correct behavior of the library
    under the limited conditions tested. It should also be noted that the library
    is a bit obtuse in how it handles state, events, and sessions. These patterns
    are common in linked libraries, but to see the pattern, let's look at the resulting
    code in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing override codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This set of tests for the FFI functions confirms that issued command codes
    are received by the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Accessing status information and sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These tests confirm that authorizing sessions and releasing sessions works
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Deactivating active sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deactivating active sessions is an error that attempts to authorize two sessions
    simultaneously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also disallowed to call a free session on the same object twice. Calling
    deconstructors in foreign libraries multiple times is highly discouraged due to
    possible memory corruption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Issuing normal commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normal commands do not require authorization, so these tests just check that
    the commands are issued and received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Issuing privileged commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Privileged commands will be allowed if there is an active authorized session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Denying unauthorized commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Privileged commands will be denied if there is no active authorized session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the Rust tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These tests in `src/tests/admin.rs` cover the high-level semantics defined in
    `src/admin.rs`. They cover mostly the same test cases as the lower level tests;
    however, some of these tests fail. To salvage the library, the library should
    be adjusted so that these tests will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Rust authorization with sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are high-level tests covering the authentication and deactivation of sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Rust sharing session reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The high-level library supports cloning sessions. Yikes! This could get complicated,
    but the tests are clear as to how it should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Privileged commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Privileged commands should be allowed if there is an active authorized session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Unprivileged commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unprivileged commands should be allowed regardless of authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Denying access to privileged commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Privileged commands should be denied if there is no authorized active session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Learning the rules of ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust has three rules of ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: Each value in Rust has a variable that's called its **owner**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can only be one owner at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the owner goes out of scope, the value will be dropped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the simplest case, we can define a block with a variable that goes out of
    scope at the end of the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have brushed against the first two rules of ownership and lifetimes in previous
    chapters. However, this is the first chapter in which we have needed to work with
    the third rule—drop.
  prefs: []
  type: TYPE_NORMAL
- en: When the owner goes out of scope, the value will be dropped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding code, we can see the simple case where a function block is
    an owner. When the function block exits, the variables are dropped. Ownership
    can also be transferred, so when a value is sent or returned to another block,
    that block will become the new owner. The remaining case is that ownership is
    transferred to an object. When a value is dropped, all children objects are automatically
    dropped as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current project, there are three tests failing, all related to the `.clone`
    method on sessions. The failing sessions look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing the boilerplate, we can see that each of the three tests follows the
    same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new block
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorize a new session
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone the new session
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that session is authorized
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the block
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that session is not authorized
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that no errors occurred
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All tests work correctly, other than generating errors that are checked at
    the end of the test. The error code indicates a double free of the session. By
    normal Rust ownership rules, we know that cloned sessions will each be dropped
    individually. This makes sense because `Drop` is implemented for each of the two `AuthorizedSession`
    structs in scope. If we look at the implementation of `Drop` then we can see that
    it naively just calls the foreign library, which will cause the double free error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Normally, Rust might complain about this careless resource management. However,
    the library uses an unsafe block to wrap the calls to the foreign function. Marking
    code as unsafe turns off many safety checks and encourages the compiler to trust
    the programmer. Calling foreign libraries is inherently unsafe, so this unsafe
    block is still necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The correct behavior here seems to be to free the session only once after all
    cloned sessions have been dropped. This is a good case for `std::rc::Rc`, which
    stands for reference counted.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rc` works by storing one owned value internal to itself. All owners of an
    `Rc` no longer hold direct ownership over the inner object of the reference counted container.
    To use the inner object, the borrower must ask to borrow a pointer to the inner
    object. Ownership of `Rc` objects will be counted, and when all references containing
    a given value are gone, the value will be dropped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This built-in functionality provides exactly what we want. Clone multiple times,
    drop once, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize sessions from raw pointers, we need to wrap them. Otherwise,
    no code needs to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After these small changes, the three remaining tests pass. The library seems
    to be working. The big lesson to learn here is that `Drop` implementations can
    be very sensitive sometimes. Don't assume that multiple drops will be safe. To
    deal with complex situations, we have in the standard library the types `std::rc::Rc`
    and `std::sync::Arc`. `Arc` is a threadsafe version of `Rc`.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After implementing and testing the library with real elevators, you find another
    bug—when someone physically keys into a session, sometimes they get deauthorized
    while still using the elevator. Sometimes is a terrible word to hear in a bug
    report.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the hard-to-reproduce bug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After way too much searching and researching, you find a test case that reliably
    reproduces the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this test case, the first thing we might ask is, why should this
    be permitted?
  prefs: []
  type: TYPE_NORMAL
- en: The problem that we encountered during physical testing was characterized by
    the random deauthorization of valid sessions. What was discovered during investigations
    was that during physically authorized sessions, sometimes software authorized
    sessions would be initiated. A physical authorization is when someone uses a key
    on the elevator to use special commands. Software authorization is any other authorized
    session initiated from the running software, rather than from the elevator hardware.
    This double authorization action violated the double authorization constraint,
    so both sessions were invalidated. The resolution is clearly to permit the first
    authorized session to continue, while rejecting the second authorization.
  prefs: []
  type: TYPE_NORMAL
- en: The solution seems fairly direct and straightforward. From `src/admin.rs`, we
    have the ability to check whether any session is authorized from the library,
    then reject the second authorization without calling the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, rewriting the authorize commands, we add a check to see whether there is
    already an authorized session. If such a session exists, then this authorization
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This change fixes the immediate problem, but causes the double free tests to
    fail, because now there is no error code generated from the library after double
    free. We are essentially protecting the underlying library from double free responsibility,
    so this is a foreseeable consequence. The new tests just remove the last line
    that previously checked for the error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Preventing hard-to-reproduce bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust was specifically designed to avoid hard-to-reproduce bugs like this. Raw
    pointer handling is prevented or strongly discouraged in Rust. A raw pointer is
    like a reference that Rust knows nothing about, and therefore can provide no safety
    guarantees regarding its use. Unfortunately, this bug is internal to a foreign
    library, so our Rust project doesn't have jurisdiction to complain about the root
    problem here. Despite this, there are still good practices that we can follow
    to prevent or limit the occurrence of bugs related to mutation and strange side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first technique we will recommend is immutability. By default, all variables
    are declared as immutable. This is Rust''s way of not so subtly telling you to
    avoid mutating values if possible, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Immutable values cannot be borrowed as mutable (by design), so requiring mutability
    for a function parameter will require mutability from each value sent to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning an immutable value into a mutable one can be as simple as cloning it
    to create a new identical value; however, as we have seen throughout this chapter,
    the clone is not always a simple operation, an example is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Declaring a variable as immutable does not absolutely prevent all mutation,
    inside or out.  In Rust, immutable variables are permitted to hold interior fields
    with datatypes that are mutable. For example, `std::cell::RefCell` can be used
    to achieve interior mutability over whatever data it holds.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the exceptions, using immutable by default variables can help prevent
    simple bugs from becoming complex bugs. Don't let your programming style become
    a liability; practice defensive software development.
  prefs: []
  type: TYPE_NORMAL
- en: Using pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pure functions are the second technique that we recommend to prevent hard-to-reproduce
    bugs. Pure functions can be thought of as an extension of the avoid side-effects
    principle. The definition of a pure function is a function where the following
    is true:'
  prefs: []
  type: TYPE_NORMAL
- en: No changes are caused outside of the function (no side-effects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value does not depend on anything but the function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of pure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of impure functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Rust does not have any language feature that specifically designates a function
    as more or less pure. However, as the preceding examples illustrate, Rust somewhat
    discourages impure functions. Function purity should be regarded as a design pattern
    and is strongly associated with the good functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Closures can also be pure or impure in the same fashion as top-level functions.
    As such, function purity becomes a concern when working with higher-level functions.
    Certain patterns of functional programming expect functions to be pure. A good
    example is the memoization pattern that we briefly mentioned in [Chapter 1](9221248a-8815-4394-8042-b2b5bb10cd5e.xhtml),
    *Functional Programming – a Comparison*. Let's compare what can happen to memoization
    if the memoized function is impure.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is a reminder of how memoization is supposed to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at a memoized impure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This first cache example should return the same value every time. The second
    example should not return the same value every time. Semantically, we don't want
    the second example to return stale values; however, this also means that we cannot
    safely cache the results. There is a necessary performance trade-off. There is
    nothing wrong with the purity or impurity of either example here if it is necessary.
    It just means that the second example should not be cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are also anti-patterns of impurity. Let''s look at another impure
    function that behaves poorly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the data itself is impure. Every `tick_tock` moves and drops
    a `TimeBomb`. Eventually, it explodes and our cache doesn't help to protect us.
    Hopefully, you won't need to work with bombshells in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with legacy code and foreign libraries in Rust. Rust
    safeguards can be annoying to learn and sometimes burdensome to work with, but
    the alternative of fast and loose coding is also stressful and problematic.
  prefs: []
  type: TYPE_NORMAL
- en: One of the motivations for Rust memory safety rules is the concept of double
    free memory, which we mentioned in this chapter. However, the code presented did
    not involve a real double free of memory. A real double free causes something
    known as undefined behavior. Undefined behavior is a term used in language standards
    to refer to operations that will cause the program to act strangely. Double freed
    memory is typically one of the worst types of undefined behavior, causing memory
    corruption and subsequent crashes or invalid states that are hard to trace back
    to the original cause.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter half of the chapter, we examined specific Rust design decisions,
    features, and patterns such as ownership, immutability, and pure functions. These
    are Rust's defense mechanisms against undefined behavior and other ills.
  prefs: []
  type: TYPE_NORMAL
- en: Using Rust safeguards correctly and not circumventing them has many benefits.
    Rust encourages a certain style of programming that benefits the design of larger
    projects. Typically, project architecture follows a more-than-linear bug/complexity
    curve. As a project grows in size, the number of bugs and difficult situations
    will grow at an even faster rate. By locking down common sources of bugs or code
    dependency, it is possible to develop large projects with fewer problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will formally explain many functional design patterns.
    This will be a good opportunity to learn the extent to which functional programming
    principles apply and are relevant to Rust. If nothing in the next chapter seems
    cool or useful, then the author has failed.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does `Rc` stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `Arc` stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a weak reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which superpowers are enabled in unsafe blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When will an object be dropped?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between lifetimes and ownership?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you be sure that a function is safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is memory corruption and how would it affect a program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
