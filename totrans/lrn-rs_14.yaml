- en: Foreign Function Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that Rust is a language primarily designed to work on servers and most
    libraries sitting on a server aren't written in Rust (yet!), it makes sense that
    Rust applications should be able to utilize libraries written in other languages.
    In this chapter, we will be examining how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how we can utilize other libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the pitfalls of using code written in another language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring, as far as is practicable, that our code will remain safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with previous chapters, the source code will be available for you to examine.
    You will also find a small library written in C to compile for Windows, macOS,
    and Linux. The library doesn't do very much but gives you an understanding of
    how the system works. Other libraries (such as `ImageMagick`) work in exactly
    the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a start!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our simple library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Libraries come in three flavors: `.dll` (dynamic linkable library) for Windows,
    `.so` (shared object), and `.a`—`.a` and `.so` are typically found on Unix type
    systems (including macOS).'
  prefs: []
  type: TYPE_NORMAL
- en: Our library is very simple; it acts as a calculation library—you pass in the
    values to the correct function and the result is returned. Not rocket science
    but enough to prove what we're going to do.
  prefs: []
  type: TYPE_NORMAL
- en: When using external libraries, we will need to use the `unsafe` directive. Rust
    cannot control what an external library delivers and therefore if we used standard
    code, the compiler will not allow compilation.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, using external libraries must be handled with care.
  prefs: []
  type: TYPE_NORMAL
- en: The three-step program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are essentially three steps to using a library within your Rust application:'
  prefs: []
  type: TYPE_NORMAL
- en: Including the dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing code that uses the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building your application to link to the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most difficult stage is the second as it requires writing code, call back
    code, and other such wrappers to use the library.
  prefs: []
  type: TYPE_NORMAL
- en: Including the dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with using any library not provided by `Prelude`, the compiler has to know
    of the existence of the library. As we did in [Chapter 8](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Rust Application Lifetime*, we let the compiler know to expect an external
    library by including in the `Cargo.toml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The figure in quotes is the library version. This is useful to have in as it
    enables the compiled Rust application to only run against a particular version
    of the library, which guarantees the code required will be in the library. The
    downside is that in order to always ensure the library is available, the compiled
    binary will need to ship with that library. In this case (and this is the case
    for most external libraries), `libc` will need to be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include the following line to the source file where the functions
    will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this part is in `Chapter 14/firstexample`.
  prefs: []
  type: TYPE_NORMAL
- en: When we are dealing with code from outside our application, we need to be able
    to tell the compiler something akin to "*Hey look, build this code and just leave
    a hook to something that may or may not exist and that may or may not take these
    parameters but that will return something hopefully.*" It's like handing a blank
    check to a fraudster with your signature on and hoping they won't write something
    in and cash it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, we do this by using the link directive and enclosing the function
    in an `extern` block. The code inside the `extern` calls the function held within
    the library. It must be the same as the name of the function within the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is then accessed using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What's the [link(name="")] for?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a directive that tells the compiler that the code is going to link to
    a library called whatever is inside the quotes. You don't need the likes of `mathlib.dll`,  `mathlib.so`,
    or  `mathlib.a` inside the quotes, just the name without the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different types of link (called models and defined in the `kind`
    parameter following the name) available: *dynamic*, *static,* and *framework*
    (though the latter is for macOS only). The following table gives a summary of
    what they are for. For the majority of the time, the `dynamic` type is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Example** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic | `[link(name="foo")]` | This is the default. The compiled binary
    creates *hooks* that will link into the platform installed form of the library.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static | `[link(name="foo", kind="static")]` | These are `.a` files. When
    the application is built, the binary is created, but the platform library file
    is not required to be distributed. |'
  prefs: []
  type: TYPE_TB
- en: '| Framework | `[link(name="foo", kind="framework")]` | macOS only. This will
    be the `.dylib` file and is treated the same as a dynamic library. |'
  prefs: []
  type: TYPE_TB
- en: What's the big deal? That was simple enough!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While on the face of it, using an external library via FFI is not rocket science,
    it does come with a number of issues. Why do we need to annotate blocks with unsafe
    even when we are referring to known names in libraries?
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen time and again with Rust, the compiler does an awful lot for
    the developer that you won't see in many other compilers. It ensures thread safety,
    that a particular operation can be achieved, the buffers don't overrun, that we
    don't leave memory unallocated or attempt to deallocate twice, and plenty of other
    things that ensure that, as far as possible, the code we have will run and remain
    rock-solid (in terms of reliability).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, with external libraries, all the compiler can do is to expect
    something from a linked library. Threads may be left hanging or be plain unsafe;
    there is no guarantee that if I passed in 6 and 0 for a similar division function,
    what is returned is a number and pretty much anything else can go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: By using `unsafe`, we give the compiler a promise that when it links the code,
    what it links to will be bound correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's extend things a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `extern` block can include as many (or as few) of the methods required from
    the library the Rust application is using.
  prefs: []
  type: TYPE_NORMAL
- en: With each new function added to the `extern` block, it is always a good idea
    to test the function being included. This can be done as either unit tests or
    by adding the function to the `extern` block and then calling that function from
    within `main`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also have multiple Rust source files that include the library functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, make the changes in the `Source1.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make changes in the `Source2.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As long as the link line is included, this won't cause an issue.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the types don't match?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no guarantee that when you build a library on a 32-bit platform, an
    `int` will have the same `size_t` as an `int` on a 64-bit platform. They usually
    will, but there is no guarantee. A simple example is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, a short can be the same size as a long! More usually, though, `int`
    will be the platform word size (32 bits on a 32-bit processor, 64 bits on a 64-bit
    processor).
  prefs: []
  type: TYPE_NORMAL
- en: Values for floats are stricter and comply with the IEEE 754 standards.
  prefs: []
  type: TYPE_NORMAL
- en: There is not normally an issue if the Rust application is built on a 64-bit
    platform and the library is 32 bits. If it is the other way around, however,there
    is a chance that an overflow may occur. It is unlikely, but worth keeping in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Can we make things safer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a strategy that we can take to try and make things slightly safer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider our original `extern` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code is calling a raw C API and, as discussed, any calls to this have to
    be marked as being `unsafe`. It is unsafe as the call is known as being **low
    level**.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of programming languages, the lower the language, the closer it is
    to being a language understood by the processor (an assembler is considered the
    lowest language that is of any real use, short of poking raw binary into a memory
    location). Here we are exposing the library at its lowest level.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the call safer, we use something known as **wrapping**.
  prefs: []
  type: TYPE_NORMAL
- en: Wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wrappers are very common when using a library designed for another language.
    They work by exposing a higher-level function name that *hides* the true method
    working underneath. The exposed function name is commonly known as the library
    interface API. By only exposing the higher-level function name, Rust is able to
    keep the unsafe part away from the rest of the world.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the methods in the library takes a vector of `int` values to perform
    a mean, median, and mode calculation, which in turn returns an array of `float`
    values containing these values. However, we need to validate the values first
    (essentially, test the array is not empty) and that there are five or more values.
    This will return a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unsafe version of the code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a wrapper for this quite simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We expose the safe function to the code and hide (wrap) the unsafe part. Once
    we have a value of true returned, we know the data is safe to have the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is a pretty pointless piece of code (it is simply a test to ensure
    we have the right number of parameters in the vector). Let's modify this wrapper
    so that we return a `Vec<f32>`, which will  contain `-999f`, `-999f`, or `-999f`
    if the check fails, or mean, median and mode of the values of the vector.
  prefs: []
  type: TYPE_NORMAL
- en: The issue though is that the original library is in C, so we need to get the
    results as an array and then put that into a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is making the first check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not only do we now have a single call to the external library, but we also have
    guarantees the compiler needs.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite frequently within a C library, there will be global variables that are
    used for such things as version details and build-specific code. Rust can access
    these in a similar way to other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up after yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the maths library is a very simple example, there may be times when you
    need to use a library that passes back a large block of data (such as you would
    expect if you created a wrapper to work with `ImageMagick`—a commonly used and
    extremely capable graphics library). When the library returns, the results are
    passed off to the Rust application, which you will need to deallocate manually.
  prefs: []
  type: TYPE_NORMAL
- en: To help you with this, Rust provides the `Drop` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Drop it!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Drop` trait is a very simple trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As with all traits, it requires an `impl` for it before the trait can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we call our `pub fn`, which returns a data block from `ImageMagick`.
    Once we have done what we need to do with that memory block, we have to free it.
    We stored the data in a variable called `graphics_block`. To free the block from
    `graphics_block`, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The memory is freed once `graphics_block` goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that `panic!` will call `drop` as it unwinds the memory.
    If you therefore have a `panic!` within a `drop`, chances are that it is going
    to abort.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring an external process within an FFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During your time using a computer, you will have no doubt seen an image like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: These progress bars work in a similar way to each other. Say you have a process
    that has five equal sized portions or you're downloading a file from the internet.
    As the portion completes or an amount of code is downloaded, the bar and percentage
    are updated using a programming technique known as a **callback**.
  prefs: []
  type: TYPE_NORMAL
- en: How a callback is implemented depends on the language being used. For example,
    in an event-driven language, the process will either emit a signal or generate
    an event that the receiver listens for. When the signal/event is received, the
    user interface is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Rust is no different; it is able to use a callback when using an FFI. Rust is
    capable of working with both synchronous and asynchronous callbacks. It is also
    possible to target a callback to a Rust object.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting synchronous callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronous callbacks are the simplest to target, as they are normally always
    on the same thread. Therefore, we don't have to deal with the code being more
    unsafe than usual, which is normally the case with asynchronous callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this part is in `Chapter 14/synccallback`. Instructions for building
    on Linux, macOS, and Windows are included in the source examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deal with the Rust side of the code first. Here, we have three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for the callback itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The calls to the external code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Fire off the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`register_callback(my_callback)` and `fn register_callback(call: extern fn(i32))
    ->→ i32;` may look strange at first glance. In a normal function call, the parameters
    within the braces are passed into the receiving function, which then does something
    with them.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are passing a function as the parameter, which we really can't do (or
    at least shouldn't). Callbacks though are different, as the function is by virtue
    of the `extern` modifier counted as a pointer that takes the returned value from
    the external library as its own parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting a Rust object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last example, we had a callback that listened for a single `int`. What
    happens though if we want to listen out for a complex object from the external
    library (for example, a structure)? We can't return a structure, but we can have
    a Rust object that can be mapped to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a slightly more complex affair than for a synchronous callback:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the structure that will map to the external structure we''re interested
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the callback; `result` is a pointer to the mutable `myobject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `extern` functions to the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Calling Rust from another language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust can also be called from a different language and it's a simple process.
    The only caveat is that the name used has to be unmangled. If you recall from
    [Chapter 8](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d), *The Rust
    Application Lifetime*, when you use a generic, the compiler generates the necessary
    code to ensure the linker works. It does this by mangling the names to ensure
    that the correct code is compiled and called when the code needs it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unmangling is the opposite of this; it preserves the name of the function in
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This can then be called from within your own (non-Rust) application.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the unknown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C developers don't always pass parameters between functions that have *strong*
    types; rather, they pass a `void*` type. This is then cast to be something solid
    within the receiving function. In a way, this is very similar to passing a generic
    type between functions.
  prefs: []
  type: TYPE_NORMAL
- en: These have to be dealt with in a different way if you want to access a function
    within a library that has a `void*` as a parameter type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the C functions may be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we don''t have anything in Rust the same as `void*`, we need to use a mutable
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will do the job.
  prefs: []
  type: TYPE_NORMAL
- en: C structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we used a `struct` as a parameter. In C, there is
    nothing to stop the developer passing a structure as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`MyStruct` and `MyOtherStruct` are known as opaque structs. The name is exposed,
    but the private parts aren''t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling a `struct` within Rust is not as simple as you''d first think, but
    then it''s not that difficult either. The only difference is that we use an empty
    `enum` instead of a `struct` when interfacing with the C library. This creates
    our opaque type that stores the information from the C opaque type. As the `enum`
    is empty, we can''t instantiate it and, more importantly, as `MyStruct` and `MyOtherStruct`
    aren''t the same, we have type-safety and so can''t get them mixed up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered something in this chapter that not only makes Rust an excellent
    choice for developing applications with, but by using libraries that aren't Rust
    ones, also makes it a flexible and powerful language. There are pitfalls (such
    as needing to use unsafe and having to be very careful with panic! code), but
    there are far more advantages than downfalls.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this text, `.dll` is purely for Windows. The .NET Framework
    also uses `.dll` files that, if they don't include anything Windows-specific,
    can also be used on macOS and Linux.
  prefs: []
  type: TYPE_NORMAL
