- en: Foreign Function Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that Rust is a language primarily designed to work on servers and most
    libraries sitting on a server aren't written in Rust (yet!), it makes sense that
    Rust applications should be able to utilize libraries written in other languages.
    In this chapter, we will be examining how to do this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Learning how we can utilize other libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the pitfalls of using code written in another language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring, as far as is practicable, that our code will remain safe
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with previous chapters, the source code will be available for you to examine.
    You will also find a small library written in C to compile for Windows, macOS,
    and Linux. The library doesn't do very much but gives you an understanding of
    how the system works. Other libraries (such as `ImageMagick`) work in exactly
    the same way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a start!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our simple library
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Libraries come in three flavors: `.dll` (dynamic linkable library) for Windows,
    `.so` (shared object), and `.a`—`.a` and `.so` are typically found on Unix type
    systems (including macOS).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Our library is very simple; it acts as a calculation library—you pass in the
    values to the correct function and the result is returned. Not rocket science
    but enough to prove what we're going to do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: When using external libraries, we will need to use the `unsafe` directive. Rust
    cannot control what an external library delivers and therefore if we used standard
    code, the compiler will not allow compilation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: As developers, using external libraries must be handled with care.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The three-step program
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are essentially three steps to using a library within your Rust application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Including the dependency.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing code that uses the library.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building your application to link to the library.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most difficult stage is the second as it requires writing code, call back
    code, and other such wrappers to use the library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Including the dependency
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with using any library not provided by `Prelude`, the compiler has to know
    of the existence of the library. As we did in [Chapter 8](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d),
    *The Rust Application Lifetime*, we let the compiler know to expect an external
    library by including in the `Cargo.toml` file, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The figure in quotes is the library version. This is useful to have in as it
    enables the compiled Rust application to only run against a particular version
    of the library, which guarantees the code required will be in the library. The
    downside is that in order to always ensure the library is available, the compiled
    binary will need to ship with that library. In this case (and this is the case
    for most external libraries), `libc` will need to be added.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to include the following line to the source file where the functions
    will be called:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating the code
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this part is in `Chapter 14/firstexample`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: When we are dealing with code from outside our application, we need to be able
    to tell the compiler something akin to "*Hey look, build this code and just leave
    a hook to something that may or may not exist and that may or may not take these
    parameters but that will return something hopefully.*" It's like handing a blank
    check to a fraudster with your signature on and hoping they won't write something
    in and cash it!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理来自我们应用程序外部的代码时，我们需要能够告诉编译器类似“嘿，看看，构建这段代码，并留下一个钩子，这个钩子可能存在也可能不存在，可能需要也可能不需要这些参数，但希望它能返回一些东西。”这就像给了拿着你签名支票的骗子一张空白支票，希望他们不会在上面填写并兑现！
- en: 'In Rust, we do this by using the link directive and enclosing the function
    in an `extern` block. The code inside the `extern` calls the function held within
    the library. It must be the same as the name of the function within the library:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们通过使用链接指令并将函数放在`extern`块中来做到这一点。`extern`块内的代码调用库中持有的函数。它必须与库中函数的名称相同：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is then accessed using the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用以下方式访问此代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What's the [link(name="")] for?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[链接](name="")]的作用是什么？'
- en: This is a directive that tells the compiler that the code is going to link to
    a library called whatever is inside the quotes. You don't need the likes of `mathlib.dll`,  `mathlib.so`,
    or  `mathlib.a` inside the quotes, just the name without the extension.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指令，告诉编译器代码将要链接到一个名为引号内内容的库。你不需要在引号内使用`mathlib.dll`、`mathlib.so`或`mathlib.a`这样的名称，只需要没有扩展名的名称。
- en: 'There are three different types of link (called models and defined in the `kind`
    parameter following the name) available: *dynamic*, *static,* and *framework*
    (though the latter is for macOS only). The following table gives a summary of
    what they are for. For the majority of the time, the `dynamic` type is used.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的三种不同类型的链接（称为模型，并在名称后的`kind`参数中定义）包括：*动态*、*静态*和*框架*（尽管后者仅适用于macOS）。下表总结了它们各自的作用。在大多数情况下，使用的是`动态`类型。
- en: '| **Type** | **Example** | **Notes** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **示例** | **注意事项** |'
- en: '| Dynamic | `[link(name="foo")]` | This is the default. The compiled binary
    creates *hooks* that will link into the platform installed form of the library.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 动态 | `[link(name="foo")]` | 这是默认选项。编译的二进制文件会创建*钩子*，这些钩子将链接到平台安装的库版本。 |'
- en: '| Static | `[link(name="foo", kind="static")]` | These are `.a` files. When
    the application is built, the binary is created, but the platform library file
    is not required to be distributed. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 静态 | `[link(name="foo", kind="static")]` | 这些是`.a`文件。当应用程序构建时，会创建二进制文件，但平台库文件不需要分发。
    |'
- en: '| Framework | `[link(name="foo", kind="framework")]` | macOS only. This will
    be the `.dylib` file and is treated the same as a dynamic library. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | `[link(name="foo", kind="framework")]` | 仅限macOS。这将是一个`.dylib`文件，其处理方式与动态库相同。
    |'
- en: What's the big deal? That was simple enough!
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那有什么大不了的？这很简单！
- en: While on the face of it, using an external library via FFI is not rocket science,
    it does come with a number of issues. Why do we need to annotate blocks with unsafe
    even when we are referring to known names in libraries?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上使用外部库通过FFI并不是什么难事，但它确实带来了一系列问题。为什么即使我们引用库中的已知名称，我们还需要在块上使用`unsafe`注释？
- en: As we have seen time and again with Rust, the compiler does an awful lot for
    the developer that you won't see in many other compilers. It ensures thread safety,
    that a particular operation can be achieved, the buffers don't overrun, that we
    don't leave memory unallocated or attempt to deallocate twice, and plenty of other
    things that ensure that, as far as possible, the code we have will run and remain
    rock-solid (in terms of reliability).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们一次又一次地看到的那样，与Rust相比，编译器为开发者做了很多工作，这在许多其他编译器中是看不到的。它确保线程安全，特定操作可以完成，缓冲区不会溢出，我们不会留下未分配的内存或尝试两次释放内存，以及许多其他确保我们的代码尽可能运行并保持稳定（从可靠性角度）的事情。
- en: Unfortunately, with external libraries, all the compiler can do is to expect
    something from a linked library. Threads may be left hanging or be plain unsafe;
    there is no guarantee that if I passed in 6 and 0 for a similar division function,
    what is returned is a number and pretty much anything else can go wrong.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于外部库，编译器所能做的只是期望从链接库中得到一些东西。线程可能会挂起或是不安全；没有保证，如果我传递了6和0给一个类似的除法函数，返回的将是一个数字，而且几乎任何其他事情都可能出错。
- en: By using `unsafe`, we give the compiler a promise that when it links the code,
    what it links to will be bound correctly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`unsafe`，我们向编译器承诺，当它链接代码时，它链接到的将正确绑定。
- en: Let's extend things a bit
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们扩展一下内容
- en: The `extern` block can include as many (or as few) of the methods required from
    the library the Rust application is using.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern` 块可以包含Rust应用程序使用的库所需的方法（或方法数量）。'
- en: With each new function added to the `extern` block, it is always a good idea
    to test the function being included. This can be done as either unit tests or
    by adding the function to the `extern` block and then calling that function from
    within `main`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每当向 `extern` 块添加新函数时，测试被包含的函数总是一个好主意。这可以通过单元测试或通过将函数添加到 `extern` 块并在 `main`
    中调用该函数来实现。
- en: We can also have multiple Rust source files that include the library functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以有多个包含库函数的Rust源文件。
- en: 'For example, make the changes in the `Source1.rs` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `Source1.rs` 文件中进行修改：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, make changes in the `Source2.rs` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `Source2.rs` 文件中进行修改：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As long as the link line is included, this won't cause an issue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 只要包含链接行，这就不会引起问题。
- en: What happens if the types don't match?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果类型不匹配会发生什么？
- en: 'There is no guarantee that when you build a library on a 32-bit platform, an
    `int` will have the same `size_t` as an `int` on a 64-bit platform. They usually
    will, but there is no guarantee. A simple example is this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在32位平台上构建库时，不能保证 `int` 的大小与64位平台上的 `int` 的大小相同。它们通常会是相同的，但并不能保证。一个简单的例子如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Therefore, a short can be the same size as a long! More usually, though, `int`
    will be the platform word size (32 bits on a 32-bit processor, 64 bits on a 64-bit
    processor).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，短整型可以与长整型大小相同！然而，更常见的情况是，`int` 将是平台字大小（在32位处理器上为32位，在64位处理器上为64位）。
- en: Values for floats are stricter and comply with the IEEE 754 standards.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的值更为严格，并符合IEEE 754标准。
- en: There is not normally an issue if the Rust application is built on a 64-bit
    platform and the library is 32 bits. If it is the other way around, however,there
    is a chance that an overflow may occur. It is unlikely, but worth keeping in mind.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Rust应用程序是在64位平台上构建的，而库是32位的，通常不会有问题。然而，如果情况相反，则可能发生溢出的情况。这种情况不太可能发生，但值得注意。
- en: Can we make things safer?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们能否使事情更安全？
- en: There is a strategy that we can take to try and make things slightly safer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取一种策略来尝试使事情稍微安全一些。
- en: 'Consider our original `extern` code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的原始 `extern` 代码：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code is calling a raw C API and, as discussed, any calls to this have to
    be marked as being `unsafe`. It is unsafe as the call is known as being **low
    level**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在调用原始C API，正如讨论的那样，任何对此的调用都必须标记为 `unsafe`。这是不安全的，因为调用被认为是 **低级** 的。
- en: In terms of programming languages, the lower the language, the closer it is
    to being a language understood by the processor (an assembler is considered the
    lowest language that is of any real use, short of poking raw binary into a memory
    location). Here we are exposing the library at its lowest level.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言方面，语言越低级，它就越接近处理器理解的语言（汇编器被认为是实际有用的最低级语言，除非直接将原始二进制代码插入内存位置）。在这里，我们正在以最低级别暴露库。
- en: In order to make the call safer, we use something known as **wrapping**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使调用更安全，我们使用了一种称为 **包装** 的方法。
- en: Wrappers
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装器
- en: Wrappers are very common when using a library designed for another language.
    They work by exposing a higher-level function name that *hides* the true method
    working underneath. The exposed function name is commonly known as the library
    interface API. By only exposing the higher-level function name, Rust is able to
    keep the unsafe part away from the rest of the world.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用为其他语言设计的库时，包装器非常常见。它们通过暴露一个高级函数名来隐藏下面的真正方法。这个暴露的函数名通常被称为库接口API。通过仅暴露高级函数名，Rust能够将不安全的部分与其他部分隔离开来。
- en: A practical example
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际例子
- en: One of the methods in the library takes a vector of `int` values to perform
    a mean, median, and mode calculation, which in turn returns an array of `float`
    values containing these values. However, we need to validate the values first
    (essentially, test the array is not empty) and that there are five or more values.
    This will return a boolean.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 库中的一个方法接受一个 `int` 值的向量来执行平均值、中位数和众数计算，然后返回一个包含这些值的 `float` 值数组。然而，我们需要首先验证这些值（本质上，测试数组不为空）并且有五个或更多的值。这将返回一个布尔值。
- en: 'The unsafe version of the code would be:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的不安全版本将是：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can create a wrapper for this quite simply:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常简单地为此创建一个包装器：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We expose the safe function to the code and hide (wrap) the unsafe part. Once
    we have a value of true returned, we know the data is safe to have the calculation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安全函数暴露给代码，并隐藏（包装）不安全的部分。一旦我们返回一个true值，我们就知道数据可以进行计算。
- en: Now, this is a pretty pointless piece of code (it is simply a test to ensure
    we have the right number of parameters in the vector). Let's modify this wrapper
    so that we return a `Vec<f32>`, which will  contain `-999f`, `-999f`, or `-999f`
    if the check fails, or mean, median and mode of the values of the vector.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一段相当无意义的代码（它只是一个测试，以确保我们在向量中有正确的参数数量）。让我们修改这个包装器，使其返回一个`Vec<f32>`，它将包含`-999f`、`-999f`或`-999f`，如果检查失败，或者包含向量的平均值、中位数和众数。
- en: The issue though is that the original library is in C, so we need to get the
    results as an array and then put that into a vector.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题是原始库是用C编写的，所以我们需要将结果作为数组获取，然后将其放入向量中。
- en: 'The first part is making the first check:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是进行第一次检查：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not only do we now have a single call to the external library, but we also have
    guarantees the compiler needs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们现在只有一个对外部库的调用，我们还保证了编译器所需的保证。
- en: Accessing global variables
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问全局变量
- en: 'Quite frequently within a C library, there will be global variables that are
    used for such things as version details and build-specific code. Rust can access
    these in a similar way to other variables:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在C库中，经常会有用于版本细节和特定构建代码等用途的全局变量。Rust可以以与其他变量类似的方式访问这些变量：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Cleaning up after yourself
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己清理
- en: While the maths library is a very simple example, there may be times when you
    need to use a library that passes back a large block of data (such as you would
    expect if you created a wrapper to work with `ImageMagick`—a commonly used and
    extremely capable graphics library). When the library returns, the results are
    passed off to the Rust application, which you will need to deallocate manually.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数学库是一个非常简单的例子，但有时你可能需要使用返回大量数据块的库（例如，如果你创建了一个用于与`ImageMagick`（一个常用且功能强大的图形库）一起工作的包装器）。当库返回时，结果会被传递给Rust应用程序，你需要手动释放。
- en: To help you with this, Rust provides the `Drop` trait.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你，Rust提供了`Drop`特质。
- en: Drop it!
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丢弃它！
- en: 'The `Drop` trait is a very simple trait:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drop`特质是一个非常简单的特质：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As with all traits, it requires an `impl` for it before the trait can be used:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有特质一样，在使用特质之前，它需要一个`impl`：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, we call our `pub fn`, which returns a data block from `ImageMagick`.
    Once we have done what we need to do with that memory block, we have to free it.
    We stored the data in a variable called `graphics_block`. To free the block from
    `graphics_block`, we use:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们调用我们的`pub fn`，它从`ImageMagick`返回一个数据块。一旦我们用完那个内存块，我们必须释放它。我们将在一个名为`graphics_block`的变量中存储数据。要释放`graphics_block`中的块，我们使用：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The memory is freed once `graphics_block` goes out of scope.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当`graphics_block`超出作用域时，内存将被释放。
- en: It is worth pointing out that `panic!` will call `drop` as it unwinds the memory.
    If you therefore have a `panic!` within a `drop`, chances are that it is going
    to abort.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，`panic!`在回滚内存时会调用`drop`。因此，如果你在`drop`中有`panic!`，那么它很可能会中止。
- en: Monitoring an external process within an FFI
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在FFI中监控外部进程
- en: 'During your time using a computer, you will have no doubt seen an image like
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用计算机的时间里，你无疑会看到以下这样的图像：
- en: '![](img/00101.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: These progress bars work in a similar way to each other. Say you have a process
    that has five equal sized portions or you're downloading a file from the internet.
    As the portion completes or an amount of code is downloaded, the bar and percentage
    are updated using a programming technique known as a **callback**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进度条以类似的方式工作。比如说，你有一个有五个相等部分的进程，或者你正在从互联网下载文件。随着部分完成或下载的代码量增加，条形图和百分比会使用一种称为**回调**的编程技术更新。
- en: How a callback is implemented depends on the language being used. For example,
    in an event-driven language, the process will either emit a signal or generate
    an event that the receiver listens for. When the signal/event is received, the
    user interface is updated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的实现方式取决于所使用的语言。例如，在事件驱动的语言中，进程将发出信号或生成接收者监听的事件。当接收到信号/事件时，用户界面会更新。
- en: Rust is no different; it is able to use a callback when using an FFI. Rust is
    capable of working with both synchronous and asynchronous callbacks. It is also
    possible to target a callback to a Rust object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有不同；它能够在使用 FFI 时使用回调。Rust 能够处理同步和异步回调。还可以将回调定位到 Rust 对象。
- en: Targeting synchronous callbacks
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位同步回调
- en: Synchronous callbacks are the simplest to target, as they are normally always
    on the same thread. Therefore, we don't have to deal with the code being more
    unsafe than usual, which is normally the case with asynchronous callbacks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同步回调是最容易定位的，因为它们通常总是在同一个线程上。因此，我们不必处理代码比平时更不安全的情况，这在异步回调中通常是常见的情况。
- en: The code for this part is in `Chapter 14/synccallback`. Instructions for building
    on Linux, macOS, and Windows are included in the source examples.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的代码在 `Chapter 14/synccallback` 中。Linux、macOS 和 Windows 的构建说明包含在源示例中。
- en: 'Let''s deal with the Rust side of the code first. Here, we have three parts:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理 Rust 代码的这一部分。在这里，我们有三个部分：
- en: 'The function for the callback itself:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调函数本身：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The calls to the external code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用外部代码：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Fire off the code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动代码：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`register_callback(my_callback)` and `fn register_callback(call: extern fn(i32))
    ->→ i32;` may look strange at first glance. In a normal function call, the parameters
    within the braces are passed into the receiving function, which then does something
    with them.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`register_callback(my_callback)` 和 `fn register_callback(call: extern fn(i32))
    ->→ i32;` 在第一眼看起来可能很奇怪。在正常的函数调用中，花括号内的参数被传递到接收函数中，然后接收函数对它们进行处理。'
- en: Here, we are passing a function as the parameter, which we really can't do (or
    at least shouldn't). Callbacks though are different, as the function is by virtue
    of the `extern` modifier counted as a pointer that takes the returned value from
    the external library as its own parameter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将一个函数作为参数传递，这实际上是不可以做的（或者至少不应该）。然而，回调是不同的，因为函数由于 `extern` 修饰符的存在，被视为一个指针，它将外部库返回的值作为自己的参数。
- en: Targeting a Rust object
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位 Rust 对象
- en: In the last example, we had a callback that listened for a single `int`. What
    happens though if we want to listen out for a complex object from the external
    library (for example, a structure)? We can't return a structure, but we can have
    a Rust object that can be mapped to the callback.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们有一个监听单个 `int` 的回调。但是，如果我们想监听外部库中的复杂对象（例如，一个结构体）会发生什么呢？我们不能返回一个结构体，但我们可以有一个可以映射到回调的
    Rust 对象。
- en: 'It is a slightly more complex affair than for a synchronous callback:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这比同步回调稍微复杂一些：
- en: 'Create the structure that will map to the external structure we''re interested
    in:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将映射到我们感兴趣的外部结构体的结构体：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the callback; `result` is a pointer to the mutable `myobject`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建回调；`result` 是指向可变 `myobject` 的指针：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `extern` functions to the library:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建库的 `extern` 函数：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the calling code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建调用代码：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Calling Rust from another language
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从其他语言调用 Rust
- en: Rust can also be called from a different language and it's a simple process.
    The only caveat is that the name used has to be unmangled. If you recall from
    [Chapter 8](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d), *The Rust
    Application Lifetime*, when you use a generic, the compiler generates the necessary
    code to ensure the linker works. It does this by mangling the names to ensure
    that the correct code is compiled and called when the code needs it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 也可以从其他语言中被调用，这是一个简单的过程。唯一的限制是使用的名称必须是未解析的。如果你还记得 [第 8 章](part0175.html#56SIE0-a5175cb437d742a9aed0ea574000ee2d)，“Rust
    应用程序生命周期”，当你使用泛型时，编译器会生成必要的代码以确保链接器正常工作。它是通过混淆名称来做到这一点的，以确保在需要时编译和调用正确的代码。
- en: 'Unmangling is the opposite of this; it preserves the name of the function in
    use:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 解析（Unmangling）是相反的过程；它保留正在使用的函数的名称：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This can then be called from within your own (non-Rust) application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以从你自己的（非 Rust）应用程序中调用。
- en: Dealing with the unknown
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理未知情况
- en: C developers don't always pass parameters between functions that have *strong*
    types; rather, they pass a `void*` type. This is then cast to be something solid
    within the receiving function. In a way, this is very similar to passing a generic
    type between functions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C 开发者并不总是在具有 *强类型* 的函数之间传递参数；相反，他们传递 `void*` 类型。然后在接收函数中将其转换为某种具体类型。从某种意义上说，这与在函数之间传递泛型类型非常相似。
- en: These have to be dealt with in a different way if you want to access a function
    within a library that has a `void*` as a parameter type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问一个以 `void*` 作为参数类型的库中的函数，这些必须以不同的方式处理。
- en: 'For example, the C functions may be:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C 函数可能是：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we don''t have anything in Rust the same as `void*`, we need to use a mutable
    pointer:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Rust 中没有与 `void*` 相同的东西，我们需要使用一个可变指针：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will do the job.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完成这项工作。
- en: C structs
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 结构体
- en: 'Earlier in this chapter, we used a `struct` as a parameter. In C, there is
    nothing to stop the developer passing a structure as a parameter:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们使用 `struct` 作为参数。在 C 中，没有阻止开发者将结构体作为参数传递：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MyStruct` and `MyOtherStruct` are known as opaque structs. The name is exposed,
    but the private parts aren''t.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyStruct` 和 `MyOtherStruct` 被称为不透明结构体。名称是公开的，但私有部分不是。'
- en: 'Handling a `struct` within Rust is not as simple as you''d first think, but
    then it''s not that difficult either. The only difference is that we use an empty
    `enum` instead of a `struct` when interfacing with the C library. This creates
    our opaque type that stores the information from the C opaque type. As the `enum`
    is empty, we can''t instantiate it and, more importantly, as `MyStruct` and `MyOtherStruct`
    aren''t the same, we have type-safety and so can''t get them mixed up:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中处理 `struct` 并不像你最初想象的那么简单，但也不是那么困难。唯一的区别是我们在与 C 库接口时使用一个空的 `enum` 而不是
    `struct`。这创建了一个不透明的类型，用于存储来自 C 不透明类型的信息。由于 `enum` 是空的，我们无法实例化它，更重要的是，由于 `MyStruct`
    和 `MyOtherStruct` 并不相同，我们有了类型安全，因此不能将它们混淆：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered something in this chapter that not only makes Rust an excellent
    choice for developing applications with, but by using libraries that aren't Rust
    ones, also makes it a flexible and powerful language. There are pitfalls (such
    as needing to use unsafe and having to be very careful with panic! code), but
    there are far more advantages than downfalls.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍的内容不仅使 Rust 成为开发应用的优秀选择，而且通过使用非 Rust 库，也使其成为一种灵活且强大的语言。存在一些陷阱（例如需要使用
    unsafe 和必须非常小心处理 panic! 代码），但优点远多于缺点。
- en: For the purposes of this text, `.dll` is purely for Windows. The .NET Framework
    also uses `.dll` files that, if they don't include anything Windows-specific,
    can also be used on macOS and Linux.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本文的用途，`.dll` 仅用于 Windows。.NET 框架也使用 `.dll` 文件，如果它们不包含任何特定于 Windows 的内容，也可以在
    macOS 和 Linux 上使用。
