<html><head></head><body>
		<div id="_idContainer114">
			<h1 id="_idParaDest-134"><em class="italic"><a id="_idTextAnchor203"/>Chapter 9</em>: Testing, Debugging, and Performance</h1>
			<p>In this book, we've built an entire game using two tools to test our logic – that is, a compiler and our eyes. If the game doesn't compile, it's broken, and if <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) doesn't look right, it's broken – simple enough. Fortunately, the compiler provides a lot of tools to make sure we don't make mistakes. Let's be honest, though – it's not enough.</p>
			<p>Developing a game can be a long process, especially if you're a hobbyist. When you only have 4 hours to work on it in a given week, they can't all be spent fighting the same bug. To ensure our game works, we need to test it, find mistakes, and make sure it's not too slow. That's what we're going to be doing here.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating automated tests</li>
				<li>Debugging the game</li>
				<li>Measuring performance with the browser</li>
			</ul>
			<p>After completing this chapter, you'll be able to fix the bugs we've written so far and make sure they don't happen again.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor204"/>Technical requirements</h1>
			<p>In this chapter, we'll use the Chrome developer tools to debug the code and monitor performance. Other browsers also ship with robust developer tools, but for the screenshots and directions in this chapter, we'll be using Chrome.</p>
			<p>The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3NKppLk">https://bit.ly/3NKppLk</a></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor205"/>Creating automated tests</h1>
			<p>In an <a id="_idIndexMarker793"/>ideal world, every system would have a large amount of testing, both automated and manual, that's done by developers and QA. Some ways to test your game is working correctly involve doing the following:</p>
			<ul>
				<li>Using types to prevent programmer errors</li>
				<li>Playing the game yourself</li>
				<li>Performing automated unit tests</li>
				<li>Performing automated integration tests</li>
			</ul>
			<p>So far, we've only used the first two, which is an unfortunately common approach in real-world code. This can be suitable for personal or hobby projects but it isn't robust enough for production applications, particularly those written by a team. </p>
			<p>Almost any application can benefit from automated, programmer-written unit tests and as a program becomes even larger, it begins to benefit from integration tests as well. There's not a consistent definition of the differences between these two types of tests as you tend to know them when you see them, but fortunately, we can use the Rust definitions. Rust and Cargo provide two kinds of testing:</p>
			<ul>
				<li>Unit tests via <strong class="source-inline">cargo test</strong></li>
				<li>Integration tests via <strong class="source-inline">wasm-pack test</strong></li>
			</ul>
			<p>Unit tests<a id="_idIndexMarker794"/> tend<a id="_idIndexMarker795"/> to be programmer-centric. They are written at the method or function level, with minimal dependencies. You may have a test for every branch of an <strong class="source-inline">if/else</strong> statement, while in the case of a loop, you may have tests for when a list has 0, 1, or many entries. These tests are small and fast and should run in seconds or less. These are my preferred form of testing.</p>
			<p>Integration tests <a id="_idIndexMarker796"/>tend to look at the app at a higher level. In <a id="_idIndexMarker797"/>the case of our code, the integration tests automate the browser and will work based on an event (such as a mouse click) throughout the program. These tests take longer to write, are harder to maintain, and often fail for mysterious reasons. So, why write them? Unit tests typically do not test parts of your application or they may only do so in small doses. This can lead to a situation where your unit tests all pass but the game doesn't work. Most systems will have fewer integration tests than unit tests because of their disadvantages, but they will need them for their benefits.</p>
			<p>In Rust, unit tests <a id="_idIndexMarker798"/>are <a id="_idIndexMarker799"/>written <a id="_idIndexMarker800"/>side by side with a module and run with <strong class="source-inline">cargo test</strong>. In our setup, they will run as part of a Rust executable, running directly on the machine. Integration tests are<a id="_idIndexMarker801"/> stored in the <strong class="source-inline">tests</strong> directory and only have access to things your crate makes public. They run in the browser – potentially a headless one – with <strong class="source-inline">wasm-pack test</strong>. Unit tests can test <a id="_idIndexMarker802"/>internal methods directly, while integration tests must use your crate as a real program would.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Ham Vocke has a very detailed<a id="_idIndexMarker803"/> article on the <em class="italic">Test Pyramid</em> that describes one way to organize all of your tests in a system: <a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor206"/>Test-driven development</h2>
			<p>I have a<a id="_idIndexMarker804"/> confession to make. I usually write all my code in a test-driven style, where you write a test then make it fail for each <a id="_idIndexMarker805"/>step in the development process. Had we followed that process during the development of this book, we'd likely have quite a few tests – perhaps more than 100. In addition, <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) exerts a lot of pressure on the design that tends to lead to more loosely coupled code. So, why didn't we do this?</p>
			<p>Well, TDD has its downsides, with perhaps the largest being we'd generate a lot more code in the form of tests. We've already written a <em class="italic">lot</em> of code in this book, so imagine trying to follow along with the tests too – you can see why I felt it was best to leave out the kind of testing I normally write. <em class="italic">Test-Driven Rust</em> isn't the title of this book after all. However, just because we didn't write tests first doesn't mean we don't want to be sure our code works. That's why, in many cases, we used the type system as the first line of defense against mistakes, such as using the typestate pattern for state transitions. The type system is one of the advantages of using Rust instead of JavaScript for this game.</p>
			<p>This isn't to say that automated testing cannot provide value for our program. The Rust ecosystem places a high value on testing, so much so that a testing framework is built into Cargo and is automatically set up for any Rust program. With unit tests, we can test algorithms such as collision detection or our famous state machines. We can make sure that the game still does what we expect, although we can't test whether a game is fun or pretty. For that, you'll have to play the game until you hate it, but a game is a lot more fun if the basics work. We can use tests, along with types, to ensure the code works as expected so<a id="_idIndexMarker806"/> that we can turn our focus to <a id="_idIndexMarker807"/>whether or not it's fun. To do that, we'll need to set up the test runner and then write some tests that run outside of the browser and inside the browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're interested in <a id="_idIndexMarker808"/>TDD, Kent Beck's book <em class="italic">Test-Driven Development By Example</em> is still an excellent resource (<a href="https://amzn.to/3o1R663">https://amzn.to/3o1R663</a>). For a web-based approach that uses TypeScript <a id="_idIndexMarker809"/>and React, you can take a look at an excellent book called <em class="italic">Build Your Own Spreadsheet</em> at <a href="https://buildyourownspreadsheet.com/">https://buildyourowns<span id="_idTextAnchor207"/>preadsheet.com/</a>.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor208"/>Getting started</h2>
			<p>As we <a id="_idIndexMarker810"/>mentioned <a id="_idIndexMarker811"/>earlier, Rust has built-in capabilities for running tests – both unit and integration. Unfortunately, the template we used way back in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, still has an out-of-date setup at the time of writing. If it hasn't been fixed, running <strong class="source-inline">cargo test</strong> at the command prompt will fail to compile, let <a id="_idIndexMarker812"/>alone run the tests. Fortunately, there are not a lot of mistakes. There's just some out-of-date <strong class="source-inline">async</strong> code for a browser test we won't be using in the automatically generated tests. Those tests are in the <strong class="source-inline">tests</strong> directory in the <strong class="source-inline">app.rs</strong> file. This is traditionally where integration tests are put in Cargo projects. We'll change that setup shortly by using unit tests, but first, let's get this to compile by deleting the incorrect <strong class="source-inline">async_test</strong> setup test. In <strong class="source-inline">app.rs</strong>, you can delete that function and the  <strong class="source-inline">#[wasm_bindgen_test(async)]</strong> macro above it so that your <strong class="source-inline">app.rs</strong> file looks like this:</p>
			<p class="source-code">use futures::prelude::*;</p>
			<p class="source-code">use wasm_bindgen::JsValue; </p>
			<p class="source-code">use wasm_bindgen_futures::JsFuture;</p>
			<p class="source-code">use wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};</p>
			<p class="source-code">wasm_bindgen_test_configure!(run_in_browser);</p>
			<p class="source-code">// This runs a unit test in native Rust, so it can only use Rust APIs.</p>
			<p class="source-code">#[test]</p>
			<p class="source-code">fn rust_test() {</p>
			<p class="source-code">    assert_eq!(1, 1);</p>
			<p class="source-code">}</p>
			<p class="source-code">// This runs a unit test in the browser, so it can use browser APIs.</p>
			<p class="source-code">#[wasm_bindgen_test]</p>
			<p class="source-code">fn web_test() {</p>
			<p class="source-code">    assert_eq!(1, 1);</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout">After this book has been published, the template will be fixed and will likely compile. I'm going to assume this, regardless of you changing the code, so that it matches what is here going forward. </p>
			<p>Some of the <strong class="source-inline">use</strong> declarations aren't needed anymore, but they will be short so you can leave them in and ignore the warnings. Now, <strong class="source-inline">app.rs</strong> contains two tests – one that will run in a JavaScript <a id="_idIndexMarker813"/>environment, such as the browser, and one that will run as a native Rust test. Both of these are just examples, where <strong class="source-inline">1</strong> is still equal to <strong class="source-inline">1</strong>. To run <a id="_idIndexMarker814"/>the native Rust tests, you can run <strong class="source-inline">cargo test</strong>, as you might be accustomed to. That will run the <strong class="source-inline">rust_test</strong> function, which is annotated with the <strong class="source-inline">test</strong> macro. You can run the browser-based tests, which are annotated with the <strong class="source-inline">wasm_bindgen_test</strong> macro, via the <strong class="source-inline">wasm-pack test --headless --chrome</strong> command. This will run the web tests using the Chrome browser, in a headless environment. You can also use <strong class="source-inline">--firefox</strong>, <strong class="source-inline">--safari</strong>, and <strong class="source-inline">--node</strong> if you wish, but you must <a id="_idIndexMarker815"/>specify what JavaScript environment you'll be running them in. Note that <strong class="source-inline">--node</strong> isn't going to work since it doesn't have a browser.</p>
			<p>We'll start writing tests using the <strong class="source-inline">#[test]</strong> macro, which runs Rust code in the native environment, just like writing a standard Rust program. The simplest thing to test is a pure functi<a id="_idTextAnchor209"/>on, so let's try that.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor210"/>Pure functions</h2>
			<p><strong class="bold">Pure</strong> functions are <a id="_idIndexMarker816"/>functions that, given the same input, will always produce the same output, without side effects such as drawing to the screen or accessing the network. They are <a id="_idIndexMarker817"/>analogous to mathematical functions, which just do a calculation, and are by far the easiest types of code to unit test. These tests do not require the browser, so they use the <strong class="source-inline">#[test]</strong> annotation and run with <strong class="source-inline">cargo test</strong>.</p>
			<p>The current setup runs our only Rust test in the <strong class="source-inline">test/app.rs</strong> file, which makes it, as far as Cargo is concerned, an integration test. I don't like that and prefer to use the Rust convention of writing unit tests in the file where the code is executed. In this first example, we'll test the <strong class="source-inline">intersects</strong> function on <strong class="source-inline">Rect</strong>, which is a pure function that is complicated enough to mess up. We'll add this test to the bottom of <strong class="source-inline">engine.rs</strong> because that's where <strong class="source-inline">Rect</strong> is defined, and we'll run it with <strong class="source-inline">cargo test</strong>. Let's add a test to the bottom of the module for the <strong class="source-inline">intersect</strong> method on <strong class="source-inline">Rect</strong>, as shown here:</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">mod tests {</p>
			<p class="source-code">    use super::*;</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn two_rects_that_intersect_on_the_left() {</p>
			<p class="source-code">        let rect1 = Rect {</p>
			<p class="source-code">            position: Point { x: 10, y: 10 },</p>
			<p class="source-code">            height: 100,</p>
			<p class="source-code">            width: 100,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        let rect2 = Rect {</p>
			<p class="source-code">            position: Point { x: 0, y: 10 },</p>
			<p class="source-code">            height: 100,</p>
			<p class="source-code">            width: 100,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        assert_eq!(rect2.intersects(&amp;rect1), true);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Much of this<a id="_idIndexMarker818"/> is documented in the Rust book at <a href="https://bit.ly/3bNBH3H">https://bit.ly/3bNBH3H</a>, but a little review never hurts anyone. We start by using the <strong class="source-inline">#[cfg(test)]</strong> attribute macro to tell Cargo not to compile and run this code except <a id="_idIndexMarker819"/>when we're running tests. Then, we create a <strong class="source-inline">tests</strong> module using the <strong class="source-inline">mod</strong> keyword to isolate our tests from the rest of the code. After that, we import the <strong class="source-inline">engine</strong> code with <strong class="source-inline">use super::*</strong>. Then, we write our test by writing a function, <strong class="source-inline">two_rects_that_intersect_on_the_left</strong>, which is annotated with the <strong class="source-inline">#[test]</strong> macro so that the test runner can pick it up. The rest of this is a pretty standard test. It creates two rectangles, where the second overlaps the first, and then makes sure that the <strong class="source-inline">intersects</strong> function returns <strong class="source-inline">true</strong>. You can run this test with <strong class="source-inline">cargo test</strong>, where you'll see the following output:</p>
			<p class="source-code">    Finished test [unoptimized + debuginfo] target(s) in 1.48s</p>
			<p class="source-code">     Running target/debug/deps/rust_webpack_template-5805000a6d5d52b4</p>
			<p class="source-code">running 1 test</p>
			<p class="source-code"><strong class="bold">test engine::tests::two_rects_that_intersect_on_the_left</strong> ... ok</p>
			<p class="source-code">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</p>
			<p class="source-code">     Running target/debug/deps/app-ec65f178e238b04b</p>
			<p class="source-code">running 1 test</p>
			<p class="source-code">test rust_test ... ok</p>
			<p class="source-code">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</p>
			<p>You'll see two <a id="_idIndexMarker820"/>sets of results. The first result <a id="_idIndexMarker821"/>references our new test, <strong class="source-inline">two_rects_that_intersect_on_the_left</strong>, which will pass. Then, you will see <strong class="source-inline">rust_test</strong> run, which will also pass. The <strong class="source-inline">rust_test</strong> test is in <strong class="source-inline">tests\app.rs</strong> and was created with the project skeleton. It is run as an integration test because it is in the <strong class="source-inline">tests</strong> directory – this is the Cargo standard. The difference between unit tests and integration tests is that the integration tests are run as a separate crate and use the production code as a separate library. This means they use the code in the same way a user of your crate would, but they cannot call internal or private functions. It's easier to get complete coverage when you're running unit tests with the caveat that they may be less realistic. Our code is not meant to be used as a crate, so we won't be using many integration tests.</p>
			<p>Now that we've written<a id="_idIndexMarker822"/> our first unit test for our code, we can write a lot more tests for this <strong class="source-inline">intersects</strong> method, including when the following occurs:</p>
			<ul>
				<li>When the rectangles overlap on the top or bottom</li>
				<li>When the rectangles overlap on the right</li>
				<li>When the rectangles <em class="italic">don't</em> overlap – that is, when the function returns false</li>
			</ul>
			<p>We should <a id="_idIndexMarker823"/>have a test for every branch in the <strong class="source-inline">intersects</strong> function. We leave these tests as an exercise for you since repeating them would be redundant. As our code base grows, it would be ideal if much of our code could easily be tested like this, but unfortunately, for this game, a lot of it interacts with the browser, so we will have two different ways to test that. The first way is to replace the browser with a stub so that we don't need to run browser-based tests. We'l<a id="_idTextAnchor211"/>l do that in the next section.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor212"/>Hiding the Browser module</h2>
			<p>Way back in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, we separated browser functions into a <strong class="source-inline">browser</strong> module. We can use this as a <strong class="bold">seam</strong> to inject test versions of the browser functions that <a id="_idIndexMarker824"/>will run as native Rust code and <a id="_idIndexMarker825"/>allow us to write tests.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The<a id="_idIndexMarker826"/> term <strong class="bold">seam</strong> comes from the book <em class="italic">Working Effectively with Legacy Code</em>, by Michael Feathers (<a href="https://amzn.to/3kas1Fa">https://amzn.to/3kas1Fa</a>). It's written in C++ and Java but is still the best book on legacy code you can find. A seam is a place where you can insert test behavior to replace real behavior, while <a id="_idIndexMarker827"/>an <strong class="bold">enabling point</strong> is a point in the code that allows that to happen.</p>
			<p>A seam is somewhere we can alter the behavior of the program without altering the code in that place. Look at the following code from the <strong class="source-inline">game</strong> module:</p>
			<p class="source-code">impl WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">        browser::hide_ui();</p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Ready,</p>
			<p class="source-code">            walk: Walk::reset(self.walk),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We'd like to<a id="_idIndexMarker828"/> test that when the game goes from the <strong class="source-inline">GameOver</strong> state to the <strong class="source-inline">Ready</strong> state, the UI is hidden. We can do this with integration tests by checking whether the <strong class="source-inline">div</strong> property <a id="_idIndexMarker829"/>that contains the UI is empty after this transition. We may want to do this, but such tests are frequently a little harder to write and maintain. This is especially true as the game grows. Another approach, which we'll use here, is to replace the <strong class="source-inline">browser</strong> module with a version of it that doesn't interact with the browser. The seam is <strong class="source-inline">hide_ui</strong>, which is a behavior we can replace without actually changing the code, while the enabling point is the <strong class="source-inline">use</strong> declaration, which is where we brought in the <strong class="source-inline">browser</strong> module.</p>
			<p>We can enable using a test version of the <strong class="source-inline">browser</strong> module with conditional compilation. In the same way that the <strong class="source-inline">#[cfg(test)]</strong> macro only includes the <strong class="source-inline">test</strong> module when compiling in test mode, we can import different versions of the <strong class="source-inline">browser</strong> module with <strong class="source-inline">cfg</strong> directives, as shown here:</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">mod test_browser;</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">use test_browser as browser;</p>
			<p class="source-code">#[cfg(not(test))]</p>
			<p class="source-code">use crate::browser;</p>
			<p>The preceding code <a id="_idIndexMarker830"/>can be found at the top of the <strong class="source-inline">game</strong> module, where we were previously<a id="_idIndexMarker831"/> importing <strong class="source-inline">crate::browser</strong>. Here, we can use the <strong class="source-inline">mod</strong> keyword to bring the contents of the <strong class="source-inline">test_browser</strong> module in from the <strong class="source-inline">src/game/test_browser.rs</strong> file, but only when we're running a <strong class="source-inline">test</strong> build. Then, we can use <strong class="source-inline">test_browser as browser</strong> to make the functions available via <strong class="source-inline">browser::</strong> calls – again, only in test builds – in the same way as we call the <strong class="source-inline">browser</strong> production code. Finally, we can add the <strong class="source-inline">#[cfg(not(test))]</strong> annotation to <strong class="source-inline">use crate::browser</strong> to prevent the real <strong class="source-inline">browser</strong> code from being imported into the test.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I first saw this technique on Klausi's Weblog at <a href="https://bit.ly/3ENxhWQ">https://bit.ly/3ENxhWQ</a>, but it is fairly common in Rust code.</p>
			<p>If you do this and run <strong class="source-inline">cargo test</strong>, you'll see a lot of errors, such as <strong class="source-inline">cannot find function `fetch_json` in module `browser`</strong>, because even though we're importing a test module, we haven't filled it in with any code. In this situation, it's a good idea to follow the compiler errors, which will point out that there's no file yet in <strong class="source-inline">src/game/test_browser.rs</strong>. It will also list the functions that are used in the <strong class="source-inline">game</strong> module but aren't defined in our <strong class="source-inline">test_browser.rs</strong> file. To get past this, you can create the <strong class="source-inline">test_browser.rs</strong> file and bring in the bare minimum that's needed to get back to compiling, as shown here:</p>
			<p class="source-code">use anyhow::{anyhow, Result};</p>
			<p class="source-code">use wasm_bindgen::JsValue;</p>
			<p class="source-code">use web_sys::HtmlElement;</p>
			<p class="source-code">pub fn draw_ui(html: &amp;str) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p class="source-code">pub fn hide_ui() -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p class="source-code">pub fn find_html_element_by_id(id: &amp;str) -&gt; Result&lt;HtmlElement&gt; {</p>
			<p class="source-code">    Err(anyhow!("Not implemented yet!"))</p>
			<p class="source-code">}</p>
			<p class="source-code">pub async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue&gt; {</p>
			<p class="source-code">    Err(anyhow!("Not implemented yet!"))</p>
			<p class="source-code">}</p>
			<p>As you can see, only <a id="_idIndexMarker832"/>four functions are used in <strong class="source-inline">game</strong> that have been defined in <strong class="source-inline">browser</strong>, and we've filled in just enough to compile. To use this for testing, we're going to need to place simulated implementations with some sort of state they keep track of. The<a id="_idIndexMarker833"/> other thing you may notice is that <strong class="source-inline">JsValue</strong> and <strong class="source-inline">HtmlElement</strong> are both being used in this code since they won't work when you run Rust native tests. They require a browser runtime, so to continue along this path, we'll eventually need to make test versions of <strong class="source-inline">HtmlElement</strong> and <strong class="source-inline">JsValue</strong> or create wrapper types for them, potentially in the <strong class="source-inline">engine</strong> module. Let's leave those as is for now, though, and try to write our first test using the standard Rust testing framework. We'll want to test the state machine change I mentioned previously by setting up the game in the <strong class="source-inline">GameOver</strong> state and transitioning to the <strong class="source-inline">Running</strong> state, then checking that the UI was hidden. The <em class="italic">beginning</em> of that test looks as follows:</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">mod tests {</p>
			<p class="source-code">    use super::*;</p>
			<p class="source-code">    use futures::channel::mpsc::unbounded;</p>
			<p class="source-code">    use std::collections::HashMap;</p>
			<p class="source-code">    use web_sys::{AudioBuffer, AudioBufferOptions};</p>
			<p class="source-code">    fn test_transition_from_game_over_to_new_game() {</p>
			<p class="source-code">        let (_, receiver) = unbounded();</p>
			<p class="source-code">        let image = HtmlImageElement::new().unwrap();</p>
			<p class="source-code">        let audio = Audio::new().unwrap();</p>
			<p class="source-code">        let options = AudioBufferOptions::new(1, 3000.0);</p>
			<p class="source-code">        let sound = Sound {</p>
			<p class="source-code">            buffer: AudioBuffer::new(&amp;options).unwrap(),</p>
			<p class="source-code">        };</p>
			<p class="source-code">        let rhb = RedHatBoy::new(</p>
			<p class="source-code">            Sheet {</p>
			<p class="source-code">                frames: HashMap::new(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            image.clone(),</p>
			<p class="source-code">            audio,</p>
			<p class="source-code">            sound,</p>
			<p class="source-code">        );</p>
			<p class="source-code">        let sprite_sheet = SpriteSheet::new(</p>
			<p class="source-code">            Sheet {</p>
			<p class="source-code">                frames: HashMap::new(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            image.clone(),</p>
			<p class="source-code">        );</p>
			<p class="source-code">        let walk = Walk {</p>
			<p class="source-code">            boy: rhb,</p>
			<p class="source-code">            backgrounds: [</p>
			<p class="source-code">                Image::new(image.clone(), Point { x: 0, y: </p>
			<p class="source-code">                  0 }),</p>
			<p class="source-code">                Image::new(image.clone(), Point { x: 0, y: </p>
			<p class="source-code">                  0 }),</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            obstacles: vec![],</p>
			<p class="source-code">            obstacle_sheet: Rc::new(sprite_sheet),</p>
			<p class="source-code">            stone: image.clone(),</p>
			<p class="source-code">            timeline: 0,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        let state = WalkTheDogState {</p>
			<p class="source-code">            _state: GameOver {</p>
			<p class="source-code">                new_game_event: receiver,</p>
			<p class="source-code">            },</p>
			<p class="source-code">            walk: walk,</p>
			<p class="source-code">        };</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Oh boy – that's a lot of code to test a few lines of Rust, and it's not even a complete test yet. It's just <a id="_idIndexMarker834"/>setting up the game in the state that we need it to be in <em class="italic">before</em> we transition into a <strong class="source-inline">Ready</strong> state. A lot is being revealed about our design, specifically that it's what I may call <em class="italic">naïve'</em>. It's very hard to construct objects, and while the <strong class="source-inline">game</strong>, <strong class="source-inline">engine</strong>, and <strong class="source-inline">browser</strong> modules are separate, they are still pretty tightly coupled. It works but it in a fashion that only solves the problem in front of us. That's completely acceptable – we had specific goals to build a small endless runner and we did it, but this also means that if we wanted to start extending our game engine so that it's more flexible, we would need to make further changes. I tend <a id="_idIndexMarker835"/>to view software design more like sculpting than constructing. You start with a big block of code and chip away at it until it looks like what you want, rather than a blueprint that you follow to get the perfect house.</p>
			<p>Some of the aspects of our design that this test is revealing are as follows:</p>
			<ul>
				<li>It's not easy to create new <strong class="source-inline">Walk</strong> structures.</li>
				<li>The <strong class="source-inline">game</strong> module is far more coupled to <strong class="source-inline">web-sys</strong> and <strong class="source-inline">wasm-bindgen</strong> than we thought.</li>
			</ul>
			<p>We made the intentional choice not to try and create perfect abstractions early in the project. This is one of the reasons we didn't write this code in a test-driven style initially. TDD would have strongly pushed in the direction of further abstraction and layering, which would have hidden the game code we're trying to learn here. As an example, instead of using <strong class="source-inline">HtmlImageElement</strong> or <strong class="source-inline">AudioBuffer</strong>, we may have written wrappers or abstractions around those objects (we already have an <strong class="source-inline">Image</strong> struct), which is probably better for growing our project in the medium to long term but is harder to understand in the short term.</p>
			<p>This is a long-winded way of saying that this code is now hard to write isolated unit tests for because we didn't build it with them in mind. If you were able to run this test, you would see the following:</p>
			<p class="source-code">thread 'game::tests::test_transition_from_game_over_to_new_game' panicked at 'cannot call wasm-bindgen imported functions on non-wasm targets', /Users/eric/.cargo/registry/src/github.com-1ecc6299db9ec823/web-sys-0.3.52/src/features/gen_HtmlImageElement.rs:4:1</p>
			<p>It turns out that even though we replaced the production <strong class="source-inline">browser</strong> with <strong class="source-inline">test_browser</strong>, we're still trying to call browser code. I have already pointed out <strong class="source-inline">HtmlElement</strong> and <strong class="source-inline">JsValue</strong>, but this test also includes <strong class="source-inline">AudioBuffer</strong> and <strong class="source-inline">AudioBufferOptions</strong>. As is, this code doesn't compile without more feature flags being enabled and <a id="_idIndexMarker836"/>changes being made to <strong class="source-inline">engine</strong>. It's just too tightly coupled to the browser still.</p>
			<p>The act of<a id="_idIndexMarker837"/> trying to use this code in a test harness demonstrated the power of coupling, and it is often useful to take legacy code and get it into a harness to identify these dependency problems and break them. Unfortunately, this is a time-consuming process that we are not going to continue using in this section, although it may appear on my blog at <a href="http://paytonrules.com">paytonrules.com</a> at some point. Instead, we'll test th<a id="_idTextAnchor213"/>is code via a test that runs in the browser.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor214"/>Browser tests</h2>
			<p>At the beginning <a id="_idIndexMarker838"/>of this chapter, I mentioned that there were <strong class="bold">unit tests</strong> and <strong class="bold">browser tests</strong>. The distinction is that while browser tests may test the same <a id="_idIndexMarker839"/>behavior as a unit test, they automate the desired behavior in a headless browser. This makes the test more realistic, but also slower and more prone to breaking for flaky reasons. I prefer my systems to have a large base of unit tests and a smaller number of more integrated tests to make sure everything is all wired together correctly, but we can't always get what we want.</p>
			<p>Instead, we'll get what we need – verification of the behavior – by skipping dependency-breaking techniques for legacy code and writing a test that runs in the browser. We'll remove the code that added <a id="_idIndexMarker840"/>the <strong class="source-inline">test_browser</strong> module, as well as the <strong class="source-inline">test_browser</strong> file itself. We'll keep the test we wrote previously and make two changes for it to compile, as follows:</p>
			<ol>
				<li>Add <strong class="source-inline">AudioBufferOptions</strong> to the list of <strong class="source-inline">web-sys</strong> features in <strong class="source-inline">Cargo.toml</strong>.</li>
				<li>In the <strong class="source-inline">engine</strong> module, make the <strong class="source-inline">buffer</strong> field on the <strong class="source-inline">Sound</strong> struct public so that we can create <strong class="source-inline">Sound</strong> directly in this test.</li>
			</ol>
			<p>These two changes will get the code compiling, but it won't make it run in the tests yet. For that, we need to make a couple of changes. First, we need to change the <strong class="source-inline">#[test]</strong> macro to <strong class="source-inline">#[wasm_bindgen_test]</strong>. Then, we need to add two statements to our <strong class="source-inline">test</strong> module, as shown here:</p>
			<p class="source-code"><strong class="bold">#[cfg(test)]</strong></p>
			<p class="source-code">mod tests {</p>
			<p class="source-code">    use super::*;</p>
			<p class="source-code">    use futures::channel::mpsc::unbounded;</p>
			<p class="source-code">    use std::collections::HashMap;</p>
			<p class="source-code">    use web_sys::{AudioBuffer, AudioBufferOptions};</p>
			<p class="source-code">    <strong class="bold">use wasm_bindgen_test::wasm_bindgen_test;</strong></p>
			<p class="source-code">    <strong class="bold">wasm_bindgen_test::wasm_bindgen_test_configure!</strong></p>
			<p class="source-code"><strong class="bold">        (run_in_browser);</strong></p>
			<p class="source-code">    <strong class="bold">#[wasm_bindgen_test]</strong></p>
			<p class="source-code">    fn test_transition_from_game_over_to_new_game() {</p>
			<p class="source-code">        ...</p>
			<p>The <a id="_idIndexMarker841"/>first line to add is <strong class="source-inline">use wasm_bindgen_test::wasm_bindgen_test</strong> so that the macro is present. The second is <strong class="source-inline">wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);</strong>. This <a id="_idIndexMarker842"/>directive tells the test runner to run in the browser so that the code can interact with the DOM, similar to how the application does. This test won't run in <strong class="source-inline">cargo test</strong>, so you'll need to use the <strong class="source-inline">wasm-pack test --headless –chrome</strong> command. This will run the web tests in a headless version of the Chrome browser. When you run them, you should see the following output:</p>
			<p class="source-code">running 1 test</p>
			<p class="source-code">test rust_webpack_template::game::tests::test_transition_from_game_over_to_new_game … ok</p>
			<p>Now, we have a test that's running and passing, but the only problem is that we don't have any assertions. We've written an "arrange" step but we haven't checked the results. The point <a id="_idIndexMarker843"/>of this test was to make sure that the UI was hidden when the state transition happened, so we'll need to update the test to check that. We can do this by adding the action <a id="_idIndexMarker844"/>and assertion steps, as shown here:</p>
			<p class="source-code">#[wasm_bindgen_test]</p>
			<p class="source-code">fn test_transition_from_game_over_to_new_game() {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">let document = browser::document().unwrap();</strong></p>
			<p class="source-code">    <strong class="bold">document</strong></p>
			<p class="source-code">        <strong class="bold">.body()</strong></p>
			<p class="source-code">        <strong class="bold">.unwrap()</strong></p>
			<p class="source-code">       <strong class="bold"> .insert_adjacent_html("afterbegin", "&lt;div </strong></p>
			<p class="source-code"><strong class="bold">            id='ui'&gt;&lt;/div&gt;")</strong></p>
			<p class="source-code">        <strong class="bold">.unwrap();</strong></p>
			<p class="source-code">    <strong class="bold">browser::draw_ui("&lt;p&gt;This is the UI&lt;/p&gt;").unwrap();</strong></p>
			<p class="source-code">    let state = WalkTheDogState {</p>
			<p class="source-code">        _state: GameOver {</p>
			<p class="source-code">            new_game_event: receiver,</p>
			<p class="source-code">        },</p>
			<p class="source-code">        walk: walk,</p>
			<p class="source-code">    };</p>
			<p class="source-code">    <strong class="bold">state.new_game();</strong></p>
			<p class="source-code">    <strong class="bold">let ui =  </strong></p>
			<p class="source-code"><strong class="bold">        browser::find_html_element_by_id("ui").unwrap();</strong></p>
			<p class="source-code">    <strong class="bold">assert_eq!(ui.child_element_count(), 0);</strong></p>
			<p class="source-code">}</p>
			<p>Here, we start the test by inserting the <strong class="source-inline">div</strong> property, along with the <strong class="source-inline">ui</strong> ID, into the document – after all, that is in <strong class="source-inline">index.html</strong> in the game. Then, <strong class="source-inline">browser::draw_ui</strong> draws the UI to the browser, even though the browser is running headlessly, so we don't see it. We continue by creating <strong class="source-inline">WalkTheDogState</strong> in the <strong class="source-inline">GameOver</strong> state; on the next line, we have it transition to <strong class="source-inline">Ready</strong> via the <strong class="source-inline">state.new_game()</strong> method. Finally, we check that the UI was cleared by finding the <strong class="source-inline">div</strong> property and checking its <strong class="source-inline">child_element_count</strong>. If it's <strong class="source-inline">0</strong>, the code is right, and this test will pass. If <a id="_idIndexMarker845"/>you run this test, you'll see that this test <em class="italic">does</em> pass, so you will probably want to comment out the <strong class="source-inline">let next_state: WalkTheDogState&lt;Ready&gt; = state.</strong><strong class="bold">new_game</strong><strong class="source-inline">()</strong> line and run it again just to make sure it fails when the transition happens.</p>
			<p>This is still <a id="_idIndexMarker846"/>a very long test but at least it's working. The test can be cleaned up by creating some factory methods in the various modules so that structs are easier to create. You'll notice that the test is full of <strong class="source-inline">unwrap</strong> calls. This is because, in a test, I want things to crash right away if they aren't as expected. Unfortunately, browser-based tests with the <strong class="source-inline">wasm_bindgen_test</strong> macro do not let you return a <strong class="source-inline">Result</strong> for readability as standard Rust tests do yet. This is another reason you sho<a id="_idTextAnchor215"/>uld try and make your tests run as native Rust tests.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor216"/>Async tests</h2>
			<p>One of the <a id="_idIndexMarker847"/>biggest challenges of testing web applications, whether they're Wasm or traditional JavaScript ones, is code that occurs <strong class="bold">asynchronously</strong>. In the case of our code, that's anything that runs in an <strong class="source-inline">async</strong> block or function. Imagine calling a function in<a id="_idIndexMarker848"/> an <strong class="source-inline">async</strong> test and then immediately trying to verify it worked. By definition, you can't, because it's running asynchronously and may not have finished yet. Fortunately, <strong class="source-inline">wasm_bindgen_test</strong> handles this rather easily by making the test's functions <strong class="source-inline">async </strong>themselves.</p>
			<p>Let's look at a simpler <a id="_idIndexMarker849"/>example and try to write a test for the <strong class="source-inline">load_json</strong> function in the <strong class="source-inline">browser</strong> module:</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">mod tests {</p>
			<p class="source-code">    use super::*;</p>
			<p class="source-code">    use wasm_bindgen_test::wasm_bindgen_test;</p>
			<p class="source-code">    wasm_bindgen_test::wasm_bindgen_test_configure!</p>
			<p class="source-code">        (run_in_browser);</p>
			<p class="source-code">    #[wasm_bindgen_test]</p>
			<p class="source-code">    async fn test_error_loading_json() {</p>
			<p class="source-code">        let json = fetch_json("not_there.json").await;</p>
			<p class="source-code">        assert_eq!(json.is_err(), true);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This can be<a id="_idIndexMarker850"/> found in the <strong class="source-inline">browser</strong> module. Here, we start with the boilerplate to set up a <strong class="source-inline">tests</strong> module, import both <strong class="source-inline">browser</strong> and <strong class="source-inline">wasm_bindgen_test</strong>, and configure the test to run in the browser. The test itself is only two lines. Try to load a <strong class="source-inline">JSON</strong> file that doesn't exist and report an error. The key difference between this is that the test is <strong class="source-inline">async</strong>, which allows us to use <strong class="source-inline">await</strong> in the test and write the assertion without adding any "wait for" logic. This is great, but there are a couple of things to keep in mind:</p>
			<ul>
				<li>If <strong class="source-inline">fetch_json</strong> can hang, this test will hang.</li>
				<li>This test will try to load a file. Ideally, we don't want to do this in a unit test.</li>
			</ul>
			<p>This test will run and pass. We could test all of the <strong class="source-inline">browser</strong> functions this way, accepting that the <strong class="source-inline">browser</strong> module's tests will use the filesystem as needed. That's probably what I would do if I was handed this system in a professional environment. You could work very hard to stub out the actual browser on these tests, but to do so would remove its ability to prevent defects. After all, if you remove the browser from the <strong class="source-inline">browser</strong> module, then how do you know you got the code right?</p>
			<p>If I was given this <a id="_idIndexMarker851"/>code and asked to maintain it, I would likely adopt the following strategies:</p>
			<ul>
				<li>Curse the name of the jerk who wrote it without tests (me!).</li>
				<li>Write tests for code as I need to change it. If it doesn't change, don't bother. Go ahead and use browser automation, as we did previously.</li>
				<li>Over time, move more code that depends on <strong class="source-inline">wasm-bindgen</strong> and <strong class="source-inline">web-sys</strong> into the <strong class="source-inline">browser</strong> module so that <strong class="source-inline">engine</strong> and <strong class="source-inline">game</strong> can stub it out.</li>
				<li>Write as many tests as possible as Rust-native tests, and then make the browser-based unit tests native whenever possible.</li>
			</ul>
			<p>As for <a id="_idIndexMarker852"/>integration tests, I doubt I would write any integration tests in the Cargo sense. For Cargo libraries, all the integration tests are written in the <strong class="source-inline">tests</strong> directory and compiled as a separate package. This is a great idea when you're writing a library that's going to be consumed by other people, but we are writing an application and aren't providing an API. The integration tests I would write would be any tests that use the real browser, but those are integration tests in the sense that they are integrated with the web browser, not that they run as Rust integration tests.</p>
			<p>However, we can't just rely on adding tests to make sure our code works. Sometimes, we just have to debug it. Let's dig into that next.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor217"/>Debugging the game</h1>
			<p>To<a id="_idIndexMarker853"/> debug a traditional program, be it in Java, C#, or C++, we must set breakpoints and step through the code. In JavaScript, we can type the word <strong class="source-inline">debugger</strong> to set a breakpoint, but although WebAssembly runs in the browser, it isn't JavaScript. So, how do we debug it?</p>
			<p>There's a lot <a id="_idIndexMarker854"/>of conflicting information about debugging with WebAssembly. How do you debug WebAssembly? Well, according to the official Rust WebAssembly documentation, it's simple – you can't!</p>
			<p class="author-quote">Unfortunately, the debugging story for WebAssembly is still immature. On most Unix systems, DWARF is used to encode the information that a debugger needs to provide source-level inspection of a running program. There is an alternative format that encodes similar information on Windows. Currently, there is no equivalent for WebAssembly. Therefore, debuggers currently provide limited utility, and we end up stepping through raw WebAssembly instructions emitted by the compiler, rather than the Rust source text we authored.  </p>
			<p class="author-quote">– <a href="https://rustwasm.github.io/docs/book/reference/debugging.html">https://rustwasm.github.io/docs/book/reference/debugging.html</a></p>
			<p>So, there you have it – no debugging, section over. That was easy.</p>
			<p>But it's not that simple. Of course, you can debug your application – you just can't use your browser's developer tools to step through the Rust code in a debugger. The technology isn't there yet. But that doesn't mean we don't debug; it just means we'll take more of an old-school approach to debugging. </p>
			<p>Earlier, I mentioned that when I write code, I typically write a lot of tests. I also typically don't use a debugger very often. If we break our code into smaller chunks that can be easily exercised by tests, a debugger is rarely required. That said, we didn't do that for this project, so we'll need a way to debug existing code. We'll start by logging, then getting stack traces, and finally using linters to prevent bugs before they happen.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The reality is not as cut and dry as the Rust Wasm site would state. Chrome developer tools have added support<a id="_idIndexMarker855"/> for the <strong class="bold">DWARF</strong> debugging format to the browser, as detailed here: <a href="https://developer.chrome.com/blog/wasm-debugging-2020/">https://developer.chrome.com/blog/wasm-debugging-2020/</a>. This standard format, whose specification can be found at <a href="https://dwarfstd.org/">https://dwarfstd.org/</a>, unfortunately is not supported by <strong class="source-inline">wasm-bindgen</strong> at the time of writing. You can see progress on this issue here: <a href="https://github.com/rustwasm/wasm-bindgen/issues/2389">https://github.com/rustwasm/wasm-bindgen/issues/2389</a>. By the time you read this book, the debugging tools may be modernized in Rust Wasm, as well as in browsers outside of Chrome, but for the time being, we must use more traditional tools such as <strong class="source-inline">println!</strong> and logging.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor218"/>Log versus error versus panic </h2>
			<p>If you've been following along and got confused at some point, then you've probably used the <strong class="source-inline">log!</strong> macro we wrote in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, to see what was going on. If you have been doing that, congratulations! You've been debugging the same way I did <a id="_idIndexMarker856"/>when I wrote the code originally. Print line debugging is still standard in many languages and it's pretty much the only form of debugging that's guaranteed to work anywhere. If you haven't done that, then it looks like this:</p>
			<p class="source-code">impl WalkTheDogStateMachine {</p>
			<p class="source-code">    fn update(self, keystate: &amp;KeyState) -&gt; Self {</p>
			<p class="source-code">        <strong class="bold">log!("Keystate is {:#?}", keystate);</strong></p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDogStateMachine::Ready(state) =&gt; </p>
			<p class="source-code">                state.update(keystate),</p>
			<p class="source-code">            WalkTheDogStateMachine::Walking(state) =&gt; </p>
			<p class="source-code">                state.update(keystate),</p>
			<p class="source-code">            WalkTheDogStateMachine::GameOver(state) =&gt; </p>
			<p class="source-code">               state.update(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>In the preceding example, we are<a id="_idIndexMarker857"/> logging <strong class="source-inline">KeyState</strong> on every tick through the <strong class="source-inline">update</strong> function. This isn't a great log because it's going to show an empty <strong class="source-inline">KeyState</strong> 60 times a second, but it's good enough for our purposes. However, there's one flaw in this log: <strong class="source-inline">KeyState</strong> doesn't implement the <strong class="source-inline">Debug</strong> trait. You can add it by adding the <strong class="source-inline">derive(Debug)</strong> annotation to the <strong class="source-inline">KeyState</strong> struct, like so:</p>
			<p class="source-code"><strong class="bold">#[derive(Debug)]</strong></p>
			<p class="source-code">pub struct KeyState {</p>
			<p class="source-code">    pressed_keys: HashMap&lt;String, web_sys::KeyboardEvent&gt;,</p>
			<p class="source-code">}</p>
			<p>When you add <a id="_idIndexMarker858"/>this, the console will log all your key state changes, which will be useful if your keyboard input is broken:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer105">
					<img alt="Figure 9.1 – Logging KeyState" src="image/Figure_9.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Logging KeyState</p>
			<p>In general, any <strong class="source-inline">pub struct</strong> should <strong class="source-inline">use</strong> <strong class="source-inline">#[derive(Debug)]</strong>, but this isn't the default option<a id="_idIndexMarker859"/> since it could make compile times long on large projects. When in doubt, go ahead and <strong class="source-inline">use</strong> <strong class="source-inline">#[derive(Debug)]</strong> and log the information. Now, maybe <strong class="source-inline">log!</strong> isn't noticeable enough for you, and you want the text to be bright, obvious, and red. For that, you'll need to use <strong class="source-inline">console.error</strong> in JavaScript and write a macro such as the <strong class="source-inline">log</strong> macro, which<a id="_idIndexMarker860"/> we already have in the <strong class="source-inline">browser</strong> module. This macro looks like this:</p>
			<p class="source-code">macro_rules! error {</p>
			<p class="source-code">    ( $( $t:tt )* ) =&gt; {</p>
			<p class="source-code">        web_sys::console::error_1(&amp;format!( $( $t )* </p>
			<p class="source-code">            ).into());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This is the same as the <strong class="source-inline">log</strong> macro but uses the <strong class="source-inline">error</strong> function on the <strong class="source-inline">console</strong> object. There are two advantages to the <strong class="source-inline">error</strong> function. The first is that it's red, while the other is that it also will <a id="_idIndexMarker861"/>show you the stack trace. Here's an example of <strong class="source-inline">error</strong> being called when the player is knocked out in Chrome:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer106">
					<img alt="Figure 9.2 – Error log" src="image/Figure_9.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Error log</p>
			<p>It's not the most readable stack trace in the world, but after seeing a few lines of the <strong class="source-inline">console::error_1</strong> function, you can see that this log was called from <strong class="source-inline">WalkTheDogState&lt;Walking&gt;::end_game</strong>. This log is really for true errors, as opposed to just informational logging, and this stack trace may not show up clearly in all browsers. You'll also want to be cautious with leaving this log in the production code as you may not want to expose this much information to a curious player. We'll want to make sure it's not in the production deployment, which we'll create in <a href="B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226"><em class="italic">Chapter 10</em></a>, <em class="italic">Continuous Deployment</em>.</p>
			<p>Finally, if you want to make sure the program stops when an error occurs, we'll want to go ahead and use the <strong class="source-inline">panic</strong>! macro. Some errors are recoverable but many are not, and we don't want our program to limp along in a broken state. In <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, we included the <strong class="source-inline">console-error-panic-hook</strong> crate so that if the program were to panic, we'd get a stack trace. Let's<a id="_idIndexMarker862"/> replace calling <strong class="source-inline">error</strong>! with calling <strong class="source-inline">panic</strong>! and see the difference:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer107">
					<img alt="Figure 9.3 – Panic log&#13;&#10;" src="image/Figure_9.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Panic log</p>
			<p>Here, you can see it looks a little different, but the information is mostly the same. There is one thing at the very top where it says <strong class="source-inline">src/game.rs:829</strong>, which tells you exactly where <strong class="source-inline">panic</strong> was called. In general, you will probably prefer to use <strong class="source-inline">panic</strong> compared to <strong class="source-inline">error</strong> if you need to have the error in your production code because that kind of error should be rare and fail fast. The <strong class="source-inline">error</strong> function is more useful during debugging, so you'll end up removing those.</p>
			<p>There's another kind of error that we've been ignoring at times, and that's the warnings and errors that are given to you by the compiler and linter. We can use the Rust ecosystem's tools to detect mistakes before we ever run the program. Let's look into that now.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor219"/>Linting and Clippy </h2>
			<p>One of the features that makes the Rust compiler great is that it has a linter built into it, in addition to the warnings <a id="_idIndexMarker863"/>and errors it already provides. If you're unfamiliar, a linter is a static code analysis tool that typically finds style errors and, potentially, logic errors above and beyond what the compiler can find. The term comes from the lint you find on clothing, so you can think of using a linter like rubbing a lint brush on your code. We've been getting some warnings from the compiler that we've been ignoring for a while now, most of which look like this:</p>
			<p class="source-code">warning: unused `std::result::Result` that must be used</p>
			<p class="source-code">   --&gt; src/game.rs:241:9</p>
			<p class="source-code">    |</p>
			<p class="source-code">241 |         browser::hide_ui();</p>
			<p class="source-code">    |         ^^^^^^^^^^^^^^^^^^^</p>
			<p class="source-code">    |</p>
			<p class="source-code">    = note: `#[warn(unused_must_use)]` on by default</p>
			<p class="source-code">    = note: this `Result` may be an `Err` variant, which should be handled</p>
			<p>These are all cases <a id="_idIndexMarker864"/>where an error could occur, but we probably don't want to crash if it does, so panicking or calling <strong class="source-inline">unwrap</strong> isn't an option. Propagating the <strong class="source-inline">Result</strong> type is an option, but I don't think we want to prevent moving from one state to another if there's a small browser issue. So, instead, we'll use the <strong class="source-inline">error</strong> case to log here. You can see it at <strong class="source-inline">https://bit.ly/3q1936N</strong> in the sample source code. Let's modify the code so that we log any errors:</p>
			<p class="source-code">impl WalkTheDogState&lt;GameOver&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {</p>
			<p class="source-code">        <strong class="bold">if let Err(err) = </strong>browser::hide_ui() {</p>
			<p class="source-code">            <strong class="bold">error!("Error hiding the browser {:#?}", err);</strong></p>
			<p class="source-code">        <strong class="bold">}</strong></p>
			<p class="source-code">        WalkTheDogState {</p>
			<p class="source-code">            _state: Ready,</p>
			<p class="source-code">            walk: Walk::reset(self.walk),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we have<a id="_idIndexMarker865"/> changed the <strong class="source-inline">browser::hide_ui()</strong> line to <strong class="source-inline">if let Err(err) = browser::hide_ui()</strong> and we log if an error occurs. We can see what that error log will look like by forcing <strong class="source-inline">hide_ui</strong> to return an error for a moment:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer108">
					<img alt="Figure 9.4 – A fake error&#13;&#10;" src="image/Figure_9.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – A fake error</p>
			<p>The stack trace is cut off in book form, but you can see that we got an error log with <strong class="source-inline">Error hiding the browser</strong> and then <strong class="source-inline">This is the error in the hide_ui function</strong>, which is the error message I forced into <strong class="source-inline">hide_ui</strong>. The stack trace also shows <strong class="source-inline">game::Ready</strong>, which would show you that you were transitioning into the <strong class="source-inline">Ready</strong> state if you had infinite room to show the entire message.</p>
			<p>Every single warning that's being generated should be dealt with. Most of the warnings are the same kind – that is, <strong class="source-inline">Result</strong> types where the <strong class="source-inline">Err</strong> variant is ignored. These can be removed by handling the <strong class="source-inline">Err</strong> case with a log or by calling <strong class="source-inline">panic</strong> if the game should truly crash at this time. For the most part, I've used the <strong class="source-inline">if let</strong> pattern but if <strong class="source-inline">request_animation_frame</strong> fails, then I just use <strong class="source-inline">unwrap</strong>. I don't see how the game could work if that's failing.</p>
			<p>There is one more warning we've been ignoring that we should address, as shown here:</p>
			<p class="source-code">warning: associated function is never used: `draw_rect`</p>
			<p class="source-code">   --&gt; src/engine.rs:106:12</p>
			<p class="source-code">    |</p>
			<p class="source-code">106 |     pub fn draw_rect(&amp;self, bounding_box: &amp;Rect) {</p>
			<p class="source-code">    |            ^^^^^^^^^</p>
			<p class="source-code">    |</p>
			<p class="source-code">    = note: `#[warn(dead_code)]` on by default</p>
			<p>This warning is a<a id="_idIndexMarker866"/> little unique because we used this function <em class="italic">for debugging</em>. You may not want to draw rectangles in your game, but it's essential for debugging collision boxes, as we did in <a href="B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Collision Detection</em>, so we'll want it to be available. To keep it around, let's annotate it with the <strong class="source-inline">allow</strong> keyword, like so:</p>
			<p class="source-code">impl Renderer {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">#[allow(dead_code)]</strong></p>
			<p class="source-code">    pub fn draw_rect(&amp;self, bounding_box: &amp;Rect) {</p>
			<p>This should leave the compilation error-free, but there's one more tool we can use to see whether our code could be improved. If you've spent much time in the Rust ecosystem, then you've probably<a id="_idIndexMarker867"/> heard of <strong class="bold">Clippy</strong>, a popular Rust linter that will catch common Rust mistakes and improve your code, above and beyond those found by the compiler's defaults. It's installed as a Cargo component, so it's not added to your <strong class="source-inline">Cargo.toml</strong> file but to the current system itself. Installation is simple, and you may have done it at some point and forgotten about it, but if you haven't, it's one shell command:</p>
			<p class="source-code">rustup component add clippy</p>
			<p>Once you've installed <a id="_idIndexMarker868"/>Clippy, you can run <strong class="source-inline">cargo clippy</strong> and see all the other ways we wrote bad Rust code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When the code is great, I wrote it and you followed along. When it's bad, we did it together. I don't make the rules.</p>
			<p>When I run <strong class="source-inline">cargo clippy</strong>, I get <strong class="source-inline">17</strong> warnings, but your number could be different, depending on when you<a id="_idIndexMarker869"/> run it. I'm not going to go through each one, but let's highlight one error:</p>
			<p class="source-code">warning: writing `&amp;Vec&lt;_&gt;` instead of `&amp;[_]` involves one more reference and cannot be used with non-Vec-based slices.</p>
			<p class="source-code">   --&gt; src/game.rs:945:29</p>
			<p class="source-code">    |</p>
			<p class="source-code">945 | fn rightmost(obstacle_list: &amp;Vec&lt;Box&lt;dyn Obstacle&gt;&gt;) -&gt; i16 {</p>
			<p class="source-code">    |                             ^^^^^^^^^^^^^^^^^^^^^^^ help: change this to: `&amp;[Box&lt;dyn Obstacle&gt;]`</p>
			<p class="source-code">    |</p>
			<p class="source-code">    = note: `#[warn(clippy::ptr_arg)]` on by default</p>
			<p class="source-code">    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg</p>
			<p>The <strong class="source-inline">rightmost</strong> function in the <strong class="source-inline">game</strong> module can be made to use one less reference and be made more flexible. <strong class="source-inline">help</strong> here is great because it tells me exactly what to do to fix it. So, let's change the <strong class="source-inline">rightmost</strong> function signature so that it looks as follows:</p>
			<p class="source-code">fn rightmost(obstacle_list: &amp;[Box&lt;dyn Obstacle&gt;]) -&gt; i16 {</p>
			<p>This doesn't fix any bugs but it does remove a Clippy warning and makes the method more flexible.</p>
			<p>It's very <a id="_idIndexMarker870"/>common for Clippy to inform you of better idioms you could be using. One Clippy warning I wanted to highlight looks like this:</p>
			<p class="source-code">warning: match expression looks like `matches!` macro</p>
			<p class="source-code">   --&gt; src/game.rs:533:9</p>
			<p class="source-code">    |</p>
			<p class="source-code">533 | /         match self {</p>
			<p class="source-code">534 | |             RedHatBoyStateMachine::KnockedOut(_) =&gt; true,</p>
			<p class="source-code">535 | |             _ =&gt; false,</p>
			<p class="source-code">536 | |         }</p>
			<p class="source-code">    | |_________^ help: try this: `matches!(self, RedHatBoyStateMachine::KnockedOut(_))`</p>
			<p class="source-code">    |</p>
			<p class="source-code">    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro</p>
			<p>I had this error <a id="_idIndexMarker871"/>occur quite a bit in earlier versions of the code. I wasn't aware that the <strong class="source-inline">matches!</strong> macro existed before I ran Clippy, but what it does is handle the exact case where you need to check whether an <strong class="source-inline">enum</strong> is a specific case you're looking for. That's why the code now uses what Clippy suggests, which is in <strong class="source-inline">impl</strong> <strong class="source-inline">RedHatBoyStateMachine</strong>:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn knocked_out(&amp;self) -&gt; bool {</p>
			<p class="source-code">        matches!(self, RedHatBoyStateMachine::KnockedOut(_))</p>
			<p class="source-code">    }</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Many editors make it very easy to enable Clippy as part of syntax checking so that you don't need to run it explicitly. If you can enable it, you should do so.</p>
			<p>Many of the other errors are about overusing <strong class="source-inline">clone</strong> and using <strong class="source-inline">into</strong> when it isn't necessary. I highly recommend going through the code and fixing those, taking another moment to understand why they were flagged. In <a href="B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226"><em class="italic">Chapter 10</em></a>, <em class="italic">Continuous Deployment</em>, we'll add Clippy to <a id="_idIndexMarker872"/>our build process so that we don't have to keep putting up with these errors.</p>
			<p>At this point, the code has been tested (a little) and we've handled every compiler error and warning we can think of. It's safe to say that the game works, but is it fast enough? The next thing to check is its performance. So, let's do that now.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor220"/>Measuring performance with a browser</h1>
			<p>The first step in<a id="_idIndexMarker873"/> debugging performance is answering the question, <em class="italic">Do you have a performance problem?</em> Too many developers, especially game developers, worry too early about performance and introduce complex code for a performance gain that just isn't there.</p>
			<p>For example, do you know why so much of this code uses <strong class="source-inline">i16</strong> and <strong class="source-inline">f16</strong>? Well, when I was going back to school a few years ago, I took a game optimization class in C++, where our final project needed to optimize a particle system. The biggest performance gains were to convert 32-bit integers into 16-bit integers. As my professor would say, "<em class="italic">We got to the moon on 16-bit!</em>" So, when I was writing this code, I internalized the lesson and made the variables 16-bit unless they were being sent to JavaScript, where everything is 32-bit anyway. Well, allow <a id="_idIndexMarker874"/>me to quote directly from the WebAssembly specification (found at <a href="https://webassembly.github.io/spec/core/syntax/types.html">https://webassembly.github.io/spec/core/syntax/types.html</a>):</p>
			<p class="author-quote">Number types classify numeric values.</p>
			<p class="author-quote">The <em class="italic">i32</em> and <em class="italic">i64</em> types classify 32- and 64-bit integers, respectively. Integers are not inherently signed or unsigned; their interpretation is determined by individual operations.</p>
			<p class="author-quote">The <em class="italic">f32</em> and <em class="italic">f64</em> types classify 32- and 64-bit floating-point data, respectively. They correspond to the respective binary floating-point representations, also known as single and double precision, as defined by the IEEE 754-2019 standard (Section 3.3).</p>
			<p>It turns out that WebAssembly doesn't support a 16-bit numeric value, so all of the optimization to <strong class="source-inline">i16</strong> is pointless. It's not harming anything and it's not worth going back to change it, but it reinforces the first rule of<a id="_idIndexMarker875"/> optimization: <strong class="bold">measure first</strong>. With that in mind, let's investigate two different ways to measure the performance of our game.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor221"/>Frame rate counter </h2>
			<p>There are <a id="_idIndexMarker876"/>two ways our game can perform poorly: by using too much memory and slowing the frame rate. The second of those is far more important, especially for a small game like this, so we'll want to start looking at frame rate first. If the frame rate consistently lags, our game loop will account for it as best it can, but the game will look jittery and respond poorly. So, we need to know the current frame rate, and the best way to do that is to draw it on the screen.</p>
			<p>We'll start by adding a function, <strong class="source-inline">draw_text</strong>, that will draw arbitrary text on the screen. This is debug text, so similarly to the <strong class="source-inline">draw_rect</strong> function, we'll need to disable the warning that says the code is unused. Writing text is a function of <strong class="source-inline">Renderer</strong> in the <strong class="source-inline">engine</strong> module, as shown here:</p>
			<p class="source-code">impl Renderer {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    #[allow(dead_code)]</p>
			<p class="source-code">    pub fn draw_text(&amp;self, text: &amp;str, location: &amp;Point) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">        self.context.set_font("16pt serif");</p>
			<p class="source-code">        self.context</p>
			<p class="source-code">            .fill_text(text, location.x.into(), </p>
			<p class="source-code">                location.y.into())</p>
			<p class="source-code">            .map_err(|err| anyhow!("Error filling text </p>
			<p class="source-code">                {:#?}", err))?;</p>
			<p class="source-code">        Ok(())</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We've hardcoded the font here because this is for debugging purposes only, so it's not worth customizing. Now, we need to add a frame rate calculator to the game loop, which is in the <strong class="source-inline">start</strong> method of <strong class="source-inline">GameLoop</strong> in the <strong class="source-inline">engine</strong> module. You can refresh your memory on how it works by reviewing <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>. The frame rate can be calculated by taking the difference between the last two frames, dividing by 1,000, to get from milliseconds to seconds, and calculating its inverse (which is 1 divided by the number). This is simple but it will lead to the frame rate fluctuating wildly on screen and won't show very useful information. What we can do instead is update the frame rate every second so that we can get a fairly stable indicator of performance on screen.</p>
			<p>Let's add<a id="_idIndexMarker877"/> that code to the <strong class="source-inline">engine</strong> module. We'll start with a standalone function that will calculate the frame rate every second in the <strong class="source-inline">start</strong> method, as shown here:</p>
			<p class="source-code">unsafe fn draw_frame_rate(renderer: &amp;Renderer, frame_time: f64) {</p>
			<p class="source-code">    static mut FRAMES_COUNTED: i32 = 0;</p>
			<p class="source-code">    static mut TOTAL_FRAME_TIME: f64 = 0.0;</p>
			<p class="source-code">    static mut FRAME_RATE: i32 = 0;</p>
			<p class="source-code">    FRAMES_COUNTED += 1;</p>
			<p class="source-code">    TOTAL_FRAME_TIME += frame_time;</p>
			<p class="source-code">    if TOTAL_FRAME_TIME &gt; 1000.0 {</p>
			<p class="source-code">        FRAME_RATE = FRAMES_COUNTED;</p>
			<p class="source-code">        TOTAL_FRAME_TIME = 0.0;</p>
			<p class="source-code">        FRAMES_COUNTED = 0;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if let Err(err) = renderer.draw_text(</p>
			<p class="source-code">        &amp;format!("Frame Rate {}", FRAME_RATE),</p>
			<p class="source-code">        &amp;Point { x: 400, y: 100 },</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">        error!("Could not draw text {:#?}", err);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Oh no – it's an <strong class="source-inline">unsafe</strong> function! It's the first one in this book, and probably the last. We're using an <strong class="source-inline">unsafe</strong> function here because of the <strong class="source-inline">static mut</strong> variables – that is, <strong class="source-inline">FRAMES_COUNTED</strong>, <strong class="source-inline">TOTAL_FRAME_TIME</strong>, and <strong class="source-inline">FRAME_RATE</strong> – which are not safe in a multithreaded environment. We know that this function won't be called in a multithreaded way, and we also know that if it was called, it would just show a weird frame rate value. It's not something I generally recommend, but in this case, we don't want to pollute <strong class="source-inline">GameLoop</strong> or the <strong class="source-inline">engine</strong> module with those values or put them in thread-safe types. After all, we wouldn't want to have our frame rate calculator take too long because of a bunch of <strong class="source-inline">Mutex</strong> lock calls. So, we'll accept that this debugging function is <strong class="source-inline">unsafe</strong>, shiver in fear for a moment, and move on.</p>
			<p>The <a id="_idIndexMarker878"/>function starts by setting up the initial <strong class="source-inline">FRAMES_COUNTED</strong>, <strong class="source-inline">TOTAL_FRAME_TIME</strong>, and <strong class="source-inline">FRAME_RATE</strong> values. On each call to <strong class="source-inline">draw_frame_rate</strong>, we update <strong class="source-inline">TOTAL_FRAME_TIME</strong> and the number of <strong class="source-inline">FRAMES_COUNTED</strong>. When <strong class="source-inline">TOTAL_FRAME_TIME</strong> has passed <strong class="source-inline">1000</strong>, this means that 1 second has elapsed, since <strong class="source-inline">TOTAL_FRAME_TIME</strong> is in milliseconds. We can set <strong class="source-inline">FRAME_RATE</strong> to the number of <strong class="source-inline">FRAMES_COUNTED</strong> because that's the literal <strong class="bold">frames per second </strong>(<strong class="bold">FPS</strong>) and <a id="_idIndexMarker879"/>then reset both counters. After calculating the frame count, we draw it with the new <strong class="source-inline">draw_text</strong> function we just created. This function is going to be called last on every frame, which is important because if it isn't, we would draw the game right over the top of the frame rate. If we didn't draw the frame rate on every frame, we also wouldn't see it except for brief flickers on the screen, which is hardly suitable for debugging.</p>
			<p>Now, let's add the call to <strong class="source-inline">GameLoop</strong>, in the <strong class="source-inline">start</strong> function, as shown here:</p>
			<p class="source-code">impl GameLoop {</p>
			<p class="source-code">    pub async fn start(game: impl Game + 'static) -&gt; Result&lt;()&gt; {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        *g.borrow_mut() = Some(browser::create_raf_closure</p>
			<p class="source-code">             (move |perf: f64| {</p>
			<p class="source-code">            process_input(&amp;mut keystate, &amp;mut </p>
			<p class="source-code">                keyevent_receiver);</p>
			<p class="source-code">            <strong class="bold">let frame_time = perf - game_loop.last_frame;</strong></p>
			<p class="source-code">            <strong class="bold">game_loop.accumulated_delta += frame_time as </strong></p>
			<p class="source-code"><strong class="bold">                f32;</strong></p>
			<p class="source-code">            while game_loop.accumulated_delta &gt; FRAME_SIZE {</p>
			<p class="source-code">                game.update(&amp;keystate);</p>
			<p class="source-code">                game_loop.accumulated_delta -= FRAME_SIZE;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            game_loop.last_frame = perf;</p>
			<p class="source-code">            game.draw(&amp;renderer);</p>
			<p class="source-code">            <strong class="bold">if cfg!(debug_assertions) {</strong></p>
			<p class="source-code">                <strong class="bold">unsafe {</strong></p>
			<p class="source-code">                    <strong class="bold">draw_frame_rate(&amp;renderer, frame_time);</strong></p>
			<p class="source-code">                <strong class="bold">}</strong></p>
			<p class="source-code">            <strong class="bold">}</strong></p>
			<p class="source-code">            ...</p>
			<p>The <strong class="source-inline">game_loop.accumlated_delta</strong> line has changed slightly, pulling the calculation<a id="_idIndexMarker880"/> for the length of the frame into a temporary variable, <strong class="source-inline">frame_time</strong>. Then, after drawing, we check whether we are in debug/development mode through the check for <strong class="source-inline">if cfg!(debug_assertions)</strong>. This will ensure that this doesn't show up in the deployed code. If we are in debug mode, we call <strong class="source-inline">draw_frame_rate</strong> inside an <strong class="source-inline">unsafe</strong> block. We send that function <strong class="source-inline">renderer</strong> and <strong class="source-inline">frame_time</strong>, which we just pulled into a temporary variable. Adding this code gives us a clear measurement of the frame rate on the screen:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer109">
					<img alt="Figure 9.5 – Showing the frame rate" src="image/Figure_9.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Showing the frame rate</p>
			<p>On my<a id="_idIndexMarker881"/> machine, the frame rate is a steady <strong class="source-inline">60</strong>, with an occasional blip that isn't consistent. That's great unless you're writing a chapter on debugging performance issues. Then, you may have a problem.</p>
			<p>Fortunately, in early drafts, there was one time when the frame rate dropped, and that was when the RHB crashed into a rock. When the <strong class="bold">New Game</strong> button showed up, the frame rate suddenly dropped, albeit briefly, and did so every time. We can "restore" that defect by removing the preloaded button and font from <strong class="source-inline">index.html</strong>. In other words, we must delete the highlighted code in <strong class="source-inline">index.html</strong>:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">  &lt;meta charset="UTF-8"&gt;</p>
			<p class="source-code">  &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;</p>
			<p class="source-code">  &lt;link rel="stylesheet" href="styles.css" type="text/css" </p>
			<p class="source-code">      media=</p>
			<p class="source-code">  "screen"&gt;</p>
			<p class="source-code">  <strong class="bold">&lt;link rel="preload" as="image" href="Button.svg"&gt;</strong></p>
			<p class="source-code">  <strong class="bold">&lt;link rel="preload" as="font" href=</strong></p>
			<p class="source-code"><strong class="bold">  "kenney_future_narrow-webfont.woff2"&gt;</strong></p>
			<p class="source-code">&lt;/head&gt;</p>
			<p>If you <a id="_idIndexMarker882"/>delete the preloaded assets, you should see the see frame rate dip briefly. Displaying the frame rate is a great way to make sure that you, as a developer, see performance issues right away. If the frame rate dips, then you've got a problem, just like we have when we don't preload the assets. Sometimes, we need more than just a frame rate counter. So, let's leave the preload code deleted and see the performance problem in the browser debugger.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor222"/>Browser debugger </h2>
			<p>Every <a id="_idIndexMarker883"/>modern browser has developer tools, but I'll be using Chrome for this section as it's the one most popular with developers. In general, they all look similar to each other. To get performance information, I must start the game and open the developer tools in Chrome. Then, I must right-click and click <strong class="bold">Inspect</strong>, though there are plenty of other ways to open the tools. From there, I must click the <strong class="bold">Performance</strong> tab and start recording. Then, I must run RHB into a rock and stop recording. Since I know I've got a specific spot with a performance dip, I want to get to it as quickly as possible to hide any noise in the debugger from other code. After I do that, I will see a graph, like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer110">
					<img alt="Figure 9.6 – The Performance tab" src="image/Figure_9.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – The Performance tab</p>
			<p>That's a lot of noise, but you can see that the graph changes. There's a pink blob on the <strong class="bold">Frames</strong> row, which shows that something happened there. I can select the section that looks like a hill with my cursor and drag it to zoom in on it. Now, I will see the following screen:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer111">
					<img alt="Figure 9.7 – Dropped frames" src="image/Figure_9.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Dropped frames</p>
			<p>Here, you can<a id="_idIndexMarker884"/> see that one frame was <strong class="bold">115.8 ms</strong>. I opened the <strong class="bold">Frames</strong> section (see how the gray arrow next to <strong class="bold">Frames</strong> points down) to see what was drawn on those frames – our poor knocked-out RHB. A frame that's 115.8 ms is way too long, and if you hover your mouse over that, it will show you <strong class="bold">dropped frames</strong>. Beneath the <strong class="bold">Frames</strong> section, there's the <strong class="bold">Main</strong> section, which shows what the application was doing. I've highlighted <strong class="bold">Recalculate Style</strong> here, which is taking <strong class="bold">33.55 ms</strong> according to the <strong class="bold">ToolTip</strong> window, which shows up after I roll my mouse over it.</p>
			<p><strong class="bold">Recalculate Style</strong> is something the browser has to do when you add things to the DOM, such as a button. How did we write our UI again? We added buttons to the UI. By inserting the button<a id="_idIndexMarker885"/> into the document, we force the styles to be recalculated and redo the layout; since we didn't preload the elements, it's slower than one of our frames in a game. To speed this up, we can restore the three preloaded lines we deleted from the <strong class="source-inline">index.html</strong> file, which should speed up recalculating the layout. If you do that and remeasure your performance, you'll see something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer112">
					<img alt="Figure 9.8 – No dropped frames!&#13;&#10;" src="image/Figure_9.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – No dropped frames!</p>
			<p>Was this worth worrying about? Possibly – it is noticeable to see the button load, but it's not worth extending this chapter to fix it. You know how to fix it, and you know how to find the issue in the <strong class="bold">Performance</strong> tab, and that's what's important for now. Anyway, we have another question to answer: how much memory is this game taking up?</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor223"/>Checking memory </h2>
			<p>When<a id="_idIndexMarker886"/> I was writing this game, I would frequently leave it running all day in the background, only to have my browser become very unresponsive as it started taking up all my computer's memory. I began to suspect that the game had a memory leak, so I started investigating. You may think it's impossible to have a memory leak in Rust due to its guarantees, and it is harder, but remember that a lot of our code talks to JavaScript, where we don't necessarily have the same guarantees. Fortunately, we can check this with the same tools we have been using to test performance.</p>
			<p>Go ahead and clear the performance data by clicking <strong class="bold">no sign</strong> in the top-left corner. Then, start another recording and play for a little while. This time, don't try to die right away; go ahead and let the game play for a bit. Then, stop recording and look at the performance <a id="_idIndexMarker887"/>data again, this time ensuring you click the <strong class="bold">Memory</strong> button. Now, you can a look at the results, which may look like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer113">
					<img alt="Figure 9.9 – Memory profiling&#13;&#10;" src="image/Figure_9.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Memory profiling</p>
			<p>Can you see that blue wave at the bottom of the screen, which shows <strong class="bold">HEAP</strong> in the bottom right-hand corner? This shows that our memory grows and then is periodically reclaimed. This may not be ideal as we'd like memory to be constant, but we aren't trying to control things to that degree at this time. Chrome, and most browsers, run their garbage collectors in separate threads so that they won't affect performance as much as you may think. It would be worth experimenting and creating a memory budget in the application and keeping all the allocations in that budget, but that's outside the scope of this book. Fortunately, the memory is reclaimed and it doesn't look like the game is growing uncontrollably.</p>
			<p>After further investigation, it turned out that the problem with my browser was caused by my company's bug tracker, which uses far more memory than this little game! If you're seeing performance issues, make sure you account for other tabs, browser extens<a id="_idTextAnchor224"/>ions, and anything else that might be slowing down your computer outside of the game.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor225"/>Summary</h1>
			<p>This chapter was a little different than the previous ones because, in many ways, our game is complete! But of course, it's not perfect, which is why we spent some time looking at ways we can investigate defects and bullet-proof the code base. </p>
			<p>We dug into automated testing, writing unit tests for our transitions, and writing integration tests that run in the browser. We now have logging for any unforeseen errors and stack traces if the code crashes, both of which are necessary diagnostics for debugging challenging errors. Then, we used the linter and Clippy to clean up our code and remove subtle issues that the compiler can't catch. Finally, we investigated performance issues in the browser and found that we had none! </p>
			<p>In the next chapter, we'll get those tests into a CI/CD setup and even deploy them to production. What are we waiting for? Let's ship this thing!</p>
		</div>
	</body></html>