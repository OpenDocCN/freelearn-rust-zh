<html><head></head><body>
		<div><h1 id="_idParaDest-134"><em class="italic"><a id="_idTextAnchor203"/>Chapter 9</em>: Testing, Debugging, and Performance</h1>
			<p>In this book, we've built an entire game using two tools to test our logic – that is, a compiler and our eyes. If the game doesn't compile, it's broken, and if <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) doesn't look right, it's broken – simple enough. Fortunately, the compiler provides a lot of tools to make sure we don't make mistakes. Let's be honest, though – it's not enough.</p>
			<p>Developing a game can be a long process, especially if you're a hobbyist. When you only have 4 hours to work on it in a given week, they can't all be spent fighting the same bug. To ensure our game works, we need to test it, find mistakes, and make sure it's not too slow. That's what we're going to be doing here.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating automated tests</li>
				<li>Debugging the game</li>
				<li>Measuring performance with the browser</li>
			</ul>
			<p>After completing this chapter, you'll be able to fix the bugs we've written so far and make sure they don't happen again.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor204"/>Technical requirements</h1>
			<p>In this chapter, we'll use the Chrome developer tools to debug the code and monitor performance. Other browsers also ship with robust developer tools, but for the screenshots and directions in this chapter, we'll be using Chrome.</p>
			<p>The source code for this chapter is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_9</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3NKppLk">https://bit.ly/3NKppLk</a></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor205"/>Creating automated tests</h1>
			<p>In an <a id="_idIndexMarker793"/>ideal world, every system would have a large amount of testing, both automated and manual, that's done by developers and QA. Some ways to test your game is working correctly involve doing the following:</p>
			<ul>
				<li>Using types to prevent programmer errors</li>
				<li>Playing the game yourself</li>
				<li>Performing automated unit tests</li>
				<li>Performing automated integration tests</li>
			</ul>
			<p>So far, we've only used the first two, which is an unfortunately common approach in real-world code. This can be suitable for personal or hobby projects but it isn't robust enough for production applications, particularly those written by a team. </p>
			<p>Almost any application can benefit from automated, programmer-written unit tests and as a program becomes even larger, it begins to benefit from integration tests as well. There's not a consistent definition of the differences between these two types of tests as you tend to know them when you see them, but fortunately, we can use the Rust definitions. Rust and Cargo provide two kinds of testing:</p>
			<ul>
				<li>Unit tests via <code>cargo test</code></li>
				<li>Integration tests via <code>wasm-pack test</code></li>
			</ul>
			<p>Unit tests<a id="_idIndexMarker794"/> tend<a id="_idIndexMarker795"/> to be programmer-centric. They are written at the method or function level, with minimal dependencies. You may have a test for every branch of an <code>if/else</code> statement, while in the case of a loop, you may have tests for when a list has 0, 1, or many entries. These tests are small and fast and should run in seconds or less. These are my preferred form of testing.</p>
			<p>Integration tests <a id="_idIndexMarker796"/>tend to look at the app at a higher level. In <a id="_idIndexMarker797"/>the case of our code, the integration tests automate the browser and will work based on an event (such as a mouse click) throughout the program. These tests take longer to write, are harder to maintain, and often fail for mysterious reasons. So, why write them? Unit tests typically do not test parts of your application or they may only do so in small doses. This can lead to a situation where your unit tests all pass but the game doesn't work. Most systems will have fewer integration tests than unit tests because of their disadvantages, but they will need them for their benefits.</p>
			<p>In Rust, unit tests <a id="_idIndexMarker798"/>are <a id="_idIndexMarker799"/>written <a id="_idIndexMarker800"/>side by side with a module and run with <code>cargo test</code>. In our setup, they will run as part of a Rust executable, running directly on the machine. Integration tests are<a id="_idIndexMarker801"/> stored in the <code>tests</code> directory and only have access to things your crate makes public. They run in the browser – potentially a headless one – with <code>wasm-pack test</code>. Unit tests can test <a id="_idIndexMarker802"/>internal methods directly, while integration tests must use your crate as a real program would.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Ham Vocke has a very detailed<a id="_idIndexMarker803"/> article on the <em class="italic">Test Pyramid</em> that describes one way to organize all of your tests in a system: <a href="https://martinfowler.com/articles/practical-test-pyramid.html">https://martinfowler.com/articles/practical-test-pyramid.html</a>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor206"/>Test-driven development</h2>
			<p>I have a<a id="_idIndexMarker804"/> confession to make. I usually write all my code in a test-driven style, where you write a test then make it fail for each <a id="_idIndexMarker805"/>step in the development process. Had we followed that process during the development of this book, we'd likely have quite a few tests – perhaps more than 100. In addition, <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) exerts a lot of pressure on the design that tends to lead to more loosely coupled code. So, why didn't we do this?</p>
			<p>Well, TDD has its downsides, with perhaps the largest being we'd generate a lot more code in the form of tests. We've already written a <em class="italic">lot</em> of code in this book, so imagine trying to follow along with the tests too – you can see why I felt it was best to leave out the kind of testing I normally write. <em class="italic">Test-Driven Rust</em> isn't the title of this book after all. However, just because we didn't write tests first doesn't mean we don't want to be sure our code works. That's why, in many cases, we used the type system as the first line of defense against mistakes, such as using the typestate pattern for state transitions. The type system is one of the advantages of using Rust instead of JavaScript for this game.</p>
			<p>This isn't to say that automated testing cannot provide value for our program. The Rust ecosystem places a high value on testing, so much so that a testing framework is built into Cargo and is automatically set up for any Rust program. With unit tests, we can test algorithms such as collision detection or our famous state machines. We can make sure that the game still does what we expect, although we can't test whether a game is fun or pretty. For that, you'll have to play the game until you hate it, but a game is a lot more fun if the basics work. We can use tests, along with types, to ensure the code works as expected so<a id="_idIndexMarker806"/> that we can turn our focus to <a id="_idIndexMarker807"/>whether or not it's fun. To do that, we'll need to set up the test runner and then write some tests that run outside of the browser and inside the browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're interested in <a id="_idIndexMarker808"/>TDD, Kent Beck's book <em class="italic">Test-Driven Development By Example</em> is still an excellent resource (<a href="https://amzn.to/3o1R663">https://amzn.to/3o1R663</a>). For a web-based approach that uses TypeScript <a id="_idIndexMarker809"/>and React, you can take a look at an excellent book called <em class="italic">Build Your Own Spreadsheet</em> at <a href="https://buildyourownspreadsheet.com/">https://buildyourownspreadsheet.com/</a>.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor208"/>Getting started</h2>
			<p>As we <a id="_idIndexMarker810"/>mentioned <a id="_idIndexMarker811"/>earlier, Rust has built-in capabilities for running tests – both unit and integration. Unfortunately, the template we used way back in <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, still has an out-of-date setup at the time of writing. If it hasn't been fixed, running <code>cargo test</code> at the command prompt will fail to compile, let <a id="_idIndexMarker812"/>alone run the tests. Fortunately, there are not a lot of mistakes. There's just some out-of-date <code>async</code> code for a browser test we won't be using in the automatically generated tests. Those tests are in the <code>tests</code> directory in the <code>app.rs</code> file. This is traditionally where integration tests are put in Cargo projects. We'll change that setup shortly by using unit tests, but first, let's get this to compile by deleting the incorrect <code>async_test</code> setup test. In <code>app.rs</code>, you can delete that function and the  <code>#[wasm_bindgen_test(async)]</code> macro above it so that your <code>app.rs</code> file looks like this:</p>
			<pre>use futures::prelude::*;
use wasm_bindgen::JsValue; 
use wasm_bindgen_futures::JsFuture;
use wasm_bindgen_test::{wasm_bindgen_test, wasm_bindgen_test_configure};
wasm_bindgen_test_configure!(run_in_browser);
// This runs a unit test in native Rust, so it can only use Rust APIs.
#[test]
fn rust_test() {
    assert_eq!(1, 1);
}
// This runs a unit test in the browser, so it can use browser APIs.
#[wasm_bindgen_test]
fn web_test() {
    assert_eq!(1, 1);
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">After this book has been published, the template will be fixed and will likely compile. I'm going to assume this, regardless of you changing the code, so that it matches what is here going forward. </p>
			<p>Some of the <code>use</code> declarations aren't needed anymore, but they will be short so you can leave them in and ignore the warnings. Now, <code>app.rs</code> contains two tests – one that will run in a JavaScript <a id="_idIndexMarker813"/>environment, such as the browser, and one that will run as a native Rust test. Both of these are just examples, where <code>1</code> is still equal to <code>1</code>. To run <a id="_idIndexMarker814"/>the native Rust tests, you can run <code>cargo test</code>, as you might be accustomed to. That will run the <code>rust_test</code> function, which is annotated with the <code>test</code> macro. You can run the browser-based tests, which are annotated with the <code>wasm_bindgen_test</code> macro, via the <code>wasm-pack test --headless --chrome</code> command. This will run the web tests using the Chrome browser, in a headless environment. You can also use <code>--firefox</code>, <code>--safari</code>, and <code>--node</code> if you wish, but you must <a id="_idIndexMarker815"/>specify what JavaScript environment you'll be running them in. Note that <code>--node</code> isn't going to work since it doesn't have a browser.</p>
			<p>We'll start writing tests using the <code>#[test]</code> macro, which runs Rust code in the native environment, just like writing a standard Rust program. The simplest thing to test is a pure functi<a id="_idTextAnchor209"/>on, so let's try that.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor210"/>Pure functions</h2>
			<p><code>#[test]</code> annotation and run with <code>cargo test</code>.</p>
			<p>The current setup runs our only Rust test in the <code>test/app.rs</code> file, which makes it, as far as Cargo is concerned, an integration test. I don't like that and prefer to use the Rust convention of writing unit tests in the file where the code is executed. In this first example, we'll test the <code>intersects</code> function on <code>Rect</code>, which is a pure function that is complicated enough to mess up. We'll add this test to the bottom of <code>engine.rs</code> because that's where <code>Rect</code> is defined, and we'll run it with <code>cargo test</code>. Let's add a test to the bottom of the module for the <code>intersect</code> method on <code>Rect</code>, as shown here:</p>
			<pre>#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn two_rects_that_intersect_on_the_left() {
        let rect1 = Rect {
            position: Point { x: 10, y: 10 },
            height: 100,
            width: 100,
        };
        let rect2 = Rect {
            position: Point { x: 0, y: 10 },
            height: 100,
            width: 100,
        };
        assert_eq!(rect2.intersects(&amp;rect1), true);
    }
}</pre>
			<p>Much of this<a id="_idIndexMarker818"/> is documented in the Rust book at <a href="https://bit.ly/3bNBH3H">https://bit.ly/3bNBH3H</a>, but a little review never hurts anyone. We start by using the <code>#[cfg(test)]</code> attribute macro to tell Cargo not to compile and run this code except <a id="_idIndexMarker819"/>when we're running tests. Then, we create a <code>tests</code> module using the <code>mod</code> keyword to isolate our tests from the rest of the code. After that, we import the <code>engine</code> code with <code>use super::*</code>. Then, we write our test by writing a function, <code>two_rects_that_intersect_on_the_left</code>, which is annotated with the <code>#[test]</code> macro so that the test runner can pick it up. The rest of this is a pretty standard test. It creates two rectangles, where the second overlaps the first, and then makes sure that the <code>intersects</code> function returns <code>true</code>. You can run this test with <code>cargo test</code>, where you'll see the following output:</p>
			<pre>    Finished test [unoptimized + debuginfo] target(s) in 1.48s
     Running target/debug/deps/rust_webpack_template-5805000a6d5d52b4
running 1 test
<strong class="bold">test engine::tests::two_rects_that_intersect_on_the_left</strong> ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
     Running target/debug/deps/app-ec65f178e238b04b
running 1 test
test rust_test ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
			<p>You'll see two <a id="_idIndexMarker820"/>sets of results. The first result <a id="_idIndexMarker821"/>references our new test, <code>two_rects_that_intersect_on_the_left</code>, which will pass. Then, you will see <code>rust_test</code> run, which will also pass. The <code>rust_test</code> test is in <code>tests\app.rs</code> and was created with the project skeleton. It is run as an integration test because it is in the <code>tests</code> directory – this is the Cargo standard. The difference between unit tests and integration tests is that the integration tests are run as a separate crate and use the production code as a separate library. This means they use the code in the same way a user of your crate would, but they cannot call internal or private functions. It's easier to get complete coverage when you're running unit tests with the caveat that they may be less realistic. Our code is not meant to be used as a crate, so we won't be using many integration tests.</p>
			<p>Now that we've written<a id="_idIndexMarker822"/> our first unit test for our code, we can write a lot more tests for this <code>intersects</code> method, including when the following occurs:</p>
			<ul>
				<li>When the rectangles overlap on the top or bottom</li>
				<li>When the rectangles overlap on the right</li>
				<li>When the rectangles <em class="italic">don't</em> overlap – that is, when the function returns false</li>
			</ul>
			<p>We should <a id="_idIndexMarker823"/>have a test for every branch in the <code>intersects</code> function. We leave these tests as an exercise for you since repeating them would be redundant. As our code base grows, it would be ideal if much of our code could easily be tested like this, but unfortunately, for this game, a lot of it interacts with the browser, so we will have two different ways to test that. The first way is to replace the browser with a stub so that we don't need to run browser-based tests. We'l<a id="_idTextAnchor211"/>l do that in the next section.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor212"/>Hiding the Browser module</h2>
			<p>Way back in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, we separated browser functions into a <code>browser</code> module. We can use this as a <strong class="bold">seam</strong> to inject test versions of the browser functions that <a id="_idIndexMarker824"/>will run as native Rust code and <a id="_idIndexMarker825"/>allow us to write tests.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The<a id="_idIndexMarker826"/> term <strong class="bold">seam</strong> comes from the book <em class="italic">Working Effectively with Legacy Code</em>, by Michael Feathers (<a href="https://amzn.to/3kas1Fa">https://amzn.to/3kas1Fa</a>). It's written in C++ and Java but is still the best book on legacy code you can find. A seam is a place where you can insert test behavior to replace real behavior, while <a id="_idIndexMarker827"/>an <strong class="bold">enabling point</strong> is a point in the code that allows that to happen.</p>
			<p>A seam is somewhere we can alter the behavior of the program without altering the code in that place. Look at the following code from the <code>game</code> module:</p>
			<pre>impl WalkTheDogState&lt;GameOver&gt; {
    ...
    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {
        browser::hide_ui();
        WalkTheDogState {
            _state: Ready,
            walk: Walk::reset(self.walk),
        }
    }
}</pre>
			<p>We'd like to<a id="_idIndexMarker828"/> test that when the game goes from the <code>GameOver</code> state to the <code>Ready</code> state, the UI is hidden. We can do this with integration tests by checking whether the <code>div</code> property <a id="_idIndexMarker829"/>that contains the UI is empty after this transition. We may want to do this, but such tests are frequently a little harder to write and maintain. This is especially true as the game grows. Another approach, which we'll use here, is to replace the <code>browser</code> module with a version of it that doesn't interact with the browser. The seam is <code>hide_ui</code>, which is a behavior we can replace without actually changing the code, while the enabling point is the <code>use</code> declaration, which is where we brought in the <code>browser</code> module.</p>
			<p>We can enable using a test version of the <code>browser</code> module with conditional compilation. In the same way that the <code>#[cfg(test)]</code> macro only includes the <code>test</code> module when compiling in test mode, we can import different versions of the <code>browser</code> module with <code>cfg</code> directives, as shown here:</p>
			<pre>#[cfg(test)]
mod test_browser;
#[cfg(test)]
use test_browser as browser;
#[cfg(not(test))]
use crate::browser;</pre>
			<p>The preceding code <a id="_idIndexMarker830"/>can be found at the top of the <code>game</code> module, where we were previously<a id="_idIndexMarker831"/> importing <code>crate::browser</code>. Here, we can use the <code>mod</code> keyword to bring the contents of the <code>test_browser</code> module in from the <code>src/game/test_browser.rs</code> file, but only when we're running a <code>test</code> build. Then, we can use <code>test_browser as browser</code> to make the functions available via <code>browser::</code> calls – again, only in test builds – in the same way as we call the <code>browser</code> production code. Finally, we can add the <code>#[cfg(not(test))]</code> annotation to <code>use crate::browser</code> to prevent the real <code>browser</code> code from being imported into the test.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I first saw this technique on Klausi's Weblog at <a href="https://bit.ly/3ENxhWQ">https://bit.ly/3ENxhWQ</a>, but it is fairly common in Rust code.</p>
			<p>If you do this and run <code>cargo test</code>, you'll see a lot of errors, such as <code>cannot find function `fetch_json` in module `browser`</code>, because even though we're importing a test module, we haven't filled it in with any code. In this situation, it's a good idea to follow the compiler errors, which will point out that there's no file yet in <code>src/game/test_browser.rs</code>. It will also list the functions that are used in the <code>game</code> module but aren't defined in our <code>test_browser.rs</code> file. To get past this, you can create the <code>test_browser.rs</code> file and bring in the bare minimum that's needed to get back to compiling, as shown here:</p>
			<pre>use anyhow::{anyhow, Result};
use wasm_bindgen::JsValue;
use web_sys::HtmlElement;
pub fn draw_ui(html: &amp;str) -&gt; Result&lt;()&gt; {
    Ok(())
}
pub fn hide_ui() -&gt; Result&lt;()&gt; {
    Ok(())
}
pub fn find_html_element_by_id(id: &amp;str) -&gt; Result&lt;HtmlElement&gt; {
    Err(anyhow!("Not implemented yet!"))
}
pub async fn fetch_json(json_path: &amp;str) -&gt; Result&lt;JsValue&gt; {
    Err(anyhow!("Not implemented yet!"))
}</pre>
			<p>As you can see, only <a id="_idIndexMarker832"/>four functions are used in <code>game</code> that have been defined in <code>browser</code>, and we've filled in just enough to compile. To use this for testing, we're going to need to place simulated implementations with some sort of state they keep track of. The<a id="_idIndexMarker833"/> other thing you may notice is that <code>JsValue</code> and <code>HtmlElement</code> are both being used in this code since they won't work when you run Rust native tests. They require a browser runtime, so to continue along this path, we'll eventually need to make test versions of <code>HtmlElement</code> and <code>JsValue</code> or create wrapper types for them, potentially in the <code>engine</code> module. Let's leave those as is for now, though, and try to write our first test using the standard Rust testing framework. We'll want to test the state machine change I mentioned previously by setting up the game in the <code>GameOver</code> state and transitioning to the <code>Running</code> state, then checking that the UI was hidden. The <em class="italic">beginning</em> of that test looks as follows:</p>
			<pre>#[cfg(test)]
mod tests {
    use super::*;
    use futures::channel::mpsc::unbounded;
    use std::collections::HashMap;
    use web_sys::{AudioBuffer, AudioBufferOptions};
    fn test_transition_from_game_over_to_new_game() {
        let (_, receiver) = unbounded();
        let image = HtmlImageElement::new().unwrap();
        let audio = Audio::new().unwrap();
        let options = AudioBufferOptions::new(1, 3000.0);
        let sound = Sound {
            buffer: AudioBuffer::new(&amp;options).unwrap(),
        };
        let rhb = RedHatBoy::new(
            Sheet {
                frames: HashMap::new(),
            },
            image.clone(),
            audio,
            sound,
        );
        let sprite_sheet = SpriteSheet::new(
            Sheet {
                frames: HashMap::new(),
            },
            image.clone(),
        );
        let walk = Walk {
            boy: rhb,
            backgrounds: [
                Image::new(image.clone(), Point { x: 0, y: 
                  0 }),
                Image::new(image.clone(), Point { x: 0, y: 
                  0 }),
            ],
            obstacles: vec![],
            obstacle_sheet: Rc::new(sprite_sheet),
            stone: image.clone(),
            timeline: 0,
        };
        let state = WalkTheDogState {
            _state: GameOver {
                new_game_event: receiver,
            },
            walk: walk,
        };
    }
}</pre>
			<p>Oh boy – that's a lot of code to test a few lines of Rust, and it's not even a complete test yet. It's just <a id="_idIndexMarker834"/>setting up the game in the state that we need it to be in <em class="italic">before</em> we transition into a <code>Ready</code> state. A lot is being revealed about our design, specifically that it's what I may call <em class="italic">naïve'</em>. It's very hard to construct objects, and while the <code>game</code>, <code>engine</code>, and <code>browser</code> modules are separate, they are still pretty tightly coupled. It works but it in a fashion that only solves the problem in front of us. That's completely acceptable – we had specific goals to build a small endless runner and we did it, but this also means that if we wanted to start extending our game engine so that it's more flexible, we would need to make further changes. I tend <a id="_idIndexMarker835"/>to view software design more like sculpting than constructing. You start with a big block of code and chip away at it until it looks like what you want, rather than a blueprint that you follow to get the perfect house.</p>
			<p>Some of the aspects of our design that this test is revealing are as follows:</p>
			<ul>
				<li>It's not easy to create new <code>Walk</code> structures.</li>
				<li>The <code>game</code> module is far more coupled to <code>web-sys</code> and <code>wasm-bindgen</code> than we thought.</li>
			</ul>
			<p>We made the intentional choice not to try and create perfect abstractions early in the project. This is one of the reasons we didn't write this code in a test-driven style initially. TDD would have strongly pushed in the direction of further abstraction and layering, which would have hidden the game code we're trying to learn here. As an example, instead of using <code>HtmlImageElement</code> or <code>AudioBuffer</code>, we may have written wrappers or abstractions around those objects (we already have an <code>Image</code> struct), which is probably better for growing our project in the medium to long term but is harder to understand in the short term.</p>
			<p>This is a long-winded way of saying that this code is now hard to write isolated unit tests for because we didn't build it with them in mind. If you were able to run this test, you would see the following:</p>
			<pre>thread 'game::tests::test_transition_from_game_over_to_new_game' panicked at 'cannot call wasm-bindgen imported functions on non-wasm targets', /Users/eric/.cargo/registry/src/github.com-1ecc6299db9ec823/web-sys-0.3.52/src/features/gen_HtmlImageElement.rs:4:1</pre>
			<p>It turns out that even though we replaced the production <code>browser</code> with <code>test_browser</code>, we're still trying to call browser code. I have already pointed out <code>HtmlElement</code> and <code>JsValue</code>, but this test also includes <code>AudioBuffer</code> and <code>AudioBufferOptions</code>. As is, this code doesn't compile without more feature flags being enabled and <a id="_idIndexMarker836"/>changes being made to <code>engine</code>. It's just too tightly coupled to the browser still.</p>
			<p>The act of<a id="_idIndexMarker837"/> trying to use this code in a test harness demonstrated the power of coupling, and it is often useful to take legacy code and get it into a harness to identify these dependency problems and break them. Unfortunately, this is a time-consuming process that we are not going to continue using in this section, although it may appear on my blog at <a href="http://paytonrules.com">paytonrules.com</a> at some point. Instead, we'll test th<a id="_idTextAnchor213"/>is code via a test that runs in the browser.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor214"/>Browser tests</h2>
			<p>At the beginning <a id="_idIndexMarker838"/>of this chapter, I mentioned that there were <strong class="bold">unit tests</strong> and <strong class="bold">browser tests</strong>. The distinction is that while browser tests may test the same <a id="_idIndexMarker839"/>behavior as a unit test, they automate the desired behavior in a headless browser. This makes the test more realistic, but also slower and more prone to breaking for flaky reasons. I prefer my systems to have a large base of unit tests and a smaller number of more integrated tests to make sure everything is all wired together correctly, but we can't always get what we want.</p>
			<p>Instead, we'll get what we need – verification of the behavior – by skipping dependency-breaking techniques for legacy code and writing a test that runs in the browser. We'll remove the code that added <a id="_idIndexMarker840"/>the <code>test_browser</code> module, as well as the <code>test_browser</code> file itself. We'll keep the test we wrote previously and make two changes for it to compile, as follows:</p>
			<ol>
				<li>Add <code>AudioBufferOptions</code> to the list of <code>web-sys</code> features in <code>Cargo.toml</code>.</li>
				<li>In the <code>engine</code> module, make the <code>buffer</code> field on the <code>Sound</code> struct public so that we can create <code>Sound</code> directly in this test.</li>
			</ol>
			<p>These two changes will get the code compiling, but it won't make it run in the tests yet. For that, we need to make a couple of changes. First, we need to change the <code>#[test]</code> macro to <code>#[wasm_bindgen_test]</code>. Then, we need to add two statements to our <code>test</code> module, as shown here:</p>
			<pre><strong class="bold">#[cfg(test)]</strong>
mod tests {
    use super::*;
    use futures::channel::mpsc::unbounded;
    use std::collections::HashMap;
    use web_sys::{AudioBuffer, AudioBufferOptions};
    <strong class="bold">use wasm_bindgen_test::wasm_bindgen_test;</strong>
    <strong class="bold">wasm_bindgen_test::wasm_bindgen_test_configure!</strong>
<strong class="bold">        (run_in_browser);</strong>
    <strong class="bold">#[wasm_bindgen_test]</strong>
    fn test_transition_from_game_over_to_new_game() {
        ...</pre>
			<p>The <a id="_idIndexMarker841"/>first line to add is <code>use wasm_bindgen_test::wasm_bindgen_test</code> so that the macro is present. The second is <code>wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);</code>. This <a id="_idIndexMarker842"/>directive tells the test runner to run in the browser so that the code can interact with the DOM, similar to how the application does. This test won't run in <code>cargo test</code>, so you'll need to use the <code>wasm-pack test --headless –chrome</code> command. This will run the web tests in a headless version of the Chrome browser. When you run them, you should see the following output:</p>
			<pre>running 1 test
test rust_webpack_template::game::tests::test_transition_from_game_over_to_new_game … ok</pre>
			<p>Now, we have a test that's running and passing, but the only problem is that we don't have any assertions. We've written an "arrange" step but we haven't checked the results. The point <a id="_idIndexMarker843"/>of this test was to make sure that the UI was hidden when the state transition happened, so we'll need to update the test to check that. We can do this by adding the action <a id="_idIndexMarker844"/>and assertion steps, as shown here:</p>
			<pre>#[wasm_bindgen_test]
fn test_transition_from_game_over_to_new_game() {
    ...
    <strong class="bold">let document = browser::document().unwrap();</strong>
    <strong class="bold">document</strong>
        <strong class="bold">.body()</strong>
        <strong class="bold">.unwrap()</strong>
       <strong class="bold"> .insert_adjacent_html("afterbegin", "&lt;div </strong>
<strong class="bold">            id='ui'&gt;&lt;/div&gt;")</strong>
        <strong class="bold">.unwrap();</strong>
    <strong class="bold">browser::draw_ui("&lt;p&gt;This is the UI&lt;/p&gt;").unwrap();</strong>
    let state = WalkTheDogState {
        _state: GameOver {
            new_game_event: receiver,
        },
        walk: walk,
    };
    <strong class="bold">state.new_game();</strong>
    <strong class="bold">let ui =  </strong>
<strong class="bold">        browser::find_html_element_by_id("ui").unwrap();</strong>
    <strong class="bold">assert_eq!(ui.child_element_count(), 0);</strong>
}</pre>
			<p>Here, we start the test by inserting the <code>div</code> property, along with the <code>ui</code> ID, into the document – after all, that is in <code>index.html</code> in the game. Then, <code>browser::draw_ui</code> draws the UI to the browser, even though the browser is running headlessly, so we don't see it. We continue by creating <code>WalkTheDogState</code> in the <code>GameOver</code> state; on the next line, we have it transition to <code>Ready</code> via the <code>state.new_game()</code> method. Finally, we check that the UI was cleared by finding the <code>div</code> property and checking its <code>child_element_count</code>. If it's <code>0</code>, the code is right, and this test will pass. If <a id="_idIndexMarker845"/>you run this test, you'll see that this test <em class="italic">does</em> pass, so you will probably want to comment out the <code>let next_state: WalkTheDogState&lt;Ready&gt; = state.</code><code>()</code> line and run it again just to make sure it fails when the transition happens.</p>
			<p>This is still <a id="_idIndexMarker846"/>a very long test but at least it's working. The test can be cleaned up by creating some factory methods in the various modules so that structs are easier to create. You'll notice that the test is full of <code>unwrap</code> calls. This is because, in a test, I want things to crash right away if they aren't as expected. Unfortunately, browser-based tests with the <code>wasm_bindgen_test</code> macro do not let you return a <code>Result</code> for readability as standard Rust tests do yet. This is another reason you sho<a id="_idTextAnchor215"/>uld try and make your tests run as native Rust tests.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor216"/>Async tests</h2>
			<p>One of the <a id="_idIndexMarker847"/>biggest challenges of testing web applications, whether they're Wasm or traditional JavaScript ones, is code that occurs <code>async</code> block or function. Imagine calling a function in<a id="_idIndexMarker848"/> an <code>async</code> test and then immediately trying to verify it worked. By definition, you can't, because it's running asynchronously and may not have finished yet. Fortunately, <code>wasm_bindgen_test</code> handles this rather easily by making the test's functions <code>async </code>themselves.</p>
			<p>Let's look at a simpler <a id="_idIndexMarker849"/>example and try to write a test for the <code>load_json</code> function in the <code>browser</code> module:</p>
			<pre>#[cfg(test)]
mod tests {
    use super::*;
    use wasm_bindgen_test::wasm_bindgen_test;
    wasm_bindgen_test::wasm_bindgen_test_configure!
        (run_in_browser);
    #[wasm_bindgen_test]
    async fn test_error_loading_json() {
        let json = fetch_json("not_there.json").await;
        assert_eq!(json.is_err(), true);
    }
}</pre>
			<p>This can be<a id="_idIndexMarker850"/> found in the <code>browser</code> module. Here, we start with the boilerplate to set up a <code>tests</code> module, import both <code>browser</code> and <code>wasm_bindgen_test</code>, and configure the test to run in the browser. The test itself is only two lines. Try to load a <code>JSON</code> file that doesn't exist and report an error. The key difference between this is that the test is <code>async</code>, which allows us to use <code>await</code> in the test and write the assertion without adding any "wait for" logic. This is great, but there are a couple of things to keep in mind:</p>
			<ul>
				<li>If <code>fetch_json</code> can hang, this test will hang.</li>
				<li>This test will try to load a file. Ideally, we don't want to do this in a unit test.</li>
			</ul>
			<p>This test will run and pass. We could test all of the <code>browser</code> functions this way, accepting that the <code>browser</code> module's tests will use the filesystem as needed. That's probably what I would do if I was handed this system in a professional environment. You could work very hard to stub out the actual browser on these tests, but to do so would remove its ability to prevent defects. After all, if you remove the browser from the <code>browser</code> module, then how do you know you got the code right?</p>
			<p>If I was given this <a id="_idIndexMarker851"/>code and asked to maintain it, I would likely adopt the following strategies:</p>
			<ul>
				<li>Curse the name of the jerk who wrote it without tests (me!).</li>
				<li>Write tests for code as I need to change it. If it doesn't change, don't bother. Go ahead and use browser automation, as we did previously.</li>
				<li>Over time, move more code that depends on <code>wasm-bindgen</code> and <code>web-sys</code> into the <code>browser</code> module so that <code>engine</code> and <code>game</code> can stub it out.</li>
				<li>Write as many tests as possible as Rust-native tests, and then make the browser-based unit tests native whenever possible.</li>
			</ul>
			<p>As for <a id="_idIndexMarker852"/>integration tests, I doubt I would write any integration tests in the Cargo sense. For Cargo libraries, all the integration tests are written in the <code>tests</code> directory and compiled as a separate package. This is a great idea when you're writing a library that's going to be consumed by other people, but we are writing an application and aren't providing an API. The integration tests I would write would be any tests that use the real browser, but those are integration tests in the sense that they are integrated with the web browser, not that they run as Rust integration tests.</p>
			<p>However, we can't just rely on adding tests to make sure our code works. Sometimes, we just have to debug it. Let's dig into that next.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor217"/>Debugging the game</h1>
			<p>To<a id="_idIndexMarker853"/> debug a traditional program, be it in Java, C#, or C++, we must set breakpoints and step through the code. In JavaScript, we can type the word <code>debugger</code> to set a breakpoint, but although WebAssembly runs in the browser, it isn't JavaScript. So, how do we debug it?</p>
			<p>There's a lot <a id="_idIndexMarker854"/>of conflicting information about debugging with WebAssembly. How do you debug WebAssembly? Well, according to the official Rust WebAssembly documentation, it's simple – you can't!</p>
			<p class="author-quote">Unfortunately, the debugging story for WebAssembly is still immature. On most Unix systems, DWARF is used to encode the information that a debugger needs to provide source-level inspection of a running program. There is an alternative format that encodes similar information on Windows. Currently, there is no equivalent for WebAssembly. Therefore, debuggers currently provide limited utility, and we end up stepping through raw WebAssembly instructions emitted by the compiler, rather than the Rust source text we authored.  </p>
			<p class="author-quote">– <a href="https://rustwasm.github.io/docs/book/reference/debugging.html">https://rustwasm.github.io/docs/book/reference/debugging.html</a></p>
			<p>So, there you have it – no debugging, section over. That was easy.</p>
			<p>But it's not that simple. Of course, you can debug your application – you just can't use your browser's developer tools to step through the Rust code in a debugger. The technology isn't there yet. But that doesn't mean we don't debug; it just means we'll take more of an old-school approach to debugging. </p>
			<p>Earlier, I mentioned that when I write code, I typically write a lot of tests. I also typically don't use a debugger very often. If we break our code into smaller chunks that can be easily exercised by tests, a debugger is rarely required. That said, we didn't do that for this project, so we'll need a way to debug existing code. We'll start by logging, then getting stack traces, and finally using linters to prevent bugs before they happen.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The reality is not as cut and dry as the Rust Wasm site would state. Chrome developer tools have added support<a id="_idIndexMarker855"/> for the <code>wasm-bindgen</code> at the time of writing. You can see progress on this issue here: <a href="https://github.com/rustwasm/wasm-bindgen/issues/2389">https://github.com/rustwasm/wasm-bindgen/issues/2389</a>. By the time you read this book, the debugging tools may be modernized in Rust Wasm, as well as in browsers outside of Chrome, but for the time being, we must use more traditional tools such as <code>println!</code> and logging.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor218"/>Log versus error versus panic </h2>
			<p>If you've been following along and got confused at some point, then you've probably used the <code>log!</code> macro we wrote in <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>, to see what was going on. If you have been doing that, congratulations! You've been debugging the same way I did <a id="_idIndexMarker856"/>when I wrote the code originally. Print line debugging is still standard in many languages and it's pretty much the only form of debugging that's guaranteed to work anywhere. If you haven't done that, then it looks like this:</p>
			<pre>impl WalkTheDogStateMachine {
    fn update(self, keystate: &amp;KeyState) -&gt; Self {
        <strong class="bold">log!("Keystate is {:#?}", keystate);</strong>
        match self {
            WalkTheDogStateMachine::Ready(state) =&gt; 
                state.update(keystate),
            WalkTheDogStateMachine::Walking(state) =&gt; 
                state.update(keystate),
            WalkTheDogStateMachine::GameOver(state) =&gt; 
               state.update(),
        }
    }</pre>
			<p>In the preceding example, we are<a id="_idIndexMarker857"/> logging <code>KeyState</code> on every tick through the <code>update</code> function. This isn't a great log because it's going to show an empty <code>KeyState</code> 60 times a second, but it's good enough for our purposes. However, there's one flaw in this log: <code>KeyState</code> doesn't implement the <code>Debug</code> trait. You can add it by adding the <code>derive(Debug)</code> annotation to the <code>KeyState</code> struct, like so:</p>
			<pre><strong class="bold">#[derive(Debug)]</strong>
pub struct KeyState {
    pressed_keys: HashMap&lt;String, web_sys::KeyboardEvent&gt;,
}</pre>
			<p>When you add <a id="_idIndexMarker858"/>this, the console will log all your key state changes, which will be useful if your keyboard input is broken:</p>
			<div><div><img alt="Figure 9.1 – Logging KeyState" src="img/Figure_9.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Logging KeyState</p>
			<p>In general, any <code>pub struct</code> should <code>use</code> <code>#[derive(Debug)]</code>, but this isn't the default option<a id="_idIndexMarker859"/> since it could make compile times long on large projects. When in doubt, go ahead and <code>use</code> <code>#[derive(Debug)]</code> and log the information. Now, maybe <code>log!</code> isn't noticeable enough for you, and you want the text to be bright, obvious, and red. For that, you'll need to use <code>console.error</code> in JavaScript and write a macro such as the <code>log</code> macro, which<a id="_idIndexMarker860"/> we already have in the <code>browser</code> module. This macro looks like this:</p>
			<pre>macro_rules! error {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::error_1(&amp;format!( $( $t )* 
            ).into());
    }
}</pre>
			<p>This is the same as the <code>log</code> macro but uses the <code>error</code> function on the <code>console</code> object. There are two advantages to the <code>error</code> function. The first is that it's red, while the other is that it also will <a id="_idIndexMarker861"/>show you the stack trace. Here's an example of <code>error</code> being called when the player is knocked out in Chrome:</p>
			<div><div><img alt="Figure 9.2 – Error log" src="img/Figure_9.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Error log</p>
			<p>It's not the most readable stack trace in the world, but after seeing a few lines of the <code>console::error_1</code> function, you can see that this log was called from <code>WalkTheDogState&lt;Walking&gt;::end_game</code>. This log is really for true errors, as opposed to just informational logging, and this stack trace may not show up clearly in all browsers. You'll also want to be cautious with leaving this log in the production code as you may not want to expose this much information to a curious player. We'll want to make sure it's not in the production deployment, which we'll create in <a href="B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226"><em class="italic">Chapter 10</em></a>, <em class="italic">Continuous Deployment</em>.</p>
			<p>Finally, if you want to make sure the program stops when an error occurs, we'll want to go ahead and use the <code>panic</code>! macro. Some errors are recoverable but many are not, and we don't want our program to limp along in a broken state. In <a href="B17151_01_Final_PG_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Hello WebAssembly</em>, we included the <code>console-error-panic-hook</code> crate so that if the program were to panic, we'd get a stack trace. Let's<a id="_idIndexMarker862"/> replace calling <code>error</code>! with calling <code>panic</code>! and see the difference:</p>
			<div><div><img alt="Figure 9.3 – Panic log&#13;&#10;" src="img/Figure_9.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Panic log</p>
			<p>Here, you can see it looks a little different, but the information is mostly the same. There is one thing at the very top where it says <code>src/game.rs:829</code>, which tells you exactly where <code>panic</code> was called. In general, you will probably prefer to use <code>panic</code> compared to <code>error</code> if you need to have the error in your production code because that kind of error should be rare and fail fast. The <code>error</code> function is more useful during debugging, so you'll end up removing those.</p>
			<p>There's another kind of error that we've been ignoring at times, and that's the warnings and errors that are given to you by the compiler and linter. We can use the Rust ecosystem's tools to detect mistakes before we ever run the program. Let's look into that now.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor219"/>Linting and Clippy </h2>
			<p>One of the features that makes the Rust compiler great is that it has a linter built into it, in addition to the warnings <a id="_idIndexMarker863"/>and errors it already provides. If you're unfamiliar, a linter is a static code analysis tool that typically finds style errors and, potentially, logic errors above and beyond what the compiler can find. The term comes from the lint you find on clothing, so you can think of using a linter like rubbing a lint brush on your code. We've been getting some warnings from the compiler that we've been ignoring for a while now, most of which look like this:</p>
			<pre>warning: unused `std::result::Result` that must be used
   --&gt; src/game.rs:241:9
    |
241 |         browser::hide_ui();
    |         ^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(unused_must_use)]` on by default
    = note: this `Result` may be an `Err` variant, which should be handled</pre>
			<p>These are all cases <a id="_idIndexMarker864"/>where an error could occur, but we probably don't want to crash if it does, so panicking or calling <code>unwrap</code> isn't an option. Propagating the <code>Result</code> type is an option, but I don't think we want to prevent moving from one state to another if there's a small browser issue. So, instead, we'll use the <code>error</code> case to log here. You can see it at <code>https://bit.ly/3q1936N</code> in the sample source code. Let's modify the code so that we log any errors:</p>
			<pre>impl WalkTheDogState&lt;GameOver&gt; {
    ...
    fn new_game(self) -&gt; WalkTheDogState&lt;Ready&gt; {
        <strong class="bold">if let Err(err) = </strong>browser::hide_ui() {
            <strong class="bold">error!("Error hiding the browser {:#?}", err);</strong>
        <strong class="bold">}</strong>
        WalkTheDogState {
            _state: Ready,
            walk: Walk::reset(self.walk),
        }
    }
}</pre>
			<p>Here, we have<a id="_idIndexMarker865"/> changed the <code>browser::hide_ui()</code> line to <code>if let Err(err) = browser::hide_ui()</code> and we log if an error occurs. We can see what that error log will look like by forcing <code>hide_ui</code> to return an error for a moment:</p>
			<div><div><img alt="Figure 9.4 – A fake error&#13;&#10;" src="img/Figure_9.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – A fake error</p>
			<p>The stack trace is cut off in book form, but you can see that we got an error log with <code>Error hiding the browser</code> and then <code>This is the error in the hide_ui function</code>, which is the error message I forced into <code>hide_ui</code>. The stack trace also shows <code>game::Ready</code>, which would show you that you were transitioning into the <code>Ready</code> state if you had infinite room to show the entire message.</p>
			<p>Every single warning that's being generated should be dealt with. Most of the warnings are the same kind – that is, <code>Result</code> types where the <code>Err</code> variant is ignored. These can be removed by handling the <code>Err</code> case with a log or by calling <code>panic</code> if the game should truly crash at this time. For the most part, I've used the <code>if let</code> pattern but if <code>request_animation_frame</code> fails, then I just use <code>unwrap</code>. I don't see how the game could work if that's failing.</p>
			<p>There is one more warning we've been ignoring that we should address, as shown here:</p>
			<pre>warning: associated function is never used: `draw_rect`
   --&gt; src/engine.rs:106:12
    |
106 |     pub fn draw_rect(&amp;self, bounding_box: &amp;Rect) {
    |            ^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default</pre>
			<p>This warning is a<a id="_idIndexMarker866"/> little unique because we used this function <em class="italic">for debugging</em>. You may not want to draw rectangles in your game, but it's essential for debugging collision boxes, as we did in <a href="B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Collision Detection</em>, so we'll want it to be available. To keep it around, let's annotate it with the <code>allow</code> keyword, like so:</p>
			<pre>impl Renderer {
    ...
    <strong class="bold">#[allow(dead_code)]</strong>
    pub fn draw_rect(&amp;self, bounding_box: &amp;Rect) {</pre>
			<p>This should leave the compilation error-free, but there's one more tool we can use to see whether our code could be improved. If you've spent much time in the Rust ecosystem, then you've probably<a id="_idIndexMarker867"/> heard of <code>Cargo.toml</code> file but to the current system itself. Installation is simple, and you may have done it at some point and forgotten about it, but if you haven't, it's one shell command:</p>
			<pre>rustup component add clippy</pre>
			<p>Once you've installed <a id="_idIndexMarker868"/>Clippy, you can run <code>cargo clippy</code> and see all the other ways we wrote bad Rust code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When the code is great, I wrote it and you followed along. When it's bad, we did it together. I don't make the rules.</p>
			<p>When I run <code>cargo clippy</code>, I get <code>17</code> warnings, but your number could be different, depending on when you<a id="_idIndexMarker869"/> run it. I'm not going to go through each one, but let's highlight one error:</p>
			<pre>warning: writing `&amp;Vec&lt;_&gt;` instead of `&amp;[_]` involves one more reference and cannot be used with non-Vec-based slices.
   --&gt; src/game.rs:945:29
    |
945 | fn rightmost(obstacle_list: &amp;Vec&lt;Box&lt;dyn Obstacle&gt;&gt;) -&gt; i16 {
    |                             ^^^^^^^^^^^^^^^^^^^^^^^ help: change this to: `&amp;[Box&lt;dyn Obstacle&gt;]`
    |
    = note: `#[warn(clippy::ptr_arg)]` on by default
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg</pre>
			<p>The <code>rightmost</code> function in the <code>game</code> module can be made to use one less reference and be made more flexible. <code>help</code> here is great because it tells me exactly what to do to fix it. So, let's change the <code>rightmost</code> function signature so that it looks as follows:</p>
			<pre>fn rightmost(obstacle_list: &amp;[Box&lt;dyn Obstacle&gt;]) -&gt; i16 {</pre>
			<p>This doesn't fix any bugs but it does remove a Clippy warning and makes the method more flexible.</p>
			<p>It's very <a id="_idIndexMarker870"/>common for Clippy to inform you of better idioms you could be using. One Clippy warning I wanted to highlight looks like this:</p>
			<pre>warning: match expression looks like `matches!` macro
   --&gt; src/game.rs:533:9
    |
533 | /         match self {
534 | |             RedHatBoyStateMachine::KnockedOut(_) =&gt; true,
535 | |             _ =&gt; false,
536 | |         }
    | |_________^ help: try this: `matches!(self, RedHatBoyStateMachine::KnockedOut(_))`
    |
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro</pre>
			<p>I had this error <a id="_idIndexMarker871"/>occur quite a bit in earlier versions of the code. I wasn't aware that the <code>matches!</code> macro existed before I ran Clippy, but what it does is handle the exact case where you need to check whether an <code>enum</code> is a specific case you're looking for. That's why the code now uses what Clippy suggests, which is in <code>impl</code> <code>RedHatBoyStateMachine</code>:</p>
			<pre>impl RedHatBoyStateMachine {
    ...
    fn knocked_out(&amp;self) -&gt; bool {
        matches!(self, RedHatBoyStateMachine::KnockedOut(_))
    }</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Many editors make it very easy to enable Clippy as part of syntax checking so that you don't need to run it explicitly. If you can enable it, you should do so.</p>
			<p>Many of the other errors are about overusing <code>clone</code> and using <code>into</code> when it isn't necessary. I highly recommend going through the code and fixing those, taking another moment to understand why they were flagged. In <a href="B17151_10_Final_PG_ePub.xhtml#_idTextAnchor226"><em class="italic">Chapter 10</em></a>, <em class="italic">Continuous Deployment</em>, we'll add Clippy to <a id="_idIndexMarker872"/>our build process so that we don't have to keep putting up with these errors.</p>
			<p>At this point, the code has been tested (a little) and we've handled every compiler error and warning we can think of. It's safe to say that the game works, but is it fast enough? The next thing to check is its performance. So, let's do that now.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor220"/>Measuring performance with a browser</h1>
			<p>The first step in<a id="_idIndexMarker873"/> debugging performance is answering the question, <em class="italic">Do you have a performance problem?</em> Too many developers, especially game developers, worry too early about performance and introduce complex code for a performance gain that just isn't there.</p>
			<p>For example, do you know why so much of this code uses <code>i16</code> and <code>f16</code>? Well, when I was going back to school a few years ago, I took a game optimization class in C++, where our final project needed to optimize a particle system. The biggest performance gains were to convert 32-bit integers into 16-bit integers. As my professor would say, "<em class="italic">We got to the moon on 16-bit!</em>" So, when I was writing this code, I internalized the lesson and made the variables 16-bit unless they were being sent to JavaScript, where everything is 32-bit anyway. Well, allow <a id="_idIndexMarker874"/>me to quote directly from the WebAssembly specification (found at <a href="https://webassembly.github.io/spec/core/syntax/types.html">https://webassembly.github.io/spec/core/syntax/types.html</a>):</p>
			<p class="author-quote">Number types classify numeric values.</p>
			<p class="author-quote">The <em class="italic">i32</em> and <em class="italic">i64</em> types classify 32- and 64-bit integers, respectively. Integers are not inherently signed or unsigned; their interpretation is determined by individual operations.</p>
			<p class="author-quote">The <em class="italic">f32</em> and <em class="italic">f64</em> types classify 32- and 64-bit floating-point data, respectively. They correspond to the respective binary floating-point representations, also known as single and double precision, as defined by the IEEE 754-2019 standard (Section 3.3).</p>
			<p>It turns out that WebAssembly doesn't support a 16-bit numeric value, so all of the optimization to <code>i16</code> is pointless. It's not harming anything and it's not worth going back to change it, but it reinforces the first rule of<a id="_idIndexMarker875"/> optimization: <strong class="bold">measure first</strong>. With that in mind, let's investigate two different ways to measure the performance of our game.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor221"/>Frame rate counter </h2>
			<p>There are <a id="_idIndexMarker876"/>two ways our game can perform poorly: by using too much memory and slowing the frame rate. The second of those is far more important, especially for a small game like this, so we'll want to start looking at frame rate first. If the frame rate consistently lags, our game loop will account for it as best it can, but the game will look jittery and respond poorly. So, we need to know the current frame rate, and the best way to do that is to draw it on the screen.</p>
			<p>We'll start by adding a function, <code>draw_text</code>, that will draw arbitrary text on the screen. This is debug text, so similarly to the <code>draw_rect</code> function, we'll need to disable the warning that says the code is unused. Writing text is a function of <code>Renderer</code> in the <code>engine</code> module, as shown here:</p>
			<pre>impl Renderer {
    ...
    #[allow(dead_code)]
    pub fn draw_text(&amp;self, text: &amp;str, location: &amp;Point) -&gt; Result&lt;()&gt; {
        self.context.set_font("16pt serif");
        self.context
            .fill_text(text, location.x.into(), 
                location.y.into())
            .map_err(|err| anyhow!("Error filling text 
                {:#?}", err))?;
        Ok(())
    }
}</pre>
			<p>We've hardcoded the font here because this is for debugging purposes only, so it's not worth customizing. Now, we need to add a frame rate calculator to the game loop, which is in the <code>start</code> method of <code>GameLoop</code> in the <code>engine</code> module. You can refresh your memory on how it works by reviewing <a href="B17151_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating a Game Loop</em>. The frame rate can be calculated by taking the difference between the last two frames, dividing by 1,000, to get from milliseconds to seconds, and calculating its inverse (which is 1 divided by the number). This is simple but it will lead to the frame rate fluctuating wildly on screen and won't show very useful information. What we can do instead is update the frame rate every second so that we can get a fairly stable indicator of performance on screen.</p>
			<p>Let's add<a id="_idIndexMarker877"/> that code to the <code>engine</code> module. We'll start with a standalone function that will calculate the frame rate every second in the <code>start</code> method, as shown here:</p>
			<pre>unsafe fn draw_frame_rate(renderer: &amp;Renderer, frame_time: f64) {
    static mut FRAMES_COUNTED: i32 = 0;
    static mut TOTAL_FRAME_TIME: f64 = 0.0;
    static mut FRAME_RATE: i32 = 0;
    FRAMES_COUNTED += 1;
    TOTAL_FRAME_TIME += frame_time;
    if TOTAL_FRAME_TIME &gt; 1000.0 {
        FRAME_RATE = FRAMES_COUNTED;
        TOTAL_FRAME_TIME = 0.0;
        FRAMES_COUNTED = 0;
    }
    if let Err(err) = renderer.draw_text(
        &amp;format!("Frame Rate {}", FRAME_RATE),
        &amp;Point { x: 400, y: 100 },
    ) {
        error!("Could not draw text {:#?}", err);
    }
}</pre>
			<p>Oh no – it's an <code>unsafe</code> function! It's the first one in this book, and probably the last. We're using an <code>unsafe</code> function here because of the <code>static mut</code> variables – that is, <code>FRAMES_COUNTED</code>, <code>TOTAL_FRAME_TIME</code>, and <code>FRAME_RATE</code> – which are not safe in a multithreaded environment. We know that this function won't be called in a multithreaded way, and we also know that if it was called, it would just show a weird frame rate value. It's not something I generally recommend, but in this case, we don't want to pollute <code>GameLoop</code> or the <code>engine</code> module with those values or put them in thread-safe types. After all, we wouldn't want to have our frame rate calculator take too long because of a bunch of <code>Mutex</code> lock calls. So, we'll accept that this debugging function is <code>unsafe</code>, shiver in fear for a moment, and move on.</p>
			<p>The <a id="_idIndexMarker878"/>function starts by setting up the initial <code>FRAMES_COUNTED</code>, <code>TOTAL_FRAME_TIME</code>, and <code>FRAME_RATE</code> values. On each call to <code>draw_frame_rate</code>, we update <code>TOTAL_FRAME_TIME</code> and the number of <code>FRAMES_COUNTED</code>. When <code>TOTAL_FRAME_TIME</code> has passed <code>1000</code>, this means that 1 second has elapsed, since <code>TOTAL_FRAME_TIME</code> is in milliseconds. We can set <code>FRAME_RATE</code> to the number of <code>FRAMES_COUNTED</code> because that's the literal <code>draw_text</code> function we just created. This function is going to be called last on every frame, which is important because if it isn't, we would draw the game right over the top of the frame rate. If we didn't draw the frame rate on every frame, we also wouldn't see it except for brief flickers on the screen, which is hardly suitable for debugging.</p>
			<p>Now, let's add the call to <code>GameLoop</code>, in the <code>start</code> function, as shown here:</p>
			<pre>impl GameLoop {
    pub async fn start(game: impl Game + 'static) -&gt; Result&lt;()&gt; {
        ...
        *g.borrow_mut() = Some(browser::create_raf_closure
             (move |perf: f64| {
            process_input(&amp;mut keystate, &amp;mut 
                keyevent_receiver);
            <strong class="bold">let frame_time = perf - game_loop.last_frame;</strong>
            <strong class="bold">game_loop.accumulated_delta += frame_time as </strong>
<strong class="bold">                f32;</strong>
            while game_loop.accumulated_delta &gt; FRAME_SIZE {
                game.update(&amp;keystate);
                game_loop.accumulated_delta -= FRAME_SIZE;
            }
            game_loop.last_frame = perf;
            game.draw(&amp;renderer);
            <strong class="bold">if cfg!(debug_assertions) {</strong>
                <strong class="bold">unsafe {</strong>
                    <strong class="bold">draw_frame_rate(&amp;renderer, frame_time);</strong>
                <strong class="bold">}</strong>
            <strong class="bold">}</strong>
            ...</pre>
			<p>The <code>game_loop.accumlated_delta</code> line has changed slightly, pulling the calculation<a id="_idIndexMarker880"/> for the length of the frame into a temporary variable, <code>frame_time</code>. Then, after drawing, we check whether we are in debug/development mode through the check for <code>if cfg!(debug_assertions)</code>. This will ensure that this doesn't show up in the deployed code. If we are in debug mode, we call <code>draw_frame_rate</code> inside an <code>unsafe</code> block. We send that function <code>renderer</code> and <code>frame_time</code>, which we just pulled into a temporary variable. Adding this code gives us a clear measurement of the frame rate on the screen:</p>
			<div><div><img alt="Figure 9.5 – Showing the frame rate" src="img/Figure_9.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Showing the frame rate</p>
			<p>On my<a id="_idIndexMarker881"/> machine, the frame rate is a steady <code>60</code>, with an occasional blip that isn't consistent. That's great unless you're writing a chapter on debugging performance issues. Then, you may have a problem.</p>
			<p>Fortunately, in early drafts, there was one time when the frame rate dropped, and that was when the RHB crashed into a rock. When the <code>index.html</code>. In other words, we must delete the highlighted code in <code>index.html</code>:</p>
			<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;My Rust + Webpack project!&lt;/title&gt;
  &lt;link rel="stylesheet" href="styles.css" type="text/css" 
      media=
  "screen"&gt;
  <strong class="bold">&lt;link rel="preload" as="image" href="Button.svg"&gt;</strong>
  <strong class="bold">&lt;link rel="preload" as="font" href=</strong>
<strong class="bold">  "kenney_future_narrow-webfont.woff2"&gt;</strong>
&lt;/head&gt;</pre>
			<p>If you <a id="_idIndexMarker882"/>delete the preloaded assets, you should see the see frame rate dip briefly. Displaying the frame rate is a great way to make sure that you, as a developer, see performance issues right away. If the frame rate dips, then you've got a problem, just like we have when we don't preload the assets. Sometimes, we need more than just a frame rate counter. So, let's leave the preload code deleted and see the performance problem in the browser debugger.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor222"/>Browser debugger </h2>
			<p>Every <a id="_idIndexMarker883"/>modern browser has developer tools, but I'll be using Chrome for this section as it's the one most popular with developers. In general, they all look similar to each other. To get performance information, I must start the game and open the developer tools in Chrome. Then, I must right-click and click <strong class="bold">Inspect</strong>, though there are plenty of other ways to open the tools. From there, I must click the <strong class="bold">Performance</strong> tab and start recording. Then, I must run RHB into a rock and stop recording. Since I know I've got a specific spot with a performance dip, I want to get to it as quickly as possible to hide any noise in the debugger from other code. After I do that, I will see a graph, like this:</p>
			<div><div><img alt="Figure 9.6 – The Performance tab" src="img/Figure_9.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – The Performance tab</p>
			<p>That's a lot of noise, but you can see that the graph changes. There's a pink blob on the <strong class="bold">Frames</strong> row, which shows that something happened there. I can select the section that looks like a hill with my cursor and drag it to zoom in on it. Now, I will see the following screen:</p>
			<div><div><img alt="Figure 9.7 – Dropped frames" src="img/Figure_9.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Dropped frames</p>
			<p>Here, you can<a id="_idIndexMarker884"/> see that one frame was <strong class="bold">115.8 ms</strong>. I opened the <strong class="bold">Frames</strong> section (see how the gray arrow next to <strong class="bold">Frames</strong> points down) to see what was drawn on those frames – our poor knocked-out RHB. A frame that's 115.8 ms is way too long, and if you hover your mouse over that, it will show you <strong class="bold">dropped frames</strong>. Beneath the <strong class="bold">Frames</strong> section, there's the <strong class="bold">Main</strong> section, which shows what the application was doing. I've highlighted <strong class="bold">Recalculate Style</strong> here, which is taking <strong class="bold">33.55 ms</strong> according to the <strong class="bold">ToolTip</strong> window, which shows up after I roll my mouse over it.</p>
			<p><code>index.html</code> file, which should speed up recalculating the layout. If you do that and remeasure your performance, you'll see something like this:</p>
			<div><div><img alt="Figure 9.8 – No dropped frames!&#13;&#10;" src="img/Figure_9.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – No dropped frames!</p>
			<p>Was this worth worrying about? Possibly – it is noticeable to see the button load, but it's not worth extending this chapter to fix it. You know how to fix it, and you know how to find the issue in the <strong class="bold">Performance</strong> tab, and that's what's important for now. Anyway, we have another question to answer: how much memory is this game taking up?</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor223"/>Checking memory </h2>
			<p>When<a id="_idIndexMarker886"/> I was writing this game, I would frequently leave it running all day in the background, only to have my browser become very unresponsive as it started taking up all my computer's memory. I began to suspect that the game had a memory leak, so I started investigating. You may think it's impossible to have a memory leak in Rust due to its guarantees, and it is harder, but remember that a lot of our code talks to JavaScript, where we don't necessarily have the same guarantees. Fortunately, we can check this with the same tools we have been using to test performance.</p>
			<p>Go ahead and clear the performance data by clicking <strong class="bold">no sign</strong> in the top-left corner. Then, start another recording and play for a little while. This time, don't try to die right away; go ahead and let the game play for a bit. Then, stop recording and look at the performance <a id="_idIndexMarker887"/>data again, this time ensuring you click the <strong class="bold">Memory</strong> button. Now, you can a look at the results, which may look like this:</p>
			<div><div><img alt="Figure 9.9 – Memory profiling&#13;&#10;" src="img/Figure_9.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Memory profiling</p>
			<p>Can you see that blue wave at the bottom of the screen, which shows <strong class="bold">HEAP</strong> in the bottom right-hand corner? This shows that our memory grows and then is periodically reclaimed. This may not be ideal as we'd like memory to be constant, but we aren't trying to control things to that degree at this time. Chrome, and most browsers, run their garbage collectors in separate threads so that they won't affect performance as much as you may think. It would be worth experimenting and creating a memory budget in the application and keeping all the allocations in that budget, but that's outside the scope of this book. Fortunately, the memory is reclaimed and it doesn't look like the game is growing uncontrollably.</p>
			<p>After further investigation, it turned out that the problem with my browser was caused by my company's bug tracker, which uses far more memory than this little game! If you're seeing performance issues, make sure you account for other tabs, browser extens<a id="_idTextAnchor224"/>ions, and anything else that might be slowing down your computer outside of the game.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor225"/>Summary</h1>
			<p>This chapter was a little different than the previous ones because, in many ways, our game is complete! But of course, it's not perfect, which is why we spent some time looking at ways we can investigate defects and bullet-proof the code base. </p>
			<p>We dug into automated testing, writing unit tests for our transitions, and writing integration tests that run in the browser. We now have logging for any unforeseen errors and stack traces if the code crashes, both of which are necessary diagnostics for debugging challenging errors. Then, we used the linter and Clippy to clean up our code and remove subtle issues that the compiler can't catch. Finally, we investigated performance issues in the browser and found that we had none! </p>
			<p>In the next chapter, we'll get those tests into a CI/CD setup and even deploy them to production. What are we waiting for? Let's ship this thing!</p>
		</div>
	</body></html>