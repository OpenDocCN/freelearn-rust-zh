- en: Music Player in a More Rusty Way with Relm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Relm 以更 Rust 风格的方式创建音乐播放器
- en: In the previous chapter, we finished our music player. It is completely fine,
    but using `gtk-rs` directly in Rust can be error-prone. That's why we'll rewrite
    our music player using `relm`, an idiomatic GUI library for Rust. `Relm` is based
    on `gtk-rs`, so the application will look the same at the end. However, the code
    will be cleaner and more declarative.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们完成了我们的音乐播放器。这完全没问题，但直接在 Rust 中使用 `gtk-rs` 可能会导致错误。这就是为什么我们将使用 `relm`，这是一个
    Rust 的惯用 GUI 库，来重写我们的音乐播放器。`Relm` 基于 `gtk-rs`，所以最终的应用程序看起来是一样的。然而，代码将更简洁、更具声明性。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Relm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Relm
- en: Relm widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Relm 小部件
- en: Model-view-controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: Declarative view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性视图
- en: Message passing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递
- en: Reasons to use relm instead of gtk-rs directly
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 relm 而不是直接使用 gtk-rs 的原因
- en: As you have seen in the previous chapters, we used concepts that were not really
    obvious, and doing certain things that would normally be easy to do aren't that
    easy when using GTK+ with Rust. These are some of the many reasons to use `relm`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中看到的，我们使用了并不真正明显的一些概念，并且在使用 GTK+ 和 Rust 时，做一些通常很容易做的事情并不那么容易。这些都是使用
    `relm` 的许多原因之一。
- en: State mutation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态修改
- en: 'It might not be clear from the previous chapter, but we indirectly used `Rc<RefCell<T>>`
    to do state mutation. Indeed, our `Playlist` type contains a `RefCell<Option<String>>`
    and we wrapped our `Playlist` inside a reference-counted pointer. This was to
    be able to mutate the state in reaction to events, for instance playing the song
    when clicking the play button:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章可能不清楚，但我们间接使用了 `Rc<RefCell<T>>` 来进行状态修改。确实，我们的 `Playlist` 类型包含一个 `RefCell<Option<String>>`，并且我们将
    `Playlist` 包裹在一个引用计数指针中。这是为了能够根据事件对状态进行修改，例如在点击播放按钮时播放歌曲：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Having to use all these calls to `clone()` is cumbersome and using the `RefCell<T>` type
    can lead to issues that are hard to debug in complex applications. The issue with
    this type is that the borrow checking happens at runtime. For instance, the following
    application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用所有这些 `clone()` 调用是非常繁琐的，使用 `RefCell<T>` 类型可能会导致在复杂应用程序中难以调试的问题。这个类型的问题在于借用检查是在运行时发生的。例如，以下应用程序：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Will panic:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将会引发恐慌：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even though it is obvious why it panics in this example (we called `borrow_mut()`
    when the borrow was still alive in `borrowed_cell`), in more complex applications,
    it will be harder to understand why the panic happens, especially if we wrap the
    `RefCell<T>` in an `Rc` and clone it everywhere. This brings us to the second
    issue with this type: using `Rc<T>` encourages us to clone our data and share
    it too much which increases the coupling between our modules.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中为什么它会引发恐慌（我们在 `borrowed_cell` 中的借用仍然有效时调用了 `borrow_mut()`）是显而易见的，但在更复杂的应用程序中，理解为什么会发生恐慌会更困难，尤其是如果我们将
    `RefCell<T>` 包裹在 `Rc` 中并在每个地方克隆它。这使我们来到了这个类型的第二个问题：使用 `Rc<T>` 鼓励我们过度克隆和共享我们的数据，这增加了我们模块之间的耦合度。
- en: 'The `relm` crate takes a different approach: widgets owns their data and the
    different widgets communicate between them using message passing.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`relm` 包采用了一种不同的方法：小部件拥有自己的数据，不同的小部件之间通过消息传递进行通信。'
- en: Asynchronous user interface
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步用户界面
- en: Another common issue when creating user interfaces is that we might want to
    perform an action that might take time (such as a network request) without freezing
    the UI. By being based on `tokio`, an asynchronous I/O framework for Rust, `relm`
    allows you to easily program graphical user interfaces that can perform network
    requests without freezing the interface itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用户界面时，另一个常见问题是，我们可能想要执行可能需要花费时间（例如网络请求）的操作，而不冻结用户界面。由于基于 `tokio`，这是一个为 Rust
    设计的异步 I/O 框架，`relm` 允许你轻松地编写可以执行网络请求而不冻结界面的图形用户界面。
- en: Creating custom widgets
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义小部件
- en: In object-oriented languages, it is very easy to create new widgets and use
    them like built-in widgets. In this paradigm, you only need to create a new class
    that inherits from a widget and that's it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，创建新小部件并像内置小部件一样使用它们非常容易。在这个范例中，你只需要创建一个新的类，它继承自小部件，然后就可以了。
- en: 'In [Chapter 5](part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Creating
    a Music Player*, we created custom widgets, such as `Playlist` and `MusicToolbar`,
    but we needed to create a function to get the real GTK+ widget:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7) *创建音乐播放器* 中，我们创建了自定义小部件，例如
    `Playlist` 和 `MusicToolbar`，但我们需要创建一个函数来获取真实的 GTK+ 小部件：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An alternative would have been to implement the `Deref` trait:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是实现 `Deref` 特性：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That implementation would allow us to add the widget to its `parent` like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现将允许我们像这样将小部件添加到其 `parent` 中：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (Note the leading `*` in front of `playlist` which is the call to `deref()`.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: （注意 `playlist` 前面的前导 `*`，这是对 `deref()` 的调用。）
- en: 'Instead of adding it in the following way:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是以下这种方式添加：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But it is still different than when using normal `gtk` widgets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仍然与使用正常的 `gtk` 小部件不同。
- en: '`Relm` solves all of these issues. Let''s start using this crate.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Relm` 解决了所有这些问题。让我们开始使用这个包。'
- en: Creating a window with relm
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 relm 创建窗口
- en: First of all, we'll use the nightly version of the Rust compiler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 Rust 编译器的 Nightly 版本。
- en: While using this nightly version is not strictly necessary to use `relm`, it
    provides a syntax that is a bit nicer using a feature that is only available on
    this version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用这个 Nightly 版本不是使用 `relm` 的严格必要条件，但它提供了一种语法，使用这个版本上仅有的功能，语法会更好一些。
- en: That will be a good opportunity to learn how to install a different version
    of the compiler. Nightly is the unstable version of Rust; it's a version that
    is compiled almost every day. Some unstable features of Rust are only available
    on nightly. But, don't worry, we'll also see how to use `relm` on the stable version
    of Rust.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个学习如何安装不同版本的编译器的良好机会。Nightly 是 Rust 的不稳定版本；这是一个几乎每天都会编译的版本。Rust 的一些不稳定特性仅在
    Nightly 版本中可用。但是，不用担心，我们也会看看如何在 Rust 的稳定版本上使用 `relm`。
- en: Installing Rust nightly
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rust Nightly
- en: 'With `rustup`, the tool we installed in [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7),
    *Basics of Rust*, it is very easy to install nightly:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rustup`，我们在 [第 1 章](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7)
    “Rust 基础”中安装的工具，安装 Nightly 非常容易：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running this command will install the nightly version of the tools (`cargo`,
    `rustc`, and so on). Also, it will switch the corresponding commands to use the
    nightly version.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将安装工具的 Nightly 版本（`cargo`、`rustc` 等）。同时，它还将切换相应的命令以使用 Nightly 版本。
- en: 'If you want to go back to the stable version, issue the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要回到稳定版本，请发出以下命令：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The nightly version is updated very frequently, so you might want to update
    it every week or more often. To do so, you need to run this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Nightly 版本更新非常频繁，所以你可能希望每周或更频繁地更新它。为此，你需要运行以下命令：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will also update the stable version if a new version was released (one
    stable version is released every 6 weeks).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发布了新版本，这将也会更新稳定版本（每 6 周发布一个稳定版本）。
- en: 'Now that we are using Rust nightly, we''re ready to create a `new` project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用 Rust Nightly，我们准备好创建一个 `new` 项目：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following dependencies in the `Cargo.toml` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 文件中添加以下依赖项：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We still need `gtk` because `relm` is based on it. Let''s add the corresponding
    `extern crate` statements:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要 `gtk`，因为 `relm` 是基于它的。让我们添加相应的 `extern crate` 语句：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`relm` provides some macros, that''s why we needed to add `#[macro_use]`. We''ll
    start slowly by creating a simple window with `relm`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`relm` 提供了一些宏，这就是为什么我们需要添加 `#[macro_use]`。我们将通过使用 `relm` 创建一个简单的窗口来慢慢开始。'
- en: Widget
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: 'This crate is centered around the concept of widgets, which are different than
    the `gtk` widgets. In `relm`, a widget is composed of a view, a model, and a method
    to update the model in reaction to events. The concept of widget is implemented
    by a trait in `relm`: the `Widget` trait.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包围绕小部件的概念构建，这与 `gtk` 小部件不同。在 `relm` 中，小部件由视图、模型和用于响应事件更新模型的方法组成。小部件的概念通过 `relm`
    中的一个 trait 实现：`Widget` trait。
- en: Model
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'We''ll start with an empty model and we''ll populate it later in this chapter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从空模型开始，并在本章的后面部分填充它：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, a model can be a simple structure. It could also be `()` if
    your widget don't need a model. Actually, it can be any type you want.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一个模型可以是一个简单的结构。如果你的小部件不需要模型，它也可以是 `()`。实际上，它可以是你想要的任何类型。
- en: 'Besides the model, a widget needs to know the initial value of its model. To
    specify what it is, we need to implement the `model()` method of the `Widget`
    trait:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模型，小部件还需要知道其模型的初始值。为了指定它是什么，我们需要实现 `Widget` trait 的 `model()` 方法：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use the `#[widget]` attribute provided by the `relm_attributes` crate.
    Attributes are currently an unstable feature of the language, that's why we use
    nightly. We'll see in the section about the declarative view why this attribute
    is needed. So, let's go back to our `model()` model, we only return `Model {}`
    for now as our model does not contain any data. Other methods are needed for this
    trait, so this implementation is incomplete for now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了由 `relm_attributes` 包提供的 `#[widget]` 属性。属性目前是语言的一个不稳定特性，这就是为什么我们使用 nightly。我们将在关于声明视图的部分看到为什么这个属性是必需的。所以，让我们回到我们的
    `model()` 模型，我们现在只返回 `Model {}` 作为我们的模型不包含任何数据。这个特性还需要其他方法，所以这个实现现在是不完整的。
- en: Messages
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息
- en: '`Relm` widgets communicate by sending messages to other widgets, but also to
    themselves. For instance, when the `delete_event` signal is emitted, we can emit
    the `Quit` message to our widget and take appropriate action when we receive this
    message. A message is modeled as an `enum` using the custom derive `Msg` that
    is specific to `relm`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Relm` 小部件通过向其他小部件以及自身发送消息来进行通信。例如，当 `delete_event` 信号被触发时，我们可以向我们的小部件发送 `Quit`
    消息，并在接收到此消息时采取适当的行动。消息被建模为一个使用特定于 `relm` 的自定义派生 `Msg` 的 `enum`：'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This custom derive is provided by the `relm_derive` crate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义派生是由 `relm_derive` 包提供的。
- en: View
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'Views are created in a declarative way in `relm` as a part of the `Widget`
    trait:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `relm` 中，视图以声明方式创建，作为 `Widget` 特性的一个部分：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first imported some stuff from the `gtk` crate. Then we imported the `Widget`
    trait from `relm` and the `widget` attribute. Later, we imported the variant of
    our `enum Msg` because we use it in this code. To declare the view, we use the
    `view!` macro. This macro is very particular, it is not a macro that is declared
    as `macro_rules!`, as we saw in [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7),
    *Basics of Rust*. Instead, it is parsed by the procedural macro implementing the
    `#[widget]` attribute in order to provide a syntax that is not allowed in Rust.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `gtk` 包中导入了一些内容。然后，我们导入了 `relm` 中的 `Widget` 特性和 `widget` 属性。稍后，我们导入了我们的
    `enum Msg` 的变体，因为我们在这段代码中使用它。为了声明视图，我们使用了 `view!` 宏。这个宏非常特别，它不是一个像我们在 [第1章](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7)
    中看到的 `macro_rules!` 声明的宏。相反，它是通过实现 `#[widget]` 属性的进程宏来解析的，以便提供在 Rust 中不允许的语法。
- en: To declare our view, we first specify the name of the `gtk::Window` widget.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明我们的视图，我们首先指定 `gtk::Window` 小部件的名称。
- en: We cannot import `gtk::Window` to be able to use only `Window` in the declaration
    of the view.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能导入 `gtk::Window` 以便在视图声明中只使用 `Window`。
- en: After that, we use curly brackets and inside them, we specify the properties
    and events handled by the widget.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用花括号，并在其中指定小部件处理的属性和事件。
- en: Properties
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Here, we declare that the `title` property is `"Rusic"`. So we transformed
    the `set_title()` call from `gtk` to the `title` property, only the part after
    `set_` is needed. Actually, `relm` will convert the property (`title: "Rusic"`)
    to the `set_title("Rusic")` call, as we''ll see later.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们声明 `title` 属性为 `"Rusic"`。因此，我们将 `set_title()` 调用从 `gtk` 转换为 `title` 属性，只需要
    `set_` 之后的部分。实际上，`relm` 会将属性 (`title: "Rusic"`) 转换为 `set_title("Rusic")` 调用，正如我们稍后将会看到的。'
- en: Events
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'The syntax of the event handler is a bit special:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器的语法有点特殊：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we only need to write `delete_event(_, _) =>` instead of `connect_delete_event(move
    |_, _| { })`. If we needed the arguments of the signal, we could have written
    the name of an identifier instead of using underscores (`_`). On the right side
    of the fat arrow (`=>`), we specify two things between parentheses and separated
    by a comma. First, there's `Quit`, which is the message that will be sent to the
    current widget when the event is emitted. And second is the value to return to
    the `gtk` callback. Here, we return `Inhibit(false)` to specify that we don't
    want to prevent the default event handler from running.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需要写 `delete_event(_, _) =>` 而不是 `connect_delete_event(move |_, _| { })`。如果我们需要信号的参数，我们可以写一个标识符的名字而不是使用下划线（`_`）。在粗箭头（`=>`）的右侧，我们指定两个用括号括起来并用逗号分隔的东西。首先，是
    `Quit`，这是当事件被触发时将发送到当前小部件的消息。其次是要返回给 `gtk` 回调的值。在这里，我们返回 `Inhibit(false)` 以指定我们不想阻止默认事件处理器运行。
- en: Code generation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成
- en: 'The code generated by the attribute is a normal Rust method that looks like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由属性生成的代码是一个看起来像正常的 Rust 方法的代码：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Update function
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新函数
- en: 'The only remaining required method of the `Widget` trait is `update()`. In
    this method, we''ll manage the `Quit` message:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget`特质唯一剩余的必需方法是`update()`。在这个方法中，我们将管理`Quit`消息：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we specify that when we receive the `Quit` message, we call `gtk::main_quit()`,
    which is a function similar to `Application::quit()` that we used in [Chapter
    5](part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Creating a Music Player*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定当接收到`Quit`消息时，我们调用`gtk::main_quit()`，这是一个类似于我们在[第5章](part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7)中使用的`Application::quit()`的函数。
- en: It should be noted that the `#[widget]` attribute will also generate the `App` structure
    that will contain the widgets and the model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`#[widget]`属性也会生成包含小部件和模型的`App`结构。
- en: 'We can finally show this window by calling its `run()` method in the `main`
    function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`main`函数中调用其`run()`方法来最终显示这个窗口：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Later, we'll see why we need to specify `()` as a parameter to `run()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到为什么需要指定`()`作为`run()`的参数。
- en: Adding child widgets
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加子小部件
- en: 'We saw the basics of how to create a widget with relm. Now, let''s continue
    the creation of our user interface. We''ll start by adding the toolbar. Besides
    specifying properties and signals in the `view!` macro, we can also nest widgets
    in order to add a child to a container. So, to add `gtk::Box` as a child of our
    window, we simply need to nest the former inside the latter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用relm创建小部件的基本方法。现在，让我们继续创建我们的用户界面。我们将从添加工具栏开始。除了在`view!`宏中指定属性和信号外，我们还可以嵌套小部件，以便将子小部件添加到容器中。因此，要将`gtk::Box`作为窗口的子小部件添加，我们只需将前者嵌套在后者内部：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And to add a toolbar to the `gtk::Box`, we create a new level of nesting:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将工具栏添加到`gtk::Box`中，我们创建一个新的嵌套层级：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we can see that there''s an attribute: the `#[name]` attribute gives
    a name to a widget which will allow us to access this widget by the specified
    identifier, as we''ll see later. We''ll encounter other attributes in the rest
    of this chapter.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个属性：`#[name]`属性给一个小部件命名，这将允许我们通过指定的标识符访问这个小部件，就像我们稍后将要看到的那样。在本章的其余部分，我们还会遇到其他属性。
- en: 'We''ll add an attribute to our model to keep the image to be shown on the play/pause
    button:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的模型中添加一个属性来保持播放/暂停按钮上要显示的图像：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also added the constants for the name of the images representing the state
    of the button. We need to update the `model()` method to specify this new field:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了表示按钮状态的图像名称的常量。我们需要更新`model()`方法来指定这个新字段：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This uses the following function to create an image:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用以下函数来创建一个图像：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s add the items to the toolbar:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向工具栏添加项目：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, there''s no new syntax shown. Take note that we can specify function
    calls as well as model attributes in the value of a property. We needed to put
    a `&` before `new_icon()` because the code is translated as such:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有展示新的语法。请注意，我们可以在属性的值中指定函数调用以及模型属性。我们需要在`new_icon()`之前放置一个`&`，因为代码被这样翻译：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And this `set_icon_widget()` method requires something that can be converted
    into an `Option<&P>` where `P` is a widget. It requires a reference, so we give
    it a reference.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`set_icon_widget()`方法需要可以转换成`Option<&P>`的东西，其中`P`是一个小部件。它需要一个引用，所以我们给它一个引用。
- en: One-way data binding
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单向数据绑定
- en: 'Setting a property from a model attribute is very frequent in relm and it actually
    creates a one-way bond between the model attribute and the property. This means
    that when the attribute is updated, the widget property will be updated as well.
    There are some restrictions to this feature though:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在relm中，从模型属性设置属性是非常频繁的，实际上它创建了一个模型属性和属性之间的单向绑定。这意味着当属性被更新时，小部件属性也会被更新。尽管这个特性有一些限制：
- en: Only an assignment to a model attribute will update the property.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有对模型属性的赋值才会更新属性。
- en: This assignment *must* be inside an implementation decorated with the `#[widget]`
    attribute.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个赋值*必须*在一个带有`#[widget]`属性的实现中。
- en: These restrictions come from the fact that `relm` only analyzes the source code
    decorated by this attribute. And it only considers assignment to be an update
    of the model data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制来自于`relm`只分析由这个属性装饰的源代码。它只考虑赋值是对模型数据的更新。
- en: 'This might require changing some code. For instance, the following code will
    not trigger a property update:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要更改一些代码。例如，以下代码不会触发属性更新：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can rewrite it this way in order for  `relm` to consider it an update:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样重写它，以便`relm`将其视为更新：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, `relm` recognizes not only the `=` assignment, but also the
    assignments using an operator such as `+=`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`relm` 不仅识别 `=` 赋值，还识别使用运算符（如 `+=`）的赋值。
- en: 'We used many new messages in the previous code, so let''s update our enumeration
    accordingly:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用了许多新的消息，所以让我们相应地更新我们的枚举：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need to change the `update()` method to consider these new messages:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改 `update()` 方法以考虑这些新消息：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For now, since we only code the interface, we do nothing when we receive these
    messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，因为我们只编写了界面，所以当我们收到这些消息时，我们不做任何事情。
- en: Post-initialization of the view
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图的后续初始化
- en: 'If you run the application, you''ll see that the images are not shown on the
    toolbar buttons. This is because of the way `relm` works. When it generates the
    code, it calls the `show()` method on every widget, instead of `show_all()`. So,
    the toolbar and the tool buttons will be shown, but not the images, as they are
    only attributes of the buttons, they are not created using the widget syntax.
    To solve this issue, we''ll call `show_all()` on the toolbar in the `init_view()`
    method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你会看到图像没有显示在工具栏按钮上。这是因为 `relm` 的工作方式。当它生成代码时，它会在每个小部件上调用 `show()` 方法，而不是
    `show_all()`。所以，工具栏和工具按钮会显示，但图像不会显示，因为它们只是按钮的属性，它们不是使用小部件语法创建的。为了解决这个问题，我们将在 `init_view()`
    方法中调用 `show_all()`：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s why we gave a name to the toolbar widget earlier: we needed to call
    a method on this widget here. The `init_view()` method is called after the `view`
    is created. This is useful to execute some code to customize the view when it''s
    not possible to do so using the `view!` syntax. If you run the application again,
    you''ll see that the buttons now have an image.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们之前给工具栏小部件命名的原因：我们需要在这个小部件上调用一个方法。`init_view()` 方法在创建 `view` 之后被调用。这在无法使用
    `view!` 语法进行操作时，执行一些代码来自定义视图是有用的。如果你再次运行应用程序，你会看到按钮现在有一个图像。
- en: 'Let''s now add the cover image widget and the cursor widget. For the image,
    we''ll need to add a new crate to `Cargo.toml`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加封面图像小部件和光标小部件。对于图像，我们需要在 `Cargo.toml` 中添加一个新的 crate：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s also add the corresponding `extern crate` statement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加相应的 `extern crate` 语句：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also need new import statements:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要新的导入语句：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s add a couple of new fields to our `Model`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 `Model` 中添加几个新字段：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Most of the new fields existed in the application we developed in the two previous
    chapters. The `cover_visible` attribute is new, though. We''ll use it to know
    whether we should show the image of the cover. Don''t forget to update the initialization
    of the model:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新字段都存在于我们在前两章中开发的应用程序中。不过，`cover_visible` 属性是新的。我们将使用它来知道是否应该显示封面图像。别忘了更新模型的初始化：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now add the `Image` after the `Toolbar` widget:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `Toolbar` 小部件之后添加 `Image`：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we call `as_ref()` on the `cover_pixbuf` attribute, because, once again,
    the method (`set_from_pixbuf()`) requires something that can be converted into
    a `Option<&Pixbuf>`. We also specify that the `visible` property of the image
    is bound to the `cover_visible` model attribute. This means that we'll be able
    to hide the image by setting this attribute to `false`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `cover_pixbuf` 属性上调用 `as_ref()`，因为，又一次，该方法（`set_from_pixbuf()`）需要可以被转换成
    `Option<&Pixbuf>` 的东西。我们还指定了图像的 `visible` 属性绑定到 `cover_visible` 模型属性。这意味着我们可以通过将此属性设置为
    `false` 来隐藏图像。
- en: 'We''ll then add the cursor, which will give us the following view:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加光标，这将给我们以下视图：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This require the following method, which we saw in the previous chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要我们在上一章中看到的方法：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We used another way to create a widget:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了另一种创建小部件的方法：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This syntax will call the constructor of the widget, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法将调用小部件的构造函数，如下所示：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We could also have used the traditional syntax to create a widget:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用传统的语法来创建小部件：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These are just two ways to do the same thing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是做同样事情的两个方法。
- en: Dialogs
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框
- en: 'For the open and save dialog, we''ll use the same functions as in the previous
    chapter:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于打开和保存对话框，我们将使用与上一章相同的功能：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But this time, we''ll put the code for the open action in a method on the `App`
    widget:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次，我们将打开操作的代码放在 `App` 小部件的方法中：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then call these functions in the `update()` method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `update()` 方法中调用这些函数：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's manage some of the other actions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们管理一些其他操作。
- en: Other methods
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他方法
- en: 'This will require two new methods in the `impl Widget`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要在 `impl Widget` 中添加两个新方法：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But these methods have nothing to do with a `Widget`, so why are we allowed
    to add `custom` methods in a trait implementation? Well, the `#[widget]` attribute
    will take these methods and move them to a separate `impl App` where they belong.
    But why do we want to do this instead of placing them ourselves? That's because
    `relm` analyzes the assignments to the model attributes in the methods in the
    implementation decorated by the `#[widget]` attribute. As we saw earlier, an assignment
    to a model field will automatically update the view. If we placed these methods
    in a separate `impl App`, `relm` would have been unable to analyze these methods
    and generate the code to automatically update the view.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些方法与`Widget`没有任何关系，那么为什么我们可以在特质实现中添加`custom`方法呢？嗯，`#[widget]`属性会将这些方法移动到属于它们的单独的`impl
    App`中。但为什么我们想要这样做而不是自己放置它们呢？那是因为`relm`会分析由`#[widget]`属性装饰的实现中的方法对模型属性的赋值。正如我们之前看到的，对模型字段的赋值将自动更新视图。如果我们将这些方法放在单独的`impl
    App`中，`relm`将无法分析这些方法并生成自动更新视图的代码。
- en: This is a frequent mistake, if your view is not updating when you're assigning
    to a model attribute, it's probably because your assignment is not within an implementation
    decorated by the `#[widget]` attribute.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的错误，如果你在分配给模型属性时视图没有更新，那么可能是因为你的分配不在由`#[widget]`属性装饰的实现中。
- en: 'We also need a new attribute for our model:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的模型添加一个新属性：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We added a `stopped` attribute that we also need to add in the model initialization:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`stopped`属性，我们还需要在模型初始化中添加它：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now change the `update()` method to use these new methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将`update()`方法改为使用这些新方法：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `update()` method receives `self` by a mutable reference, which allows us
    to update the model attributes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法通过可变引用接收`self`，这允许我们更新模型属性。'
- en: Playlist
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放列表
- en: 'We''re now ready to create a new widget: the playlist. We''ll need the following
    new `dependencies`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建一个新的小部件：播放列表。我们需要以下新的`dependencies`：
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add their corresponding `extern crate` statements:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 添加它们相应的`extern crate`语句：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s create a new module for our `playlist`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`playlist`创建一个新的模块：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `src/playlist.rs` file, we start by creating our model:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/playlist.rs`文件中，我们首先创建我们的模型：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `Relm` type comes from the `relm` crate:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Relm`类型来自`relm`包：'
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It is useful to send messages to a widget. We''ll learn more about that in
    the section about widget communication. Let''s add the model initialization function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 向小部件发送消息是有用的。我们将在关于小部件通信的部分了解更多。让我们添加模型初始化函数：
- en: '[PRE56]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we notice that we use a different signature for the `model()` method.
    How is this possible? The method of the trait cannot change, right? It is another
    convenience brought by the `#[widget]` crate. In many cases, we don't need these
    parameters, so they are automatically added if they are needed. The first parameter
    is `relm` and we save a copy of it in the model. The second parameter is the model
    initialization parameter. The `ListStore` is the same as in [Chapter 5](part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7),
    *Creating a Music Player*, we only save it in our model because we'll need it
    later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们注意到我们使用了`model()`方法的不同的签名。这是怎么可能的？特质的方法定义不能改变，对吧？这是`#[widget]`包带来的另一个便利。在许多情况下，我们不需要这些参数，所以如果需要，它们会自动添加。第一个参数是`relm`，我们将其副本保存在模型中。第二个参数是模型初始化参数。`ListStore`与[第5章](part0117.html#3FIHQ0-13a27bdc411a4c2eaad1cc3a71f7fca7)中的相同，*创建音乐播放器*，我们只将其保存在我们的模型中，因为我们以后会用到它。
- en: Model parameter
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型参数
- en: 'Let''s talk more about this second parameter. It could be used to send data
    to the widget when we create it. Remember when we called `run()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地谈谈这个第二个参数。它可以在创建小部件时用来向小部件发送数据。记得我们调用`run()`时：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we specified `()` as the model parameter because we don't need one. But
    we could have used a different value, such as `42`, and this value would have
    been received in the second parameter of the `model()` method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们指定`()`作为模型参数，因为我们不需要它。但我们可以使用不同的值，例如`42`，这个值将会在`model()`方法的第二个参数中被接收。
- en: 'We''re now ready to create the view:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建视图：
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It is really simple: we give it a name and set both the `hexpand` and `vexpand`
    properties to `true` and we bind the `model` property with our `ListStore`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它真的很简单：我们给它一个名字，并将`hexpand`和`vexpand`属性都设置为`true`，并将`model`属性绑定到我们的`ListStore`。
- en: 'Let''s create an empty `update()` method for now:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建一个空的`update()`方法：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ll see the `Msg` type later. We''ll now add the columns exactly like we
    did it in  [Chapter 5](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86), *Creating
    a Music Player*. Let''s copy the following enumeration and constants:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到 `Msg` 类型。现在，我们将添加列，就像我们在 [第 5 章](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86)
    中 *创建音乐播放器* 所做的那样。让我们复制以下枚举和常量：
- en: '[PRE60]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And let''s add new methods to the `Paylist`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们向 `Paylist` 添加新方法：
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The difference from these functions in  [Chapter 5](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86), *Creating
    a Music Player* is that here, we have direct access to the `treeview` as an attribute.
    This requires new import statements:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 5 章](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86)
    中 *创建音乐播放器* 的这些函数相比，这里的区别在于，我们直接通过属性访问 `treeview`。这需要新的导入语句：
- en: '[PRE62]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We''ll now call the `create_columns()` method in the `init_view()` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `init_view()` 方法中调用 `create_columns()` 方法：
- en: '[PRE63]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s start interacting with the playlist. We''ll create a method to add a
    song to the playlist:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从与播放列表的交互开始。我们将创建一个将歌曲添加到播放列表的方法：
- en: '[PRE64]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This calls the `set_pixbuf()` method, so let''s define it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `set_pixbuf()` 方法，因此让我们来定义它：
- en: '[PRE65]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It is very similar to the one created in  [Chapter 5](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86), *Creating
    a Music Player*. This method will be called when we receive the `AddSong(path)`
    message, so let''s now create our message type:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 [第 5 章](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86)
    中 *创建音乐播放器* 创建的方法非常相似。当接收到 `AddSong(path)` 消息时，将调用此方法，因此我们现在创建我们的消息类型：
- en: '[PRE66]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And let''s modify the `update()` method accordingly:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，相应地修改 `update()` 方法：
- en: '[PRE67]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we call the method `add()` when we receive the `AddSong` message. But
    where is this message emitted? Well, it will be emitted by the `App` type, when
    the user requests to open a file. It is time we go back to the main module and
    use this new `relm` widget.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当接收到 `AddSong` 消息时，我们调用 `add()` 方法。但这条消息是从哪里发出的？嗯，它将由 `App` 类型发出，当用户请求打开文件时。现在是时候回到主模块并使用这个新的
    `relm` 小部件了。
- en: Adding a relm widget
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 relm 小部件
- en: 'First, we''ll need these new import statements:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要这些新的导入语句：
- en: '[PRE68]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And then, add the `Playlist` widget below the toolbar:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在工具栏下方添加 `Playlist` 小部件：
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'There''s something different with using `relm` widgets and `gtk` widgets. `Relm`
    widgets must not contain a module prefix, while `gtk` widget must contain one.
    This is why we imported `Playlist`, but now `gtk::Toolbar`, for instance. But
    why is it needed? Well, `relm` widgets are different than `gtk` widgets, so they
    are not created or added to another widget in the same way. Thus, `relm` can distinguish
    them this way: if there''s a prefix, this is a built-in `gtk` widget, otherwise
    it is a custom `relm` widget. When I say `gtk` widgets, this even includes `gtk`
    widgets from other crates, such as `webkit2gtk::WebView`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `relm` 小部件和 `gtk` 小部件时有一些不同。`Relm` 小部件不得包含模块前缀，而 `gtk` 小部件必须包含一个。这就是为什么我们导入了
    `Playlist`，但现在导入了 `gtk::Toolbar`。但为什么需要它呢？嗯，`relm` 小部件与 `gtk` 小部件不同，因此它们不是以相同的方式创建或添加到其他小部件中的。因此，`relm`
    可以通过这种方式区分它们：如果有前缀，这是一个内置的 `gtk` 小部件，否则它是一个自定义的 `relm` 小部件。当我说 `gtk` 小部件时，这甚至包括来自其他包的
    `gtk` 小部件，例如 `webkit2gtk::WebView`。
- en: Communicating between widgets
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件之间的通信
- en: We'll now communicate between the widgets to indicate we want to add a song
    to the playlist. But before we do so, we'll look in more detail at how a widget
    can communicate with itself.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在小部件之间进行通信，以表示我们想要将歌曲添加到播放列表中。但在这样做之前，我们将更详细地了解小部件如何与自身通信。
- en: Communicating with the same widget
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与同一小部件的通信
- en: 'We previously saw how to communicate with the same widget. To send a message
    to the same widget from an event handler in the view, we simply need to specify
    the message to be sent on the right side of `=>`, like in the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了如何与同一小部件通信。要从视图中的事件处理器向同一小部件发送消息，我们只需在 `=>` 的右侧指定要发送的消息，如下例所示：
- en: '[PRE70]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, the `Quit` message is sent to the same widget (that is, `App`) when the
    user clicks this tool button. But this is syntax sugar for a call to the `emit()`
    method on the stream of events of a `relm` widget.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当用户点击此工具按钮时，将向同一小部件（即 `App`）发送 `Quit` 消息。但这是对 `relm` 小部件事件流上的 `emit()` 方法的调用的一种语法糖。
- en: Emit
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射
- en: 'So, let''s see how to send a message to the same widget without using this
    syntax: this is useful in more complex cases, such as when we want to conditionally
    send a message. Let''s go back to our `Playlist` and add a `play()` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如何在不使用这种语法的情况下向同一个小部件发送消息：这在更复杂的情况下很有用，例如当我们想要有条件地发送消息时。让我们回到我们的`Playlist`并添加一个`play()`方法：
- en: '[PRE71]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This line sends a message to the current widget:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码向当前小部件发送一个消息：
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We first get the event stream from the `relm` widget and then call `emit()`
    on it with a message. This `play()` method requires two new methods:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`relm`小部件获取事件流，然后在上面调用`emit()`方法并传递一个消息。这个`play()`方法需要两个新方法：
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'These are very similar to the ones we wrote in the previous chapters. We can
    now call the `play()` method in the `update()` method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与我们在前几章中编写的非常相似。我们现在可以在`update()`方法中调用`play()`方法：
- en: '[PRE74]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: I also added a comment before `SongStarted` to indicate that this message will
    not be handled by the `Paylist` widget, but by the `App` widget. Now, let's see
    how to communicate between different widgets.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在`SongStarted`之前添加了一个注释，表明这个消息不会被`Paylist`小部件处理，而是由`App`小部件处理。现在，让我们看看如何在不同的小部件之间进行通信。
- en: With different widgets
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的小部件
- en: 'Let''s update the `open()` method to communicate with the playlist:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`open()`方法以与播放列表进行通信：
- en: '[PRE75]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So, we call the same `emit()` method to send a message to another widget:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们调用相同的`emit()`方法向另一个小部件发送消息：
- en: '[PRE76]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here, we sent a message that is not yet handled by the `Playlist` (`LoadSong`),
    so let''s fix that:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们发送了一个尚未由`Playlist`（`LoadSong`）处理的消息，所以让我们修复这个问题：
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This method is called in the `update()` method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在`update()`方法中被调用：
- en: '[PRE78]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Handle messages from a relm widget
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理来自relm小部件的消息
- en: 'Let''s now see how to handle the `SongStarted` message. To do so, we use a
    syntax similar to the one for handling `gtk` events. The message is on the left
    side of `=>` while the handler is on the right side of it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何处理`SongStarted`消息。为了做到这一点，我们使用与处理`gtk`事件类似的语法。消息位于`=>`的左侧，而处理程序位于其右侧：
- en: '[PRE79]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can see here that when we receive the `SongStarted` message from the playlist,
    we emit the `Started` message on the same widget (`App`). We needed to use `ref`
    and then `clone()` the value contained in the message here because we do not own
    the message. Indeed, multiple widgets can listen to the same message, the widget
    that emitted the message and its parent. Before we handle this new message, we''ll
    add it to our `Msg` enumeration:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们从播放列表接收到`SongStarted`消息时，我们在同一个小部件（`App`）上发出`Started`消息。我们需要在这里使用`ref`然后`clone()`消息中包含的值，因为我们不拥有这个消息。确实，多个小部件可以监听同一个消息，即发出消息的小部件及其父小部件。在我们处理这个新消息之前，我们将它添加到我们的`Msg`枚举中：
- en: '[PRE80]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This variant takes an optional `pixbuf` because some MP3 files do not have
    a cover image inside them. And here''s how we handle this message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变体接受一个可选的`pixbuf`，因为一些MP3文件内部没有封面图像。以下是处理这个消息的方法：
- en: '[PRE81]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: When the song starts playing, we show the pause icon and the cover.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当歌曲开始播放时，我们显示暂停图标和封面。
- en: Syntax sugar to send a message to another relm widget
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向另一个relm小部件发送消息的语法糖
- en: 'Sending a message to another widget with `emit()` is a bit verbose, so `relm`
    provides syntactic sugar for this case. Let''s send a message to the playlist
    when the user clicks the remove button:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`emit()`向另一个小部件发送消息有点冗长，所以`relm`为此情况提供了语法糖。让我们在用户点击删除按钮时向播放列表发送消息：
- en: '[PRE82]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we used the `@` syntax to specify that the message will be sent to another
    widget. The part before the `@` is the receiver widget, while the part after this
    character is the message. So, this code means that whenever the user clicks the
    remove button, send the `RemoveSong` message to the `playlist` widget.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`@`语法来指定消息将被发送到另一个小部件。`@`之前的部分是接收器小部件，而`@`之后的部分是消息。因此，这段代码的意思是，每当用户点击删除按钮时，将`RemoveSong`消息发送到`playlist`小部件。
- en: 'Let''s handle this message in the `Paylist::update()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Paylist::update()`方法中处理这个消息：
- en: '[PRE83]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This calls the `remove_selection()` method, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用`remove_selection()`方法，如下所示：
- en: '[PRE84]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This is the same method as the one from  [Chapter 5](https://cdp.packtpub.com/rust_by_example/wp-admin/post.php?post=121&action=edit#post_86), *Creating
    a Music Player*. Now, let''s send the remaining messages. The `PlaySong`, `PauseSong`,
    `SaveSong`, and `StopSong` messages are emitted in the `update()` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这与第5章中提到的相同方法，*创建音乐播放器*。现在，让我们发送剩余的消息。`PlaySong`、`PauseSong`、`SaveSong`和`StopSong`消息在`update()`方法中发出：
- en: '[PRE85]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The other messages are sent using the `@` syntax in the view:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 其他消息使用视图中的 `@` 语法发送：
- en: '[PRE86]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We''ll handle these messages in the `Paylist::update()` method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Paylist::update()` 方法中处理这些消息：
- en: '[PRE87]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This requires some new methods:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些新方法：
- en: '[PRE88]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And function `stop`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '并且函数 `stop`:'
- en: '[PRE91]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: These methods are all similar to the ones we created in the previous chapters.
    You can run the application to see that we can open and remove songs, but we cannot
    play them yet. So let's fix this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都与我们在上一章中创建的方法相似。你可以运行应用程序以查看我们可以打开和删除歌曲，但我们还不能播放它们。所以让我们解决这个问题。
- en: Playing music
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐
- en: 'First, add the `mp3` module:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加 `mp3` 模块：
- en: '[PRE92]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Copy the `src/mp3.rs` file from the previous chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一章的 `src/mp3.rs` 文件复制过来。
- en: 'We also need the following dependencies:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要以下依赖项：
- en: '[PRE93]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And add these statements to the `main` module:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这些语句添加到 `main` 模块中：
- en: '[PRE94]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We''ll now add a `player` module:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个 `player` 模块：
- en: '[PRE95]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This new module will start with a bunch of import statements:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新模块将开始于一系列导入语句：
- en: '[PRE96]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We imported a new `PlayerMsg` type from the `playlist` module, so let''s add
    it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `playlist` 模块导入了新的 `PlayerMsg` 类型，所以让我们添加它：
- en: '[PRE97]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We''ll define some constants:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一些常量：
- en: '[PRE98]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And let''s create the types that we''ll need:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们创建我们需要的类型：
- en: '[PRE99]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `Action` and `EventLoop` are the same as in the previous chapter, but the
    `Player` type is a bit different. Instead of having a field with the state of
    the application, it contains a sender that will be used to send messages to the
    playlist and ultimately to the application itself. So, instead of using a shared
    state and a timeout like we did in the previous chapter, we'll use message passing,
    which is more efficient.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action` 和 `EventLoop` 与上一章相同，但 `Player` 类型略有不同。它不包含表示应用程序状态的字段，而是包含一个用于向播放列表和最终向应用程序本身发送消息的发送者。因此，我们不会像上一章那样使用共享状态和超时，而是使用消息传递，这更有效率。'
- en: 'We''ll need a constructor for `EventLoop`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 `EventLoop` 的构造函数：
- en: '[PRE100]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s create the constructor for `Player`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `Player` 创建构造函数：
- en: '[PRE101]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'It is similar to the one we wrote in the previous chapter, but instead of using
    the shared state, we send messages back to the playlist. Here''s an example of
    how we send these messages:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们在上一章中编写的类似，但不是使用共享状态，而是将消息发送回播放列表。以下是如何发送这些消息的示例：
- en: '[PRE102]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This sends the current time back to the UI so that it can display it. This
    requires the `send()` function to be defined:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将当前时间发送回 UI，以便它可以显示它。这需要定义 `send()` 函数：
- en: '[PRE103]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This code uses the `future` crate to send the message and it shows an error
    in case it fails. The `iter_to_buffer()` function is the same as the one from
    the previous chapter:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用 `future` crate 发送消息，并在失败时显示错误。`iter_to_buffer()` 函数与上一章中的相同：
- en: '[PRE104]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We''ll now add the methods to play and pause a song:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加播放和暂停歌曲的方法：
- en: '[PRE105]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'They''re very similar to the ones from the previous chapter, but we send a
    message instead of modifying a state. They require the following methods:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 它们与上一章的非常相似，但我们发送一个消息而不是修改状态。它们需要以下方法：
- en: '[PRE106]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `emit()` and `set_playing()` methods are the same as in the previous chapter.
    The `send()` method simply calls the `send()` function we defined earlier.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`emit()` 和 `set_playing()` 方法与上一章相同。`send()` 方法只是调用我们之前定义的 `send()` 函数。'
- en: 'We''ll also need these two methods:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要这两个方法：
- en: '[PRE107]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `is_paused()` method has not changed. And the `stop()` method is similar,
    but again, it sends messages instead of updating the application state directly.
    Let''s go back to our `Paylist` to use this new player. The model will now contain
    the player itself:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_paused()` 方法没有变化。而 `stop()` 方法类似，但同样，它发送消息而不是直接更新应用程序状态。让我们回到我们的 `Paylist`
    来使用这个新的播放器。现在模型将包含播放器本身：'
- en: '[PRE108]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `Msg` type will contain a new variant called `PlayerMsgRecv` that will
    be emitted whenever the player sends a message:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Msg` 类型将包含一个名为 `PlayerMsgRecv` 的新变体，每当播放器发送消息时都会发出：'
- en: '[PRE109]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We''re now ready to update the model initialization:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好更新模型初始化：
- en: '[PRE110]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: It now creates a sender and receiver pair from the `mpsc` type of the `future`
    crate. **MPSC** stands for **Multiple-Producers-Single-Consumer**. We now call
    the `Relm::connect_exec_ignore_err()` method, this method connects a `Future`
    or a `Stream` to a message. This means that whenever a value is produced in the
    `Stream`, a message will be emitted. The message needs to take a parameter of
    the same type as the value produced by the `Stream`. A `Future` represents a value
    that is possibly not yet available, but will be available in the future, unless
    an error happens. A `Stream` is similar, but can produce multiple values that
    will be available at different times in the future. Similar to the `connect_exec_ignore_err()`
    method, there's also the `connect_exec()` method, which takes another message
    variant as a parameter, this second message will be emitted when there's an error.
    Here, we simply ignore the errors.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它从`future` crate的`mpsc`类型创建一个发送者和接收者对。**MPSC**代表**Multiple-Producers-Single-Consumer**。我们现在调用`Relm::connect_exec_ignore_err()`方法，这个方法将一个`Future`或一个`Stream`连接到一个消息。这意味着每当`Stream`中产生一个值时，就会发出一个消息。这个消息需要接受一个与`Stream`产生的值相同类型的参数。一个`Future`代表一个可能尚未可用，但将来会可用，除非发生错误。一个`Stream`类似，但可以在未来不同时间产生多个值。与`connect_exec_ignore_err()`方法类似，还有一个`connect_exec()`方法，它接受另一个消息变体作为参数，当发生错误时，将发出第二个消息。在这里，我们简单地忽略错误。
- en: 'In the `update()` method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update()`方法中：
- en: '[PRE111]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We have nothing to do with this message because it will be handled by the `App`
    widget. We''ll now add a method to pause the player:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与这个消息无关，因为它将由`App`小部件处理。我们现在将添加一个暂停播放器的函数：
- en: '[PRE112]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Next we need to update the `play()` and `stop()` methods:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`play()`和`stop()`方法：
- en: '[PRE113]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The `stop()` method is the same, except that we can update the model directly,
    because we don't need to use the `RefCell` type anymore. The `play()` method will
    now load or resume the song depending on the state of the player.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop()`方法与之前相同，只是我们可以直接更新模型，因为我们不再需要使用`RefCell`类型。`play()`方法现在将根据播放器的状态加载或恢复歌曲。'
- en: 'The `play()` method requires a `path()` method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`play()`方法需要一个`path()`方法：'
- en: '[PRE114]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let''s go back to the `main` module to manage the messages sent by the player.
    First, we need a new variant for our `enum Msg`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`main`模块来管理播放器发送的消息。首先，我们需要为我们的`enum Msg`添加一个新的变体：
- en: '[PRE115]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We will handle this in the `update()` method:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`update()`方法中处理这个问题：
- en: '[PRE116]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This requires a new method to be added in `impl Widget for App`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要在`impl Widget for App`中添加一个新的方法：
- en: '[PRE117]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This is also a `custom` method, that is, a method that is not part of the `Widget`
    trait, but is analyzed by the `#[widget]` attribute. We put it there instead of
    a separate `impl App` because we updated the model. In this method, we either
    update the icon to display the play button or the current time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个`custom`方法，即不是`Widget`特质的组成部分，但由`#[widget]`属性分析的方法。我们将其放在那里而不是单独的`impl
    App`中，因为我们更新了模型。在这个方法中，我们要么更新图标以显示播放按钮，要么显示当前时间。
- en: Computing the song duration
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算歌曲时长
- en: 'The only remaining feature that needs to be implemented in order to be on par
    with the music player of the previous chapter is to compute and display the song
    duration. First, we will copy the `compute_duration()` method from the previous
    chapter and paste it in our `Player`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与上一章的音乐播放器相匹配，唯一需要实现的功能是计算并显示歌曲时长。首先，我们将从上一章复制`compute_duration()`方法并将其粘贴到我们的`Player`中：
- en: '[PRE118]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We''ll now call this method in the `Playlist`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`Playlist`中调用这个方法：
- en: '[PRE119]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Here, we use `oneshot` which is also a channel, similar to `mpsc`, but `oneshot`
    can only send a message once. The message sent is a tuple, so we convert it to
    our `Msg` type by using a new `DurationComputed` variant that we''ll add to the
    type:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用`oneshot`，它也是一个通道，类似于`mpsc`，但`oneshot`只能发送一次消息。发送的消息是一个元组，因此我们通过使用一个新添加的`DurationComputed`变体将其转换为我们的`Msg`类型：
- en: '[PRE120]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We've also added a `SongDuration` message that we'll use soon.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个即将使用的`SongDuration`消息。
- en: 'We need to call this method in `Playlist::add()`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Playlist::add()`中调用这个方法：
- en: '[PRE121]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We then need to handle the new `DurationComputed` message in `Playlist::update()`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`Playlist::update()`中处理新的`DurationComputed`消息：
- en: '[PRE122]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Here, we insert the computed duration in the model. And if the song is the one
    currently being played, we send the `SongDuration` message so that the `App` widget
    can update itself.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将计算出的时长插入到模型中。如果歌曲是当前正在播放的，我们将发送`SongDuration`消息，以便`App`小部件可以更新自己。
- en: 'This requires a new field for the durations in the model:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要在模型中的时长添加一个新的字段：
- en: '[PRE123]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Add the new model initialization:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的模型初始化：
- en: '[PRE124]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This also requires the `to_millis()` function to be added in the `main` module,
    which is the same as in the previous chapter:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求在 `main` 模块中添加 `to_millis()` 函数，这与上一章相同：
- en: '[PRE125]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Since the duration is only computed once, we also need to send it when we start
    playing the song, so let''s update the `Playlist::play()` method:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于持续时间只计算一次，因此在我们开始播放歌曲时也需要发送它，所以让我们更新 `Playlist::play()` 方法：
- en: '[PRE126]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We send the `SongDuration` message if we found it in the `HashMap` (it is possible
    that the song starts playing before the duration is computed).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `HashMap` 中找到了 `SongDuration` 消息（歌曲可能在计算持续时间之前开始播放），我们将发送 `SongDuration`
    消息。
- en: 'Finally, we need to handle the following message in the `App` view:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在 `App` 视图中处理以下消息：
- en: '[PRE127]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'When we receive the `SongDuration` message from the playlist, we send the `Duration`
    message to `App`, so we need to add this variant to its `Msg` type:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从播放列表接收到 `SongDuration` 消息时，我们会向 `App` 发送 `Duration` 消息，因此我们需要将这个变体添加到它的
    `Msg` 类型中：
- en: '[PRE128]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We''ll simply handle it in the `update()` method:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `update()` 方法中简单地处理它：
- en: '[PRE129]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: You can now run the application and see that it works exactly the same as the
    one from the previous chapter.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用程序并看到它的工作方式与上一章中的完全相同。
- en: Using relm on stable Rust
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在稳定版 Rust 上使用 relm
- en: 'In this whole chapter, we used Rust nightly to be able to use `custom` attributes,
    which are currently unstable. The `#[widget]` attribute provided by `relm` provides
    many advantages:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个这一章中，我们使用了 Rust 夜间版，以便能够使用当前不稳定的 `custom` 属性。`relm` 提供的 `#[widget]` 属性提供了许多优势：
- en: Declarative view
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性视图
- en: Data bindings
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Less typing
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入更少
- en: 'So it would be nice to be able to use a similar syntax on stable that provides
    the same advantages. And it is possible to do so, by using the `relm_widget!`
    macro. We''ll rewrite the `App` widget to use this macro:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够在稳定版上使用类似的语法并且提供相同优势将会很棒。通过使用 `relm_widget!` 宏，我们可以做到这一点。我们将重写 `App` 小部件以使用这个宏：
- en: '[PRE130]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: As you can see, we moved the external `open()` method inside the implementation
    decorated by the `relm_widget!` macro. This is due to a limitation of this macro,
    while it allows us to use the nice syntax provided by relm on stable Rust, we
    cannot access the fields of the model from outside the macro. The rest is exactly
    the same as the previous versions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将外部 `open()` 方法移动到了由 `relm_widget!` 宏装饰的实现内部。这是由于这个宏的限制，虽然它允许我们在稳定版 Rust
    上使用 relm 提供的漂亮语法，但我们无法从宏外部访问模型字段。其余部分与之前的版本完全相同。
- en: Relm widgets data binding
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Relm 小部件数据绑定
- en: 'There are many other features available in relm and I wanted to show you the
    most important of them: the syntax that is provided to simulate property binding.
    As you may have noticed by now, there''s no property in `relm` widgets, but you
    can use message passing to update the internal state of a `relm` widget. To make
    it more convenient, the `#[widget]` attribute also allows you to bind a model
    attribute to a message, this means that whenever the attribute is updated, the
    message will be emitted with this new value.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: relm 中还有许多其他功能可用，我想向你展示其中最重要的：提供的用于模拟属性绑定的语法。正如你可能已经注意到的，`relm` 小部件中没有属性，但你可以使用消息传递来更新
    `relm` 小部件的内部状态。为了使其更方便，`#[widget]` 属性还允许你将模型属性绑定到消息，这意味着每当属性更新时，都会发出带有这个新值的消息。
- en: 'We''ll add a toggle button to be able to switch between a simple and a detailed
    view for the playlist. The simple view will only show the cover and the title
    while the detailed view will show all the columns. First, let''s add an attribute
    to the `App` model:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个切换按钮，以便能够在播放列表的简单视图和详细视图之间切换。简单视图将只显示封面和标题，而详细视图将显示所有列。首先，让我们向 `App`
    模型添加一个属性：
- en: '[PRE131]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This field specifies whether we''re in the detailed view mode or not. We''ll
    also need a message that will be emitted when we click the toggle button:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段指定我们是否处于详细视图模式。我们还需要一个在点击切换按钮时将发出的消息：
- en: '[PRE132]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Then, we add the toggle button to the toolbar:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将切换按钮添加到工具栏中：
- en: '[PRE133]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'When we receive this message, we''ll set the `model` attribute accordingly:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到这个消息时，我们将相应地设置 `model` 属性：
- en: '[PRE134]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, let''s a message to the `Playlist`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向 `Playlist` 发送一个消息：
- en: '[PRE135]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'This is the message we''ll use for the binding. Let''s handle it:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于绑定的消息。让我们来处理它：
- en: '[PRE136]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The latter method toggles the visible of all columns except the first two.
    We can now create the binding in the `App` view:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 后者方法切换除前两个之外的所有列的可见性。现在我们可以在 `App` 视图中创建绑定：
- en: '[PRE137]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This code will send the `DetailedView` message with the specified attribute
    as the value whenever it changes.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在指定的属性发生变化时发送 `DetailedView` 消息。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we used `relm` to create a music player. We saw how simple
    it is to use rust nightly with `rustup`. We learned how to declaratively create
    views and use message passing to communicate between widgets. We also learned
    how to structure GUI applications by separating the model, the view, and the function
    to update the model in reaction to events. In the next chapter, we''ll switch
    to another project: an FTP server.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 `relm` 创建了一个音乐播放器。我们看到了如何使用 `rustup` 与 rust nightly 版本结合使用是多么简单。我们学习了如何声明式地创建视图，并使用消息传递在部件之间进行通信。我们还学习了如何通过分离模型、视图以及更新模型的函数来结构化
    GUI 应用程序。在下一章中，我们将切换到另一个项目：一个 FTP 服务器。
