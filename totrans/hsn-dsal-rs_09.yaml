- en: Ordering Things
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序事物
- en: '*Tidy house, tidy mind* is a saying that, as in its German variation, implies
    that order plays an important part in our lives. Anyone who wants to maximize
    efficiency has to rely on order, or risk the occasional time-consuming search
    through the chaos that has slowly unfolded. Having things in a particular order
    is great; it''s the process of getting there that is expensive.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*整理房屋，整理心灵*是一句谚语，正如其德语变体一样，意味着秩序在我们的生活中起着重要作用。任何想要最大化效率的人都必须依赖秩序，否则可能会偶尔花费大量时间在慢慢展开的混乱中进行搜索。拥有特定顺序的事物是很好的；但到达那里的过程是昂贵的。'
- en: 'This often does not feel like a good use of our time, or simply may not be
    worth it. While a computer does not exactly feel, the time required to sort things
    is of a similar cost. Minimizing this time is the goal of inventing new algorithms
    and improving their efficiency, which is necessary for a task as common as sorting.
    A call to `mycollection.sort()` is not expected to take seconds (or minutes or
    even hours), so this is also a matter of usability. In this chapter, we will explore
    several solutions for that, so you can look forward to learning about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常感觉不像是我们时间的良好利用，或者简单地可能不值得。虽然计算机并不确切地感觉，但排序事物所需的时间成本是相似的。最小化这一时间是发明新算法和改进其效率的目标，这对于像排序这样的常见任务来说是必要的。调用`mycollection.sort()`不应该需要几秒钟（或几分钟甚至几小时），因此这也是可用性的问题。在本章中，我们将探讨几个解决方案，因此你可以期待学习以下内容：
- en: Implementing and analyzing sorting algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和分析排序算法
- en: Knowing more about (in)famous sorting strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于（不）著名的排序策略
- en: From chaos to order
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从混乱到有序
- en: There are many sorting algorithms (and their individual variations), each with
    their individual characteristics. Since it is impossible to cover every algorithm
    in a single chapter, and considering their limited usefulness, this chapter covers
    a selected few.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多排序算法（及其各自的变体），每个都有其独特的特性。由于不可能在单章中涵盖每个算法，并且考虑到它们的有限实用性，本章涵盖了选定的几个。
- en: The selection should show the different strategies that are common in sorting
    a collection of items, many of which have been implemented in various libraries
    across different languages. Since many of you will never implement any sorting
    algorithms for productive use, this section is supposed to familiarize you with
    what's behind the scenes when a call to `mycollection.sort()` is issued, and why
    this could take a surprising amount of time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 选择应展示在排序项目集合中常见的不同策略，其中许多已经在不同语言的各个库中实现。由于你们中的许多人永远不会为生产目的实现任何排序算法，本节旨在使你们熟悉在发出`mycollection.sort()`调用时幕后发生的事情，以及为什么这可能需要令人惊讶的大量时间。
- en: 'Sorting algorithms fall into a group on each of these properties:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法根据这些属性分为不同的组：
- en: '**Stable**: Maintains a relative order when comparing equal values'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定**：在比较相等值时保持相对顺序'
- en: '**Hybrid**: Combines two or more sorting approaches (for example, by collection
    length)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：结合两种或多种排序方法（例如，按集合长度）'
- en: '**In-place**: Uses indices instead of full copies for passing collections around'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原地**：使用索引而不是完整副本来传递集合'
- en: While stable and hybrid algorithms are more complex and, in many cases, at a
    higher level (because they combine various approaches), in-place sorting is common
    and reduces the space and amount of copying an algorithm has to do.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然稳定和混合算法更复杂，并且在许多情况下处于更高层次（因为它们结合了各种方法），但原地排序是常见的，它减少了算法必须执行的空间和复制量。
- en: 'We have touched on a very basic sorting algorithm already: **insertion sort**.
    It is the exact algorithm most real life things are done with: when adding a new
    book to a bookshelf, most people will pick up the book, look at the property to
    order by (such as the author''s last name), and find the spot in their current
    collection, starting from the letter *A*. This is a very efficient approach and
    is used to build a new collection with minimal overhead, but it does not warrant
    its own section.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了一个非常基础的排序算法：**插入排序**。这是现实生活中大多数事情所使用的确切算法：当向书架上添加新书时，大多数人会拿起书，查看排序属性（例如作者的姓氏），并从字母*A*开始，找到他们当前收藏中的位置。这是一个非常有效的方法，用于以最小的开销构建新的收藏，但它不值得单独成章。
- en: 'Let''s start off with an absolute classic that is always a part of any university''s
    curriculum because of its simplicity: bubble sort.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从绝对经典且总是任何大学课程的一部分的简单算法开始：冒泡排序。
- en: Bubble sort
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Bubble sort is the infamous algorithm that university students often learn as
    their first sorting algorithm. In terms of performance and runtime complexity,
    it is certainly among the worst ways to sort a collection, but it's great for
    teaching.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是臭名昭著的算法，大学生通常将其作为他们第一个学习的排序算法。在性能和运行时间复杂度方面，它无疑是排序集合的最差方法之一，但非常适合教学。
- en: 'The principle is simple: walk through an array, scanning two elements and bringing
    them into the correct order by swapping. Repeat these steps until no swaps occur.
    The following diagram shows this process on the example array `[8, 9, 7, 6]`,
    where a total of four swaps establishes the order of `[6, 7, 8, 9]` by repeatedly
    comparing two succeeding elements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 原理很简单：遍历一个数组，扫描两个元素，并通过交换将它们带入正确的顺序。重复这些步骤，直到没有交换发生。以下图显示了在示例数组 `[8, 9, 7, 6]`
    上的此过程，总共进行了四次交换，通过反复比较两个连续的元素，建立了 `[6, 7, 8, 9]` 的顺序。
- en: '![](img/49af9e15-7037-4151-87d3-8a79f6380e00.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49af9e15-7037-4151-87d3-8a79f6380e00.png)'
- en: 'This diagram also shows an interesting (and name-giving) property of the algorithm:
    the "bubbling up" of elements to their intended position. The number `6` in the
    diagram travels, swap by swap, from the last position to the first position in
    the collection.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此图还显示了算法的一个有趣（且命名）的特性：元素“冒泡”到它们预期的位置。图中的数字`6`通过一次交换，从集合的最后位置移动到第一个位置。
- en: 'When this is transformed into Rust code, the simplicity remains: two nested
    loops iterate over the collection, whereas the outer loop could just as well run
    till infinity, since the inner portion does all the comparing and swapping.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当这被转换成Rust代码时，其简洁性仍然保持：两个嵌套循环遍历集合，而外层循环也可以无限运行，因为内层部分做了所有的比较和交换。
- en: 'Bubble sort is, infamously, a short snippet of code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序，臭名昭著，是一段简短的代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For easier handling, the algorithm creates a copy of the input array (using
    the `Into<T>` trait's `into()` method) and swaps around elements using the `swap()`
    method provided by `Vec<T>`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易处理，该算法创建了输入数组的副本（使用`Into<T>`特质的`into()`方法）并使用`Vec<T>`提供的`swap()`方法交换元素。
- en: 'The nested loops already hint toward the (worst case) runtime complexity: *O(n²)*.
    However, thanks to the early stopping when there are no swaps in a run, a partially
    ordered collection will be sorted surprisingly quickly. In fact, the best case
    scenario is really fast with bubble sort, since it''s basically a single run-through
    (in other words, *O(n)* in this case).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环已经暗示了（最坏情况）的运行时间复杂度：*O(n²)*。然而，由于在运行中没有交换时提前停止，部分有序集合将被惊人地快速排序。事实上，冒泡排序的最佳情况非常快，因为它基本上是单次遍历（换句话说，在这种情况下是*O(n)*）。
- en: 'The following chart shows three cases: sorting an already sorted collection
    (ascending numbers and descending numbers), as well as sorting a randomly shuffled
    array of distinct numbers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了三种情况：排序已排序的集合（升序数字和降序数字），以及排序一个由不同数字随机打乱的数组：
- en: '![](img/6d516145-94c2-4c8b-8794-612388aa77f5.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d516145-94c2-4c8b-8794-612388aa77f5.png)'
- en: The output graph comparison between Bubble sort ascending, descending, and randomly
    sorted arrays
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序升序、降序和随机排序数组的输出图比较
- en: 'The algorithm will produce an ascending sequence, yet the shuffled collection
    shows a worse absolute runtime than the traditional worst case: a collection sorted
    in descending order. In any case, the exponential nature of these runtimes shows
    why bubble sort is not fit for real-world use.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法将产生一个升序序列，但打乱后的集合的绝对运行时间比传统的最坏情况还要差：按降序排序的集合。无论如何，这些运行时间的指数性质显示了为什么冒泡排序不适合实际应用。
- en: Shell sort is sometimes dubbed as an optimized version of bubble sort!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 希尔排序有时被称为冒泡排序的优化版本！
- en: Shell sort
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 希尔排序
- en: 'Bubble sort always compares an element to the neighboring element, but is this
    important? Many would say that it depends on the pre-existing order of the unsorted
    collection: are these future neighbors far apart or close together?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序总是将一个元素与相邻的元素进行比较，但这重要吗？许多人会说，这取决于未排序集合的现有顺序：这些未来的邻居是相隔很远还是很近？
- en: Donald Shell, the inventor of shell sort, must have had a similar idea and used
    a "gap" between elements to make further jumps with the swapping approach adopted
    by bubble sort. By utilizing a specified strategy to choose those gaps, the runtime
    can change dramatically. Shell's original strategy is to start with half the collection's
    length and, by halving the gap size until zero, a runtime of *O(n²)* is achieved.
    Other strategies include choosing numbers based on some form of calculation of
    the current iteration *k* (for example, *2^k - 1*), or empirically collected gaps
    ([http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf](http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf)),
    which do not have a fixed runtime complexity yet!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 壳排序的发明者唐纳德·希尔（Donald Shell）肯定有类似的思路，并使用元素之间的“间隙”来采用冒泡排序的交换方法进行进一步的跳跃。通过利用特定的策略来选择这些间隙，运行时间可以发生显著变化。希尔的原策略是从集合长度的一半开始，通过将间隙大小减半直到零，实现了*O(n²)*的运行时间。其他策略包括根据当前迭代*k*（例如，*2^k
    - 1*）的某种形式的计算选择数字，或者根据经验收集的间隙([http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf](http://sun.aei.polsl.pl/~mciura/publikacje/shellsort.pdf))，这些间隙还没有固定的运行时间复杂度！
- en: 'The following diagram explains some of the workings of shell sort. First, the
    initial gap is chosen, which is `n / 2` in the original paper. Starting at that
    gap (`2`, in this particular example), the element is saved and compared to the
    element *at the other end of the gap*, in other words, the current index minus
    the gap:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了壳排序的一些工作原理。首先，选择初始间隙，原始论文中是`n / 2`。从那个间隙开始（在这个特定的例子中是`2`），保存元素并与间隙另一端的元素进行比较，换句话说，当前索引减去间隙：
- en: '![](img/c0ef36fb-3d18-4a9a-9dc4-22eacb87ec54.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0ef36fb-3d18-4a9a-9dc4-22eacb87ec54.png)'
- en: 'If the element at the other end of the gap is greater, it replaces the origin.
    Then, the process walks toward index zero with gap-sized steps, so the question
    becomes: what is going to fill that hole (`7` is overwritten by `8`, so the hole
    is where `8` was)—the original element, or element "gap" steps before it?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果间隙另一端的元素更大，它将替换原始元素。然后，这个过程以间隙大小的步长向索引零移动，所以问题变成了：什么将填补那个空隙（`7`被`8`覆盖，所以空隙是`8`所在的位置）——原始元素，还是它之前的元素“间隙”步数？
- en: In this example, it's `7`, since there is no preceding element. In longer collections,
    a lot more moving around can occur before the original element is inserted. After
    this insertion process has finished for index 2, it's repeated for index 3, moving
    from the gap toward the end of the collection. Following that, the gap size is
    reduced (in our case, by half) and the insertion steps are repeated until the
    collection is in order (and the gap size is zero).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，它是`7`，因为没有前面的元素。在更长的集合中，在原始元素插入之前可能会发生更多的移动。在完成索引2的插入过程后，它会对索引3重复这个过程，从间隙向集合的末尾移动。之后，间隙大小会减少（在我们的例子中，减半），然后重复插入步骤，直到集合有序（并且间隙大小为零）。
- en: 'Words, and even an image, make it surprisingly hard to understand what is going
    on. Code, however, shows the workings nicely:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单词，甚至是一张图片，都让人难以理解正在发生的事情。然而，代码却很好地展示了工作原理：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This snippet shows the value of shell sort: with the correct gap strategy,
    it can achieve results that are similar to more sophisticated sorting algorithms,
    but it is a lot shorter to implement and understand. Because of this, it can be
    a good choice for embedded use cases, where no library and only limited space
    is available.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了壳排序的价值：使用正确的间隙策略，它可以实现与更复杂的排序算法相似的结果，但它实现起来要短得多，理解起来也容易得多。正因为如此，它对于嵌入式用例来说可能是一个不错的选择，在这些用例中，没有库，只有有限的空间可用。
- en: 'The actual performance on the test sets is good:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试集上的实际性能很好：
- en: '![](img/13270bdd-7cb8-4119-ab99-f66fe233620e.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13270bdd-7cb8-4119-ab99-f66fe233620e.png)'
- en: The output graph comparison between shell sort ascending, descending, and randomly
    sorted arrays
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 壳排序升序、降序和随机排序数组之间的输出图比较
- en: Even with the original gap strategy that is said to produce *O(n²)* runtimes,
    the random set produces something more akin to linear behavior. Definitely a solid
    performance, but can it compare to heap sort?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是据说会产生*O(n²)*运行时间的原始间隙策略，随机集合也产生了更接近线性行为的结果。绝对是一个良好的性能，但它能与堆排序相比吗？
- en: Heap sort
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆排序
- en: 'Ordering numbers was already a topic that we covered earlier in this book ([Chapter
    5](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml), *Robust Trees*) while discussing
    trees: with heaps. A heap is a tree-like data structure with the highest (max-heap)
    or lowest number (min-heap) at the root that maintains order when inserting or
    removing elements. Hence, a sorting mechanism could be as simple as inserting
    everything into a heap and retrieving it again!'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们之前已经讨论过排序数字的话题（[第5章](84f203ac-a9f6-498b-90ff-e069c41aaca0.xhtml)，*健壮的树*），当时在讨论树：堆。堆是一种类似树的数据结构，其根节点具有最高（最大堆）或最低（最小堆）数值，在插入或删除元素时保持有序。因此，排序机制可以简单到将所有内容插入堆中，然后再检索出来！
- en: 'Since a (binary) heap has a known runtime complexity of *O(log n)*, and the
    entire array has to be inserted, the estimated runtime complexity will be *O(n
    log n)*, among the best sorting performances in sorting. The following diagram
    shows the binary heap in tree notation on the right, and the array implementation
    on the left:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于（二叉）堆的已知运行时间复杂度为*O(log n*)，并且整个数组都必须插入，因此估计的运行时间复杂度将是*O(n log n*)，这是排序中最佳性能之一。以下图表显示了右侧的树表示法中的二叉堆和左侧的数组实现：
- en: '![](img/87a58184-896d-489c-8fe7-5d4ce6ea28e3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87a58184-896d-489c-8fe7-5d4ce6ea28e3.png)'
- en: 'In the Rust standard library, there is a `BinaryHeap` structure available,
    which makes the implementation quick and easy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust标准库中，有一个可用的`BinaryHeap`结构，这使得实现变得快速且简单：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The fact that a heap is used to do the sorting will generate fairly uniform
    outcomes, making it a great choice for unordered collections, but an inferior
    choice for presorted ones. This is due to the fact that a heap is filled and emptied,
    regardless of the pre-existing ordering. Plotting the different cases shows almost
    no difference:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆进行排序的事实将产生相当均匀的结果，使其成为无序集合的优秀选择，但对于预先排序的集合则不是最佳选择。这是因为无论预先存在的排序如何，堆都会被填充和清空。绘制不同情况几乎显示没有差异：
- en: '![](img/2ba32ddb-8ca6-4a97-b5ce-4e9e58789cf4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ba32ddb-8ca6-4a97-b5ce-4e9e58789cf4.png)'
- en: The output graph comparison between heap sort ascending, descending, and randomly
    sorted arrays
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序升序、降序和随机排序数组的输出图比较
- en: A very different strategy, called *divide and conquer*, is employed by an entire
    group of algorithms. This group is what we are going to explore now, starting
    with merge sort.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常不同的策略，称为*分而治之*，被一组算法所采用。我们现在将要探索的这一组算法，从归并排序开始。
- en: Merge sort
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: One fundamental strategy in battle, as well as in sorting collections, is to
    divide and conquer. Merge sort does exactly that, by splitting the collection
    in half recursively until only a single element remains. The merging operation
    can then put these single elements together in the correct order with the benefit
    of working with presorted collections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 战斗中的一个基本策略，以及在排序集合中，是分而治之。归并排序正是通过递归地将集合分成两半，直到只剩下一个元素来做到这一点。合并操作可以利用预先排序的集合的优势，将这些单个元素按正确顺序放在一起。
- en: 'What this does is reduce the problem size (in other words, the number of elements
    in the collection) to more manageable chunks that come presorted for easier comparison,
    resulting in a worst case runtime complexity of *O(n log n)*. The following diagram
    shows the split and merge process (note that comparing and ordering only starts
    at the merge step):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是将问题规模（换句话说，集合中的元素数量）减少到更易于管理的块，这些块预先排序，以便更容易比较，从而在最坏情况下的运行时间复杂度为*O(n log
    n*)。以下图表显示了拆分和合并过程（请注意，比较和排序仅在合并步骤开始）：
- en: '![](img/8471c780-90ab-4e95-98a8-0162ddaff0f3.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8471c780-90ab-4e95-98a8-0162ddaff0f3.png)'
- en: 'There are various implementations of this principle: bottom up, top down, using
    blocks, and other variations. In fact, as of 2018, Rust''s default sorting algorithm
    is Timsort, a stable, hybrid algorithm that combines insertion sort (up until
    a certain size) with merge sort.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则有多种实现方式：自下而上、自上而下、使用块以及其他变体。实际上，截至2018年，Rust的默认排序算法是Timsort，这是一种稳定、混合算法，它将插入排序（直到一定大小）与归并排序相结合。
- en: Implementing a vanilla merge sort in Rust is, again, a great place to use recursion.
    First, the left half is evaluated, then the right half of a sequence, and only
    then does merging begin, first by comparing the two sorted results (left and right)
    and picking elements from either side. Once one of these runs out of elements,
    the rest is simply appended since the elements are obviously larger. This result
    is returned to the caller, repeating the merging on a higher level until the original
    caller is reached.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中实现简单的归并排序，再次是一个很好的使用递归的地方。首先，评估序列的左半部分，然后是右半部分，然后才开始合并，首先是通过比较两个已排序的结果（左和右）并从任一边选择元素。一旦这些运行用完了元素，剩下的就简单地附加，因为元素显然更大。这个结果被返回给调用者，重复在更高层次上的合并，直到达到原始调用者。
- en: 'Here''s the Rust code for a typical merge sort implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是典型归并排序实现的 Rust 代码：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This behavior also pays off, creating a quasi-linear runtime complexity, as
    shown in the following plot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为也有回报，创建了一个准线性的运行时间复杂度，如下面的图表所示：
- en: '![](img/24ed5a69-8014-4793-a25b-93bf72a593a0.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24ed5a69-8014-4793-a25b-93bf72a593a0.png)'
- en: The output graph comparison between Quicksort asc, desc, and random
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Quicksort 升序、降序和随机输出图比较
- en: Another divide-and-conquer-type algorithm is Quicksort. It's a very interesting
    way to sort a list for a variety of reasons.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个分而治之类型的算法是快速排序。由于多种原因，这是一种非常有趣的排序列表的方法。
- en: Quicksort
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序
- en: 'This algorithm significantly outperformed merge sort in best case scenarios
    and was quickly adopted as Unix''s default sorting algorithm, as well as in Java''s
    reference implementation. By using a similar strategy to merge sort, Quicksort
    achieves faster average and best case speeds. Unfortunately, the worst case complexity
    is just as bad as bubble sort: *O(n²)*. How so? you might ask.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法在最佳情况下显著优于归并排序，并迅速被采纳为 Unix 的默认排序算法，以及 Java 的参考实现。通过使用与归并排序类似的策略，快速排序实现了更快的平均和最佳速度。不幸的是，最坏情况下的复杂度与冒泡排序一样：*O(n²)*。为什么会这样？你可能会问。
- en: 'Quicksort operates, sometimes recursively, on parts of the full collection,
    and swaps elements around to establish an order. Hence, the critical question
    becomes: how do we choose these parts? This choosing bit is called the partitioning
    scheme and typically includes the swapping as well, not just choosing a split
    index. The choice is made by picking a pivot element, the value of which is what
    everything is compared with.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序在全集的部分上操作，有时是递归的，并交换元素以建立顺序。因此，关键问题变成了：我们如何选择这些部分？这个选择部分被称为分区方案，通常包括交换，而不仅仅是选择一个分割索引。选择是通过选择一个枢轴元素来进行的，其值是所有内容与之比较的。
- en: Everything less than the pivot value goes to one side, and everything greater
    goes to the other—by swapping. Once the algorithm detects a nice ascending (on
    the one side) and descending (from the other side) order, the split can be made
    where the two sequences intersect. Then, the entire process starts anew with each
    of the partitions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 小于枢轴值的所有内容都移到一边，而大于的内容则移到另一边——通过交换。一旦算法检测到一边是升序（另一边是降序），就可以在两个序列相交的地方进行分割。然后，整个过程重新开始，每个分区都从新开始。
- en: 'The following illustration shows the picking and ordering of the elements based
    on the previous example collection. While the partitions in this example are only
    length one versus the rest, the same process would apply if these were longer
    sequences as well:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图显示了基于先前示例集合的元素选择和排序。虽然在这个例子中，分区只有一个长度与剩余部分相比，但如果这些是更长的序列，同样的过程也会适用：
- en: '![](img/71ad8529-8a9f-4779-bdf2-7b9ac0cf55f6.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71ad8529-8a9f-4779-bdf2-7b9ac0cf55f6.png)'
- en: 'The partitioning scheme used here is called the Hoare scheme, named after the
    inventor of Quicksort, Sir Anthony Hoare, in 1959\. There are other schemes (Lomuto
    seems to be the most popular alternative) that may provide better performance
    by trading off various other aspects, such as memory efficiency or the number
    of swaps. Whatever the partition scheme, picking a pivot value plays a major role
    in performance as well and the more equal parts it produces (like the median),
    the better the value is. Potential strategies include the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的分区方案被称为霍尔方案，以 1959 年发明快速排序的发明者，安东尼·霍尔爵士命名。还有其他方案（Lomuto 似乎是最受欢迎的替代方案）可能通过权衡其他方面（如内存效率或交换次数）来提供更好的性能。无论分区方案如何，选择枢轴值在性能中也起着重要作用，它产生的部分越均匀（如中位数），值就越好。潜在策略包括以下：
- en: Choosing the median
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择中位数
- en: Choosing the arithmetic mean
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择算术平均值
- en: Picking an element (random, first, or last, as chosen here)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个元素（随机、第一个或最后一个，如这里所示）
- en: 'In Rust code, Quicksort is implemented in three functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust代码中，快速排序通过三个函数实现：
- en: The public API to provide a usable interface
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共API以提供可用的接口
- en: A wrapped recursive function that takes a low and high index to sort in-between
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包装的递归函数，它接受一个低索引和高索引来对中间部分进行排序
- en: The partition function implementing the Hoare partition scheme
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现霍尔划分方案的划分函数
- en: 'This implementation can be considered in-place since it operates on the same
    vector that was provided in the beginning, swapping elements based on their indices.
    Here is the code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它操作的是最初提供的同一向量，根据它们的索引交换元素，因此这个实现可以被认为是就地操作。以下是代码：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another new aspect in this implementation is the use of loop labels, which allow
    for better structure and readability. This is due to Hoare's use of a do-until
    type loop, a syntax that is not available in Rust, but that required the algorithm
    to avoid an infinite loop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，另一个新的方面是使用循环标签，这有助于提高结构和可读性。这是由于霍尔使用了do-until类型的循环，这种语法在Rust中不可用，但算法需要避免无限循环。
- en: 'The `break`/`continue` instructions are relatives of the infamous go-to instruction,
    so they should only be used sparingly and with great care for the purpose of readability.
    Loop labels provide a tool to achieve that. They allow a reader to track exactly
    which loop is being exited or continued. The syntax leans slightly on that of
    the lifetimes: `''mylabel: loop { break ''mylabel; }`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`/`continue`指令是臭名昭著的goto指令的亲戚，因此它们应该仅在使用时谨慎且非常小心，以增加可读性。循环标签提供了一种实现这一点的工具。它们允许读者跟踪确切是哪个循环正在退出或继续。语法略微借鉴了生命周期的语法：`''mylabel:
    loop { break ''mylabel; }`。'
- en: Quicksort's performance characteristics are definitely interesting. The rare
    worst case behavior or *O(n²)* has triggered many optimizations over the decades
    since its invention, the latest of which is called Dual-Pivot Quicksort from 2009,
    which has been adopted in Oracle's library for Java 7\. Refer to the *Further
    reading* section for a more detailed explanation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的性能特征确实很有趣。自其发明以来，罕见的worst case行为或*O(n²)*触发了数十年的优化，其中最新的是2009年的Dual-Pivot
    Quicksort，它已被Oracle的Java 7库采用。有关更详细的解释，请参阅*进一步阅读*部分。
- en: 'Running the original Quicksort on the previous dataset, the worst case and
    best case behaviors are clearly visible. The performance on the descending and
    (curiously) the ascending datasets is clearly *O(n²)*, while the randomized array
    is quickly processed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始数据集上运行快速排序，最坏情况和最佳情况行为明显可见。在降序和（令人好奇的）升序数据集上的性能明显是*O(n²)*，而随机数组则被快速处理：
- en: '![](img/0ef3c141-c993-4c43-957c-2fbef567911d.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ef3c141-c993-4c43-957c-2fbef567911d.png)'
- en: The output graph comparison between Quicksort ascensding, descending and randomly
    sorted arrays
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序在升序、降序和随机排序数组之间的输出图比较
- en: This behavior speaks for the Quicksort's strong sides, which are more "real-world"
    type scenarios, where the worst case rarely appears. In current libraries around
    various programming languages though, sorting is done in a hybrid fashion, which
    means that these generic algorithms are used according to their strengths. This
    approach is called **Introsort** (from introspective sort) and, in C++'s `std::sort`,
    relies on Quicksort up to a certain point. Rust's standard library, however, uses
    Timsort.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为说明了快速排序的强项，这些强项更符合“现实世界”类型的场景，其中最坏的情况很少出现。然而，在当前各种编程语言的库中，排序是以混合方式进行的，这意味着这些通用算法根据它们的优点被使用。这种方法被称为**Introsort**（来自自省排序），在C++的`std::sort`中，它依赖于快速排序直到某个点。然而，Rust的标准库使用Timsort。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Putting things in order is a very fundamental problem that has been solved in
    many different ways, varying in aspects such as worst-case runtime complexity,
    memory required, the relative order of equal elements (stability), as well as
    overall strategies. A few fundamental approaches were presented in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将事物排序是一个非常基本的问题，它以许多不同的方式得到解决，这些方式在诸如最坏情况运行时间复杂度、所需内存、相等元素的相对顺序（稳定性）以及整体策略等方面有所不同。本章介绍了一些基本方法。
- en: '**Bubble sort** is one of the simplest algorithms to implement, but it comes
    at a high runtime cost, with a worst-case behavior of *O(n²)*. This is due to
    the fact that it simply swaps elements based on a nested loop, which makes elements
    "bubble up" to either end of the collection.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**冒泡排序**是实施起来最简单的算法之一，但它有很高的运行时成本，最坏情况下的行为为*O(n²)*。这是因为它简单地根据嵌套循环交换元素，使得元素“冒泡”到集合的任一端。'
- en: '**Shell sort** can be seen as an improved version of bubble sort, with a major
    upside: it does not start off by swapping neighbors. Instead, there is a gap that
    elements are compared and swapped across, covering a greater distance. This gap
    size changes with every round that shows worst-case runtime complexities of *O(n²)*
    for the original scheme to *O(n log n)* in the fastest variant. In fact, the runtime
    complexity of some empirically derived gaps cannot even be measured reliably!'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**希尔排序**可以看作是冒泡排序的改进版本，有一个主要优点：它不是从交换相邻元素开始。相反，有一个间隔，元素在这个间隔内进行比较和交换，覆盖了更长的距离。这个间隔大小随着每一轮的进行而改变，从原始方案的*O(n²)*最坏情况运行时复杂度到最快变体的*O(n
    log n)*。实际上，一些经验推导出的间隔的运行时复杂度甚至无法可靠地测量！'
- en: '**Heap sort** makes use of a data structure''s property to create a sorted
    collection. The heap, as presented earlier, retains the largest (or smallest)
    element at its root, returning it at every `pop()`. Heap sort therefore simply
    inserts the entire collection into a heap, only to retrieve it one by one in a
    sorted fashion. This leads to a runtime complexity of *O(n log n)*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆排序**利用数据结构的属性来创建一个有序集合。正如之前所提到的，堆在其根节点保留最大（或最小）元素，并在每次`pop()`时返回它。因此，堆排序简单地将整个集合插入堆中，然后按顺序逐个检索。这导致运行时复杂度为*O(n
    log n)*。'
- en: Tree-based strategies are also found in **merge sort**, a divide-and-conquer
    approach. This algorithm recursively splits the collection in half to sort the
    subset before working on the entire collection. This work is done when returning
    from the recursive calls when the resulting sub-collections have to be merged,
    hence the name. Typically, this will exercise a runtime complexity of *O(n log
    n)*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于树的策略也存在于**归并排序**中，这是一种分而治之的方法。该算法递归地将集合分成一半以排序子集，然后再处理整个集合。这项工作是在从递归调用返回时进行的，当结果子集需要合并时。因此得名。通常，这将导致运行时复杂度为*O(n
    log n)*。
- en: '**Quicksort** also uses a divide-and-conquer approach, but instead of simply
    breaking the collection in half every time, it works with a pivot value, where
    the other values are swapped before looking at each sub-collection. This results
    in a worst-case behavior of *O(n²)*, but Quicksort is often used for its frequent
    average complexity of *O(n log n)*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速排序**也使用分而治之的方法，但不是每次都简单地将集合分成两半，而是使用一个枢轴值，在查看每个子集合之前，将其他值与枢轴值交换。这导致最坏情况下的行为为*O(n²)*，但快速排序通常因其频繁的平均复杂度为*O(n
    log n)*而被使用。'
- en: Nowadays, standard libraries use hybrid approaches such as Timsort, Introsort,
    or pattern-defeating Quicksort to get the best absolute and relative runtime performance.
    Rust's standard library provides either a stable sorting function for slices (`slice::sort()`
    versus `slice::sort_unstable()`) based on merge sort, and an unstable sorting
    function based on the pattern-defeating Quicksort.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，标准库使用混合方法，如Timsort、Introsort或模式击败的快速排序，以获得最佳绝对和相对运行时性能。Rust的标准库提供基于归并排序的稳定排序函数（`slice::sort()`与`slice::sort_unstable()`），以及基于模式击败的快速排序的不稳定排序函数。
- en: This chapter aimed to be the basis for the next chapter, which will cover how
    to find a specific element, something that typically requires a sorted collection!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在成为下一章的基础，下一章将介绍如何找到特定元素，这通常需要有序集合！
- en: Questions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is sorting an important aspect of programming?
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么排序是编程的一个重要方面？
- en: What makes values bubble up in bubble sort?
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在冒泡排序中是什么使得值向上冒泡？
- en: Why is shell sort useful?
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么希尔排序是有用的？
- en: Can heap sort outperform bubble sort in its best case scenario?
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆排序在其最佳情况下能否优于冒泡排序？
- en: What do merge sort and Quicksort have in common?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序和快速排序有什么共同之处？
- en: What are hybrid sorting algorithms?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合排序算法是什么？
- en: Further reading
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的参考资料，您可能需要参考本章所涵盖的内容：
- en: '*Dual-Pivot Quicksort* ([https://web.archive.org/web/20151002230717/http://iaroslavski.narod.ru/quicksort/DualPivotQuicksort.pdf](https://web.archive.org/web/20151002230717/http://iaroslavski.narod.ru/quicksort/DualPivotQuicksort.pdf))'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双轴快速排序* ([https://web.archive.org/web/20151002230717/http://iaroslavski.narod.ru/quicksort/DualPivotQuicksort.pdf](https://web.archive.org/web/20151002230717/http://iaroslavski.narod.ru/quicksort/DualPivotQuicksort.pdf))'
- en: C++ sorting explained ([https://medium.com/@lucianoalmeida1/exploring-some-standard-libraries-sorting-functions-dd633f838182](https://medium.com/@lucianoalmeida1/exploring-some-standard-libraries-sorting-functions-dd633f838182))
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 排序解释 ([https://zhuanlan.zhihu.com/p/27633895](https://zhuanlan.zhihu.com/p/27633895))
- en: Wikipedia on Introsort ([https://en.wikipedia.org/wiki/Introsort](https://en.wikipedia.org/wiki/Introsort))
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的 Introsort ([https://zh.wikipedia.org/wiki/Introsort](https://zh.wikipedia.org/wiki/Introsort))
- en: Wikipedia on Timsort ([https://en.wikipedia.org/wiki/Timsort](https://en.wikipedia.org/wiki/Timsort))
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的 Timsort ([https://zh.wikipedia.org/wiki/Timsort](https://zh.wikipedia.org/wiki/Timsort))
- en: Pattern defeating Quicksort ([https://github.com/orlp/pdqsort](https://github.com/orlp/pdqsort))
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打败快速排序的模式 ([https://github.com/orlp/pdqsort](https://github.com/orlp/pdqsort))
