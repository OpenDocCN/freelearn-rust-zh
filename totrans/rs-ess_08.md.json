["```rs\n// code from Chapter 8/code/thread_spawn.rs:\nuse std::thread;\nfn main() {\n thread::spawn(move || {\n println!(\"Hello from the goblin in the spawned thread!\");\n });\n}\n```", "```rs\n  fn main() {\n    thread::spawn(move || { …  });\n thread::sleep_ms(50);\n}\n```", "```rs\nfn main() {\n let handle = thread::spawn(move || {\n        println!(\"Hello from the goblin in the spawned thread!\");\n });\n// do other work in the meantime\n let output = handle.join().unwrap();\n  println!(\"{:?}\", output); // ()\n}\n```", "```rs\nthread::spawn(move || { \n// work done in child thread \n}).join();\n\n```", "```rs\n// code from Chapter 8/code/many_threads.rs:\t\nuse std::thread;\nstatic NTHREADS: i32 = 10000;\nfn main() {\n    for i in 0..NTHREADS {\n        let _ = thread::spawn(move || {\n            println!(\"this is thread number {}\", i)\n        });\n    }\n}\n```", "```rs\nthis is thread number 1\nthis is thread number 3\nthis is thread number 4\nthis is thread number 2\nthis is thread number 6\nthis is thread number 5\nthis is thread number 0\n…\n```", "```rs\n    [dependencies]\n    num_cpus = \"*\"\n    ```", "```rs\n    extern crate num_cpus;\n    fn main() {\n      let ncpus = num_cpus::get();\n      println!(\"The number of cpus in this machine is: {}\", ncpus);\n    }\n    ```", "```rs\nextern crate threadpool;\n\nuse std::thread;\nuse threadpool::ThreadPool;\n\n```", "```rs\nlet pool = ThreadPool::new(ncpus);\nfor i in 0..ncpus {\n pool.execute(move || {\n        println!(\"this is thread number {}\", i)\n   });\n}\nthread::sleep_ms(50);\n```", "```rs\nthis is thread number 0\nthis is thread number 5\nthis is thread number 7\nthis is thread number 3\nthis is thread number 4\nthis is thread number 1\nthis is thread number 6\nthis is thread number 2\n```", "```rs\n// code from Chapter 8/code/panic_thread.rs:\t\nuse std::thread;\nfn main() {\n  let result = thread::spawn(move || {\n      panic!(\"I have fallen into an unrecoverable trap!\");\n  }).join();\n  if result.is_err() {\n   println!(\"This child has panicked\");\n  }\n}\n```", "```rs\nthread '<unnamed>' panicked at 'I' have fallen into an unrecoverable trap!'\nThis child has panicked\n```", "```rs\n// code from Chapter 8/code/not_shared.rs:\nuse std::thread;\nfn main() {\n    let mut health = 12;\n    for i in 2..5 {\n        thread::spawn(move || {\n            health *= i;\n        });\n    }\n    thread::sleep_ms(2000);\n    println!(\"{}\", health); // 12\n}\n```", "```rs\n// code from Chapter 8/code/thread_safe.rs:\t\nlet data = Mutex::new(health);\n\n```", "```rs\n     for i in 2..5 {\t\n       thread::spawn(move || {\n let mut health = data.lock().unwrap();\n            // do other things\n       }\n     }\n```", "```rs\n let data = Arc::new(Mutex::new(health));\n\n```", "```rs\n  for i in 2..5 {\n      let mutex = data.clone();\n      thread::spawn(move || { \n         let mut health = mutex.lock().unwrap();\n         *health *= i;\n      });\n  }\n```", "```rs\n// code from Chapter 8/code/thread_safe.rs:\nuse std::thread;\nuse std::sync::{Arc, Mutex};\nfn main() {\n  let mut health = 12;\n  println!(\"health before: {:?}\", health);\n  let data = Arc::new(Mutex::new(health));\n  for i in 2..5 {\n        let mutex = data.clone();\n        thread::spawn(move || {\n            let health = mutex.lock();\n            match health {\n                // health is multiplied by i:\n                Ok(mut health) => *health *= i,\n                Err(str) => println!(\"{}\", str)\n            }\n        }).join().unwrap();\n    };\n    health = *data.lock().unwrap();\n    println!(\"health after: {:?}\", health);\n}\n```", "```rs\nhealth before: 12\nhealth after: 288\n```", "```rs\nhealth = *data.lock().unwrap();\n```", "```rs\n// code from Chapter 8/code/channels.rs:\nuse std::thread;\nuse std::sync::mpsc::channel;\nuse std::sync::mpsc::{Sender, Receiver};\nfn main() {\n let (tx, rx): (Sender<i32>, Receiver<i32>) = channel();\n}\n```", "```rs\nfn main() {\n  let (tx, rx) = channel();\n  thread::spawn(move|| {\n tx.send(10).unwrap();\n  });\n let res = rx.recv().unwrap();\n  println!(\"{:?}\", res); \n}\n```", "```rs\ntx.send(10).ok().expect(\"Unable to send message\");\n\n```", "```rs\nlet _ = rx.recv();\n```", "```rs\n// code from Chapter 8/code/channels2.rs:\nuse std::thread;\nuse std::sync::mpsc::channel;\nfn main() {\n  let (tx, rx) = channel();\n\n    thread::spawn(move|| {\n        let result = some_expensive_computation();\n        tx.send(result).ok().expect(\"Unable to send message\");\n    });\n    some_other_expensive_computation();\n    let result = rx.recv();\n    println!(\"{:?}\", result);  \n}\nfn some_expensive_computation() -> i32 { 1 }\nfn some_other_expensive_computation() { }\n```", "```rs\n// code from Chapter 8/code/make_channel.rs:\nuse std::sync::mpsc::channel;\nuse std::sync::mpsc::Receiver;\nfn make_chan() -> Receiver<i32> {\n let (tx, rx) = channel();\n tx.send(7).unwrap();\n rx\n}\n\nfn main() {\n    let rx = make_chan();\n if let Some(msg) = rx.recv().ok() {\n        println!(\"received message {}\", msg);\n    };\n}\n```", "```rs\n// code from Chapter 8/code/sync_channel.rs:\nuse std::sync::mpsc::sync_channel;\nuse std::thread;\ntype TokenType = i32;\nstruct Msg {\n    typ: TokenType,\n    val: String,\n}\n\nfn main() {\n let (tx, rx) = sync_channel(1); // buffer size 1\n    tx.send(Msg {typ: 42, val: \"Rust is cool\".to_string()}).unwrap();\n    println!(\"message 1 is sent\");\n    thread::spawn(move|| {\n    tx.send(Msg {typ: 43, val: \"Rust is still cool\".to_string()}).unwrap();\n        println!(\"message 2 is sent\");\n    });\n    println!(\"Waiting for 3 seconds ...\");\n    thread::sleep_ms(3000);\n    if let Some(msg) = rx.recv().ok() {\n      println!(\"received message of type {} and val {}\", msg.typ, msg.val);\n    };\n    if let Some(msg) = rx.recv().ok() {\n      println!(\"received second message of type {} and val {}\", msg.typ, msg.val);\n    };\n}\n```", "```rs\nmessage 1 is sent\nWaiting for 3 seconds\n```", "```rs\nreceived message of type 42 and val Rust is cool\nmessage 2 is sent\nreceived second message of type 43 and val Rust is still cool\n```"]