["```rs\n=> PWD\\r\\n\n<= 257 \"/\"\\r\\n\n```", "```rs\n=> NOOP\\r\\n\n<= 250 Doing nothing\\r\\n\n```", "```rs\n=> NOOP\\r\\n\n<= 250 42 is life\\r\\n\n```", "```rs\nuse std::net::TcpListener;\nuse std::io::Write;\n\nfn main() {\n    let listener = TcpListener::bind(\"0.0.0.0:1234\").expect(\"Couldn't bind this \n    address...\");\n\n    println!(\"Waiting for clients to connect...\");\n    for stream in listener.incoming() {\n        Ok(stream) => {\n            println!(\"New client!);\n            if let Err(_) = stream.write(b\"hello\") {\n                println!(\"Failed to send hello... :'(\");\n            }\n        }\n        _ => {\n            println!(\"A client tried to connect...\")\n        }\n    }\n}\n```", "```rs\nlet listener = TcpListener::bind(\"0.0.0.0:1234\").expect(\"Couldn't bind this address...\");\n```", "```rs\nfor stream in listener.incoming() {\n```", "```rs\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\n\nfn handle_client(mut stream: TcpStream) {\n    println!(\"new client connected!\");\n    // put client code handling here\n}\n\nfn main() {\n    let listener = TcpListener::bind(\"0.0.0.0:1234\").expect(\"Couldn't bind this \n    address...\");\n\n    println!(\"Waiting for clients to connect...\");\n    for stream in listener.incoming() {\n        Ok(stream) => {\n            thread::spawn(move || {\n                handle_client(stream);\n            });\n        }\n        _ => {\n            println!(\"A client tried to connect...\")\n        }\n    }\n}\n```", "```rs\nuse use std::net::TcpStream;\nuse std::io::Write;\n\nfn send_cmd(stream: &mut TcpStream, code: ResultCode, message: &str) {\n    let msg = if message.is_empty() { CommandNotImplemented = 502,\n        format!(\"{}\\r\\n\", code as u32)\n    } else {\n        format!(\"{} {}\\r\\n\", code as u32, message)\n    };\n    println!(\"<==== {}\", msg);\n    write!(stream, \"{}\", msg).unwrap()\n}\n```", "```rs\n#[derive(Debug, Clone, Copy)]\n#[repr(u32)]\n#[allow(dead_code)]\nenum ResultCode {\n    RestartMarkerReply = 110,\n    ServiceReadInXXXMinutes = 120,\n    DataConnectionAlreadyOpen = 125,\n    FileStatusOk = 150,\n    Ok = 200,\n    CommandNotImplementedSuperfluousAtThisSite = 202,\n    SystemStatus = 211,\n    DirectoryStatus = 212,\n    FileStatus = 213,\n    HelpMessage = 214,\n    SystemType = 215,\n    ServiceReadyForNewUser = 220,\n    ServiceClosingControlConnection = 221,\n    DataConnectionOpen = 225,\n    ClosingDataConnection = 226,\n    EnteringPassiveMode = 227,\n    UserLoggedIn = 230,\n    RequestedFileActionOkay = 250,\n    PATHNAMECreated = 257,\n    UserNameOkayNeedPassword = 331,\n    NeedAccountForLogin = 332,\n    RequestedFileActionPendingFurtherInformation = 350,\n    ServiceNotAvailable = 421,\n    CantOpenDataConnection = 425,\n    ConnectionClosed = 426,\n    FileBusy = 450,\n    LocalErrorInProcessing = 451,\n    InsufficientStorageSpace = 452,\n    UnknownCommand = 500,\n    InvalidParameterOrArgument = 501,\n    CommandNotImplemented = 502,\n    BadSequenceOfCommands = 503,\n    CommandNotImplementedForThatParameter = 504,\n    NotLoggedIn = 530,\n    NeedAccountForStoringFiles = 532,\n    FileNotFound = 550,\n    PageTypeUnknown = 551,\n    ExceededStorageAllocation = 552,\n    FileNameNotAllowed = 553,\n}\n```", "```rs\nuse std::io;\nuse std::str;\n\n#[derive(Clone, Copy, Debug)]\nenum Command {\n    Auth,\n    Unknown(String),\n}\n\nimpl AsRef<str> for Command {\n    fn as_ref(&self) -> &str {\n        match *self {\n            Command::Auth => \"AUTH\",\n            Command::Unknown(_) => \"UNKN\",\n        }\n    }\n}\n\nimpl Command {\n    pub fn new(input: Vec<u8>) -> io::Result<Self> {\n        let mut iter = input.split(|&byte| byte == b' ');\n        let mut command = iter.next().expect(\"command in \n         input\").to_vec();\n        to_uppercase(&mut command);\n        let data = iter.next();\n        let command =\n            match command.as_slice() {\n             b\"AUTH\" => Command::Auth,\n             s => Command::Unknown(str::from_utf8(s).unwrap_or(\"\").to_owned()),\n            };\n        Ok(command)\n    }\n}\n```", "```rs\nenum Command {\n    Auth,\n    Unknown(String),\n}\n```", "```rs\nenum Command {\n    Auth,\n    Cwd(PathBuf),\n    Unknown(String),\n}\n```", "```rs\nCommand::Cwd(_) => \"CWD\",\n```", "```rs\nb\"CWD\" => Command::Cwd(data.map(|bytes| Path::new(str::from_utf8(bytes).unwrap()).to_path_buf()).unwrap()),\n```", "```rs\nfn foo<S: AsRef<str>>(f: S) {\n    println!(\"{}\", f.as_ref());\n}\n```", "```rs\npub fn new(input: Vec<u8>) -> io::Result<Self> {\n    let mut iter = input.split(|&byte| byte == b' ');\n    let mut command = iter.next().expect(\"command in input\").to_vec();\n    to_uppercase(&mut command);\n    let data = iter.next();\n    let command =\n        match command.as_slice() {\n         b\"AUTH\" => Command::Auth,\n         s => Command::Unknown(str::from_utf8(s).unwrap_or(\"\").to_owned()),\n        };\n    Ok(command)\n}\n```", "```rs\nlet mut iter = input.split(|&byte| byte == b' ');\n```", "```rs\nlet mut command = iter.next().expect(\"command in input\").to_vec();\n```", "```rs\nfn to_uppercase(data: &mut [u8]) {\n    for byte in data {\n        if *byte >= 'a' as u8 && *byte <= 'z' as u8 {\n            *byte -= 32;\n        }\n    }\n}\n```", "```rs\nlet data = iter.next();\n```", "```rs\nmatch command.as_slice() {\n    b\"AUTH\" => Command::Auth,\n    s => Command::Unknown(str::from_utf8(s).unwrap_or(\"\").to_owned()),\n}\n```", "```rs\nfn read_all_message(stream: &mut TcpStream) -> Vec<u8> {\n    let buf = &mut [0; 1];\n    let mut out = Vec::with_capacity(100);\n\n    loop {\n        match stream.read(buf) {\n            Ok(received) if received > 0 => {\n                if out.is_empty() && buf[0] == b' ' {\n                    continue\n                }\n                out.push(buf[0]);\n            }\n            _ => return Vec::new(),\n        }\n        let len = out.len();\n        if len > 1 && out[len - 2] == b'\\r' && out[len - 1] == \n         b'\\n' {\n            out.pop();\n            out.pop();\n            return out;\n        }\n    }\n}\n```", "```rs\n#[allow(dead_code)]\nstruct Client {\n    cwd: PathBuf,\n    stream: TcpStream,\n    name: Option<String>,\n}\n```", "```rs\nfn handle_client(mut stream: TcpStream) {\n    println!(\"new client connected!\");\n    send_cmd(&mut stream, ResultCode::ServiceReadyForNewUser, \"Welcome to this FTP \n    server!\");\n    let client = Client::new(stream);\n    loop {\n        let data = read_all_message(&mut client.stream);\n        if data.is_empty() {\n            println!(\"client disconnected...\");\n            break;\n        }\n        client.handle_cmd(command::new(data));\n    }\n}\n```", "```rs\nimpl Client {\n    fn new(stream: TcpStream) -> Client {\n        Client {\n            cwd: PathBuf::from(\"/\"),\n            stream: stream,\n            name: None,\n        }\n    }\n}\n```", "```rs\nfn handle_cmd(&mut self, cmd: Command) {\n    println!(\"====> {:?}\", cmd);\n    match cmd {\n        Command::Auth => send_cmd(&mut self.stream, \n        ResultCode::CommandNotImplemented,\n                                  \"Not implemented\"),\n        Command::Unknown(s) => send_cmd(&mut self.stream, \n         ResultCode::UnknownCommand,\n                                        \"Not implemented\"),\n    }\n}\n```", "```rs\nenum Command {\n    Auth,\n    Syst,\n    Unknown(String),\n}\n```", "```rs\nimpl AsRef<str> for Command {\n    fn as_ref(&self) -> &str {\n        match *self {\n            Command::Auth => \"AUTH\",\n            Command::Syst => \"SYST\",\n            Command::Unknown(_) => \"UNKN\",\n        }\n    }\n}\n```", "```rs\nimpl Command {\n    pub fn new(input: Vec<u8>) -> io::Result<Self> {\n        let mut iter = input.split(|&byte| byte == b' ');\n        let mut command = iter.next().expect(\"command in \n         input\").to_vec();\n        to_uppercase(&mut command);\n        let data = iter.next();\n        let command =\n            match command.as_slice() {\n                b\"AUTH\" => Command::Auth,\n                b\"SYST\" => Command::Syst,\n                s => \n                Command::Unknown(str::from_utf8(s).unwrap_or(\"\").to_owned()),\n            };\n        Ok(command)\n    }\n}\n```", "```rs\nfn handle_cmd(&mut self, cmd: Command) {\n    println!(\"====> {:?}\", cmd);\n    match cmd {\n        Command::Auth => send_cmd(&mut self.stream, \n        ResultCode::CommandNotImplemented,\n                                  \"Not implemented\"),\n        Command::Syst => send_cmd(&mut self.stream, ResultCode::Ok, \"I won't tell\"),\n        Command::Unknown(s) => send_cmd(&mut self.stream, \n        ResultCode::UnknownCommand,\n                                        \"Not implemented\"),\n    }\n}\n```", "```rs\nenum Command {\n    Auth,\n    Syst,\n    User(String),\n    Unknown(String),\n}\n```", "```rs\nimpl AsRef<str> for Command {\n    fn as_ref(&self) -> &str {\n        match *self {\n            Command::Auth => \"AUTH\",\n            Command::Syst => \"SYST\",\n            Command::User => \"USER\",\n            Command::Unknown(_) => \"UNKN\",\n        }\n    }\n}\n```", "```rs\nimpl Command {\n    pub fn new(input: Vec<u8>) -> io::Result<Self> {\n        let mut iter = input.split(|&byte| byte == b' ');\n        let mut command = iter.next().expect(\"command in input\").to_vec();\n        to_uppercase(&mut command);\n        let data = iter.next();\n        let command =\n            match command.as_slice() {\n                b\"AUTH\" => Command::Auth,\n                b\"SYST\" => Command::Syst,\n                b\"USER\" => Command::User(data.map(|bytes| \n                String::from_utf8(bytes.to_vec()).expect(\"cannot\n                 convert bytes to String\")).unwrap_or_default()),\n                s => Command::Unknown(str::from_utf8(s).unwrap_or(\"\").to_owned()),\n            };\n        Ok(command)\n    }\n}\n```", "```rs\nfn handle_cmd(&mut self, cmd: Command) {\n    println!(\"====> {:?}\", cmd);\n    match cmd {\n        Command::Auth => send_cmd(&mut self.stream, \n         ResultCode::CommandNotImplemented,\n                                  \"Not implemented\"),\n        Command::Syst => send_cmd(&mut self.stream, ResultCode::Ok, \n        \"I won't tell\"),\n        Command::User(username) => {\n            if username.is_empty() {\n                send_cmd(&mut self.stream, ResultCode::InvalidParameterOrArgument,\n                         \"Invalid username\")\n            } else {\n                self.name = username.to_owned();\n                send_cmd(&mut self.stream, ResultCode::UserLoggedIn,\n                         &format!(\"Welcome {}!\", username)),\n            }\n        }\n        Command::Unknown(s) => send_cmd(&mut self.stream,  \n        ResultCode::UnknownCommand,\n                                        \"Not implemented\"),\n    }\n}\n```", "```rs\nCommand::NoOp => send_cmd(&mut self.stream, ResultCode::Ok, \"Doing nothing...\"),\n```", "```rs\nCommand::Pwd => {\n    let msg = format!(\"{}\", self.cwd.to_str().unwrap_or(\"\"));\n    if !msg.is_empty() {\n        let message = format!(\"\\\"/{}\\\" \", msg);\n        send_cmd(&mut self.stream, ResultCode::PATHNAMECreated,\n         &format!(\"\\\"/{}\\\" \", \n         msg))\n    } else {\n        send_cmd(&mut self.stream, ResultCode::FileNotFound, \"No \n         such file or directory\")\n    }\n}\n```", "```rs\nCommand::Type => send_cmd(&mut self.stream, ResultCode::Ok, \"Transfer type changed successfully\"),\n```", "```rs\nstruct Client {\n    cwd: PathBuf,\n    stream: TcpStream,\n    name: Option<String>,\n    data_writer: Option<TcpStream>,\n}\n```", "```rs\nfn new(stream: TcpStream) -> Client {\n    Client {\n        cwd: PathBuf::from(\"/\"),\n        stream: stream,\n        name: None,\n        data_writer: None,\n    }\n}\n```", "```rs\n// Adding some new imports:\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\n\nCommand::Pasv => {\n    if self.data_writer.is_some() {\n        send_cmd(&mut self.stream, ResultCode::DataConnectionAlreadyOpen, \"Already \n        listening...\")\n    } else {\n        let port = 43210;\n        send_cmd(&mut self.stream, ResultCode::EnteringPassiveMode,\n           &format!(\"127,0,0,1,{},{}\", port >> 8, port & 0xFF));\n        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0,\n         0, 1)), port);\n        let listener = TcpListener::bind(&addr).unwrap();\n        match listener.incoming().next() {\n            Some(Ok(client)) => {\n                self.data_writer = Some(client);\n            }\n            _ => {\n                send_cmd(&mut self.stream, ResultCode::ServiceNotAvailable, \"issues  \n                happen...\");\n            }\n        }\n    }\n}\n```", "```rs\nif self.data_writer.is_some() {\n    send_cmd(&mut self.stream, ResultCode::DataConnectionAlreadyOpen, \"Already listening...\")\n}\n```", "```rs\nlet port: u16 = 43210;\nsend_cmd(&mut self.stream, ResultCode::EnteringPassiveMode,\n         &format!(\"127,0,0,1,{},{}\", port >> 8, port & 0xFF));\n```", "```rs\nip1,ip2,ip3,ip4,port1,port2\n```", "```rs\n1010 1010 1111 1111\n```", "```rs\n0000 0000 1010 1010\n```", "```rs\n1 & 1 == 1\n1 & 0 == 0\n```", "```rs\n0000 0000 1111 1111 == 0xFF\n```", "```rs\n1111 1111 1010 1010 & 0xFF\n=>\n0000 0000 1010 1010\n```", "```rs\nlet addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);\nlet listener = TcpListener::bind(&addr).unwrap();\nmatch listener.incoming().next() {\n    Some(Ok(client)) => {\n        self.data_writer = Some(client);\n    }\n    _ => {\n        send_cmd(&mut self.stream, ResultCode::ServiceNotAvailable, \"issues \n        happen...\");\n    }\n}\n```", "```rs\nCommand::List => {\n    if let Some(ref mut data_writer) = self.data_writer {\n        let mut tmp = PathBuf::from(\".\");\n        send_cmd(&mut self.stream, ResultCode::DataConnectionAlreadyOpen,\n                 \"Starting to list directory...\");\n        let mut out = String::new();\n        for entry in read_dir(tmp).unwrap() {\n            for entry in dir {\n                if let Ok(entry) = entry {\n                    add_file_info(entry.path(), &mut out);\n                }\n            }\n            send_data(data_writer, &out)\n        }\n    } else {\n        send_cmd(&mut self.stream, ResultCode::ConnectionClosed, \n         \"No opened data connection\");\n    }\n    if self.data_writer.is_some() {\n        self.data_writer = None;\n        send_cmd(&mut self.stream, ResultCode::ClosingDataConnection, \"Transfer \n        done\");\n    }\n}\n```", "```rs\nfn send_data(stream: &mut TcpStream, s: &str) {\n    write!(stream, \"{}\", s).unwrap();\n}\n```", "```rs\nfn add_file_info(path: PathBuf, out: &mut String) {\n    let extra = if path.is_dir() { \"/\" } else { \"\" };\n    let is_dir = if path.is_dir() { \"d\" } else { \"-\" };\n\n    let meta = match ::std::fs::metadata(&path) {\n        Ok(meta) => meta,\n        _ => return,\n    };\n    let (time, file_size) = get_file_info(&meta);\n    let path = match path.to_str() {\n        Some(path) => match path.split(\"/\").last() {\n            Some(path) => path,\n            _ => return,\n        },\n        _ => return,\n    };\n    let rights = if meta.permissions().readonly() {\n        \"r--r--r--\"\n    } else {\n        \"rw-rw-rw-\"\n    };\n    let file_str = format!(\"{is_dir}{rights} {links} {owner} {group} {size} {month} \n    {day} {hour}:{min} {path}{extra}\\r\\n\",\n                           is_dir=is_dir,\n                           rights=rights,\n                           links=1, // number of links\n                           owner=\"anonymous\", // owner name\n                           group=\"anonymous\", // group name\n                           size=file_size,\n                           month=MONTHS[time.tm_mon as usize],\n                           day=time.tm_mday,\n                           hour=time.tm_hour,\n                           min=time.tm_min,\n                           path=path,\n                           extra=extra);\n    out.push_str(&file_str);\n    println!(\"==> {:?}\", &file_str);\n}\n```", "```rs\n#[macro_use]\nextern crate cfg_if;\n\ncfg_if! {\n    if #[cfg(windows)] {\n        fn get_file_info(meta: &Metadata) -> (time::Tm, u64) {\n            use std::os::windows::prelude::*;\n            (time::at(time::Timespec::new(meta.last_write_time())), \n             meta.file_size())\n        }\n    } else {\n        fn get_file_info(meta: &Metadata) -> (time::Tm, u64) {\n            use std::os::unix::prelude::*;\n            (time::at(time::Timespec::new(meta.mtime(), 0)),\n             meta.size())\n        }\n    }\n}\n```", "```rs\ncfg-if = \"0.1.2\"\n```", "```rs\ndr--r--r-- 1 me me 1024 Jan 7 12:42 foo/\n-rw-rw-rw- 1 me me 4 Mar 3 23:42 some_file\n```", "```rs\n[rwx][rwx][rwx]\n```", "```rs\nlet path = Path::new(\"/foo/test/../bar.rs\");\nassert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/bar.rs\"));\n```", "```rs\nCwd(PathBuf),\n```", "```rs\nb\"CWD\" => Command::Cwd(data.map(|bytes| Path::new(str::from_utf8(bytes).unwrap()).to_path_buf()).unwrap()),\n```", "```rs\nCommand::Cwd(directory) => self.cwd(directory),\n```", "```rs\nfn complete_path(&self, path: PathBuf, server_root: &PathBuf) -> Result<PathBuf, io::Error> {\n    let directory = server_root.join(if path.has_root() {\n        path.iter().skip(1).collect()\n    } else {\n        path\n    });\n    let dir = directory.canonicalize();\n    if let Ok(ref dir) = dir {\n        if !dir.starts_with(&server_root) {\n            return Err(io::ErrorKind::PermissionDenied.into());\n        }\n    }\n    dir\n}\n\nfn cwd(mut self, directory: PathBuf) {\n    let server_root = env::current_dir().unwrap();\n    let path = self.cwd.join(&directory);\n    if let Ok(dir) = self.complete_path(path, &server_root) {\n        if let Ok(prefix) = dir.strip_prefix(&server_root)\n                               .map(|p| p.to_path_buf()) {\n            self.cwd = prefix.to_path_buf();\n            send_cmd(&mut self.stream, ResultCode::Ok,\n                     &format!(\"Directory changed to \\\"{}\\\"\", directory.display()));\n            return\n        }\n    }\n    send_cmd(&mut self.stream, ResultCode::FileNotFound, \"No such file or directory\");\n}\n```", "```rs\nlet server_root = env::current_dir().unwrap();\n```", "```rs\nlet path = self.cwd.join(&directory);\n```", "```rs\nif let Ok(dir) = self.complete_path(path, &server_root) {\n```", "```rs\nlet directory = server_root.join(if path.has_root() {\n    path.iter().skip(1).collect()\n} else {\n    path\n});\n```", "```rs\nlet dir = directory.canonicalize();\n```", "```rs\nif let Ok(ref dir) = dir {\n    if !dir.starts_with(&server_root) {\n        return Err(io::ErrorKind::PermissionDenied.into());\n    }\n}\n```", "```rs\nif let Ok(dir) = self.complete_path(path, &server_root) {\n    if let Ok(prefix) = dir.strip_prefix(&server_root)\n                           .map(|p| p.to_path_buf()) {\n        // ...\n    }\n}\n```", "```rs\nself.cwd = prefix.to_path_buf();\nsend_cmd(&mut self.stream, ResultCode::Ok,\n         &format!(\"Directory changed to \\\"{}\\\"\", directory.display()));\nreturn\n```", "```rs\nsend_cmd(&mut self.stream, ResultCode::FileNotFound, \"No such file or directory\");\n```", "```rs\nCommand::CdUp => {\n    if let Some(path) = self.cwd.parent().map(Path::to_path_buf) {\n        self.cwd = path;\n    }\n    send_cmd(&mut self.stream, ResultCode::Ok, \"Done\");\n}\n```", "```rs\nCommand::List => {\n    if let Some(ref mut data_writer) = self.data_writer {\n        let mut tmp = PathBuf::from(\".\");\n        send_cmd(&mut self.stream, ResultCode::DataConnectionAlreadyOpen,\n                 \"Starting to list directory...\");\n        let mut out = String::new();\n        for entry in read_dir(tmp).unwrap() {\n            for entry in dir {\n                if let Ok(entry) = entry {\n                    add_file_info(entry.path(), &mut out);\n                }\n            }\n            send_data(data_writer, &out)\n        }\n    } else {\n        send_cmd(&mut self.stream, ResultCode::ConnectionClosed, \"No opened data  \n         connection\");\n    }\n    if self.data_writer.is_some() {\n        self.data_writer = None;\n        send_cmd(&mut self.stream, ResultCode::ClosingDataConnection, \"Transfer \n         done\");\n    }\n}\n```", "```rs\nCommand::List(path) => {\n    if let Some(ref mut data_writer) = self.data_writer {\n        let server_root = env::current_dir().unwrap();\n        let path = self.cwd.join(path.unwrap_or_default());\n        let directory = PathBuf::from(&path);\n        if let Ok(path) = self.complete_path(directory, \n         &server_root) {\n            send_cmd(&mut self.stream, \n             ResultCode::DataConnectionAlreadyOpen,\n             \"Starting to list directory...\");\n            let mut out = String::new();\n            for entry in read_dir(path).unwrap() {\n                for entry in dir {\n                    if let Ok(entry) = entry {\n                        add_file_info(entry.path(), &mut out);\n                    }\n                }\n                send_data(data_writer, &out)\n            }\n        } else {\n            send_cmd(&mut self.stream, ResultCode::InvalidParameterOrArgument,\n                     \"No such file or directory...\");\n        }\n    } else {\n        send_cmd(&mut self.stream, ResultCode::ConnectionClosed, \n        \"No opened data connection\");\n    }\n    if self.data_writer.is_some() {\n        self.data_writer = None;\n        send_cmd(&mut self.stream,\n         ResultCode::ClosingDataConnection, \"Transfer done\");\n    }\n}\n```", "```rs\nlet path = self.cwd.join(path.unwrap_or_default());\nlet directory = PathBuf::from(&path);\nif let Ok(path) = self.complete_path(directory, &server_root) {\n    // ...\n} else {\n    send_cmd(&mut self.stream, ResultCode::InvalidParameterOrArgument,\n             \"No such file or directory...\");\n}\n```", "```rs\nfor entry in read_dir(path).unwrap() {\n    for entry in dir {\n        if let Ok(entry) = entry {\n            add_file_info(entry.path(), &mut out);\n        }\n    }\n    send_data(data_writer, &out)\n}\n```", "```rs\nif path.is_dir() {\n    for entry in read_dir(path).unwrap() {\n        for entry in dir {\n            if let Ok(entry) = entry {\n                add_file_info(entry.path(), &mut out);\n            }\n        }\n        send_data(data_writer, &out)\n    }\n} else {\n    add_file_info(path, &mut out);\n}\n```", "```rs\nCommand::Mkd(path) => self.mkd(path),\n```", "```rs\nuse std::fs::create_dir;\n\nfn mkd(&self, path: PathBuf) {\n    let server_root = env::current_dir().unwrap();\n    let path = self.cwd.join(&path);\n    if let Some(parent) = path.parent().map(|p| p.to_path_buf()) {\n        if let Ok(mut dir) = self.complete_path(parent,\n         &server_root) {\n            if dir.is_dir() {\n                if let Some(filename) = path.file_name().map(|p| \n                 p.to_os_string()) {\n                    dir.push(filename);\n                    if create_dir(dir).is_ok() {\n                        send_cmd(&mut self.stream,\n                         ResultCode::PATHNAMECreated,\n                          \"Folder successfully created!\");\n                        return\n                    }\n                }\n            }\n        }\n    }\n    send_cmd(&mut self.stream, ResultCode::FileNotFound,\n             \"Couldn't create folder\");\n}\n```", "```rs\nCommand::Rmd(path) => self.rmd(path),\n```", "```rs\nuse std::fs::remove_dir_all;\n\nfn rmd(&self, path: PathBuf) {\n    let server_root = env::current_dir().unwrap();\n    if let Ok(path) = self.complete_path(path, &server_root) {\n        if remove_dir_all(path).is_ok() {\n            send_cmd(&mut self.stream, \n                     ResultCode::RequestedFileActionOkay,\n                     \"Folder successfully removed!\");\n            return\n        }\n    }\n    send_cmd(&mut self.stream, ResultCode::FileNotFound, \n      \"Couldn't remove folder!\");\n}\n```"]