<html><head></head><body>
		<div><h1 id="_idParaDest-91" class="chapter-number"><a id="_idTextAnchor091"/>5</h1>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor092"/>Displaying Content in the Browser </h1>
			<p>We are now at the stage where we can build a web application that can manage a range of HTTP requests with different methods and data. This is useful, especially if we are building a server for microservices. However, we also want non-programmers to interact with our application to use it. To enable non-programmers to use our application, we must create a graphical user interface. However, it must be noted that this chapter does not contain much Rust. This is because other languages exist to render a graphical user interface. We will mainly use HTML, JavaScript, and CSS. These tools are mature and widely used for frontend web development. While I personally love Rust (otherwise I wouldn’t be writing a book on it), we must use the right tool for the right job. At the time of writing this book, we can build a frontend application in Rust using the Yew framework. However, being able to fuse more mature tools into our Rust technical stack is a more valuable skill. </p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Serving HTML, CSS, and JavaScript using Rust </li>
				<li>Building a React application that connects to a Rust server</li>
				<li>Converting our React application into a desktop application to be installed on the computer</li>
			</ul>
			<p>In the previous edition (<em class="italic">Rust Web Programming: A hands-on guide to developing fast and secure web apps with the Rust programming language</em>), we merely served frontend assets directly from Rust. However, due to feedback and revision, this does not scale well, leading to a lot of repetition. Raw HTML, CSS, and JavaScript served directly by Rust were also prone to errors due to the unstructured nature of using this approach, which is why, in this second edition, we will cover React as well as provide a brief introduction to serving frontend assets directly with Rust. By the end of this chapter, you will be able to write basic frontend graphical interfaces without any dependencies, as well as understand the trade-offs between low-dependency frontend solutions and full frontend frameworks such as React. Not only will you understand when to use them but you will also be able to implement both approaches as and when they are needed for your project. As a result, you will be able to pick the right tool for the right job and build an end-to-end product using Rust in the backend and JavaScript in the frontend.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor093"/>Technical requirements</h1>
			<p>We will be building on the server code we created in the previous chapter, which can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app</a>. </p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05">https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05</a>.</p>
			<p>We will also be using Node.js to run our React application. Node and npm can be installed by carrying out the steps laid out at <a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">https://docs.npmjs.com/downloading-and-installing-node-js-and-npm</a>.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Serving HTML, CSS, and JavaScript using Rust </h1>
			<p>In the previous chapter, we returned<a id="_idIndexMarker426"/> all our data in the form<a id="_idIndexMarker427"/> of JSON. In this section, we are going<a id="_idIndexMarker428"/> to return HTML data<a id="_idIndexMarker429"/> for the user<a id="_idIndexMarker430"/> to see. In this HTML<a id="_idIndexMarker431"/> data, we will have buttons and forms that enable the user to interact with the API endpoints that we defined in the previous chapter to create, edit, and delete to-do items. To do this, we will need to structure our own <code>app</code> views module that takes the following structure:</p>
			<pre class="source-code">
views
├── app
│   ├── items.rs
│   └── mod.rs</pre>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Serving basic HTML</h2>
			<p>In our <code>items.rs</code> file, we will be defining<a id="_idIndexMarker432"/> the main view that displays the to-do items. However, before we do that, we should explore the simplest way in which we can return HTML in the <code>items.rs</code> file:</p>
			<pre class="source-code">
use actix_web::HttpResponse;
pub async fn items() -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body("&lt;h1&gt;Items&lt;/h1&gt;")
}</pre>
			<p>Here, we simply return an <code>HttpResponse</code> struct that has an HTML<a id="_idIndexMarker433"/> content type and a body of <code>&lt;h1&gt;Items&lt;/h1&gt;</code>. To pass <code>HttpResponse</code> into the app, we must define our factory in the <code>app/views/mod.rs</code> file, as follows:</p>
			<pre class="source-code">
use actix_web::web;
mod items;
pub fn app_views_factory(app: &amp;mut web::ServiceConfig) {
    app.route("/", web::get().to(items::items));
}</pre>
			<p>Here, we can see that instead of building a service, we merely defined a <code>route</code> for our application. This is because this is the landing page. If we were going to define a <code>service</code> instead of a <code>route</code>, we would not be able to define the views for the service without a prefix. </p>
			<p>Once we have defined <code>app_views_factory</code>, we can call it in our <code>views/mod.rs</code> file. However, first, we must define the app module at the top of the <code>views/mod.rs</code> file:</p>
			<pre class="source-code">
mod app;</pre>
			<p>Once we have defined the <code>app</code> module, we can call the app factory in the <code>views_factory</code> function within the same file:</p>
			<pre class="source-code">
app::app_views_factory(app);</pre>
			<p>Now that our HTML serving view is a part of our app, we can run it and call the home URL in our browser, giving us the following output:</p>
			<div><div><img src="img/Figure_5.1_B18722.jpg" alt="Figure 5.1 – First rendered HTML view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – First rendered HTML view</p>
			<p>We can see that our HTML rendered! With what we saw in <em class="italic">Figure 5</em><em class="italic">.1</em>, we can deduce that we can return a string at the body of the response with the following:</p>
			<pre class="source-code">
HttpResponse::Ok()
    .content_type("text/html; charset=utf-8")
    .body("&lt;h1&gt;Items&lt;/h1&gt;")</pre>
			<p>This renders the HTML<a id="_idIndexMarker434"/> if the string is in HTML format. From this revelation, how do you think we can render HTML from HTML files that are served by our Rust server? Before moving on, think about this – this will exercise your problem-solving abilities. </p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Reading basic HTML from files</h2>
			<p>If we have an<a id="_idIndexMarker435"/> HTML file, we can render it by merely readying that HTML file to a string and inserting that string into the body of <code>HttpResponse</code>. Yes, it is that simple. To achieve this, we will build a content loader. </p>
			<p>To build a basic content loader, start by building an HTML file reading function in the <code>views/app/content_loader.rs</code> file:</p>
			<pre class="source-code">
use std::fs;
pub fn read_file(file_path: &amp;str) -&gt; String {
    let data: String = fs::read_to_string(
        file_path).expect("Unable to read file");
    return data
}</pre>
			<p>All we must do here is return a string because this is all we need for the response body. Then, we must define the loader in the <code>views/app/mod.rs</code> file with the <code>mod content_loader;</code> line at the top of the file. </p>
			<p>Now that we have a loading<a id="_idIndexMarker436"/> function, we need an HTML directory. This can be defined alongside the <code>src</code> directory called <code>templates</code>. Inside the <code>templates</code> directory, we can add an HTML file called <code>templates/main.html</code> with the following content:</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charSet="UTF-8"/&gt;
        &lt;meta name="viewport"
              content="width=device-width, initial-
                                           scale=1.0"/&gt;
        &lt;meta httpEquiv="X-UA-Compatible"
              content="ie=edge"/&gt;
        &lt;meta name="description"
              content="This is a simple to do app"/&gt;
        &lt;title&gt;To Do App&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;To Do Items&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>Here, we can see that our <code>body</code> tag has the same content that we presented previously – that is, <code>&lt;h1&gt;To Do Items&lt;/h1&gt;</code>. Then, we have a <code>head</code> tag that defines a range of meta tags. We can see that we define <code>viewport</code>. This tells the browser how to handle the dimensions and scaling of the page content. Scaling is important because our application could be accessed by a range of different devices and screen sizes. With this viewport, we can set the width of the page to the same width as the device screen. Then, we can set the initial scale of the page that we access to <code>1.0</code>. Moving on to the <code>httpEquiv</code> tag, we set it to <code>X-UA-Compatible</code>, which means that we support older browsers. The final tag is simply a description<a id="_idIndexMarker437"/> of the page that can be used by search engines. Our <code>title</code> tag ensures that <code>to do app</code> is displayed on the browser tag. With that, we have our standard header title in our body.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Serving basic HTML loaded from files</h2>
			<p>Now that we have defined<a id="_idIndexMarker438"/> our HTML file, we must load and serve it. Going back to our <code>src/views/app/items.rs</code> file, we must load the HTML file and serve it with the following code:</p>
			<pre class="source-code">
use actix_web::HttpResponse;
use super::content_loader::read_file;
pub async fn items() -&gt; HttpResponse {
    let html_data = read_file(
        "./templates/main.html");
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(html_data)
}</pre>
			<p>If we run our application, we will get the following output: </p>
			<div><div><img src="img/Figure_5.2_B18722.jpg" alt="Figure 5.2 – View from loading the HTML page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – View from loading the HTML page</p>
			<p>In <em class="italic">Figure 5</em><em class="italic">.2</em>, we can see that we have the same output as before. This is not surprising; however, we must notice that the tab in <em class="italic">Figure 5</em><em class="italic">.2</em> now states <strong class="bold">To Do App</strong>, which means that the metadata in our HTML file is being loaded into the view. Nothing is stopping us from fully utilizing the HTML<a id="_idIndexMarker439"/> file. Now that our HTML file is being served, we can move on to our next ambition, which is adding functionality to our page. </p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>Adding JavaScript to an HTML file</h2>
			<p>It would not be useful<a id="_idIndexMarker440"/> to the frontend<a id="_idIndexMarker441"/> user if they couldn’t do anything to our state for to-do items. Before we amend this, we need to understand the layout of an HTML file by looking at the following figure:</p>
			<div><div><img src="img/Figure_5.3_B18722.jpg" alt="Figure 5.3 – General layout of an HTML file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – General layout of an HTML file</p>
			<p>Here, in <em class="italic">Figure 5</em><em class="italic">.3</em>, we can see that we can define the meta tags in the header. However, we can also see<a id="_idIndexMarker442"/> that we can define style<a id="_idIndexMarker443"/> tags in the header. Within the style tags below the header, we can insert CSS into the style. Below the body, there is also a script section where we can inject JavaScript. This JavaScript runs in the browser and interacts with elements in the body. With this, we can see that serving an HTML file loaded with CSS and JavaScript provides a fully functioning frontend single-page app. With this, we can reflect on the introduction of this chapter. While I love Rust and feel a strong urge to tell you to write everything in it, this is just not a good idea for any language in software engineering. The ease with which we can serve functional frontend views with JavaScript now makes it the best choice for your frontend needs. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Communicating with our server using JavaScript </h2>
			<p>Now that we know<a id="_idIndexMarker444"/> where to insert<a id="_idIndexMarker445"/> the JavaScript into our HTML file, we can test our bearings. In the remainder of this section, we are going to create a button in the HTML body, fuse it to a JavaScript function, and then get the browser to print out an alert with an inputted message when that button is pressed. This will do nothing to our backend application, but it will prove that our understanding of HTML files is correct. We can add the following code to our <code>templates/main.html</code> file:</p>
			<pre class="source-code">
&lt;body&gt;
    &lt;h1&gt;To Do Items&lt;/h1&gt;
    &lt;input type="text" id="name" placeholder="create to do 
         item"&gt;
    &lt;button id="create-button" value="Send"&gt;Create&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    let createButton = document.getElementById("create-
        button");
    createButton.addEventListener("click", postAlert);
    function postAlert() {
        let titleInput = document.getElementById("name");
        alert(titleInput.value);
        titleInput.value = null;
    }
&lt;/script&gt;</pre>
			<p>In our body section, we can see that we define an <code>input</code> and a <code>button</code>. We give the <code>input</code> and <code>button</code> properties unique ID names. Then, we use the ID of <code>button</code> to add an event listener. After that, we bind our <code>postAlert</code> function to that event listener to be fired when our <code>button</code> is clicked. When we fire our <code>postAlert</code> function, we get <code>input</code> by using<a id="_idIndexMarker446"/> its ID and print<a id="_idIndexMarker447"/> out the value of <code>input</code> in an alert. Then, we set the value of <code>input</code> to <code>null</code> to enable the user to fill in another value to be processed. Serving our new <code>main.html</code> file, putting <code>testing</code> in <code>input</code> and then clicking the button will result in the following output:</p>
			<div><div><img src="img/Figure_5.4_B18722.jpg" alt="Figure 5.4 – The effect of clicking a button when connected to an alert in JavaScript"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The effect of clicking a button when connected to an alert in JavaScript</p>
			<p>Our JavaScript does not have to stop with having elements interact in the body. We can also use JavaScript to perform API calls to our backend Rust application. However, we must stop and think before we rush off and write our entire application in our <code>main.html</code> file. If we did that, the <code>main.html</code> file would balloon into a massive file. It would be hard to debug. Also, this could lead to code duplication. What if we wanted to use the same JavaScript in other views? We would have to copy and paste it into another HTML file. This would not scale well and if we need to update a function, we could run the risk of forgetting to update some of the duplicated functions. This is where JavaScript frameworks such as React come in handy. We will explore React later in this chapter, but for now, we will complete our low-dependency frontend by coming up with a way in which we can separate our JavaScript from our HTML files. </p>
			<p>It must be warned that we are essentially manually rewriting HTML on the fly with this JavaScript. People could describe this as a “hacky” solution. However, it is important to get to grips with our approach before exploring React to truly appreciate the benefits of different approaches. Before we move on to the next section, we do have to refactor our <code>create</code> view in the <code>src/views/to_do/create.rs</code> file. This is a good opportunity to revisit what we developed in the previous chapters. You must essentially convert the <code>create</code> view so that it returns our current state of the to-do items as opposed to a string. Once<a id="_idIndexMarker448"/> you have attempted this, the solution<a id="_idIndexMarker449"/> should look as follows:</p>
			<pre class="source-code">
use actix_web::HttpResponse;
use serde_json::Value;
use serde_json::Map;
use actix_web::HttpRequest;
use crate::to_do::{to_do_factory, enums::TaskStatus};
use crate::json_serialization::to_do_items::ToDoItems;
use crate::state::read_file;
use crate::processes::process_input;
pub async fn create(req: HttpRequest) -&gt; HttpResponse {
    let state: Map&lt;String, Value&gt; = 
        read_file("./state.json");
    let title: String = req.match_info().get("title"
    ).unwrap().to_string();
    let item = to_do_factory(&amp;title.as_str(), 
        TaskStatus::PENDING);
    process_input(item, "create".to_string(), &amp;state);
    return HttpResponse::Ok().json(ToDoItems::get_state())
}</pre>
			<p>Now, all our to-do items are up to date and functioning. We can now move on to the next section, where we will be getting our frontend to make cal<a id="_idTextAnchor100"/>ls to our backend. </p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor101"/>Injecting JavaScript into HTML</h1>
			<p>Once we have finished this section, we will have<a id="_idIndexMarker450"/> a not-so-pretty but fully functional<a id="_idIndexMarker451"/> main view where we can add, edit, and delete to-do items using JavaScript to make calls to our Rust server. However, as you may recall, we did not add a <code>delete</code> API endpoint. To inject JavaScript into our HTML, we will have to carry out the following steps:</p>
			<ol>
				<li>Create a <code>delete</code> item API endpoint.</li>
				<li>Add a <code>JavaScript loading</code> function and replace the JavaScript tag in the HTML data with the loaded JavaScript data in the main item Rust view.</li>
				<li>Add a JavaScript tag in the HTML file and IDs to the HTML components so that we can reference the components in our JavaScript. </li>
				<li>Build a <code>rendering</code> function for our to-do items in JavaScript and bind it to our HTML via IDs.</li>
				<li>Build an <code>API call</code> function in JavaScript to talk to the backend.</li>
				<li>Build the <code>get</code>, <code>delete</code>, <code>edit</code>, and <code>create</code> functions in JavaScript for our buttons to use.</li>
			</ol>
			<p>Let’s have a detailed look at this.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor102"/>Adding the delete endpoint</h2>
			<p>Adding the <code>delete</code> API endpoint should<a id="_idIndexMarker452"/> be straightforward now. If you want to, it is advised to try and implement this view by yourself as you should be comfortable with this process by now:</p>
			<ol>
				<li value="1">If you are struggling, we can achieve this by importing the following third-party dependencies into the <code>views/to_do/delete.rs</code> file:<pre class="source-code">
use actix_web::{web, HttpResponse};</pre><pre class="source-code">
use serde_json::value::Value;</pre><pre class="source-code">
use serde_json::Map;</pre></li>
			</ol>
			<p>These are not new, and you should<a id="_idIndexMarker453"/> be familiar with them and know where we need to utilize them. </p>
			<ol>
				<li value="2">Then, we must import our structs and functions with the following code:<pre class="source-code">
use crate::to_do::{to_do_factory, enums::TaskStatus};</pre><pre class="source-code">
use crate::json_serialization::{to_do_item::ToDoItem, </pre><pre class="source-code">
    to_do_items::ToDoItems};</pre><pre class="source-code">
use crate::processes::process_input;</pre><pre class="source-code">
use crate::jwt::JwToken;</pre><pre class="source-code">
use crate::state::read_file;</pre></li>
			</ol>
			<p>Here, we can see that we are using our <code>to_do</code> module to construct our to-do items. With our <code>json_serialization</code> module, we can see that we are accepting <code>ToDoItem</code> and returning <code>ToDoItems</code>. Then, we execute the deletion of our item with the <code>process_input</code> function. We also do not want anyone who can visit our page to be deleting our items. Therefore, we need our <code>JwToken</code> struct. Finally, we read the state of our items with the <code>read_file</code> function. </p>
			<ol>
				<li value="3">Now that we have all that we need, we can define our <code>delete</code> view with the following code:<pre class="source-code">
pub async fn delete(to_do_item: web::Json&lt;ToDoItem&gt;, </pre><pre class="source-code">
    token: JwToken) -&gt; HttpResponse {</pre><pre class="source-code">
    . . .</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Here, we can see that we have accepted <code>ToDoItem</code> as JSON and that we have attached <code>JwToken</code> for the view so that the user must be authorized to access it. At this point, we only have <code>JwToken</code> attaching a message; we will manage the authentication logic for <code>JwToken</code> in <a href="B18722_07.xhtml#_idTextAnchor149"><em class="italic">Chapter 7</em></a>, <em class="italic">Managing User Sessions</em>. </p>
			<ol>
				<li value="4">Inside our <code>delete</code> view, we can get<a id="_idIndexMarker454"/> the state of our to-do items by reading our JSON file with the following code:<pre class="source-code">
let state: Map&lt;String, Value&gt; = read_file("./state.json");</pre></li>
				<li>Then, we can check if the item with this title is in the state. If it is not, then we return a not found HTTP response. If it is, we then pass on the status as we need the title and status to construct the item. We can achieve this checking and status extraction with the following code:<pre class="source-code">
let status: TaskStatus;</pre><pre class="source-code">
match &amp;state.get(&amp;to_do_item.title) {</pre><pre class="source-code">
    Some(result) =&gt; {</pre><pre class="source-code">
        status = TaskStatus::from_string</pre><pre class="source-code">
                 (result.as_str().unwrap().to_string()                 );</pre><pre class="source-code">
    }</pre><pre class="source-code">
    None=&gt; {</pre><pre class="source-code">
        return HttpResponse::NotFound().json(</pre><pre class="source-code">
            format!("{} not in state", </pre><pre class="source-code">
                     &amp;to_do_item.title))</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
				<li>Now that we have the status and title of the to-do item, we can construct our item and pass it through our <code>process_input</code> function with a <code>delete</code> command. This will delete<a id="_idIndexMarker455"/> our item from the JSON file:<pre class="source-code">
let existing_item = to_do_factory(to_do_item.title.as_    str(),</pre><pre class="source-code">
    status.clone());</pre><pre class="source-code">
process_input(existing_item, "delete".    to_owned(), </pre><pre class="source-code">
    &amp;state);</pre></li>
				<li>Remember, we implemented the <code>Responder</code> trait for our <code>ToDoItems</code> struct, and our <code>ToDoItems::get_state()</code> function returns a <code>ToDoItems</code> struct populated with items from the JSON file. Therefore, we can have the following return statement from our <code>delete</code> view:<pre class="source-code">
return HttpResponse::Ok().json(ToDoItems::get_state())</pre></li>
				<li>Now that our <code>delete</code> view has been defined, we can add it to our <code>src/views/to_do/mod.rs</code> file, resulting in our view factory that looks like this:<pre class="source-code">
mod create;</pre><pre class="source-code">
mod get;</pre><pre class="source-code">
mod edit;</pre><pre class="source-code">
mod delete;</pre><pre class="source-code">
use actix_web::web::{ServiceConfig, post, get, scope};</pre><pre class="source-code">
pub fn to_do_views_factory(app: &amp;mut ServiceConfig) {</pre><pre class="source-code">
    app.service(</pre><pre class="source-code">
        scope("v1/item")</pre><pre class="source-code">
        .route("create/{title}", </pre><pre class="source-code">
                post().to(create::create))</pre><pre class="source-code">
        .route("get", get().to(get::get))</pre><pre class="source-code">
        .route("edit", post().to(edit::edit))</pre><pre class="source-code">
        .route("delete", post().to(delete::delete))</pre><pre class="source-code">
    );</pre><pre class="source-code">
}</pre></li>
				<li>By quickly inspecting <code>to_do_views_factory</code>, we can see that we have all the views that we need to manage our to-do items. If we were to eject this module out of our application<a id="_idIndexMarker456"/> and insert it into another, we would instantly see what we were deleting and adding. </li>
			</ol>
			<p>With our <code>delete</code> view fully integrated into our application, we can move on to the second step, which is building our JavaScript loading functionality. </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/>Adding a JavaScript loading function</h2>
			<p>Now that all our endpoints<a id="_idIndexMarker457"/> are ready, we must revisit our main app view. In the previous section, we established that the JavaScript in the <code>&lt;script&gt;</code> section works even though it is all just part of one big string. To enable us to put our JavaScript into a separate file, our view will load the HTML file as a string that has a <code>{{JAVASCRIPT}}</code> tag in the <code>&lt;script&gt;</code> section of the HTML file. Then, we will load the JavaScript file as a string and replace the <code>{{JAVASCRIPT}}</code> tag with the string from the JavaScript file. Finally, we will return the full string in the body in the <code>views/app/items.rs</code> file:</p>
			<pre class="source-code">
pub async fn items() -&gt; HttpResponse {
    let mut html_data = read_file(
        "./templates/main.html");
    let javascript_data = read_file(
        "./javascript/main.js");
    html_data = html_data.replace("{{JAVASCRIPT}}", 
        &amp;javascript_data);
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(html_data)
}</pre>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/>Adding JavaScript tags in the HTML </h2>
			<p>From our <code>items</code> function<a id="_idIndexMarker458"/> in the previous step, we can see that we need to build a new directory in the root called <code>JavaScript</code>. We must also create a file in it called <code>main.js</code>. With this change to the app view, we are also going to have to change the <code>templates/main.html</code> file by adding the following code:</p>
			<pre class="source-code">
&lt;body&gt;
    &lt;h1&gt;Done Items&lt;/h1&gt;
    &lt;div id="doneItems"&gt;&lt;/div&gt;
    &lt;h1&gt;To Do Items&lt;/h1&gt;
    &lt;div id="pendingItems"&gt;&lt;/div&gt;
    &lt;input type="text" id="name" placeholder="create to do
     item"&gt;
    &lt;button id="create-button" value="Send"&gt;Create&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    {{JAVASCRIPT}}
&lt;/script&gt;</pre>
			<p>Recall that our endpoints return pending items and completed items. Because of this, we have defined both lists with their own titles. <code>div</code> with the ID of <code>"doneItems"</code> is where we will insert the done to-do items from an API call. </p>
			<p>Then, we will insert our pending items<a id="_idIndexMarker459"/> from an API call in <code>div</code> with the ID of <code>"pendingItems"</code>. After that, we must define an input with text and a button. This will be for our user to create a new item.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/>Building a rendering JavaScript function</h2>
			<p>Now that our HTML has been defined, we are going<a id="_idIndexMarker460"/> to define the logic in our <code>javascript/main.js</code> file:</p>
			<ol>
				<li value="1">The first function that we are going to build renders all the to-do items on our main page. It must be noted that this is the most convoluted part of the code in the <code>javascript/main.js</code> file. We are essentially writing JavaScript code that writes HTML code. Later, in the <em class="italic">Creating a React app</em> section, we will replace the need to do this using the React framework. For now, we will build a render function that will create a list of items. Each item takes the following form in HTML:<pre class="source-code">
&lt;div&gt;</pre><pre class="source-code">
    &lt;div&gt;</pre><pre class="source-code">
        &lt;p&gt;learn to code rust&lt;/p&gt;</pre><pre class="source-code">
        &lt;button id="edit-learn-to-code-rust"&gt;</pre><pre class="source-code">
            edit</pre><pre class="source-code">
        &lt;/button&gt;</pre><pre class="source-code">
    &lt;/div&gt;</pre><pre class="source-code">
&lt;/div&gt;</pre></li>
			</ol>
			<p>We can see that the title of the to-do item is nested in a paragraph HTML tag. Then, we have a button. Recall that the <code>id</code> property of an HTML tag must be unique. Therefore, we construct this ID based on what the button is going to do on it and the title of the to-do item. This will enable us to bind functions performing API calls to these <code>id</code> properties using event listeners. </p>
			<ol>
				<li value="2">To build our render<a id="_idIndexMarker461"/> function, we are going to have to pass in the items to be rendered, the process type that we are going to perform (that is, <code>edit</code> or <code>delete</code>), the element ID of the section in the HTML where we are going to render these items, and the function that we are going to bind to each to-do item button. The outline of this function is defined in the following code:<pre class="source-code">
function renderItems(items, processType, </pre><pre class="source-code">
    elementId, processFunction) {</pre><pre class="source-code">
 . . .</pre><pre class="source-code">
}</pre></li>
				<li>Inside our <code>renderItems</code> function, we can start by constructing HTML and looping through our to-do items with the following code:<pre class="source-code">
let itemsMeta = [];</pre><pre class="source-code">
let placeholder = "&lt;div&gt;"</pre><pre class="source-code">
for (let i = 0; i &lt; items.length; i++) {</pre><pre class="source-code">
    . . .</pre><pre class="source-code">
}</pre><pre class="source-code">
placeholder += "&lt;/div&gt;"</pre><pre class="source-code">
document.getElementById(elementId).innerHTML = </pre><pre class="source-code">
    placeholder;</pre></li>
			</ol>
			<p>Here, we have defined an array that will collect metadata about the to-do items HTML that we generate for each to-do item. This is under the <code>itemsMeta</code> variable and will be used later in the <code>renderItems</code> function to bind <code>processFunction</code> to each to-do item button<a id="_idIndexMarker462"/> using event listeners. Then, we define the HTML that is housing all our to-do items for a process under the <code>placeholder</code> variable. Here, we start with a <code>div</code> tag. Then, we loop through the items, converting the data from each item into HTML, and then finish off the HTML with a closing <code>div</code> tag. After that, we insert the constructed HTML string known as <code>placeholder</code> into <code>innerHTML</code>. Where <code>innerHTML</code> is on the page is where we want to see our constructed to-do items. </p>
			<ol>
				<li value="4">Inside the loop, we must construct the individual to-do item HTML with the following code:<pre class="source-code">
let title = items[i]["title"];</pre><pre class="source-code">
let placeholderId = processType +</pre><pre class="source-code">
"-" + title.replaceAll(" ", "-");</pre><pre class="source-code">
placeholder += "&lt;div&gt;" + title +</pre><pre class="source-code">
"&lt;button " + 'id="' + placeholderId + '"&gt;'</pre><pre class="source-code">
+ processType +</pre><pre class="source-code">
'&lt;/button&gt;' + "&lt;/div&gt;";</pre><pre class="source-code">
itemsMeta.push({"id": placeholderId, "title": title});</pre></li>
			</ol>
			<p>Here, we extract the title of the item from the item that we are looping through. Then, we define our ID for the item that we are going to use to bind to an event listener. Note that we replace all empty spaces with a <code>-</code>. Now that we have defined the title and ID, we add a <code>div</code> with a title to our <code>placeholder</code> HTML string. We also add a <code>button</code> with a <code>placeholderId</code> and then finish it off with a <code>div</code>. We can see that our addition to the HTML string is finished with a <code>;</code>. Then, we add <code>placeholderId</code> and <code>title</code> to the <code>itemsMeta</code> array to be used later. </p>
			<ol>
				<li value="5">Next, we loop <code>itemsMeta</code>, creating event listeners<a id="_idIndexMarker463"/> with the following code:<pre class="source-code">
    . . .</pre><pre class="source-code">
    placeholder += "&lt;/div&gt;"</pre><pre class="source-code">
    document.getElementById(elementId).innerHTML </pre><pre class="source-code">
    = placeholder;</pre><pre class="source-code">
    for (let i = 0; i &lt; itemsMeta.length; i++) {</pre><pre class="source-code">
        document.getElementById(</pre><pre class="source-code">
            itemsMeta[i]["id"]).addEventListener(</pre><pre class="source-code">
            "click", processFunction);</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Now, <code>processFunction</code> will fire if a button that we created next to a to-do item is clicked. Our function now renders the items, but we need to get them from our backend with an API call function. We will look at this now. </p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor106"/>Building an API call JavaScript function</h2>
			<p>Now that we have our render<a id="_idIndexMarker464"/> function, we can look at our API call function: </p>
			<ol>
				<li value="1">First, we must define our API call function in the <code>javascript/main.js</code> file. This function takes in a URL, which is the endpoint of the API call. It also takes a method, which is a string of either <code>POST</code>, <code>GET</code>, or <code>PUT</code>. Then, we must define our request object:<pre class="source-code">
function apiCall(url, method) {</pre><pre class="source-code">
    let xhr = new XMLHttpRequest();</pre><pre class="source-code">
    xhr.withCredentials = true;</pre></li>
				<li>Then, we must define the event listener inside the <code>apiCall</code> function that renders the to-do items<a id="_idIndexMarker465"/> with the JSON returned once the call has finished:<pre class="source-code">
xhr.addEventListener('readystatechange', function() {</pre><pre class="source-code">
    if (this.readyState === this.DONE) {</pre><pre class="source-code">
        renderItems(JSON.parse(</pre><pre class="source-code">
        this.responseText)["pending_items"], </pre><pre class="source-code">
        "edit", "pendingItems", editItem);</pre><pre class="source-code">
        renderItems(JSON.parse(this.responseText)</pre><pre class="source-code">
            ["done_items"],</pre><pre class="source-code">
        "delete", "doneItems", deleteItem);</pre><pre class="source-code">
    }</pre><pre class="source-code">
});</pre></li>
			</ol>
			<p>Here, we can see that we are passing in the IDs that we defined in the <code>templates/main.html</code> file. We also pass in the response from the API call. We can also see that we pass in the <code>editItem</code> function, meaning that we are going to fire an <code>edit</code> function when a button alongside a pending item is clicked, turning the item into a done item. Considering this, if a button belonging to a done item is clicked, the <code>deleteItem</code> function is fired. For now, we will continue building the <code>apiCall</code> function. </p>
			<ol>
				<li value="3">After this, we must build the <code>editItem</code> and <code>deleteItem</code> functions. We also know that every time the <code>apiCall</code> function is called, the items are rendered.</li>
			</ol>
			<p>Now that we have defined the event listener, we must prep the API call object with the method and the URL, define the headers, and then return the request object for us to send it whenever we need:</p>
			<pre class="source-code">
    xhr.open(method, url);
    xhr.setRequestHeader('content-type', 
        'application/json');
    xhr.setRequestHeader('user-token', 'token');
    return xhr
}</pre>
			<p>Now, we can use our <code>apiCall</code> function to perform a call to the backend of our application and re-render the frontend with the new state of the items after our API call. With this, we can move on to the final step, where we will define our functions that perform<a id="_idIndexMarker466"/> create, get, delete, and edit functions on our to-do items. </p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor107"/>Building JavaScript functions for buttons</h2>
			<p>Note that the header is just hardcoding<a id="_idIndexMarker467"/> the accepted token that is hardcoded in the backend. We will cover how to properly define auth headers in <a href="B18722_07.xhtml#_idTextAnchor149"><em class="italic">Chapter 7</em></a>, <em class="italic">Managing User Sessions</em>. Now that our API call function has been defined, we can move on to the <code>editItem</code> function:</p>
			<pre class="source-code">
function editItem() {
    let title = this.id.replaceAll("-", " ")
        .replace("edit ", "");
    let call = apiCall("/v1/item/edit", "POST");
    let json = {
        "title": title,
        "status": "DONE"
    };
    call.send(JSON.stringify(json));
}</pre>
			<p>Here, we can see that the HTML section that the event listener belongs to can be accessed via <code>this</code>. We know that if we remove the <code>edit</code> word, and switch <code>-</code> with a space, it will convert the ID of the to-do item<a id="_idIndexMarker468"/> into the title of the to-do item. Then, we utilize the <code>apiCall</code> function to define our endpoint and method. Note that we have a space in the <code>"edit "</code> string in the <code>replace</code> function. We have this space because we must remove the space after the edit string as well. If we do not remove that space, it will be sent to the backend, causing an error since our application backend will not have the space next to the title of the item in our JSON file. Once our endpoint and API call method have been defined, we pass the title into a dictionary with the status as done. This is because we know that we are switching the pending item to done. Once this is done, we send the API call with the JSON body.</p>
			<p>Now, we can use the same approach for the <code>deleteItem</code> function:</p>
			<pre class="source-code">
function deleteItem() {
    let title = this.id.replaceAll("-", " ")
        .replace("delete ", "");
    let call = apiCall("/v1/item/delete", "POST");
    let json = {
        "title": title,
        "status": "DONE"
    };
    call.send(JSON.stringify(json));
}</pre>
			<p>Again, there is a space in the <code>"delete "</code> string in the <code>replace</code> function. With that, our rendering process is fully processed. We have defined edit and delete functions and a render function. Now, we must load the items when the page is initially loaded without having to click any buttons. This can be done with a simple API call:</p>
			<pre class="source-code">
function getItems() {
    let call = apiCall("/v1/item/get", 'GET');
    call.send()
}
getItems();</pre>
			<p>Here, we can see that we just make an API call with a <code>GET</code> method and send it. Also, note that our <code>getItems</code> function is being called outside of the function. This will be fired once when the view has loaded. </p>
			<p>It has been a long stint<a id="_idIndexMarker469"/> of coding; however, we are nearly there. We only need to define the functionality of the create text input and button. We can manage this with a simple event listener and API call for the <code>create</code> endpoint:</p>
			<pre class="source-code">
document.getElementById("create-button")
        .addEventListener("click", createItem);
function createItem() {
    let title = document.getElementById("name");
    let call = apiCall("/v1/item/create/" + 
        title.value, "POST");
    call.send();
    document.getElementById("name").value = null;
}</pre>
			<p>We have also added the detail of setting the text input value to <code>null</code>. We set <code>input</code> to <code>null</code> so that the user can input another item to be created without having to delete the old item title that was just created. Hitting the main view for the app gives us the following output:</p>
			<p class="IMG---Figure"><img src="img/Figure_5.5_B18722.png" alt="Figure 5.5 – Main page with rendered to-do items"/></p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Main page with rendered to-do items</p>
			<p>Now, to see if our frontend<a id="_idIndexMarker470"/> works the way we want it to, we can perform the following steps:</p>
			<ol>
				<li value="1">Press the <strong class="bold">delete</strong> button next to the <strong class="bold">washing</strong> done item.</li>
				<li>Type in <code>eat cereal for breakfast</code> and click <strong class="bold">Create</strong>.</li>
				<li>Type in <code>eat ramen for breakfast</code> and click <strong class="bold">Create</strong>.</li>
				<li>Click <code>eat ramen for </code><code>breakfast</code> item.</li>
			</ol>
			<p>These steps should yield the following result:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/Figure_5.6_B18722.jpg" alt="Figure 5.6 – Main page after completing the aforementioned steps"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Main page after completing the aforementioned steps</p>
			<p>With that, we have a fully functioning web app. All the buttons work, and the lists are instantly updated. However, it does not look very pretty. There is no spacing, and everything is in black and white. To amend<a id="_idIndexMarker471"/> this, we need to integrate CSS into the HTML file, which we will do in the next section.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Injecting CSS into HTML</h1>
			<p>Injecting CSS takes<a id="_idIndexMarker472"/> the same approach<a id="_idIndexMarker473"/> as injecting JavaScript. We will have a CSS tag in the HTML file that will be replaced with the CSS from the file. To achieve this, we must carry out the following steps:</p>
			<ol>
				<li value="1">Add CSS tags to our HTML file.</li>
				<li>Create a base CSS file for the whole app.</li>
				<li>Create a CSS file for our main view.</li>
				<li>Update our Rust crate to serve the CSS and JavaScript. </li>
			</ol>
			<p> Let’s have a closer look at this process.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Adding CSS tags to HTML</h2>
			<p>First, let’s make<a id="_idIndexMarker474"/> some changes to our <code>templates/main.html</code> file:</p>
			<pre class="source-code">
 &lt;style&gt;
    {{BASE_CSS}}
    {{CSS}}
&lt;/style&gt;
&lt;body&gt;
    &lt;div class="mainContainer"&gt;
        &lt;h1&gt;Done Items&lt;/h1&gt;
        &lt;div id="doneItems"&gt;&lt;/div&gt;
        &lt;h1&gt;To Do Items&lt;/h1&gt;
        &lt;div id="pendingItems"&gt;&lt;/div&gt;
        &lt;div class="inputContainer"&gt;
            &lt;input type="text" id="name"
                   placeholder="create to do item"&gt;
            &lt;div class="actionButton" 
                 id="create-button" 
                 value="Send"&gt;Create&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    {{JAVASCRIPT}}
&lt;/script&gt;</pre>
			<p>Here, we can see that<a id="_idIndexMarker475"/> we have two CSS tags. The <code>{{BASE_CSS}}</code> tag is for base CSS, which will be consistent in multiple different views, such as the background color and column ratios, depending on the screen size. The <code>{{BASE_CSS}}</code> tag is for managing CSS classes for this view. Respectfully, the <code>css/base.css</code> and <code>css/main.css</code> files are made for our views. Also, note that we have put all the items in a <code>div</code> with a class called <code>mainContainer</code>. This will enable us to center all the items on the screen. We have also added some more classes so that the CSS can reference them, and changed the button for the create item from a <code>button</code> HTML tag to a <code>div</code> HTML tag. Once this is done, our <code>renderItems</code> function in the <code>javascript/main.js</code> file will have the following alteration for the loop of the items:</p>
			<pre class="source-code">
function renderItems(items, processType, 
    elementId, processFunction) {
    . . . 
    for (i = 0; i &lt; items.length; i++) {
        . . .
        placeholder += '&lt;div class="itemContainer"&gt;' +
            '&lt;p&gt;' + title + '&lt;/p&gt;' +
            '&lt;div class="actionButton" ' + 
                  'id="' + placeholderId + '"&gt;'
            + processType + '&lt;/div&gt;' + "&lt;/div&gt;";
        itemsMeta.push({"id": placeholderId, "title":        title});
    }
    . . .
}</pre>
			<p>With this considered, we can<a id="_idIndexMarker476"/> now define our base CSS in our <code>css/base.css</code> file.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/>Creating a base CSS</h2>
			<p>Now, we must define<a id="_idIndexMarker477"/> the style of the page and its components. A good place to start is by defining the body of the page in the <code>css/base.css</code> file. We can do a basic configuration of the body with the following code:</p>
			<pre class="source-code">
body {
    background-color: #92a8d1;
    font-family: Arial, Helvetica, sans-serif;
    height: 100vh;
} </pre>
			<p>The background color is a reference to a type of color. This reference might not seem like it makes sense just looking at it but there are color pickers online where you can see and pick a color and the reference code is supplied. Some code editors support this functionality but for some quick reference, simply Google <code>HTML color picker</code> and you will be spoilt for choice at the number of free online interactive tools that will be available. With the preceding configuration, the background for the entire page will have a code of <code>#92a8d1</code>, which is a navy-blue color. If we just had that, most of the page would have a white background. The navy-blue background would only be present where there is content. We set the height to <code>100vh</code>. <code>vh</code> is relative to 1% of the height of the viewport. With this, we can deduce that <code>100vh</code> means the styling we defined in the body occupies 100% of the viewport. Then, we define the font for all text unless overwritten to <code>Arial</code>, <code>Helvetica</code>, or <code>sans-serif</code>. We can see that we have defined multiple fonts in <code>font-family</code>. This does not mean that all of them are implemented or that there are different fonts for different levels of headers or HTML tags. Instead, this is a fallback mechanism. First, the browser will try and render <code>Arial</code>; if it is not supported by the browser, it will then try and render <code>Helvetica</code>, and if that fails too, it will try and render <code>sans-serif</code>. </p>
			<p>With that, we have defined<a id="_idIndexMarker478"/> the general style for our body, but what about different screen sizes? For instance, if we were going to access our application on our phone, it should have different dimensions. We can see this in the following figure:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/Figure_5.7_B18722.jpg" alt="Figure 5.7 – Difference in margins between a phone and desktop monitor"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Difference in margins between a phone and desktop monitor</p>
			<p><em class="italic">Figure 5</em><em class="italic">.7</em> shows the ratio of the margin to the space that is filled up by the to-do items list changes. With a phone, there is not much screen space, so most of the screen needs to be taken up by the to-do item; otherwise, we would not be able to read it. However, if we are using a widescreen desktop monitor, we no longer need most of the screen for the to-do items. If the ratio was the same, the to-do items would be so stretched in the <em class="italic">X</em>-axis that it would be hard to read and frankly would not look good. This is where media queries come in. We can have different style conditions based on attributes such as the width and height of the window. We will start with the phone specification. So, if the width of the screen<a id="_idIndexMarker479"/> is up to 500 pixels, in our <code>css/base.css</code> file, we must define the following CSS configuration for our body:</p>
			<pre class="source-code">
@media(max-width: 500px) {
    body {
        padding: 1px;
        display: grid;
        grid-template-columns: 1fr;
    }
}</pre>
			<p>Here, we can see that the padding around the edge of the page and each element is just one pixel. We also have a grid display. This is where we can define columns and rows. However, we do not use it to its full extent. We just have one column. This means that our to-do items will take up most of the screen, as shown in the phone depiction in <em class="italic">Figure 5</em><em class="italic">.7</em>. Even though we are not using a grid in this context, I have kept it in so that you can see the relationship this has to the other configurations for larger screens. If our screen gets a little bigger, we can split our page into three different vertical columns; however, the ratio of the width of the middle column to that of the columns on either side is 5:1. This is because our screen is still not very big, and we want our items to still take up most of the screen. We can adjust for this by adding another media query with different parameters:</p>
			<pre class="source-code">
@media(min-width: 501px) and (max-width: 550px) {
    body {
        padding: 1px;
        display: grid;
        grid-template-columns: 1fr 5fr 1fr;
    } 
    .mainContainer {
        grid-column-start: 2;
    }
}</pre>
			<p>We can also see that, for our <code>mainContainer</code> CSS class where we house our to-do items, we will overwrite the <code>grid-column-start</code> attribute. If we don’t do this, then <code>mainContainer</code> would be squeezed in the left margin at <code>1fr</code> width. Instead, we are starting and finishing in the middle at <code>5fr</code>. We can make <code>mainContainer</code> span across multiple columns with a <code>grid-column-finish</code> attribute.  </p>
			<p>If our screen gets<a id="_idIndexMarker480"/> larger, then we want to adjust the ratios even more as we do not want our items width to get out of control. To achieve this, we must define a 3 to 1 ratio for the middle column versus the 2 side columns, and then a 1 to 1 ratio when the screen width gets higher than <code>1001px</code>:</p>
			<pre class="source-code">
@media(min-width: 551px) and (max-width: 1000px) {
    body {
        padding: 1px;
        display: grid;
        grid-template-columns: 1fr 3fr 1fr;
    } 
    .mainContainer {
        grid-column-start: 2;
    }
} 
@media(min-width: 1001px) {
    body {
        padding: 1px;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
    } 
    .mainContainer {
        grid-column-start: 2;
    }
}</pre>
			<p>Now that we have defined<a id="_idIndexMarker481"/> our general CSS for all views, we can move on to our view-specific CSS in our <code>css/main.css</code> file. </p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/>Creating CSS for the home page</h2>
			<p>Now, we must break<a id="_idIndexMarker482"/> down our app components. We have a list of to-do items. Each item in the list will be a <code>div</code> that has a different background color:</p>
			<pre class="source-code">
.itemContainer {
    background: #034f84;
    margin: 0.3rem;
}</pre>
			<p>We can see that this class has a margin of 0.3. We are using <code>rem</code> because we want the margin to scale relative to the font size of the root element. We also want our item to slightly change color if our cursor hovers over it:</p>
			<pre class="source-code">
.itemContainer:hover {
    background: #034f99;
}</pre>
			<p>Inside an item container, the title of our item is denoted with a paragraph tag. We want to define the style of all the paragraphs in the item containers but not elsewhere. We can define the style of the paragraphs in the container using the following code:</p>
			<pre class="source-code">
.itemContainer p {
    color: white;
    display: inline-block;
    margin: 0.5rem;
    margin-right: 0.4rem;
    margin-left: 0.4rem;
}</pre>
			<p><code>inline-block</code> allows the title to be displayed alongside <code>div</code>, which will be acting as the button for the item. The margin definitions merely stop the title from being right up against the edge of the item container. We also ensure that the paragraph color is white. </p>
			<p>With our item title styled, the only item styling<a id="_idIndexMarker483"/> left is the action button, which is either <code>edit</code> or <code>delete</code>. This action button is going to float to the right with a different background color so that we know where to click. To do this, we must define our button style with a class, as outlined in the following code:</p>
			<pre class="source-code">
.actionButton {
    display: inline-block;
    float: right;
    background: #f7786b;
    border: none;
    padding: 0.5rem;
    padding-left: 2rem;
    padding-right: 2rem;
    color: white;
}</pre>
			<p>Here, we’ve defined the display, made it float to the right, and defined the background color and padding. With this, we can ensure the color changes on hover by running the following code:</p>
			<pre class="source-code">
.actionButton:hover {
    background: #f7686b;
    color: black;
}</pre>
			<p>Now that we have covered all the concepts, we must define the styles for the input container. This can be done by running the following code: </p>
			<pre class="source-code">
.inputContainer {
    background: #034f84;
    margin: 0.3rem;
    margin-top: 2rem;
}
.inputContainer input {
    display: inline-block;
    margin: 0.4rem;
}</pre>
			<p>We’ve done it! We have defined<a id="_idIndexMarker484"/> all the CSS, JavaScript, and HTML. Before we run the app, we need to load the data in the main view. </p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Serving CSS and JavaScript from Rust</h2>
			<p>We serve<a id="_idIndexMarker485"/> our CSS <a id="_idIndexMarker486"/>in the <code>views/app/items.rs</code> file. We do<a id="_idIndexMarker487"/> this by reading<a id="_idIndexMarker488"/> the HTML, JavaScript, base CSS, and main CSS files. Then, we replace our tags in the HTML data with the data from the other files:  </p>
			<pre class="source-code">
pub async fn items() -&gt; HttpResponse {
    let mut html_data = read_file(
        "./templates/main.html");
    let javascript_data: String = read_file(
        "./javascript/main.js");
    let css_data: String = read_file(
        "./css/main.css");
    let base_css_data: String = read_file(
        "./css/base.css");
    html_data = html_data.replace("{{JAVASCRIPT}}", 
    &amp;javascript_data);
    html_data = html_data.replace("{{CSS}}", 
    &amp;css_data);
    html_data = html_data.replace("{{BASE_CSS}}", 
    &amp;base_css_data);
    HttpResponse::Ok()
        .content_type("text/html; charset=utf-8")
        .body(html_data)
}</pre>
			<p>Now, when we spin up<a id="_idIndexMarker489"/> our server, we will have<a id="_idIndexMarker490"/> a fully running app<a id="_idIndexMarker491"/> with an intuitive<a id="_idIndexMarker492"/> frontend that will look like what’s shown in the following screenshot:</p>
			<div><div><img src="img/Figure_5.8_B18722.jpg" alt="Figure 5.8 – Main page after CSS"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Main page after CSS</p>
			<p>Even though our app is functioning, and we have configured the base CSS and HTML, we may want to have reusable standalone HTML structures that have their own CSS. These structures can be injected into views as and when needed. What this does is gives us the ability to write a component once, and then import it into other HTML files. This, in turn, makes it easier to maintain<a id="_idIndexMarker493"/> and ensures consistency of the component<a id="_idIndexMarker494"/> in multiple<a id="_idIndexMarker495"/> views. For instance, if we<a id="_idIndexMarker496"/> create an information bar at the top of the view, we will want it to have the same styling in the rest of the views. Therefore, it makes sense to create an information bar once as a component and insert it into other views, as covered in the next section.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor113"/>Inheriting components </h1>
			<p>Sometimes, we will want<a id="_idIndexMarker497"/> to build a component that can be injected into views. To do this, we are going to have to load both the CSS and HTML, and then insert them into the correct parts of the HTML. </p>
			<p>To do this, we can create an <code>add_component</code> function that takes the name of the component, creates tags from the component<a id="_idIndexMarker498"/> name, and loads the HTML and CSS based on the component name. We will define this function in the <code>views/app/content_loader.rs</code> file:</p>
			<pre class="source-code">
pub fn add_component(component_tag: String, 
    html_data: String) -&gt; String {
    let css_tag: String = component_tag.to_uppercase() + 
        "_CSS";
    let html_tag: String = component_tag.to_uppercase() + 
        "_HTML";
    let css_path = String::from("./templates/components/") 
        + &amp;component_tag.to_lowercase() + ".css";
    let css_loaded = read_file(&amp;css_path);
    let html_path = String::from("./templates/components/") 
        + &amp;component_tag.to_lowercase() + ".html";
    let html_loaded = read_file(&amp;html_path);
    let html_data = html_data.replace(html_tag.as_str(), 
        &amp;html_loaded);
    let html_data = html_data.replace(css_tag.as_str(), 
        &amp;css_loaded);
    return html_data
} </pre>
			<p>Here, we use the <code>read_file</code> function<a id="_idIndexMarker499"/> that is defined in the same file. Then, we inject the component HTML and CSS into the view data. Note that we nested our components in a <code>templates/components/</code> directory. For this instance, we are inserting a <code>header</code> component, so our <code>add_component</code> function will try and load the <code>header.html</code> and <code>header.css</code> files when we pass the header into the <code>add_component</code> function. In our <code>templates/components/header.html</code> file, we must define the following HTML:</p>
			<pre class="source-code">
&lt;div class="header"&gt;
    &lt;p&gt;complete tasks: &lt;/p&gt;&lt;p id="completeNum"&gt;&lt;/p&gt;
    &lt;p&gt;pending tasks: &lt;/p&gt;&lt;p id="pendingNum"&gt;&lt;/p&gt;
&lt;/div&gt;</pre>
			<p>Here, we are merely displaying<a id="_idIndexMarker500"/> the counts for the number of completed and pending to-do items. In our <code>templates/components/header.css</code> file, we must define the following CSS:</p>
			<pre class="source-code">
.header {
    background: #034f84;
    margin-bottom: 0.3rem;
}
.header p {
    color: white;
    display: inline-block;
    margin: 0.5rem;
    margin-right: 0.4rem;
    margin-left: 0.4rem;
}</pre>
			<p>For our <code>add_component</code> function to insert our CSS and HTML into the right place, we must insert the <code>HEADER</code> tag into the <code>&lt;style&gt;</code> section of the <code>templates/main.html</code> file: </p>
			<pre class="source-code">
. . . 
    &lt;style&gt;
        {{BASE_CSS}}
        {{CSS}}
        HEADER_CSS
    &lt;/style&gt;
    &lt;body&gt;
        &lt;div class="mainContainer"&gt;
            HEADER_HTML
            &lt;h1&gt;Done Items&lt;/h1&gt;
. . .</pre>
			<p>Now that all of our HTML<a id="_idIndexMarker501"/> and CSS have been defined, we need to import the <code>add_component</code> function in our <code>views/app/items.rs</code> file:</p>
			<pre class="source-code">
use super::content_loader::add_component;</pre>
			<p>In the same file, we must add the header in the <code>items</code> view function, like so:</p>
			<pre class="source-code">
html_data = add_component(String::from("header"), 
    html_data);</pre>
			<p>Now, we must alter the <code>apiCall</code> function in our <code>injecting_header/javascript/main.js</code> file to ensure that the header is updated with the to-do item counts:</p>
			<pre class="source-code">
document.getElementById("completeNum").innerHTML = 
    JSON.parse(this.responseText)["done_item_count"];
document.getElementById("pendingNum").innerHTML = 
    JSON.parse(this.responseText)["pending_item_count"]; </pre>
			<p>Now that we have inserted our component, we get the following rendered view:</p>
			<div><div><img src="img/Figure_5.9_B18722.jpg" alt="Figure 5.9 – Main page with header"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Main page with header</p>
			<p>As we can see, our header displays the data correctly. If we add the header tags to the view HTML file, and we call <code>add_component</code> in our view, we will get that header. </p>
			<p>Right now, we have a fully working single-page application. However, this was not without difficulty. We can see that our frontend would start to spiral out of control if we started to add more features<a id="_idIndexMarker502"/> to the frontend. This is where frameworks such as React come in. With React, we can structure our code into proper components so that we can use them whenever we need to. In the next section, we will create a basic React application. </p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor114"/>Creating a React app</h1>
			<p>React is a standalone<a id="_idIndexMarker503"/> application. Because of this, we will usually have our React application in its own GitHub repository. If you want to keep your Rust application and React application in the same GitHub repository, that is fine, but just make sure that they are in different directories in the root. Once we have navigated outside of the Rust web application, we can run the following command:</p>
			<pre class="console">
npx create-react-app front_end</pre>
			<p>This creates a React application in the <code>front_end</code> directory. If we look inside, we will see that there are a lot of files. Remember that this book is about web programming in Rust. Exploring everything about React is beyond the scope of this book. However, a book dedicated to React<a id="_idIndexMarker504"/> development is suggested in the <em class="italic">Further reading</em> section. For now, we will focus on the <code>front_end/package.json</code> file. Our <code>package.json</code> file is like our <code>Cargo.toml</code> file, where we define dependencies, scripts, and other metadata around the application that we are building. Inside our <code>package.json</code> file, we have the following scripts:</p>
			<pre class="source-code">
. . .
"scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
},
. . .</pre>
			<p>We can edit this if we want but as it stands, if we run the <code>npm start</code> command in the directory where our <code>package.json</code> file is, we will run the <code>react-scripts start</code> command. We will run our React application soon, but before this, we must edit our <code>front_end/src/App.js</code> file with the following code:</p>
			<pre class="source-code">
import React, { Component } from 'react';
class App extends Component {
  state = {
    "message": "To Do"
  }
  render() {
    return (
        &lt;div className="App"&gt;
          &lt;p&gt;{this.state.message} application&lt;/p&gt;
        &lt;/div&gt;
    )
  }
}
export default App;</pre>
			<p>Before we break down this code, we must clarify something. If you go on the internet, you might come across articles<a id="_idIndexMarker505"/> stating that JavaScript is not a class-based object-oriented language. This book is not going to take a deep dive into JavaScript. Instead, this chapter is designed to give you enough knowledge to get a frontend up and running. Hopefully, this chapter is enough to facilitate further reading and kickstart your journey if you want to add a frontend to your Rust web application. For the sake of this chapter, we will just look at classes and objects that can support inheritance. </p>
			<p>In the preceding code, we imported the <code>component</code> object from the <code>react</code> package. Then, we defined an <code>App</code> class that inherits the <code>component</code> class. The <code>App</code> class is the main part of our application, and we can treat the <code>front_end/src/App.js</code> file as our entry point for the frontend application. It is in the <code>App</code> class that we can define other routes if needed. We can also see that there is a <code>state</code> belonging to the <code>App</code> class. This is the overall memory of the application. We must call it <code>state</code>; every time the state is updated, the <code>render</code> function is executed, updating what the component renders to the frontend. This has abstracted a lot of what we were doing throughout the previous sections of this chapter when our state updated our homemade <code>render</code> function. We can see that our state can be referenced in the <code>render</code> function when returning. This is known as JSX, which allows us<a id="_idIndexMarker506"/> to write HTML elements directly in JavaScript without any extra methods. Now that the basic application has been defined, we can export it to make it available. </p>
			<p>Let’s navigate to the directory where the <code>package.json</code> file is placed and run the following command:</p>
			<pre class="console">
npm start</pre>
			<p>The React server will spin up and we will get the following view in our browser:</p>
			<div><div><img src="img/Figure_5.10_B18722.jpg" alt="Figure 5.10 – First main view of our React application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – First main view of our React application</p>
			<p>Here, we can see that the message<a id="_idIndexMarker507"/> in our state has been passed into our <code>render</code> function and then displayed in our browser. Now that our React application is running, we can start loading data into our React application using API calls. </p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Making API calls in React</h1>
			<p>Now that the basic <a id="_idIndexMarker508"/>application<a id="_idIndexMarker509"/> is running, we can start performing an API call to our backend. For this, we will mainly focus on the <code>front_end/src/App.js</code> file. We can build up our application so that it can populate the frontend with items from our Rust application. First we must add the following to the dependencies of our <code>package.json</code> file:</p>
			<pre class="source-code">
"axios": "^0.26.1"</pre>
			<p>Then, we can run the following command:</p>
			<pre class="console">
npm install</pre>
			<p>This will install our extra dependency. Now, we can turn to our <code>front_end/src/App.js</code> file and import what we need with the following code:</p>
			<pre class="source-code">
import React, { Component } from 'react';
import axios from 'axios';</pre>
			<p>We are going to use <code>Component</code> for our <code>App</code> class inheritance and <code>axios</code> to perform API calls to our backend. Now, we can define our <code>App</code> class and update our state with the following code:</p>
			<pre class="source-code">
class App extends Component {
  state = {
      "pending_items": [],
      "done_items": [],
      "pending_items_count": 0,
      "done_items_count": 0
  }
}
export default App;</pre>
			<p>Here, we have the same structure<a id="_idIndexMarker510"/> as our homemade frontend. This is also the data<a id="_idIndexMarker511"/> that we return from our get items view in the Rust server. Now that we know what data we are going to work with, we can carry out the following steps:</p>
			<ol>
				<li value="1">Create a function inside our <code>App</code> class that gets the functions from the Rust server. </li>
				<li>Ensure that this function is executed when the <code>App</code> class is mounted.</li>
				<li>Create a function inside our <code>App</code> class that processes the items that are returned from the Rust server into HTML. </li>
				<li>Create a function inside our <code>App</code> class that renders all the aforementioned components to the frontend once we are finished. </li>
				<li>Enable our Rust server to receive calls from other sources.</li>
			</ol>
			<p>Before we embark on these steps, we should note that the outline for our <code>App</code> class will take the following form:</p>
			<pre class="source-code">
class App extends Component {
 
  state = {
      . . .
  }
  // makes the API call
  getItems() {
      . . .
  }
  // ensures the API call is updated when mounted
  componentDidMount() {
      . . .
  }
  // convert items from API to HTML 
  processItemValues(items) {
      . . .
  }
  // returns the HTML to be rendered
  render() {
    return (
        . . .
    )
  }
}</pre>
			<p>With this, we can<a id="_idIndexMarker512"/> start on the function<a id="_idIndexMarker513"/> that makes the API call:</p>
			<ol>
				<li value="1">Inside our <code>App</code> class, our <code>getItems</code> function takes the following layout:<pre class="source-code">
axios.get("http://127.0.0.1:8000/v1/item/get",</pre><pre class="source-code">
  {headers: {"token": "some_token"}})</pre><pre class="source-code">
  .then(response =&gt; {</pre><pre class="source-code">
      let pending_items = response.data["pending_items"]</pre><pre class="source-code">
      let done_items = response.data["done_items"]</pre><pre class="source-code">
      this.setState({</pre><pre class="source-code">
            . . .</pre><pre class="source-code">
        })</pre><pre class="source-code">
  });</pre></li>
			</ol>
			<p>Here, we define the URL. Then, we add our token to our header. For now, we will just hardcode a simple string because we are not setting up our user sessions in the Rust server yet; we will update this in <a href="B18722_07.xhtml#_idTextAnchor149"><em class="italic">Chapter 7</em></a>, <em class="italic">Managing User Sessions</em>. Then, we close this. Because <code>axios.get</code> is a promise, we must use <code>.then</code>. The code inside the <code>.then</code> brackets is executed when the data is returned. Inside these brackets, we extract the data that we need and then execute the <code>this.setState</code> function. The <code>this.setState</code> function updates the state of the <code>App</code> class. However, executing <code>this.setState</code> also executes the <code>render</code> function of the <code>App</code> class, which will update the browser. Inside this <code>this.setState</code> function, we pass in the following code:</p>
			<pre class="source-code">
"pending_items": this.processItemValues(pending_items),
"done_items": this.processItemValues(done_items),
"pending_items_count": response.data["pending_item_count"],
"done_items_count": response.data["done_item_count"]</pre>
			<p>With this, we have completed <code>getItems</code> and we can get items from the backend. Now<a id="_idIndexMarker514"/> that we have defined it, we must ensure<a id="_idIndexMarker515"/> that it gets executed, which we will do next. </p>
			<ol>
				<li value="2">Ensuring the <code>getItems</code> function is fired and thus the state is updated when the <code>App</code> class is loaded can be achieved with the following code:<pre class="source-code">
componentDidMount() {</pre><pre class="source-code">
  this.getItems();</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>This is straightforward. <code>getItems</code> will execute immediately after our <code>App</code> component is mounted. We are essentially calling <code>this.setState</code> in the <code>componentDidMount</code> function. This triggers the extra rendering before the browser updates the screen. Even though <code>render</code> is called twice, the user will not see the intermediate state. This is one of the many functions that we inherit from the React <code>Component</code> class. Now that we load the data as soon as the page loads, we can move on to the next step: processing the loaded data. </p>
			<ol>
				<li value="3">For the <code>processItemValues</code> function inside our <code>App</code> class, we must take in an array of JSON objects that represent items and convert them into HTML, which can be achieved with the following code:<pre class="source-code">
processItemValues(items) {</pre><pre class="source-code">
  let itemList = [];</pre><pre class="source-code">
  items.forEach((item, index)=&gt;{</pre><pre class="source-code">
      itemList.push(</pre><pre class="source-code">
          &lt;li key={index}&gt;{item.title} {item.status}&lt;/li&gt;</pre><pre class="source-code">
      )</pre><pre class="source-code">
  })</pre><pre class="source-code">
  return itemList</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Here, we just loop through the items, converting them into <code>li</code> HTML elements and adding them to an empty array that is then returned once filled. Remember that we use the <code>processItemValue</code> function to process the data before it goes into the state in the <code>getItems</code> function. Now that we have all the HTML components in our state, we need to place them on the page with our <code>render</code> function. </p>
			<ol>
				<li value="4">For our <code>App</code> class, the <code>render</code> function<a id="_idIndexMarker516"/> only returns HTML<a id="_idIndexMarker517"/> components. We do not employ any extra logic in this. We can return the following:  <pre class="source-code">
&lt;div className="App"&gt;</pre><pre class="source-code">
&lt;h1&gt;Done Items&lt;/h1&gt;</pre><pre class="source-code">
&lt;p&gt;done item count: {this.state.done_items_count}&lt;/p&gt;</pre><pre class="source-code">
{this.state.done_items}</pre><pre class="source-code">
&lt;h1&gt;Pending Items&lt;/h1&gt;</pre><pre class="source-code">
&lt;p&gt;pending item count: </pre><pre class="source-code">
    {this.state.pending_items_count}&lt;/p&gt;</pre><pre class="source-code">
{this.state.pending_items}</pre><pre class="source-code">
&lt;/div&gt;</pre></li>
			</ol>
			<p>Here, we can see that our state is directly referenced. This is a lovely change from the manual string manipulation that we employed earlier in this chapter. Using React is a lot cleaner, reducing the risk of errors. On our frontend, the render process with the calls to the backend should work. However, our Rust server will block requests from the React application because it is from a different application. To fix this, we need to move on to the next step.  </p>
			<ol>
				<li value="5">Right now, our Rust server<a id="_idIndexMarker518"/> will block our requests to the server. This is down to <code>Cargo.toml</code> file with the following code:<pre class="source-code">
actix-cors = "0.6.1"</pre></li>
			</ol>
			<p>In our <code>src/main.rs</code> file, we must import CORS with the following code:</p>
			<pre class="source-code">
use actix_cors::Cors;</pre>
			<p>Now, we must define CORS policy before the definition of the server and wrap the CORS policy right after the views configuration with the following code:</p>
			<pre class="source-code">
#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    HttpServer::new(|| {
        let cors = Cors::default().allow_any_origin()
                                  .allow_any_method()
                                  .allow_any_header();
        let app = App::new()
            .wrap_fn(|req, srv|{
                println!("{}-{}", req.method(), 
                          req.uri());
                let future = srv.call(req);
                async {
                    let result = future.await?;
                    Ok(result)
                }
        }).configure(views::views_factory).wrap(cors);
        return app
    })
    .bind("127.0.0.1:8000")?
    .run()
    .await
}</pre>
			<p>With this, our server<a id="_idIndexMarker521"/> is ready to accept requests from our React<a id="_idIndexMarker522"/> application. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">When we defined our CORS policy, we were expressive in that we wanted to allow all methods, headers, and origins. However, we can be more concise with the following CORS definition:</p>
			<p class="callout"><code>let cors = </code><code>Cors::permissive();</code></p>
			<p>Now, we can test our application to see if it is working. We can do this by running our Rust server with Cargo and running our React application in a different terminal. Once this is up and running, our React application should look like this when loaded:</p>
			<div><div><img src="img/Figure_5.11_B18722.jpg" alt="Figure 5.11 – The view of our React application when it first talks to our Rust server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – The view of our React application when it first talks to our Rust server</p>
			<p>With this, we can see that the call<a id="_idIndexMarker523"/> to our Rust application is now working<a id="_idIndexMarker524"/> as expected. However, all we are doing is listing the names and statuses of the to-do items. Where React shines is in building custom components. This means that we can build individual classes that have their own states and functions for each to-do item. We’ll see this in the next section. </p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/>Creating custom components in React</h1>
			<p>When we look<a id="_idIndexMarker525"/> at our <code>App</code> class, we can see that it is useful<a id="_idIndexMarker526"/> to have a class that has a state and functions that can be utilized to manage how and when HTML is rendered to the browser. When it comes to individual to-do items, we could use a state and functions. This is because we have a button that gets attributes from the to-do item and calls the Rust server to either edit or delete it. In this section, we are going to build two components: a <code>ToDoItem</code> component in the <code>src/components/ToDoItem.js</code> file and a <code>CreateToDoItem</code> component in the <code>src/components/CreateToDoItem.js</code> file. Once we have built these, we can plug them into our <code>App</code> component as our <code>App</code> component will get the items’ data and loop through these items, creating multiple <code>ToDoItem</code> components. There are a few steps that we need to process<a id="_idIndexMarker527"/> to achieve this, so this section will be split<a id="_idIndexMarker528"/> into the following subsections:</p>
			<ul>
				<li>Creating our <code>ToDoItem</code> component </li>
				<li>Creating our <code>CreateToDoItem</code> component</li>
				<li>Constructing and managing custom components in our <code>App</code> component</li>
			</ul>
			<p>Let’s get started.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/>Creating our ToDoItem component</h2>
			<p>We will start<a id="_idIndexMarker529"/> with the simpler <code>ToDoItem</code> component in the <code>src/components/ToDoItem.js</code> file. First, we must import the following:</p>
			<pre class="source-code">
import React, { Component } from 'react';
import axios from "axios";</pre>
			<p>This is nothing new. Now that we have imported what we need, we can focus on how we define <code>ToDoItem</code> with the following code:</p>
			<pre class="source-code">
class ToDoItem extends Component {
    state = {
        "title": this.props.title,
        "status": this.props.status,
        "button": this.processStatus(this.props.status)
    }
    processStatus(status) {
        . . .
    }
    inverseStatus(status) {
        . . .
    }
    sendRequest = () =&gt; {
        . . .
    }
    render() {
        return(
            . . .
        )
    }
}
export default ToDoItem;</pre>
			<p>Here, we populate the state with <code>this.props</code>, which is the parameter that’s passed into the component<a id="_idIndexMarker530"/> when the component is constructed. Then, we have the following functions for our <code>ToDoItem</code> component:</p>
			<ul>
				<li><code>processStatus</code>: This function converts<a id="_idIndexMarker531"/> the status of the to-do item, such as <code>PENDING</code>, into the message on the button, such as <code>edit</code>.</li>
				<li><code>inverseStatus</code>: When we have a to-do item with a status of <code>PENDING</code> and we edit it, we want to convert it into a status of <code>DONE</code> so that it can be sent to the <code>edit</code> endpoint on the Rust server, which is the inverse. Therefore, this function creates an inverse of the status that’s passed in. </li>
				<li><code>sendRequest</code>: This function sends the request to the Rust server for either editing or deleting the to-do item. We can also see that our <code>sendRequest</code> function is an arrow function. The arrow syntax essentially binds the function to the component so that we can reference it in our <code>render</code> return statement, allowing the <code>sendRequest</code> function to be executed<a id="_idIndexMarker532"/> when a button that is bound to it is clicked. </li>
			</ul>
			<p>Now that we know what<a id="_idIndexMarker533"/> our functions are supposed to do, we can define our status functions with the following code:</p>
			<pre class="source-code">
processStatus(status) {
    if (status === "PENDING") {
        return "edit"
    } else {
        return "delete"
    }
}
inverseStatus(status) {
    if (status === "PENDING") {
        return "DONE"
    } else {
        return "PENDING"
    }
}</pre>
			<p>This is straightforward and does not need much explanation. Now that our status processing functions are done, we can define our <code>sendRequest</code> function with the following code:</p>
			<pre class="source-code">
sendRequest = () =&gt; {
    axios.post("http://127.0.0.1:8000/v1/item/" + 
                this.state.button,
        {
            "title": this.state.title,
            "status": this.inverseStatus(this.state.status)
        },
    {headers: {"token": "some_token"}})
        .then(response =&gt; {
            this.props.passBackResponse(response);
        });
}</pre>
			<p>Here, we use <code>this.state.button</code> to define part of the URL as the endpoint changes, depending on the button<a id="_idIndexMarker534"/> that we are pressing. We can also see that we execute the <code>this.props.passBackResponse</code> function. This is a function that we pass into the <code>ToDoItem</code> component. This is because we get the full state of our to-do items from the Rust server back after the edit or delete request. We will need to enable our <code>App</code> component to process the data that has been passed back. Here, we are getting a sneak peek of what we are going to be doing in the <em class="italic">Constructing and managing custom components in our App component</em> subsection. Our <code>App</code> component will have an unexecuted function under the <code>passBackResponse</code> parameter that it will pass through to our <code>ToDoItem</code> component. This function, under the <code>passBackResponse</code> parameter, will process the new to-do item’s state and render it in the <code>App</code> component. </p>
			<p>With that, we have configured all our functions. All that is left is to define the return of the <code>render</code> function, which takes the following form:</p>
			<pre class="source-code">
&lt;div&gt;
    &lt;p&gt;{this.state.title}&lt;/p&gt;
    &lt;button onClick={this.sendRequest}&gt;
                    {this.state.button}&lt;/button&gt;
&lt;/div&gt;</pre>
			<p>Here, we can see that the title of the to-do item is rendered in the paragraph tag and that our button executes the <code>sendRequest</code> function when clicked. We have now finished this component and it is ready to be displayed in our application. However, before we do this, we need<a id="_idIndexMarker535"/> to build the component that creates to-do items in the next section. </p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Creating custom components in React</h2>
			<p>Our React application<a id="_idIndexMarker536"/> is functioning in terms of listing, editing, and deleting<a id="_idIndexMarker537"/> to-do items. However, we are not able to create any to-do items. This consists of an input and a <code>create</code> button so that we can put in a to-do item that we can then create by clicking the button. In our <code>src/components/CreateToDoItem.js</code> file, we need to import the following:</p>
			<pre class="source-code">
import React, { Component } from 'react';
import axios from "axios";</pre>
			<p>These are the standard imports to build our components. Once the imports have been defined, our <code>CreateToDoItem</code> component takes the following form: </p>
			<pre class="source-code">
class CreateToDoItem extends Component {
    state = {
        title: ""
    }
    createItem = () =&gt; {
        . . .
    }
    handleTitleChange = (e) =&gt; {
        . . .
    }
    render() {
        return (
            . . .
        )
    }
}
export default CreateToDoItem;</pre>
			<p>In the preceding code, we can see that our <code>CreateToDoItem</code> component has the following functions:</p>
			<ul>
				<li><code>createItem</code>: This function sends a request to the Rust server to create the to-do item with the title in the state</li>
				<li><code>handleTitleChange</code>: This function updates the state every time the input is updated</li>
			</ul>
			<p>Before we explore<a id="_idIndexMarker538"/> these two functions, we will flip around the order<a id="_idIndexMarker539"/> in which we code these functions, and define the return of the <code>render</code> function with the following code:</p>
			<pre class="source-code">
&lt;div className="inputContainer"&gt;
    &lt;input type="text" id="name"
           placeholder="create to do item"
           value={this.state.title}
           onChange={this.handleTitleChange}/&gt;
    &lt;div className="actionButton"
         id="create-button"
         onClick={this.createItem}&gt;Create&lt;/div&gt;
&lt;/div&gt;</pre>
			<p>Here, we can see that the value of the input is <code>this.state.title</code>. Also, when the input changes, we execute the <code>this.handleTitleChange</code> function. Now that we have covered the <code>render</code> function, there is nothing new to introduce. This is a good opportunity for you to look at the outline of our <code>CreateToDoItem</code> component again and try to define the <code>createItem</code> and <code>handleTitleChange</code> functions yourself. They take a similar form to the functions in the <code>ToDoItem</code> component. </p>
			<p>Your attempt to define the <code>createItem</code> and <code>handleTitleChange</code> functions should look similar to the following:</p>
			<pre class="source-code">
createItem = () =&gt; {
    axios.post("http://127.0.0.1:8000/v1/item/create/" +
        this.state.title,
        {},
        {headers: {"token": "some_token"}})
        .then(response =&gt; {
            this.setState({"title": ""});
            this.props.passBackResponse(response);
        });
}
handleTitleChange = (e) =&gt; {
    this.setState({"title": e.target.value});
}    </pre>
			<p>With that, we have defined<a id="_idIndexMarker540"/> both of our custom<a id="_idIndexMarker541"/> components. We are now ready to move on to the next subsection, where we will manage our custom components.  </p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/>Constructing and managing custom components in our App component</h2>
			<p>While it was fun creating<a id="_idIndexMarker542"/> our custom<a id="_idIndexMarker543"/> components, they<a id="_idIndexMarker544"/> are not much use if we do not use them<a id="_idIndexMarker545"/> in our application. In this subsection, we will add some additional code to the <code>src/App.js</code> file to enable our custom components to be used. First, we must import our components with the following code:</p>
			<pre class="source-code">
import ToDoItem from "./components/ToDoItem";
import CreateToDoItem from "./components/CreateToDoItem";</pre>
			<p>Now that we have our<a id="_idIndexMarker546"/> components, we can move<a id="_idIndexMarker547"/> on to our first<a id="_idIndexMarker548"/> alteration. Our <code>App</code> component’s <code>processItemValues</code> function<a id="_idIndexMarker549"/> can be defined with the following code:</p>
			<pre class="source-code">
processItemValues(items) {
  let itemList = [];
  items.forEach((item, _)=&gt;{
      itemList.push(
          &lt;ToDoItem key={item.title + item.status}
                    title={item.title}
                    status={item.status.status}
                    passBackResponse={
                    this.handleReturnedState}/&gt;
      )
  })
  return itemList
}</pre>
			<p>Here, we can see that we loop through the data that we get from the Rust server but instead of passing the data into a generic HTML tag, we pass the parameters of the to-do item data into our own custom component, which is treated like an HTML tag. When it comes to handling our own response with the returned state, we can see that it is an arrow function that processes the data and sets the state with the following code:</p>
			<pre class="source-code">
handleReturnedState = (response) =&gt; {
  let pending_items = response.data["pending_items"]
  let done_items = response.data["done_items"]
  this.setState({
      "pending_items": 
       this.processItemValues(pending_items),
      "done_items": this.processItemValues(done_items),
      "pending_items_count": 
       response.data["pending_item_count"],
      "done_items_count": response.data["done_item_count"]
  })
}</pre>
			<p>This is very similar<a id="_idIndexMarker550"/> to our <code>getItems</code> function. You could<a id="_idIndexMarker551"/> do some refactoring<a id="_idIndexMarker552"/> here if you wanted<a id="_idIndexMarker553"/> to reduce the amount of duplicated code. However, to make this work, we must define the return statement for the <code>render</code> function with the following code:</p>
			<pre class="source-code">
&lt;div className="App"&gt;
    &lt;h1&gt;Pending Items&lt;/h1&gt;
    &lt;p&gt;done item count: 
    {this.state.pending_items_count}&lt;/p&gt;
    {this.state.pending_items}
    &lt;h1&gt;Done Items&lt;/h1&gt;
    &lt;p&gt;done item count: {this.state.done_items_count}&lt;/p&gt;
    {this.state.done_items}
    &lt;CreateToDoItem 
     passBackResponse={this.handleReturnedState} /&gt;
&lt;/div&gt;</pre>
			<p>Here, we can see that there is not much change apart from adding the <code>createItem</code> component. Running our Rust server and our React application will give us the following view:</p>
			<div><div><img src="img/Figure_5.12_B18722.jpg" alt="Figure 5.12 – The view of our React application with custom components"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – The view of our React application with custom components</p>
			<p><em class="italic">Figure 5</em><em class="italic">.12</em> shows that our custom<a id="_idIndexMarker554"/> components<a id="_idIndexMarker555"/> are rendering. We can<a id="_idIndexMarker556"/> click on the buttons<a id="_idIndexMarker557"/> and, as a result, we will see that all our API calls work and our custom components work as they should. Now, all that is standing in our way is making our frontend look presentable, which we can do by lifting our CSS into the React application. </p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Lifting CSS into React</h1>
			<p>We are now on the final stretch<a id="_idIndexMarker558"/> of making our React application usable. We could<a id="_idIndexMarker559"/> split up our CSS into multiple different files. However, we are coming to the end of this chapter, and going over all the CSS again would unnecessarily fill up this chapter with loads of duplicate code. While our HTML and JavaScript are different, the CSS is the same. To get it running, we can copy all the CSS from the following files:</p>
			<ul>
				<li><code>templates/components/header.css</code></li>
				<li><code>css/base.css</code></li>
				<li><code>css/main.css</code></li>
			</ul>
			<p>Copy the CSS files listed here into the <code>front_end/src/App.css</code> file. There is one change to the CSS, and this is where all the <code>.body</code> references should be replaced with <code>.App</code>, as shown in the following code snippet:</p>
			<pre class="source-code">
.App {
  background-color: #92a8d1;
  font-family: Arial, Helvetica, sans-serif;
  height: 100vh;
}
@media(min-width: 501px) and (max-width: 550px) {
  .App {
    padding: 1px;
    display: grid;
    grid-template-columns: 1fr 5fr 1fr;
  }
  .mainContainer {
    grid-column-start: 2;
  }
}
. . .</pre>
			<p>Now, we can import our CSS and use it in our app and components. We will also have to alter the return HTML in the <code>render</code> functions. We can work through all three files. For the <code>src/App.js</code> file, we must import the CSS with the following code:</p>
			<pre class="source-code">
import "./App.css";</pre>
			<p>Then, we must add a header<a id="_idIndexMarker560"/> and define our <code>div</code> tags with the correct classes with the following<a id="_idIndexMarker561"/> code for the return statement from our <code>render</code> function:</p>
			<pre class="source-code">
&lt;div className="App"&gt;
    &lt;div className="mainContainer"&gt;
        &lt;div className="header"&gt;
            &lt;p&gt;complete tasks: 
            {this.state.done_items_count}&lt;/p&gt;
            &lt;p&gt;pending tasks: 
            {this.state.pending_items_count}&lt;/p&gt;
        &lt;/div&gt;
        &lt;h1&gt;Pending Items&lt;/h1&gt;
        {this.state.pending_items}
        &lt;h1&gt;Done Items&lt;/h1&gt;
        {this.state.done_items}
        &lt;CreateToDoItem passBackResponse=
       {this.handleReturnedState}/&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
			<p>In our <code>src/components/ToDoItem.js</code> file, we must import the CSS with the following code:</p>
			<pre class="source-code">
import "../App.css";</pre>
			<p>Then, we must change<a id="_idIndexMarker562"/> our <code>button</code> into a <code>div</code> and define the return statement<a id="_idIndexMarker563"/> for our <code>render</code> function with the following code:</p>
			<pre class="source-code">
&lt;div className="itemContainer"&gt;
    &lt;p&gt;{this.state.title}&lt;/p&gt;
    &lt;div className="actionButton" onClick=
    {this.sendRequest}&gt;
    {this.state.button}&lt;/div&gt;
&lt;/div&gt;</pre>
			<p>In our <code>src/components/CreateToDoItem.js</code> file, we must import the CSS with the following code:</p>
			<pre class="source-code">
import "../App.css";</pre>
			<p>Then, we must change our <code>button</code> into a <code>div</code> and define the return statement for our <code>render</code> function with the following code:</p>
			<pre class="source-code">
&lt;div className="inputContainer"&gt;
    &lt;input type="text" id="name"
           placeholder="create to do item"
           value={this.state.title}
           onChange={this.handleTitleChange}/&gt;
    &lt;div className="actionButton"
         id="create-button"
         onClick={this.createItem}&gt;Create&lt;/div&gt;
&lt;/div&gt;</pre>
			<p>With this, we have lifted our CSS from our Rust web server into our React application. If we run the Rust server and React application, we’ll get the output shown in the following figure:</p>
			<div><div><img src="img/Figure_5.13_B18722.jpg" alt="Figure 5.13 – The view of our React application with CSS added"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – The view of our React application with CSS added</p>
			<p>And there we have it! Our React application is working. Getting our React application up and running takes more time, but we can see that we have more flexibility with React. We can also see that our React application is less error-prone because we are not having to manually manipulate<a id="_idIndexMarker564"/> strings. There is also one more advantage for us to build<a id="_idIndexMarker565"/> in React, and that is the existing infrastructure. In the next and final section, we will convert our React application into a compiled desktop application that runs in the applications of the computer by wrapping our React application in <strong class="bold">Electron</strong>. </p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Converting our React application into a desktop application </h1>
			<p>Converting our React application<a id="_idIndexMarker566"/> into a desktop application<a id="_idIndexMarker567"/> is not complex. We are going to use the Electron framework to do so. Electron is a powerful framework<a id="_idIndexMarker568"/> that converts our JavaScript, HTML, and CSS application into a desktop application that is compiled across platforms for macOS, Linux, and Windows. The Electron framework can also give us access to the computer’s components via an API such as encrypted storage, notifications, power monitor, message ports, processes, shell, system preferences, and much more. Desktop applications such as Slack, Visual Studio Code, Twitch, Microsoft Teams, and many more are built into Electron. To convert our React application, we must start by updating the <code>package.json</code> file. First, we must update our metadata at the top of our <code>package.json</code> file with the following code:</p>
			<pre class="source-code">
{
  "name": "front_end",
  "version": "0.1.0",
  "private": true,
  "homepage": "./",
  "main": "public/electron.js",
  "description": "GUI Desktop Application for a simple To 
                  Do App",
  "author": "Maxwell Flitton",
  "build": {
    "appId": "Packt"
  },
  "dependencies": {
    . . .</pre>
			<p>Most of this is general metadata. However, the <code>main</code> field is essential. This is where we will write our file that defines<a id="_idIndexMarker569"/> how the Electron<a id="_idIndexMarker570"/> application will run. Setting the <code>homepage</code> field to <code>"./"</code> also ensures that the asset paths are relative to the <code>index.html</code> file. Now that our metadata has been defined, we can add the following dependencies:</p>
			<pre class="source-code">
"webpack": "4.28.3",
"cross-env": "^7.0.3",
"electron-is-dev": "^2.0.0"</pre>
			<p>These dependencies help with building<a id="_idIndexMarker571"/> the Electron application. Once they have been added, we can redefine our scripts with the following code:</p>
			<pre class="source-code">
    . . .
"scripts": {
    "react-start": "react-scripts start",
    "react-build": "react-scripts build",
    "react-test": "react-scripts test",
    "react-eject": "react-scripts eject",
    "electron-build": "electron-builder",
    "build": "npm run react-bu<a href="http://localhost:3000">ild &amp;&amp; npm run electr</a>on-
              build",
    "start": "concurrently \"cross-env BROWSER=none npm run 
              react-start\" \"wait-on http://localhost:3000 
              &amp;&amp; electron .\""
},</pre>
			<p>Here, we have prefixed all our React scripts with <code>react</code>. This is to separate the React processes from our Electron processes. If we just want to run our React application in dev mode now, we must run the following command:</p>
			<pre class="console">
npm run react-start</pre>
			<p>We have also defined build commands and dev start commands for Electron. These will not work yet because we have not defined<a id="_idIndexMarker572"/> our Electron<a id="_idIndexMarker573"/> file. At the bottom<a id="_idIndexMarker574"/> of our <code>package.json</code> file, we must define our developer dependencies for building our Electron application:</p>
			<pre class="source-code">
    . . .
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "concurrently": "^7.1.0",
    "electron": "^18.0.1",
    "electron-builder": "^22.14.13",
    "wait-on": "^6.0.1"
  }
}</pre>
			<p>With that, we have defined all that we need in the <code>package.json</code> file. We need to install the new dependencies with the following command:</p>
			<pre class="console">
npm install</pre>
			<p>Now, we can start building our <code>front_end/public/electron.js</code> file so that we can build<a id="_idIndexMarker575"/> our Electron file. This is essentially boilerplate code, and you will probably see this file in other tutorials as this is the minimum to get an application running in Electron. First, we must import what we need with the following code:</p>
			<pre class="source-code">
const { app, BrowserWindow } = require("electron");
const path = require("path");
const isDev = require("electron-is-dev");</pre>
			<p>Then, we must define the function<a id="_idIndexMarker576"/> that creates<a id="_idIndexMarker577"/> our Desktop window with the following code:</p>
			<pre class="source-code">
function createWindow() {
    const mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            nodeIntegration: true,
            enableRemoteModule: true,
            contextIsolation: false,
        },
    });
    mainWindow.loadURL(
        isDev
           ? "http://localhost:3000"
           : `file://${path.join(__dirname, 
                                 "../build/index.html")}`
    );
    if (isDev) {
        mainWindow.webContents.openDevTools();
    }
}</pre>
			<p>Here, we essentially define the width and height of the window. Also, note that <code>nodeIntegration</code> and <code>enableRemoteModule</code> enable the renderer remote process (browser window) to run code on the main process. Then, we start loading the URL in the main window. If the run<a id="_idIndexMarker578"/> is in developer mode, we merely load <code>http://localhost:3000</code> as we have the React application<a id="_idIndexMarker579"/> running on localhost. If we build our application, then the assets and files that we coded get compiled and can be loaded through the <code>../build/index.html</code> file. We also state that if we are running in developer mode, we open the developer tools. We must execute the <code>createWindow</code> function when the window is ready with the following code:   </p>
			<pre class="source-code">
app.whenReady().then(() =&gt; {
    createWindow();
    app.on("activate", function () {
        if (BrowserWindow.getAllWindows().length === 0){
           createWindow(); 
        }
    });
});</pre>
			<p>If the operating system is macOS, we must keep the program running, even if we close the window:</p>
			<pre class="source-code">
app.on("window-all-closed", function () {
    if (process.platform !== "darwin") app.quit();
});</pre>
			<p>Now, we must run the following command:</p>
			<pre class="console">
npm start</pre>
			<p>This runs the Electron<a id="_idIndexMarker580"/> application, giving us the following output:</p>
			<div><div><img src="img/Figure_5.14_B18722.jpg" alt="Figure 5.14 – Our React application running in Electron"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – Our React application running in Electron</p>
			<p>In <em class="italic">Figure 5</em><em class="italic">.13</em>, we can see<a id="_idIndexMarker581"/> that our application<a id="_idIndexMarker582"/> is running in a window<a id="_idIndexMarker583"/> on our desktop. We can also see that our application is accessible with the menu bar at the top of my screen. The application’s logo is showing on my taskbar:</p>
			<div><div><img src="img/Figure_5.15_B18722.jpg" alt="Figure 5.15 – Electron on ﻿my taskbar"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – Electron on my taskbar</p>
			<p>The following command<a id="_idIndexMarker584"/> will compile our application<a id="_idIndexMarker585"/> in the <code>dist</code> folder, which, if clicked, will install the application onto your computer: </p>
			<pre class="console">
npm build</pre>
			<p>The following is an example of this in the applications area on my Mac when I used Electron<a id="_idIndexMarker586"/> to test out a GUI for the open source package I built called Camel for <em class="italic">OasisLMF</em>:</p>
			<div><div><img src="img/Figure_5.16_B18722.jpg" alt="Figure 5.16 – Our Electron app in the applications area"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 – Our Electron app in the applications area</p>
			<p>Eventually, I will come<a id="_idIndexMarker587"/> up with<a id="_idIndexMarker588"/> a logo. However, this<a id="_idIndexMarker589"/> concludes this chapter on displaying content in the browser. </p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, we have finally enabled our application to be used by a casual user as opposed to having to rely on a third-party application such as Postman. We defined our own app views module that housed read file and insert functions. This resulted in us building a process that loaded an HTML file, inserted data from JavaScript and CSS files into the view data, and then served that data.</p>
			<p>This gave us a dynamic view that automatically updated when we edited, deleted, or created a to-do item. We also explored some basics around CSS and JavaScript to make API calls from the frontend and dynamically edit the HTML of certain sections of our view. We also managed the styling of the whole view based on the size of the window. Note that we did not rely on external crates. This is because we want to be able to understand how we can process our HTML data.</p>
			<p>Then, we rebuilt the frontend in React. While this took longer and there were more moving parts, the code was more scalable and safer since we didn’t have to manually manipulate strings to write HTML components. We can also see why we leaned into React as it fits nicely into Electron, giving us another way of delivering our application to our users. </p>
			<p>While our app now works at face value, it is not scalable in terms of data storage. We do not have data filter processes. There are no checks on the data that we store, and we do not have multiple tables. </p>
			<p>In the next chapter, we will build data models that interact with a <strong class="bold">PostgreSQL</strong> database that runs locally in Docker. </p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor123"/>Questions</h1>
			<ol>
				<li value="1">What is the simplest way to return HTML data to the user’s browser?</li>
				<li>What is the simplest (not scalable) way to return HTML, CSS, and JavaScript data to the user’s browser?</li>
				<li>How do we ensure that the background color and style standard of certain elements is consistent across all views of the app?</li>
				<li>How do we update the HTML after an API call?</li>
				<li>How do we enable a button to connect to our backend API?</li>
			</ol>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor124"/>Answers</h1>
			<ol>
				<li value="1">We can serve HTML data by merely defining a string of HTML and putting it in the body of an <code>HttpResponse</code> struct while defining the content type as HTML. The <code>HttpResponse</code> struct is then returned to the user’s browser.</li>
				<li>The simplest way is to hardcode a full HTML string with the CSS hardcoded in the <code>&lt;style&gt;</code> section, and our JavaScript hardcoded in the <code>&lt;script&gt;</code> section. This string is then put in the body of an <code>HttpResponse</code> struct and returned to the user’s browser.</li>
				<li>We make a CSS file that defines the components that we want to be consistent throughout the app. Then, we put a tag in the <code>&lt;style&gt;</code> section of all our HTML files. Then, with each file, we load the base CSS file and replace the tag with the CSS data. </li>
				<li>After the API call, we must wait for the status to be ready. Then, we get the HTML section we want to update using <code>getElementById</code>, serialize the response data, and then set the inner HTML of the element as the response data.</li>
				<li>We give the button a unique ID. Then, we add an event listener, which is defined by the unique ID. In this event listener, we bind it to a function that gets the ID using <code>this</code>. In this function, we make an API call to the backend and then use the response to update the HTML of other parts of our view that display the data.</li>
			</ol>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/>Further reading </h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li><em class="italic">React and React Native: A complete hands-on guide to modern web and mobile development with React.js</em>, by Adam Boduch and Roy Derks, Packt Publishing</li>
				<li><em class="italic">Mastering React Test-Driven Development: Build rock-solid, well-tested web apps with React, Redux, and GraphQL</em>, by Daniel Irvine, Packt Publishing</li>
				<li><em class="italic">Responsive Web De</em><a href="https://www.electronjs.org/"><em class="italic">sign with HTML5 and CSS: De</em></a><em class="italic">velop future-proof responsive websites using the latest HTML5 and CSS techniques</em>, by Ben Frain, Packt Publishing</li>
				<li>Electron documentation: <a href="https://www.electronjs.org/">https://www.electronjs.org/</a></li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-125"><a id="_idTextAnchor126"/>Part 3:Data Persistence</h1>
			<p>Now that our application handles HTTP requests and displays the content in the browser, we need to store and process data properly. In this part, you will learn how to manage databases locally in development with Docker and how to perform database migrations with SQL scripts. You will also learn how to map the database schema to the Rust application, querying and updating the database from Rust. After this part, you will be able to manage database connection pools, data models, and migrations; log in and authenticate requests with middleware; and cache data in the frontend, exploring RESTful concepts. </p>
			<p>This part includes the following chapters:</p>
			<ul>
				<li><a href="B18722_06.xhtml#_idTextAnchor127"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Persistence with PostgreSQL</em></li>
				<li><a href="B18722_07.xhtml#_idTextAnchor149"><em class="italic">Chapter 7</em></a>, <em class="italic">Managing User Sessions</em></li>
				<li><a href="B18722_08.xhtml#_idTextAnchor168"><em class="italic">Chapter 8</em></a>, <em class="italic">Building RESTful Services</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>