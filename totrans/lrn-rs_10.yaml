- en: Creating Your Own Crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most languages allow for external libraries to be created. These typically contain
    commonly used pieces of code that are for general use. For example, libraries
    for deserializing JSON are fairly common, as are math libraries. Rust is no exception.
    It allows for the creation of libraries (known as **crates**). These crates can
    be kept to yourself or distributed however you see fit. The metadata about crates
    is stored on a public service, at [https://crates.io/](https://crates.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How crates are created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the directory structure is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How crates are made up of modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to include your crate within your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How scopes are used with your modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What exactly is a crate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with all languages, Rust can use external libraries that, we've established
    are called crates. But what are they?
  prefs: []
  type: TYPE_NORMAL
- en: If we think about a crate, we think either of something we use to hold lots
    of other things. Software developers like to keep their code clean and if they
    know what they're doing, they tend to keep their libraries fairly specialized.
    These specialisms within a crate are known as modules.
  prefs: []
  type: TYPE_NORMAL
- en: A crate is a container with one or more modules within it.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show how crates are put together, we are going to create one. In this case,
    it will be a simple math crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we consider this, let''s consider something we all know: a car. We will
    consider the car a crate, as everything to do with the car is held within it.'
  prefs: []
  type: TYPE_NORMAL
- en: To start, let's think about the main parts of the car: the engine, fuel, interior, wheels
    and movement, and electrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more but, for now, we will ignore them. Let''s represent this as
    a block diagram to make the relationship clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can, of course, split up each of these blocks (for example, we can split
    the electrics into ignition, audio, windows, heated windscreens, lights, and interior
    fan).
  prefs: []
  type: TYPE_NORMAL
- en: The car is the crate. Each block is a module. Each split is a submodule. It's
    now quite simple to see how crates can be visualized.
  prefs: []
  type: TYPE_NORMAL
- en: I can see a problem with this analogy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a reason I chose a car. If we think about it, all of the parts aren't
    really that discrete; the engine requires fuel, the electrics are needed by the
    engine, but the engine also generates electricity, and so on. In terms of programming,
    this will lead to a horrid mess.
  prefs: []
  type: TYPE_NORMAL
- en: How can we keep them apart?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we use a scope for each. For example, the top level for this
    crate would be **Car**. We then add **::** followed by the module name (**Car::Engine**,
    **Car::Fuel**, and so on.). If a module requires access to another module, it
    can be included using the usual `use` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the crate is the name used when the library is created using cargo.
    In this example, the command line to create this crate will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cargo new Car**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do not use the `--bin` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we break the modules down further, we extend the scope in the same way as
    we did previously in order to access them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Back to our math library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how crates and modules go together and how their scope allows
    for the modules to not become confused if they function with the same name (`Car::Engine`
    and `Car::Electics` can both have a function called `voltage_to_earth`, for example,
    each does a different action), let's consider our math library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library will have four modules with a number of submodules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Trigonometry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sin/Cos/Tan
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Arcsin, Arccos, and Arctan
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regression analysis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercept on a straight line
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard deviation and r² value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature, pressure, and volume
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Base functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base *n* to base 10 conversions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Base 10 to base *n* conversions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Base *m* to base *n* addition, subtraction, multiplication, and division
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a useful name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Naming within a module is very important; it is going to be visible to anyone
    using it and should therefore describe what it does. The same applies to function
    names. For example, *f_to_c* is fine, but the whole point of a library is that
    you can get what you are after without having to second-guess what the author
    meant. A function name such as *fahrenheit_to_celcius* makes much more sense.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to modules. If I were to use *ra* for regression analysis,
    it might seem like a reasonable name to use, but is it clear? The name can mean
    anything here. It may seem like a lot of effort to create a module called *regression_analysis*,
    but it will help other users know what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start, we need to create the crate itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, instead of writing the following, we need to tell cargo that we
    are creating a library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, we simply omit the `-bin` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows this, followed by the tree structure for the
    module. You''ll notice that `main.rs` has been replaced by `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: Creating top-level modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a module, we first need to tell the compiler that the code is held
    in a module. In this example, I will use the `Trigonometry` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile this using `cargo build` (not `cargo run`; there is no `main`
    function within the library) and examine the tree, we''ll see the library (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: The structure for this section can be found in `Chapter10/MathsLibStucture`.
  prefs: []
  type: TYPE_NORMAL
- en: We can't do very much with it currently as all it contains are placeholders
    that do very little. Before this goes any further, have a look at the `lib.rs`
    source file. With nothing in except for the module names, it hits 62 lines. Let's
    think of a very simple example for the `Conversion` module, *fahrenheit_to_celcius*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula to do this is *(F - 32) * 5/9*. Our function will therefore be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That was just four lines of code. We also need ones to go from C to F, K to
    C, C to K, F to K, and K to F (K is Kelvin, which denotes absolute temperature,
    that is, 0K = -273.15^oC , also known as absolute zero). Including these will
    take it to a total of around 24 lines of code. This is a simple module. The ones
    for regression analysis run to around 100.
  prefs: []
  type: TYPE_NORMAL
- en: Our source file is going to be huge. As we want to keep our modules manageable,
    we are going to need to break the `lib.rs` file down a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The multifile module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to break our current `lib.rs` file down, we are going to have to change
    how we declare modules.
  prefs: []
  type: TYPE_NORMAL
- en: The source for this section is in `Chapter10/MathsLibMultiFile and Chapter10/MathsLibMultiFileDirs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To break this into separate files, we need to declare only the top-level modules
    in `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What about submodules?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare top-level modules like this, Rust will expect there to be either
    a directory for each of these modules or four source files (`Trigonometry.rs`,
    `RegressionAnalysis.rs`, `Conversions.rs`, and `Bases.rs`). If the directory structure
    is used, Rust will expect a file called `mod.rs` in each directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare how these two systems look, and then we can examine the relative
    benefits of each. The structure of `MathsLibMultiFile` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3a
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of `MathsLibMultiFileDirs` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3b
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, they seem to be very similar; the only difference is that multifiledir
    (*Fig 3b*) has modules broken down into separate files whereas multifile (*Fig
    3a*) only has a single file for each module. This is a limitation of the non-directory
    structure; the submodules are kept in a single file, which is fine for a very
    small module but no good for larger modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the directory structure version, there is a `mod.rs` file. This is completely
    empty but is there to let the compiler know that we have submodules. If (say)
    `RegressionAnalysis::Statistics` were to be further broken down, it would be a
    case of creating a new directory within the `RegressionAnalysis` directory called
    `Statistics` (the directory must have the same name as the module) and adding
    a new `mod.rs` file as well as new submodules.
  prefs: []
  type: TYPE_NORMAL
- en: The mod.rs file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file should include an interface to the module itself. The name of the
    module will point to a file with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line will point to `mycode.rs`. You will need to include an interface
    to each file in that module directory (with the exception of `mod.rs`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have the structure in place and our basic framework; we can start adding
    some code to the library. In this case, it will be the `Conversions::Temperature`
    part. We have already seen the function for Fahrenheit to Celcius, so let''s add
    the other functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing earth-shattering about this code, but we do have to stop for
    a second to think about this. The Kelvin scale goes from 0 to *n*; it never goes
    below zero. It's entirely possible for the user to want to use `celcius_to_kelvin`
    and pass -274 instead. This would mean that the answer from the function would
    be mathematically correct but physically incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is in `Chapter10/MathsLib`.
  prefs: []
  type: TYPE_NORMAL
- en: We could return `-1` but then, for some of the functions, that answer is fine.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to return here is a tuple with the first parameter being a Boolean,
    signifying whether the calculation is valid or not (`true` = valid). If it's `true`,
    the answer is in the second parameter; otherwise, pass back the original value
    passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick test, the following code can be run:'
  prefs: []
  type: TYPE_NORMAL
- en: See `Chapter10/QuickTest` for the source.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is convenient here to use the indexed form of the tuple rather than destructuring
    it into two variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiled, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what was expected. It does also show a need for a set of unit
    tests to be added into the library to determine the validity (or not) of the data
    being fed in.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of double name scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is quite a common problem to create a crate that may run into an issue known
    as double name scope. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing the preceding line instead of the following line causes a major problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The problem is down to the mod.rs and the temperature file.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at `lib.rs`, it has in it the name of the module that has to marry
    up with the name of the directory, which, in turn, contains the `mod.rs` file.
    The `mod.rs` file (as we have seen) needs to contain a public interface to the
    module. Now, following this logic, the code in the `temperature.rs` file should
    also have `pub mod temperature { ... }`. It is this final `pub mod` that gives
    the double name scope.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, just leave the `pub mod temperature` line out. As long
    as the filename matches the `pub mod` name in `mod.rs`, the compiler will consider
    that code as belonging to the named mod from `mod.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding unit tests to the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create tests in one of the two ways: either by adding a `tests` directory
    with a `lib.rs` file or by simply adding a file with the tests for that module.
    As we are already using a directory structure, let''s stay with that for the unit
    tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously discussed in [Chapter 1](part0021.html#K0RQ0-a5175cb437d742a9aed0ea574000ee2d),
    *Introducing and Installing Rust*, to add a unit test, we precede the code with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to build, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do this, though, we hit a problem. Our unit test file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'On the face of it, this should work, but it comes back with something that
    is somewhat perplexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't make sense; we know there is a module called `Temperature`, so
    why are we getting this message? The answer is that it's all down to the privacy
    of the module and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Making something public
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in [Chapter 7](part0143.html#48C0E0-a5175cb437d742a9aed0ea574000ee2d),
    *Matching and Structures*, how Rust, by default, sets all the functions, `structs`,
    and so on to be private. This is fine, as it prevents some of the nuts and bolts
    of the code from being exposed to the public interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does mean, though, that we have to explicitly set the module, and all
    of the functions we want the user to have access to, to be `pub` (public). Therefore,
    our functions for the temperature conversion will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next time we come to run the unit tests, we should not have this issue,
    except for the following snag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6
  prefs: []
  type: TYPE_NORMAL
- en: 'We have definitely got a `pub` function in the `Temperature` module called
    `kelvin_to_celcius`. The issue is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'What this does is import only the module and none of the symbols (the functions).
    We can fix this in one of the following four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use mathslib::conversions::temperature;` then precede `kelvin_to_celcius`
    with `temperature::`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We remove the `use mathslib` line and add the following line inside `mod temperature_tests`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using any of these should allow the tests to compile and run. The output you
    will see should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 7: chap10_unittest'
  prefs: []
  type: TYPE_NORMAL
- en: Let's give our crate a quick run out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it stands, our crate is far from finished. However, there is enough code
    in there to see whether it actually runs.
  prefs: []
  type: TYPE_NORMAL
- en: Code for this section is in `Chapter10/first_run_out`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our initial code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7
  prefs: []
  type: TYPE_NORMAL
- en: This stands to reason; we're asking the code to include a library that it has
    no clue about.
  prefs: []
  type: TYPE_NORMAL
- en: External dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, if a dependency is outside the application, we would add something
    like this to the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're not able to use cargo to make the build; instead, we need
    to compile using `rustc`. The way cargo works is it recompiles the dependencies
    for each project (there is no guarantee that each project will use the same set
    of features for a given crate).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simulate a cargo run with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `-L` links any libraries in `.` (the root directory, where you find `Cargo.toml`)
    to the sources after the `.` . The `/main` part essentially tells the command-line
    interpreter to execute the binary called `./main` in the root directory (the name
    comes from the file compiled).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have executed this, we can see our application in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8
  prefs: []
  type: TYPE_NORMAL
- en: We now know that our crate (as-is) is running as it should do.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more interesting features that we can perform with our scope names
    is to change them. We can also customize which modules to include on our use lines.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the crate name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, when we import a crate, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to avoid confusion with something in your code, you may want to refer
    to the crate with a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It looks very similar to casting, which is because it casts the name `my_crate`
    to be `crate_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we now refer to the crate we don''t use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We rather use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing your use statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the very few things Java has done correctly is the degree of granularity
    in the way it imports libraries; it pushes the developer to only include the parts
    of the library actually required by the application. This is down to the history
    of Java, but it's something that should be encouraged. Rust does something similar.
  prefs: []
  type: TYPE_NORMAL
- en: The `use` statement can take a number of different styles.
  prefs: []
  type: TYPE_NORMAL
- en: The use-everything approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is often referred to as the sledgehammer approach, as it makes available
    all the symbols (the functions, traits, and so on that are public) within the
    `module_name` scope. There is nothing wrong with this approach, but it ends up
    with a larger binary (which may slow down the final application and will certainly
    require more memory to run the code).
  prefs: []
  type: TYPE_NORMAL
- en: The you-decide approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the very minimum required to use the `module_name` scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you are telling the compiler that `module_name` exists and that, as long
    as the function name exists in the symbols, it can be used. However, in order
    to use `module_name`, the function will need to be preceded by `module_name`.
    For example, to use the `print_me(f32)` function, which exists in `module_name`,
    you will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `module_name::` has to be added to tell the compiler to use the `module_name`
    scope rather than the current scope of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The use-me approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we tell the compiler that we are only allowing the current scope to use
    a specific function from within the `module_name` scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The use-me-but-call-me-something-else approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is very similar to referring to the crate by another name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't mean what you probably think it means. With the crate example,
    we said that we are going to use `my_crate`, which is the cast of `crate_name`.
    In this case, what we're saying is that `mod_name` is a cast of `my_crate::module_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following after the preceding line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do so, we now use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks the same, but really it means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The use-glob approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This approach is similar to the use-me approach, with the exception of using
    `{}` around what we want the code to have access to (known as a **glob**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The line means that the code can access `module_name::print_me` and `module_name::calculate_time`
    but nothing else from the `module_name` scope.
  prefs: []
  type: TYPE_NORMAL
- en: The use-glob-self approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, the first parameter of the glob is `self`. In this context, `self` refers
    back to the root context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In an expanded form, this will equate to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter and saw that, for most of the time,
    cargo makes building a Rust application simple. When testing your own crates outside
    the project it was originally created in, we need to use `rustc` in order to compile.
    We saw how to create our own libraries, how to add unit tests, how to effectively
    utilize the use statement, and how to call crates and scopes by different names.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will be looking at how we can really make use of Rust's
    in-built memory protection system to fully utilize concurrency and parallelism.
  prefs: []
  type: TYPE_NORMAL
