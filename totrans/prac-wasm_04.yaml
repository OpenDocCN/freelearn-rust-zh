- en: '*Chapter 3*:Exploring WebAssembly Modules'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：探索WebAssembly模块'
- en: WebAssembly is a low-level assembly-like code that is designed for efficient
    execution and compact representation. WebAssembly runs at a near-native speed
    in all JavaScript engines (including modern desktop and mobile browsers and Node.js).
    Compact representation of the binary enables the generated binary to be as small
    as possible in size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是一种低级类似汇编的代码，旨在高效执行和紧凑表示。WebAssembly在所有JavaScript引擎中（包括现代桌面和移动浏览器以及Node.js）以接近原生速度运行。二进制的紧凑表示使得生成的二进制文件尽可能小。
- en: Note
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The main goal of WebAssembly is to enable high-performance applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的主要目标是实现高性能应用程序。
- en: Each WebAssembly file is an efficient, optimal, and self-sufficient module called
    a **WebAssembly module** (**WASM**). WASM is safe, that is, the binary runs in
    a memory-safe and sandboxed environment. WASM does not have permission to access
    anything outside of that sandbox. WASM is language-, hardware-, and platform-independent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个WebAssembly文件都是一个高效、最优且自给自足的模块，称为**WebAssembly模块**（**WASM**）。WASM是安全的，也就是说，二进制在内存安全和沙箱环境中运行。WASM没有权限访问沙箱之外的任何内容。WASM是语言、硬件和平台无关的。
- en: 'WebAssembly is a virtual **instruction set architecture** (**ISA**). The WebAssembly
    specifications define the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是一个虚拟的**指令集架构**（**ISA**）。WebAssembly规范定义了以下内容：
- en: Instruction set
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令集
- en: Binary encoding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制编码
- en: Validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Execution semantics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行语义
- en: The WebAssembly specification also defines a textual representation of the WebAssembly
    binary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly规范还定义了WebAssembly二进制的文本表示。
- en: 'In this chapter, we will explore WASM and how a JavaScript engine executes
    WASM. We then explore the WebAssembly text format and why it is useful. Understanding
    WASM execution and the WebAssembly text format will enable us to easily understand
    the module and debug it in the JavaScript engine. We will cover the following
    main topics in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索WASM以及JavaScript引擎如何执行WASM。然后我们将探索WebAssembly文本格式及其用途。理解WASM执行和WebAssembly文本格式将使我们能够轻松理解模块并在JavaScript引擎中调试它。本章将涵盖以下主要主题：
- en: Understanding how WebAssembly works
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解WebAssembly的工作原理
- en: Exploring the WebAssembly text format
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索WebAssembly文本格式
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中包含的代码文件，网址为[https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)。
- en: Understanding how WebAssembly works
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解WebAssembly的工作原理
- en: Let's first explore how JavaScript and WebAssembly are executed inside the JavaScript
    engine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探索JavaScript和WebAssembly如何在JavaScript引擎中执行。
- en: Understanding JavaScript execution inside the JavaScript engine
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JavaScript在JavaScript引擎中的执行
- en: The JavaScript engine first fetches the complete JavaScript file (note that
    the engine has to wait until the entire file is downloaded/loaded).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎首先获取完整的JavaScript文件（请注意，引擎必须等待整个文件下载/加载完成）。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The bigger the JavaScript file, the longer it takes to load. It doesn't matter
    how fast your JavaScript engine is or how efficient your code is. If your JavaScript
    file is huge (that is, greater than 170 KB), then your application is going to
    be slow at loading time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript文件越大，加载所需的时间就越长。无论你的JavaScript引擎有多快，或者你的代码有多高效，都没有关系。如果你的JavaScript文件非常大（即，大于170
    KB），那么你的应用程序在加载时将会很慢。
- en: '![Figure 3.1 – JavaScript execution inside the JavaScript engine'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – JavaScript在JavaScript引擎中的执行'
- en: '](img/Figure_3.1_B14844.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B14844.jpg)'
- en: Figure 3.1 – JavaScript execution inside the JavaScript engine
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – JavaScript在JavaScript引擎中的执行
- en: Once loaded, the JavaScript is parsed into **abstract syntax trees** (**ASTs**).
    This phase is called **parse**. Since JavaScript is both an interpreted and compiled
    language, the JavaScript engine kickstarts the execution after parsing. The interpreter
    executes the code faster but it compiles the code every time. This phase is called
    **interpret**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，JavaScript就会被解析成**抽象语法树**（**ASTs**）。这个阶段称为**解析**。由于JavaScript既是解释型语言又是编译型语言，JavaScript引擎在解析后启动执行。解释器执行代码更快，但每次都会编译代码。这个阶段称为**解释**。
- en: The JavaScript engine has **watchers** (called **profilers** in some browsers).
    Watchers keep track of code execution. If a particular block of code is executed
    frequently, then the watcher marks it as hot code. The engine compiles the block
    of code using the **just-in-time** (**JIT**) compiler. The engine spends some
    time doing the compilation, say in the order of nanoseconds. The time spent here
    is worth it, because the next time the function is called, the execution happens
    much faster, because the compiled version is always faster than the interpreted
    one. This phase is called **optimize**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎有 **监视器**（在一些浏览器中称为 **分析器**）。监视器跟踪代码执行。如果一个特定的代码块经常执行，那么监视器将其标记为热代码。引擎使用
    **即时编译**（**JIT**）编译这个代码块。引擎花费一些时间进行编译，比如说在纳秒级别。这里花费的时间是值得的，因为下次函数被调用时，执行会更快，因为编译版本总是比解释版本快。这个阶段被称为
    **优化**。
- en: JavaScript engines add one (or two) more layers of optimization. The watchers
    continue watching the code execution. The watchers then name the code that is
    called more often *very hot code*. The engine optimizes this code further. This
    optimization takes a long time (consider something like `-O3`-level optimization).
    This phase produces highly optimized code that runs super fast. This code is much
    faster than the previously optimized code and the interpreted version. Obviously,
    the engine spends more time during this phase, say in the order of milliseconds.
    This is compensated by the code performance and frequency of execution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 引擎添加一个（或两个）更多的优化层。监视器继续监视代码执行。然后，监视器将调用频率更高的代码命名为 *非常热代码*。引擎进一步优化此代码。这种优化需要很长时间（考虑类似于
    `-O3` 级别的优化）。这个阶段产生高度优化的代码，运行速度极快。此代码比之前优化的代码和解释版本快得多。显然，引擎在这个阶段花费更多的时间，比如说在毫秒级别。这是通过代码性能和执行频率来补偿的。
- en: JavaScript is a dynamically typed language and all the optimizations the engine
    can do are based on the assumption of *types*. If the assumption breaks, then
    the code is interpreted and executed, and the optimized code gets removed rather
    than throwing a runtime exception. The JavaScript engine implements the necessary
    type checks and bails out the optimized code when the assumed type changes. But
    the time spent on the optimize phase is in vain.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态类型语言，引擎能做的所有优化都是基于 *类型* 的假设。如果假设被打破，那么代码将被解释并执行，优化的代码将被移除而不是抛出运行时异常。JavaScript
    引擎实现了必要的类型检查，并在假设的类型发生变化时退出优化的代码。但是，在优化阶段花费的时间是徒劳的。
- en: We can prevent these *type*-related issues by using something such as **TypeScript**.
    TypeScript is a superset of JavaScript. With TypeScript, we can prevent polymorphic
    code (code that accepts different types). In the JavaScript engine, monomorphic
    code (code that accepts only one type) always runs faster than its polymorphic
    counterpart.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用诸如 **TypeScript** 这样的工具来防止这些 *类型* 相关的问题。TypeScript 是 JavaScript 的超集。使用
    TypeScript，我们可以防止多态代码（接受不同类型的代码）。在 JavaScript 引擎中，单态代码（只接受一种类型的代码）总是比其多态对应物运行得更快。
- en: There is no use in having highly optimized monomorphic JavaScript code if the
    JavaScript files are huge in size. The JavaScript engine has to wait until the
    entire file is downloaded. With a poor connection, that takes forever to happen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JavaScript 文件很大，那么拥有高度优化的单态 JavaScript 代码是没有用的。JavaScript 引擎必须等待整个文件下载完成。在糟糕的连接下，这需要很长时间才能完成。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to split the JavaScript bundle into smaller chunks. Including
    the JavaScript asynchronously (or in other words, lazy loading) boosts the performance
    of your application. We need to strike a correct balance and know which JavaScript
    module/file to load, cache, and then revalidate. Larger file sizes (payloads)
    will degrade the performance of the application greatly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JavaScript 包拆分成更小的块非常重要。异步包含 JavaScript（换句话说，懒加载）可以提高应用程序的性能。我们需要找到一个正确的平衡点，并知道要加载、缓存和重新验证哪个
    JavaScript 模块/文件。更大的文件大小（负载）将大大降低应用程序的性能。
- en: The final step is **garbage collection**, where all the live objects in the
    memory are removed. The garbage collection in the JavaScript engine works on the
    basis of reference. During the garbage collection cycle, the JavaScript engine
    starts from the root object (something like global in Node.js). It finds all the
    objects referenced from the root object and marks them as reachable objects. It
    marks the remaining objects as unreachable objects. Finally, it sweeps the unreachable
    objects. Since it is automatically done by the JavaScript engine, the garbage
    collection process is not efficient and it is much slower.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是**垃圾回收**，其中移除内存中所有活动的对象。JavaScript引擎中的垃圾回收基于引用。在垃圾回收周期中，JavaScript引擎从根对象（类似于Node.js中的全局对象）开始。它找到所有从根对象引用的对象，并将它们标记为可达对象。它将剩余的对象标记为不可达对象。最后，它清除不可达对象。由于这是由JavaScript引擎自动完成的，因此垃圾回收过程效率不高，速度较慢。
- en: Understanding WebAssembly execution inside the JavaScript engine
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JavaScript引擎中的WebAssembly执行
- en: WASM is in binary format and is already compiled and optimized. The JavaScript
    engine fetches the WASM. Then, it decodes the WASM and converts it into the module's
    internal representation (that is, AST). This phase is called **decode**. The decode
    phase is much faster than JavaScript's **parse** phase.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: WASM是二进制格式，并且已经编译和优化。JavaScript引擎获取WASM。然后，它解码WASM并将其转换为模块的内部表示（即AST）。这个阶段称为**解码**。解码阶段比JavaScript的**解析**阶段快得多。
- en: '![Figure 3.2 – WebAssembly execution inside the JavaScript engine'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.2 – WebAssembly execution inside the JavaScript engine]'
- en: '](img/Figure_3.2_B14844.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.2_B14844.jpg]'
- en: Figure 3.2 – WebAssembly execution inside the JavaScript engine
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.2 – WebAssembly execution inside the JavaScript engine
- en: Next, the decoded WASM enters the **compile** phase. During this phase, the
    module is validated, and during the validation, the code is checked for certain
    conditions to guarantee the module is safe and does not have any harmful code.
    The functions, instruction sequences, and the usage of stacks are type-checked
    during the validation process. The validated code is then compiled to machine-executable
    code. Since the WASM is already compiled and optimized, this compile phase is
    faster. During this phase, the WASM is converted into machine code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，解码后的WASM进入**编译**阶段。在这个阶段，模块被验证，在验证过程中，代码会检查某些条件以确保模块是安全的，并且没有有害的代码。在验证过程中，函数、指令序列和堆栈的使用都会进行类型检查。验证后的代码随后被编译成机器可执行代码。由于WASM已经编译和优化，这个编译阶段更快。在这个阶段，WASM被转换成机器代码。
- en: The compiled code then enters the **execute** phase. In the execute phase, the
    module is instantiated and invoked. During the instantiation, the engine instantiates
    the state and the execution stack (memory where it stores all the information
    related to the program) and then executes the module.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的代码随后进入**执行**阶段。在执行阶段，模块被实例化和调用。在实例化过程中，引擎实例化了状态和执行栈（存储所有与程序相关的信息的内存），然后执行模块。
- en: The other advantage of WebAssembly is that the module is ready to compile and
    instantiate right from the first byte. Thus, the JavaScript engine need not wait
    until the entire module is downloaded. This further increases WebAssembly's performance.
    WebAssembly is fast because its execution has fewer steps than JavaScript execution,
    so the binary is already optimized and compiled, and the binary can be streaming
    compiled.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的另一个优点是模块从第一字节开始就可以准备编译和实例化。因此，JavaScript引擎无需等待整个模块下载完成。这进一步提高了WebAssembly的性能。WebAssembly之所以快速，是因为它的执行步骤比JavaScript执行步骤少，所以二进制文件已经优化和编译，并且可以流式编译。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: WASM does not always provide high performance. There are scenarios in which
    JavaScript performs better. So, it is necessary to understand that and think before
    using WebAssembly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: WASM并不总是提供高性能。在某些场景中，JavaScript的表现更好。因此，有必要理解这一点，并在使用WebAssembly之前进行思考。
- en: Find out more about JavaScript performance and how load time is involved at
    [https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4)了解更多关于JavaScript性能和加载时间如何涉及的信息。
- en: Find out more about chunking and code splitting in webpack at [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/)了解更多关于webpack中的代码拆分和分块的信息。
- en: We have seen how WebAssembly works inside the browser; now, let's explore the
    WebAssembly text format.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 WebAssembly 在浏览器中的工作方式；现在，让我们探索 WebAssembly 文本格式。
- en: Exploring the WebAssembly text format
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 WebAssembly 文本格式
- en: Machines understand a bunch of 1s and 0s. We optimize the binary to make it
    run faster and more efficiently. The more concise and optimal the instructions
    are, the more efficient and performant the machine will be. But for people, it
    is difficult to contextually analyze and understand a huge blob of 1s and 0s.
    That is the very reason why we started abstracting and creating high-level programming
    languages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 机器理解一串 1 和 0。我们优化二进制以使其运行更快、更高效。指令越简洁、越优化，机器将越高效、性能越好。但对于人类来说，很难在上下文中分析和理解一大堆
    1 和 0。这正是我们开始抽象和创建高级编程语言的原因。
- en: In the WebAssembly world, we convert human-readable programming languages, such
    as Rust, Go, and C/C++, into binary code. These binaries are a bunch of instructions
    with opcodes and operands. These instructions make the machine highly efficient
    but contextually make it difficult for us to understand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 世界中，我们将可读性编程语言，如 Rust、Go 和 C/C++，转换为二进制代码。这些二进制是一系列带有操作码和操作数的指令。这些指令使机器运行得非常高效，但在上下文中也使得我们难以理解。
- en: Why should we worry about the readability of the binary generated? Because it
    helps us to understand the code, which helps while debugging the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要担心生成的二进制的可读性？因为它有助于我们理解代码，这在调试代码时很有帮助。
- en: WebAssembly provides the WebAssembly text format, WAST or WAT. WAST is a human-readable
    format of the WebAssembly binary. The JavaScript engine (both in the browser and
    Node.js), when loading the WebAssembly file, can convert the binary into WebAssembly
    text format. This helps in understanding what is in the code and debugging. Text
    editors can show the binary in WebAssembly text format, which is much more readable
    than its binary counterpart.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 提供了 WebAssembly 文本格式，WAST 或 WAT。WAST 是 WebAssembly 二进制的可读格式。JavaScript
    引擎（无论是在浏览器中还是在 Node.js 中），在加载 WebAssembly 文件时，可以将二进制转换为 WebAssembly 文本格式。这有助于理解代码内容并进行调试。文本编辑器可以以
    WebAssembly 文本格式显示二进制，这比其二进制对应物更易读。
- en: 'Basic WASM in binary format is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式的基本 WASM 如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This translates to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于以下内容：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This basic module has a magic header (`\0asm`) followed by the version of WebAssembly
    (`01`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本模块有一个魔法头（`\0asm`），后面跟着 WebAssembly 的版本（`01`）。
- en: The textual format is written in an `()`. S-expressions are commonly used when
    defining a nested list or structured tree. Many research papers on tree-based
    data structures use this notation to showcase their code. The s-expression removes
    all the unnecessary ceremony from XML, providing a concise format.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文本格式是用 `()` 写的。S-表达式在定义嵌套列表或结构化树时常用。许多关于基于树的数据结构的研究论文使用这种符号来展示他们的代码。s-表达式从 XML
    中移除了所有不必要的仪式，提供了一个简洁的格式。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Does this expression (defining everything within parentheses) look familiar?
    Have you ever worked with LISP (or the languages that are built inspired by LISP)?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式（定义括号内的所有内容）看起来熟悉吗？你曾经使用过 LISP（或受 LISP 启发的语言）吗？
- en: 'Modules are the basic building blocks in WASM. A textual representation of
    basic WASM is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是 WASM 的基本构建块。基本 WASM 的文本表示如下：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'WASM is made up of a header and zero or more sections. The header starts with
    a magic header and the version of WASM. Following the header, the WASM may have
    zero or more of the following sections:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 由一个头和零个或多个部分组成。头以一个魔法头和 WASM 的版本开始。在头之后，WASM 可能包含零个或多个以下部分：
- en: Types
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Functions
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Tables
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表
- en: Memories
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Globals
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量
- en: Element
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素
- en: Data
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Start function
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始函数
- en: Exports
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出
- en: Imports
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入
- en: 'All these sections are optional in WASM. The structure of WASM looks as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些部分在 WASM 中都是可选的。WASM 的结构如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every section inside the WASM is a vector (array) that contains zero or more
    values of the respective types, except for `start`. We will explore the `start`
    section later in the book. For now, `start` holds an index that references a function
    in the `funcs` section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 内部的每个部分都是一个包含零个或多个相应类型值的向量（数组），除了 `start`。我们将在本书的后面部分探讨 `start` 部分。目前，`start`
    保存一个索引，该索引引用 `funcs` 部分中的一个函数。
- en: 'Every section in the WASM takes the following format:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: WASM 中的每个部分都采用以下格式：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first byte refers to a unique section ID. Every section has a unique section
    ID. Next to the unique section ID is an **unsigned 32-bit** (**u32**) integer
    that defines the section's size in bytes. The remaining bytes are the section
    content.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字节指的是一个唯一的节 ID。每个节都有一个唯一的节 ID。紧随唯一节 ID 的是定义节大小的 **无符号 32 位**（**u32**）整数。剩余的字节是节内容。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since the section size is defined by a u32 integer, the maximum size of the
    section is limited to approximately 4.2 GB of memory (that is, 2^32 - 1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节大小由 u32 整数定义，因此节的最大大小限制在大约 4.2 GB 的内存（即 2^32 - 1）内。
- en: In the WebAssembly text format, we use the name of the section to represent
    each segment in the section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebAssembly 文本格式中，我们使用节的名字来表示节中的每个段。
- en: 'For example, the function section contains a list of functions. A sample function
    definition in WebAssembly text format is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，函数节包含一个函数列表。以下是一个 WebAssembly 文本格式中的示例函数定义：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As with other expressions, everything that we define goes within parentheses,
    `()`. First, we define the function block with a `func` keyword. Following the
    `func` keyword, we add the name of the function. The function name is optional
    here because in binary, the function is identified by the index of the function
    block inside the function section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他表达式一样，我们定义的所有内容都在括号 `()` 内。首先，我们使用 `func` 关键字定义函数块。在 `func` 关键字之后，我们添加函数的名称。在这里，函数名称是可选的，因为在二进制中，函数是通过函数节内函数块的索引来识别的。
- en: 'The name is followed by `func_type`. `func_type` is referred to as `type_use`
    in the spec. `type_use` here refers to the type definition. `func_type` holds
    all the input parameters (along with their types) and the return type of the function.
    So, for an `add` function, which takes two input operands and returns the result,
    `func_type` will look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 名字后面跟着 `func_type`。`func_type` 在规范中被称为 `type_use`。在这里，`type_use` 指的是类型定义。`func_type`
    包含所有输入参数（及其类型）和函数的返回类型。因此，对于一个 `add` 函数，它接受两个输入操作数并返回结果，`func_type` 将看起来像这样：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The type is either `i32`, `i64`, `f32`, or `f64` (32-bit and 64-bit integer
    or float). The type information might change in the future, when WebAssembly adds
    support for more types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是 `i32`、`i64`、`f32` 或 `f64`（32 位和 64 位整数或浮点数）。类型信息可能会在未来改变，当 WebAssembly
    增加对更多类型的支持时。
- en: The `param` keyword denotes the defined expression holds a parameter. `$lhs`
    is the variable name. Note that all variables defined in the WebAssembly text
    format will have `$` as a prefix. Following that, we have the type of the parameter,
    `i32`. Similarly, we have defined another expression for the second operand, `$rhs`.
    Finally, the return type is mentioned as `(result i32)`. The `result` keyword
    denotes that the expression is a return type, followed by the type, `i32`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`param` 关键字表示定义的表达式包含一个参数。`$lhs` 是变量名。请注意，在 WebAssembly 文本格式中定义的所有变量都将有 `$`
    作为前缀。接下来，我们有参数的类型，`i32`。同样，我们为第二个操作数定义了另一个表达式，`$rhs`。最后，返回类型被提到为 `(result i32)`。`result`
    关键字表示表达式是一个返回类型，后面跟着类型，`i32`。'
- en: Following `func_type`, we define any local variables that we will use inside
    the function. Finally, we have a list of instructions/operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `func_type` 之后，我们定义任何将在函数内部使用的局部变量。最后，我们有一个指令/操作的列表。
- en: 'Let''s define an `add` function with the preceding code snippets as a reference:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面的代码片段为参考，定义一个 `add` 函数：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The entire block is wrapped inside the parentheses. The function block starts
    with a `func` keyword. Then, we have an optional name (`$add`) for the function.
    The WebAssembly binary module will use the function index inside the function
    section to identify the function rather than a name. Then, we define the operand
    and return type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 整个块被括号包围。函数块以 `func` 关键字开始。然后，我们有一个可选的函数名（`$add`）。WebAssembly 二进制模块将使用函数节内的函数索引来识别函数，而不是名称。然后，我们定义操作数和返回类型。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In binary format, the parameters and results are defined via the `type` section
    as that helps to optimize the generated functions. But in the text format, for
    brevity and ease of understanding, the type information will be shown in every
    function definition.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制格式中，参数和结果通过 `type` 节定义，因为这有助于优化生成的函数。但在文本格式中，为了简洁和易于理解，类型信息将显示在每个函数定义中。
- en: Then, we have a list of instructions. The first instruction, `get_local`, gets
    the local value of (from the heap) `$lhs`. Then, we fetch the local value of `$rhs`.
    After that, we add them both using the `i32.add` instruction. Finally, the closing
    parenthesis finishes things off.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一系列指令。第一条指令`get_local`获取（从堆中）的局部值`$lhs`。然后，我们获取`$rhs`的局部值。之后，我们使用`i32.add`指令将它们相加。最后，关闭括号结束。
- en: There is no separate `return` statement/expression. So, how does the function
    know what to return?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单独的`return`语句/表达式。那么，函数是如何知道要返回什么的？
- en: As we have seen before, WebAssembly is a stack machine. When a function is called,
    it creates an empty stack for it. The function then uses this stack to push and
    pop data. So, when the `get_local` instruction is executed, it pushes the value
    into the stack. After the two `get_local` calls, the stack will have `$lhs` and
    `$rhs` in the stack. Finally, `i32.add` will pop two values from the stack, do
    the `add` operation, and push the element. When the function is ended, the top
    of the stack will be taken out and provided to the function caller.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，WebAssembly是一种栈机器。当调用一个函数时，它会为它创建一个空栈。然后，函数使用这个栈来推送和弹出数据。因此，当执行`get_local`指令时，它将值推入栈中。在执行了两个`get_local`调用之后，栈中将包含`$lhs`和`$rhs`。最后，`i32.add`将从栈中弹出两个值，执行`add`操作，并将元素推入。当函数结束时，栈顶的值将被取出并提供给函数调用者。
- en: 'If we want to export this function to the outside world, then we can add an
    `export` block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将此函数导出到外部世界，则可以添加一个`export`块：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `export` block is defined inside `()`. The `export` block starts with an
    `export` keyword. The `export` keyword is followed by the name of the function.
    Following the name, we refer to the function. The function block consists of the
    following `func` keyword. Then, we have `function_reference`, which refers to
    the name of the function defined/imported inside the module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`块定义在`()`内。`export`块以`export`关键字开始。`export`关键字后面跟着函数的名称。名称之后，我们引用该函数。函数块由以下`func`关键字组成。然后，我们有`function_reference`，它引用模块内部定义/导入的函数的名称。'
- en: 'In order to export the `add` function, we define the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导出`add`函数，我们定义以下内容：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`"add"` refers to the name with which the function is exported outside the
    module, followed by `(func $add)`, referring to the function.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`"add"`指的是函数在模块外部导出的名称，后面跟着`(func $add)`，指的是该函数。'
- en: 'Both the function and `export` sections should be wrapped inside a `module`
    section, to make it valid WASM:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和`export`部分都应该包裹在`module`部分内，以使其成为有效的WASM：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding is valid WASM. Imagine it as a tree structure with the module
    as its root and both the function and export as its children.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容是有效的WASM。想象它是一个树结构，模块作为其根，函数和导出作为其子节点。
- en: We have seen how to create a simple function in WebAssembly text format. Now,
    let's define a complex function in WebAssembly text format.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在WebAssembly文本格式中创建一个简单的函数。现在，让我们在WebAssembly文本格式中定义一个复杂函数。
- en: Building a function in WebAssembly text format
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WebAssembly文本格式中构建函数
- en: 'For this, we will use a recursive Fibonacci series generator. The Fibonacci
    function that we will be writing will be of the following format:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将使用递归的斐波那契数列生成器。我们将编写的斐波那契函数将具有以下格式：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s first define the function signature for the given `fib` function using
    WebAssembly text format. The `fib` function, similar to its C counterpart, takes
    in a number parameter and returns a number. So, the function definition follows
    the same signature in the WebAssembly text format:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用WebAssembly文本格式定义给定`fib`函数的函数签名。`fib`函数类似于其C语言对应版本，接受一个数字参数并返回一个数字。因此，函数定义遵循WebAssembly文本格式中的相同签名：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We define the function inside parentheses, `()`. The function starts with a
    `func` keyword. Following the keyword, we add the function name, `$fib`. Then,
    we add the parameter to the function; in our case, the function has only one parameter,
    `n`; we define it as `(param $n i32)`. Then, the function returns a number, `(result
    i32)`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在括号`()`内定义函数。函数以`func`关键字开始。关键字之后，我们添加函数名称，`$fib`。然后，我们向函数添加参数；在我们的例子中，函数只有一个参数，`n`；我们将其定义为`(param
    $n i32)`。然后，函数返回一个数字，`(result i32)`。
- en: 'WebAssembly does not have in-memory to handle temporary variables. In order
    to have local values, we should push the value into the stack and then retrieve
    it. So, to check `n<=1`, we have to first create a local variable and store `1`
    inside it, and then do the check. To define a local variable, we use the `local`
    block. The `local` block starts with a `local` keyword. This keyword is followed
    by the name of the variable. After the variable name, we define the type of the
    variable:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly没有内存来处理临时变量。为了有局部值，我们应该将值推入栈中，然后检索它。所以，要检查`n<=1`，我们必须首先创建一个局部变量并在其中存储`1`，然后进行检查。要定义局部变量，我们使用`local`块。`local`块以`local`关键字开始。这个关键字后面跟着变量的名称。在变量名称之后，我们定义变量的类型：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a `local` variable called `$tmp`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`$tmp`的`local`变量：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`(local $tmp i32)` is not an instruction. It is part of the function declaration.
    Remember, the preceding function syntax includes `local`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`(local $tmp i32)`不是一个指令。它是函数声明的一部分。记住，前面的函数语法包括`local`。'
- en: 'We then have to set the value of `$tmp` to `1`. To set the value, we first
    have to push the value `1` into the stack, after which we have to pop the value
    from the stack and set it to `$tmp`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来必须将`$tmp`的值设置为`1`。要设置值，我们首先必须将值`1`推入栈中，然后从栈中弹出值并将其设置为`$tmp`：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`i32.const` creates an `i32` constant value and pushes that into the stack.
    So, here, we create a constant with a value of `1` and push that into the stack.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`i32.const`创建一个`i32`常量值并将其推入栈中。所以，在这里，我们创建一个值为`1`的常量并将其推入栈中。'
- en: Then, we set the value in `$tmp` using `set_local`. `set_local` takes the topmost
    value from the stack, in our case, 1, and assigns the value of `$tmp` to `1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`set_local`设置`$tmp`中的值。`set_local`从栈顶获取最高值，在我们的例子中是1，并将`$tmp`的值设置为1。
- en: Now, we have to check whether the given parameter is less than 2\. WebAssembly
    provides `i32.<some_action>` to do some action on `i32`. For example, to add two
    numbers, we have used `i32.add`. Similarly, to check whether it's less than a
    particular value, we have `i32.lt_s`. `_s` here denotes that we are checking for
    a signed number.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须检查给定的参数是否小于2。WebAssembly提供了`i32.<some_action>`来对`i32`执行一些操作。例如，要添加两个数字，我们使用了`i32.add`。同样，要检查它是否小于某个特定值，我们有`i32.lt_s`。这里的`_s`表示我们正在检查一个有符号数字。
- en: '`i32.lt_s` expects two operands. For the first operand (that is, `$n`), we
    use the `get_local` expression to fetch the value from `$n` and put it at the
    top of the stack. Then, we create a constant of `2` using `i32.const 2` and add
    `2` to the stack. Finally, we compare the `$n` value with `2` using `i32.lt_s`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`i32.lt_s`期望两个操作数。对于第一个操作数（即`$n`），我们使用`get_local`表达式从`$n`中获取值并将其放在栈顶。然后，我们使用`i32.const
    2`创建一个常量并将其推入栈中。最后，我们使用`i32.lt_s`比较`$n`的值与`2`：'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But how do we define the *if condition*? WebAssembly provides `br_if` and `block`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何定义*条件*？WebAssembly提供了`br_if`和`block`。
- en: 'In WebAssembly text format, a block is defined with a `block` keyword followed
    by a name to identify the block. We end the block using `end`. The block looks
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebAssembly文本格式中，一个块是通过`block`关键字定义的，后面跟着一个用于识别块的名称。我们使用`end`来结束块。块看起来如下：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will provide this block to `br_if`. `br_if` calls the block if the condition
    succeeds:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供这个块给`br_if`。如果条件成功，`br_if`将调用块：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The WebAssembly text format so far will look like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly文本格式目前看起来是这样的：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Everything is wrapped inside `module`. At the end of `$block`, the value will
    be stored in `$tmp`. We get the value of `$tmp` using `get_local $tmp`. The only
    thing that is left to do is to create the loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的内容都被包裹在`module`中。在`$block`的末尾，值将被存储在`$tmp`中。我们使用`get_local $tmp`来获取`$tmp`的值。唯一剩下要做的就是创建循环。
- en: Loop time
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环时间
- en: 'First, we set `$tmp` to `1`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`$tmp`设置为`1`：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we will create a loop. To create a loop, the WebAssembly text format
    uses the `loop` keyword:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个循环。要创建循环，WebAssembly文本格式使用`loop`关键字：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `loop` keyword is followed by the name of the loop. The loop ends with
    the `end` keyword. `loop` is a special block that will run until we exit using
    some conditional expression such as `br_if`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`关键字后面跟着循环的名称。循环以`end`关键字结束。`loop`是一个特殊的块，它将一直运行，直到我们使用一些条件表达式（如`br_if`）退出：'
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We get `$n` and add `-2` to it, and then call the `fib` function. To call a
    function, we use the `call` keyword followed by the name of the function. Here,
    `call $fib` returns the value and pushes the value into the stack.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到`$n`并给它加上`-2`，然后调用`fib`函数。要调用一个函数，我们使用`call`关键字后跟函数名。在这里，`call $fib`返回值并将值推入栈中。
- en: Now, get `$tmp` using `get_local $tmp`. This pushes `$tmp` to the stack. Then,
    we use `i32.add` to pop two values from the stack and add them. Finally, we set
    `$tmp` using `set_local $tmp`. `set_local $tmp` takes the topmost value from the
    stack and assigns it to `$tmp`. We get `$n` and add `-1` to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`get_local $tmp`获取`$tmp`。这会将`$tmp`推入栈中。然后，我们使用`i32.add`从栈中弹出两个值并将它们相加。最后，我们使用`set_local
    $tmp`设置`$tmp`。`set_local $tmp`从栈中取出最顶部的值并将其分配给`$tmp`。我们得到`$n`并给它加上`-1`。
- en: 'We use `tee_local` here because `tee_local` is similar to `set_local` but instead
    of pushing the value into the stack, it returns the value. Finally, we run the
    loop until `$n` is greater than 1\. If it is less than 1, we break the loop using
    `br_if $loop`. The complete WebAssembly text format will look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`tee_local`是因为`tee_local`与`set_local`类似，但不同之处在于它不是将值推入栈中，而是返回值。最后，我们运行循环直到`$n`大于1。如果它小于1，我们使用`br_if
    $loop`跳出循环。完整的WebAssembly文本格式将看起来像这样：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In future chapters, we will see how we can convert this WebAssembly text format
    into WASM and execute it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的章节中，我们将看到如何将这个WebAssembly文本格式转换为WASM并执行它。
- en: If you're interested in learning more about s-expressions, check out [https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对学习更多关于s表达式感兴趣，请查看[https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression)。
- en: To find out more about the WebAssembly text format design, check out the specifications
    at [https://github.com/WebAssembly/design/blob/master/Semantics.md](https://github.com/WebAssembly/design/blob/master/Semantics.md).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于WebAssembly文本格式设计的信息，请查看[https://github.com/WebAssembly/design/blob/master/Semantics.md](https://github.com/WebAssembly/design/blob/master/Semantics.md)中的规范。
- en: Check out more text instructions at [https://webassembly.github.io/spec/core/text/instructions.html](https://webassembly.github.io/spec/core/text/instructions.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://webassembly.github.io/spec/core/text/instructions.html](https://webassembly.github.io/spec/core/text/instructions.html)查看更多文本指令。
- en: Refer to various instructions and their opcode at [https://webassembly.github.io/spec/core/binary/instructions.html](https://webassembly.github.io/spec/core/binary/instructions.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://webassembly.github.io/spec/core/binary/instructions.html](https://webassembly.github.io/spec/core/binary/instructions.html)参考各种指令及其操作码。
- en: Find out more about binary encoding at [https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md](https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md](https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md)了解更多关于二进制编码的信息。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how WebAssembly is executed inside the JavaScript
    engine and explored what WebAssembly text format is and how to define WASM using
    WebAssembly text format. In the next chapter, we will explore the WebAssembly
    Binary Toolkit.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了WebAssembly如何在JavaScript引擎中执行，并探讨了WebAssembly文本格式是什么以及如何使用WebAssembly文本格式定义WASM。在下一章中，我们将探索WebAssembly二进制工具包。
