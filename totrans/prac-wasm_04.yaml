- en: '*Chapter 3*:Exploring WebAssembly Modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly is a low-level assembly-like code that is designed for efficient
    execution and compact representation. WebAssembly runs at a near-native speed
    in all JavaScript engines (including modern desktop and mobile browsers and Node.js).
    Compact representation of the binary enables the generated binary to be as small
    as possible in size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of WebAssembly is to enable high-performance applications.
  prefs: []
  type: TYPE_NORMAL
- en: Each WebAssembly file is an efficient, optimal, and self-sufficient module called
    a **WebAssembly module** (**WASM**). WASM is safe, that is, the binary runs in
    a memory-safe and sandboxed environment. WASM does not have permission to access
    anything outside of that sandbox. WASM is language-, hardware-, and platform-independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly is a virtual **instruction set architecture** (**ISA**). The WebAssembly
    specifications define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WebAssembly specification also defines a textual representation of the WebAssembly
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore WASM and how a JavaScript engine executes
    WASM. We then explore the WebAssembly text format and why it is useful. Understanding
    WASM execution and the WebAssembly text format will enable us to easily understand
    the module and debug it in the JavaScript engine. We will cover the following
    main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how WebAssembly works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the WebAssembly text format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how WebAssembly works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first explore how JavaScript and WebAssembly are executed inside the JavaScript
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JavaScript execution inside the JavaScript engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript engine first fetches the complete JavaScript file (note that
    the engine has to wait until the entire file is downloaded/loaded).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The bigger the JavaScript file, the longer it takes to load. It doesn't matter
    how fast your JavaScript engine is or how efficient your code is. If your JavaScript
    file is huge (that is, greater than 170 KB), then your application is going to
    be slow at loading time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – JavaScript execution inside the JavaScript engine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B14844.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – JavaScript execution inside the JavaScript engine
  prefs: []
  type: TYPE_NORMAL
- en: Once loaded, the JavaScript is parsed into **abstract syntax trees** (**ASTs**).
    This phase is called **parse**. Since JavaScript is both an interpreted and compiled
    language, the JavaScript engine kickstarts the execution after parsing. The interpreter
    executes the code faster but it compiles the code every time. This phase is called
    **interpret**.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript engine has **watchers** (called **profilers** in some browsers).
    Watchers keep track of code execution. If a particular block of code is executed
    frequently, then the watcher marks it as hot code. The engine compiles the block
    of code using the **just-in-time** (**JIT**) compiler. The engine spends some
    time doing the compilation, say in the order of nanoseconds. The time spent here
    is worth it, because the next time the function is called, the execution happens
    much faster, because the compiled version is always faster than the interpreted
    one. This phase is called **optimize**.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript engines add one (or two) more layers of optimization. The watchers
    continue watching the code execution. The watchers then name the code that is
    called more often *very hot code*. The engine optimizes this code further. This
    optimization takes a long time (consider something like `-O3`-level optimization).
    This phase produces highly optimized code that runs super fast. This code is much
    faster than the previously optimized code and the interpreted version. Obviously,
    the engine spends more time during this phase, say in the order of milliseconds.
    This is compensated by the code performance and frequency of execution.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed language and all the optimizations the engine
    can do are based on the assumption of *types*. If the assumption breaks, then
    the code is interpreted and executed, and the optimized code gets removed rather
    than throwing a runtime exception. The JavaScript engine implements the necessary
    type checks and bails out the optimized code when the assumed type changes. But
    the time spent on the optimize phase is in vain.
  prefs: []
  type: TYPE_NORMAL
- en: We can prevent these *type*-related issues by using something such as **TypeScript**.
    TypeScript is a superset of JavaScript. With TypeScript, we can prevent polymorphic
    code (code that accepts different types). In the JavaScript engine, monomorphic
    code (code that accepts only one type) always runs faster than its polymorphic
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: There is no use in having highly optimized monomorphic JavaScript code if the
    JavaScript files are huge in size. The JavaScript engine has to wait until the
    entire file is downloaded. With a poor connection, that takes forever to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to split the JavaScript bundle into smaller chunks. Including
    the JavaScript asynchronously (or in other words, lazy loading) boosts the performance
    of your application. We need to strike a correct balance and know which JavaScript
    module/file to load, cache, and then revalidate. Larger file sizes (payloads)
    will degrade the performance of the application greatly.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is **garbage collection**, where all the live objects in the
    memory are removed. The garbage collection in the JavaScript engine works on the
    basis of reference. During the garbage collection cycle, the JavaScript engine
    starts from the root object (something like global in Node.js). It finds all the
    objects referenced from the root object and marks them as reachable objects. It
    marks the remaining objects as unreachable objects. Finally, it sweeps the unreachable
    objects. Since it is automatically done by the JavaScript engine, the garbage
    collection process is not efficient and it is much slower.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WebAssembly execution inside the JavaScript engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WASM is in binary format and is already compiled and optimized. The JavaScript
    engine fetches the WASM. Then, it decodes the WASM and converts it into the module's
    internal representation (that is, AST). This phase is called **decode**. The decode
    phase is much faster than JavaScript's **parse** phase.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – WebAssembly execution inside the JavaScript engine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B14844.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – WebAssembly execution inside the JavaScript engine
  prefs: []
  type: TYPE_NORMAL
- en: Next, the decoded WASM enters the **compile** phase. During this phase, the
    module is validated, and during the validation, the code is checked for certain
    conditions to guarantee the module is safe and does not have any harmful code.
    The functions, instruction sequences, and the usage of stacks are type-checked
    during the validation process. The validated code is then compiled to machine-executable
    code. Since the WASM is already compiled and optimized, this compile phase is
    faster. During this phase, the WASM is converted into machine code.
  prefs: []
  type: TYPE_NORMAL
- en: The compiled code then enters the **execute** phase. In the execute phase, the
    module is instantiated and invoked. During the instantiation, the engine instantiates
    the state and the execution stack (memory where it stores all the information
    related to the program) and then executes the module.
  prefs: []
  type: TYPE_NORMAL
- en: The other advantage of WebAssembly is that the module is ready to compile and
    instantiate right from the first byte. Thus, the JavaScript engine need not wait
    until the entire module is downloaded. This further increases WebAssembly's performance.
    WebAssembly is fast because its execution has fewer steps than JavaScript execution,
    so the binary is already optimized and compiled, and the binary can be streaming
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: WASM does not always provide high performance. There are scenarios in which
    JavaScript performs better. So, it is necessary to understand that and think before
    using WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about JavaScript performance and how load time is involved at
    [https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4](https://medium.com/@addyosmani/the-cost-of-javascript-in-2018-7d8950fbb5d4).
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about chunking and code splitting in webpack at [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how WebAssembly works inside the browser; now, let's explore the
    WebAssembly text format.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the WebAssembly text format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machines understand a bunch of 1s and 0s. We optimize the binary to make it
    run faster and more efficiently. The more concise and optimal the instructions
    are, the more efficient and performant the machine will be. But for people, it
    is difficult to contextually analyze and understand a huge blob of 1s and 0s.
    That is the very reason why we started abstracting and creating high-level programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the WebAssembly world, we convert human-readable programming languages, such
    as Rust, Go, and C/C++, into binary code. These binaries are a bunch of instructions
    with opcodes and operands. These instructions make the machine highly efficient
    but contextually make it difficult for us to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Why should we worry about the readability of the binary generated? Because it
    helps us to understand the code, which helps while debugging the code.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly provides the WebAssembly text format, WAST or WAT. WAST is a human-readable
    format of the WebAssembly binary. The JavaScript engine (both in the browser and
    Node.js), when loading the WebAssembly file, can convert the binary into WebAssembly
    text format. This helps in understanding what is in the code and debugging. Text
    editors can show the binary in WebAssembly text format, which is much more readable
    than its binary counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic WASM in binary format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This basic module has a magic header (`\0asm`) followed by the version of WebAssembly
    (`01`).
  prefs: []
  type: TYPE_NORMAL
- en: The textual format is written in an `()`. S-expressions are commonly used when
    defining a nested list or structured tree. Many research papers on tree-based
    data structures use this notation to showcase their code. The s-expression removes
    all the unnecessary ceremony from XML, providing a concise format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Does this expression (defining everything within parentheses) look familiar?
    Have you ever worked with LISP (or the languages that are built inspired by LISP)?
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules are the basic building blocks in WASM. A textual representation of
    basic WASM is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'WASM is made up of a header and zero or more sections. The header starts with
    a magic header and the version of WASM. Following the header, the WASM may have
    zero or more of the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these sections are optional in WASM. The structure of WASM looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every section inside the WASM is a vector (array) that contains zero or more
    values of the respective types, except for `start`. We will explore the `start`
    section later in the book. For now, `start` holds an index that references a function
    in the `funcs` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every section in the WASM takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first byte refers to a unique section ID. Every section has a unique section
    ID. Next to the unique section ID is an **unsigned 32-bit** (**u32**) integer
    that defines the section's size in bytes. The remaining bytes are the section
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the section size is defined by a u32 integer, the maximum size of the
    section is limited to approximately 4.2 GB of memory (that is, 2^32 - 1).
  prefs: []
  type: TYPE_NORMAL
- en: In the WebAssembly text format, we use the name of the section to represent
    each segment in the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the function section contains a list of functions. A sample function
    definition in WebAssembly text format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As with other expressions, everything that we define goes within parentheses,
    `()`. First, we define the function block with a `func` keyword. Following the
    `func` keyword, we add the name of the function. The function name is optional
    here because in binary, the function is identified by the index of the function
    block inside the function section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name is followed by `func_type`. `func_type` is referred to as `type_use`
    in the spec. `type_use` here refers to the type definition. `func_type` holds
    all the input parameters (along with their types) and the return type of the function.
    So, for an `add` function, which takes two input operands and returns the result,
    `func_type` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The type is either `i32`, `i64`, `f32`, or `f64` (32-bit and 64-bit integer
    or float). The type information might change in the future, when WebAssembly adds
    support for more types.
  prefs: []
  type: TYPE_NORMAL
- en: The `param` keyword denotes the defined expression holds a parameter. `$lhs`
    is the variable name. Note that all variables defined in the WebAssembly text
    format will have `$` as a prefix. Following that, we have the type of the parameter,
    `i32`. Similarly, we have defined another expression for the second operand, `$rhs`.
    Finally, the return type is mentioned as `(result i32)`. The `result` keyword
    denotes that the expression is a return type, followed by the type, `i32`.
  prefs: []
  type: TYPE_NORMAL
- en: Following `func_type`, we define any local variables that we will use inside
    the function. Finally, we have a list of instructions/operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define an `add` function with the preceding code snippets as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The entire block is wrapped inside the parentheses. The function block starts
    with a `func` keyword. Then, we have an optional name (`$add`) for the function.
    The WebAssembly binary module will use the function index inside the function
    section to identify the function rather than a name. Then, we define the operand
    and return type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In binary format, the parameters and results are defined via the `type` section
    as that helps to optimize the generated functions. But in the text format, for
    brevity and ease of understanding, the type information will be shown in every
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a list of instructions. The first instruction, `get_local`, gets
    the local value of (from the heap) `$lhs`. Then, we fetch the local value of `$rhs`.
    After that, we add them both using the `i32.add` instruction. Finally, the closing
    parenthesis finishes things off.
  prefs: []
  type: TYPE_NORMAL
- en: There is no separate `return` statement/expression. So, how does the function
    know what to return?
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen before, WebAssembly is a stack machine. When a function is called,
    it creates an empty stack for it. The function then uses this stack to push and
    pop data. So, when the `get_local` instruction is executed, it pushes the value
    into the stack. After the two `get_local` calls, the stack will have `$lhs` and
    `$rhs` in the stack. Finally, `i32.add` will pop two values from the stack, do
    the `add` operation, and push the element. When the function is ended, the top
    of the stack will be taken out and provided to the function caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to export this function to the outside world, then we can add an
    `export` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `export` block is defined inside `()`. The `export` block starts with an
    `export` keyword. The `export` keyword is followed by the name of the function.
    Following the name, we refer to the function. The function block consists of the
    following `func` keyword. Then, we have `function_reference`, which refers to
    the name of the function defined/imported inside the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to export the `add` function, we define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`"add"` refers to the name with which the function is exported outside the
    module, followed by `(func $add)`, referring to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the function and `export` sections should be wrapped inside a `module`
    section, to make it valid WASM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is valid WASM. Imagine it as a tree structure with the module
    as its root and both the function and export as its children.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create a simple function in WebAssembly text format. Now,
    let's define a complex function in WebAssembly text format.
  prefs: []
  type: TYPE_NORMAL
- en: Building a function in WebAssembly text format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this, we will use a recursive Fibonacci series generator. The Fibonacci
    function that we will be writing will be of the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first define the function signature for the given `fib` function using
    WebAssembly text format. The `fib` function, similar to its C counterpart, takes
    in a number parameter and returns a number. So, the function definition follows
    the same signature in the WebAssembly text format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We define the function inside parentheses, `()`. The function starts with a
    `func` keyword. Following the keyword, we add the function name, `$fib`. Then,
    we add the parameter to the function; in our case, the function has only one parameter,
    `n`; we define it as `(param $n i32)`. Then, the function returns a number, `(result
    i32)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'WebAssembly does not have in-memory to handle temporary variables. In order
    to have local values, we should push the value into the stack and then retrieve
    it. So, to check `n<=1`, we have to first create a local variable and store `1`
    inside it, and then do the check. To define a local variable, we use the `local`
    block. The `local` block starts with a `local` keyword. This keyword is followed
    by the name of the variable. After the variable name, we define the type of the
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `local` variable called `$tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`(local $tmp i32)` is not an instruction. It is part of the function declaration.
    Remember, the preceding function syntax includes `local`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to set the value of `$tmp` to `1`. To set the value, we first
    have to push the value `1` into the stack, after which we have to pop the value
    from the stack and set it to `$tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`i32.const` creates an `i32` constant value and pushes that into the stack.
    So, here, we create a constant with a value of `1` and push that into the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set the value in `$tmp` using `set_local`. `set_local` takes the topmost
    value from the stack, in our case, 1, and assigns the value of `$tmp` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have to check whether the given parameter is less than 2\. WebAssembly
    provides `i32.<some_action>` to do some action on `i32`. For example, to add two
    numbers, we have used `i32.add`. Similarly, to check whether it's less than a
    particular value, we have `i32.lt_s`. `_s` here denotes that we are checking for
    a signed number.
  prefs: []
  type: TYPE_NORMAL
- en: '`i32.lt_s` expects two operands. For the first operand (that is, `$n`), we
    use the `get_local` expression to fetch the value from `$n` and put it at the
    top of the stack. Then, we create a constant of `2` using `i32.const 2` and add
    `2` to the stack. Finally, we compare the `$n` value with `2` using `i32.lt_s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But how do we define the *if condition*? WebAssembly provides `br_if` and `block`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In WebAssembly text format, a block is defined with a `block` keyword followed
    by a name to identify the block. We end the block using `end`. The block looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will provide this block to `br_if`. `br_if` calls the block if the condition
    succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The WebAssembly text format so far will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Everything is wrapped inside `module`. At the end of `$block`, the value will
    be stored in `$tmp`. We get the value of `$tmp` using `get_local $tmp`. The only
    thing that is left to do is to create the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Loop time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we set `$tmp` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create a loop. To create a loop, the WebAssembly text format
    uses the `loop` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loop` keyword is followed by the name of the loop. The loop ends with
    the `end` keyword. `loop` is a special block that will run until we exit using
    some conditional expression such as `br_if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We get `$n` and add `-2` to it, and then call the `fib` function. To call a
    function, we use the `call` keyword followed by the name of the function. Here,
    `call $fib` returns the value and pushes the value into the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now, get `$tmp` using `get_local $tmp`. This pushes `$tmp` to the stack. Then,
    we use `i32.add` to pop two values from the stack and add them. Finally, we set
    `$tmp` using `set_local $tmp`. `set_local $tmp` takes the topmost value from the
    stack and assigns it to `$tmp`. We get `$n` and add `-1` to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `tee_local` here because `tee_local` is similar to `set_local` but instead
    of pushing the value into the stack, it returns the value. Finally, we run the
    loop until `$n` is greater than 1\. If it is less than 1, we break the loop using
    `br_if $loop`. The complete WebAssembly text format will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In future chapters, we will see how we can convert this WebAssembly text format
    into WASM and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in learning more about s-expressions, check out [https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression).
  prefs: []
  type: TYPE_NORMAL
- en: To find out more about the WebAssembly text format design, check out the specifications
    at [https://github.com/WebAssembly/design/blob/master/Semantics.md](https://github.com/WebAssembly/design/blob/master/Semantics.md).
  prefs: []
  type: TYPE_NORMAL
- en: Check out more text instructions at [https://webassembly.github.io/spec/core/text/instructions.html](https://webassembly.github.io/spec/core/text/instructions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Refer to various instructions and their opcode at [https://webassembly.github.io/spec/core/binary/instructions.html](https://webassembly.github.io/spec/core/binary/instructions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about binary encoding at [https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md](https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how WebAssembly is executed inside the JavaScript
    engine and explored what WebAssembly text format is and how to define WASM using
    WebAssembly text format. In the next chapter, we will explore the WebAssembly
    Binary Toolkit.
  prefs: []
  type: TYPE_NORMAL
