- en: The Big Ideas – Ownership and Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ownership and borrowing are the features that set Rust apart from other programming
    languages. The closest equivalent that you're likely to find is the **Resource
    Aquisition Is Instantiation** (**RAII**) design pattern common in C++, but that's
    a design pattern, not a language feature, and is not fully analogous.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to talk about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ownership of values and the scope of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ways that ownership is transferred between scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Borrowing and lending data values, and how that interacts with ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lifetime of borrowed values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self` parameter of functions, and the implications of borrowing or not
    borrowing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, every data value has a single owning scope—no more, no less. So, what's
    a scope? The easy answer is that a scope is the place where a block expression
    stores its variables. Scopes are not directly represented in the source code,
    but a scope begins when a block expression begins, with a `{` symbol, and ends
    when the block expression ends, with `}` (or when a `return` statement is run
    before the block reaches its end). The scope is the chunk of memory where the
    block's variables are stored.
  prefs: []
  type: TYPE_NORMAL
- en: '*Every* data value has an owning scope, including implied temporary values
    such as the result of `2 + 2` when we ask Rust to compute `(2 + 2) * 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: When Rust is done with a scope, all of the data values that scope owns are discarded
    and the memory that was used to store them is freed up for other uses. This includes
    memory that was allocated on the **heap**, which we'll learn how to use in [Chapter
    6](864ada48-1934-447e-8351-a88a1f9fccbb.xhtml), *Heap Memory and Smart Pointers*.
  prefs: []
  type: TYPE_NORMAL
- en: The time between when a value is created and the time when its owning scope
    is done is called the **lifetime** of the value.
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like most programming languages, Rust uses a **stack** to handle memory management
    for scopes. A stack is a simple data structure, also referred to as a **Last In,
    First Out Queue** or **LIFO**. Stacks support two operations: **push**, which
    stores a new value, and `pop`*,* which removes and returns the most recently stored
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of a stack as a pile of boxes. If we want to remove the stuff
    stored in the top box, we can just take it down and look inside. However, if we
    want to remove the stuff stored in one of the boxes underneath, we first have
    to remove the boxes above it. Here''s a diagram of what I''m talking about, with
    access to the boxes underneath blocked by the ones above them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37dac796-847b-404c-af01-64c3a6fbda64.png)'
  prefs: []
  type: TYPE_IMG
- en: When a Rust block expression starts, it makes a note of how tall the stack is
    and, when the block ends, it removes things from the stack until the stack is
    the same height as it was to begin with. In between, when the block needs to store
    a new value, it pushes that value onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: When a value is removed from the stack, the Rust compiler also makes sure to
    do any cleanup that is needed before discarding the value, including calling a
    custom cleanup function for the value if one is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages do this, but not exclusively. In Rust, even when
    a data value uses heap memory, it is represented on the stack and controlled by
    the rules of ownership. By following that simple procedure, it's easy for Rust
    to handle all of the record keeping and memory management for a program, efficiently
    and with no garbage collection required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Garbage collection is a mechanism used in many programming languages to remove
    the burden of memory management from the programmer. It''s even easier to use
    than Rust''s method, but it does require time for the garbage collection mechanism
    to run, which can impact program performance. Rust''s method is almost entirely
    deterministic at compile time: the Rust compiler knows when to allocate and deallocate
    memory without having to figure it out while the program runs.'
  prefs: []
  type: TYPE_NORMAL
- en: Transferring ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s possible (and common) to transfer ownership of a value to a different
    scope. For example, we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is happening is that the `main_1` variable is created and initialized under
    the ownership of the current scope (the value is pushed onto the stack), but then
    the ownership is transferred to the scope of the block expression that makes up
    the `receive_ownership` function's body, when the value is used as a function
    parameter. The compiler knows that the current scope is no longer responsible
    for cleaning up the value stored in `main_1`, because that job now belongs to
    a different scope.
  prefs: []
  type: TYPE_NORMAL
- en: The bytes that represent the value on the stack are copied to a new location
    on the stack, within the scope that is receiving ownership. Most data values store
    some of their information outside of the stack, though, so the bytes that are
    left behind in the old scope are considered no longer meaningful or safe to use.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to use the value stored in `main_1` after it has been moved to a different
    scope, as we're doing here with the second call to `receive_ownership`, the compiler
    will report an error. It's not just using the value as a function parameter that
    will cause an error, either. Any use of a value that has been moved is an error.
    It's no longer there to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ownership can also be transferred in the other direction. This function receives
    ownership of its parameter, but then returns the parameter (and hence the ownership)
    back to the block where it was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That doesn't mean that the original variable (`main_1`) becomes usable again,
    but if we assign the return value from the function to a variable, we can continue
    using that value through the new variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ownership can also be transferred "sideways" by assigning a value to a different
    variable. We do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the value stored in `main_2` is moved to `main_4`. In this basic example,
    that's not particularly interesting; we've just got a new variable containing
    the value that the old variable used to contain, and they're both in the same
    scope anyway. This gets more interesting when we do things like assigning a value
    to a structure member, especially when the structure has a different lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust''s compiler is very careful about ownership, and when it detects a situation
    where ownership is not properly respected, or even *might not* be properly respected,
    it reports an error. The following function will not compile, because it is only
    valid when the `switch` parameter is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to compile the `uncertain_ownership` function, we get output like
    this from the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/670d92c5-49b3-48ec-ae29-2456fd8d7459.png)'
  prefs: []
  type: TYPE_IMG
- en: As far as the compiler is concerned, if we could have moved the value before
    using it, we don't get to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Copying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the compiler error discussed at the end of the *Transferring ownership* section
    of this chapter, we see that the compiler noted that the data value is moved because
    it *does not implement the* `Copy` *trait*, which is interesting. What does that
    mean?
  prefs: []
  type: TYPE_NORMAL
- en: For some data types, particularly the primitive types such as integers and floating-point
    numbers, copying the bytes that represent them on the stack is all that is required
    to actually make a complete working copy of the data value. In other words, their
    representation does not refer to anything stored elsewhere in memory or otherwise
    rely on ownership to keep everything correct.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of data types in the standard library that could have the
    `Copy` trait as far as memory usage is concerned, but make use of ownership to
    keep other things safe and correct. Examples include data types that represent
    access to external resources such as files or network sockets, and data types
    having to do with concurrency. Ownership has turned out to be an even more powerful
    tool than was originally expected.
  prefs: []
  type: TYPE_NORMAL
- en: Data types that do not rely on ownership at all are said to have the `Copy`
    trait. We'll see how to declare that our own data types have the Copy trait in
    [Chapter 8](a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml), *Important Standard Traits*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a value''s data type has the Copy trait, Rust doesn''t move the value
    when it is transferred. The receiver still receives the value, but the old value
    remains valid. Instead of moving, the value has been copied. This function has
    almost exactly the same structure as the `uncertain_ownership` function, which
    refuses to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The important difference here is that `local` contains a floating-point value
    and the floating-point data types have the Copy trait, which means that even though
    the value of `local` is placed inside of a `Point2D` structure, and that structure
    is then moved to the `receive_ownership` function's scope, `local` remains valid
    in the current scope. That's because the value of `local` wasn't moved into `Point2D`.
    It was copied.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we used a structure initializer to assign the value of `local`
    instead of using an `=` symbol makes no difference. Either way, it's an assignment,
    and either way, the data type's Copy trait determines whether the assignment is
    a copy or a move.
  prefs: []
  type: TYPE_NORMAL
- en: Lending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one more way we can send information to a different scope and that is
    by **lending**. When we move a data value, the receiving scope becomes the value's
    new owner. When we copy a data value, the receiving scope owns the duplicate it
    received, and the sending scope retains ownership of the original. When we lend
    a data value, things can get more complicated, because the original scope retains
    ownership, but the receiving scope is still allowed to access the data.
  prefs: []
  type: TYPE_NORMAL
- en: The original scope still owns the data, which means that, when that scope ends,
    the data will go away. If some of the scope's contained data was still loaned
    to a different scope at that time, the program would likely crash and, since the
    Rust compiler hates potential crashes, it does not allow us to get into that situation.
    Instead, it requires that any borrowed information must be returned before the
    owning scope's time is up.
  prefs: []
  type: TYPE_NORMAL
- en: When a data value is borrowed, that value is neither copied nor moved. The bytes
    that represent that value on the stack stay right where they were. Instead, the
    borrower receives the memory address of those bytes on the stack, allowing it
    to violate the conceptual idea of a stack by accessing information stored below
    the top, probably in a different scope entirely. You can see why the compiler
    wants to be careful about that!
  prefs: []
  type: TYPE_NORMAL
- en: 'A currently borrowed data value can''t be changed by the owner, even if the
    data value is stored in a mutable variable. This is part of keeping lending from
    causing problems: a data value can only ever be changed in one place at a time
    at most and, when it *can* be changed, it''s never in use elsewhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Lending immutably
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When lending, the default is to lend the data **immutably**, meaning that the
    borrowed data can be read, but not changed. We can lend immutably to more than
    one borrower at the same time, which is safe because none of them can change the
    borrowed data, and so they can't interfere with each other by changing the data
    value unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an immutable borrow, we prefix the expression producing the data
    value with `&`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're calling a function called `borrow_ownership`, and passing it a data
    value borrowed from the `main_3` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Lending mutably
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want to lend a data value and allow the receiver to modify it,
    so that, after the borrow has ended, the data value in the owning scope has changed.
    When that's what we need, we lend the data **mutably**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t lend mutably unless the data value we''re lending is stored in a
    mutable variable, which means that the `mut` keyword was used when we declared
    the variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we have a mutable variable to lend, we can create a mutable borrow
    of that variable''s value, by using the `mut` keyword *again*, in a different
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If there's a mutable borrow of a data value, creating another borrow for it (of
    either sort) is impossible and, if there are any immutable borrows, then creating
    a mutable borrow is impossible. That rule means that if a data value is mutably
    borrowed, it's not borrowed anywhere else. Combined with the rule we discussed
    earlier that prevents borrowed data from being changed by its real owner, that
    means that as long as there's a mutable borrow active, that borrow is the only
    way to modify the borrowed data value.
  prefs: []
  type: TYPE_NORMAL
- en: However, once the borrow is finished, the owner regains control of the (possibly
    modified) data value.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing borrowed data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To receive borrowed data, we need to properly specify the data type as a borrow.
    That is done by using `&` or `&mut` with the data type on the receiving end, just
    as we used them with the data value on the sending end.
  prefs: []
  type: TYPE_NORMAL
- en: While the term *borrow* is common in Rust, the technical term is **reference**.
    So, we will usually say we are borrowing data, using borrowed data, or that a
    data value is accessed as a borrow, but we could also say that we are referencing
    data, using referenced data, or that a data value is accessed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the definition of two functions, the same two functions we used
    in our previous examples. Look at the data types specified for the `point` parameter
    on each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Being a borrow or mutable borrow is part of the data type for the parameter.
    That means that the compiler knows the value passed to the parameter must be a
    borrow and will refuse to compile code that tries to pass a non-borrowed value
    to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, using a borrowed value is the same as using a non-borrowed
    value, as we can see in these functions. They interact with `point` just as if
    it were a locally owned variable.
  prefs: []
  type: TYPE_NORMAL
- en: However, that's because the compiler is smart. The truth is that a borrow is
    a memory address for a data value, not the data value itself (which is the bytes
    stored in memory *at* that address). Most of the time, the compiler can figure
    out that it needs to take the extra step of looking in the local variable for
    the address, then looking in memory at that address for the data, rather than
    just looking in the local variable for the data.
  prefs: []
  type: TYPE_NORMAL
- en: This process is called **dereferencing***.* For some reason, nobody ever says
    **deborrowing**.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when the compiler can't figure out that we want to dereference
    and handle it automatically. In those situations, we can use the `*` symbol to
    manually dereference a borrowed value.
  prefs: []
  type: TYPE_NORMAL
- en: The most common place where this comes up is in assigning to a borrowed value.
    If the borrowed value is a structure or something that has internal data, we can
    assign to the internal data with no problem, but when we want to assign a whole
    new value to a borrowed variable, we need to use dereferencing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code tries to assign the value as if it weren''t a borrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that `value` is a mutable borrow of a 32-bit unsigned integer. When
    we try to assign to that variable directly, the compiler tells us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6479fd9f-79b6-4736-952d-2f6f19640e19.png)'
  prefs: []
  type: TYPE_IMG
- en: What's happening here is that there's no way for the compiler to tell the difference
    between *I want to assign this value to be what is stored in memory at the referenced
    location* and *I want this reference variable to refer to a different memory location*.
    It needs to assume one of those and let us tell it if we want the other, and the
    assumption it picks is the second one.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to pick *assign a new value to this variable* as the default,
    since that's what `=` means in any other situation as well. Working with borrowed
    data is a special case, not the default.
  prefs: []
  type: TYPE_NORMAL
- en: The advice given by the compiler here is also based on the assumption that what
    we want to do is have `value` refer to a new memory address, which means that
    if we were to follow it blindly, the compiler error would go away, but the program
    would not do what we want. Instead of storing the number 6 in the borrowed variable,
    it would set the `value` variable to contain a new borrow.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we actually want to do is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That tells the compiler that instead of assigning *to* `value`, we want to assign
    *through* `value` to the originally borrowed variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `*` symbol can be used for both reading and writing the borrowed value,
    and can be used even when not strictly required if we want to be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Even though dereferencing and multiplication are written using the same symbol,
    the compiler never gets them confused. Multiplication is not a valid operation
    on a borrow, and dereferencing isn't a valid operation on a number. Additionally,
    multiplication always needs a data value on both sides of the `*`, while dereferencing
    always needs a data value on only one side. Between those two pieces of information,
    the compiler has more than enough to know which operation we're asking for.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of borrowed data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Borrows can not last longer than the data value that they're borrowing. The
    Rust compiler has to make sure that no part of the program could allow that to
    happen, which means that it has to keep track of the **lifetime** of every borrow.
    In the examples we've seen so far, that's easy, because each borrow was created
    when we called a function and ended when the function returned, while the values
    that were borrowed lived until the end of the block expression that contained
    the function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetimes of the borrows were obviously shorter than the lifetimes of the
    variables, beginning later and ending sooner.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's not hard to create situations where the compiler needs us to give
    it a hint about how long a borrow can exist, or how long the borrowed value will
    remain valid. We've already seen that once, when we used `&'static str` as the
    error type in `Result`. As we now know, this is an immutable reference to `str` ,
    but there's still that `'static` part to understand.
  prefs: []
  type: TYPE_NORMAL
- en: When we write something such as `'static` or `'a` after an `&` symbol, we're
    telling Rust that the lifetime of that reference has a name, which it recognizes
    because all lifetime names start with the `'` symbol. If we say that a borrow's
    lifetime is named `'a`, then we can use that name elsewhere to describe the relationship
    of that lifetime with the lifetimes of other borrows.
  prefs: []
  type: TYPE_NORMAL
- en: The static lifetime is special, because it's used for data values that are always
    available, as long as the program is running, such as the string constants we
    used as error messages in our examples earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It's most useful to give names to lifetimes when we're defining functions, because
    we don't know what data values are going to be filled in to the function's parameter
    variables. If some of those parameters are borrows, we need to be able to tell
    Rust what our expectations are about the lifetimes of those borrows, so it can
    make sure that the code that calls our functions is doing it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function that Rust can''t safely compile, because it needs to know
    more about the lifetimes than we''ve told it (yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that we're receiving two borrowed parameters in this function,
    each of which could have a different lifetime, and returning another borrowed
    value . Unfortunately, the Rust compiler doesn't know which parameter the return
    value will be borrowed from or what its lifetime is, and so it can't properly
    check the use of that value with code that calls our `smaller_x` function. Since
    it can't be sure everything is correct, the compiler simply refuses to try.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this by adding lifetime annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here is use the name `'a` for the lifetimes of all three borrowed
    values, and also put `'a` between `<` and `>`, between the function name and the
    parameter list. The `<` and `>` mark the beginning and end of the function's **generic
    parameter** list, which we'll talk about more in [Chapter 7](4b9cbf75-975c-4f6f-a1d3-7832a83cffae.xhtml), *Generic
    Types*. For now, what's important is that we're telling Rust that there is a lifetime
    that is equal to *or shorter than* the actual lifetimes of both `value1` and `value2`,
    which is called `'a`, and that the return value is safe to use within that `'a`
    lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a lifetime name *never* changes the actual lifetime of a borrow.
    If `value1` and `value2` have different lifetimes, specifying `'a` for them here
    doesn't make one of them last longer, nor does it shorten the span of the other
    one. When applied to the parameters, a lifetime name tells Rust that the named
    lifetime must be *compatible with* that parameter, meaning that the named lifetime
    must be wholly contained within the actual lifetime of the parameter. Then, when
    we use the same name for the return value's lifetime, we're telling Rust that
    the return value will only be guaranteed to be valid within the same limits—in
    this case, while *both* of the parameters are still valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust uses that guarantee to check the calling code. If we tried something like
    this, the Rust compiler would refuse, because we''re trying to use the returned
    value in a way that might be incorrect, and Rust doesn''t deal in maybes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a block expression between the `{` and the `}`, like we saw in [Chapter
    2](ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml), *Basics of the Rust Language*,
    which means it has its own scope, which owns the `main_5` variable. That means
    that, when we create a borrow of `main_5`, it has a shorter lifetime than a borrow
    of the `main_4` variable. Rust looks at the function definition for `smaller_x`
    and sees that the return value is only guaranteed valid within the lifetimes of
    both `main_4` and `main_5`, so trying to use it after the block expression has
    ended produces a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: This is a compiler error even though *in fact* `main_4` contains the `smaller_x`,
    and so the return value is a borrow of a value that will still be valid when we
    get to the print command. Rust doesn't analyze the logic of a function when it's
    checking lifetimes, it just looks at what we've told it about the parameters and
    return.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good thing. In this case, it would have been possible to examine the
    values used for the parameters, recognize that they are constant values that will
    always result in the same behavior from the function, and logically reason out
    that the lifetime of the returned borrow is equal to the lifetime of the first
    parameter. However, in general, that sort of reasoning would not be possible (what
    if the first parameter was input by the user?), and attempting it would just cause
    problems. Imagine changing the source of a variable's value, and suddenly having
    compiler errors way off in some other part of the program that shouldn't care!
    It's better to have these things as a concrete part of a function's interface.
  prefs: []
  type: TYPE_NORMAL
- en: Ownership and the self parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen before, when we implement behavior for a type, the functions we
    define have `self`, `&self`, or `&mut self` as the first parameter. We now understand
    enough to recognize that that means that `self` is either moved (or copied) into
    the scope of the function, borrowed, or mutably borrowed. Which one we choose
    to use can have some pretty important consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data type of `self` is implicit: it''s got to be the data type we''re implementing
    the function on and, because of that, we don''t get to specify the data type for
    `self` as part of the parameter list. Since there is no data type to prefix `&`
    or `&mut` to, we are allowed to write them before `self` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In all three cases, `self` means *the data value that this function was called
    through*. If we have a `u32` variable named `x` and we tell Rust to `x.pow(3)`,
    the `pow` function implemented for `u32` will receive *two* parameters: the value
    of `x` as `self`, and `3` as the second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The same rules apply to moving, borrowing, and mutably borrowing the `self`
    value as they apply to any other value. If we currently have any borrows of a
    value, we can't mutably borrow it into `self`, nor can we move it (because that
    would invalidate the existing borrows). If we currently have a mutable borrow
    of the value, we can't borrow it or move it into `self`, because mutable borrows
    do not allow anyone else to borrow or change the value. Similarly, borrowing into
    a function's `self` affects how we can access the data in other places, because
    it *is* a borrow, and there are rules about how borrows coexist.
  prefs: []
  type: TYPE_NORMAL
- en: Moving self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the `self` value is moved into the function, it''s just like moving any
    other value; we can''t continue to use it where it used to be anymore. Here is
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This can be said to *consume* the `self` value. The value is moved into the
    function's scope when it is called, and the old variable that used to contain
    the value is no longer usable. This particular function returns a new, different `Point2D`
    value, so the value of `self` is completely gone once this function is done running.
  prefs: []
  type: TYPE_NORMAL
- en: There are reasons why this might be exactly the behavior we want. In the previous
    example, the function transforms the `self` value into something new, which is
    reflected by having it consume the old value.
  prefs: []
  type: TYPE_NORMAL
- en: A very common use of functions that consume `self` is the **builder pattern**.
    This is a design pattern in Rust where we construct complex data structures bit
    by bit by filling in values to a builder structure, and then call a build function
    implemented on the builder structure to construct our final data value. Most of
    the time, the build function will consume its `self`, since each builder value
    should be used to construct only one final value.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern is essentially a way to use Rust's syntax to achieve the
    same things that are achieved by keyword arguments and default values in some
    other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Any time the value of `self` will be invalidated by what the function does,
    either literally or conceptually, it makes sense to move `self` into the function's
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the `self` value is immutably borrowed into a function, then that function
    has read-only access to the value. This is useful in many situations, because
    it lets us call the function without making a copy of the `self` value for it
    to operate on, and without making the compiler ensure that the rules of write
    access are maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a function that immutably borrows `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function returns ![](img/2c60b426-f1c8-448c-93f7-d284a1ab7624.png), or
    in other words, the distance between the point stored in `self` and the origin
    of the coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: The magnitude function doesn't need to change `self`, so there's no reason for
    it to use a mutable borrow and deal with the restrictions that implies. It could
    have worked with a moved `self`, but there's nothing wrong with calling the magnitude
    function twice on the same value, so that isn't what we want either.
  prefs: []
  type: TYPE_NORMAL
- en: Using an immutable borrow for `self` is most often the correct choice. We need
    a reason to use `self` or `&mut self`, and if we don't have such a reason, we
    use `&self`.
  prefs: []
  type: TYPE_NORMAL
- en: Mutably borrowing self
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a function needs to change its `self`. For those situations, we can
    receive `self` as a mutable borrow with `&mut self`. Like any other time we create
    a mutable borrow, we can only call such a function if we have the value for `self`
    stored in a mutable variable, and that value is not currently borrowed anywhere
    else. In other words, we can only call functions that have write access to a value
    when we ourselves have write access to that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have an example function that mutable borrows `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We see several things here. First, we are able to call the read-only `magnitude`
    function on `self`, even though that function takes its `self` as an immutable
    borrow, and we''ve got our `self` value as a mutable borrow. The reverse is not
    true: if we tried to call the `unit` function from inside of the `magnitude` function,
    the compiler would refuse to allow it.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, since we have write access to `self`, we can change the data stored
    in it. That's what write access means.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we don't have a return type specified for this function. Technically,
    it defaults to returning `()`, but that's just another way of saying it doesn't
    return anything meaningful. It's common practice for functions that change `self`
    to not return a value or to return a `Result` with `()` as its success value if
    the function needs the ability to report errors. That's because the real result
    of the function is the updated `self` value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ownership is the thing that most separates Rust from other programming languages.
    It's an idea that seems obvious at first, then surprisingly complicated, and finally
    powerful and useful. Ownership gives Rust its nearly-free automatic memory management,
    along with things such as safe and easy multithreading and concurrency, and just
    generally being able to spot more errors in the compiler than other languages
    can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Borrowing makes use of ownership to create a safe version of one of the biggest
    problem points for other languages: accessing data via a memory address. Mistakes
    with memory addresses are one of the most common problems programs encounter and,
    in Rust, those mistakes are caught by the compiler and reported along with helpful
    hints about how to address them.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also looked at how to implement consuming, read-only, or
    read-write functions for data types, based on whether they move, borrow, or mutably
    borrow their `self` value, and discussed an assortment of errors that the compiler
    might report in various situations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn about how to use pattern matching
    on data types to make decisions.
  prefs: []
  type: TYPE_NORMAL
