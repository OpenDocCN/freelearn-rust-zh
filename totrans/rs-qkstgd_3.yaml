- en: The Big Ideas – Ownership and Borrowing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大概念——所有权和借用
- en: Ownership and borrowing are the features that set Rust apart from other programming
    languages. The closest equivalent that you're likely to find is the **Resource
    Aquisition Is Instantiation** (**RAII**) design pattern common in C++, but that's
    a design pattern, not a language feature, and is not fully analogous.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权和借用是使Rust与其他编程语言区分开来的特性。你可能会找到最接近的等效物是C++中常见的**资源获取即初始化**（**RAII**）设计模式，但那是一个设计模式，不是一个语言特性，并且并不完全类似。
- en: 'In this chapter, we''re going to talk about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Ownership of values and the scope of variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的所有权和变量的作用域
- en: The ways that ownership is transferred between scopes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域之间所有权转移的方式
- en: Borrowing and lending data values, and how that interacts with ownership
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借用和借出数据值，以及这与所有权如何交互
- en: The lifetime of borrowed values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借用值的生命周期
- en: The `self` parameter of functions, and the implications of borrowing or not
    borrowing it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的`self`参数，以及借用或不借用它的含义
- en: Scope and ownership
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和所有权
- en: In Rust, every data value has a single owning scope—no more, no less. So, what's
    a scope? The easy answer is that a scope is the place where a block expression
    stores its variables. Scopes are not directly represented in the source code,
    but a scope begins when a block expression begins, with a `{` symbol, and ends
    when the block expression ends, with `}` (or when a `return` statement is run
    before the block reaches its end). The scope is the chunk of memory where the
    block's variables are stored.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，每个数据值都有一个单一的所有作用域——不多也不少。那么，什么是作用域呢？简单的答案是，作用域是块表达式存储其变量的地方。作用域在源代码中不是直接表示的，但作用域从块表达式开始时开始，以`{`符号为标志，并在块表达式结束时结束，以`}`（或当在块达到其结束之前运行`return`语句时）。作用域是存储块变量的内存块。
- en: '*Every* data value has an owning scope, including implied temporary values
    such as the result of `2 + 2` when we ask Rust to compute `(2 + 2) * 3`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个*数据值都有一个所有作用域，包括像`2 + 2`这样的隐式临时值，当我们要求Rust计算`(2 + 2) * 3`时。'
- en: When Rust is done with a scope, all of the data values that scope owns are discarded
    and the memory that was used to store them is freed up for other uses. This includes
    memory that was allocated on the **heap**, which we'll learn how to use in [Chapter
    6](864ada48-1934-447e-8351-a88a1f9fccbb.xhtml), *Heap Memory and Smart Pointers*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当Rust完成一个作用域后，该作用域拥有的所有数据值都会被丢弃，用于存储它们的内存也会被释放出来供其他用途使用。这包括在**堆**上分配的内存，我们将在[第6章](864ada48-1934-447e-8351-a88a1f9fccbb.xhtml)中学习如何使用它，*堆内存和智能指针*。
- en: The time between when a value is created and the time when its owning scope
    is done is called the **lifetime** of the value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从值创建到其拥有作用域完成之间的时间称为值的**生命周期**。
- en: The stack
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: 'Like most programming languages, Rust uses a **stack** to handle memory management
    for scopes. A stack is a simple data structure, also referred to as a **Last In,
    First Out Queue** or **LIFO**. Stacks support two operations: **push**, which
    stores a new value, and `pop`*,* which removes and returns the most recently stored
    value.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，Rust使用**栈**来处理作用域的内存管理。栈是一种简单的数据结构，也被称为**后进先出队列**或**LIFO**。栈支持两种操作：**push**，用于存储新值，和`pop`*，*用于移除并返回最近存储的值。
- en: 'We can think of a stack as a pile of boxes. If we want to remove the stuff
    stored in the top box, we can just take it down and look inside. However, if we
    want to remove the stuff stored in one of the boxes underneath, we first have
    to remove the boxes above it. Here''s a diagram of what I''m talking about, with
    access to the boxes underneath blocked by the ones above them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将栈想象成一堆盒子。如果我们想取出顶部盒子中存储的东西，我们只需将其取下并查看里面的内容。然而，如果我们想取出下面某个盒子中存储的东西，我们首先必须移除上面的盒子。以下是我所描述内容的示意图，其中下面的盒子被上面的盒子阻挡，无法访问：
- en: '![](img/37dac796-847b-404c-af01-64c3a6fbda64.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37dac796-847b-404c-af01-64c3a6fbda64.png)'
- en: When a Rust block expression starts, it makes a note of how tall the stack is
    and, when the block ends, it removes things from the stack until the stack is
    the same height as it was to begin with. In between, when the block needs to store
    a new value, it pushes that value onto the stack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当Rust块表达式开始时，它会记录栈的高度，当块结束时，它会从栈中移除东西，直到栈的高度与开始时相同。在中间，当块需要存储新值时，它会将那个值推入栈中。
- en: When a value is removed from the stack, the Rust compiler also makes sure to
    do any cleanup that is needed before discarding the value, including calling a
    custom cleanup function for the value if one is defined.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值从栈中移除时，Rust 编译器还会确保在丢弃值之前进行任何必要的清理，包括如果定义了自定义清理函数，则调用该值的自定义清理函数。
- en: Most programming languages do this, but not exclusively. In Rust, even when
    a data value uses heap memory, it is represented on the stack and controlled by
    the rules of ownership. By following that simple procedure, it's easy for Rust
    to handle all of the record keeping and memory management for a program, efficiently
    and with no garbage collection required.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都会这样做，但并非全部。在 Rust 中，即使数据值使用堆内存，它也会在栈上表示并由所有权规则控制。通过遵循这个简单的程序，Rust 可以高效地处理程序的记录保存和内存管理，而且不需要垃圾回收。
- en: 'Garbage collection is a mechanism used in many programming languages to remove
    the burden of memory management from the programmer. It''s even easier to use
    than Rust''s method, but it does require time for the garbage collection mechanism
    to run, which can impact program performance. Rust''s method is almost entirely
    deterministic at compile time: the Rust compiler knows when to allocate and deallocate
    memory without having to figure it out while the program runs.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是许多编程语言中用来减轻程序员内存管理负担的一种机制。它甚至比 Rust 的方法更容易使用，但它确实需要时间来运行垃圾回收机制，这可能会影响程序性能。Rust
    的方法在编译时几乎完全是确定性的：Rust 编译器知道何时分配和释放内存，而无需在程序运行时进行推断。
- en: Transferring ownership
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转移所有权
- en: 'It''s possible (and common) to transfer ownership of a value to a different
    scope. For example, we can do something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将值的所有权转移到不同作用域是可能的（并且很常见）。例如，我们可以这样做：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is happening is that the `main_1` variable is created and initialized under
    the ownership of the current scope (the value is pushed onto the stack), but then
    the ownership is transferred to the scope of the block expression that makes up
    the `receive_ownership` function's body, when the value is used as a function
    parameter. The compiler knows that the current scope is no longer responsible
    for cleaning up the value stored in `main_1`, because that job now belongs to
    a different scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正在发生的是，`main_1` 变量在当前作用域（值被推入栈）的所有权下创建和初始化，但当值作为函数参数使用时，所有权就转移到了构成 `receive_ownership`
    函数体代码块的作用域。编译器知道当前作用域不再负责清理存储在 `main_1` 中的值，因为这项工作现在属于不同的作用域。
- en: The bytes that represent the value on the stack are copied to a new location
    on the stack, within the scope that is receiving ownership. Most data values store
    some of their information outside of the stack, though, so the bytes that are
    left behind in the old scope are considered no longer meaningful or safe to use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表示栈上值的字节被复制到栈上的新位置，在接收所有权的范围内。然而，大多数数据值将它们的一些信息存储在栈外，因此，在旧作用域中留下的字节被认为不再有意义或安全使用。
- en: If we try to use the value stored in `main_1` after it has been moved to a different
    scope, as we're doing here with the second call to `receive_ownership`, the compiler
    will report an error. It's not just using the value as a function parameter that
    will cause an error, either. Any use of a value that has been moved is an error.
    It's no longer there to be used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在将 `main_1` 移动到不同作用域之后使用其存储的值，就像我们在对 `receive_ownership` 的第二次调用中所做的那样，编译器将报告错误。不仅仅是将值用作函数参数会导致错误，任何对已移动值的任何使用都是错误。它不再存在以供使用。
- en: 'Ownership can also be transferred in the other direction. This function receives
    ownership of its parameter, but then returns the parameter (and hence the ownership)
    back to the block where it was called:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权也可以向相反的方向转移。这个函数接收其参数的所有权，但随后将参数（以及所有权）返回到调用它的代码块：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That doesn't mean that the original variable (`main_1`) becomes usable again,
    but if we assign the return value from the function to a variable, we can continue
    using that value through the new variable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着原始变量（`main_1`）再次变得可使用，但如果我们将函数的返回值赋给一个变量，我们就可以通过这个新变量继续使用这个值。
- en: 'Ownership can also be transferred "sideways" by assigning a value to a different
    variable. We do something like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权也可以通过将值赋给不同的变量“横向”转移。我们做类似这样的事情：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the value stored in `main_2` is moved to `main_4`. In this basic example,
    that's not particularly interesting; we've just got a new variable containing
    the value that the old variable used to contain, and they're both in the same
    scope anyway. This gets more interesting when we do things like assigning a value
    to a structure member, especially when the structure has a different lifetime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，存储在`main_2`中的值被移动到`main_4`。在这个基本示例中，这并不特别有趣；我们只是得到了一个新变量，它包含旧变量曾经包含的值，而且它们都在同一个作用域内。当我们像将值赋给结构体成员那样做事情时，这会更有趣，尤其是当结构体具有不同的生命周期时。
- en: 'Rust''s compiler is very careful about ownership, and when it detects a situation
    where ownership is not properly respected, or even *might not* be properly respected,
    it reports an error. The following function will not compile, because it is only
    valid when the `switch` parameter is `false`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的编译器对所有权非常小心，当它检测到所有权没有得到适当尊重的情况，或者甚至可能没有得到适当尊重的情况时，它会报告错误。以下函数将无法编译，因为它仅在`switch`参数为`false`时有效：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we try to compile the `uncertain_ownership` function, we get output like
    this from the compiler:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译`uncertain_ownership`函数时，编译器会输出如下信息：
- en: '![](img/670d92c5-49b3-48ec-ae29-2456fd8d7459.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/670d92c5-49b3-48ec-ae29-2456fd8d7459.png)'
- en: As far as the compiler is concerned, if we could have moved the value before
    using it, we don't get to use it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器而言，如果我们能够在使用它之前移动该值，我们就无法使用它。
- en: Copying
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: In the compiler error discussed at the end of the *Transferring ownership* section
    of this chapter, we see that the compiler noted that the data value is moved because
    it *does not implement the* `Copy` *trait*, which is interesting. What does that
    mean?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章“转移所有权”部分的末尾讨论的编译器错误中，我们看到编译器指出数据值被移动，因为它没有实现`Copy`特质，这很有趣。这意味着什么呢？
- en: For some data types, particularly the primitive types such as integers and floating-point
    numbers, copying the bytes that represent them on the stack is all that is required
    to actually make a complete working copy of the data value. In other words, their
    representation does not refer to anything stored elsewhere in memory or otherwise
    rely on ownership to keep everything correct.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些数据类型，尤其是像整数和浮点数这样的原始类型，复制表示它们的栈上的字节就足以实际上制作一个完整的工作副本。换句话说，它们的表示不引用内存中存储的其他任何内容，也不依赖于所有权来保持一切正确。
- en: There are a number of data types in the standard library that could have the
    `Copy` trait as far as memory usage is concerned, but make use of ownership to
    keep other things safe and correct. Examples include data types that represent
    access to external resources such as files or network sockets, and data types
    having to do with concurrency. Ownership has turned out to be an even more powerful
    tool than was originally expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有许多数据类型在内存使用方面可以具有`Copy`特质，但利用所有权来保持其他事物的安全性和正确性。例如，表示对文件或网络套接字等外部资源访问的数据类型，以及与并发有关的数据类型。所有权已经证明比最初预期的更强大的工具。
- en: Data types that do not rely on ownership at all are said to have the `Copy`
    trait. We'll see how to declare that our own data types have the Copy trait in
    [Chapter 8](a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml), *Important Standard Traits*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不依赖所有权的那些数据类型被称为具有`Copy`特质。我们将在[第8章](a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml)，“重要标准特质”中看到如何声明我们的数据类型具有`Copy`特质。
- en: 'When a value''s data type has the Copy trait, Rust doesn''t move the value
    when it is transferred. The receiver still receives the value, but the old value
    remains valid. Instead of moving, the value has been copied. This function has
    almost exactly the same structure as the `uncertain_ownership` function, which
    refuses to compile:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值的数据类型具有`Copy`特质时，Rust在转移值时不会移动该值。接收者仍然接收该值，但旧值仍然有效。而不是移动，值已经被复制。这个函数的结构几乎与`uncertain_ownership`函数完全相同，后者拒绝编译：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The important difference here is that `local` contains a floating-point value
    and the floating-point data types have the Copy trait, which means that even though
    the value of `local` is placed inside of a `Point2D` structure, and that structure
    is then moved to the `receive_ownership` function's scope, `local` remains valid
    in the current scope. That's because the value of `local` wasn't moved into `Point2D`.
    It was copied.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的区别是`local`包含一个浮点值，而浮点数据类型具有Copy trait，这意味着尽管`local`的值被放置在`Point2D`结构体内部，并且该结构体随后被移动到`receive_ownership`函数的作用域中，`local`在当前作用域中仍然有效。这是因为`local`的值并没有被移动到`Point2D`中。它是被复制的。
- en: The fact that we used a structure initializer to assign the value of `local`
    instead of using an `=` symbol makes no difference. Either way, it's an assignment,
    and either way, the data type's Copy trait determines whether the assignment is
    a copy or a move.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用结构初始化器来分配`local`的值，而不是使用`=`符号，这并不会造成任何区别。无论是哪种方式，它都是一个赋值操作，并且无论是哪种方式，数据类型的Copy
    trait都会决定赋值是复制还是移动。
- en: Lending
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借贷
- en: There's one more way we can send information to a different scope and that is
    by **lending**. When we move a data value, the receiving scope becomes the value's
    new owner. When we copy a data value, the receiving scope owns the duplicate it
    received, and the sending scope retains ownership of the original. When we lend
    a data value, things can get more complicated, because the original scope retains
    ownership, but the receiving scope is still allowed to access the data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过**借贷**的方式将信息发送到不同的作用域。当我们移动一个数据值时，接收的作用域成为该值的新所有者。当我们复制一个数据值时，接收的作用域拥有它接收的副本，而发送的作用域保留对原始值的所有权。当我们借贷一个数据值时，事情可能会变得更加复杂，因为原始作用域保留了所有权，但接收的作用域仍然可以访问数据。
- en: The original scope still owns the data, which means that, when that scope ends,
    the data will go away. If some of the scope's contained data was still loaned
    to a different scope at that time, the program would likely crash and, since the
    Rust compiler hates potential crashes, it does not allow us to get into that situation.
    Instead, it requires that any borrowed information must be returned before the
    owning scope's time is up.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 原始作用域仍然拥有数据，这意味着当该作用域结束时，数据将会消失。如果在那时作用域中包含的一些数据仍然借给了不同的作用域，程序可能会崩溃，由于Rust编译器讨厌潜在的崩溃，它不允许我们陷入那种情况。相反，它要求在拥有作用域的时间结束之前，必须返回任何借用的信息。
- en: When a data value is borrowed, that value is neither copied nor moved. The bytes
    that represent that value on the stack stay right where they were. Instead, the
    borrower receives the memory address of those bytes on the stack, allowing it
    to violate the conceptual idea of a stack by accessing information stored below
    the top, probably in a different scope entirely. You can see why the compiler
    wants to be careful about that!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据值被借用时，该值既没有被复制也没有被移动。表示该值在栈上的字节仍然保持在原来的位置。相反，借用人接收这些字节在栈上的内存地址，这使得它可以违反栈的概念性想法，通过访问存储在顶部以下的信息，可能在完全不同的作用域中。你可以看到为什么编译器想要对此小心谨慎！
- en: 'A currently borrowed data value can''t be changed by the owner, even if the
    data value is stored in a mutable variable. This is part of keeping lending from
    causing problems: a data value can only ever be changed in one place at a time
    at most and, when it *can* be changed, it''s never in use elsewhere.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当前借用的数据值不能被所有者更改，即使数据值存储在一个可变变量中。这是防止借贷引起问题的部分：数据值最多只能在一个地方更改一次，并且当它*可以*更改时，它永远不会在其他地方被使用。
- en: Lending immutably
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变借贷
- en: When lending, the default is to lend the data **immutably**, meaning that the
    borrowed data can be read, but not changed. We can lend immutably to more than
    one borrower at the same time, which is safe because none of them can change the
    borrowed data, and so they can't interfere with each other by changing the data
    value unexpectedly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在借贷时，默认情况下是进行不可变借贷，这意味着借用的数据可以读取，但不能更改。我们可以同时向多个借用人进行不可变借贷，这是安全的，因为它们中没有人可以更改借用的数据，因此它们不能通过意外更改数据值来相互干扰。
- en: 'To create an immutable borrow, we prefix the expression producing the data
    value with `&`, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不可变借用，我们需要在产生数据值的表达式前加上`&`，如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're calling a function called `borrow_ownership`, and passing it a data
    value borrowed from the `main_3` variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用一个名为`borrow_ownership`的函数，并向它传递从`main_3`变量借用的数据值。
- en: Lending mutably
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变借贷
- en: Sometimes, we want to lend a data value and allow the receiver to modify it,
    so that, after the borrow has ended, the data value in the owning scope has changed.
    When that's what we need, we lend the data **mutably**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望借出一个数据值并允许接收者修改它，以便在借用结束后，拥有作用域中的数据值已发生变化。当我们需要这样做时，我们以**可变**的方式借出数据。
- en: 'We can''t lend mutably unless the data value we''re lending is stored in a
    mutable variable, which means that the `mut` keyword was used when we declared
    the variable, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能在借出的数据值存储在可变变量中时才能以可变方式借出，这意味着我们在声明变量时使用了`mut`关键字，如下所示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given that we have a mutable variable to lend, we can create a mutable borrow
    of that variable''s value, by using the `mut` keyword *again*, in a different
    context:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个可变变量可以借出，我们可以通过使用`mut`关键字**再次**，在不同的上下文中创建该变量值的可变借用：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If there's a mutable borrow of a data value, creating another borrow for it (of
    either sort) is impossible and, if there are any immutable borrows, then creating
    a mutable borrow is impossible. That rule means that if a data value is mutably
    borrowed, it's not borrowed anywhere else. Combined with the rule we discussed
    earlier that prevents borrowed data from being changed by its real owner, that
    means that as long as there's a mutable borrow active, that borrow is the only
    way to modify the borrowed data value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个数据值的可变借用，则无法为其创建另一个借用（无论是哪种类型），如果存在任何不可变借用，则创建可变借用是不可能的。这条规则意味着如果一个数据值是可变借用的，那么它不会在其他任何地方被借用。结合我们之前讨论的规则，该规则防止借用数据被其实际所有者更改，这意味着只要存在一个活动的可变借用，那么这个借用就是修改借用数据值的唯一方式。
- en: However, once the borrow is finished, the owner regains control of the (possibly
    modified) data value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦借用结束，所有者就会重新获得对（可能已修改的）数据值的控制权。
- en: Accessing borrowed data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问借用数据
- en: To receive borrowed data, we need to properly specify the data type as a borrow.
    That is done by using `&` or `&mut` with the data type on the receiving end, just
    as we used them with the data value on the sending end.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收借用数据，我们需要正确指定数据类型作为借用。这是通过在接收端使用`&`或`&mut`与数据类型一起完成的，就像我们在发送端使用数据值一样。
- en: While the term *borrow* is common in Rust, the technical term is **reference**.
    So, we will usually say we are borrowing data, using borrowed data, or that a
    data value is accessed as a borrow, but we could also say that we are referencing
    data, using referenced data, or that a data value is accessed by reference.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*Rust*中常用术语*借用*，但技术术语是**引用**。因此，我们通常会说我正在借用数据，使用借用数据，或者一个数据值作为借用被访问，但我们也可以说我们在引用数据，使用引用数据，或者一个数据值通过引用被访问。
- en: 'Here, we have the definition of two functions, the same two functions we used
    in our previous examples. Look at the data types specified for the `point` parameter
    on each one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个函数的定义，与我们在之前的示例中使用的相同两个函数。看看每个函数中为`point`参数指定的数据类型：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Being a borrow or mutable borrow is part of the data type for the parameter.
    That means that the compiler knows the value passed to the parameter must be a
    borrow and will refuse to compile code that tries to pass a non-borrowed value
    to the function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为借用或可变借用是参数数据类型的一部分。这意味着编译器知道传递给参数的值必须是一个借用，并且会拒绝编译尝试将非借用值传递给函数的代码。
- en: Most of the time, using a borrowed value is the same as using a non-borrowed
    value, as we can see in these functions. They interact with `point` just as if
    it were a locally owned variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，使用借用值和使用非借用值相同，正如我们可以在这些函数中看到的那样。它们与`point`交互，就像它是一个局部拥有的变量一样。
- en: However, that's because the compiler is smart. The truth is that a borrow is
    a memory address for a data value, not the data value itself (which is the bytes
    stored in memory *at* that address). Most of the time, the compiler can figure
    out that it needs to take the extra step of looking in the local variable for
    the address, then looking in memory at that address for the data, rather than
    just looking in the local variable for the data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那是因为编译器很聪明。事实是，借用是一个数据值的内存地址，而不是数据值本身（这是存储在内存**中**的字节）。大多数时候，编译器可以弄清楚它需要采取额外的步骤，查找局部变量中的地址，然后在那个地址的内存中查找数据，而不是只在局部变量中查找数据。
- en: This process is called **dereferencing***.* For some reason, nobody ever says
    **deborrowing**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为**解引用**。*由于某种原因，没有人说**还借**。
- en: There are times when the compiler can't figure out that we want to dereference
    and handle it automatically. In those situations, we can use the `*` symbol to
    manually dereference a borrowed value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候编译器无法确定我们想要解引用并自动处理它。在这些情况下，我们可以使用`*`符号手动解引用一个借用值。
- en: The most common place where this comes up is in assigning to a borrowed value.
    If the borrowed value is a structure or something that has internal data, we can
    assign to the internal data with no problem, but when we want to assign a whole
    new value to a borrowed variable, we need to use dereferencing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况最常见的地方是在对借用值进行赋值时。如果借用值是一个结构体或者具有内部数据的某种东西，我们可以毫无问题地对内部数据进行赋值，但当我们想要对一个借用变量赋予一个全新的值时，我们需要使用解引用。
- en: 'This code tries to assign the value as if it weren''t a borrow:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码试图像它不是一个借用一样对值进行赋值：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We see that `value` is a mutable borrow of a 32-bit unsigned integer. When
    we try to assign to that variable directly, the compiler tells us this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`value`是一个32位无符号整数的可变借用。当我们尝试直接对该变量进行赋值时，编译器会告诉我们这一点：
- en: '![](img/6479fd9f-79b6-4736-952d-2f6f19640e19.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6479fd9f-79b6-4736-952d-2f6f19640e19.png)'
- en: What's happening here is that there's no way for the compiler to tell the difference
    between *I want to assign this value to be what is stored in memory at the referenced
    location* and *I want this reference variable to refer to a different memory location*.
    It needs to assume one of those and let us tell it if we want the other, and the
    assumption it picks is the second one.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，编译器无法区分**我想将这个值赋给内存中引用位置存储的内容**和**我想让这个引用变量指向不同的内存位置**。它需要假设其中之一，并让我们告诉它如果我们想要另一个，它选择的假设是第二个。
- en: It makes sense to pick *assign a new value to this variable* as the default,
    since that's what `=` means in any other situation as well. Working with borrowed
    data is a special case, not the default.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个变量**赋予一个新值**作为默认值是有意义的，因为在任何其他情况下，`=`都代表这个意思。处理借用数据是一个特殊情况，而不是默认情况。
- en: The advice given by the compiler here is also based on the assumption that what
    we want to do is have `value` refer to a new memory address, which means that
    if we were to follow it blindly, the compiler error would go away, but the program
    would not do what we want. Instead of storing the number 6 in the borrowed variable,
    it would set the `value` variable to contain a new borrow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在这里给出的建议也是基于这样的假设：我们想要的是`value`指向一个新的内存地址，这意味着如果我们盲目地遵循它，编译器错误会消失，但程序不会做我们想要的事情。它不会在借用变量中存储数字6，而是会将`value`变量设置为包含一个新的借用。
- en: 'What we actually want to do is this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要做的是这样：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That tells the compiler that instead of assigning *to* `value`, we want to assign
    *through* `value` to the originally borrowed variable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器，我们不是要**对`value`进行赋值**，而是要通过`value`对最初借用的变量进行赋值。
- en: The `*` symbol can be used for both reading and writing the borrowed value,
    and can be used even when not strictly required if we want to be explicit.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`符号可以用来读取和写入借用值，即使不是严格必需的，如果我们想明确表示也可以使用。'
- en: Even though dereferencing and multiplication are written using the same symbol,
    the compiler never gets them confused. Multiplication is not a valid operation
    on a borrow, and dereferencing isn't a valid operation on a number. Additionally,
    multiplication always needs a data value on both sides of the `*`, while dereferencing
    always needs a data value on only one side. Between those two pieces of information,
    the compiler has more than enough to know which operation we're asking for.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解引用和乘法使用的是相同的符号，但编译器永远不会将它们混淆。乘法在借用上不是一个有效的操作，而解引用在数字上也不是一个有效的操作。此外，乘法总是需要在`*`的两侧都有数据值，而解引用只需要在一边有数据值。在这两块信息之间，编译器有足够的信息知道我们要求的是哪种操作。
- en: The lifetime of borrowed data
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用数据的生命周期
- en: Borrows can not last longer than the data value that they're borrowing. The
    Rust compiler has to make sure that no part of the program could allow that to
    happen, which means that it has to keep track of the **lifetime** of every borrow.
    In the examples we've seen so far, that's easy, because each borrow was created
    when we called a function and ended when the function returned, while the values
    that were borrowed lived until the end of the block expression that contained
    the function calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 借用不能比它们借用的数据值存在的时间更长。Rust编译器必须确保程序中没有任何部分允许这种情况发生，这意味着它必须跟踪每个借用的**生命周期**。在我们迄今为止看到的例子中，这很简单，因为每个借用都是在调用函数时创建的，并在函数返回时结束，而借用的值则一直存活到包含函数调用的代码块表达式结束。
- en: The lifetimes of the borrows were obviously shorter than the lifetimes of the
    variables, beginning later and ending sooner.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 借用的生命周期显然比变量的生命周期短，开始得晚，结束得早。
- en: However, it's not hard to create situations where the compiler needs us to give
    it a hint about how long a borrow can exist, or how long the borrowed value will
    remain valid. We've already seen that once, when we used `&'static str` as the
    error type in `Result`. As we now know, this is an immutable reference to `str` ,
    but there's still that `'static` part to understand.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建需要我们向编译器提供有关借用存在时间或借用值有效时间提示的情况并不困难。我们之前已经见过一次，当时我们在`Result`中将`&'static
    str`用作错误类型。正如我们所知，这是一个对`str`的不可变引用，但还有那个`'static`部分需要理解。
- en: When we write something such as `'static` or `'a` after an `&` symbol, we're
    telling Rust that the lifetime of that reference has a name, which it recognizes
    because all lifetime names start with the `'` symbol. If we say that a borrow's
    lifetime is named `'a`, then we can use that name elsewhere to describe the relationship
    of that lifetime with the lifetimes of other borrows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`&`符号后面写上`'static`或`'a`时，我们是在告诉Rust那个引用的生命周期有一个名字，它通过所有生命周期名称都以`'`符号开头来识别。如果我们说一个借用的生命周期被命名为`'a`，那么我们可以在其他地方使用那个名字来描述该生命周期与其他借用生命周期的关系。
- en: The static lifetime is special, because it's used for data values that are always
    available, as long as the program is running, such as the string constants we
    used as error messages in our examples earlier.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态生命周期是特殊的，因为它用于始终可用的数据值，只要程序在运行，例如我们在之前的示例中用作错误信息的字符串常量。
- en: It's most useful to give names to lifetimes when we're defining functions, because
    we don't know what data values are going to be filled in to the function's parameter
    variables. If some of those parameters are borrows, we need to be able to tell
    Rust what our expectations are about the lifetimes of those borrows, so it can
    make sure that the code that calls our functions is doing it correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义函数时，给生命周期命名最有用，因为我们不知道将要填充到函数参数变量中的数据值是什么。如果其中一些参数是借用，我们需要能够告诉Rust我们对这些借用生命周期的期望，以便它可以确保调用我们的函数的代码是正确进行的。
- en: 'Here is a function that Rust can''t safely compile, because it needs to know
    more about the lifetimes than we''ve told it (yet):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个Rust无法安全编译的函数，因为它需要比我们告诉它的更多关于生命周期的信息（尚未告知）：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The problem here is that we're receiving two borrowed parameters in this function,
    each of which could have a different lifetime, and returning another borrowed
    value . Unfortunately, the Rust compiler doesn't know which parameter the return
    value will be borrowed from or what its lifetime is, and so it can't properly
    check the use of that value with code that calls our `smaller_x` function. Since
    it can't be sure everything is correct, the compiler simply refuses to try.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在这个函数中我们接收了两个借用参数，每个参数可能具有不同的生命周期，并且返回另一个借用值。不幸的是，Rust编译器不知道返回值将借用哪个参数或其生命周期是什么，因此它无法正确检查调用我们的`smaller_x`函数时该值的用法。由于它无法确定一切是否正确，编译器简单地拒绝尝试。
- en: 'We can fix this by adding lifetime annotations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加生命周期注解来修复这个问题：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we've done here is use the name `'a` for the lifetimes of all three borrowed
    values, and also put `'a` between `<` and `>`, between the function name and the
    parameter list. The `<` and `>` mark the beginning and end of the function's **generic
    parameter** list, which we'll talk about more in [Chapter 7](4b9cbf75-975c-4f6f-a1d3-7832a83cffae.xhtml), *Generic
    Types*. For now, what's important is that we're telling Rust that there is a lifetime
    that is equal to *or shorter than* the actual lifetimes of both `value1` and `value2`,
    which is called `'a`, and that the return value is safe to use within that `'a`
    lifetime.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用名称`'a`来表示所有三个借用值的生命周期，并且还在`<`和`>`之间、函数名称和参数列表之间放置了`'a`。`<`和`>`标记了函数的**泛型参数**列表的开始和结束，我们将在[第7章](4b9cbf75-975c-4f6f-a1d3-7832a83cffae.xhtml)中更详细地讨论，*泛型类型*。现在，重要的是我们要告诉Rust存在一个生命周期，它等于或短于`value1`和`value2`的实际生命周期，称为`'a`，并且返回值可以在那个`'a`生命周期内安全使用。
- en: Specifying a lifetime name *never* changes the actual lifetime of a borrow.
    If `value1` and `value2` have different lifetimes, specifying `'a` for them here
    doesn't make one of them last longer, nor does it shorten the span of the other
    one. When applied to the parameters, a lifetime name tells Rust that the named
    lifetime must be *compatible with* that parameter, meaning that the named lifetime
    must be wholly contained within the actual lifetime of the parameter. Then, when
    we use the same name for the return value's lifetime, we're telling Rust that
    the return value will only be guaranteed to be valid within the same limits—in
    this case, while *both* of the parameters are still valid.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个生命周期名称**永远不会**改变借用实际的周期。如果`value1`和`value2`有不同的生命周期，在这里为它们指定`'a`不会使其中一个持续更长，也不会缩短另一个的范围。当应用于参数时，生命周期名称告诉Rust该命名生命周期必须与该参数**兼容**，这意味着该命名生命周期必须完全包含在参数的实际生命周期内。然后，当我们为返回值的生命周期使用相同的名称时，我们告诉Rust返回值将只保证在相同的限制内有效——在这种情况下，当**两个**参数仍然有效时。
- en: 'Rust uses that guarantee to check the calling code. If we tried something like
    this, the Rust compiler would refuse, because we''re trying to use the returned
    value in a way that might be incorrect, and Rust doesn''t deal in maybes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Rust使用这个保证来检查调用代码。如果我们尝试这样做，Rust编译器会拒绝，因为我们试图以可能不正确的方式使用返回值，而Rust不处理可能的情况：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a block expression between the `{` and the `}`, like we saw in [Chapter
    2](ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml), *Basics of the Rust Language*,
    which means it has its own scope, which owns the `main_5` variable. That means
    that, when we create a borrow of `main_5`, it has a shorter lifetime than a borrow
    of the `main_4` variable. Rust looks at the function definition for `smaller_x`
    and sees that the return value is only guaranteed valid within the lifetimes of
    both `main_4` and `main_5`, so trying to use it after the block expression has
    ended produces a compiler error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在`{`和`}`之间的块表达式，就像我们在[第2章](ee56cb8a-b053-4673-9a4a-e890ce323f2d.xhtml)中看到的，*Rust语言基础*，这意味着它有自己的作用域，它拥有`main_5`变量。这意味着当我们创建`main_5`的借用时，它的生命周期比`main_4`变量的借用短。Rust查看`smaller_x`函数的定义，看到返回值只在`main_4`和`main_5`的生命周期内保证有效，因此尝试在块表达式结束后使用它会产生编译器错误。
- en: This is a compiler error even though *in fact* `main_4` contains the `smaller_x`,
    and so the return value is a borrow of a value that will still be valid when we
    get to the print command. Rust doesn't analyze the logic of a function when it's
    checking lifetimes, it just looks at what we've told it about the parameters and
    return.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这即使实际上`main_4`包含了`smaller_x`，也是一个编译器错误，因此返回值是当我们到达打印命令时仍然有效的值的借用。Rust在检查生命周期时不会分析函数的逻辑，它只是查看我们告诉它的关于参数和返回的信息。
- en: This is a good thing. In this case, it would have been possible to examine the
    values used for the parameters, recognize that they are constant values that will
    always result in the same behavior from the function, and logically reason out
    that the lifetime of the returned borrow is equal to the lifetime of the first
    parameter. However, in general, that sort of reasoning would not be possible (what
    if the first parameter was input by the user?), and attempting it would just cause
    problems. Imagine changing the source of a variable's value, and suddenly having
    compiler errors way off in some other part of the program that shouldn't care!
    It's better to have these things as a concrete part of a function's interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事。在这种情况下，检查用于参数的值，认识到它们是始终产生相同行为的常量值，并逻辑推理出返回的借用的生命周期等于第一个参数的生命周期是可能的。然而，通常情况下，这种推理是不可能的（如果第一个参数是用户输入的怎么办？），尝试这样做只会造成问题。想象一下改变一个变量值的来源，突然在程序的其他某个不应该关心的部分出现编译错误！将这些事情作为函数接口的实体部分会更好。
- en: Ownership and the self parameter
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权和 `self` 参数
- en: As we've seen before, when we implement behavior for a type, the functions we
    define have `self`, `&self`, or `&mut self` as the first parameter. We now understand
    enough to recognize that that means that `self` is either moved (or copied) into
    the scope of the function, borrowed, or mutably borrowed. Which one we choose
    to use can have some pretty important consequences.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，当我们为类型实现行为时，我们定义的函数以 `self`、`&self` 或 `&mut self` 作为第一个参数。我们现在已经足够了解，这意味着
    `self` 要么被移动（或复制）到函数的作用域中，要么被借用，或者可变借用。我们选择使用哪一种可能会有一些相当重要的后果。
- en: 'The data type of `self` is implicit: it''s got to be the data type we''re implementing
    the function on and, because of that, we don''t get to specify the data type for
    `self` as part of the parameter list. Since there is no data type to prefix `&`
    or `&mut` to, we are allowed to write them before `self` instead.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 的数据类型是隐式的：它必须是我们在其上实现函数的数据类型，因此，我们无法在参数列表中将数据类型指定为 `self`。由于没有数据类型可以前缀
    `&` 或 `&mut`，我们可以在 `self` 前写它们。'
- en: 'In all three cases, `self` means *the data value that this function was called
    through*. If we have a `u32` variable named `x` and we tell Rust to `x.pow(3)`,
    the `pow` function implemented for `u32` will receive *two* parameters: the value
    of `x` as `self`, and `3` as the second parameter.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种情况下，`self` 指的是 *通过该函数被调用的数据值*。如果我们有一个名为 `x` 的 `u32` 变量，并告诉 Rust 执行 `x.pow(3)`，为
    `u32` 实现的 `pow` 函数将接收 *两个* 参数：`x` 的值作为 `self`，以及 `3` 作为第二个参数。
- en: The same rules apply to moving, borrowing, and mutably borrowing the `self`
    value as they apply to any other value. If we currently have any borrows of a
    value, we can't mutably borrow it into `self`, nor can we move it (because that
    would invalidate the existing borrows). If we currently have a mutable borrow
    of the value, we can't borrow it or move it into `self`, because mutable borrows
    do not allow anyone else to borrow or change the value. Similarly, borrowing into
    a function's `self` affects how we can access the data in other places, because
    it *is* a borrow, and there are rules about how borrows coexist.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 移动、借用和可变借用 `self` 值的规则与应用于任何其他值的规则相同。如果我们当前有任何值的借用，我们无法将其可变借用到 `self` 中，也不能移动它（因为这会使得现有的借用无效）。如果我们当前有值的可变借用，我们无法借用它或将其移动到
    `self` 中，因为可变借用不允许其他人借用或更改值。同样，将借用放入函数的 `self` 影响我们在其他地方访问数据的方式，因为这是一个借用，并且有关借用共存的规则。
- en: Moving self
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动 `self`
- en: 'If the `self` value is moved into the function, it''s just like moving any
    other value; we can''t continue to use it where it used to be anymore. Here is
    a function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `self` 值被移动到函数中，它就像移动任何其他值一样；我们不能再在它原来的地方使用它了。这里有一个函数：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This can be said to *consume* the `self` value. The value is moved into the
    function's scope when it is called, and the old variable that used to contain
    the value is no longer usable. This particular function returns a new, different `Point2D`
    value, so the value of `self` is completely gone once this function is done running.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被认为是 *消耗* `self` 值。当它被调用时，值被移动到函数的作用域中，而原来包含该值的旧变量就不再可用了。这个特定的函数返回一个新的不同的
    `Point2D` 值，所以一旦这个函数运行完毕，`self` 的值就完全消失了。
- en: There are reasons why this might be exactly the behavior we want. In the previous
    example, the function transforms the `self` value into something new, which is
    reflected by having it consume the old value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原因可能正是我们想要的这种行为。在前面的例子中，函数将`self`值转换成新的东西，这体现在它消耗了旧值。
- en: A very common use of functions that consume `self` is the **builder pattern**.
    This is a design pattern in Rust where we construct complex data structures bit
    by bit by filling in values to a builder structure, and then call a build function
    implemented on the builder structure to construct our final data value. Most of
    the time, the build function will consume its `self`, since each builder value
    should be used to construct only one final value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数消耗`self`的一个非常常见的用途是**构建器模式**。这是Rust中的一个设计模式，我们通过填充一个构建器结构中的值来逐步构建复杂的数据结构，然后调用在构建器结构上实现的构建函数来构建最终的数据值。大多数时候，构建函数会消耗其`self`，因为每个构建器值应该只用来构建一个最终值。
- en: The builder pattern is essentially a way to use Rust's syntax to achieve the
    same things that are achieved by keyword arguments and default values in some
    other languages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器模式本质上是一种使用Rust语法来实现某些其他语言中通过关键字参数和默认值实现相同功能的方法。
- en: Any time the value of `self` will be invalidated by what the function does,
    either literally or conceptually, it makes sense to move `self` into the function's
    scope.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候`self`的值会因为函数的操作而被无效化，无论是字面意义上的还是概念上的，将`self`移动到函数的作用域内都是有意义的。
- en: Borrowing self
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用`self`
- en: If the `self` value is immutably borrowed into a function, then that function
    has read-only access to the value. This is useful in many situations, because
    it lets us call the function without making a copy of the `self` value for it
    to operate on, and without making the compiler ensure that the rules of write
    access are maintained.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`self`值不可变借用到一个函数中，那么该函数只能对该值进行只读访问。这在许多情况下很有用，因为它允许我们调用该函数而不需要为它复制`self`值，也不需要编译器确保写入访问规则得到维护。
- en: 'Here''s an example of a function that immutably borrows `self`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例函数，它不可变地借用了`self`：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function returns ![](img/2c60b426-f1c8-448c-93f7-d284a1ab7624.png), or
    in other words, the distance between the point stored in `self` and the origin
    of the coordinate system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回![图片](img/2c60b426-f1c8-448c-93f7-d284a1ab7624.png)，换句话说，是存储在`self`中的点与坐标系原点之间的距离。
- en: The magnitude function doesn't need to change `self`, so there's no reason for
    it to use a mutable borrow and deal with the restrictions that implies. It could
    have worked with a moved `self`, but there's nothing wrong with calling the magnitude
    function twice on the same value, so that isn't what we want either.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`magnitude`函数不需要改变`self`，因此没有必要使用可变借用并处理由此产生的限制。它可以用移动的`self`工作，但两次在同一个值上调用`magnitude`函数并没有什么问题，所以这也不是我们想要的。'
- en: Using an immutable borrow for `self` is most often the correct choice. We need
    a reason to use `self` or `&mut self`, and if we don't have such a reason, we
    use `&self`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变借用`self`通常是正确的选择。我们需要一个使用`self`或`&mut self`的理由，如果没有这样的理由，我们就使用`&self`。
- en: Mutably borrowing self
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变借用`self`
- en: Sometimes, a function needs to change its `self`. For those situations, we can
    receive `self` as a mutable borrow with `&mut self`. Like any other time we create
    a mutable borrow, we can only call such a function if we have the value for `self`
    stored in a mutable variable, and that value is not currently borrowed anywhere
    else. In other words, we can only call functions that have write access to a value
    when we ourselves have write access to that value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个函数需要改变它的`self`。对于这些情况，我们可以通过`&mut self`接收`self`作为可变借用。就像我们创建任何其他可变借用一样，我们只能调用这样的函数，如果我们有一个存储在可变变量中的`self`值，并且该值目前没有被其他地方借用。换句话说，我们只能在
    ourselves 有写入访问权时调用具有写入访问权的函数。
- en: 'Here, we have an example function that mutable borrows `self`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个示例函数，它可变地借用了`self`：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We see several things here. First, we are able to call the read-only `magnitude`
    function on `self`, even though that function takes its `self` as an immutable
    borrow, and we''ve got our `self` value as a mutable borrow. The reverse is not
    true: if we tried to call the `unit` function from inside of the `magnitude` function,
    the compiler would refuse to allow it.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了几个方面。首先，我们能够在`self`上调用只读的`magnitude`函数，尽管该函数接受一个不可变的`self`借用，而我们得到了一个可变的`self`借用。反之则不成立：如果我们试图在`magnitude`函数内部调用`unit`函数，编译器会拒绝允许这样做。
- en: Second, since we have write access to `self`, we can change the data stored
    in it. That's what write access means.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，由于我们有对`self`的写入访问权限，我们可以更改其中存储的数据。这就是写入访问的含义。
- en: Third, we don't have a return type specified for this function. Technically,
    it defaults to returning `()`, but that's just another way of saying it doesn't
    return anything meaningful. It's common practice for functions that change `self`
    to not return a value or to return a `Result` with `()` as its success value if
    the function needs the ability to report errors. That's because the real result
    of the function is the updated `self` value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们为这个函数没有指定返回类型。技术上，它默认返回`()`，但这只是另一种说法，表示它没有返回任何有意义的内容。对于需要改变`self`的函数，不返回值或返回一个带有`()`作为成功值的`Result`是常见的做法，如果函数需要报告错误的能力。这是因为函数的真正结果是更新后的`self`值。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Ownership is the thing that most separates Rust from other programming languages.
    It's an idea that seems obvious at first, then surprisingly complicated, and finally
    powerful and useful. Ownership gives Rust its nearly-free automatic memory management,
    along with things such as safe and easy multithreading and concurrency, and just
    generally being able to spot more errors in the compiler than other languages
    can.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权是Rust与其他编程语言最显著的区别。一开始这个想法似乎很显然，然后出人意料地复杂，最后变得强大且有用。所有权为Rust提供了几乎免费的自动内存管理，以及诸如安全且易于多线程和并发等特性，以及通常能够在编译器中比其他语言发现更多错误的能力。
- en: 'Borrowing makes use of ownership to create a safe version of one of the biggest
    problem points for other languages: accessing data via a memory address. Mistakes
    with memory addresses are one of the most common problems programs encounter and,
    in Rust, those mistakes are caught by the compiler and reported along with helpful
    hints about how to address them.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 借用利用所有权来创建其他语言中最大的问题点之一的安全版本：通过内存地址访问数据。与内存地址相关的错误是程序遇到的最常见问题之一，在Rust中，这些错误会被编译器捕获，并附带有关如何解决它们的
    helpful hints。
- en: In this chapter, we also looked at how to implement consuming, read-only, or
    read-write functions for data types, based on whether they move, borrow, or mutably
    borrow their `self` value, and discussed an assortment of errors that the compiler
    might report in various situations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还探讨了如何根据数据类型是否移动、借用或可变借用其`self`值来实现消耗性、只读或读写函数，并讨论了编译器在各种情况下可能报告的各种错误。
- en: In the next chapter, we're going to learn about how to use pattern matching
    on data types to make decisions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用数据类型上的模式匹配来做出决策。
