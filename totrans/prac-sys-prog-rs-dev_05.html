<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-68"><em class="italic">Chapter 4</em>: <a id="_idTextAnchor070"/>Managing Environment, Command Line, and Time</h1>
			<p>In the previous chapter, we looked at how the Rust Standard Library is structured. We also wrote a portion of a basic template engine that can generate dynamic HTML page components given an HTML template and data. From here onward, we will start to deep-dive into specific modules of the standard library grouped by functional areas.</p>
			<p>In this chapter, we will look at Rust Standard Library modules that pertain to working with system environment, command-line, and time-related functions. The goal of this chapter is for you to gain more proficiency in working with <em class="italic">command-line parameters</em>, <em class="italic">path manipulation, environment variables</em>, and <em class="italic">time measurements.</em></p>
			<p>What is the benefit of learning about these?</p>
			<p>Working with <em class="italic">command-line arguments</em> is a required skill for writing any program that accepts user inputs from the command line.</p>
			<p>Imagine how you would write a tool (such as <strong class="bold">find</strong> or <strong class="bold">grep</strong>) that deals with searching for files and patterns within folders and subfolders. This requires knowledge of <em class="italic">path manipulation</em>, including navigating paths and reading and manipulating path entries.</p>
			<p>Learning to use <em class="italic">environment variables</em> is an essential part of separating the code from the configuration, which is a good practice for any kind of program.</p>
			<p>Learning to work with time is required for programs that deal with timestamps of resources and activities. Learning how to do <em class="italic">time measurements</em> to record time intervals between events is needed for benchmarking the time taken for various operations.</p>
			<p>In this chapter, you will learn the following skills:</p>
			<ul>
				<li>Writing Rust programs that can discover and manipulate the system environment and filesystem across Linux, Unix, and Windows platforms</li>
				<li>Creating programs that can use command-line arguments to accept configuration parameters and user inputs</li>
				<li>Capturing elapsed time between events</li>
			</ul>
			<p>These are relevant skills to have for systems programming in Rust. We will learn these topics in a practical way by developing a command-line application for image processing. Along the way, we will see more details about the <strong class="source-inline">path</strong>, <strong class="source-inline">time</strong>, <strong class="source-inline">env</strong>, and <strong class="source-inline">fs</strong> modules of the Rust Standard Library.</p>
			<p>First, let's see what we will be building.</p>
			<p>Imagine that we had a tool for bulk image resizing – tool that would look through a filesystem directory on a desktop or server, pull out all the image files (for instance, <strong class="source-inline">.png</strong> and <strong class="source-inline">.jpg</strong>), and resize all of them to predefined sizes (for example, small, medium, or large).</p>
			<p>Think about how helpful such a tool would be for freeing up space on the hard disk, or for uploading pictures to show in a mobile or web app. We will be building such a tool. Fasten your seat belts.</p>
			<p>We will cover the topics in the following order:</p>
			<ul>
				<li>Project scope and design overview</li>
				<li>Coding the image resizing library</li>
				<li>Developing the command-line application</li>
			</ul>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Technical requirements</h1>
			<p>The GitHub repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04</a>.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor072"/>Project scope and design overview</h1>
			<p>In this section, we <a id="_idIndexMarker249"/>will first define what we are going to build and look at the <a id="_idIndexMarker250"/>technical design. We will then code a Rust library for image processing. Finally, we will build a command-line application that accepts user inputs through the command line and uses the image resizing library we have built to perform user-specified commands.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>What will we build? </h2>
			<p>In this subsection, we will describe the functional requirements, technical requirements, and project structure for the tool we are building.</p>
			<h3>Functional requirements</h3>
			<p>We will <a id="_idIndexMarker251"/>build a command-line <a id="_idIndexMarker252"/>tool that performs the <a id="_idIndexMarker253"/>following two operations:</p>
			<ul>
				<li><strong class="bold">Image resize</strong>: Resizes one or <a id="_idIndexMarker254"/>more images in a source folder to a specified size</li>
				<li><strong class="bold">Image stats</strong>: Provides some <a id="_idIndexMarker255"/>statistics on the image files present in the source folder</li>
			</ul>
			<p>Let's name the tool <strong class="bold">ImageCLI</strong>. <em class="italic">Figure 4.1</em> shows the two main features of the tool:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_4.1_B16405.jpg" alt="Figure 4.1 – Features of ImageCLI tool"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Features of ImageCLI tool</p>
			<p>Users will be able to resize images using this tool. The user can ask to resize either a single image or multiple images. Supported <em class="italic">input</em> image formats are JPG and PNG. The supported <em class="italic">output</em> image format is PNG. The tool will accept three command-line parameters as follows:</p>
			<ul>
				<li><strong class="bold">Size</strong>: This is the desired <a id="_idIndexMarker256"/>output size of the image. If the user specifies <strong class="source-inline">size = small</strong>, the output image will have <em class="italic">200</em> pixels of width; for <strong class="source-inline">size = medium</strong>, the output file will have <em class="italic">400</em> pixels of width; and for <strong class="source-inline">size = large</strong>, the output will have <em class="italic">800</em> pixels of width. For example, if the input image is a JPG file with a total size of 8 MB, it can be resized to approximately &lt; 500 KB in size by specifying <strong class="source-inline">size = medium</strong>.</li>
				<li><strong class="bold">Mode</strong>: The <a id="_idIndexMarker257"/>mode indicates whether the user wants to resize one image file or multiple files. The user specifies <strong class="source-inline">mode = single</strong> for resizing a single file, or <strong class="source-inline">mode = all</strong> for resizing all image files in a specified folder. </li>
				<li><strong class="bold">Source folder</strong>: The value <a id="_idIndexMarker258"/>specified by the user for the source folder has a different meaning depending on whether <strong class="source-inline">mode = single</strong> or <strong class="source-inline">mode = all</strong> is chosen. For <strong class="source-inline">mode = single</strong>, the user specifies the value of <strong class="source-inline">srcfolder</strong> as the full path of the image file with its filename. For <strong class="source-inline">mode = all</strong>, the user specifies, for the value of <strong class="source-inline">srcfolder</strong>, the full path of the folder (the one containing the image files) without any image filenames. For example, if <strong class="source-inline">mode = single</strong> and <strong class="source-inline">srcfolder = /user/bob/images/image1.png</strong> are used, the tool will resize the single image file of <strong class="source-inline">image1.png</strong>, contained in the <strong class="source-inline">/user/bob/images</strong> folder. If <strong class="source-inline">mode = all</strong> and <strong class="source-inline">srcfolder = /user/bob/images</strong> are used, the tool will resize <em class="italic">all</em> the image files contained in the <strong class="source-inline">/user/bob/images</strong> source folder.</li>
			</ul>
			<p>For our <a id="_idIndexMarker259"/>image stats functionality, users <a id="_idIndexMarker260"/>will also be able to specify a <strong class="source-inline">srcfolder</strong> containing the image files and get back the number of image files in that folder, along with the total size of all those image files. For example, if <strong class="source-inline">srcfolder=/user/bob/images</strong> is used, the <strong class="source-inline">image stats</strong> option will give a result similar to the following: <strong class="bold">The folder contains 200 image files with total size 2,234 MB</strong>.</p>
			<h3>Non-functional requirements</h3>
			<p>The following are a list of <a id="_idIndexMarker261"/>non-functional (technical) requirements <a id="_idIndexMarker262"/>for the project:</p>
			<ul>
				<li>The tool will be packaged and distributed as a binary and it should work on three platforms: Linux, Unix, and Windows.</li>
				<li>We should be able to measure the time taken to resize the images.</li>
				<li>User inputs for specifying command-line flags must be <em class="italic">case-insensitive</em> for ease of use.</li>
				<li>The tool must be able to display meaningful error messages to the user.</li>
				<li>The core functionality <a id="_idIndexMarker263"/>of image resizing must be separate from the <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>). This way, we have the flexibility of reusing the core functionality with a desktop graphical interface or as part of a web backend in a web application.</li>
				<li>The project will be organized as a <strong class="bold">library</strong> containing the image processing functionality and a <strong class="bold">binary</strong> that provides the CLI to read and parse user input, provide error messages, and display output messages to the user. The binary will make use of the library for core image processing.</li>
			</ul>
			<h3>Project structure</h3>
			<p>Let's create the project <a id="_idIndexMarker264"/>skeleton so we can visualize the project structure better. Create a new <strong class="source-inline">lib</strong> project using <strong class="source-inline">cargo</strong>. Let's name the CLI tool as <strong class="source-inline">imagecli</strong> using the following command:</p>
			<p class="source-code">cargo new --lib imagecli &amp;&amp; cd imagecli</p>
			<p>Here is the project structure:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_4.2_B16405.jpg" alt="Figure 4.2 – Cargo project structure"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Cargo project structure</p>
			<p>Set up the project structure as follows:</p>
			<ol>
				<li>Under the <strong class="source-inline">src</strong> folder, create <a id="_idIndexMarker265"/>a subfolder called <strong class="source-inline">imagix</strong> (for image magic!) to host the library code. Under the <strong class="source-inline">imagix</strong> subfolder, create four files: <strong class="source-inline">mod.rs</strong>, which is the entry point into the <strong class="source-inline">imagix</strong> library, <strong class="source-inline">resize.rs</strong> to host the code related to image resizing, <strong class="source-inline">stats.rs</strong> to host the code for image file statistics, and <strong class="source-inline">error.rs</strong> to contain the custom error type and error handling code.</li>
				<li>Under the <strong class="source-inline">src</strong> folder, create a new file called <strong class="source-inline">imagecli.rs</strong>, which will contain the code for the CLI.</li>
			</ol>
			<p>In this subsection, we have seen the feature requirements for the tool and the desired project structure. In the next subsection, we will look at the design for the tool.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>Technical design</h2>
			<p>In this subsection, we will <a id="_idIndexMarker266"/>look at the high-level design of the tool, primarily focusing on the image processing feature. We will design the specifics of the CLI in the <em class="italic">Developing the command-line application and testing</em> section.</p>
			<p>Our project comprises our reusable <strong class="source-inline">imagix</strong> library containing the core functionality for image resizing and statistics, and a binary executable, <strong class="source-inline">imagecli</strong>, with a CLI. This is depicted in <em class="italic">Figure 4.3</em>:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_4.3_B16405.jpg" alt="Figure 4.3 – CLI tool with a reusable library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – CLI tool with a reusable library</p>
			<p>If the library is <a id="_idIndexMarker267"/>designed right, it can be reused in the future for other types of clients; for example, the application can be provided with a graphical user interface (instead of a CLI) as a desktop application, or can even be made accessible from a browser-based HTML client app.</p>
			<p>Before we begin the design, let's try to visualize a few of the key technical challenges we have to overcome and solve:</p>
			<ul>
				<li><strong class="bold">Resizing a single image:</strong><p>How do we resize a larger <a id="_idIndexMarker268"/>image to a smaller, user-specified size, programmatically? </p><p>How do we create a <strong class="source-inline">/tmp/</strong> subfolder to store the resized images?</p><p>How do we measure the time taken for image resizing?</p></li>
				<li><strong class="bold">Resizing multiple images</strong>:<p>How do we iterate through the <a id="_idIndexMarker269"/>source folder provided by the user to identify all the image files and invoke the image resizing function for each entry?</p></li>
				<li><strong class="bold">Getting image statistics</strong>:<p>How do we scan through the <a id="_idIndexMarker270"/>user-provided source folder, count only the number of image files, and get the aggregate file size of all image files in that folder?</p></li>
				<li><strong class="bold">Path manipulation</strong>:<p>How do we manipulate <a id="_idIndexMarker271"/>paths so that the output file is stored in the <strong class="source-inline">tmp</strong> subfolder?</p></li>
			</ul>
			<p>The preceding points can be grouped into three broad categories of concerns for design purposes:</p>
			<ul>
				<li>Image resizing logic</li>
				<li>Path manipulation and directory-iteration logic</li>
				<li>Measuring time taken for image resizing</li>
			</ul>
			<p>Image processing is a highly-specialized domain in itself, and it is beyond the scope of this book to cover the <a id="_idIndexMarker272"/>techniques and algorithms involved. Given the complexity and scope of the image processing domain, we will use a third-party library that will implement the needed algorithms and provide us with a nice API to call.</p>
			<p>For this purpose, we will use the <strong class="source-inline">image-rs/image</strong> open source crate that is written in Rust. The crate docs are at the following link: <a href="https://docs.rs/image/">https://docs.rs/image/</a></p>
			<p>Let's look at how we can design the <strong class="source-inline">imagix</strong> library using the <strong class="source-inline">image</strong> crate.</p>
			<p>The <strong class="source-inline">image</strong> crate is fully featured and has many image processing functions. We will however use only a small subset of features for our project. Let's recall our three key requirements for image processing: the ability to <em class="italic">open an image file and load it into memory</em>, the ability to <em class="italic">resize the image to a desired size</em>, and the ability to <em class="italic">write the resized image from memory into a file</em> on the disk. The following methods in the <strong class="source-inline">image-rs/image</strong> crate address our needs:</p>
			<ul>
				<li><strong class="source-inline">image::open()</strong>: This function opens an image at the specified path. It automatically detects the format of the image from the image's file extension. The image data is read from the file and converted into a <strong class="source-inline">DynamicImage</strong> type stored in memory.</li>
				<li><strong class="source-inline">DynamicImage::thumbnail()</strong>: This function scales an image down to a specified size (width and height) and returns a new image while preserving the aspect ratio. It uses a fast integer algorithm, which is a sinusoidal <a id="_idIndexMarker273"/>transformation technique. This is an <strong class="bold">in-memory operation</strong>.</li>
				<li><strong class="source-inline">DynamicImage::write_to()</strong>: This function encodes an image and writes it to any object that implements the <strong class="source-inline">std::io::write</strong> trait, which in our case will be an output <em class="italic">file handle</em>. We will use this method to write the resized image to a file.</li>
			</ul>
			<p>This should be adequate for our <a id="_idIndexMarker274"/>image processing requirements in this project. For the other two concerns around path manipulation and time measurements, we will use the Rust Standard Library, which is described in the next subsection.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Using the Rust Standard Library</h2>
			<p>For <a id="_idIndexMarker275"/>developing the image resizing tool, we will be <a id="_idIndexMarker276"/>using both external crates and the Rust Standard Library. In the previous section, we saw how we plan to use the <strong class="source-inline">image</strong> crate.</p>
			<p>In this section, we will cover the features of the Rust Standard Library that we will be using to build our project. There are three key areas where we will need the standard library:</p>
			<ul>
				<li>The<em class="italic"> path manipulation and directory iteration</em> functionality is needed in order to search through a directory, locate the image files, and create a new subfolder.</li>
				<li>We need to get <a id="_idIndexMarker277"/>tool configuration options from the user. We will evaluate two approaches – getting this <a id="_idIndexMarker278"/>information through <em class="italic">environment variables</em> and getting it through <em class="italic">command-line parameters</em>. We will choose one of the options.</li>
				<li>We want to <em class="italic">measure the time taken</em> for the image resizing tasks.</li>
			</ul>
			<p>Let's take a look at each of these areas in detail.</p>
			<h3>Path manipulation and directory iteration</h3>
			<p>For path <a id="_idIndexMarker279"/>manipulation, we will use the <strong class="source-inline">std::path</strong> module from the Rust Standard Library. For directory <a id="_idIndexMarker280"/>iteration, we will use the <strong class="source-inline">std::fs</strong> module.</p>
			<p>Why do we need to manipulate paths?</p>
			<p>The source image files for resizing are stored in the <em class="italic">source folder</em>. The destination path for the resized image files is the <strong class="source-inline">tmp</strong> subfolder (within the <em class="italic">source folder</em>). Before writing each resized image file to disk, we have to construct the path where the file is to be stored. For example, if the path for the source file is <strong class="source-inline">/user/bob/images/image1.jpg</strong>, the destination path for the resized image will be <strong class="source-inline">/user/bob/images/tmp/image1.jpg</strong>. We have to construct the destination path programmatically, and then call the method on the <strong class="source-inline">image</strong> crate to store the image on the destination path.</p>
			<p>The Rust Standard Library supports path manipulation functionality through two data types: <strong class="source-inline">Path</strong> and <strong class="source-inline">PathBuf</strong>, both part of the <strong class="source-inline">std::path</strong> module. See the sidebar for more details on how to construct and manipulate <strong class="source-inline">paths</strong> using the standard library.</p>
			<p class="callout-heading">The std::path module of the Rust Standard Library</p>
			<p class="callout">This module provides cross-platform path manipulation functions.</p>
			<p class="callout">A path points to a filesystem location by following a directory tree. An example of a path in Unix systems is <strong class="source-inline">/home/bob/images/</strong>. An example of a path on the Windows operating system could be <strong class="source-inline">c:\bob\images\image1.png</strong>.</p>
			<p class="callout">There are two main types in the <strong class="source-inline">std::path</strong> module that are commonly used—<strong class="source-inline">Path</strong> and <strong class="source-inline">PathBuf</strong>.</p>
			<p class="callout">For parsing the path and its components (read operations), <strong class="source-inline">Path</strong> is used. In Rust parlance, it is a <strong class="bold">path slice</strong> (like a <a id="_idIndexMarker281"/>string slice, which is a reference to a string).</p>
			<p class="callout">For modifying existing paths or to construct new paths, <strong class="source-inline">PathBuf</strong> is used. <strong class="source-inline">PathBuf</strong> is an <strong class="bold">owned</strong>, <strong class="bold">mutable path</strong>.</p>
			<p class="callout"><strong class="source-inline">Path</strong> is used for read operations and <strong class="source-inline">PathBuf</strong> for read and write operations on paths.</p>
			<p class="callout">Here is how <a id="_idIndexMarker282"/>to construct a new path <a id="_idIndexMarker283"/>from a string:</p>
			<p class="callout"><strong class="source-inline">let path_name = Path::new("/home/alice/foo.txt");</strong></p>
			<p class="callout">In <strong class="source-inline">path_name</strong>, <strong class="source-inline">/home/alice</strong> represents the parent, <strong class="source-inline">foo</strong> is the file stem, and <strong class="source-inline">txt</strong> is the file extension. We will be making use of the <strong class="source-inline">file_stem()</strong> and <strong class="source-inline">extension()</strong> methods on the <strong class="source-inline">Path</strong> type.</p>
			<p class="callout">The <strong class="source-inline">pop()</strong> and <strong class="source-inline">push()</strong> methods on the <strong class="source-inline">PathBuf</strong> type are used to truncate and append components to a path.</p>
			<p class="callout">Let's create a new <strong class="source-inline">PathBuf</strong> path with the following code:</p>
			<p class="callout"><strong class="source-inline">let mut path_for_editing = PathBuf::from("/home/bob/file1.png")</strong></p>
			<p class="callout"><strong class="source-inline">path_for_editing.pop()</strong> truncates this path to its parent, that is, <strong class="source-inline">"/home/bob"</strong>.</p>
			<p class="callout">Now, <strong class="source-inline">push()</strong> can be used to append a new component to <strong class="source-inline">PathBuf</strong>. For example, continuing from <strong class="source-inline">PathBuf</strong> with the value <strong class="source-inline">"/home/bob"</strong>, <strong class="source-inline">push("tmp")</strong> will append <strong class="source-inline">tmp</strong> to <strong class="source-inline">"/home/bob"</strong> path and return <strong class="source-inline">"/home/bob/tmp"</strong>.</p>
			<p class="callout">We will be using the <strong class="source-inline">pop()</strong> and <strong class="source-inline">push()</strong> methods in our project to manipulate paths.</p>
			<p>Let's next look at how to perform the directory operations needed for our project.</p>
			<p>When the user specifies <strong class="source-inline">mode=all</strong>, our requirement is to iterate through all the files in the specified source <a id="_idIndexMarker284"/>folder and filter the list of <a id="_idIndexMarker285"/>image files for processing. For iterating over directory paths, we will use the <strong class="source-inline">read_dir()</strong> function in the <strong class="source-inline">std::fs</strong> module.</p>
			<p>Let's see an example of how to use this function:</p>
			<p class="source-code">use std::fs;</p>
			<p class="source-code"> </p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let entries = fs::read_dir("/tmp").unwrap();</p>
			<p class="source-code">    for entry in entries {</p>
			<p class="source-code">        if let Ok(entry) = entry {</p>
			<p class="source-code">            println!("{:?}", entry.path());</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The following is the explanation for the preceding code:</p>
			<ol>
				<li value="1"><strong class="source-inline">fs:read_dir()</strong> takes a source folder path and returns <strong class="source-inline">std::fs::ReadDir</strong>, which is an iterator over entries in the directory.</li>
				<li>We then use a <strong class="source-inline">for</strong> loop to extract each directory entry (which is wrapped in a <strong class="source-inline">Result</strong> type), and print out its value.</li>
			</ol>
			<p>This is the code we will use to get entries in a directory and do further processing.</p>
			<p>Apart from reading a <a id="_idIndexMarker286"/>directory for its contents, we <a id="_idIndexMarker287"/>also need to check for the presence of a <strong class="source-inline">tmp</strong> subfolder under the source folder and create it if it does not already exist. We will use the <strong class="source-inline">create_dir()</strong> method from the <strong class="source-inline">std::fs</strong> module to create a new subdirectory.</p>
			<p>We will see more details of the <strong class="source-inline">std::fs</strong> module in a later chapter.</p>
			<h3>Time measurement</h3>
			<p>For measuring time, we can use the <strong class="source-inline">std::time</strong> module.</p>
			<p>The <strong class="source-inline">std::time</strong> module in <a id="_idIndexMarker288"/>the Rust Standard Library has several time-related functions including getting the <em class="italic">current system time</em>, creating a <em class="italic">duration</em> to represent a span of time, and measuring the <em class="italic">time elapsed</em> between two specific time instants. Some examples of using the <strong class="source-inline">time</strong> module are provided in the following.</p>
			<p>To get the current system time, we can write the following code:</p>
			<p class="source-code">use std::time::SystemTime;</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let _now = SystemTime::now();</p>
			<p class="source-code">}</p>
			<p>Here is how to get the elapsed time from a given point in time:</p>
			<p class="source-code">use std::thread::sleep;</p>
			<p class="source-code">use std::time::{Duration, Instant};</p>
			<p class="source-code">fn main() {</p>
			<p class="source-code">    let now = Instant::now();</p>
			<p class="source-code">    sleep(Duration::new(3, 0));</p>
			<p class="source-code">    println!("{:?}", now.elapsed().as_secs());</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Instant::now()</strong> is used to indicate the starting point of the time to be measured. The time duration between this <a id="_idIndexMarker289"/>point and the point at which <strong class="source-inline">now.elapsed()</strong> is called represents the time taken for the operation(s). Here, we are simulating a delay using the <strong class="source-inline">sleep()</strong> function from the <strong class="source-inline">std::thread</strong> module.</p>
			<h3>Working with environment variables</h3>
			<p>In this subsection, we will learn <a id="_idIndexMarker290"/>how to use the Rust Standard Library, along with a third-party helper crate, to store the values in environment variables and use them in the program:</p>
			<ol>
				<li value="1">Create a new project with the following line of code:<p class="source-code"><strong class="bold">cargo new read-env &amp;&amp; cd read-env</strong></p><p>It is easier to work with environment variables from a <strong class="source-inline">.env</strong> file (instead of setting them in the console), so let's add a popular crate for this purpose, called <strong class="source-inline">dotenv</strong>, in <strong class="source-inline">Cargo.toml</strong>:</p><p class="source-code">[dependencies]</p><p class="source-code">dotenv = "0.15.0"</p><p>Depending on when you are reading this book, you may have a later version of this tool available, which you may choose to use.</p></li>
				<li>In <strong class="source-inline">main.rs</strong>, add the following code:<p class="source-code">use dotenv::dotenv;</p><p class="source-code">use std::env;</p><p class="source-code">fn main() {</p><p class="source-code">dotenv().ok();</p><p class="source-code">for (key, value) in env::vars() {</p><p class="source-code">    println!("{}:{}", key, value);</p><p class="source-code">}</p><p class="source-code">}</p><p>In the preceding code, we import the <strong class="source-inline">std::env</strong> module and also the <strong class="source-inline">dotenv::dotenv</strong> module.</p><p>The following statement loads the environment variables from an <strong class="source-inline">.env</strong> file:</p><p class="source-code">dotenv().ok();</p><p>The <strong class="source-inline">for</strong> loop in the <a id="_idIndexMarker291"/>previous code block iterates through the environment variables in a loop and prints them to the console. <strong class="source-inline">env:vars()</strong> returns an iterator of key-value pairs for all environment variables of the current process.</p></li>
				<li>To test this, let's create a new<strong class="source-inline">.env</strong> file in the project root and make the following entries:<p class="source-code">size=small</p><p class="source-code">mode=single</p><p class="source-code">srcfolder=/home/bob/images/image1.jpg </p></li>
				<li>Replace the <strong class="source-inline">srcfolder</strong> value with your own. Run the program with the following command:<p class="source-code"><strong class="bold">cargo run</strong></p><p>You will see the environment variables from the <strong class="source-inline">.env</strong> file printed out, along with the others associated with the process.</p></li>
				<li>To access the value of any particular environment variable, the <strong class="source-inline">std::env::var()</strong> function can be used, which takes the key of the variable as a parameter. Add the following statement to the <strong class="source-inline">main()</strong> function and see the value of the <strong class="source-inline">size</strong> variable <a id="_idIndexMarker292"/>printed out:<p class="source-code">println!("Value of size is {}",   </p><p class="source-code">    env::var("size").unwrap());</p></li>
			</ol>
			<p>We have seen how to use <em class="italic">environment variables</em> to accept user inputs for image processing. Let's see how to accept user inputs with <em class="italic">command-line</em> parameters.</p>
			<h3>Working with command-line parameters</h3>
			<p>In this subsection, we <a id="_idIndexMarker293"/>will learn to read command-line parameters using the <strong class="source-inline">std::env</strong> module of the Rust Standard Library:</p>
			<ol>
				<li value="1">The <strong class="source-inline">std::env</strong> module supports command-line parameters through <strong class="source-inline">std::env::args()</strong>. Create a new Cargo project. Add the following line to the <strong class="source-inline">main()</strong> function in <strong class="source-inline">src/main.rs</strong>:<p class="source-code">use std::env;</p><p class="source-code">fn main() {</p><p class="source-code">    for argument in env::args() {</p><p class="source-code">        println!("{}", argument);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Execute the code with <strong class="source-inline">cargo run small all /tmp</strong>.</li>
				<li>The three parameters passed to the program will be printed out to the console. To access individual parameters by index, add the following code to <strong class="source-inline">main.rs</strong>:<p class="source-code">use std::env;</p><p class="source-code">fn main() {</p><p class="source-code">    let args: Vec&lt;String&gt; = env::args().collect();</p><p class="source-code">    let size = &amp;args[1];</p><p class="source-code">    let mode = &amp;args[2];</p><p class="source-code">    let source_folder = &amp;args[3];</p><p class="source-code">    println!(</p><p class="source-code">        "Size:{},mode:{},source folder: {}",</p><p class="source-code">        size, mode, source_folder</p><p class="source-code">    );</p><p class="source-code">}</p></li>
				<li>Run the program with <strong class="source-inline">cargo run small all /tmp</strong>.</li>
			</ol>
			<p>The individual values for <strong class="source-inline">size</strong>, <strong class="source-inline">mode</strong>, and <strong class="source-inline">source_folder</strong> will be printed out as shown here:</p>
			<p class="source-code">Size:small,mode:all,source folder: /tmp</p>
			<p>Of the two <a id="_idIndexMarker294"/>approaches we have seen – that is, using <em class="italic">environment variables</em> and <em class="italic">command-line parameters</em> – the latter is more suitable for accepting inputs from end users, while the environment variable approach is more suitable for developers configuring the tool.</p>
			<p>However, for a user-friendly interface, the bare-bones functionality offered by <strong class="source-inline">std::env::args</strong> is inadequate. We will use a third-party crate called <strong class="bold">StructOpt</strong> to improve the user interaction with the CLI.</p>
			<p>This concludes the deep dive into the Rust Standard Library modules for path manipulation, time measurement, and reading environment and command-line parameters.</p>
			<p>Here is a summary of the design approaches we have discussed, for the <strong class="source-inline">imagix</strong> library:</p>
			<ul>
				<li><strong class="bold">Resizing a single image</strong>:<p>How do we resize a larger image to a user-specified size, programmatically? </p><p>We will use the <strong class="source-inline">image-rs/image</strong> crate.</p><p>How do we create a <strong class="source-inline">/tmp/</strong> subfolder to store the resized images? </p><p>We will use the <strong class="source-inline">std::fs::create_dir()</strong> method.</p></li>
				<li><strong class="bold">Resizing multiple images</strong>:<p>How do we iterate through the source folder provided by the user to identify all the image files and invoke the image resizing function? </p><p>We will use <strong class="source-inline">std::fs::read_dir()</strong> method.</p><p>How do we manipulate paths so that the output file is stored in the <strong class="source-inline">tmp</strong> subfolder?</p><p>We will use the <strong class="source-inline">std::path::Path</strong> and <strong class="source-inline">std::path::PathBuf</strong> types.</p></li>
				<li><strong class="bold">Getting image statistics</strong>:<p>How do we scan through the user-provided source folder, count only the number of image files, and get the aggregate file size of all image files in that folder?</p><p>We will use the <strong class="source-inline">std::path::Path</strong> type and the <strong class="source-inline">std::fs::read_dir()</strong> method.</p></li>
				<li><strong class="bold">Metrics for benchmarking</strong>:<p>How do we measure the time taken for image resizing?</p><p>We will use the <strong class="source-inline">std::time::Duration</strong> and <strong class="source-inline">std::time::Instant</strong> modules.</p></li>
				<li><strong class="bold">Reading command-line parameters:</strong><p>Use the <strong class="source-inline">StructOpt</strong> crate.</p></li>
			</ul>
			<p>With this, we conclude this section on addressing project scope and design for the <strong class="source-inline">imagix</strong> library. We are now ready to start writing the code for the image processing library in the next section.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Coding the imagix library</h1>
			<p>In this section, we'll write the <a id="_idIndexMarker295"/>code for the image resizing and image statistics functionalities. Let's first look at the code structure.</p>
			<p>The module structure of the <strong class="source-inline">imagix</strong> library is summarized in <em class="italic">Figure 4.4</em>:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_4.4_B16405.jpg" alt="Figure 4.4 – Modules of the imagix library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Modules of the imagix library</p>
			<p>The <strong class="source-inline">imagix</strong> library will consist of two modules, <strong class="bold">resize</strong> and <strong class="bold">stats</strong>, represented by <strong class="source-inline">resize.rs</strong> and <strong class="source-inline">stats.rs</strong> respectively. There are two <strong class="source-inline">enums</strong>, <strong class="source-inline">SizeOption</strong> and <strong class="source-inline">Mode</strong>, for representing the variants for <em class="italic">size option </em>and <em class="italic">mode</em> respectively. The user will specify one of the variants of the <strong class="source-inline">SizeOption</strong> <strong class="source-inline">enum</strong> to indicate the desired output image size, and one of the variants of the <strong class="source-inline">Mode</strong> <strong class="source-inline">enum</strong> to indicate whether one or multiple images need to be resized. There is also <strong class="source-inline">struct Elapsed</strong> for capturing elapsed time of the image resizing operation.</p>
			<p>The <strong class="source-inline">resize</strong> module has the <strong class="source-inline">process_resize_request()</strong> public function, which is the main entry point into the <strong class="source-inline">imagix</strong> library for resizing images.</p>
			<p>The <strong class="source-inline">stats</strong> module has a <strong class="source-inline">get_stats()</strong> public function.</p>
			<p>An overview of the overall code organization of the project is shown in <em class="italic">Figure 4.5</em>:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.5_B16405.jpg" alt="Figure 4.5 – Code organization"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Code organization</p>
			<p><em class="italic">Figure 4.5</em> shows the <a id="_idIndexMarker296"/>following:</p>
			<ul>
				<li>The configuration and dependency entries needed in the <strong class="source-inline">Cargo.toml</strong> file</li>
				<li>The Cargo project's code tree structure</li>
				<li>The list of source files of the <strong class="source-inline">imagix</strong> library along with a list of the key functions</li>
				<li>The <strong class="source-inline">imagecli.rs</strong> file, which represents the command-line wrapper over the <strong class="source-inline">imagix</strong> library, and the code execution entry point in our tool</li>
			</ul>
			<p>Let's first add the two external crates to <strong class="source-inline">Cargo.toml</strong> in the <strong class="source-inline">imagecli</strong> project folder root:</p>
			<p class="source-code">[dependencies]</p>
			<p class="source-code">image = "0.23.12"</p>
			<p class="source-code">structopt = "0.3.20"</p>
			<p>In this section, we will walk through the code snippets for the following methods:</p>
			<ul>
				<li><strong class="source-inline">get_image_files()</strong>, which demonstrates path navigation</li>
				<li><strong class="source-inline">resize_image()</strong>, which contains the core logic for image resizing using the image crate, and for time measurements</li>
				<li><strong class="source-inline">get_stats()</strong>, which returns the total count and the total size of image files in a folder</li>
				<li>Custom error handling methods</li>
			</ul>
			<p>The rest of the code is <a id="_idIndexMarker297"/>standard Rust (not specific to the topics this chapter is focused on) and can be found in the code repository for this chapter.</p>
			<h3>Iterating through directory entries</h3>
			<p>In this subsection, let's <a id="_idIndexMarker298"/>review the code for <strong class="source-inline">get_image_files()</strong>. This is the method that retrieves the list of image files contained in a source folder.</p>
			<p>The logic for this method is described here:</p>
			<ol>
				<li value="1">We first retrieve the directory entries in the source folder and collect them in a <em class="italic">vector</em>. </li>
				<li>We then iterate over entries in the vector and filter for only the image files. Note that we are only focusing on <strong class="source-inline">PNG</strong> and <strong class="source-inline">JPG</strong> files in this project, but it can be extended to other types of image files too. </li>
				<li>A list of image files is returned from this method.</li>
			</ol>
			<p>The code listing is shown here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/resize.rs</p>
			<p class="source-code">pub fn <strong class="bold">get_image_files</strong>(src_folder: PathBuf) -&gt; </p>
			<p class="source-code">    Result&lt;Vec&lt;PathBuf&gt;, ImagixError&gt; {</p>
			<p class="source-code">    let entries = fs::read_dir(src_folder)</p>
			<p class="source-code">        .map_err(|e| ImagixError::UserInputError("Invalid </p>
			<p class="source-code">            source folder".to_string()))?</p>
			<p class="source-code">        .map(|res| res.map(|e| e.path()))</p>
			<p class="source-code">        .collect::&lt;Result&lt;Vec&lt;_&gt;, io::Error&gt;&gt;()?</p>
			<p class="source-code">        .into_iter()</p>
			<p class="source-code">        .filter(|r| {</p>
			<p class="source-code">            r.extension() == Some("JPG".as_ref())</p>
			<p class="source-code">                || r.extension() == Some("jpg".as_ref())</p>
			<p class="source-code">                || r.extension() == Some("PNG".as_ref())</p>
			<p class="source-code">                || r.extension() == Some("png".as_ref())</p>
			<p class="source-code">        })</p>
			<p class="source-code">        .collect();</p>
			<p class="source-code">    Ok(entries)</p>
			<p class="source-code">}</p>
			<p>The code uses the <strong class="source-inline">read_dir()</strong> method to iterate through directory entries and collects the results in a <strong class="source-inline">Vector</strong>. The <strong class="source-inline">Vector</strong> is then converted into an iterator, and the entries are filtered <a id="_idIndexMarker299"/>to return only image files. This gives us the set of image files to work with, for resizing. In the next subsection, we will review the code to perform the actual resizing of the images.</p>
			<h3>Resizing images</h3>
			<p>In this subsection, we will <a id="_idIndexMarker300"/>review the code for <strong class="source-inline">resize_image()</strong>. This method performs the resizing of images.</p>
			<p>The logic for this method is as follows:</p>
			<ol>
				<li value="1">The method accepts a source image filename with the full source folder path, resizes it as a <strong class="source-inline">.png</strong> file, and stores the resized file in a <strong class="source-inline">/tmp</strong> subfolder under the source folder.</li>
				<li>First, the source filename is extracted from the full path. The file extension is changed to <strong class="source-inline">.png</strong>. This is because our tool will only support output files in <strong class="source-inline">.png</strong> format. As an exercise, you can add support for other image format types.</li>
				<li>Then the destination file path is constructed with the <strong class="source-inline">/tmp</strong> prefix, as the resized image will need to be stored in the <strong class="source-inline">tmp</strong> subfolder under the source folder. To achieve this, we first need to check whether the <strong class="source-inline">tmp</strong> folder already exists. If not, it has to be created. The logic for constructing the path with the <strong class="source-inline">tmp</strong> subfolder and for creating the <strong class="source-inline">tmp</strong> subfolder is shown in the previous code listing.</li>
				<li>Finally, we need to resize the image. For this, the source file is opened, the resize function is called with requisite parameters, and the resized image is written to the output file.</li>
				<li>The time taken for image resizing is calculated using the <strong class="source-inline">Instant::now()</strong> and <strong class="source-inline">Elapsed::from()</strong> functions.</li>
			</ol>
			<p>The code listing is shown <a id="_idIndexMarker301"/>here. For purposes of explanation, the code listing has been split into multiple snippets.</p>
			<p>The code listed here accepts three input parameters – the size, source folder, and an entry of type <strong class="source-inline">PathBuf</strong> (which can refer to the full path of an image file). The file extension is changed to <strong class="source-inline">.png</strong> as this is the output format supported by the tool:</p>
			<p class="source-code">fn resize_image(size: u32, src_folder: &amp;mut PathBuf) -&gt; </p>
			<p class="source-code">    Result&lt;(), ImagixError&gt; {</p>
			<p class="source-code">    // Construct destination filename with .png extension</p>
			<p class="source-code">    let new_file_name = src_folder</p>
			<p class="source-code">        .file_stem()</p>
			<p class="source-code">        .unwrap()</p>
			<p class="source-code">        .to_str()</p>
			<p class="source-code">        .ok_or(std::io::ErrorKind::InvalidInput)</p>
			<p class="source-code">        .map(|f| format!("{}.png", f));</p>
			<p>The code snippet here appends the suffix <strong class="source-inline">/tmp</strong> to the file path entry in order to create the destination folder path. Note that due to a limitation in the standard library, the filename is first constructed as <strong class="source-inline">tmp.png</strong>, which is subsequently changed to reflect the final resized image filename:</p>
			<p class="source-code">// Construct path to destination folder i.e. create /tmp </p>
			<p class="source-code">// under source folder if not exists</p>
			<p class="source-code">let mut dest_folder = src_folder.clone();</p>
			<p class="source-code">dest_folder.pop();</p>
			<p class="source-code">dest_folder.push("tmp/");</p>
			<p class="source-code">if !dest_folder.exists() {</p>
			<p class="source-code">    fs::create_dir(&amp;dest_folder)?;</p>
			<p class="source-code">}</p>
			<p class="source-code">dest_folder.pop();</p>
			<p class="source-code">dest_folder.push("tmp/tmp.png");</p>
			<p class="source-code">dest_folder.set_file_name(new_file_name?.as_str());</p>
			<p>The code here opens the image file and loads the image data into memory. The <strong class="source-inline">/tmp</strong> subfolder is created <a id="_idIndexMarker302"/>under the source folder. Then, the image is resized and written to the output file in the destination folder. The time taken for the resizing operation is recorded and printed out:</p>
			<p class="source-code">let timer = Instant::now();</p>
			<p class="source-code">let img = image::open(&amp;src_folder)?;</p>
			<p class="source-code">let scaled = img.thumbnail(size, size);</p>
			<p class="source-code">let mut output = fs::File::create(&amp;dest_folder)?;</p>
			<p class="source-code">scaled.write_to(&amp;mut output, ImageFormat::Png)?;</p>
			<p class="source-code">println!(</p>
			<p class="source-code">    "Thumbnailed file: {:?} to size {}x{} in {}. Output </p>
			<p class="source-code">     file   </p>
			<p class="source-code">     in {:?}", </p>
			<p class="source-code">     src_folder, </p>
			<p class="source-code">     size,</p>
			<p class="source-code">     size,</p>
			<p class="source-code">     Elapsed::from(&amp;timer), </p>
			<p class="source-code">     dest_folder</p>
			<p class="source-code">    );</p>
			<p class="source-code">    Ok(())</p>
			<p class="source-code">}</p>
			<p>We have now seen <a id="_idIndexMarker303"/>the code for resizing images. Next, we will look at the code for generating image stats.</p>
			<h3>Image statistics</h3>
			<p>In the previous subsection, we <a id="_idIndexMarker304"/>looked at the code for image resizing. In this subsection, we will see the logic for generating image statistics. This method will count the number of image files in a specified source folder, and measure their total file size.</p>
			<p> The logic of the <strong class="source-inline">get_stats()</strong> method that we will use is described as follows:</p>
			<ol>
				<li value="1">The <strong class="source-inline">get_stats()</strong> method takes a source folder as its input parameter and returns two values: the number of image files in the folder, and the total aggregate size of all image files in the folder.</li>
				<li>Get a list of image files in the source folder by calling the <strong class="source-inline">get_image_files()</strong> method.</li>
				<li>The <strong class="source-inline">metadata()</strong> function in the <strong class="source-inline">std::path</strong> module allows us to query a file or directory for its metadata information. In our code, as we iterate through the directory entries, we aggregate the sizes of all files in one variable, <strong class="source-inline">sum</strong>. The <strong class="source-inline">sum</strong> variable is returned from the function along with the count of image file entries.</li>
			</ol>
			<p>The code listing is provided here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/stats.rs</p>
			<p class="source-code">pub fn get_stats(src_folder: PathBuf) -&gt; Result&lt;(usize, </p>
			<p class="source-code">    f64), ImagixError&gt; {</p>
			<p class="source-code">    let image_files = get_image_files</p>
			<p class="source-code">        (src_folder.to_path_buf())?;</p>
			<p class="source-code">    let size = image_files</p>
			<p class="source-code">        .iter()</p>
			<p class="source-code">        .map(move |f| f.metadata().unwrap().len())</p>
			<p class="source-code">        .sum::&lt;u64&gt;();</p>
			<p class="source-code">    Ok((image_files.len(), (size / 1000000) as f64))</p>
			<p class="source-code">}</p>
			<p>We have covered the <a id="_idIndexMarker305"/>code for the image processing functionality. We will now cover some details of our custom error handling for the project.</p>
			<h3>Error handling</h3>
			<p>Let's now take a look at <a id="_idIndexMarker306"/>our error handling design.</p>
			<p>As a part of our project, there may be many failure conditions that we have to handle. Some of them are given here:</p>
			<ul>
				<li>The source folder given by the user may be invalid.</li>
				<li>The specified file may not be present in the source folder.</li>
				<li>Our program may not have permission to read and write files.</li>
				<li>User inputs for size or mode may be incorrect.</li>
				<li>There may be errors during image resizing (for example, a corrupt file).</li>
				<li>There may be other types of internal processing errors.</li>
			</ul>
			<p>Let's define a custom error type to handle all these different types of errors in a unified manner, and provide the error as output to the users of our library:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/error.rs</p>
			<p class="source-code">pub enum <strong class="bold">ImagixError</strong> {</p>
			<p class="source-code">    FileIOError(String),</p>
			<p class="source-code">    UserInputError(String),</p>
			<p class="source-code">    ImageResizingError(String),</p>
			<p class="source-code">    FormatError(String),</p>
			<p class="source-code">}</p>
			<p>The names of the errors are mostly self-explanatory. <strong class="source-inline">FormatError</strong> is any error encountered while converting or printing values of parameters. The goal of defining this custom error type is that <a id="_idIndexMarker307"/>the various types of errors that may be encountered during processing, such as errors in user input, the inability to read through a directory or write to a file, an error in image processing, and so on, are converted into our custom error type.</p>
			<p>It is not enough to just define a custom error type. We also have to ensure that when errors happen in due course of the program's operation, these errors are translated into the custom error type. For example, an error in reading an image file raises an error defined in the <strong class="source-inline">std::fs</strong> module. This error should be caught and transformed into our custom error type. This way, regardless of whether there is an error in file operations or error processing, the program uniformly propagates the same custom error type for handling by the frontend interface to the user (in the case of this project, it is the command line).</p>
			<p>For the conversion of various types of errors into <strong class="source-inline">ImagixError</strong>, we will implement the <strong class="source-inline">From</strong> trait. We will also implement the <strong class="source-inline">Display</strong> trait for our error type so that the errors can be printed out to the console.</p>
			<p>Within each of the methods in the project modules, at the failure points, you will notice that <strong class="source-inline">ImagixError</strong> is raised and propagated back to the calling function. The source code can be found in the source folder for this chapter in the Packt code repository.</p>
			<p>This concludes the error handling subsection of the code.</p>
			<p>This also concludes this section on coding the <strong class="source-inline">imagix</strong> library. We have only walked through key code snippets as it isn't practical to print out the entire code listing inline in the chapter. I would urge <a id="_idIndexMarker308"/>the reader to go through the entire source code to understand how the various features are translated into idiomatic Rust code.</p>
			<p>In the next section, we will build the command-line application that wraps this library and provides the user interface.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Developing the command-line application and testing</h1>
			<p>In the previous section, we <a id="_idIndexMarker309"/>built the library for image resizing. In this section, we will review the design and key parts of the code for the main <a id="_idIndexMarker310"/>command-line application. </p>
			<p>Let's begin with some automated unit tests to test the image resizing functionality in <strong class="source-inline">resize.rs</strong>: This way we can confirm that the image resizing library works independently of any calling function.</p>
			<p>Two test cases are shown here in the following code—one to resize a single image, and the other to resize multiple images. You can replace the source folder and filenames in the code with your own:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/resize.rs</p>
			<p class="source-code">#[cfg(test)]</p>
			<p class="source-code">mod tests {</p>
			<p class="source-code">    use super::*;</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn <strong class="bold">test_single_image_resize</strong>() {</p>
			<p class="source-code">        let mut path = PathBuf::from("/tmp/images/</p>
			<p class="source-code">            image1.jpg");</p>
			<p class="source-code">        let destination_path = PathBuf::from(</p>
			<p class="source-code">            "/tmp/images/tmp/image1.png");</p>
			<p class="source-code">        match process_resize_request(SizeOption::Small, </p>
			<p class="source-code">            Mode::Single, &amp;mut path) {</p>
			<p class="source-code">            Ok(_) =&gt; println!("Successful resize of single      </p>
			<p class="source-code">                image"),</p>
			<p class="source-code">            Err(e) =&gt; println!("Error in single image: </p>
			<p class="source-code">                {:?}", e),</p>
			<p class="source-code">        }</p>
			<p class="source-code">        assert_eq!(true, destination_path.exists());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    #[test]</p>
			<p class="source-code">    fn <strong class="bold">test_multiple_image_resize</strong>() {</p>
			<p class="source-code">        let mut path = PathBuf::from("/tmp/images/");</p>
			<p class="source-code">        let _res = process_resize_request(</p>
			<p class="source-code">            SizeOption::Small, Mode::All, &amp;mut path);</p>
			<p class="source-code">        let destination_path1 = PathBuf::from(</p>
			<p class="source-code">            "/tmp/images/tmp/image1.png");</p>
			<p class="source-code">        let destination_path2 = PathBuf::from(</p>
			<p class="source-code">            "/tmp/images/tmp/image2.png");</p>
			<p class="source-code">        assert_eq!(true, destination_path1.exists());</p>
			<p class="source-code">        assert_eq!(true, destination_path2.exists());</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Place the <strong class="source-inline">image1.jpg</strong> and <strong class="source-inline">image2.jpg</strong> files in <strong class="source-inline">/tmp/images</strong> and execute the tests with the following command:</p>
			<p class="source-code">cargo test </p>
			<p>You can see the tests pass successfully. You can also inspect the resized images.</p>
			<p>As an exercise, you can add the test cases for the image stats function as well.</p>
			<p>We can <a id="_idIndexMarker311"/>now conclude that the <strong class="source-inline">imagix</strong> library works as intended. Let's now move on to designing the <a id="_idIndexMarker312"/>command-line application.</p>
			<p>We shall first look at the CLI requirements.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Designing the command-line interface</h2>
			<p>In this subsection, we will <a id="_idIndexMarker313"/>look at the design of the CLI. By design, we mean finalizing the structure of the CLI that the user will use. The CLI should be intuitive to use for the end user. The CLI must also accommodate some flexibility in its performing of different types of operations.</p>
			<p>The <strong class="source-inline">imagecli</strong> CLI will use a command-subcommand model like <strong class="source-inline">git</strong>.</p>
			<p>The CLI command structure is shown in <em class="italic">Figure 4.6</em>: </p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.6_B16405.jpg" alt="Figure 4.6 – Design of CLI commands"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Design of CLI commands</p>
			<p>Here are some examples of commands with parameters that the user can specify:</p>
			<ul>
				<li>For resizing images, the command is <strong class="source-inline">cargo run –-release resize</strong> with three parameters. </li>
				<li>For image statistics, the command is <strong class="source-inline">cargo run –-release stats</strong> with one parameter.</li>
				<li>For resizing a <a id="_idIndexMarker314"/>single image the command is <strong class="source-inline">cargo run --release resize --size small --mode single --srcfolder &lt;path-to-image-file/file-name.extn&gt;</strong>.</li>
				<li>For resizing multiple images, we use the <strong class="source-inline">cargo run --release resize --size medium --mode all --srcfolder &lt;path-to-folder-containing-images&gt;</strong> command.</li>
				<li>For image statistics, the <strong class="source-inline">cargo run --release  stats --srcfolder &lt;path-to-folder-containing-images&gt;</strong> command is used.</li>
			</ul>
			<p>The <strong class="source-inline">imagecli</strong> <strong class="source-inline">main()</strong> function parses the command-line parameters, handles user and processing errors with suitable messages to the user, and invokes the respective functions from the <strong class="source-inline">imagix</strong> library.</p>
			<p>Let's do a quick recap. To resize images, we need to know the following from the user:</p>
			<ul>
				<li>The mode (single or multiple files)</li>
				<li>The output size of the image file (small/medium/large) </li>
				<li>The source folder where the image file (or files) is located</li>
			</ul>
			<p>In this section, we designed the CLI for the tool. In the previous sections, we built the <strong class="source-inline">imagix</strong> library to <a id="_idIndexMarker315"/>resize images. We will now move on to the last part of the project, which is to develop the main command-line binary application that ties all the pieces together and accepts user inputs from the command-line.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Coding the command-line binary using structopt</h2>
			<p>In the previous section, we designed the interface for the command-line tool. In this section, we will see <a id="_idIndexMarker316"/>the code for the <strong class="source-inline">main()</strong> function that accepts <a id="_idIndexMarker317"/>user inputs from the command line and invokes the <strong class="source-inline">imagix</strong> library. This <strong class="source-inline">main()</strong> function will be compiled and built into the command-line binary tool. The user will invoke this executable for resizing images and provide the necessary command-line parameters. </p>
			<p>The <strong class="source-inline">main()</strong> function will be located in <strong class="source-inline">src/imagecli.rs</strong>, as we want the command-line tool binary name to be <strong class="source-inline">imagecli</strong>.</p>
			<p>Let's now review the code snippets for the command-line application. The <strong class="source-inline">main()</strong> function is located in the <strong class="source-inline">src/imagecli.rs</strong> file:</p>
			<ol>
				<li value="1">We will start with the imports section. Note the imports of the <strong class="source-inline">imagix</strong> library that we have written, and <strong class="source-inline">structOpt</strong> for command-line argument parsing:<p class="source-code">mod imagix;</p><p class="source-code">use ::imagix::error::ImagixError;</p><p class="source-code">use ::imagix::resize::{process_resize_request, Mode,  </p><p class="source-code">    SizeOption};</p><p class="source-code">use ::imagix::stats::get_stats;</p><p class="source-code">use std::path::PathBuf;</p><p class="source-code">use std::str::FromStr;</p><p class="source-code">use structopt::StructOpt;</p><p class="source-code">// Define commandline arguments in a struct</p></li>
				<li>We will now see the definition of the command-line parameters for the tool. For this we will use the <strong class="source-inline">structopt</strong> syntax. Refer to documentation at <a href="https://docs.rs/structopt">https://docs.rs/structopt</a>. Basically, we have defined an <strong class="source-inline">enum</strong> called <strong class="source-inline">Commandline</strong> and defined two subcommands, <strong class="source-inline">Resize</strong> and <strong class="source-inline">Stats</strong>. <strong class="source-inline">Resize</strong> takes <a id="_idIndexMarker318"/>three arguments: <strong class="source-inline">size</strong>, <strong class="source-inline">mode</strong> and <strong class="source-inline">srcfolder</strong> (the <a id="_idIndexMarker319"/>source folder). <strong class="source-inline">Stats</strong> takes one argument: <strong class="source-inline">srcfolder</strong>:<p class="source-code">#[derive(StructOpt, Debug)]</p><p class="source-code">#[structopt(</p><p class="source-code">    name = "resize",</p><p class="source-code">    about = "This is a tool for image resizing and </p><p class="source-code">        stats",</p><p class="source-code">    help = "Specify subcommand resize or stats. For </p><p class="source-code">        help, type imagecli resize --help or </p><p class="source-code">        imagecli stats --help"</p><p class="source-code">)]</p><p class="source-code">enum <strong class="bold">Commandline</strong> {</p><p class="source-code">    #[structopt(help = "</p><p class="source-code">          Specify size(small/medium/large),</p><p class="source-code">          mode(single/all) and srcfolder")]</p><p class="source-code"><strong class="bold">    Resize</strong> {</p><p class="source-code">        #[structopt(long)]</p><p class="source-code">        size: SizeOption,</p><p class="source-code">        #[structopt(long)]</p><p class="source-code">        mode: Mode,</p><p class="source-code">        #[structopt(long, parse(from_os_str))]</p><p class="source-code">        srcfolder: PathBuf,</p><p class="source-code">    },</p><p class="source-code">    #[structopt(help = "Specify srcfolder")]</p><p class="source-code"><strong class="bold">    Stats</strong> {</p><p class="source-code">        #[structopt(long, parse(from_os_str))]</p><p class="source-code">        srcfolder: PathBuf,</p><p class="source-code">    },</p><p class="source-code">}</p></li>
				<li>We can now review the code for the <strong class="source-inline">main()</strong> <a id="_idTextAnchor080"/>function. Here, we basically accept the command-line inputs (validated by <strong class="source-inline">StructOpt</strong>) and invoke the suitable <a id="_idIndexMarker320"/>methods from our <strong class="source-inline">imagix</strong> library. If the user <a id="_idIndexMarker321"/>specifies the <strong class="source-inline">Resize</strong> command, the <strong class="source-inline">process_resize_request()</strong> method of the <strong class="source-inline">imagix</strong> library is invoked. If the user specifies the <strong class="source-inline">Stats</strong> command, the <strong class="source-inline">get_stats()</strong> method of the <strong class="source-inline">imagix</strong> library is invoked. Any errors are handled with suitable messages:<p class="source-code"><strong class="bold">fn main()</strong> {</p><p class="source-code">    let args: Commandline = Commandline::from_args();</p><p class="source-code">    match args {</p><p class="source-code">        Commandline::Resize {</p><p class="source-code">            size,</p><p class="source-code">            mode,</p><p class="source-code">            mut srcfolder,</p><p class="source-code">        } =&gt; {</p><p class="source-code">            match <strong class="bold">process_resize_request</strong>(size, mode, </p><p class="source-code">                &amp;mut src_folder) {</p><p class="source-code">                Ok(_) =&gt; println!("Image resized    </p><p class="source-code">                    successfully"),</p><p class="source-code">                Err(e) =&gt; match e {</p><p class="source-code">                    ImagixError::FileIOError(e) =&gt; </p><p class="source-code">                        println!("{}", e),</p><p class="source-code">                    ImagixError::UserInputError(e) =&gt; </p><p class="source-code">                        println!("{}", e),</p><p class="source-code">                    ImagixError::ImageResizingError(e)     </p><p class="source-code">                        =&gt; println!("{}", e),</p><p class="source-code">                    _ =&gt; println!("Error in </p><p class="source-code">                        processing"),</p><p class="source-code">                },</p><p class="source-code">            };</p><p class="source-code">        }</p><p class="source-code">        Commandline::Stats { srcfolder } =&gt; match </p><p class="source-code">            <strong class="bold">get_stats</strong>(srcfolder) {</p><p class="source-code">            Ok((count, size)) =&gt; println!(</p><p class="source-code">                "Found {:?} image files with aggregate </p><p class="source-code">                size of {:?} MB",</p><p class="source-code">                count, size</p><p class="source-code">            ),</p><p class="source-code">            Err(e) =&gt; match e {</p><p class="source-code">                ImagixError::FileIOError(e) =&gt; </p><p class="source-code">                    println!("{}", e),</p><p class="source-code">                ImagixError::UserInputError(e) =&gt;    </p><p class="source-code">                    println!("{}", e),</p><p class="source-code">                _ =&gt; println!("Error in processing"),</p><p class="source-code">            },</p><p class="source-code">        },</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Build the app with the following command:<p class="source-code"><strong class="bold"> cargo build --release </strong></p></li>
			</ol>
			<p>The <a id="_idIndexMarker322"/>reason to use the release builds is that there is a considerable time difference in resizing images <a id="_idIndexMarker323"/>between the debug and release builds (the latter being much faster).</p>
			<p>You can then execute and test the following scenarios at the Terminal. Ensure to place one or more <strong class="source-inline">.png</strong> or <strong class="source-inline">.jpg</strong> files in the folder that you specify in <strong class="source-inline">--srcfolder</strong> flag:</p>
			<ul>
				<li><strong class="bold">Resize a single image</strong>:<p class="source-code"><strong class="bold">cargo run --release resize --size medium --mode single --srcfolder &lt;path-to-image-file&gt;</strong></p></li>
				<li><strong class="bold">Resize multiple files</strong>:<p class="source-code"><strong class="bold">cargo run --release resize --size small --mode all --srcfolder &lt;path-to-image-file&gt;</strong></p></li>
				<li><strong class="bold">Generate image stats</strong>:<p class="source-code"><strong class="bold">cargo run --release  stats --srcfolder &lt;path-to-image-folder&gt;</strong></p></li>
			</ul>
			<p>In this section, we have built a tool for image resizing that works from a CLI. As an exercise, you can experiment by adding additional features, including adding support for more image formats, changing the size of the output file, or even providing the option to encrypt the generated image file for additional security.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor081"/>Summary</h1>
			<p>In this chapter, we learned to write Rust programs that can discover and manipulate the system environment, directory structures, and filesystem metadata in a cross-platform manner, using the <strong class="source-inline">std::env</strong>, <strong class="source-inline">std::path</strong>, and <strong class="source-inline">std::fs</strong> modules. We looked at how to create programs that can use command-line arguments or environment variables to accept configuration parameters and user inputs. We saw the use of two third-party crates: the <strong class="source-inline">StructOpt</strong> crate to improve the user interface of the tool, and <strong class="source-inline">image-rs/image</strong> to do the image resizing.</p>
			<p>We also learned how to use the <strong class="source-inline">std:time</strong> module to measure the time taken for specific processing tasks. We defined a custom error type to unify error handling in the library. In this chapter, we were also introduced to file handling operations.</p>
			<p>In the next chapter, we will take a detailed look at doing advanced memory management with the standard library.</p>
		</div>
	</body></html>