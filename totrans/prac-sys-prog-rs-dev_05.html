<html><head></head><body>
		<div><h1 id="_idParaDest-68"><em class="italic">Chapter 4</em>: <a id="_idTextAnchor070"/>Managing Environment, Command Line, and Time</h1>
			<p>In the previous chapter, we looked at how the Rust Standard Library is structured. We also wrote a portion of a basic template engine that can generate dynamic HTML page components given an HTML template and data. From here onward, we will start to deep-dive into specific modules of the standard library grouped by functional areas.</p>
			<p>In this chapter, we will look at Rust Standard Library modules that pertain to working with system environment, command-line, and time-related functions. The goal of this chapter is for you to gain more proficiency in working with <em class="italic">command-line parameters</em>, <em class="italic">path manipulation, environment variables</em>, and <em class="italic">time measurements.</em></p>
			<p>What is the benefit of learning about these?</p>
			<p>Working with <em class="italic">command-line arguments</em> is a required skill for writing any program that accepts user inputs from the command line.</p>
			<p>Imagine how you would write a tool (such as <strong class="bold">find</strong> or <strong class="bold">grep</strong>) that deals with searching for files and patterns within folders and subfolders. This requires knowledge of <em class="italic">path manipulation</em>, including navigating paths and reading and manipulating path entries.</p>
			<p>Learning to use <em class="italic">environment variables</em> is an essential part of separating the code from the configuration, which is a good practice for any kind of program.</p>
			<p>Learning to work with time is required for programs that deal with timestamps of resources and activities. Learning how to do <em class="italic">time measurements</em> to record time intervals between events is needed for benchmarking the time taken for various operations.</p>
			<p>In this chapter, you will learn the following skills:</p>
			<ul>
				<li>Writing Rust programs that can discover and manipulate the system environment and filesystem across Linux, Unix, and Windows platforms</li>
				<li>Creating programs that can use command-line arguments to accept configuration parameters and user inputs</li>
				<li>Capturing elapsed time between events</li>
			</ul>
			<p>These are relevant skills to have for systems programming in Rust. We will learn these topics in a practical way by developing a command-line application for image processing. Along the way, we will see more details about the <code>path</code>, <code>time</code>, <code>env</code>, and <code>fs</code> modules of the Rust Standard Library.</p>
			<p>First, let's see what we will be building.</p>
			<p>Imagine that we had a tool for bulk image resizing – tool that would look through a filesystem directory on a desktop or server, pull out all the image files (for instance, <code>.png</code> and <code>.jpg</code>), and resize all of them to predefined sizes (for example, small, medium, or large).</p>
			<p>Think about how helpful such a tool would be for freeing up space on the hard disk, or for uploading pictures to show in a mobile or web app. We will be building such a tool. Fasten your seat belts.</p>
			<p>We will cover the topics in the following order:</p>
			<ul>
				<li>Project scope and design overview</li>
				<li>Coding the image resizing library</li>
				<li>Developing the command-line application</li>
			</ul>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Technical requirements</h1>
			<p>The GitHub repo for the code in this chapter can be found at <a href="https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04">https://github.com/PacktPublishing/Practical-System-Programming-for-Rust-Developers/tree/master/Chapter04</a>.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor072"/>Project scope and design overview</h1>
			<p>In this section, we <a id="_idIndexMarker249"/>will first define what we are going to build and look at the <a id="_idIndexMarker250"/>technical design. We will then code a Rust library for image processing. Finally, we will build a command-line application that accepts user inputs through the command line and uses the image resizing library we have built to perform user-specified commands.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>What will we build? </h2>
			<p>In this subsection, we will describe the functional requirements, technical requirements, and project structure for the tool we are building.</p>
			<h3>Functional requirements</h3>
			<p>We will <a id="_idIndexMarker251"/>build a command-line <a id="_idIndexMarker252"/>tool that performs the <a id="_idIndexMarker253"/>following two operations:</p>
			<ul>
				<li><strong class="bold">Image resize</strong>: Resizes one or <a id="_idIndexMarker254"/>more images in a source folder to a specified size</li>
				<li><strong class="bold">Image stats</strong>: Provides some <a id="_idIndexMarker255"/>statistics on the image files present in the source folder</li>
			</ul>
			<p>Let's name the tool <strong class="bold">ImageCLI</strong>. <em class="italic">Figure 4.1</em> shows the two main features of the tool:</p>
			<div><div><img src="img/Figure_4.1_B16405.jpg" alt="Figure 4.1 – Features of ImageCLI tool"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Features of ImageCLI tool</p>
			<p>Users will be able to resize images using this tool. The user can ask to resize either a single image or multiple images. Supported <em class="italic">input</em> image formats are JPG and PNG. The supported <em class="italic">output</em> image format is PNG. The tool will accept three command-line parameters as follows:</p>
			<ul>
				<li><code>size = small</code>, the output image will have <em class="italic">200</em> pixels of width; for <code>size = medium</code>, the output file will have <em class="italic">400</em> pixels of width; and for <code>size = large</code>, the output will have <em class="italic">800</em> pixels of width. For example, if the input image is a JPG file with a total size of 8 MB, it can be resized to approximately &lt; 500 KB in size by specifying <code>size = medium</code>.</li>
				<li><code>mode = single</code> for resizing a single file, or <code>mode = all</code> for resizing all image files in a specified folder. </li>
				<li><code>mode = single</code> or <code>mode = all</code> is chosen. For <code>mode = single</code>, the user specifies the value of <code>srcfolder</code> as the full path of the image file with its filename. For <code>mode = all</code>, the user specifies, for the value of <code>srcfolder</code>, the full path of the folder (the one containing the image files) without any image filenames. For example, if <code>mode = single</code> and <code>srcfolder = /user/bob/images/image1.png</code> are used, the tool will resize the single image file of <code>image1.png</code>, contained in the <code>/user/bob/images</code> folder. If <code>mode = all</code> and <code>srcfolder = /user/bob/images</code> are used, the tool will resize <em class="italic">all</em> the image files contained in the <code>/user/bob/images</code> source folder.</li>
			</ul>
			<p>For our <a id="_idIndexMarker259"/>image stats functionality, users <a id="_idIndexMarker260"/>will also be able to specify a <code>srcfolder</code> containing the image files and get back the number of image files in that folder, along with the total size of all those image files. For example, if <code>srcfolder=/user/bob/images</code> is used, the <code>image stats</code> option will give a result similar to the following: <strong class="bold">The folder contains 200 image files with total size 2,234 MB</strong>.</p>
			<h3>Non-functional requirements</h3>
			<p>The following are a list of <a id="_idIndexMarker261"/>non-functional (technical) requirements <a id="_idIndexMarker262"/>for the project:</p>
			<ul>
				<li>The tool will be packaged and distributed as a binary and it should work on three platforms: Linux, Unix, and Windows.</li>
				<li>We should be able to measure the time taken to resize the images.</li>
				<li>User inputs for specifying command-line flags must be <em class="italic">case-insensitive</em> for ease of use.</li>
				<li>The tool must be able to display meaningful error messages to the user.</li>
				<li>The core functionality <a id="_idIndexMarker263"/>of image resizing must be separate from the <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>). This way, we have the flexibility of reusing the core functionality with a desktop graphical interface or as part of a web backend in a web application.</li>
				<li>The project will be organized as a <strong class="bold">library</strong> containing the image processing functionality and a <strong class="bold">binary</strong> that provides the CLI to read and parse user input, provide error messages, and display output messages to the user. The binary will make use of the library for core image processing.</li>
			</ul>
			<h3>Project structure</h3>
			<p>Let's create the project <a id="_idIndexMarker264"/>skeleton so we can visualize the project structure better. Create a new <code>lib</code> project using <code>cargo</code>. Let's name the CLI tool as <code>imagecli</code> using the following command:</p>
			<pre>cargo new --lib imagecli &amp;&amp; cd imagecli</pre>
			<p>Here is the project structure:</p>
			<div><div><img src="img/Figure_4.2_B16405.jpg" alt="Figure 4.2 – Cargo project structure"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Cargo project structure</p>
			<p>Set up the project structure as follows:</p>
			<ol>
				<li>Under the <code>src</code> folder, create <a id="_idIndexMarker265"/>a subfolder called <code>imagix</code> (for image magic!) to host the library code. Under the <code>imagix</code> subfolder, create four files: <code>mod.rs</code>, which is the entry point into the <code>imagix</code> library, <code>resize.rs</code> to host the code related to image resizing, <code>stats.rs</code> to host the code for image file statistics, and <code>error.rs</code> to contain the custom error type and error handling code.</li>
				<li>Under the <code>src</code> folder, create a new file called <code>imagecli.rs</code>, which will contain the code for the CLI.</li>
			</ol>
			<p>In this subsection, we have seen the feature requirements for the tool and the desired project structure. In the next subsection, we will look at the design for the tool.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>Technical design</h2>
			<p>In this subsection, we will <a id="_idIndexMarker266"/>look at the high-level design of the tool, primarily focusing on the image processing feature. We will design the specifics of the CLI in the <em class="italic">Developing the command-line application and testing</em> section.</p>
			<p>Our project comprises our reusable <code>imagix</code> library containing the core functionality for image resizing and statistics, and a binary executable, <code>imagecli</code>, with a CLI. This is depicted in <em class="italic">Figure 4.3</em>:</p>
			<div><div><img src="img/Figure_4.3_B16405.jpg" alt="Figure 4.3 – CLI tool with a reusable library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – CLI tool with a reusable library</p>
			<p>If the library is <a id="_idIndexMarker267"/>designed right, it can be reused in the future for other types of clients; for example, the application can be provided with a graphical user interface (instead of a CLI) as a desktop application, or can even be made accessible from a browser-based HTML client app.</p>
			<p>Before we begin the design, let's try to visualize a few of the key technical challenges we have to overcome and solve:</p>
			<ul>
				<li><code>/tmp/</code> subfolder to store the resized images?</p><p>How do we measure the time taken for image resizing?</p></li>
				<li><strong class="bold">Resizing multiple images</strong>:<p>How do we iterate through the <a id="_idIndexMarker269"/>source folder provided by the user to identify all the image files and invoke the image resizing function for each entry?</p></li>
				<li><strong class="bold">Getting image statistics</strong>:<p>How do we scan through the <a id="_idIndexMarker270"/>user-provided source folder, count only the number of image files, and get the aggregate file size of all image files in that folder?</p></li>
				<li><code>tmp</code> subfolder?</p></li>
			</ul>
			<p>The preceding points can be grouped into three broad categories of concerns for design purposes:</p>
			<ul>
				<li>Image resizing logic</li>
				<li>Path manipulation and directory-iteration logic</li>
				<li>Measuring time taken for image resizing</li>
			</ul>
			<p>Image processing is a highly-specialized domain in itself, and it is beyond the scope of this book to cover the <a id="_idIndexMarker272"/>techniques and algorithms involved. Given the complexity and scope of the image processing domain, we will use a third-party library that will implement the needed algorithms and provide us with a nice API to call.</p>
			<p>For this purpose, we will use the <code>image-rs/image</code> open source crate that is written in Rust. The crate docs are at the following link: <a href="https://docs.rs/image/">https://docs.rs/image/</a></p>
			<p>Let's look at how we can design the <code>imagix</code> library using the <code>image</code> crate.</p>
			<p>The <code>image</code> crate is fully featured and has many image processing functions. We will however use only a small subset of features for our project. Let's recall our three key requirements for image processing: the ability to <em class="italic">open an image file and load it into memory</em>, the ability to <em class="italic">resize the image to a desired size</em>, and the ability to <em class="italic">write the resized image from memory into a file</em> on the disk. The following methods in the <code>image-rs/image</code> crate address our needs:</p>
			<ul>
				<li><code>image::open()</code>: This function opens an image at the specified path. It automatically detects the format of the image from the image's file extension. The image data is read from the file and converted into a <code>DynamicImage</code> type stored in memory.</li>
				<li><code>DynamicImage::thumbnail()</code>: This function scales an image down to a specified size (width and height) and returns a new image while preserving the aspect ratio. It uses a fast integer algorithm, which is a sinusoidal <a id="_idIndexMarker273"/>transformation technique. This is an <strong class="bold">in-memory operation</strong>.</li>
				<li><code>DynamicImage::write_to()</code>: This function encodes an image and writes it to any object that implements the <code>std::io::write</code> trait, which in our case will be an output <em class="italic">file handle</em>. We will use this method to write the resized image to a file.</li>
			</ul>
			<p>This should be adequate for our <a id="_idIndexMarker274"/>image processing requirements in this project. For the other two concerns around path manipulation and time measurements, we will use the Rust Standard Library, which is described in the next subsection.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Using the Rust Standard Library</h2>
			<p>For <a id="_idIndexMarker275"/>developing the image resizing tool, we will be <a id="_idIndexMarker276"/>using both external crates and the Rust Standard Library. In the previous section, we saw how we plan to use the <code>image</code> crate.</p>
			<p>In this section, we will cover the features of the Rust Standard Library that we will be using to build our project. There are three key areas where we will need the standard library:</p>
			<ul>
				<li>The<em class="italic"> path manipulation and directory iteration</em> functionality is needed in order to search through a directory, locate the image files, and create a new subfolder.</li>
				<li>We need to get <a id="_idIndexMarker277"/>tool configuration options from the user. We will evaluate two approaches – getting this <a id="_idIndexMarker278"/>information through <em class="italic">environment variables</em> and getting it through <em class="italic">command-line parameters</em>. We will choose one of the options.</li>
				<li>We want to <em class="italic">measure the time taken</em> for the image resizing tasks.</li>
			</ul>
			<p>Let's take a look at each of these areas in detail.</p>
			<h3>Path manipulation and directory iteration</h3>
			<p>For path <a id="_idIndexMarker279"/>manipulation, we will use the <code>std::path</code> module from the Rust Standard Library. For directory <a id="_idIndexMarker280"/>iteration, we will use the <code>std::fs</code> module.</p>
			<p>Why do we need to manipulate paths?</p>
			<p>The source image files for resizing are stored in the <em class="italic">source folder</em>. The destination path for the resized image files is the <code>tmp</code> subfolder (within the <em class="italic">source folder</em>). Before writing each resized image file to disk, we have to construct the path where the file is to be stored. For example, if the path for the source file is <code>/user/bob/images/image1.jpg</code>, the destination path for the resized image will be <code>/user/bob/images/tmp/image1.jpg</code>. We have to construct the destination path programmatically, and then call the method on the <code>image</code> crate to store the image on the destination path.</p>
			<p>The Rust Standard Library supports path manipulation functionality through two data types: <code>Path</code> and <code>PathBuf</code>, both part of the <code>std::path</code> module. See the sidebar for more details on how to construct and manipulate <code>paths</code> using the standard library.</p>
			<p class="callout-heading">The std::path module of the Rust Standard Library</p>
			<p class="callout">This module provides cross-platform path manipulation functions.</p>
			<p class="callout">A path points to a filesystem location by following a directory tree. An example of a path in Unix systems is <code>/home/bob/images/</code>. An example of a path on the Windows operating system could be <code>c:\bob\images\image1.png</code>.</p>
			<p class="callout">There are two main types in the <code>std::path</code> module that are commonly used—<code>Path</code> and <code>PathBuf</code>.</p>
			<p class="callout">For parsing the path and its components (read operations), <code>Path</code> is used. In Rust parlance, it is a <strong class="bold">path slice</strong> (like a <a id="_idIndexMarker281"/>string slice, which is a reference to a string).</p>
			<p class="callout">For modifying existing paths or to construct new paths, <code>PathBuf</code> is used. <code>PathBuf</code> is an <strong class="bold">owned</strong>, <strong class="bold">mutable path</strong>.</p>
			<p class="callout"><code>Path</code> is used for read operations and <code>PathBuf</code> for read and write operations on paths.</p>
			<p class="callout">Here is how <a id="_idIndexMarker282"/>to construct a new path <a id="_idIndexMarker283"/>from a string:</p>
			<p class="callout"><code>let path_name = Path::new("/home/alice/foo.txt");</code></p>
			<p class="callout">In <code>path_name</code>, <code>/home/alice</code> represents the parent, <code>foo</code> is the file stem, and <code>txt</code> is the file extension. We will be making use of the <code>file_stem()</code> and <code>extension()</code> methods on the <code>Path</code> type.</p>
			<p class="callout">The <code>pop()</code> and <code>push()</code> methods on the <code>PathBuf</code> type are used to truncate and append components to a path.</p>
			<p class="callout">Let's create a new <code>PathBuf</code> path with the following code:</p>
			<p class="callout"><code>let mut path_for_editing = PathBuf::from("/home/bob/file1.png")</code></p>
			<p class="callout"><code>path_for_editing.pop()</code> truncates this path to its parent, that is, <code>"/home/bob"</code>.</p>
			<p class="callout">Now, <code>push()</code> can be used to append a new component to <code>PathBuf</code>. For example, continuing from <code>PathBuf</code> with the value <code>"/home/bob"</code>, <code>push("tmp")</code> will append <code>tmp</code> to <code>"/home/bob"</code> path and return <code>"/home/bob/tmp"</code>.</p>
			<p class="callout">We will be using the <code>pop()</code> and <code>push()</code> methods in our project to manipulate paths.</p>
			<p>Let's next look at how to perform the directory operations needed for our project.</p>
			<p>When the user specifies <code>mode=all</code>, our requirement is to iterate through all the files in the specified source <a id="_idIndexMarker284"/>folder and filter the list of <a id="_idIndexMarker285"/>image files for processing. For iterating over directory paths, we will use the <code>read_dir()</code> function in the <code>std::fs</code> module.</p>
			<p>Let's see an example of how to use this function:</p>
			<pre>use std::fs;
 
fn main() {
    let entries = fs::read_dir("/tmp").unwrap();
    for entry in entries {
        if let Ok(entry) = entry {
            println!("{:?}", entry.path());
        }
    }
}</pre>
			<p>The following is the explanation for the preceding code:</p>
			<ol>
				<li value="1"><code>fs:read_dir()</code> takes a source folder path and returns <code>std::fs::ReadDir</code>, which is an iterator over entries in the directory.</li>
				<li>We then use a <code>for</code> loop to extract each directory entry (which is wrapped in a <code>Result</code> type), and print out its value.</li>
			</ol>
			<p>This is the code we will use to get entries in a directory and do further processing.</p>
			<p>Apart from reading a <a id="_idIndexMarker286"/>directory for its contents, we <a id="_idIndexMarker287"/>also need to check for the presence of a <code>tmp</code> subfolder under the source folder and create it if it does not already exist. We will use the <code>create_dir()</code> method from the <code>std::fs</code> module to create a new subdirectory.</p>
			<p>We will see more details of the <code>std::fs</code> module in a later chapter.</p>
			<h3>Time measurement</h3>
			<p>For measuring time, we can use the <code>std::time</code> module.</p>
			<p>The <code>std::time</code> module in <a id="_idIndexMarker288"/>the Rust Standard Library has several time-related functions including getting the <em class="italic">current system time</em>, creating a <em class="italic">duration</em> to represent a span of time, and measuring the <em class="italic">time elapsed</em> between two specific time instants. Some examples of using the <code>time</code> module are provided in the following.</p>
			<p>To get the current system time, we can write the following code:</p>
			<pre>use std::time::SystemTime;
fn main() {
    let _now = SystemTime::now();
}</pre>
			<p>Here is how to get the elapsed time from a given point in time:</p>
			<pre>use std::thread::sleep;
use std::time::{Duration, Instant};
fn main() {
    let now = Instant::now();
    sleep(Duration::new(3, 0));
    println!("{:?}", now.elapsed().as_secs());
}</pre>
			<p><code>Instant::now()</code> is used to indicate the starting point of the time to be measured. The time duration between this <a id="_idIndexMarker289"/>point and the point at which <code>now.elapsed()</code> is called represents the time taken for the operation(s). Here, we are simulating a delay using the <code>sleep()</code> function from the <code>std::thread</code> module.</p>
			<h3>Working with environment variables</h3>
			<p>In this subsection, we will learn <a id="_idIndexMarker290"/>how to use the Rust Standard Library, along with a third-party helper crate, to store the values in environment variables and use them in the program:</p>
			<ol>
				<li value="1">Create a new project with the following line of code:<pre><code>.env</code> file (instead of setting them in the console), so let's add a popular crate for this purpose, called <code>dotenv</code>, in <code>Cargo.toml</code>:</p><pre>[dependencies]
dotenv = "0.15.0"</pre><p>Depending on when you are reading this book, you may have a later version of this tool available, which you may choose to use.</p></li>
				<li>In <code>main.rs</code>, add the following code:<pre>use dotenv::dotenv;
use std::env;
fn main() {
dotenv().ok();
for (key, value) in env::vars() {
    println!("{}:{}", key, value);
}
}</pre><p>In the preceding code, we import the <code>std::env</code> module and also the <code>dotenv::dotenv</code> module.</p><p>The following statement loads the environment variables from an <code>.env</code> file:</p><pre>dotenv().ok();</pre><p>The <code>for</code> loop in the <a id="_idIndexMarker291"/>previous code block iterates through the environment variables in a loop and prints them to the console. <code>env:vars()</code> returns an iterator of key-value pairs for all environment variables of the current process.</p></li>
				<li>To test this, let's create a new<code>.env</code> file in the project root and make the following entries:<pre>size=small
mode=single
srcfolder=/home/bob/images/image1.jpg </pre></li>
				<li>Replace the <code>srcfolder</code> value with your own. Run the program with the following command:<pre><code>.env</code> file printed out, along with the others associated with the process.</p></li>
				<li>To access the value of any particular environment variable, the <code>std::env::var()</code> function can be used, which takes the key of the variable as a parameter. Add the following statement to the <code>main()</code> function and see the value of the <code>size</code> variable <a id="_idIndexMarker292"/>printed out:<pre>println!("Value of size is {}",   
    env::var("size").unwrap());</pre></li>
			</ol>
			<p>We have seen how to use <em class="italic">environment variables</em> to accept user inputs for image processing. Let's see how to accept user inputs with <em class="italic">command-line</em> parameters.</p>
			<h3>Working with command-line parameters</h3>
			<p>In this subsection, we <a id="_idIndexMarker293"/>will learn to read command-line parameters using the <code>std::env</code> module of the Rust Standard Library:</p>
			<ol>
				<li value="1">The <code>std::env</code> module supports command-line parameters through <code>std::env::args()</code>. Create a new Cargo project. Add the following line to the <code>main()</code> function in <code>src/main.rs</code>:<pre>use std::env;
fn main() {
    for argument in env::args() {
        println!("{}", argument);
    }
}</pre></li>
				<li>Execute the code with <code>cargo run small all /tmp</code>.</li>
				<li>The three parameters passed to the program will be printed out to the console. To access individual parameters by index, add the following code to <code>main.rs</code>:<pre>use std::env;
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let size = &amp;args[1];
    let mode = &amp;args[2];
    let source_folder = &amp;args[3];
    println!(
        "Size:{},mode:{},source folder: {}",
        size, mode, source_folder
    );
}</pre></li>
				<li>Run the program with <code>cargo run small all /tmp</code>.</li>
			</ol>
			<p>The individual values for <code>size</code>, <code>mode</code>, and <code>source_folder</code> will be printed out as shown here:</p>
			<pre>Size:small,mode:all,source folder: /tmp</pre>
			<p>Of the two <a id="_idIndexMarker294"/>approaches we have seen – that is, using <em class="italic">environment variables</em> and <em class="italic">command-line parameters</em> – the latter is more suitable for accepting inputs from end users, while the environment variable approach is more suitable for developers configuring the tool.</p>
			<p>However, for a user-friendly interface, the bare-bones functionality offered by <code>std::env::args</code> is inadequate. We will use a third-party crate called <strong class="bold">StructOpt</strong> to improve the user interaction with the CLI.</p>
			<p>This concludes the deep dive into the Rust Standard Library modules for path manipulation, time measurement, and reading environment and command-line parameters.</p>
			<p>Here is a summary of the design approaches we have discussed, for the <code>imagix</code> library:</p>
			<ul>
				<li><code>image-rs/image</code> crate.</p><p>How do we create a <code>/tmp/</code> subfolder to store the resized images? </p><p>We will use the <code>std::fs::create_dir()</code> method.</p></li>
				<li><code>std::fs::read_dir()</code> method.</p><p>How do we manipulate paths so that the output file is stored in the <code>tmp</code> subfolder?</p><p>We will use the <code>std::path::Path</code> and <code>std::path::PathBuf</code> types.</p></li>
				<li><code>std::path::Path</code> type and the <code>std::fs::read_dir()</code> method.</p></li>
				<li><code>std::time::Duration</code> and <code>std::time::Instant</code> modules.</p></li>
				<li><code>StructOpt</code> crate.</p></li>
			</ul>
			<p>With this, we conclude this section on addressing project scope and design for the <code>imagix</code> library. We are now ready to start writing the code for the image processing library in the next section.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor076"/>Coding the imagix library</h1>
			<p>In this section, we'll write the <a id="_idIndexMarker295"/>code for the image resizing and image statistics functionalities. Let's first look at the code structure.</p>
			<p>The module structure of the <code>imagix</code> library is summarized in <em class="italic">Figure 4.4</em>:</p>
			<div><div><img src="img/Figure_4.4_B16405.jpg" alt="Figure 4.4 – Modules of the imagix library"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Modules of the imagix library</p>
			<p>The <code>imagix</code> library will consist of two modules, <code>resize.rs</code> and <code>stats.rs</code> respectively. There are two <code>enums</code>, <code>SizeOption</code> and <code>Mode</code>, for representing the variants for <em class="italic">size option </em>and <em class="italic">mode</em> respectively. The user will specify one of the variants of the <code>SizeOption</code> <code>enum</code> to indicate the desired output image size, and one of the variants of the <code>Mode</code> <code>enum</code> to indicate whether one or multiple images need to be resized. There is also <code>struct Elapsed</code> for capturing elapsed time of the image resizing operation.</p>
			<p>The <code>resize</code> module has the <code>process_resize_request()</code> public function, which is the main entry point into the <code>imagix</code> library for resizing images.</p>
			<p>The <code>stats</code> module has a <code>get_stats()</code> public function.</p>
			<p>An overview of the overall code organization of the project is shown in <em class="italic">Figure 4.5</em>:</p>
			<div><div><img src="img/Figure_4.5_B16405.jpg" alt="Figure 4.5 – Code organization"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Code organization</p>
			<p><em class="italic">Figure 4.5</em> shows the <a id="_idIndexMarker296"/>following:</p>
			<ul>
				<li>The configuration and dependency entries needed in the <code>Cargo.toml</code> file</li>
				<li>The Cargo project's code tree structure</li>
				<li>The list of source files of the <code>imagix</code> library along with a list of the key functions</li>
				<li>The <code>imagecli.rs</code> file, which represents the command-line wrapper over the <code>imagix</code> library, and the code execution entry point in our tool</li>
			</ul>
			<p>Let's first add the two external crates to <code>Cargo.toml</code> in the <code>imagecli</code> project folder root:</p>
			<pre>[dependencies]
image = "0.23.12"
structopt = "0.3.20"</pre>
			<p>In this section, we will walk through the code snippets for the following methods:</p>
			<ul>
				<li><code>get_image_files()</code>, which demonstrates path navigation</li>
				<li><code>resize_image()</code>, which contains the core logic for image resizing using the image crate, and for time measurements</li>
				<li><code>get_stats()</code>, which returns the total count and the total size of image files in a folder</li>
				<li>Custom error handling methods</li>
			</ul>
			<p>The rest of the code is <a id="_idIndexMarker297"/>standard Rust (not specific to the topics this chapter is focused on) and can be found in the code repository for this chapter.</p>
			<h3>Iterating through directory entries</h3>
			<p>In this subsection, let's <a id="_idIndexMarker298"/>review the code for <code>get_image_files()</code>. This is the method that retrieves the list of image files contained in a source folder.</p>
			<p>The logic for this method is described here:</p>
			<ol>
				<li value="1">We first retrieve the directory entries in the source folder and collect them in a <em class="italic">vector</em>. </li>
				<li>We then iterate over entries in the vector and filter for only the image files. Note that we are only focusing on <code>PNG</code> and <code>JPG</code> files in this project, but it can be extended to other types of image files too. </li>
				<li>A list of image files is returned from this method.</li>
			</ol>
			<p>The code listing is shown here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/resize.rs</p>
			<pre>pub fn <strong class="bold">get_image_files</strong>(src_folder: PathBuf) -&gt; 
    Result&lt;Vec&lt;PathBuf&gt;, ImagixError&gt; {
    let entries = fs::read_dir(src_folder)
        .map_err(|e| ImagixError::UserInputError("Invalid 
            source folder".to_string()))?
        .map(|res| res.map(|e| e.path()))
        .collect::&lt;Result&lt;Vec&lt;_&gt;, io::Error&gt;&gt;()?
        .into_iter()
        .filter(|r| {
            r.extension() == Some("JPG".as_ref())
                || r.extension() == Some("jpg".as_ref())
                || r.extension() == Some("PNG".as_ref())
                || r.extension() == Some("png".as_ref())
        })
        .collect();
    Ok(entries)
}</pre>
			<p>The code uses the <code>read_dir()</code> method to iterate through directory entries and collects the results in a <code>Vector</code>. The <code>Vector</code> is then converted into an iterator, and the entries are filtered <a id="_idIndexMarker299"/>to return only image files. This gives us the set of image files to work with, for resizing. In the next subsection, we will review the code to perform the actual resizing of the images.</p>
			<h3>Resizing images</h3>
			<p>In this subsection, we will <a id="_idIndexMarker300"/>review the code for <code>resize_image()</code>. This method performs the resizing of images.</p>
			<p>The logic for this method is as follows:</p>
			<ol>
				<li value="1">The method accepts a source image filename with the full source folder path, resizes it as a <code>.png</code> file, and stores the resized file in a <code>/tmp</code> subfolder under the source folder.</li>
				<li>First, the source filename is extracted from the full path. The file extension is changed to <code>.png</code>. This is because our tool will only support output files in <code>.png</code> format. As an exercise, you can add support for other image format types.</li>
				<li>Then the destination file path is constructed with the <code>/tmp</code> prefix, as the resized image will need to be stored in the <code>tmp</code> subfolder under the source folder. To achieve this, we first need to check whether the <code>tmp</code> folder already exists. If not, it has to be created. The logic for constructing the path with the <code>tmp</code> subfolder and for creating the <code>tmp</code> subfolder is shown in the previous code listing.</li>
				<li>Finally, we need to resize the image. For this, the source file is opened, the resize function is called with requisite parameters, and the resized image is written to the output file.</li>
				<li>The time taken for image resizing is calculated using the <code>Instant::now()</code> and <code>Elapsed::from()</code> functions.</li>
			</ol>
			<p>The code listing is shown <a id="_idIndexMarker301"/>here. For purposes of explanation, the code listing has been split into multiple snippets.</p>
			<p>The code listed here accepts three input parameters – the size, source folder, and an entry of type <code>PathBuf</code> (which can refer to the full path of an image file). The file extension is changed to <code>.png</code> as this is the output format supported by the tool:</p>
			<pre>fn resize_image(size: u32, src_folder: &amp;mut PathBuf) -&gt; 
    Result&lt;(), ImagixError&gt; {
    // Construct destination filename with .png extension
    let new_file_name = src_folder
        .file_stem()
        .unwrap()
        .to_str()
        .ok_or(std::io::ErrorKind::InvalidInput)
        .map(|f| format!("{}.png", f));</pre>
			<p>The code snippet here appends the suffix <code>/tmp</code> to the file path entry in order to create the destination folder path. Note that due to a limitation in the standard library, the filename is first constructed as <code>tmp.png</code>, which is subsequently changed to reflect the final resized image filename:</p>
			<pre>// Construct path to destination folder i.e. create /tmp 
// under source folder if not exists
let mut dest_folder = src_folder.clone();
dest_folder.pop();
dest_folder.push("tmp/");
if !dest_folder.exists() {
    fs::create_dir(&amp;dest_folder)?;
}
dest_folder.pop();
dest_folder.push("tmp/tmp.png");
dest_folder.set_file_name(new_file_name?.as_str());</pre>
			<p>The code here opens the image file and loads the image data into memory. The <code>/tmp</code> subfolder is created <a id="_idIndexMarker302"/>under the source folder. Then, the image is resized and written to the output file in the destination folder. The time taken for the resizing operation is recorded and printed out:</p>
			<pre>let timer = Instant::now();
let img = image::open(&amp;src_folder)?;
let scaled = img.thumbnail(size, size);
let mut output = fs::File::create(&amp;dest_folder)?;
scaled.write_to(&amp;mut output, ImageFormat::Png)?;
println!(
    "Thumbnailed file: {:?} to size {}x{} in {}. Output 
     file   
     in {:?}", 
     src_folder, 
     size,
     size,
     Elapsed::from(&amp;timer), 
     dest_folder
    );
    Ok(())
}</pre>
			<p>We have now seen <a id="_idIndexMarker303"/>the code for resizing images. Next, we will look at the code for generating image stats.</p>
			<h3>Image statistics</h3>
			<p>In the previous subsection, we <a id="_idIndexMarker304"/>looked at the code for image resizing. In this subsection, we will see the logic for generating image statistics. This method will count the number of image files in a specified source folder, and measure their total file size.</p>
			<p> The logic of the <code>get_stats()</code> method that we will use is described as follows:</p>
			<ol>
				<li value="1">The <code>get_stats()</code> method takes a source folder as its input parameter and returns two values: the number of image files in the folder, and the total aggregate size of all image files in the folder.</li>
				<li>Get a list of image files in the source folder by calling the <code>get_image_files()</code> method.</li>
				<li>The <code>metadata()</code> function in the <code>std::path</code> module allows us to query a file or directory for its metadata information. In our code, as we iterate through the directory entries, we aggregate the sizes of all files in one variable, <code>sum</code>. The <code>sum</code> variable is returned from the function along with the count of image file entries.</li>
			</ol>
			<p>The code listing is provided here:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/stats.rs</p>
			<pre>pub fn get_stats(src_folder: PathBuf) -&gt; Result&lt;(usize, 
    f64), ImagixError&gt; {
    let image_files = get_image_files
        (src_folder.to_path_buf())?;
    let size = image_files
        .iter()
        .map(move |f| f.metadata().unwrap().len())
        .sum::&lt;u64&gt;();
    Ok((image_files.len(), (size / 1000000) as f64))
}</pre>
			<p>We have covered the <a id="_idIndexMarker305"/>code for the image processing functionality. We will now cover some details of our custom error handling for the project.</p>
			<h3>Error handling</h3>
			<p>Let's now take a look at <a id="_idIndexMarker306"/>our error handling design.</p>
			<p>As a part of our project, there may be many failure conditions that we have to handle. Some of them are given here:</p>
			<ul>
				<li>The source folder given by the user may be invalid.</li>
				<li>The specified file may not be present in the source folder.</li>
				<li>Our program may not have permission to read and write files.</li>
				<li>User inputs for size or mode may be incorrect.</li>
				<li>There may be errors during image resizing (for example, a corrupt file).</li>
				<li>There may be other types of internal processing errors.</li>
			</ul>
			<p>Let's define a custom error type to handle all these different types of errors in a unified manner, and provide the error as output to the users of our library:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/error.rs</p>
			<pre>pub enum <strong class="bold">ImagixError</strong> {
    FileIOError(String),
    UserInputError(String),
    ImageResizingError(String),
    FormatError(String),
}</pre>
			<p>The names of the errors are mostly self-explanatory. <code>FormatError</code> is any error encountered while converting or printing values of parameters. The goal of defining this custom error type is that <a id="_idIndexMarker307"/>the various types of errors that may be encountered during processing, such as errors in user input, the inability to read through a directory or write to a file, an error in image processing, and so on, are converted into our custom error type.</p>
			<p>It is not enough to just define a custom error type. We also have to ensure that when errors happen in due course of the program's operation, these errors are translated into the custom error type. For example, an error in reading an image file raises an error defined in the <code>std::fs</code> module. This error should be caught and transformed into our custom error type. This way, regardless of whether there is an error in file operations or error processing, the program uniformly propagates the same custom error type for handling by the frontend interface to the user (in the case of this project, it is the command line).</p>
			<p>For the conversion of various types of errors into <code>ImagixError</code>, we will implement the <code>From</code> trait. We will also implement the <code>Display</code> trait for our error type so that the errors can be printed out to the console.</p>
			<p>Within each of the methods in the project modules, at the failure points, you will notice that <code>ImagixError</code> is raised and propagated back to the calling function. The source code can be found in the source folder for this chapter in the Packt code repository.</p>
			<p>This concludes the error handling subsection of the code.</p>
			<p>This also concludes this section on coding the <code>imagix</code> library. We have only walked through key code snippets as it isn't practical to print out the entire code listing inline in the chapter. I would urge <a id="_idIndexMarker308"/>the reader to go through the entire source code to understand how the various features are translated into idiomatic Rust code.</p>
			<p>In the next section, we will build the command-line application that wraps this library and provides the user interface.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor077"/>Developing the command-line application and testing</h1>
			<p>In the previous section, we <a id="_idIndexMarker309"/>built the library for image resizing. In this section, we will review the design and key parts of the code for the main <a id="_idIndexMarker310"/>command-line application. </p>
			<p>Let's begin with some automated unit tests to test the image resizing functionality in <code>resize.rs</code>: This way we can confirm that the image resizing library works independently of any calling function.</p>
			<p>Two test cases are shown here in the following code—one to resize a single image, and the other to resize multiple images. You can replace the source folder and filenames in the code with your own:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">src/imagix/resize.rs</p>
			<pre>#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn <strong class="bold">test_single_image_resize</strong>() {
        let mut path = PathBuf::from("/tmp/images/
            image1.jpg");
        let destination_path = PathBuf::from(
            "/tmp/images/tmp/image1.png");
        match process_resize_request(SizeOption::Small, 
            Mode::Single, &amp;mut path) {
            Ok(_) =&gt; println!("Successful resize of single      
                image"),
            Err(e) =&gt; println!("Error in single image: 
                {:?}", e),
        }
        assert_eq!(true, destination_path.exists());
    }
    #[test]
    fn <strong class="bold">test_multiple_image_resize</strong>() {
        let mut path = PathBuf::from("/tmp/images/");
        let _res = process_resize_request(
            SizeOption::Small, Mode::All, &amp;mut path);
        let destination_path1 = PathBuf::from(
            "/tmp/images/tmp/image1.png");
        let destination_path2 = PathBuf::from(
            "/tmp/images/tmp/image2.png");
        assert_eq!(true, destination_path1.exists());
        assert_eq!(true, destination_path2.exists());
    }
}</pre>
			<p>Place the <code>image1.jpg</code> and <code>image2.jpg</code> files in <code>/tmp/images</code> and execute the tests with the following command:</p>
			<pre>cargo test </pre>
			<p>You can see the tests pass successfully. You can also inspect the resized images.</p>
			<p>As an exercise, you can add the test cases for the image stats function as well.</p>
			<p>We can <a id="_idIndexMarker311"/>now conclude that the <code>imagix</code> library works as intended. Let's now move on to designing the <a id="_idIndexMarker312"/>command-line application.</p>
			<p>We shall first look at the CLI requirements.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>Designing the command-line interface</h2>
			<p>In this subsection, we will <a id="_idIndexMarker313"/>look at the design of the CLI. By design, we mean finalizing the structure of the CLI that the user will use. The CLI should be intuitive to use for the end user. The CLI must also accommodate some flexibility in its performing of different types of operations.</p>
			<p>The <code>imagecli</code> CLI will use a command-subcommand model like <code>git</code>.</p>
			<p>The CLI command structure is shown in <em class="italic">Figure 4.6</em>: </p>
			<div><div><img src="img/Figure_4.6_B16405.jpg" alt="Figure 4.6 – Design of CLI commands"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Design of CLI commands</p>
			<p>Here are some examples of commands with parameters that the user can specify:</p>
			<ul>
				<li>For resizing images, the command is <code>cargo run –-release resize</code> with three parameters. </li>
				<li>For image statistics, the command is <code>cargo run –-release stats</code> with one parameter.</li>
				<li>For resizing a <a id="_idIndexMarker314"/>single image the command is <code>cargo run --release resize --size small --mode single --srcfolder &lt;path-to-image-file/file-name.extn&gt;</code>.</li>
				<li>For resizing multiple images, we use the <code>cargo run --release resize --size medium --mode all --srcfolder &lt;path-to-folder-containing-images&gt;</code> command.</li>
				<li>For image statistics, the <code>cargo run --release  stats --srcfolder &lt;path-to-folder-containing-images&gt;</code> command is used.</li>
			</ul>
			<p>The <code>imagecli</code> <code>main()</code> function parses the command-line parameters, handles user and processing errors with suitable messages to the user, and invokes the respective functions from the <code>imagix</code> library.</p>
			<p>Let's do a quick recap. To resize images, we need to know the following from the user:</p>
			<ul>
				<li>The mode (single or multiple files)</li>
				<li>The output size of the image file (small/medium/large) </li>
				<li>The source folder where the image file (or files) is located</li>
			</ul>
			<p>In this section, we designed the CLI for the tool. In the previous sections, we built the <code>imagix</code> library to <a id="_idIndexMarker315"/>resize images. We will now move on to the last part of the project, which is to develop the main command-line binary application that ties all the pieces together and accepts user inputs from the command-line.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>Coding the command-line binary using structopt</h2>
			<p>In the previous section, we designed the interface for the command-line tool. In this section, we will see <a id="_idIndexMarker316"/>the code for the <code>main()</code> function that accepts <a id="_idIndexMarker317"/>user inputs from the command line and invokes the <code>imagix</code> library. This <code>main()</code> function will be compiled and built into the command-line binary tool. The user will invoke this executable for resizing images and provide the necessary command-line parameters. </p>
			<p>The <code>main()</code> function will be located in <code>src/imagecli.rs</code>, as we want the command-line tool binary name to be <code>imagecli</code>.</p>
			<p>Let's now review the code snippets for the command-line application. The <code>main()</code> function is located in the <code>src/imagecli.rs</code> file:</p>
			<ol>
				<li value="1">We will start with the imports section. Note the imports of the <code>imagix</code> library that we have written, and <code>structOpt</code> for command-line argument parsing:<pre>mod imagix;
use ::imagix::error::ImagixError;
use ::imagix::resize::{process_resize_request, Mode,  
    SizeOption};
use ::imagix::stats::get_stats;
use std::path::PathBuf;
use std::str::FromStr;
use structopt::StructOpt;
// Define commandline arguments in a struct</pre></li>
				<li>We will now see the definition of the command-line parameters for the tool. For this we will use the <code>structopt</code> syntax. Refer to documentation at <a href="https://docs.rs/structopt">https://docs.rs/structopt</a>. Basically, we have defined an <code>enum</code> called <code>Commandline</code> and defined two subcommands, <code>Resize</code> and <code>Stats</code>. <code>Resize</code> takes <a id="_idIndexMarker318"/>three arguments: <code>size</code>, <code>mode</code> and <code>srcfolder</code> (the <a id="_idIndexMarker319"/>source folder). <code>Stats</code> takes one argument: <code>srcfolder</code>:<pre>#[derive(StructOpt, Debug)]
#[structopt(
    name = "resize",
    about = "This is a tool for image resizing and 
        stats",
    help = "Specify subcommand resize or stats. For 
        help, type imagecli resize --help or 
        imagecli stats --help"
)]
enum <strong class="bold">Commandline</strong> {
    #[structopt(help = "
          Specify size(small/medium/large),
          mode(single/all) and srcfolder")]
<strong class="bold">    Resize</strong> {
        #[structopt(long)]
        size: SizeOption,
        #[structopt(long)]
        mode: Mode,
        #[structopt(long, parse(from_os_str))]
        srcfolder: PathBuf,
    },
    #[structopt(help = "Specify srcfolder")]
<strong class="bold">    Stats</strong> {
        #[structopt(long, parse(from_os_str))]
        srcfolder: PathBuf,
    },
}</pre></li>
				<li>We can now review the code for the <code>main()</code> <a id="_idTextAnchor080"/>function. Here, we basically accept the command-line inputs (validated by <code>StructOpt</code>) and invoke the suitable <a id="_idIndexMarker320"/>methods from our <code>imagix</code> library. If the user <a id="_idIndexMarker321"/>specifies the <code>Resize</code> command, the <code>process_resize_request()</code> method of the <code>imagix</code> library is invoked. If the user specifies the <code>Stats</code> command, the <code>get_stats()</code> method of the <code>imagix</code> library is invoked. Any errors are handled with suitable messages:<pre><strong class="bold">fn main()</strong> {
    let args: Commandline = Commandline::from_args();
    match args {
        Commandline::Resize {
            size,
            mode,
            mut srcfolder,
        } =&gt; {
            match <strong class="bold">process_resize_request</strong>(size, mode, 
                &amp;mut src_folder) {
                Ok(_) =&gt; println!("Image resized    
                    successfully"),
                Err(e) =&gt; match e {
                    ImagixError::FileIOError(e) =&gt; 
                        println!("{}", e),
                    ImagixError::UserInputError(e) =&gt; 
                        println!("{}", e),
                    ImagixError::ImageResizingError(e)     
                        =&gt; println!("{}", e),
                    _ =&gt; println!("Error in 
                        processing"),
                },
            };
        }
        Commandline::Stats { srcfolder } =&gt; match 
            <strong class="bold">get_stats</strong>(srcfolder) {
            Ok((count, size)) =&gt; println!(
                "Found {:?} image files with aggregate 
                size of {:?} MB",
                count, size
            ),
            Err(e) =&gt; match e {
                ImagixError::FileIOError(e) =&gt; 
                    println!("{}", e),
                ImagixError::UserInputError(e) =&gt;    
                    println!("{}", e),
                _ =&gt; println!("Error in processing"),
            },
        },
    }
}</pre></li>
				<li>Build the app with the following command:<pre><strong class="bold"> cargo build --release </strong></pre></li>
			</ol>
			<p>The <a id="_idIndexMarker322"/>reason to use the release builds is that there is a considerable time difference in resizing images <a id="_idIndexMarker323"/>between the debug and release builds (the latter being much faster).</p>
			<p>You can then execute and test the following scenarios at the Terminal. Ensure to place one or more <code>.png</code> or <code>.jpg</code> files in the folder that you specify in <code>--srcfolder</code> flag:</p>
			<ul>
				<li><strong class="bold">Resize a single image</strong>:<pre><strong class="bold">cargo run --release resize --size medium --mode single --srcfolder &lt;path-to-image-file&gt;</strong></pre></li>
				<li><strong class="bold">Resize multiple files</strong>:<pre><strong class="bold">cargo run --release resize --size small --mode all --srcfolder &lt;path-to-image-file&gt;</strong></pre></li>
				<li><strong class="bold">Generate image stats</strong>:<pre><strong class="bold">cargo run --release  stats --srcfolder &lt;path-to-image-folder&gt;</strong></pre></li>
			</ul>
			<p>In this section, we have built a tool for image resizing that works from a CLI. As an exercise, you can experiment by adding additional features, including adding support for more image formats, changing the size of the output file, or even providing the option to encrypt the generated image file for additional security.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor081"/>Summary</h1>
			<p>In this chapter, we learned to write Rust programs that can discover and manipulate the system environment, directory structures, and filesystem metadata in a cross-platform manner, using the <code>std::env</code>, <code>std::path</code>, and <code>std::fs</code> modules. We looked at how to create programs that can use command-line arguments or environment variables to accept configuration parameters and user inputs. We saw the use of two third-party crates: the <code>StructOpt</code> crate to improve the user interface of the tool, and <code>image-rs/image</code> to do the image resizing.</p>
			<p>We also learned how to use the <code>std:time</code> module to measure the time taken for specific processing tasks. We defined a custom error type to unify error handling in the library. In this chapter, we were also introduced to file handling operations.</p>
			<p>In the next chapter, we will take a detailed look at doing advanced memory management with the standard library.</p>
		</div>
	</body></html>