- en: Advanced Programming with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining an expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing variable bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing type casting in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision-making with Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping operations in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the enum type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing pointer operations in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining your first user-defined data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding functionality to the user-defined data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar functionality for different data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is focused on equipping you with all the recipes to implement expressions
    that will represent the state of the code, build logic using decision-making statements
    such as `if...else`, declare a custom complex data type to represent a real-world
    scenario using `struct`, add functionality to a complex data type using traits,
    and control code execution using the looping statement.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An expression, in simple words, is a statement in Rust by using which we can
    create logic and workflows in the program and applications. We will deep dive
    into understanding expressions and blocks in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the ensuing steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `expression.rs` with the next code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the `main` function and create the variables `x_val`, `y_val`, and
    `z_val`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the ensuing output upon running the code. Please refer to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a06ce81-0c14-41ec-8059-11313a8eee4f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the statements that end in a semicolon (`;`) are expressions. A block is
    a statement that has a set of statements and variables inside the `{}` scope.
    The last statement of a block is the value that will be assigned to the variable.
    When we close the last statement with a semicolon, it returns `()` to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding recipe, the first statement which is a variable named `x_val`
    , is assigned to the value `5`. Second, `y_val` is a block that performs certain
    operations on the variable `x_val` and a few more variables, which are `x_squared`
    and `x_cube` that contain the squared and cubic values of the variable `x_val`
    , respectively. The variables `x_squared` and `x_cube` , will be deleted soon
    after the scope of the block.
  prefs: []
  type: TYPE_NORMAL
- en: The block where we declare the `z_val` variable has a semicolon at the last
    statement which assigns it to the value of `()`, suppressing the expression. We
    print out all the values in the end.
  prefs: []
  type: TYPE_NORMAL
- en: We print all the declared variables values in the end.
  prefs: []
  type: TYPE_NORMAL
- en: Defining constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust provides the ability to assign and maintain constant values across the
    code in Rust. These values are very useful when we want to maintain a global count,
    such as a timer threshold for example. Rust provides two `const` keywords to perform
    this activity. You will learn how to deliver constant values globally in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `constant.rs` with the next code snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the global `UPPERLIMIT` using `constant`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `is_big` function by accepting a single integer as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, call the `is_big` function and perform the decision-making
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c60a17c8-d8fc-4ab2-8545-fa765521cbf9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workflow of the recipe is fairly simple, where we have a function to check
    whether an integer is greater than a fixed threshold or not. The `UPPERLIMIT`
    variable defines the fixed threshold for the function, which is a constant whose
    value will not change in the code and is accessible throughout the program.
  prefs: []
  type: TYPE_NORMAL
- en: We assigned `15` to `random_number` and passed it via `is_big (integer value);`
    and we then get a boolean output, either `true` or `false`, as the return type
    of the function is a `bool` type. The answer to our situation is `false` as `15`
    is not bigger than `12`, which the `UPPERLIMIT` value set as the constant. We
    performed this condition checking using the `if...else` statement in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot change the `UPPERLIMIT` value; when attempted, it will throw an error,
    which is commented in the code section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants declare constant values. They represent a value, not a memory address:
    `type = value;`'
  prefs: []
  type: TYPE_NORMAL
- en: Performing variable bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variable binding refers to how a variable in the Rust code is bound to a type.
    We will cover pattern, mutability, scope, and shadow concepts in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `binding.rs` and enter a code snippet that includes declaring
    the `main` function and different variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ec9f244-b7ee-427e-910f-347cb826dc2b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `let` statement is the simplest way to create a binding, where we bind
    a variable to a value, which is the case with variable `a`. To create a pattern
    with the `let` statement, we assign the pattern values to `b` and `c` values in
    the same pattern. Rust is a statically typed language. This means that we have
    to specify our types during an assignment, and at compile time, it is checked
    to see if it is compatible. Rust also has the type reference feature that identifies
    the variable type automatically at compile time. The `variable_name : type` is
    the format we use to explicitly mention the type in Rust. We read the assignment
    in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: x_val is a binding with the type i32 and the value 5.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we declared `x_val` as a 32-bit signed integer. However, Rust has many
    different primitive integer types that begin with `i` for signed integers and
    `u` for unsigned integers, and the possible integer sizes are 8, 16, 32, and 64
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: Variable bindings have a scope that makes the variable alive only in the scope.
    Once it goes out of the scope, the resources are freed.
  prefs: []
  type: TYPE_NORMAL
- en: A block is a collection of statements enclosed by `{}`. Function definitions
    are also blocks! We use a block to illustrate the feature in Rust that allows
    variable bindings to be shadowed. This means that a later variable binding can
    be done with the same name, which in our case is `y_val`. This goes through a
    series of value changes, as a new binding that is currently in scope overrides
    the previous binding. Shadowing enables us to rebind a name to a value of a different
    type. This is the reason why we are able to assign new values to the immutable
    `y_val` variable in and out of the block.
  prefs: []
  type: TYPE_NORMAL
- en: Performing type casting in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about casting between different data types in
    Rust. Rust does not provide an automatic type cast. The developer has to manually
    own it. Using as we will perform safe type casting in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `typecasting.rs` and enter the following code to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we created four variables: `true_positive`,
    `true_negative`, `false_positive`, and `false_negative`. These are basically the
    four measurement parameters of a confusion matrix.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `accuracy` and `percentage` function that returns the final accuracy
    percentage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `total` variable is the sum of all the measurements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `accuracy` function accepts those which are all `int` data types that return
    a `float` data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value received from the `accuracy` function is passed to the `percentage`
    function and the `accuracy` is printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84373cae-5155-4aff-a7bc-984bd5d2cbd2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have two functions, `accuracy` and `percentage`, which take
    in arguments from the `main` function and convert the type passed to the desired
    type, due to the nature of the arithmetic operations for which we use the `as`
    keywords in Rust which helps in type casting in Rust. In the case of the `accuracy`
    function, it takes three input arguments of type `i32` and returns a single `f32`
    type value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to protect developers from accidental casts, Rust makes it mandatory
    for developers to convert data types manually. In the following example, we define
    an `int` variable named `a` and assign it the value `3`; after the assignment
    operation, we would see that a part of the code is commented. This implies that
    it won''t be compiled by the Rust compiler. If we take a careful look at the code,
    we find that we are multiplying an `int` variable with a flat value, which will
    give us a type mismatch error during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we used the `as` keyword converting `int` to `float` (64-bit)
    in order to multiply an `int` value by a `float` variable. This step produced
    `b` without any error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we perform arithmetic operations in the same kind of data type,
    we don't have to worry about type conversion as the result of the operation produced
    is automatically typecasted.
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making with Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about decision-making statements in Rust. Condition
    checking in Rust is similar to other dynamic programming languages and is very
    easy to use. Using `if...else` statements, we will perform condition checking
    in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `condition.rs` and enter the following code to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create a variable named `age` and assign it to an integer with the value `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding code has an `if...else` statement to make a decision about the
    `age` value. It performs print operations based on the conditions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d86289f0-d256-4aaf-a32c-fc91cc7e3e28.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented an `if...else` statement to perform conditional
    statements in Rust. The conditions are performed in the `age` variable. In this
    recipe, we assigned an immutable variable taking the value `10`; after this, we
    compared it with various rules and performed an action based on the qualifying
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: These rules are the conditions that the developer generates in the form of a
    mathematical operation that yields a result of `true` or `false`. Based on the
    output of the operation, we select a particular set of actions inside the scope
    of the decision statement.
  prefs: []
  type: TYPE_NORMAL
- en: The `if...else` statements are a great tool for developers to route the program
    logic. They are ideal for comparing thresholds at the end state of the application
    for making a logical decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding case, we checked three cases in the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement checks whether the `age` variable is less than `18`. If the
    operation returns `true`, then we go ahead and print `Go to School`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next condition is checked in the `else...if` statement when the first condition
    returns `false`; here we check whether the age is between `18` and `28`, and if
    this condition returns `true`, we print `Go to college`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have the `else` statement, which has no condition and is executed
    only when all the preceding conditions fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's often a very important skill to write in a very optimized manner. We should
    learn the ability to develop the skill of writing less and optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding set of statements contains a lot of lines of code, but we can
    write it in an optimized way, where we would have the `if...else` statement along
    with the condition in a single line. The general syntax for this case is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have a variable to which we assign the `if` the `condition 1` operation produces
    `true`; alternatively, we assign the value from the `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Looping operations in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about looping statements in Rust. Looping statements
    that we are referring to in Rust provide interactive functionality. Using the
    `loop`, `while`, and `for` keywords, we can perform iterative operations in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `looping.rs` and enter the following code in the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` function, perform a looping operation on the mutable variable
    `x`, which is initially assigned to the integer value of `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a `loop` statement, which is an infinite iterative statement, and check
    the various conditions inside its scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mutable variable `y` and assign it to the integer value `1` , and
    define a `while` loop with the `y < 10` condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a similar operation as for the `while` loop. Here, use the `for` loop
    to iterate over the 1 to 9 range on the mutable variable `z`, which is initially
    assigned to the value `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a27d1e7-4a2a-4ab8-b357-e5de211f1e5c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `loop` is an iterative keyword in Rust where the statements inside its scope
    run forever, that is, indefinitely, unless they are explicitly stopped by the
    `break` statement. This is very useful when we want a process a particular task
    in an application until it reaches a particular state for further processing.
    Consider a video storage application where I want to continuously save the camera
    feeds until the users give a command to stop the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we declared a mutable `int` variable `x`, which we initialized
    with the value `1`. When it enters the `loop` statement, we had two conditions
    for it. The first condition prints the value of `x`. Only when it is an even number,
    we use the `%` operator to perform this divisibility operation, followed by an
    increase in the value.
  prefs: []
  type: TYPE_NORMAL
- en: Then we used the `continue` keyword, which goes back to the `loop`. The preceding
    statements of the keyword will not be executed. The second condition checks whether
    the value of `x` is greater than `10`. This condition will only be reached at
    runtime. When the value of `x` is odd in this case, we break the `loop`, which
    is the exit point of the infinite loop, which is similar to the case of the stop
    button in the video application discussed in the preceding example. Next, we increase
    the value of the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: While printing `1` to `9` in two different ways, the first method uses `while`,
    where we have a condition placed which is at first compared to the loop that does
    not have a condition. All the while, the loop checks the condition at every iteration.
    Only if it is `true`, it proceeds. In the preceding case, we had an immutable
    variable `y`, which was initialized with the value `1`. We had a condition which
    checks whether `y` is less than `10` at every iteration. In each iteration, we
    print the value of `y` and increase its value by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The second way to do the preceding activity is by using the `for` looping statement,
    where we specify a range of values in which we want to operate. We don't have
    any explicit condition checking, as in the case of other looping statements. We
    declared an immutable variable `z`, which was initialized to the value `1` and
    then iterated from `1` to `10` in the loop where we print the value in every step.
  prefs: []
  type: TYPE_NORMAL
- en: Looping statements are really handy to the developer when there is a requirement
    to perform a particular task repeatedly in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the enum type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about using the `enum` type in Rust. In Rust,
    the `enum` type lets the developer represent data in multiple formats, and each
    format can optionally have specific data associated with it. Using `enum` keywords,
    we perform iterative operations in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `enum.rs` and enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an `enum` date type, namely `Hero`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `get_info` that will take the `enum` data type as an
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1c20210-9c79-42b3-b994-1c5b4250d9e0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `enum` is a very important Rust type as it allows a particular data type
    to be associated with multiple data variants. A value of an `enum` type contains
    information about which data variant it is associated with.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to note about `enum` in Rust before moving to the code
    explanation is you can use the `::` syntax in order to use the name of each data
    variant and assign values to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, we created an `enum` type `Hero`, which has three types of data
    variants: `Fast`, which is not specified with explicit data requirements; `Strong(i32)`,
    which requires a 32-bit integer input; and `Info`, which supports two string data
    variables, `name` and `secret`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's check out the initialization of these data variants in the `main`
    function. Here, we have created three variables that represent the three data
    variants and initialized them with the required data requirement. We also called
    the `get_info()` function three times by passing different `enum` data variants
    to print the data values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The is initialized with the `Hero::Strong(100)` `enum` type, `fasty` with `Hero::Fast`,
    and `spiderman` with `Hero::Info`, which requires two variables: `name:"spiderman".to_owned()`
    and `secret:"peter parker".to_owned()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that while declaring the values to `Hero` data variant `Info` , we assigned
    data variables with strings along with `.to_owned()` method, this is done in order
    to ensure the string is owned when borrowed, as `&str` is an immutable reference
    to a string and using `to_owned()` turns it into a string that we own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_info(argument : enum type)` function takes the `enum` as the data
    type, and when we pass each of the different data variants, the arguments are
    assigned with those values. Then we used the `match` statement, which is a decision-making
    statement, to compare the argument with the different types of data variants mentioned
    as the different cases in the `match` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: We passed the fast variable, which is of the type `Fast`--variant of `Hero`--and
    it will print `Fast`, which is the first case of the `match` statement. Similarly,
    for the `spiderman` case and `hulk`, which are of the types `Info` and `Strong`,
    respectively, the corresponding statement in the match of the `get_info` function
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At an uber level, closures are similar to functions, and calling a closure is
    exactly like a function. Closures are similar to **lambdas**, which are basically
    functions that operate over the variables in a closed scope.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `closures.rs` and enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a closure and name it `sum_num`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another closure, namely `add_ten`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0fb5d91-5cf4-456f-9a4a-f4c4b37f9058.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important thing about a closure is that it's bound or its operations are
    within a scope where it is defined. It is similar to a function that uses the
    free variable in the environment of its operation.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are great ways to write mathematical operations. If the developer is
    working on Rust to speed up the mathematical computation of the application, then
    the developer can maintain closures in his or her code for different equations
    for better optimization, code debugging, and benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created two closures in the `main` function. The basic way
    to create a simple closure is to have a variable assigned to an operation, before
    in which we could declare the variable types in the pipe symbol in a `let` statement.
    The first closure is named `sum_num`, which basically adds two numbers and returns
    an integer output as the two variables it uses, namely `x` and `y`, which are
    32-bit integers. The second closure `add_ten` adds a fixed integer value of `10`
    to the integer that is passed to the closure. Calling a closure is similar to
    that of a function. The convention is to call the name of the closure followed
    by the parameters to be passed to the closure operation. In this recipe, we called
    `sum_num(7,8)`, which gave the output of `15` at runtime and `add_ten(3)`, which
    produced `13`.
  prefs: []
  type: TYPE_NORMAL
- en: Performing pointer operations in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust provides different smart pointers. These are different types of pointers
    used in Rust for different use cases, but `&mut T` is a mutable (exclusive) reference
    that is one of the operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `pointer.rs` and enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a vector named `vect1` and assign it to `vec![1,2,3]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass `&vect1` to the `sum_vects()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform summation operations for each value of the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9acfd557-9eb0-44fd-929f-794bcd5f3112.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ownership and borrowing are the main concepts on which Rust is built, and the
    standard APIs given by Rust are based on this concept. In the preceding snippet,
    we created a vector, namely `vect1`, and assigned it `1,2,3` using the `vec!`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a vector is a non-primitive value. Vectors cannot be reused after,
    as shown in the commented section of the code. The compiler will throw an error
    saying that `vect1` is a moved value and cannot be used. This is the case when
    we assign `vect1` to `vect2` and try to assign `vect1` to the print statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the `sum_vects(&vect1)` function, we passed the ownership of `vect1` to the
    `sum_vector` function, which iterates through each of the objects of the vector
    and produces the sum. Note that we passed `vect1` with a `&` symbol. This way,
    we shared the vector as a reference or pointer, but if we had passed it as `&mut
    vect1`, then the function would have had the ability to mutate or make changes
    in the values of the vector. We verify this by printing `vect1` after processing
    it from the `sum_vects` function, which still yields the same result.
  prefs: []
  type: TYPE_NORMAL
- en: In `sum_vects(&vect1)`, we had `v1`, which is the argument to which `vect1`
    is moved to. The vector has a method from the standard APIs that allows the `iter`
    function to read one data object from the zero position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fold()` function takes two arguments: an initial value and a closure.
    The closure again takes two arguments: an accumulator and an element. The closure
    returns the value that the accumulator should have for the next iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: Here the accumulator is `sum` and the element is `x`, which is added to `sum`
    in every iteration. Note that `x` being mutable in the definition of the closure
    can change the values in the scope of its operation. This is stored in the `sum`
    variable and returned to the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your first user-defined data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn about structs, which is a way in which you can
    create complex data types in Rust. Using `struct`, we will define user-defined
    data types in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `struct.rs` and enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `struct` named `Circle` with two parameters, namely `x` and `radius`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function `get_radius` by accepting `Circle` as a user-defined data
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47f4eac1-b057-433f-b3c0-5a7b344aeded.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point of the product development life cycle, developers often have too
    many variables to handle and the code becomes really complex. This is where structs
    appear as a big savior. Structs enable developers to create complex data types,
    where they allow the unification of multiple data types under a single name.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created a custom data type named `Circle`, which has two
    labels `radius` and `x` of the type `f64`, which is a 64-bit `float` type. Both
    the parameters here are related to the `Circle` data type and uniquely express
    their features.
  prefs: []
  type: TYPE_NORMAL
- en: Consider use cases such as database management, machine learning models, and
    so on, where the developer has to handle multiple variables conveying the property
    of a single task/entity. Structs, in these cases, are great tools to utilize for
    making the code more optimized and modular. This makes the life of a developer
    easy; we can debug errors easily and scale up features on requests of the application/product.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `struct` keyword to create a user-defined data type, where the custom
    name is provided after the keyword but along with the types of the different labels
    or variables it uses.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we initialized a mutable variable `circle1` of the user-defined
    data type `Circle` and populated it with its required values, which are `10.0`
    for `radius` and `10.0` for `x`. We did this to access the variable in the scope
    of the program. We get the value by calling the variable name label we require,
    that is, we get the value of the assigned values by calling `circle1.x` and `circle.radius`.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the reference of `circle1` to `get_radius`, where we have an argument
    `c1` of the data type `Circle` from which we get the radius of `c1.radius`. Then,
    we call the function with `get_radius(&circle1)` to get the value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to the user-defined data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will learn about performing method calls using the `impl` keyword in Rust,
    which helps in adding functionality to a user-defined data type. In this recipe,
    the `impl` block helps us create the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `implement.rs` and enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `struct` named `Circle` with two parameters, `x` and `radius`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `get_x` method for the user-defined `Circle` data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following screenshot as output upon running the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa90b058-9448-4244-b5a4-bf1aaf568991.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we created a custom data type named `Circle`, which has two
    labels: `radius` and `x` of the type `f64`, which is a 64-bit `float` type. Both
    the parameters here are related to the `Circle` data type and uniquely express
    its features.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we initialized a mutable variable `circle1` of the user-defined
    data type `Circle` and populated it with its required values, which are `10.0`
    for `radius` and `10.0` for `x`. To access the variable in the scope of the program,
    we get the value by calling the variable name label we require, that is, we get
    the value of the assigned values by calling `circle1.x` and `circle.radius`.
  prefs: []
  type: TYPE_NORMAL
- en: But, we went ahead and created unique functionalities for each data type so
    that they can perform a unique operation on the labels associated with them; this
    eliminates the need to pass argument values to externally created functions. We
    used `impl` to achieve this method call, where we defined functionalities for
    the data type.
  prefs: []
  type: TYPE_NORMAL
- en: This feature allows the developer to call functions of the data type using `datatype_name.function1().function2()`,
    which reduces the function call complexity and delivers optimized code.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call `circle1.get_x()` to get the value of the `x`
    value. If you closely observe the `impl` code part of `Circle`, you'll notice
    we passed `&self` to the `get_x()` method, which is a reference to the circle
    label's data type.
  prefs: []
  type: TYPE_NORMAL
- en: Similar functionality for different data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will learn about the `trait` feature of Rust in this recipe is similar to
    `impl`, which helps the developer make a method call of the user-defined data
    type. However, `trait` provides many more features, such as inheritance and control,
    over the functionality that the user-defined data type provides.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will require the Rust compiler and any text editor for coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `trait.rs` and enter the following code in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `struct` named `Rectangle` with the parameters `h` and `b`, both 64-bit
    `float` data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `struct` named `Circle` with the parameter `r`, which is a 64-bit
    `float` data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `trait` named `HasArea` with the `area` functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `area` function for the `Circle` user-defined data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `area` function for the `Rectangle` user-defined data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output upon running the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/721561fa-e66f-461c-8d4a-8583ec482b3e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we applied all the concepts that we learned in the previous
    ones. We created two `struct` types: `Circle` with a `radius` of f64 and `Rectangle`
    with the parameters `h` and `b` of f64\. Then, we created the `area` functionality
    for each `struct` data type that operates on the data of the labels, as they are
    referenced by `self`.'
  prefs: []
  type: TYPE_NORMAL
- en: The function definition of both user-defined data types is different in terms
    of the mathematical operation. We defined the data type `Circle` and `Rectangle`
    in the `main` function. We called the functions in real time by `Circle.area()`
    and `Rectangle.area()`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we observe that both data types provide a similar kind of functionality;
    this is where the `trait` comes into place. It basically tells the compiler the
    functionality that a particular function would use, so we implement the `trait`.
    For the data type in this recipe, we have a `trait` named `HasArea`, which contains
    only the signature of the function that is inside the scope, which contains the
    output that is returned and the reference which was passed as the argument. In
    this recipe, we had a signature of `fn area(&self) -> f64;`, which indicated the
    output of the computation in a 64-bit `float` type. The function operates by taking
    a reference to the label and values of the data type.
  prefs: []
  type: TYPE_NORMAL
