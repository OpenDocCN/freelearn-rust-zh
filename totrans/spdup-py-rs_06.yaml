- en: '*Chapter 7*: Using Python Modules with Rust'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第七章*: 在Rust中使用Python模块'
- en: We have now become comfortable with writing Python packages in Rust that can
    be installed using `pip`. However, a large advantage of Python is that it has
    a lot of mature Python libraries that help us write productive code with minimal
    errors. This seems a legitimate observation that could halt us from adopting Rust
    in our Python system. However, in this chapter, we counter this observation by
    importing Python modules into our Rust code and running Python code in our Rust
    code. To achieve an understanding of this, we are going to use the **NumPy** Python
    package to implement a basic mathematical model. Once this is done, we are going
    to use the NumPy package in our Rust code to simplify the implementation of our
    mathematical model. Finally, we will evaluate the speed of both implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经熟悉了在Rust中编写可以使用`pip`安装的Python包。然而，Python的一个大优势是它拥有许多成熟的Python库，这有助于我们以最小的错误编写高效的代码。这似乎是一个合理的观察，可能会阻止我们在Python系统中采用Rust。然而，在本章中，我们通过将Python模块导入我们的Rust代码并在Rust代码中运行Python代码来反驳这一观察。为了理解这一点，我们将使用**NumPy**
    Python包来实现一个基本的数学模型。一旦完成，我们将在Rust代码中使用NumPy包来简化我们的数学模型的实现。最后，我们将评估两种实现的性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring NumPy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索NumPy
- en: Building a model in NumPy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NumPy中构建模型
- en: Using NumPy and other Python modules in Rust
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中使用NumPy和其他Python模块
- en: Recreating our NumPy model in Rust
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Rust中重新创建我们的NumPy模型
- en: After completing this chapter, we will be able to import Python packages into
    our Rust code and use it. This is powerful, as relying on a certain Python package
    would not hold us back from implementing Rust in our Python systems for a certain
    task. The solutions that we implement in this chapter using pure Python, Rust,
    and NumPy will also give us an understanding of the trade-offs of each implementation
    when it comes to code complexity and speed so that we do not try to implement
    a *one-size-fits-all* solution for every problem, avoiding sub-optimal solutions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将能够将Python包导入我们的Rust代码并使用它。这是强大的，因为依赖某个Python包不会阻碍我们在Python系统中实现Rust来完成特定任务。我们本章使用纯Python、Rust和NumPy实现的解决方案也将让我们了解每种实现在代码复杂度和速度方面的权衡，这样我们就不试图为每个问题实现一个*一刀切*的解决方案，避免次优解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found via the following GitHub link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以通过以下GitHub链接找到：
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven)'
- en: Exploring NumPy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索NumPy
- en: Before we start using NumPy in our own modules, we must explore what NumPy is
    and how to use it. NumPy is a third-party computational Python package that enables
    us to perform calculations on lists. NumPy is mainly written in the C language,
    meaning that it will be faster than pure Python. In this section, we will have
    to assess whether our NumPy implementation beats a Rust implementation that is
    imported into Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在自定义模块中使用NumPy之前，我们必须探索NumPy是什么以及如何使用它。NumPy是一个第三方计算Python包，它使我们能够在列表上执行计算。NumPy主要用C语言编写，这意味着它将比纯Python更快。在本节中，我们将评估我们的NumPy实现是否优于导入Python的Rust实现。
- en: Adding vectors in NumPy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy中的向量相加
- en: 'NumPy enables us to build vectors that we can loop through and apply functions
    to. We can also perform operations between vectors. We can demonstrate the power
    of NumPy by adding items of each vector together, as seen here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy使我们能够构建可以遍历并对其应用函数的向量。我们还可以在向量之间执行操作。我们可以通过将每个向量的项目相加来展示NumPy的强大功能，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To achieve this, we initially need to import modules by running the following
    code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们最初需要通过运行以下代码来导入模块：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this, we can build a `numpy_function` NumPy function that creates two
    NumPy vectors of a certain size and adds them together by running the code presented
    here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以构建一个`numpy_function` NumPy函数，该函数创建一定大小的两个NumPy向量并通过运行以下代码将它们相加：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we can see that we can add the vectors by merely using the addition operator.
    Now that we have our function defined, we can plot how this scales by looping
    through a list of integers and applying `numpy_function` to the items, collecting
    the results in a list, by running the code shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以通过仅使用加法运算符来添加向量。现在我们已经定义了函数，我们可以通过遍历一个整数列表并应用`numpy_function`到这些项上，通过运行下面的代码来收集结果，并绘制出这个扩展性：
- en: '[PRE13]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This gives us a line plot, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一条线形图，如下所示：
- en: '![Figure 7.1 – Time taken to add two NumPy vectors based on size'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 根据大小添加两个NumPy向量的时间'
- en: '](img/Figure_7.01_B17720.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17720.jpg)'
- en: Figure 7.1 – Time taken to add two NumPy vectors based on size
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 根据大小添加两个NumPy向量的时间
- en: We can see in the preceding screenshot that the increase is linear. This is
    expected because there is only one loop when adding each integer in the vector
    to the other vector. We can also see that there are points where the time taken
    shoots up—this is the garbage collection kicking in. To appreciate the effect
    NumPy has, we can redefineour example by adding both vectors with a list in pure
    Python in the next subsection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到增长是线性的。这是预期的，因为添加向量中的每个整数到另一个向量时只有一个循环。我们还可以看到时间突然增加的点——这是垃圾回收开始工作的时候。为了欣赏NumPy的影响，我们可以在下一小节中通过在纯Python中使用列表添加两个向量来重新定义我们的示例。
- en: Adding vectors in pure Python
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在纯Python中添加向量
- en: 'We can add two vectors in pure Python and time this by running the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在纯Python中添加两个向量并计时，通过运行以下代码：
- en: '[PRE17]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With our new Python function, we can run both NumPy and Python functions and
    chart them by running the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的Python函数，我们可以运行NumPy和Python函数，并通过运行以下代码来绘制它们：
- en: '[PRE24]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This gives us the following results:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '![Figure 7.2 – Time taken to add two vectors based on size'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 根据大小添加两个向量的时间'
- en: '](img/Figure_7.02_B17720.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17720.jpg)'
- en: Figure 7.2 – Time taken to add two vectors based on size
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 根据大小添加两个向量的时间
- en: As we can see in *Figure 7.2*, the NumPy vectors are represented in the bottom
    line and pure Python is represented in the increasing line, so we can conclude
    that Python does not scale that well when compared to our NumPy implementation.
    The output makes it clear that NumPy is a good choice when performing calculations
    on big vectors. However, how does this compare to our Rust implementation? We
    explore this in the next subsection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图7.2*中看到的，NumPy向量在底部行表示，纯Python在递增行表示，因此我们可以得出结论，与我们的NumPy实现相比，Python的扩展性并不好。输出清楚地表明，在执行大向量计算时，NumPy是一个不错的选择。然而，这与我们的Rust实现相比如何呢？我们将在下一小节中探讨这个问题。
- en: Adding vectors using NumPy in Rust
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Rust中使用NumPy添加向量
- en: 'To compare how NumPy compares to our Rust implementation, we must incorporate
    an adding vector function to our Rust package that we have been building throughout
    this book so far. Here are the steps we need to take:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较NumPy与我们的Rust实现，我们必须在我们的Rust包中添加一个添加向量的函数，这是我们到目前为止在整本书中一直在构建的。以下是我们需要采取的步骤：
- en: 'Considering that this is a test function that we are using for demonstrative
    purposes, we can merely insert it into our `lib.rs` file. All we do is build a
    `time_add_vectors` function that accepts a number, create two vectors of a size
    equal to the number passed as input, loop through them at the same time, and add
    the items together, as shown here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这是一个用于演示目的的测试函数，我们只需将其插入到我们的`lib.rs`文件中。我们只是构建一个`time_add_vectors`函数，该函数接受一个数字，创建两个大小等于输入数字的向量，同时遍历它们，并将这些项相加，如下所示：
- en: '[PRE33]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once we have done this, we must remember to add this function to our module,
    as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成这个步骤，我们必须记住将这个函数添加到我们的模块中，如下所示：
- en: '[PRE34]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We must remember to update our GitHub repository and reinstall our Rust package
    in our Python environment.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须记住更新我们的GitHub仓库并在Python环境中重新安装我们的Rust包。
- en: 'Once this is done, we must implement the function in our Python testing script
    and time it. First, we must import it with the code shown here:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，我们必须在我们的Python测试脚本中实现这个函数并计时。首先，我们必须使用以下代码导入它：
- en: '[PRE35]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once this is done, we can define our `rust_function` Python function that calls
    the `time_add_vectors` function and times how long it takes to complete the addition
    by running the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成这个步骤，我们可以定义我们的`rust_function` Python函数，该函数调用`time_add_vectors`函数并计时完成加法所需的时间，通过运行以下代码：
- en: '[PRE36]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You may have noticed that we trim `result` returned by `rust_function`. This
    is not cheating—we do this because when the garbage collector kicks in, it can
    cause spikes and ruin the scaling of the graph. We will also do this with our
    NumPy function by running the following code:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们修剪了 `rust_function` 返回的 `result`。这并不是作弊——我们这样做是因为当垃圾回收器启动时，它可能会导致峰值并破坏图形的扩展。我们也将通过以下代码对
    NumPy 函数做同样的事情：
- en: '[PRE37]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can see that we are applying the same metrics to both the functions so that
    one will not be artificially lowered compared to the other.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到，我们对这两个函数应用了相同的度量标准，这样就不会人为地降低其中一个与另一个相比的值。
- en: 'Now that we have done this, we need to define the pure function by running
    the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这些，我们需要通过运行以下代码来定义纯函数：
- en: '[PRE38]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It must be noted that we have a higher cut-off for the pure Python because we
    expect the base reading to be much higher.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须指出，我们对纯 Python 的截止值更高，因为我们预计基本读数会高得多。
- en: 'Now that we have all of our metric functions for Rust, NumPy, and pure Python,
    we can create Python lists with the results of both functions and plot them by
    running the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了 Rust、NumPy 和纯 Python 的所有度量函数，我们可以创建包含这两个函数结果的 Python 列表，并通过运行以下代码进行绘图：
- en: '[PRE39]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running our code will give us the result shown here:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行我们的代码将给出以下结果：
- en: '![Figure 7.3 – Time taken to add two vectors based on the size of the vectors;'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – Time taken to add two vectors based on the size of the vectors;'
- en: 'left: NumPy; middle: Rust; right: pure Python'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 左：NumPy；中：Rust；右：纯 Python
- en: '](img/Figure_7.03_B17720.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.3 – Time taken to add two vectors based on the size of the vectors;'
- en: 'Figure 7.3 – Time taken to add two vectors based on the size of the vectors;
    left: NumPy; middle: Rust; right: pure Python'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 基于向量大小添加两个向量所需的时间；左：NumPy；中：Rust；右：纯 Python
- en: In the preceding screenshot, we can see that NumPy is the fastest and is not
    scaling aggressively as the size of the vector increases. Our Rust implementation
    is a lot faster than our pure Python implementation by an order of magnitude,
    but it is not as efficient as NumPy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到 NumPy 是最快的，并且随着向量大小的增加并没有过于激进地进行扩展。我们的 Rust 实现比我们的纯 Python
    实现快一个数量级，但它并不像 NumPy 那么高效。
- en: We can see that Python optimizations such as NumPy do increase the speed compared
    to pure Python and Rust. However, NumPy's clean syntax of simply adding vectors
    is not the only functional advantage of this module. In the next section, we will
    explore another functionality that NumPy has that would require a lot of extra
    code if we were going to try to code it from scratch in Python or Rust.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Python 优化，如 NumPy，与纯 Python 和 Rust 相比确实提高了速度。然而，NumPy 简单添加向量的清晰语法并不是这个模块的唯一功能优势。在下一节中，我们将探讨
    NumPy 具有的另一个功能，如果我们尝试在 Python 或 Rust 中从头开始编写代码，这将需要很多额外的代码。
- en: Building a model in NumPy
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 NumPy 中构建模型
- en: 'In this section, we are going to build a basic mathematical model to demonstrate
    the power that NumPy has apart from speed. We are going to use matrices to make
    a simple model. To achieve this, we will have to carry out the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个基本的数学模型来展示 NumPy 除了速度之外的强大功能。我们将使用矩阵来构建一个简单的模型。为了实现这一点，我们必须执行以下步骤：
- en: Define our model.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的模型。
- en: Build a Python object that executes our model.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个执行我们模型的 Python 对象。
- en: Let's look at these steps in detail in the following subsections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下小节中详细查看这些步骤。
- en: Defining our model
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '![img/B17720_07_001.png]'
- en: 'A mathematical model is essentially a set of weights that calculate an outcome
    based on inputs. Before we go any further, we must remember the scope of this
    book. We are building a model to demonstrate how to utilize NumPy. If we covered
    the nuances of mathematical modeling, that would take up the whole book. We will
    be building a model based on the example discussed in the previous section, but
    this does not mean that the model defined is an accurate description of the complexity
    of mathematical modeling. Here are the steps we need to take:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数学模型本质上是一组权重，它根据输入计算结果。在继续之前，我们必须记住这本书的范围。我们正在构建一个模型来展示如何利用 NumPy。如果我们涵盖了数学建模的细微差别，那将占用整本书。我们将基于前一小节讨论的示例构建一个模型，但这并不意味着定义的模型是数学建模复杂性的准确描述。以下是我们需要采取的步骤：
- en: 'We start by looking at a very simple mathematical model that would be a simple
    speed equation, as shown here:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先查看一个非常简单的数学模型，它将是一个简单的速度方程，如下所示：
- en: '![](img/B17720_07_001.png)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B17720_07_001.png]'
- en: 'With our model, we can calculate the time taken to complete a journey with
    the rearrangement shown here:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的模型，我们可以通过以下方式计算完成旅程所需的时间：
- en: '![](img/B17720_07_002.png)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_002.png)'
- en: The final equation on the right is merely substituting the values for letters
    so that they can be plugged into a bigger model without it taking up an entire
    page.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右侧最后的方程只是替换字母的值，以便它们可以插入到一个更大的模型中，而不会占用整整一页。
- en: 'Now, let''s take our model a little further. We collect some data from a trucking
    company, and we manage to quantify different grades of traffic into numbers and
    fit our data so that we can produce a weight to describe the effect traffic has
    on time. With this, our model has evolved to the one defined here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的模型进一步扩展。我们从一家卡车公司收集了一些数据，并设法将不同的交通等级量化为数字，并拟合我们的数据，以便我们可以产生一个权重来描述交通对时间的影响。有了这个，我们的模型已经发展到如下定义的形式：
- en: '![](img/B17720_07_003.png)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_003.png)'
- en: 'Here, ![](img/B17720_07_004.png) is the weight of traffic, and *y* is the grade
    of traffic. As we can see, if the grade of traffic increases, so does the time.
    Now, let''s say that the model is different for cars and trucks. This gives us
    the following set of equations:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，![](img/B17720_07_004.png) 表示交通的权重，而 *y* 表示交通等级。正如我们所见，如果交通等级增加，时间也会相应增加。现在，让我们假设模型对汽车和卡车是不同的。这给我们以下一组方程：
- en: '![](img/B17720_07_005.png)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_005.png)'
- en: '![](img/B17720_07_006.png)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_006.png)'
- en: We can deduce from the equations that the distance (*x*) and traffic grade (*y*)
    are the same for both cars and trucks. This makes sense. While the weights could
    be different as cars could be affected by distance and traffic differently, as
    denoted in their weights, the input parameters are the same.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以从方程中推断出，距离 (*x*) 和交通等级 (*y*) 对汽车和卡车都是相同的。这是有道理的。虽然权重可能不同，因为汽车可能受到距离和交通的影响不同，正如它们在权重中所表示的，但输入参数是相同的。
- en: 'Considering this, the equation could be defined as the following matrix equation:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，方程可以定义为以下矩阵方程：
- en: '![](img/B17720_07_007.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_007.png)'
- en: This might seem excessive right now, but there are advantages to this. Matrices
    have a range of functions that enable us to perform algebra on them. We will cover
    a few here so that we can understand how NumPy becomes invaluable to us when calculating
    this model.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能现在看起来有些过分，但这种方法有其优势。矩阵有一系列函数，使我们能够对它们进行代数运算。我们将在这里介绍几个，以便我们能够理解NumPy在计算此模型时对我们是多么有价值。
- en: 'To do this, we must acknowledge that matrix multiplication must occur in a
    certain order for it to work. Our model is essentially calculated by the notation
    shown here:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须承认矩阵乘法必须按照一定的顺序进行，才能使其工作。我们的模型本质上是通过以下符号计算的：
- en: '![](img/B17720_07_008.png)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_008.png)'
- en: 'Our *x* *y* matrix must be on the right of our weights matrix. We can add more
    inputs to our *x* *y* matrix with the following notation:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 *x* *y* 矩阵必须位于权重矩阵的右侧。我们可以通过以下符号向 *x* *y* 矩阵添加更多输入：
- en: '![](img/B17720_07_009.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_009.png)'
- en: 'We can, in fact, keep stacking our inputs, and we will get proportional outputs.
    This is powerful; we can put in an input matrix of any size if we keep the dimensions
    of the matrix consistent. We can also invert our matrix. If we invert our matrix,
    we can then input times to work out the distance and grade of the traffic. Inverting
    a matrix takes the following form:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，我们可以继续堆叠我们的输入，并将得到成比例的输出。这是强大的；如果我们保持矩阵的维度一致，我们可以输入任何大小的输入矩阵。我们还可以求逆矩阵。如果我们求逆矩阵，我们就可以输入时间来计算距离和交通等级。求逆矩阵的形式如下：
- en: '![](img/B17720_07_010.png)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17720_07_010.png)'
- en: 'Here, we can see that if we multiply a scalar by the matrix, it just gets applied
    to all elements of the matrix. Considering this, our model can calculate the traffic
    grade and distance using the inverse matrix with the following notation:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，如果我们将标量乘以矩阵，它就会应用于矩阵的所有元素。考虑到这一点，我们的模型可以使用以下符号使用逆矩阵来计算交通等级和距离：
- en: '![](img/B17720_07_011.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17720_07_011.png)'
- en: We have only covered enough matrix mathematics to code our model, but even with
    just this, we can see that matrices enable us to manipulate multiple equations
    and shuffle them around to calculate different things quickly. However, if we
    were to code the matrix multiplications from scratch, it would take a lot of time
    and we would run the risk of performing errors. To have fast, safe development
    of our model, we will need to use NumPy module functions, which is what we will
    do in the next subsection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只覆盖了足够的矩阵数学知识来编写我们的模型，但即使这样，我们也可以看到矩阵使我们能够操纵多个方程，快速地重新排列它们以计算不同的事情。然而，如果我们从头开始编写矩阵乘法，这将花费很多时间，我们还会犯错误的风险。为了快速、安全地开发我们的模型，我们需要使用NumPy模块函数，这就是我们在下一小节将要做的。
- en: Building a Python object that executes our model
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建执行我们的模型的Python对象
- en: 'We saw in the previous section that there are two different paths that we can
    take. When we build our model, we are going to have two branches—one for calculating
    the time taken, and the other for calculating the traffic and distance from time.
    To build our model class, we must map out our dependencies, as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了两条不同的路径。当我们构建我们的模型时，我们将有两个分支——一个用于计算时间，另一个用于从时间计算交通和距离。为了构建我们的模型类，我们必须绘制出我们的依赖关系，如下所示：
- en: '![Figure 7.4 – Dependencies of a Python matrix model'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.4 – Dependencies of a Python matrix model](img/Figure_7.04_B17720.jpg)'
- en: '](img/Figure_7.04_B17720.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.4 – Dependencies of a Python matrix model](img/Figure_7.04_B17720.jpg)'
- en: Figure 7.4 – Dependencies of a Python matrix model
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – Python矩阵模型的依赖关系
- en: 'The preceding diagram shows us that we must define the weight matrix property
    before anything else as this property is the main mechanism on which everything
    else is calculated. This was also evident in the matrix equation. We can build
    our class with the weight matrix property, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示，我们必须在所有其他内容之前定义权重矩阵属性，因为这个属性是其他所有计算的主要机制。这在矩阵方程中也很明显。我们可以通过以下方式构建具有权重矩阵属性的类：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we can see that we use NumPy for our matrix and that our matrix is a
    list of lists. We use NumPy arrays over normal arrays because NumPy arrays have
    matrix operations such as `transpose`. Remember that the positions of the matrices
    matter when they are being multiplied. For instance, we have a simple matrix equation
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们使用NumPy进行矩阵操作，并且我们的矩阵是一个列表的列表。我们使用NumPy数组而不是普通数组，因为NumPy数组具有矩阵操作，如`transpose`。记住，当矩阵相乘时，矩阵的位置很重要。例如，我们有一个简单的矩阵方程如下：
- en: '![](img/B17720_07_012.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17720_07_012.png]'
- en: 'If we were to swap the matrix order, the matrices would not be able to multiply
    due to their shapes not being compatible; this is where the `transpose` operation
    comes in. A `transpose` function flips the matrix, enabling us to switch the order
    of the multiplication. We will not be using `transpose` in our model, but the
    Python commands in the terminal here show us how NumPy gives us this function
    out of the box:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们交换矩阵的顺序，由于它们的形状不兼容，矩阵将无法相乘；这就是`transpose`操作发挥作用的地方。`transpose`函数翻转矩阵，使我们能够切换乘法的顺序。在我们的模型中，我们不会使用`transpose`，但终端中的Python命令显示了NumPy如何直接提供这个函数：
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we can see that the matrices that we have built with NumPy arrays can
    change shape with ease. Now that we have established that we are building our
    matrices with NumPy arrays, we can build a function that will call the function
    that accepts the distance of the journey and the traffic grade for our `MatrixModel`
    class, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们用NumPy数组构建的矩阵可以轻松地改变形状。既然我们已经确定我们是用NumPy数组构建矩阵，我们可以构建一个函数，该函数将调用接受旅程距离和交通等级的函数，用于我们的`MatrixModel`类，如下所示：
- en: '[PRE62]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we can see that once we have constructed our input matrix, we multiply
    this by our weights matrix with the `np.dot` function. `result` is a matrix, which—as
    we know—is a list of lists. We unpack this and then return it in the form of a
    dictionary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，一旦我们构建了输入矩阵，我们就使用`np.dot`函数将其与权重矩阵相乘。`result`是一个矩阵，正如我们所知，它是一个列表的列表。我们解包它，然后以字典的形式返回它。
- en: 'We have nearly finished our model; all we must do now is now build our inverse
    model. This is where we pass in the times taken for the journey to calculate the
    distance and traffic grade for our `MatrixModel` class. This is done with the
    following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们的模型；我们现在必须构建我们的逆模型。这就是我们传入旅程所需时间来计算`MatrixModel`类的距离和交通等级的地方。这是通过以下代码完成的：
- en: '[PRE73]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here, we can see that we take the same approach; however, we use the `np.linalg.inv`
    function to get the inverse of the `self.weights_matrix` matrix. Now that this
    is done, we have a fully functioning model and we can test it, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们采取了相同的方法；然而，我们使用`np.linalg.inv`函数来获取`self.weights_matrix`矩阵的逆。现在这项工作已经完成，我们有一个完全功能化的模型，我们可以按照以下方式对其进行测试：
- en: '[PRE85]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Running the preceding code will give us the following printout in the terminal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将在终端给出以下输出：
- en: '[PRE93]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With this terminal printout, we can see that our model works and that our inverse
    model returns the original inputs. With this, we can also conclude that NumPy
    is more than just speeding up our code; it gives us extra tools to solve problems
    such as modeling with matrices. This is the last hurdle that could stop us from
    reaching for Rust. In the next section, we will use the NumPy Python module in
    Rust by recreating our model in Rust.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个终端输出，我们可以看到我们的模型是有效的，并且我们的逆模型返回了原始输入。由此，我们还可以得出结论，NumPy不仅仅是加快我们的代码；它为我们提供了额外的工具来解决诸如矩阵建模等问题。这是阻止我们达到Rust的最后障碍。在下一节中，我们将通过在Rust中重新创建我们的模型来使用NumPy
    Python模块。
- en: Using NumPy and other Python modules in Rust
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中使用NumPy和其他Python模块
- en: 'In this section, we are going to understand the basics of importing a Python
    module such as NumPy in our Rust program and return the result to our Python function.
    We will build our functionality in our Fibonacci number package that we have been
    coding so far in this book. We will also briefly explore importing a Python module
    in a generic sense so that you experience how to use a Python module that has
    the functionality you are relying on. We will build a more comprehensive approach
    to using Python modules in our Rust code in the next section. For this section,
    we will write all our code in the `src/lib.rs` file. Here are the steps we need
    to take:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在Rust程序中导入Python模块（如NumPy）的基本知识，并将结果返回到我们的Python函数中。我们将构建我们迄今为止在这本书中编写的Fibonacci数字包的功能。我们还将简要探讨以通用方式导入Python模块，以便您体验如何使用具有您所依赖的功能的Python模块。我们将在下一节中构建一个更全面的在Rust代码中使用Python模块的方法。对于本节，我们将把所有代码都写在`src/lib.rs`文件中。以下是我们需要采取的步骤：
- en: 'First, we need to acknowledge that we pass in a dictionary and return the results
    in it. Because of this, we must import the `PyDict` struct by running the following
    code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要承认我们传递了一个字典，并在其中返回结果。正因为如此，我们必须通过运行以下代码来导入`PyDict`结构体：
- en: '[PRE95]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now that this is imported, we can define our function by running the following
    code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经导入，我们可以通过运行以下代码来定义我们的函数：
- en: '[PRE96]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Because we are using a Python module, there is no surprise that we acquire the
    `PyDict` struct called `locals`.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在使用一个Python模块，因此我们获得名为`locals`的`PyDict`结构体并不令人惊讶。
- en: We then import the NumPy module using the `py.import` function, inserting it
    into our `localsstruct`.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用`py.import`函数导入NumPy模块，将其插入到我们的`localsstruct`中。
- en: 'As demonstrated here, we will be using our `locals` struct as Python storage:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如此所示，我们将使用我们的`locals`结构体作为Python存储：
- en: '![Figure 7.5 – Rust flow for computing Python processes within Rust'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.5 – Rust在Rust中计算Python进程的流程]'
- en: '](img/Figure_7.05_B17720.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 7.05 – Rust在Rust中计算Python进程的流程图](img/Figure_7.05_B17720.jpg)'
- en: Figure 7.5 – Rust flow for computing Python processes within Rust
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.5 – Rust在Rust中计算Python进程的流程
- en: Here, every time we run a Python operation in our Rust code, we will pass Python
    objects from the `locals` into the Python computation. We then pass any new Python
    variables we need to add to our `PyDict` `locals` struct.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，每次我们在Rust代码中运行Python操作时，我们都会将Python对象从`locals`传递到Python计算中。然后，我们将任何需要添加到我们的`PyDict`
    `locals`结构体的新Python变量传递进去。
- en: 'Now that we understand the flow, we can compute our first Python computation
    inside our `test_numpy` function by running the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经了解了流程，我们可以在`test_numpy`函数内部通过运行以下代码来计算我们的第一个Python计算：
- en: '[PRE97]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, we can see that we define the Python command as a string literal. We then
    pass this into our `py.eval` function. Our `None` parameter is for global variables.
    We are going to refrain from passing in global variables to keep this simple.
    We also pass in our `PyDict` `locals` struct to get the NumPy module we imported
    under the `np` namespace. We then unwrap the result and add this to our `localsstruct`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们定义Python命令为一个字符串字面量。然后，我们将这个传递给我们的`py.eval`函数。我们的`None`参数用于全局变量。我们将避免传递全局变量以保持简单。我们还传递了我们的`PyDict`
    `locals`结构体，以获取在`np`命名空间下导入的NumPy模块。然后，我们解包结果并将其添加到我们的`localsstruct`中。
- en: 'We can now create an input NumPy vector and insert the outcome into our `localsstruct`
    by running the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个输入NumPy向量，并通过运行以下代码将结果插入到我们的`localsstruct`中：
- en: '[PRE98]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now that we have both of our matricies in our `locals` storage, we can multiply
    them together, add them to our input dictionary, and return the result by running
    the following code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将两个矩阵存储在我们的`locals`存储中，我们可以将它们相乘，将它们添加到我们的输入字典中，并通过运行以下代码来返回结果：
- en: '[PRE99]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'With this, we can now use NumPy in our Rust code and get the results to pass
    them back into the Python system. We must remember to update our GitHub repository
    and reinstall our Rust package in our Python system. To test this, we can carry
    out the following console commands:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在可以在Rust代码中使用NumPy，并将结果传递回Python系统。我们必须记住更新我们的GitHub存储库，并在Python系统中重新安装我们的Rust包。为了测试这一点，我们可以执行以下控制台命令：
- en: '[PRE100]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, we can see that our NumPy process works inside Rust and returns Python
    objects that we can use just like all other Python objects. We could have done
    this using the Rust NumPy module, which gives us NumPy Rust structs. However,
    with the approach that we have covered, nothing is stopping us from using any
    Python module that we wish. We now have a full tool belt for fusing Python with
    Rust. In the next section, we will structure our NumPy model in Rust over a range
    of functions so that we can put in times for the inverse calculation and grade
    traffic with distance to calculate the times.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的NumPy过程在Rust中运行，并返回我们可以像所有其他Python对象一样使用的Python对象。我们本可以使用Rust NumPy模块，它为我们提供了NumPy
    Rust结构。然而，使用我们已介绍的方法，我们没有任何阻止我们使用我们想要的任何Python模块。我们现在有了融合Python和Rust的完整工具包。在下一节中，我们将通过一系列函数在Rust中构建NumPy模型，以便我们可以输入逆计算的时间并按距离计算时间来评估交通。
- en: Recreating our NumPy model in Rust
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中重新创建我们的NumPy模型
- en: 'Now that we can use our NumPy module in Rust, we need to explore how to structure
    it so that we can use Python modules to solve bigger problems. We will do this
    by building a NumPy model with a Python interface. To achieve this, we can break
    down the processes into functions that can be used as and when we need them. The
    structure of our NumPy model can be seen here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在Rust中使用我们的NumPy模块，我们需要探索如何构建它，以便我们可以使用Python模块来解决更大的问题。我们将通过构建一个具有Python接口的NumPy模型来实现这一点。为了实现这一点，我们可以将过程分解为我们可以按需使用的函数。我们的NumPy模型的结构如下所示：
- en: '![Figure 7.6 – Rust NumPy model structure'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.6 – Rust NumPy模型结构'
- en: '](img/Figure_7.06_B17720.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.06_B17720.jpg]'
- en: Figure 7.6 – Rust NumPy model structure
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – Rust NumPy模型结构
- en: 'Considering the flow of our model structure in the preceding diagram, we can
    build our NumPy model in Rust with the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面图表中我们的模型结构的流程，我们可以按照以下步骤在Rust中构建我们的NumPy模型：
- en: Build `get_weight_matrix` and `inverse_weight_matrix` functions.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`get_weight_matrix`和`inverse_weight_matrix`函数。
- en: Build `get_parameters`, `get_times`, and `get_input_vector` functions.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`get_parameters`、`get_times`和`get_input_vector`函数。
- en: Build `calculate_parameters` and `calculate_times` functions.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`calculate_parameters`和`calculate_times`函数。
- en: Add calculate functions to the Python bindings and add a NumPy dependency to
    our `setup.py` file.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Python绑定添加计算函数，并在`setup.py`文件中添加NumPy依赖项。
- en: Build our Python interface.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的Python接口。
- en: We can see that each step has dependencies from the previous step. Let's have
    a detailed look at each of these steps in the following subsections.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每个步骤都依赖于前一个步骤。让我们在以下子节中详细查看每个步骤。
- en: Building get_weight_matrix and inverse_weight_matrix functions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建`get_weight_matrix`和`inverse_weight_matrix`函数
- en: 'Our weight and inverse weight matrices enable us to calculate the times and
    then recalculate the parameters inputted based on those times. We can start building
    our weight matrix function in the `src/numpy_model.rs` file with the following
    steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的权重和逆权重矩阵使我们能够计算时间，然后根据这些时间重新计算输入的参数。我们可以在`src/numpy_model.rs`文件中通过以下步骤开始构建我们的权重矩阵函数：
- en: 'Before we write any code, we can import what we need by running the following
    code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们可以通过运行以下代码来导入我们需要的：
- en: '[PRE104]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We will be using the `PyDict` struct to pass data between our functions and
    `pyo3` macros to wrap the functions and get the Python GIL.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`PyDict`结构在函数之间传递数据，并使用`pyo3`宏包装函数以获取Python GIL。
- en: 'Now that we have all of our imports, we can build our weight matrix function
    by running the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所有必要的模块，我们可以通过运行以下代码来构建我们的权重矩阵函数：
- en: '[PRE105]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, we can see that we accept a reference to Python and `locals` storage.
    With this, we run our code and add it to our `locals` storage. We do not have
    to return anything because these are just referencing via borrowing. This means
    that the `py` and `locals` variables are not deleted when the scope of the variable
    has run its course. It also means that the `locals` storage will be updated with
    our `weights_matrix` function even though nothing is returned. We will be using
    this approach in most of our functions shown in *Figure 7.6*.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们接受对Python和 `locals` 存储的引用。有了这个，我们运行我们的代码并将其添加到我们的 `locals` 存储中。我们不需要返回任何内容，因为这些只是通过借用进行引用。这意味着当变量的作用域结束时，`py`
    和 `locals` 变量不会被删除。这也意味着即使没有返回任何内容，`locals` 存储空间也会通过我们的 `weights_matrix` 函数被更新。我们将在图7.6中展示的大多数函数中使用这种方法。
- en: 'Now that we have our approach defined, we can create our inverse matrix function
    by running the following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的方法，我们可以通过以下代码创建我们的逆矩阵函数：
- en: '[PRE106]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Clearly, the `invert_get_weight_matrix` function cannot be run unless we run
    our `get_weight_matrix` function beforehand. We could make this more robust with
    a `get_item` check for `weights_matrix` in our `locals` storage and run the `get_weight_matrix`
    function if the weights matrix is not there, but this is not essential. We now
    have our weights functions defined, so we can move on to our next step of building
    our input vectors and calculation functions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，除非我们事先运行 `get_weight_matrix` 函数，否则无法运行 `invert_get_weight_matrix` 函数。我们可以在
    `locals` 存储中的 `weights_matrix` 上进行 `get_item` 检查，以使这个操作更加健壮，如果权重矩阵不存在，则运行 `get_weight_matrix`
    函数，但这不是必需的。我们现在已经定义了权重函数，因此可以继续到下一步——构建我们的输入向量和计算函数。
- en: Building get_parameters, get_times, and get_input_vector functions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 `get_parameters`、`get_times` 和 `get_input_vector` 函数
- en: 'Just as with the previous steps. we are going to get our parameters, times,
    and inputs by using three functions. We will also have to pass the Python struct
    and `locals` storage into these functions as they are also going to be using NumPy
    via Python. We define these three functions in the following steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的步骤一样，我们将通过使用三个函数来获取我们的参数、时间和输入。我们还需要将这些函数中的Python `struct` 和 `locals` 存储传递进去，因为它们也将通过Python使用NumPy。我们将在以下步骤中定义这三个函数：
- en: 'Referring to *Figure 7.6*, we can see that our input vector function does not
    have any dependencies and the other two depend on the input vector. Considering
    this, we build our input vector function by running the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考图7.6，我们可以看到我们的输入向量函数没有任何依赖，而其他两个则依赖于输入向量。考虑到这一点，我们通过以下代码构建我们的输入向量函数：
- en: '[PRE107]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, we can see that this vector is generic, so we can pass in the parameters
    or the times depending on the calculation that we need. We can see that we use
    the `format!` macro to pass our parameters into our Python code.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个向量是通用的，因此我们可以根据所需的计算传递参数或时间。我们可以看到我们使用 `format!` 宏将参数传递到我们的Python代码中。
- en: 'Now that our input vector function is defined, we can build our calculations
    by running the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了输入向量函数，我们可以通过以下代码构建我们的计算：
- en: '[PRE108]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: With the aforementioned functions, we can get the variables that we need and
    put them into our Python code that uses the NumPy `np.dot` function. We then return
    the result as opposed to adding it to `locals`. We do not need to add it to `locals`
    because we are not going to use the results in any other computations in Rust.
    Now that all the computation steps have been done, we can move on to our next
    step—building the calculation functions that run and organize the whole process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述函数，我们可以获取所需的变量并将它们放入使用NumPy `np.dot` 函数的Python代码中。然后我们将结果返回，而不是添加到 `locals`
    中。我们不需要将其添加到 `locals` 中，因为我们不会在Rust中的任何其他计算中使用这些结果。现在所有的计算步骤都已经完成，我们可以继续到下一步——构建运行和组织整个过程的计算函数。
- en: Building calculate_parameters and calculate_times functions
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 `calculate_parameters` 和 `calculate_times` 函数
- en: 'With these calculation functions, we need to take in some parameters, get the
    Python GIL, define our `locals` storage, and then run a series of computation
    processes to get what we need. We can define a `calculate_times` function by running
    the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些计算函数时，我们需要输入一些参数，获取Python GIL，定义我们的 `locals` 存储空间，然后运行一系列计算过程以获取所需内容。我们可以通过以下代码定义一个
    `calculate_times` 函数：
- en: '[PRE109]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here, we can see that we get the weight matrix, then the input vector, and
    then insert the results into a blank `PyDict` struct and return it. We can see
    the flexibility in this approach. We can slot functions in and out whenever we
    want, and rearranging the order is not a struggle. Now that we have built our
    `calculate_times` function, we can build our `calculate_parameters` function by
    running the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们首先获取权重矩阵，然后是输入向量，然后将结果插入到一个空的`PyDict`结构中并返回它。我们可以看到这种方法的灵活性。我们可以随时添加或移除函数，重新排列顺序也不是问题。现在我们已经构建了`calculate_times`函数，我们可以通过运行以下代码来构建`calculate_parameters`函数：
- en: '[PRE122]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: We can see that we use the same approach as our `calculate_times` function,
    using the invert weights instead. We could refactor this to reduce the repeated
    code, or we could enjoy the maximum flexibility of having the two functions isolated
    against each other. Our model is built now, so we can move to our next step where
    we add our calculation functions to our Python bindings.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们使用了与我们的`calculate_times`函数相同的方法，使用的是逆权重。我们可以重构这段代码以减少重复代码，或者我们可以享受两个函数相互隔离的最大灵活性。我们的模型现在已经构建完成，因此我们可以进入下一步，将我们的计算函数添加到我们的Python绑定中。
- en: Adding calculate functions to the Python bindings and adding a NumPy dependency
    to our setup.py file
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将计算函数添加到Python绑定中，并在`setup.py`文件中添加NumPy依赖项
- en: 'Now that we have all the model code needed to calculate parameters through
    two functions, we are going to have to enable our outside user to utilize these
    functions with the following steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通过两个函数计算参数所需的所有模型代码，我们必须通过以下步骤使外部用户能够使用这些函数：
- en: 'In our `src/lib.rs` file, we must define our module by running the following
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`src/lib.rs`文件中，我们必须通过运行以下代码定义我们的模块：
- en: '[PRE136]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now that this module has been declared, we can import the functions by running
    the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这个模块已经声明，我们可以通过运行以下代码导入函数：
- en: '[PRE137]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We then wrap our functions in our module by running the following code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过运行以下代码将我们的函数包装在我们的模块中：
- en: '[PRE138]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Remember—`. . .` denotes existing code. We now must accept that our Rust code
    has a dependency on NumPy, so in our `setup.py` file, our dependencies will look
    like this:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住——`...`表示现有代码。我们现在必须接受我们的Rust代码依赖于NumPy，因此在我们的`setup.py`文件中，我们的依赖项将如下所示：
- en: '[PRE139]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: At this point, there is nothing stopping us from using our NumPy model; however,
    it will be better with a simple Python interface, which we will define in the
    next step.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，没有任何阻碍我们使用我们的NumPy模型；然而，有一个简单的Python接口会更好，我们将在下一步定义它。
- en: Building our Python interface
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的Python接口
- en: 'In the `src/numpy_model.rs` file, we import what we need and define a basic
    class by running the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/numpy_model.rs`文件中，我们导入所需的模块并通过运行以下代码定义一个基本类：
- en: '[PRE140]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The `self.inventory` variable will be where we store the results. Our functions
    for our class should calculate the times and parameters by calling our Rust functions,
    as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.inventory`变量将用于存储结果。我们类中的函数应该通过调用我们的Rust函数来计算时间和参数，如下所示：'
- en: '[PRE145]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Now that our Python interface is built, we have finished our NumPy model.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了Python接口，我们的NumPy模型已经完成。
- en: 'We must remember to update our GitHub repository and reinstall our module.
    Once this is done, we can run the following Python console commands:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记得更新我们的GitHub仓库并重新安装我们的模块。一旦完成，我们可以运行以下Python控制台命令：
- en: '[PRE158]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: While this demonstrates how we can use Python modules within Rust, we have to
    be careful when to use them. For our NumPy model example, it would have just been
    better to use NumPy within our Python code. To be honest, there is not that much
    that you can do with Python modules that you cannot do in Rust. Rust already has
    a NumPy crate that we can use. We should be using the Python modules in the initial
    stage if we cannot find—or do not have time to find and learn—a Rust alternative
    module; however, over time, these should be phased out of your Rust code.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这展示了我们如何在Rust中使用Python模块，但我们必须小心何时使用它们。对于我们的NumPy模型示例，直接在我们的Python代码中使用NumPy会更好。说实话，你用Python模块能做的事情，你用Rust也能做。Rust已经有一个我们可以使用的NumPy
    crate。如果我们找不到——或者没有时间找到并学习——Rust的替代模块，我们应该在初始阶段使用Python模块；然而，随着时间的推移，这些应该从你的Rust代码中逐步淘汰。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completed our tool belt when it comes to building Python
    extensions in Rust by using Python modules in our Rust code. We got a deeper appreciation
    for modules such as NumPy by exploring matrix mathematics to create a simple mathematical
    model. This showed us that we use modules such as NumPy for other functionality
    such as matrix multiplication, as opposed to just using NumPy for speed. This
    was demonstrated when we manipulated multiple mathematical equations with a few
    lines of NumPy code and matrix logic.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过在 Rust 代码中使用 Python 模块，完成了构建 Rust 中 Python 扩展的工具集。通过探索矩阵数学来创建一个简单的数学模型，我们对诸如
    NumPy 等模块有了更深的理解。这表明我们使用诸如 NumPy 等模块是为了其他功能，如矩阵乘法，而不仅仅是使用 NumPy 来提高速度。这在我们用几行
    NumPy 代码和矩阵逻辑操作多个数学方程时得到了证明。
- en: We then used matrix NumPy multiplication functions in our Rust code to recreate
    our mathematical model using a flexible functional programming approach. We finished
    this off by making our interface in a Python class. We also must remember that
    the NumPy implementation was faster than our Rust code. This is partly down to
    poor implementation on our part and the C optimization in NumPy. This has shown
    us that while Rust is a lot faster than Python, solving problems with Python packages
    such as NumPy might still be faster until equivalent crates are coded in Rust.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 Rust 代码中的矩阵 NumPy 乘法函数，通过灵活的函数式编程方法重新创建我们的数学模型。我们通过在 Python 类中创建我们的接口来完成这项工作。我们还必须记住，NumPy
    的实现比我们的 Rust 代码更快。这部分的归因于我们部分的糟糕实现和 NumPy 中的 C 优化。这表明虽然 Rust 比 Python 快得多，但使用
    Python 包如 NumPy 解决问题可能仍然更快，直到等效的 Rust crate 被编写出来。
- en: We used a generic approach to using Python modules in Rust. Because of this,
    we can theoretically use any Python module that we want. This means that if the
    Python module that you are rewriting relies on the functionality of third-party
    Python modules such as NumPy, we are now able to create Rust functions that use
    them. Considering this, there is no generic technical hurdle stopping you from
    rewriting Python code in Rust and slotting it into your Python system.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一种通用的方法来在 Rust 中使用 Python 模块。正因为如此，我们可以理论上使用我们想要的任何 Python 模块。这意味着，如果您正在重写的
    Python 模块依赖于第三方 Python 模块的功能，例如 NumPy，我们现在能够创建使用它们的 Rust 函数。考虑到这一点，没有通用的技术障碍阻止您在
    Rust 中重写 Python 代码并将其嵌入到您的 Python 系统中。
- en: In the next chapter, we will put everything that we have learned so far together
    to build a new Python package written in Rust from start to end.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把迄今为止所学的一切整合起来，从头到尾用 Rust 编写一个新的 Python 包。
- en: Questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the steps we must follow to run a Python module in Rust?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须遵循哪些步骤才能在 Rust 中运行一个 Python 模块？
- en: How do you import a Python module into your Rust code?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将 Python 模块导入到您的 Rust 代码中？
- en: If we wanted to use our Python code result inside Rust, how would we do this?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在 Rust 中使用我们的 Python 代码结果，我们该如何做？
- en: When you compare speed graphs of Python/NumPy with Rust, the Python/NumPy code
    has a lot of spikes. What could be causing this?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您比较 Python/NumPy 与 Rust 的速度图表时，Python/NumPy 代码有很多峰值。这可能是由于什么原因造成的？
- en: Do you think our NumPy implementation in Rust will be slower or faster than
    calling NumPy from Python, and why?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你认为我们用 Rust 实现的 NumPy 与从 Python 调用 NumPy 相比，速度会更快还是更慢，为什么？
- en: Answers
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We initially must get Python from the GIL. We then must build a `PyDict` struct
    in order to store and pass Python variables between Python executions. We then
    define the Python code as a string literal and pass this into our `py.eval` function
    with our `PyDict` storage.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最初必须从 GIL 获取 Python。然后我们必须构建一个 `PyDict` 结构体，以便在 Python 执行之间存储和传递 Python 变量。然后我们将
    Python 代码定义为字符串字面量，并将其作为参数传递给我们的 `py.eval` 函数，同时使用我们的 `PyDict` 存储空间。
- en: We must make sure that we get Python from the GIL. We then use this to run the
    `py.eval` function with the import line of code passed in as a string literal.
    We must remember to pass in our `PyDict` storage to ensure that we can reference
    the module in the future.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保我们从 GIL 获取 Python。然后我们使用它来运行 `py.eval` 函数，并将导入代码行作为字符串字面量传递。我们必须记住传递我们的
    `PyDict` 存储空间，以确保我们将来可以引用该模块。
- en: 'We must remember that Python code returns a `PyAny` struct, which we can extract
    using the following code:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须记住，Python 代码返回一个 `PyAny` 结构体，我们可以使用以下代码提取它：
- en: '[PRE167]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: This is because the Python versions must keep stopping to clean up variables
    with the garbage collection mechanism.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为 Python 版本必须不断停止以清理变量，这是垃圾回收机制的一部分。
- en: It would be slightly slower. This is because we are essentially still running
    Python code but through an extra layer which is Rust.Considering this, we should
    be using Python code out of convenience as opposed to optimization.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可能会稍微慢一些。这是因为我们本质上仍然在运行 Python 代码，但通过一个额外的层，即 Rust。考虑到这一点，我们应该出于方便而不是优化的原因使用
    Python 代码。
- en: Further reading
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'NumPy documentation for Rust (2021): *Crate numpy:* [https://docs.rs/numpy/0.14.1/numpy/](https://docs.rs/numpy/0.14.1/numpy/)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rust 的 NumPy 文档（2021）: *Crate numpy:* [https://docs.rs/numpy/0.14.1/numpy/](https://docs.rs/numpy/0.14.1/numpy/)'
- en: 'Giuseppe Ciaburro (2020): *Hands-on Simulation Modeling with Python: Develop
    simulation models to get accurate results and enhance decision-making processes*.
    Packt Publishing.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Giuseppe Ciaburro (2020): *使用 Python 进行实践模拟建模：开发模拟模型以获得准确的结果并增强决策过程*。Packt
    出版。'
