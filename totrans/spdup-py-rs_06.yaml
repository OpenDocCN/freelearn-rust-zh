- en: '*Chapter 7*: Using Python Modules with Rust'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now become comfortable with writing Python packages in Rust that can
    be installed using `pip`. However, a large advantage of Python is that it has
    a lot of mature Python libraries that help us write productive code with minimal
    errors. This seems a legitimate observation that could halt us from adopting Rust
    in our Python system. However, in this chapter, we counter this observation by
    importing Python modules into our Rust code and running Python code in our Rust
    code. To achieve an understanding of this, we are going to use the **NumPy** Python
    package to implement a basic mathematical model. Once this is done, we are going
    to use the NumPy package in our Rust code to simplify the implementation of our
    mathematical model. Finally, we will evaluate the speed of both implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a model in NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NumPy and other Python modules in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recreating our NumPy model in Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, we will be able to import Python packages into
    our Rust code and use it. This is powerful, as relying on a certain Python package
    would not hold us back from implementing Rust in our Python systems for a certain
    task. The solutions that we implement in this chapter using pure Python, Rust,
    and NumPy will also give us an understanding of the trade-offs of each implementation
    when it comes to code complexity and speed so that we do not try to implement
    a *one-size-fits-all* solution for every problem, avoiding sub-optimal solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found via the following GitHub link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven](https://github.com/PacktPublishing/Speed-up-your-Python-with-Rust/tree/main/chapter_seven)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start using NumPy in our own modules, we must explore what NumPy is
    and how to use it. NumPy is a third-party computational Python package that enables
    us to perform calculations on lists. NumPy is mainly written in the C language,
    meaning that it will be faster than pure Python. In this section, we will have
    to assess whether our NumPy implementation beats a Rust implementation that is
    imported into Python.
  prefs: []
  type: TYPE_NORMAL
- en: Adding vectors in NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy enables us to build vectors that we can loop through and apply functions
    to. We can also perform operations between vectors. We can demonstrate the power
    of NumPy by adding items of each vector together, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve this, we initially need to import modules by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can build a `numpy_function` NumPy function that creates two
    NumPy vectors of a certain size and adds them together by running the code presented
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we can add the vectors by merely using the addition operator.
    Now that we have our function defined, we can plot how this scales by looping
    through a list of integers and applying `numpy_function` to the items, collecting
    the results in a list, by running the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a line plot, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Time taken to add two NumPy vectors based on size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Time taken to add two NumPy vectors based on size
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding screenshot that the increase is linear. This is
    expected because there is only one loop when adding each integer in the vector
    to the other vector. We can also see that there are points where the time taken
    shoots up—this is the garbage collection kicking in. To appreciate the effect
    NumPy has, we can redefineour example by adding both vectors with a list in pure
    Python in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding vectors in pure Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can add two vectors in pure Python and time this by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With our new Python function, we can run both NumPy and Python functions and
    chart them by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Time taken to add two vectors based on size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Time taken to add two vectors based on size
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 7.2*, the NumPy vectors are represented in the bottom
    line and pure Python is represented in the increasing line, so we can conclude
    that Python does not scale that well when compared to our NumPy implementation.
    The output makes it clear that NumPy is a good choice when performing calculations
    on big vectors. However, how does this compare to our Rust implementation? We
    explore this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding vectors using NumPy in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To compare how NumPy compares to our Rust implementation, we must incorporate
    an adding vector function to our Rust package that we have been building throughout
    this book so far. Here are the steps we need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering that this is a test function that we are using for demonstrative
    purposes, we can merely insert it into our `lib.rs` file. All we do is build a
    `time_add_vectors` function that accepts a number, create two vectors of a size
    equal to the number passed as input, loop through them at the same time, and add
    the items together, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have done this, we must remember to add this function to our module,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must remember to update our GitHub repository and reinstall our Rust package
    in our Python environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this is done, we must implement the function in our Python testing script
    and time it. First, we must import it with the code shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, we can define our `rust_function` Python function that calls
    the `time_add_vectors` function and times how long it takes to complete the addition
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You may have noticed that we trim `result` returned by `rust_function`. This
    is not cheating—we do this because when the garbage collector kicks in, it can
    cause spikes and ruin the scaling of the graph. We will also do this with our
    NumPy function by running the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we are applying the same metrics to both the functions so that
    one will not be artificially lowered compared to the other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have done this, we need to define the pure function by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It must be noted that we have a higher cut-off for the pure Python because we
    expect the base reading to be much higher.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have all of our metric functions for Rust, NumPy, and pure Python,
    we can create Python lists with the results of both functions and plot them by
    running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running our code will give us the result shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Time taken to add two vectors based on the size of the vectors;'
  prefs: []
  type: TYPE_NORMAL
- en: 'left: NumPy; middle: Rust; right: pure Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3 – Time taken to add two vectors based on the size of the vectors;
    left: NumPy; middle: Rust; right: pure Python'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that NumPy is the fastest and is not
    scaling aggressively as the size of the vector increases. Our Rust implementation
    is a lot faster than our pure Python implementation by an order of magnitude,
    but it is not as efficient as NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that Python optimizations such as NumPy do increase the speed compared
    to pure Python and Rust. However, NumPy's clean syntax of simply adding vectors
    is not the only functional advantage of this module. In the next section, we will
    explore another functionality that NumPy has that would require a lot of extra
    code if we were going to try to code it from scratch in Python or Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Building a model in NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to build a basic mathematical model to demonstrate
    the power that NumPy has apart from speed. We are going to use matrices to make
    a simple model. To achieve this, we will have to carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define our model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Python object that executes our model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at these steps in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A mathematical model is essentially a set of weights that calculate an outcome
    based on inputs. Before we go any further, we must remember the scope of this
    book. We are building a model to demonstrate how to utilize NumPy. If we covered
    the nuances of mathematical modeling, that would take up the whole book. We will
    be building a model based on the example discussed in the previous section, but
    this does not mean that the model defined is an accurate description of the complexity
    of mathematical modeling. Here are the steps we need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by looking at a very simple mathematical model that would be a simple
    speed equation, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_001.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'With our model, we can calculate the time taken to complete a journey with
    the rearrangement shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_002.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The final equation on the right is merely substituting the values for letters
    so that they can be plugged into a bigger model without it taking up an entire
    page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s take our model a little further. We collect some data from a trucking
    company, and we manage to quantify different grades of traffic into numbers and
    fit our data so that we can produce a weight to describe the effect traffic has
    on time. With this, our model has evolved to the one defined here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_003.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here, ![](img/B17720_07_004.png) is the weight of traffic, and *y* is the grade
    of traffic. As we can see, if the grade of traffic increases, so does the time.
    Now, let''s say that the model is different for cars and trucks. This gives us
    the following set of equations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17720_07_005.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![](img/B17720_07_006.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can deduce from the equations that the distance (*x*) and traffic grade (*y*)
    are the same for both cars and trucks. This makes sense. While the weights could
    be different as cars could be affected by distance and traffic differently, as
    denoted in their weights, the input parameters are the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Considering this, the equation could be defined as the following matrix equation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_007.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This might seem excessive right now, but there are advantages to this. Matrices
    have a range of functions that enable us to perform algebra on them. We will cover
    a few here so that we can understand how NumPy becomes invaluable to us when calculating
    this model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To do this, we must acknowledge that matrix multiplication must occur in a
    certain order for it to work. Our model is essentially calculated by the notation
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_008.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Our *x* *y* matrix must be on the right of our weights matrix. We can add more
    inputs to our *x* *y* matrix with the following notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_009.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can, in fact, keep stacking our inputs, and we will get proportional outputs.
    This is powerful; we can put in an input matrix of any size if we keep the dimensions
    of the matrix consistent. We can also invert our matrix. If we invert our matrix,
    we can then input times to work out the distance and grade of the traffic. Inverting
    a matrix takes the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_010.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here, we can see that if we multiply a scalar by the matrix, it just gets applied
    to all elements of the matrix. Considering this, our model can calculate the traffic
    grade and distance using the inverse matrix with the following notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17720_07_011.png)'
  prefs: []
  type: TYPE_IMG
- en: We have only covered enough matrix mathematics to code our model, but even with
    just this, we can see that matrices enable us to manipulate multiple equations
    and shuffle them around to calculate different things quickly. However, if we
    were to code the matrix multiplications from scratch, it would take a lot of time
    and we would run the risk of performing errors. To have fast, safe development
    of our model, we will need to use NumPy module functions, which is what we will
    do in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Python object that executes our model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in the previous section that there are two different paths that we can
    take. When we build our model, we are going to have two branches—one for calculating
    the time taken, and the other for calculating the traffic and distance from time.
    To build our model class, we must map out our dependencies, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Dependencies of a Python matrix model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Dependencies of a Python matrix model
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows us that we must define the weight matrix property
    before anything else as this property is the main mechanism on which everything
    else is calculated. This was also evident in the matrix equation. We can build
    our class with the weight matrix property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we use NumPy for our matrix and that our matrix is a
    list of lists. We use NumPy arrays over normal arrays because NumPy arrays have
    matrix operations such as `transpose`. Remember that the positions of the matrices
    matter when they are being multiplied. For instance, we have a simple matrix equation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17720_07_012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to swap the matrix order, the matrices would not be able to multiply
    due to their shapes not being compatible; this is where the `transpose` operation
    comes in. A `transpose` function flips the matrix, enabling us to switch the order
    of the multiplication. We will not be using `transpose` in our model, but the
    Python commands in the terminal here show us how NumPy gives us this function
    out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the matrices that we have built with NumPy arrays can
    change shape with ease. Now that we have established that we are building our
    matrices with NumPy arrays, we can build a function that will call the function
    that accepts the distance of the journey and the traffic grade for our `MatrixModel`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that once we have constructed our input matrix, we multiply
    this by our weights matrix with the `np.dot` function. `result` is a matrix, which—as
    we know—is a list of lists. We unpack this and then return it in the form of a
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have nearly finished our model; all we must do now is now build our inverse
    model. This is where we pass in the times taken for the journey to calculate the
    distance and traffic grade for our `MatrixModel` class. This is done with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we take the same approach; however, we use the `np.linalg.inv`
    function to get the inverse of the `self.weights_matrix` matrix. Now that this
    is done, we have a fully functioning model and we can test it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code will give us the following printout in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: With this terminal printout, we can see that our model works and that our inverse
    model returns the original inputs. With this, we can also conclude that NumPy
    is more than just speeding up our code; it gives us extra tools to solve problems
    such as modeling with matrices. This is the last hurdle that could stop us from
    reaching for Rust. In the next section, we will use the NumPy Python module in
    Rust by recreating our model in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Using NumPy and other Python modules in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to understand the basics of importing a Python
    module such as NumPy in our Rust program and return the result to our Python function.
    We will build our functionality in our Fibonacci number package that we have been
    coding so far in this book. We will also briefly explore importing a Python module
    in a generic sense so that you experience how to use a Python module that has
    the functionality you are relying on. We will build a more comprehensive approach
    to using Python modules in our Rust code in the next section. For this section,
    we will write all our code in the `src/lib.rs` file. Here are the steps we need
    to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to acknowledge that we pass in a dictionary and return the results
    in it. Because of this, we must import the `PyDict` struct by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that this is imported, we can define our function by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are using a Python module, there is no surprise that we acquire the
    `PyDict` struct called `locals`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then import the NumPy module using the `py.import` function, inserting it
    into our `localsstruct`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As demonstrated here, we will be using our `locals` struct as Python storage:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Rust flow for computing Python processes within Rust'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B17720.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.5 – Rust flow for computing Python processes within Rust
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, every time we run a Python operation in our Rust code, we will pass Python
    objects from the `locals` into the Python computation. We then pass any new Python
    variables we need to add to our `PyDict` `locals` struct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we understand the flow, we can compute our first Python computation
    inside our `test_numpy` function by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we define the Python command as a string literal. We then
    pass this into our `py.eval` function. Our `None` parameter is for global variables.
    We are going to refrain from passing in global variables to keep this simple.
    We also pass in our `PyDict` `locals` struct to get the NumPy module we imported
    under the `np` namespace. We then unwrap the result and add this to our `localsstruct`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now create an input NumPy vector and insert the outcome into our `localsstruct`
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have both of our matricies in our `locals` storage, we can multiply
    them together, add them to our input dictionary, and return the result by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this, we can now use NumPy in our Rust code and get the results to pass
    them back into the Python system. We must remember to update our GitHub repository
    and reinstall our Rust package in our Python system. To test this, we can carry
    out the following console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that our NumPy process works inside Rust and returns Python
    objects that we can use just like all other Python objects. We could have done
    this using the Rust NumPy module, which gives us NumPy Rust structs. However,
    with the approach that we have covered, nothing is stopping us from using any
    Python module that we wish. We now have a full tool belt for fusing Python with
    Rust. In the next section, we will structure our NumPy model in Rust over a range
    of functions so that we can put in times for the inverse calculation and grade
    traffic with distance to calculate the times.
  prefs: []
  type: TYPE_NORMAL
- en: Recreating our NumPy model in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can use our NumPy module in Rust, we need to explore how to structure
    it so that we can use Python modules to solve bigger problems. We will do this
    by building a NumPy model with a Python interface. To achieve this, we can break
    down the processes into functions that can be used as and when we need them. The
    structure of our NumPy model can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Rust NumPy model structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.06_B17720.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Rust NumPy model structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the flow of our model structure in the preceding diagram, we can
    build our NumPy model in Rust with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build `get_weight_matrix` and `inverse_weight_matrix` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build `get_parameters`, `get_times`, and `get_input_vector` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build `calculate_parameters` and `calculate_times` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add calculate functions to the Python bindings and add a NumPy dependency to
    our `setup.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our Python interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that each step has dependencies from the previous step. Let's have
    a detailed look at each of these steps in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Building get_weight_matrix and inverse_weight_matrix functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our weight and inverse weight matrices enable us to calculate the times and
    then recalculate the parameters inputted based on those times. We can start building
    our weight matrix function in the `src/numpy_model.rs` file with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write any code, we can import what we need by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be using the `PyDict` struct to pass data between our functions and
    `pyo3` macros to wrap the functions and get the Python GIL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have all of our imports, we can build our weight matrix function
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we accept a reference to Python and `locals` storage.
    With this, we run our code and add it to our `locals` storage. We do not have
    to return anything because these are just referencing via borrowing. This means
    that the `py` and `locals` variables are not deleted when the scope of the variable
    has run its course. It also means that the `locals` storage will be updated with
    our `weights_matrix` function even though nothing is returned. We will be using
    this approach in most of our functions shown in *Figure 7.6*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our approach defined, we can create our inverse matrix function
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Clearly, the `invert_get_weight_matrix` function cannot be run unless we run
    our `get_weight_matrix` function beforehand. We could make this more robust with
    a `get_item` check for `weights_matrix` in our `locals` storage and run the `get_weight_matrix`
    function if the weights matrix is not there, but this is not essential. We now
    have our weights functions defined, so we can move on to our next step of building
    our input vectors and calculation functions.
  prefs: []
  type: TYPE_NORMAL
- en: Building get_parameters, get_times, and get_input_vector functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as with the previous steps. we are going to get our parameters, times,
    and inputs by using three functions. We will also have to pass the Python struct
    and `locals` storage into these functions as they are also going to be using NumPy
    via Python. We define these three functions in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to *Figure 7.6*, we can see that our input vector function does not
    have any dependencies and the other two depend on the input vector. Considering
    this, we build our input vector function by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that this vector is generic, so we can pass in the parameters
    or the times depending on the calculation that we need. We can see that we use
    the `format!` macro to pass our parameters into our Python code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that our input vector function is defined, we can build our calculations
    by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the aforementioned functions, we can get the variables that we need and
    put them into our Python code that uses the NumPy `np.dot` function. We then return
    the result as opposed to adding it to `locals`. We do not need to add it to `locals`
    because we are not going to use the results in any other computations in Rust.
    Now that all the computation steps have been done, we can move on to our next
    step—building the calculation functions that run and organize the whole process.
  prefs: []
  type: TYPE_NORMAL
- en: Building calculate_parameters and calculate_times functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With these calculation functions, we need to take in some parameters, get the
    Python GIL, define our `locals` storage, and then run a series of computation
    processes to get what we need. We can define a `calculate_times` function by running
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we get the weight matrix, then the input vector, and
    then insert the results into a blank `PyDict` struct and return it. We can see
    the flexibility in this approach. We can slot functions in and out whenever we
    want, and rearranging the order is not a struggle. Now that we have built our
    `calculate_times` function, we can build our `calculate_parameters` function by
    running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we use the same approach as our `calculate_times` function,
    using the invert weights instead. We could refactor this to reduce the repeated
    code, or we could enjoy the maximum flexibility of having the two functions isolated
    against each other. Our model is built now, so we can move to our next step where
    we add our calculation functions to our Python bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Adding calculate functions to the Python bindings and adding a NumPy dependency
    to our setup.py file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the model code needed to calculate parameters through
    two functions, we are going to have to enable our outside user to utilize these
    functions with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `src/lib.rs` file, we must define our module by running the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that this module has been declared, we can import the functions by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then wrap our functions in our module by running the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember—`. . .` denotes existing code. We now must accept that our Rust code
    has a dependency on NumPy, so in our `setup.py` file, our dependencies will look
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, there is nothing stopping us from using our NumPy model; however,
    it will be better with a simple Python interface, which we will define in the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Python interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `src/numpy_model.rs` file, we import what we need and define a basic
    class by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The `self.inventory` variable will be where we store the results. Our functions
    for our class should calculate the times and parameters by calling our Rust functions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Now that our Python interface is built, we have finished our NumPy model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must remember to update our GitHub repository and reinstall our module.
    Once this is done, we can run the following Python console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: While this demonstrates how we can use Python modules within Rust, we have to
    be careful when to use them. For our NumPy model example, it would have just been
    better to use NumPy within our Python code. To be honest, there is not that much
    that you can do with Python modules that you cannot do in Rust. Rust already has
    a NumPy crate that we can use. We should be using the Python modules in the initial
    stage if we cannot find—or do not have time to find and learn—a Rust alternative
    module; however, over time, these should be phased out of your Rust code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed our tool belt when it comes to building Python
    extensions in Rust by using Python modules in our Rust code. We got a deeper appreciation
    for modules such as NumPy by exploring matrix mathematics to create a simple mathematical
    model. This showed us that we use modules such as NumPy for other functionality
    such as matrix multiplication, as opposed to just using NumPy for speed. This
    was demonstrated when we manipulated multiple mathematical equations with a few
    lines of NumPy code and matrix logic.
  prefs: []
  type: TYPE_NORMAL
- en: We then used matrix NumPy multiplication functions in our Rust code to recreate
    our mathematical model using a flexible functional programming approach. We finished
    this off by making our interface in a Python class. We also must remember that
    the NumPy implementation was faster than our Rust code. This is partly down to
    poor implementation on our part and the C optimization in NumPy. This has shown
    us that while Rust is a lot faster than Python, solving problems with Python packages
    such as NumPy might still be faster until equivalent crates are coded in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: We used a generic approach to using Python modules in Rust. Because of this,
    we can theoretically use any Python module that we want. This means that if the
    Python module that you are rewriting relies on the functionality of third-party
    Python modules such as NumPy, we are now able to create Rust functions that use
    them. Considering this, there is no generic technical hurdle stopping you from
    rewriting Python code in Rust and slotting it into your Python system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will put everything that we have learned so far together
    to build a new Python package written in Rust from start to end.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the steps we must follow to run a Python module in Rust?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you import a Python module into your Rust code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we wanted to use our Python code result inside Rust, how would we do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you compare speed graphs of Python/NumPy with Rust, the Python/NumPy code
    has a lot of spikes. What could be causing this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you think our NumPy implementation in Rust will be slower or faster than
    calling NumPy from Python, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We initially must get Python from the GIL. We then must build a `PyDict` struct
    in order to store and pass Python variables between Python executions. We then
    define the Python code as a string literal and pass this into our `py.eval` function
    with our `PyDict` storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must make sure that we get Python from the GIL. We then use this to run the
    `py.eval` function with the import line of code passed in as a string literal.
    We must remember to pass in our `PyDict` storage to ensure that we can reference
    the module in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must remember that Python code returns a `PyAny` struct, which we can extract
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because the Python versions must keep stopping to clean up variables
    with the garbage collection mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It would be slightly slower. This is because we are essentially still running
    Python code but through an extra layer which is Rust.Considering this, we should
    be using Python code out of convenience as opposed to optimization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy documentation for Rust (2021): *Crate numpy:* [https://docs.rs/numpy/0.14.1/numpy/](https://docs.rs/numpy/0.14.1/numpy/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Giuseppe Ciaburro (2020): *Hands-on Simulation Modeling with Python: Develop
    simulation models to get accurate results and enhance decision-making processes*.
    Packt Publishing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
