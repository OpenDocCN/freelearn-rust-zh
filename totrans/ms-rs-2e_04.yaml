- en: Types, Generics, and Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's type system is one of the striking features of the language. In this
    chapter, we'll go into detail on some of the notable aspects of the language such
    as traits, generics, and how to use them to write expressive code. We'll also
    explore some of the standard library traits that help with writing idiomatic Rust
    libraries. Expect lots of interesting material in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Type systems and why they matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augmenting types using traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring standard library traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing traits and generics for writing expressive code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type systems and why they matter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Be conservative in what you send, be liberal in what you accept."         
                                                                                 
                                                                                 
                                                                                 
                                                         - John Postel'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need types in a language? That's a good question to ask as a motivation
    to understand type systems in programming languages. As programmers, we know that
    programs written for computers are represented in binary as combinations of 0s
    and 1s at the lowest level. In fact, the earliest computers had to be programmed
    manually in machine code. Eventually, programmers realized that this is very error-prone,
    tedious, and time-consuming. It's not practical for a human to manipulate and
    reason about these entities at the binary level. Later, during the 1950s, the
    programming community came up with machine code mnemonics, which turned into the
    assembly language we know of today. Following that, programming languages came
    into existence, which compiled down to assembly code and allowed programmers to
    write code that is human readable yet easy for computers to compile down to machine
    code. However, the languages that we humans speak can be quite ambiguous, so a
    set of rules and constraints needed to be put in place to convey what is possible
    and what is not in a computer program written in a human-like language, that is,
    the semantics. This brings us to the idea of types and type systems.
  prefs: []
  type: TYPE_NORMAL
- en: A type is a named set of possible values. For example, `u8` is a type that can
    contain only positive values from 0 to 255\. Types provide us with a way to bridge
    the gap between the lower-level representation and the mental model we create
    of these entities. Apart from this, types also provide us with a way to express
    intent, behavior, and constraints for an entity. They define what we can and cannot
    do with types. For example, it is undefined to add a value of a type string to
    a value of a type number. From types, language designers built type systems, which
    are sets of rules that govern how different types interact with one another in
    a programming language. They act as a tool for reasoning about programs and help
    ensure that our programs behave correctly and according to the specification.
    Type systems are qualified based on their expressiveness, which simply means the
    extent to which you can express your logic, as well as invariants in the program
    using only the type system. For example, Haskell, a high-level language, has a
    very expressive type system, while C, a low-level language, provides us with very
    few type-based abstractions. Rust tries to draw a fine line between these two
    extremes.
  prefs: []
  type: TYPE_NORMAL
- en: Rust's type system is inspired quite a bit by functional languages such as Ocaml
    and Haskell with their ADTs such as enums and structs, traits (akin to haskell
    typeclasses), and error handling types (`Option` and `Result`). The type system
    is characterized as a strong type system, which simply means that it performs
    more type checks at compile time rather than throwing them at runtime. Furthermore,
    the type system is static, which means that variables that are, for example, bound
    to an integer value, cannot be changed to point to a string later. These features
    enable robust programs that rarely break the invariants at runtime, with the cost
    that writing programs requires a bit of planning and thinking from the programmer.
    Rust tries to put more planning on your plate when designing programs, which can
    put off some programmers looking to prototype things fast. However, it is a good
    thing from the long-term perspective of maintaining software systems.
  prefs: []
  type: TYPE_NORMAL
- en: With that aside, let's start by exploring how Rust's type system enables code
    reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the dawn of high-level programming languages, the pursuit of better abstraction
    is something that language designers have always strived for. As such, many ideas
    concerning code reuse emerged. The very first of them was functions. Functions
    allow you to chunk away a sequence of instructions within a named entity that
    can be called later many times, optionally accepting any arguments for each invocation.
    They reduce code complexity and amplify readability. However, functions can only
    get you so far. If you have a function, say `avg`, that calculates the average
    of a given list of integer values and later you have a use case where you need
    to calculate the average for a list of float values too, then the usual solution
    is to create a new function that can average float values from the list of floats.
    What if you wanted to accept a list of double values too? We probably need to
    write another function again. Writing the same function over and over again that
    differs only by its arguments is a waste of precious time for programmers. To
    reduce this repetition, language designers wanted a way to express code so that
    the `avg` function can be written in a way that accepts multiple types, a generic
    function, and thus the idea of generic programming, or generics, was born. Having
    functions that can take more than one type is one of the features of generic programming,
    and there are other places that generics can be used. We'll explore all of them
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Generic programming is a technique that is only applicable in the case of statically
    typed programming languages. They first appeared in ML, a statically typed functional
    language. Dynamic languages such as Python use duck typing, where APIs treat arguments
    based on what they can do rather than what they are, so they don't rely on generics.
    Generics are part of the language design feature that enables code reuse and the
    **Don't repeat yourself **(**DRY**) principle. Using this technique, you can write
    algorithms, functions, methods, and types with placeholders for types, and specify
    a type variable (with a single letter, which is usually `T`, `K`, or `V` by convention)
    on these types, telling the compiler to fill in the actual types later when any
    code instantiates them. These types are referred to as generic types or items.
    The single letter symbols such as `T` on type are called **generic type** **parameters**.
    They are substituted with concrete types such as  `u32` when you use or instantiate
    any generic item.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: By substitution, we mean that every time a generic item is used with
    a concrete type, a specialized copy of that code is generated at compile time
    with the type variable `T`, getting replaced with the concrete type. This process
    of generating specialized functions with concrete types at compile time is called
    **monomorphization**, which is the procedure of doing the opposite of polymorphic
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the existing generic types from the Rust standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vec<T>` type from the standard library is a generic type that is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the type signature of `Vec` contains a type parameter `T` after
    its name, surrounded by a pair of angle brackets `< >`. Its member field, `buf`,
    is a generic type as well, and so the `Vec` itself has to be generic. If we don''t
    have `T` on our generic type `Vec<T>`, even though we have a `T` on its `buf`
    field, we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `T` needs to be part of the type definition for `Vec`. So, when we denote
    a `Vec`, we always refer to it by using `Vec<T>` when denoting generically or
    by using `Vec<u64>` when we know the concrete type. Next, let's look at how to
    create our own generic types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows us to declare many things as generics such as structs, enums, functions,
    traits, methods, and implementation blocks. One thing that they have in common
    is that the generic type parameters are separated by and enclosed within a pair
    of `< >` brackets. Within them, you can put any number of comma-separated generic
    type parameters. Let's go through how you might create generics, starting by looking
    at generic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a generic function, we place the generic type parameter immediately
    after the function name and before the parenthesis, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `give_me` is a generic function with `<T>` after its
    name, and the `value` parameter is of type `T`. In `main`, we can call this function
    with any argument. During compilation, our compiled object file will contain two
    specialized copies of this function. We can confirm this in our generated binary
    object file by using the `nm` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3876463a-6779-4ef4-9d8e-20433f15aa1e.png)'
  prefs: []
  type: TYPE_IMG
- en: '`nm` is a utility from the GNU binutils package for viewing symbols from compiled
    object files. By passing `nm` our binary, we pipe and grep for the prefix of our
    `give_me` function. As you can see, we have two copies of the function with random
    IDs appended to them to distinguish them. One of them takes a `&str` and the other
    a `i32`, because of two invocations with different arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions are a cheap way to give the illusion of polymorphic code.
    I say illusion because after compilation, it is all duplicated code with concrete
    types as parameters. They come with a downside though, which is an increase in
    the size of the compiled object file due to code duplication. This is proportional
    to the number of concrete types that are used. In later sections, when we get
    to traits, we'll see the true form of polymorphism, trait objects. Still, polymorphism
    through generics is preferred in most cases because it has no runtime overhead,
    as is the case with trait objects. Trait objects should only be used when generics
    don't cater to the solution and cases where you need to store a bunch of types
    together in a collection. We'll see those examples when we get to trait objects.
    Next, we'll look at how we can make our structs and enums generic. We'll only
    explore how to declare them first. Creating and using these types are covered
    in the later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generic structs**: We can declare tuple structs and normal structs generically
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Generic structs contain the generic type parameter after the name of the struct,
    as shown in the preceding code. With this, whenever we denote this struct anywhere
    in our code, we also need to type the `<T>` part together with the type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic enums**: Similarly, we can create generic enums as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `Transmission` enum has a variant called `Signal`, which holds a generic
    value, and a variant called `NoSignal`, which is a no value variant.
  prefs: []
  type: TYPE_NORMAL
- en: Generic implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also write `impl` blocks for our generic types too, but it gets verbose
    here because of the extra generic type parameters, as we''ll see. Let''s implement
    a `new()` method on our `Container<T>` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/030da4c0-1c15-493c-82f0-fa4967b03e75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The error message cannot find our generic type `T`. When writing an `impl`
    block for any generic type, we need to declare the generic type parameter before
    using it within our type. `T` is just like a variable—a type variable—and we need
    to declare it. Therefore, we need to modify the implementation block a bit by
    adding `<T>` after `impl`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With that change, the preceding code compiles. The previous `impl` block  basically
    means that we are implementing these methods for all types `T`, which appear in
    `Container<T>`. This `impl` block is a generic implementation. Therefore, every
    concrete `Container` that ever gets generated will have these methods. Now, we
    could have also written a more specific `impl` block for `Container<T>` by putting
    any concrete type in place of `T`. This is what it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implemented a method called `sum`, which is only present
    on `Container<u32>` types. Here, we don't need the `<T>` after `impl` because
    of the presence of `u32` as a concrete type. This is another nice property of
    `impl` blocks, which allows you to specialize generic types by implementing methods
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Using generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the way we instantiate or use generic types is also a bit different than
    their non-generic counterparts. Any time we instantiate them, the compiler needs
    to know the concrete type in place of `T` in their type, signature, which gives
    it the type information to monomorphize the generic code. Most of the time, the
    concrete type is inferred based on the instantiation of the type or by calling
    any method that takes a concrete type in the case of generic functions. In rare
    cases, we need to help the compiler by specifically typing out the concrete type
    in place of the generic type by using the turbofish (`::<>`) operator. We'll see
    how that is used in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the case of instantiating `Vec<T>`, a generic type. Without
    any type signature, the following code does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the preceding code, gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/156ddf29-ad47-42a3-af39-d8a5a315707a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is because the compiler doesn''t know what type `a` would contain until
    we specify it manually or call one of its methods, thereby passing in a concrete
    value. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the second code snippet, we specified the type of `v1` to be a `Vec` of `u8`,
    and it compiles fine. Another way, as with `v2`, is to call a method that accepts
    any concrete type. After the `push` method call, the compiler can infer that `v2`
    is a `Vec<i32>`. The other way to create the `Vec` is to use the `turbofish` operator,
    as is the case with `v3` binding in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `turbofish` operator in generic functions appears right after the function
    name and before the parenthesis. Another example of this is the generic `parse`
    function from the `std::str` module. `parse` can parse values from a string, and
    many types are able to parse from it, such as `i32`, `f64`, `usize`, and so on,
    so it''s a generic type. So, when using `parse`, you really need to use the `turbofish`
    operator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Something to take note of is that only types that implement the `FromStr` interface
    or trait can be passed to the `parse` function. `u8` has an implementation of
    `FromStr`, and so we were able to parse it in the preceding code. The `parse`
    function uses the `FromStr` trait to limit types that can be passed to it. We'll
    get to know how we can mix generics and traits after we're done exploring traits.
  prefs: []
  type: TYPE_NORMAL
- en: With the idea of generics under our belt, let's focus on one of the most ubiquitous
    features in Rust, traits!
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting behavior with traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a polymorphism and code reuse perspective, it is often a good idea to separate
    shared behavior and common properties of types from themselves in code and only
    have methods that are unique to themselves. In doing so, we allow different types
    to relate to each other with these common properties, which allows us to program
    for APIs that are more general or inclusive in terms of their parameters. This
    means that we can accept types that have those shared properties while not being
    restricted to one particular type.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented languages such as Java or C#, interfaces convey the same
    idea, where we can define shared behavior that many types can implement. For example,
    instead of having multiple `sort` functions, which take in a list of integer values,
    and other functions that take in a list of string values, we can have a single
    `sort` function that can take a list of items that implement the `Comparable`
    or `Comparator` interface. This allows us to pass anything that is `Comparable` to
    our `sort` function.
  prefs: []
  type: TYPE_NORMAL
- en: Rust also has a similar yet powerful construct known as **traits**. There are
    many forms of traits in Rust, and we'll look at most of them and the ways we can
    interact with them briefly. Also, when traits are mixed with generics, we can
    restrict the range of parameters that we can pass to our APIs. We'll see how that
    happens when we learn more about trait bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A trait is an item that defines a set of contracts or shared behavior that types
    can opt to implement. Traits are not usable by themselves and are meant to be
    implemented by types. Traits have the power to establish relationships between
    distinct types. They are the backbone to many language features such as closures,
    operators, smart pointers, loops, compile-time data race checks, and much more.
    Quite a few of the high-level language features in Rust boil down to some type
    calling a trait method that it implements. With that said, let's look at how we
    can define and use a trait in Rust!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we are modeling a simple media player application that can play
    audio and video files. For this demo, we''ll create a project by running `cargo
    new super_player`. To convey the idea of traits and to make this simple, in our
    `main.rs` file, we have represented our audio and video media as tuple structs
    with the name of the media as a `String`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the very minimum, both the `Audio` and `Video` structs need to have
    a `play` and `pause` method. It''s a functionality that''s shared by both of them.
    It''s a good opportunity for us to use a trait here. Here, we''ll define a trait
    called `Playable` with two methods in a separate module called `media.rs`, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We use the `trait` keyword to create a trait, followed by its name and a pair
    of braces. Within the braces, we can provide zero or more methods that any type
    implementing the trait should fulfill. We can also define constants within traits,
    which all of the implementers can share. The implementer can be any struct, enum,
    primitive, function, closure, or even a trait.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the signature of `play`; it takes a reference to a symbol,
    `self`, but does not have a body, and ends with a semicolon.  `self` is just a
    type alias to `Self`, which refers to the type on which the trait is being implemented.
    We'll cover these in detail in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),  *Advanced
    Concepts*. This means that the methods within the traits are like an abstract
    method from Java. It is up to the types to implement this trait and define the
    function according to their use case. However, methods declared within a trait
    can also have default implementations, as is the case with the `pause` function
    in the preceding code. `pause` does not take `self`, and so it's akin to a static
    method that does not require an instance of the implementer to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have two kinds of methods within a trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associated methods**: These are methods that are available directly on the
    type implementing the trait and do not need an instance of the type to invoke
    them. There are also known as static methods in mainstream languages, for example,
    the `from_str` method from the `FromStr` trait in the standard library. It is
    implemented for a `String` and thus allows you to create a `String` from a `&str`
    by calling `String::from_str("foo")`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance methods**: These are methods that have their first parameter as `self`.
    These are only available on instances of the type that are implementing the trait.  `self`
    points to the instance of the type implementing the trait. It can be of three
    types: `self`  methods, which consume the instance when called; `&self` methods,
    which only have read access to the instance its members (if any); and `&mut self` methods,
    which have mutable access to its members and can modify them or even replace them
    with another instance. For example, the `as_ref` method from the `AsRef` trait
    in the standard library is an instance method that takes `&self`, and is meant
    to be implemented by types that can be converted to a reference or a pointer.
    We''ll cover references and the `&` and `&mut` parts of the type signature in
    these methods when we get to [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we''ll implement the preceding `Playable` trait on our `Audio`  and `Video`
    types, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We write trait implementations with the `impl` keyword followed by the trait
    name, followed by the `for` keyword and the type we want to implement the trait
    for, followed by a pair of braces. Within these braces, we are required to provide
    the implementations of methods, and optionally override any default implementation
    that exists in the trait. Let''s compile this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfa66081-2815-459f-94f9-16b38038c29f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding error highlights an important feature of traits: traits are private
    by default. To be usable by other modules or across crates, they need to be made
    public. There are two steps to this. First, we need to expose our trait to the
    outside world. To do that, we need to prepend our `Playable` trait declaration
    with the `pub` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have exposed our trait, we need to use the `use` keyword to bring
    the trait into scope in the module we want to use the trait in. This will allow
    us to call its methods, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we can play our audio and video media:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e9db8c6-9ad4-4880-b753-13f114e2fe5e.png)'
  prefs: []
  type: TYPE_IMG
- en: This is very far from any actual media player implementation, but our aim was
    to explore the use case for traits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traits can also specify in their declaration that they depend on other traits;
    this is a feature known as trait inheritance. We can declare inherited traits
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declared two traits: a `Vehicle` (a more general)
    trait and a `Car` (more specific) trait, which depends on `Vehicle`. Since `TeslaRoadster`
    is a car, we implemented the `Car` trait for it. Also, notice the body of the
    method `new` on `TeslaRoadster`, which uses `Self` as the return type. This is
    also substituted for the `TeslaRoadster` instance that we return from `new`. `Self`
    is just a convenient type alias for the implementing type within the trait''s
    impl blocks. It can also be used to create other types, such as tuple structs
    and enums, and also in match expressions. Let''s try compiling this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f86789bc-8698-45a2-a43d-017c212d109e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'See that error? In its definition, the `Car` trait specifies the constraint
    that any type that implements the trait must also implement the `Vehicle` trait, `Car:
    Vehicle`. We did not implement `Vehicle` for our `TeslaRoadster`, and Rust caught
    and reported it for us. Therefore, we must implement the `Vehicle` trait like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With that implementation satisfied, our program compiles fine with the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The underscore in `200_200` in the `get_price` method is a handy syntax to create
    readable numeric literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an analogy to object-oriented languages, traits and their implementations
    are similar to interfaces and classes that implement those interfaces. However,
    it is to be noted that traits are very different from interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: Even though traits have a form of inheritance in Rust, implementations do not.
    This means that a trait called `Panda` can be declared, which requires another
    trait called `KungFu` to be implemented by types that implement `Panda`. However,
    the types themselves don't have any sort of inheritance. Therefore, instead of
    object inheritance, type composition is used, which relies on trait inheritance
    to model any real-world entity in code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can write trait implementation blocks anywhere, without having access to
    the actual type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also implement your own traits on any type ranging from built-in primitive
    types to generic types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot implicitly have return types as traits in a function like you can
    return an *interface* as a return type in Java. You have to return something called
    a trait object, and the syntax to do that is explicit. We'll see how to do that
    when we get to trait objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The many forms of traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we had a glimpse of the simplest form of trait. But
    there's more to traits than meets the eye. As you start interacting with traits
    in bigger code bases, you will encounter different forms of them. Depending on
    the complexity of the program and the problem to be solved, the simple form of
    traits might not be suitable. Rust provides us with other forms of traits that
    model the problem well. We'll take a look at some of the standard library traits
    and try to classify them so that we have a good idea when to use what.
  prefs: []
  type: TYPE_NORMAL
- en: Marker traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traits defined in the `std::marker` module are called **marker traits**. These
    traits don't have any method, and simply have their declaration with their name
    with an empty body. Examples from the standard library include `Copy`, `Send`,
    and `Sync`. They are called marker traits because they are used to simply mark
    a type as belonging to a particular family for to gain some compile time guarantees.
    Two such examples from the standard library are the `Send` and `Sync` traits that
    are auto-implemented by the language for most types whenever appropriate, and
    convey which values are safe to send and share across threads. We'll get to know
    more about them in [Chapter 8](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml), *Concurrency*.
  prefs: []
  type: TYPE_NORMAL
- en: Simple traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the simplest form a trait definition could possibly be. We already
    discussed this as an introduction to traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An example from the standard library would be the `Default` trait, which is
    implemented for types that can be initialized with a default value. It is documented
    at [https://doc.rust-lang.org/std/default/trait.Default.html](https://doc.rust-lang.org/std/default/trait.Default.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generic traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traits can also be generic. This is useful in scenarios where you want to implement
    a trait for a wide variety of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Two such examples are is the `From<T>` and `Into<T>` traits, which allow from conversion
    from a type to a type `T` and vice versa. Their use becomes prominent when these
    traits are used as trait bounds in function parameters. We'll see what trait bounds
    are and how they work in a moment. However, generic traits can get quite verbose
    when they are declared with three or four generic types. For those cases, we have
    associated type traits.
  prefs: []
  type: TYPE_NORMAL
- en: Associated type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These are a better alternative to generic traits due to their ability to declare
    associated types within the trait, like the `Out` type in the declaration of `Foo` in
    the preceding code. They have a less verbose type signature. The advantage of
    them is that, in the implementation, they allow us to declare the associated type
    once and use `Self::Out` as the return type or parameter type in any of the trait
    methods or functions. This removes the redundant specification of types, as is
    the case with generic traits. One of the finest examples of associated type traits
    is the `Iterator` trait, which is used for iterating over the values of a custom
    type. Its documentation can be found at [https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html).
    We'll dig deeper into iterators when we get to [Chapter 8](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),  *Advanced
    Topics*.
  prefs: []
  type: TYPE_NORMAL
- en: Inherited traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw these traits in our `trait_inheritance.rs` code example. Unlike
    types in Rust, traits can have an inheritance relationship, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet , we declared a trait, `Foo`, that depends on a super
    trait, `Bar`. The definition of `Foo` mandates implementing `Bar` whenever you
    are implementing `Foo` for your type. One such example from the standard library
    is the `Copy` trait, which requires  the type to also implement the `Clone` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Using traits with generics – trait bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a decent idea about generics and traits, we can explore ways
    in which we can combine them to express more about our interfaces at compile time.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have a generic function, `load`, on our `Game` type
    that can take any game entity and load it in our game world by calling `init()`
    on all kinds of `T`. However, this example fails to compile with the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9c1cf25-669f-4489-9bb2-f5592e705788.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, a generic function taking any type `T` cannot know or assume by default 
    the `init` method exists on `T`. If it did, it wouldn''t be generic at all, and
    would only be able to accept types that have the `init()` method on them. So,
    there is a way that we can let the compiler know of this and constrain the set
    of types that `load` can accept using traits. This is where trait bounds come
    into the picture. We can define a trait called `Loadable` and implement it on
    our our `Enemy` and `Hero` types. Following that, we have to put a couple of symbols
    beside our generic type declaration to specify the trait. We call this a trait
    bound. The changes to the code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this new code, we implement Loadable for both `Enemy` and `Hero` and we
    also modified the load method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `: Loadable` part. This is how we specify a trait bound. Trait bounds
    allow us to constrain the range of parameters that a generic API can accept. Specifying
    a trait bound on a generic item is similar to how we specify types for variables,
    but here the variable is the generic type `T` and the type is some trait, such
    as `T: SomeTrait`. Trait bounds are almost always needed when defining generic
    functions. If one defines a generic function that takes `T` without any trait
    bounds, we cannot call any of the methods since Rust does not know what implementation
    to use for the given method. It needs to know whether `T` has the `foo` method
    or not to monomorphize the code. Take a look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a method,  `add_thing`, that can add any type `T`. If we compile the
    preceding snippet, it does not compile and gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/677a9ad2-011e-4d14-a6ff-adf0b2af2dc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It says to add a trait bound `Add` on `T`. The reason for this is that the
    addition operation is dictated by the `Add` trait, which is generic, and different
    types have different implementations that might even return a different type altogether.
    This means that Rust needs our help to annotate that for us. Here, we need to
    modify our function definition like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the `: Add` after `T` and with that change, our code compiles. Now,
    there are two ways to specify trait, bounds depending on how complex the type
    signature gets when defining generic items with trait bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-between generics**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is the most common syntax to specify trait bounds on generic items. We
    read the preceding function as follows `show_me` is a method that takes any type
    that implements the `Display` trait. This is the usual syntax used to declare
    the trait bound when the length of the type signature of the generic function
    is small. This syntax also works when specifying trait bounds on types. Now, let's
    look at the second way to specify trait bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using where clauses:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax is used when the type signature of any generic item becomes too
    large to fit on a line. For example, there is a `parse` method in the standard
    library''s `std::str` module, which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `where F: FromStr` part. This tells us that our `F` type must implement
    the `FromStr` trait. The `where` clause decouples the trait bound from the function
    signature and makes it readable.'
  prefs: []
  type: TYPE_NORMAL
- en: Having seen how to write trait bounds, it's important to know where can we specify
    these bounds. Trait bounds are applicable in all of the places where you can use
    generics.
  prefs: []
  type: TYPE_NORMAL
- en: Trait bounds on types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can specify trait bounds on types too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: However, trait bounds on types are discouraged as it places restrictions on
    types themselves. Generally, we want types to be as generic as possible, allowing
    us to create instances using any type, and instead place restrictions on their
    behavior using traits bounds in functions or methods.
  prefs: []
  type: TYPE_NORMAL
- en: Trait bounds on generic functions and impl blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the most common place where trait bounds are used. We can specify trait
    bounds on functions and also on generic implementations, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have a generic type `Food` and a specific food type `Apple` that we put into
    a `Food` instance and bind to variable `apple`. Next, we call the generic method
    `eat`, passing `apple`. Looking at the signature of `eat`, the type `T` has to
    be `Eatable`. To make `apple` eatable, we implement the `Eatable` trait for `Food`,
    also specifying that our type has to be `Debug` to make it printable to the console
    inside our method. This is a dumb example but demonstrates the idea.
  prefs: []
  type: TYPE_NORMAL
- en: Using + to compose traits as bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also specify multiple trait bounds to a generic type using the `+` symbol.
    Let''s take a look at the impl block for the `HashMap` type from the standard
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that `K`, denoting the type of the `HashMap` key, has to implement
    the `Eq` trait, as well as the `Hash` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also combine traits to create a new trait, that represents all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a new trait `Programmer`, that is a composition
    of three traits, `Eat` `Code` and `Sleep`. In this way, we have put constraints
    on the type, so that if a type `T` implements `Programmer`, it has to implement
    all the other traits. Running the code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Trait bounds with impl trait syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other syntax for declaring trait bounds is the impl trait syntax, which
    is a recent addition to the compiler. Using this syntax, you can also write a
    generic function with trait bounds like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of specifying `T: Display`, we directly use `impl Display`. This is
    the impl trait syntax. This provides advantages in cases where we want to return
    a complex or unrepresentable type, such as a closure from a function. Without
    this syntax, you had to return it by putting it behind a pointer using the `Box`
    smart pointer type, which involves heap allocation. Closures under the hood are
    implemented as structs that implement a family of traits. One of these traits
    is the `Fn(T) -> U` trait. So, using the impl trait syntax, it''s now possible
    to write functions where we can write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a function, `lazy_adder`, that takes in two
    numbers and returns a closure that adds two numbers. We then call `lazy_adder`,
    passing in two numbers. This creates a closure in `add_later` but does not evaluate
    it. In `main`, we called `add_later` in the `println!` macro. We can even have
    this syntax in both places, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`surround_with_braces` takes in anything that is `Display` and returns a string
    surrounded with `{}`. Here, both our return types are `impl Display`.'
  prefs: []
  type: TYPE_NORMAL
- en: The extra braces are there to escape the brace itself, as `{}` has a special
    meaning in string formatting for string interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: The impl trait syntax for trait bounds is mostly recommended to be used as return
    types from functions. Using it in parameter position means that we can't use the
    turbofish operator. This can cause API incompatibility if some dependent code
    uses the turbofish operator to invoke one of your crate's methods. It should only
    be used when we don't have a concrete type available to us, as is the case with
    closures.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring standard library traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's standard library has a lot of built-in traits. Most of the syntatic sugar
    in Rust is due to traits. These traits also provide a nice baseline upon which
    crate authors can provide an idiomatic interface to their libraries. In this section,
    we'll explore some of the abstractions and conveniences of the standard library
    traits that enhance the experience for a crate author and the consumer. We'll
    base our exploration from a library author's perspective and create a library
    that provides support for complex number types. This example serves well to introduce
    the common traits you have to implement if you are creating a crate of your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a new project by running `cargo new complex --lib`. To start
    with, we need to represent our complex number as a type. We''ll use a struct for
    this. Our complex number struct has two fields: the *real* and *imaginary* part
    of a complex number. Here''s how we have defined it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We're making it generic over `T`, as `re` and `im` can both be a float or an
    integer value. For this type to be of any use, we want ways to create instances
    of it. The usual way to do this is to implement the associated method `new`, where
    we pass the values for `re` and `im`. What if we also wanted to initialize a complex
    value with defaults (say `re = 0`, `im = 0`) ? For this, we have a trait called
    `Default`. Implementing `Default` is very simple for a user-defined type; we can
    just put a `#[derive(Default)]` attribute over the `Complex` structure to automatically
    implement the `Default` trait for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: `Default` can only be implemented for structs, enums, or unions whose
    members and fields themselves implement `Default`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our updated code with the method `new` and the `Default` annotation looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We also added a simple initialization test case at the bottom under the `tests`
    module. The `#[derive(Default)]` attribute functionality is implemented as a procedural
    macro that can automatically implement traits for the type on which it appear.
    This auto-deriving requires that the fields of any custom type, such as a struct
    or an enum, also implement the `Default` trait themselves. Deriving a trait using
    them is only applicable to structs, enums, and unions. We'll look at how to write
    our own deriving procedural macros in Chapter 9, *Metaprogramming with Macros*.
    Also, the function `new` is not really a special constructor function (if you
    are familiar with languages with constructors), but just a conventional name adopted
    by the community as a method name to create new instances of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we get into more complex trait implementations, we need to auto-derive
    some more built-in traits that will help us implement more high-level functionality.
    Let''s look at some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Debug`: We have already seen this before. As the name suggests, this trait
    helps types to be printed on the console for debugging purposes. In the case of
    a composite type, the types will be printed in a JSON-like format with braces
    and parentheses, and quotes if the type is a string. This is implemented for most
    built-in types in Rust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PartialEq` and `Eq`: These traits allow two items to be compared to each other
    for equality. For our complex type, only `PartialEq` makes sense, because when
    our complex type contains `f32` or `f64` values, we cannot compare them since `Eq`
    is not implemented for `f32` and `f64` values. `PartialEq` defines partial ordering.
    whereas `Eq` requires a total ordering, Total ordering is undefined for floats,
    as `NaN` is not equal to `NaN`.  `NaN` is a type in floating point types that
    represents an operation whose result is undefined, such as `0.0 / 0.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Copy` and `Clone`: These traits define how types get duplicated. We have a
    separate section for them in [Chapter 6](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety*. In brief, when auto-derived on any custom type,
    these traits allow you to create a new copy from the instance, either implicitly
    when `Copy` is implemented or explicitly by calling `clone()` on them when `Clone`
    is implemented. Please note that the `Copy` trait depends on `Clone` being implemented
    on types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With those explanations out of the way, we''ll add auto-derives for these built-in
    traits, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s enhance our `Complex<T>` type more so that we have better ergonomics
    in terms of its use. Some additional traits we''ll implement (in no particular
    order) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Add` trait from the `std::ops` module ,which will let us use the `+` operator
    to add `Complex` types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Into` and `From` traits from the `std::convert` module ,which will give
    us the ability to create `Complex` types from other types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Display` trait, will let us print a human readable version of our `Complex`
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the implementation of the `Add` trait. It is documented at
    [https://doc.rust-lang.org/std/ops/trait.Add.html](https://doc.rust-lang.org/std/ops/trait.Add.html),
    and the trait is declared like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pub trait Add<RHS = Self>` says that `Add` is a trait that has a generic type, `RHS`,
    that is set to `Self` by default. Here, `Self` is an alias for the type that implements
    this trait, which is `Complex` in our case. It''s a convenient way to refer to
    the implementer within the trait.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Output` is an associated type that the implementer needs to declare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn add(self, rhs: RHS) -> Self::Output` is the core functionality that''s
    provided by the `Add` trait and is the method that gets invoked whenever we use
    `+` operator between two implementing types. It''s an instance method, takes `self`
    by value and takes in an `rhs` as a parameter, which is `RHS` in the trait definition.
    In our case, the left-hand side and the right-hand side around the `+` operator
    are of the same type by default, but `RHS` can be changed to any other type when
    we are writing impl blocks. For example, we can have an implementation that adds
    the `Meter` and `Centimeter` types. In that case, we''ll write `RHS=Centimeter`
    in our impl block. Finally, it says that the `add` method must return the `Output`
    type that we declared on the second line with the `Self::Output` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OK, let''s try implementing this. Here''s the code, along with the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dig into the `impl` block for `Complex<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The impl block for `Add` seems more complex. Let''s go through this piece by
    piece:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `impl<T: Add<T, Output=T>` part says that we are implementing `Add` for
    a generic type `T`, where `T` implements `Add<T, Output=T>`. The `<T, Output=T>`
    part says that the implementation of the `Add` trait must have the same input
    and output types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add for Complex<T>` says that we are implementing the `Add` trait for the `Complex<T>` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T: Add` has to implement the `Add` trait. If it doesn''t, we can''t use the
    `+` operator on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then comes the `From` trait. It would be convenient if we could also construct
    `Complex` types from a built-in primitive type such as a two-element tuple, where
    the first element is the real part and the second is the imaginary part. We can
    do this by implementing the `From` trait. This trait defines a `from` method,
    giving us a general way to do conversions between types. Its documentation can
    be found at [https://doc.rust-lang.org/std/convert/trait.From.html](https://doc.rust-lang.org/std/convert/trait.From.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the trait definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit simpler than the previous one. It''s a generic trait, where `T`
    specifies what type to convert from. When we implement this, we just need to substitute
    the `T` with the type we want to implement it for and implement the `from` method.
    Then, we can use the method on our type. Here''s an implementation that converts
    our `Complex` value into a two-element tuple type, which is natively known to
    Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the `impl` line for this one. This is similar to the `Add` trait,
    except that we don''t have to constrain our generic by any special output type,
    since `From` does not have that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first `<T>` is a declaration of the generic type `T`, and the second and
    third are the uses of it. We are creating it from a `(T, T)` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to be able to let the users view the complex type as in mathematical
    notation, we should implement the `Display` trait. It''s documented at [https://doc.rust-lang.org/std/fmt/trait.Display.html](https://doc.rust-lang.org/std/fmt/trait.Display.html),
    and here''s the trait''s type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the implementation of `Display` for the `Complex<T>`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `Display` trait has an `fmt` method, which takes in a `Formatter` type that
    we write into using the `write!` macro. Like before, because our `Complex<T>`
    type uses a generic type for both the `re` and `im` fields, we need to specify
    that it also must satisfy the `Display` trait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `cargo test -- --nocapture`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/931da4d9-fcd8-4c68-aaaf-2f87d58dfb61.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our complex type is printed in a readable format as `2345 +
    456i` and that all of our tests are green. Next, let's look at the idea of polymorphism
    and how Rust traits model this.
  prefs: []
  type: TYPE_NORMAL
- en: True polymorphism using trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows a true form of polymorphism through special forms of types implementing
    a trait. These are known as *trait objects*. Before we explain how Rust achieves
    polymorphism using trait objects, we need to understand the idea of **dispatch**.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dispatch is a concept that emerged from the object-oriented programming paradigm,
    mainly in the context of one of its features called polymorphism. In the context
    of OOP, when APIs are generic or take parameters implementing an interface, it
    here has to figure out what method implementation to invoke on an instance of
    a type that''s passed to the API. This process of method resolution in a polymorphic
    context is called **dispatch**, and invoking the method is called dispatching.
    In mainstream languages that support polymorphism, the dispatch may happen in
    either of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static dispatch:** When the method to invoke is decided at compile time,
    it is known as static dispatch or early binding. The method''s signature is used
    to decide the method to call, and all of this is decided at compile time. In Rust,
    generics exhibit this form of dispatch because even though the generic function
    can accept many arguments, a specialized copy of the function is generated at
    compile time with that concrete type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic dispatch:** In object-oriented languages, there are times when the
    method call can''t be decided until runtime. This is because the concrete type
    is hidden and only interface methods are available to call on the type. In Java,
    this is the case when a function has an argument, which is known as an **interface**.
    Such a scenario can only be handled by dynamic dispatch. In dynamic dispatch,
    the method is determined dynamically by navigating through the list of implementations
    of the interface from the `vtable` and invoking the method. The `vtable` is a
    list of function pointers that point to each type''s implemented method. This
    has a bit of overhead because of the extra pointer indirection in method invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore trait objects next.
  prefs: []
  type: TYPE_NORMAL
- en: Trait objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, up until this point, we have mostly seen traits being used in a static
    dispatch context, where we specified trait bounds in generic APIs. However, we
    also have another way to create polymorphic APIs, where we can specify parameters
    as something that implements a trait rather than a generic or a concrete type.
    This form of type, specified as implementing a trait API, is known as a trait
    object. Trait objects are similar to C++ virtual methods. A trait object is implemented
    as a fat pointer and is an unsized type, which means that they can only be used
    behind references (`&`). We explain unsized types in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. A trait object fat pointer has the first pointer pointing points
    to the actual data associated with the object while the second pointer to a virtual
    table (vtable), which is a structure holding one function pointer per method for
    the object, at a fixed offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trait objects are Rust''s way of performing dynamic dispatch where we don''t
    have the actual concrete type information. Method resolution is done by hopping
    down to the vtable and invoking the appropriate method. One of the use cases for
    trait objects is that they allow you to operate on a collection that can have
    multiple types, but with an extra pointer indirection at runtime. To illustrate
    this, consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the elements of shapes are of type `&dyn Area`, a type that
    is represented as a trait. The trait object is represented by `dyn Area`, denoting
    that it's a pointer to some implementation of the `Area` trait. A type in the
    form of a trait object allows you to store different types within a collection
    type such as `Vec`. In the preceding example, `Square` and `Rectangle` were converted
    into trait objects implicitly because we pushed a reference to them. We can also
    make a type, a trait object by casting it manually. This is an advanced case,
    though, and is used when the compiler cannot cast the type as a trait object by
    itself. Do note that we can only create trait objects of types whose sizes we
    know at compile time. A `dyn Trait` is an unsized type and can only be created
    as a reference. We can also create trait objects by putting them behind other
    pointer types such as `Box`, `Rc`, `Arc`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the older Rust 2015 edition, trait objects are referred to as just the name
    of the trait, for a trait object `dyn Foo` , it is represented as `Foo`. This
    syntax is confusing and it deprecated in the latest 2018 edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are illustrating the use of `dyn Trait` as a parameters
    in functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Traits, along with generics, provide both kinds of code reuse, either through
    monomorphization (early binding) or through runtime polymorphism (late binding).
    The decision on when to use which depends on the context and the needs of the
    application in question. Often, error types are taken toward the dynamic dispatch
    train as they are supposed to be code paths that rarely get executed. Monomorphization
    can be handy for small use cases, but the downside to it is that it introduces
    code bloat and duplication, which affects the cache line and increases binary
    size. However, of these two options, static dispatch should be preferred unless
    there is a hard constraint on binary size.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types are one of the most beautiful aspects of any statically typed language.
    They allow you to express so much at compile time. This chapter might not be the
    most advanced in this book, but the content was probably the heaviest. We now
    have a working knowledge of the different ways to reuse code. We also got to know
    about the mighty traits and how Rust's standard library makes heavy use of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about how programs use memory and how Rust
    provides compile-time memory management.
  prefs: []
  type: TYPE_NORMAL
