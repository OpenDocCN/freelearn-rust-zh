- en: Types, Generics, and Traits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型、泛型和特性
- en: Rust's type system is one of the striking features of the language. In this
    chapter, we'll go into detail on some of the notable aspects of the language such
    as traits, generics, and how to use them to write expressive code. We'll also
    explore some of the standard library traits that help with writing idiomatic Rust
    libraries. Expect lots of interesting material in this chapter!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的类型系统是语言的一个显著特点。在本章中，我们将详细介绍语言的一些显著方面，如特性、泛型和如何使用它们来编写表达性代码。我们还将探索一些有助于编写惯用Rust库的标准库特性。期待本章中有许多有趣的内容！
- en: 'We''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Type systems and why they matter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统和它们的重要性
- en: Generic programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程
- en: Augmenting types using traits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特性增强类型
- en: Exploring standard library traits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索标准库特性
- en: Composing traits and generics for writing expressive code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合特性和泛型以编写表达性代码
- en: Type systems and why they matter
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统和它们的重要性
- en: '"Be conservative in what you send, be liberal in what you accept."         
                                                                                 
                                                                                 
                                                                                 
                                                         - John Postel'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “发送时要保守，接受时要宽容。” —— 约翰·波斯尔
- en: Why do we need types in a language? That's a good question to ask as a motivation
    to understand type systems in programming languages. As programmers, we know that
    programs written for computers are represented in binary as combinations of 0s
    and 1s at the lowest level. In fact, the earliest computers had to be programmed
    manually in machine code. Eventually, programmers realized that this is very error-prone,
    tedious, and time-consuming. It's not practical for a human to manipulate and
    reason about these entities at the binary level. Later, during the 1950s, the
    programming community came up with machine code mnemonics, which turned into the
    assembly language we know of today. Following that, programming languages came
    into existence, which compiled down to assembly code and allowed programmers to
    write code that is human readable yet easy for computers to compile down to machine
    code. However, the languages that we humans speak can be quite ambiguous, so a
    set of rules and constraints needed to be put in place to convey what is possible
    and what is not in a computer program written in a human-like language, that is,
    the semantics. This brings us to the idea of types and type systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要在语言中使用类型？这是一个很好的问题，可以作为理解编程语言中类型系统的动机。作为程序员，我们知道为计算机编写的程序在最低级别上以0和1的组合形式表示为二进制。事实上，最早的计算机必须手动用机器码编程。最终，程序员意识到这非常容易出错、繁琐且耗时。对于人类来说，在二进制级别操作和推理这些实体并不实用。后来，在20世纪50年代，编程社区提出了机器码助记符，这变成了我们今天所知道的汇编语言。在此之后，编程语言开始出现，它们编译成汇编代码，允许程序员编写人类可读且易于计算机编译成机器码的代码。然而，我们人类所使用的语言可能相当含糊，因此需要制定一套规则和约束来传达在用类似人类语言编写的计算机程序中可能和不可能的内容，即语义。这引出了类型和类型系统的概念。
- en: A type is a named set of possible values. For example, `u8` is a type that can
    contain only positive values from 0 to 255\. Types provide us with a way to bridge
    the gap between the lower-level representation and the mental model we create
    of these entities. Apart from this, types also provide us with a way to express
    intent, behavior, and constraints for an entity. They define what we can and cannot
    do with types. For example, it is undefined to add a value of a type string to
    a value of a type number. From types, language designers built type systems, which
    are sets of rules that govern how different types interact with one another in
    a programming language. They act as a tool for reasoning about programs and help
    ensure that our programs behave correctly and according to the specification.
    Type systems are qualified based on their expressiveness, which simply means the
    extent to which you can express your logic, as well as invariants in the program
    using only the type system. For example, Haskell, a high-level language, has a
    very expressive type system, while C, a low-level language, provides us with very
    few type-based abstractions. Rust tries to draw a fine line between these two
    extremes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是一组可能值的命名集合。例如，`u8`是一个只能包含从0到255的正值的类型。类型为我们提供了一种方式来弥合底层表示和我们对这些实体创建的心理模型之间的差距。除此之外，类型还为我们提供了一种表达意图、行为和约束的方式。它们定义了我们可以用类型做什么，不能做什么。例如，将字符串类型的值添加到数字类型的值是未定义的。从类型出发，语言设计者构建了类型系统，这是一组规则，它规定了在编程语言中不同类型如何相互交互。它们作为推理程序的工具，并有助于确保我们的程序按规范正确运行。类型系统根据其表达能力进行分类，这仅仅意味着你可以用类型系统表达你的逻辑，以及程序中的不变性。例如，Haskell这种高级语言有一个非常表达性的类型系统，而C这种低级语言为我们提供了非常少的基于类型的抽象。Rust试图在这两个极端之间划一条细线。
- en: Rust's type system is inspired quite a bit by functional languages such as Ocaml
    and Haskell with their ADTs such as enums and structs, traits (akin to haskell
    typeclasses), and error handling types (`Option` and `Result`). The type system
    is characterized as a strong type system, which simply means that it performs
    more type checks at compile time rather than throwing them at runtime. Furthermore,
    the type system is static, which means that variables that are, for example, bound
    to an integer value, cannot be changed to point to a string later. These features
    enable robust programs that rarely break the invariants at runtime, with the cost
    that writing programs requires a bit of planning and thinking from the programmer.
    Rust tries to put more planning on your plate when designing programs, which can
    put off some programmers looking to prototype things fast. However, it is a good
    thing from the long-term perspective of maintaining software systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的类型系统在很大程度上受到了函数式语言如Ocaml和Haskell的启发，它们有诸如枚举和结构体这样的ADT（抽象数据类型），特质（类似于Haskell的类型类），以及错误处理类型（`Option`和`Result`）。这个类型系统被描述为一个强类型系统，这仅仅意味着它在编译时执行更多的类型检查，而不是在运行时抛出它们。此外，类型系统是静态的，这意味着例如绑定到整数值的变量不能在之后改变为指向字符串。这些特性使得程序健壮，很少在运行时破坏不变性，但代价是编写程序需要程序员进行一些规划和思考。Rust试图在设计程序时在你的盘子里放更多的规划，这可能会让一些寻求快速原型化的程序员感到沮丧。然而，从长期维护软件系统的角度来看，这是一件好事。
- en: With that aside, let's start by exploring how Rust's type system enables code
    reuse.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 把这些放在一边，让我们先来探索Rust的类型系统是如何使代码重用成为可能的。
- en: Generics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: From the dawn of high-level programming languages, the pursuit of better abstraction
    is something that language designers have always strived for. As such, many ideas
    concerning code reuse emerged. The very first of them was functions. Functions
    allow you to chunk away a sequence of instructions within a named entity that
    can be called later many times, optionally accepting any arguments for each invocation.
    They reduce code complexity and amplify readability. However, functions can only
    get you so far. If you have a function, say `avg`, that calculates the average
    of a given list of integer values and later you have a use case where you need
    to calculate the average for a list of float values too, then the usual solution
    is to create a new function that can average float values from the list of floats.
    What if you wanted to accept a list of double values too? We probably need to
    write another function again. Writing the same function over and over again that
    differs only by its arguments is a waste of precious time for programmers. To
    reduce this repetition, language designers wanted a way to express code so that
    the `avg` function can be written in a way that accepts multiple types, a generic
    function, and thus the idea of generic programming, or generics, was born. Having
    functions that can take more than one type is one of the features of generic programming,
    and there are other places that generics can be used. We'll explore all of them
    in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从高级编程语言的开端起，追求更好的抽象一直是语言设计者努力的目标。因此，许多关于代码重用的想法应运而生。其中第一个就是函数。函数允许你将一系列指令封装在可以稍后多次调用的命名实体中，并且可以选择性地为每次调用接受任何参数。它们降低了代码的复杂性并提高了可读性。然而，函数只能带你走这么远。如果你有一个名为`avg`的函数，它计算给定整数列表的平均值，后来你有一个用例需要计算浮点值列表的平均值，那么通常的解决方案是创建一个新的函数来从浮点值列表中计算平均值。如果你还想接受双精度值列表呢？我们可能需要再次编写另一个函数。反复编写只有参数不同的相同函数是程序员宝贵时间的浪费。为了减少这种重复，语言设计者希望有一种方法来表达代码，使得`avg`函数可以以接受多种类型的方式编写，从而产生了泛型编程，或称为泛型。泛型编程的一个特征是函数可以接受多种类型，还有其他地方可以使用泛型。我们将在本节中探讨所有这些内容。
- en: Generic programming is a technique that is only applicable in the case of statically
    typed programming languages. They first appeared in ML, a statically typed functional
    language. Dynamic languages such as Python use duck typing, where APIs treat arguments
    based on what they can do rather than what they are, so they don't rely on generics.
    Generics are part of the language design feature that enables code reuse and the
    **Don't repeat yourself **(**DRY**) principle. Using this technique, you can write
    algorithms, functions, methods, and types with placeholders for types, and specify
    a type variable (with a single letter, which is usually `T`, `K`, or `V` by convention)
    on these types, telling the compiler to fill in the actual types later when any
    code instantiates them. These types are referred to as generic types or items.
    The single letter symbols such as `T` on type are called **generic type** **parameters**.
    They are substituted with concrete types such as  `u32` when you use or instantiate
    any generic item.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程是一种仅在静态类型编程语言中适用的技术。它们最初出现在ML语言中，这是一种静态类型函数式语言。像Python这样的动态语言使用鸭子类型，API根据对象能做什么而不是它们是什么来处理参数，因此它们不依赖于泛型。泛型是语言设计特征的一部分，它使得代码重用和**不要重复自己（DRY**）原则成为可能。使用这种技术，你可以编写带有类型占位符的算法、函数、方法和类型，并在这些类型上指定一个类型变量（通常用单个字母表示，通常是`T`、`K`或`V`），告诉编译器在代码实例化时填充实际类型。这些类型被称为泛型类型或项。类型上的单个字母符号，如`T`，被称为**泛型类型参数**。当你使用或实例化任何泛型项时，它们会被替换为具体的类型，例如`u32`。
- en: '**Note**: By substitution, we mean that every time a generic item is used with
    a concrete type, a specialized copy of that code is generated at compile time
    with the type variable `T`, getting replaced with the concrete type. This process
    of generating specialized functions with concrete types at compile time is called
    **monomorphization**, which is the procedure of doing the opposite of polymorphic
    functions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：通过替换，我们是指每次使用泛型项与具体类型结合时，在编译时都会生成一个具有类型变量`T`的专用代码副本，其中`T`会被替换为具体类型。在编译时生成具有具体类型的专用函数的过程称为**单态化**，这是执行多态函数相反的过程。'
- en: Let's look at some of the existing generic types from the Rust standard library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Rust标准库中的一些现有通用类型。
- en: 'The `Vec<T>` type from the standard library is a generic type that is defined
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的`Vec<T>`类型是一个定义为以下内容的通用类型：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can see that the type signature of `Vec` contains a type parameter `T` after
    its name, surrounded by a pair of angle brackets `< >`. Its member field, `buf`,
    is a generic type as well, and so the `Vec` itself has to be generic. If we don''t
    have `T` on our generic type `Vec<T>`, even though we have a `T` on its `buf`
    field, we get the following error:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Vec`的类型签名在其名称之后包含一个类型参数`T`，由一对尖括号`< >`包围。其成员字段`buf`也是一个通用类型，因此`Vec`本身也必须是泛型的。如果我们没有在泛型类型`Vec<T>`上使用`T`，即使在其`buf`字段上有`T`，我们也会得到以下错误：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `T` needs to be part of the type definition for `Vec`. So, when we denote
    a `Vec`, we always refer to it by using `Vec<T>` when denoting generically or
    by using `Vec<u64>` when we know the concrete type. Next, let's look at how to
    create our own generic types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`T`需要成为`Vec`类型定义的一部分。因此，当我们表示`Vec`时，我们总是使用`Vec<T>`来表示泛型，或者当我们知道具体的类型时，使用`Vec<u64>`。接下来，让我们看看如何创建我们自己的通用类型。
- en: Creating generic types
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建通用类型
- en: Rust allows us to declare many things as generics such as structs, enums, functions,
    traits, methods, and implementation blocks. One thing that they have in common
    is that the generic type parameters are separated by and enclosed within a pair
    of `< >` brackets. Within them, you can put any number of comma-separated generic
    type parameters. Let's go through how you might create generics, starting by looking
    at generic functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Rust允许我们声明许多泛型，如结构体、枚举、函数、特质、方法和实现块。它们共同的一点是泛型类型参数由`< >`括号分隔。在其中，你可以放置任意数量的逗号分隔的泛型类型参数。让我们通过查看泛型函数的创建方法来了解如何创建泛型。
- en: Generic functions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'To create a generic function, we place the generic type parameter immediately
    after the function name and before the parenthesis, like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个泛型函数，我们将泛型类型参数直接放置在函数名称之后和括号之前，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, `give_me` is a generic function with `<T>` after its
    name, and the `value` parameter is of type `T`. In `main`, we can call this function
    with any argument. During compilation, our compiled object file will contain two
    specialized copies of this function. We can confirm this in our generated binary
    object file by using the `nm` command, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`give_me`是一个泛型函数，其名称后有`<T>`，`value`参数是类型`T`。在`main`中，我们可以用任何参数调用此函数。在编译过程中，我们的编译对象文件将包含此函数的两个专门副本。我们可以通过使用`nm`命令来确认这一点，如下所示：
- en: '![](img/3876463a-6779-4ef4-9d8e-20433f15aa1e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3876463a-6779-4ef4-9d8e-20433f15aa1e.png)'
- en: '`nm` is a utility from the GNU binutils package for viewing symbols from compiled
    object files. By passing `nm` our binary, we pipe and grep for the prefix of our
    `give_me` function. As you can see, we have two copies of the function with random
    IDs appended to them to distinguish them. One of them takes a `&str` and the other
    a `i32`, because of two invocations with different arguments.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`nm`是GNU binutils包中的一个实用工具，用于查看编译对象文件中的符号。通过将我们的二进制文件传递给`nm`，我们可以使用管道和grep来搜索我们的`give_me`函数的前缀。正如你所见，我们有两个函数副本，它们后面附加了随机ID以区分它们。其中一个接受`&str`，另一个接受`i32`，因为有两个具有不同参数的调用。'
- en: Generic functions are a cheap way to give the illusion of polymorphic code.
    I say illusion because after compilation, it is all duplicated code with concrete
    types as parameters. They come with a downside though, which is an increase in
    the size of the compiled object file due to code duplication. This is proportional
    to the number of concrete types that are used. In later sections, when we get
    to traits, we'll see the true form of polymorphism, trait objects. Still, polymorphism
    through generics is preferred in most cases because it has no runtime overhead,
    as is the case with trait objects. Trait objects should only be used when generics
    don't cater to the solution and cases where you need to store a bunch of types
    together in a collection. We'll see those examples when we get to trait objects.
    Next, we'll look at how we can make our structs and enums generic. We'll only
    explore how to declare them first. Creating and using these types are covered
    in the later sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数是一种以低成本实现多态代码幻觉的方法。我说幻觉，因为编译后，它都是具有具体类型参数的重复代码。尽管如此，它们也有一个缺点，那就是由于代码重复，编译后的对象文件大小增加。这与使用的具体类型数量成正比。在后面的章节中，当我们到达特质时，我们将看到多态的真正形式，即特质对象。尽管如此，泛型多态在大多数情况下仍然是首选的，因为它没有运行时开销，就像特质对象一样。特质对象应该只在泛型无法满足解决方案和需要将多种类型一起存储在集合中的情况下使用。当我们到达特质对象时，我们将看到那些示例。接下来，我们将看看我们如何使我们的结构体和枚举泛型化。我们首先将探索如何声明它们。创建和使用这些类型的内容将在后面的章节中介绍。
- en: Generic types
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: '**Generic structs**: We can declare tuple structs and normal structs generically
    like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型结构体**：我们可以像这样泛型地声明元组结构体和普通结构体：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Generic structs contain the generic type parameter after the name of the struct,
    as shown in the preceding code. With this, whenever we denote this struct anywhere
    in our code, we also need to type the `<T>` part together with the type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型结构体在结构体名称之后包含泛型类型参数，如前述代码所示。有了这个，无论我们在代码的任何地方引用这个结构体，我们都需要一起输入 `<T>` 部分，以及类型。
- en: '**Generic enums**: Similarly, we can create generic enums as well:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型枚举**：同样，我们也可以创建泛型枚举：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Transmission` enum has a variant called `Signal`, which holds a generic
    value, and a variant called `NoSignal`, which is a no value variant.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Transmission` 枚举有一个名为 `Signal` 的变体，它包含一个泛型值，还有一个名为 `NoSignal` 的变体，它是一个无值变体。
- en: Generic implementations
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型实现
- en: 'We can also write `impl` blocks for our generic types too, but it gets verbose
    here because of the extra generic type parameters, as we''ll see. Let''s implement
    a `new()` method on our `Container<T>` struct:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为我们的泛型类型编写 `impl` 块，但由于额外的泛型类型参数，这会变得冗长，正如我们将看到的。让我们在 `Container<T>` 结构体上实现一个
    `new()` 方法：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s compile this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译这个：
- en: '![](img/030da4c0-1c15-493c-82f0-fa4967b03e75.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/030da4c0-1c15-493c-82f0-fa4967b03e75.png)'
- en: 'The error message cannot find our generic type `T`. When writing an `impl`
    block for any generic type, we need to declare the generic type parameter before
    using it within our type. `T` is just like a variable—a type variable—and we need
    to declare it. Therefore, we need to modify the implementation block a bit by
    adding `<T>` after `impl`, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息无法找到我们的泛型类型 `T`。在为任何泛型类型编写 `impl` 块时，我们需要在使用它之前声明泛型类型参数。`T` 就像是一个变量——一个类型变量——我们需要声明它。因此，我们需要通过在
    `impl` 后面添加 `<T>` 来稍微修改实现块，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With that change, the preceding code compiles. The previous `impl` block  basically
    means that we are implementing these methods for all types `T`, which appear in
    `Container<T>`. This `impl` block is a generic implementation. Therefore, every
    concrete `Container` that ever gets generated will have these methods. Now, we
    could have also written a more specific `impl` block for `Container<T>` by putting
    any concrete type in place of `T`. This is what it would look like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个更改，前面的代码可以编译。之前的 `impl` 块基本上意味着我们正在为出现在 `Container<T>` 中的所有类型 `T` 实现这些方法。这个
    `impl` 块是一个泛型实现。因此，每个生成的具体 `Container` 都将具有这些方法。现在，我们也可以为 `Container<T>` 编写一个更具体的
    `impl` 块，通过将任何具体类型放在 `T` 的位置。这将看起来像这样：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we implemented a method called `sum`, which is only present
    on `Container<u32>` types. Here, we don't need the `<T>` after `impl` because
    of the presence of `u32` as a concrete type. This is another nice property of
    `impl` blocks, which allows you to specialize generic types by implementing methods
    independently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了一个名为`sum`的方法，这个方法只存在于`Container<u32>`类型上。在这里，由于存在具体的类型`u32`，我们不需要在`impl`后面加上`<T>`。这是`impl`块另一个很好的特性，它允许你通过独立实现方法来专门化泛型类型。
- en: Using generics
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型
- en: Now, the way we instantiate or use generic types is also a bit different than
    their non-generic counterparts. Any time we instantiate them, the compiler needs
    to know the concrete type in place of `T` in their type, signature, which gives
    it the type information to monomorphize the generic code. Most of the time, the
    concrete type is inferred based on the instantiation of the type or by calling
    any method that takes a concrete type in the case of generic functions. In rare
    cases, we need to help the compiler by specifically typing out the concrete type
    in place of the generic type by using the turbofish (`::<>`) operator. We'll see
    how that is used in a moment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实例化或使用泛型类型的方式也与其非泛型对应物略有不同。每次我们实例化它们时，编译器都需要知道在它们的类型签名中将`T`替换为具体类型，从而为单态化泛型代码提供类型信息。大多数情况下，具体类型是根据类型的实例化或泛型函数中调用接受具体类型的方法来推断的。在罕见的情况下，我们需要通过使用尖括号操作符（`::<>`）将具体类型显式地替换为泛型类型来帮助编译器。我们将在稍后看到它是如何使用的。
- en: 'Let''s look at the case of instantiating `Vec<T>`, a generic type. Without
    any type signature, the following code does not compile:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实例化泛型类型`Vec<T>`的情况。在没有任何类型签名的情况下，以下代码无法编译：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compiling the preceding code, gives the following error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编译前面的代码，会得到以下错误：
- en: '![](img/156ddf29-ad47-42a3-af39-d8a5a315707a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/156ddf29-ad47-42a3-af39-d8a5a315707a.png)'
- en: 'This is because the compiler doesn''t know what type `a` would contain until
    we specify it manually or call one of its methods, thereby passing in a concrete
    value. This is shown in the following snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器不知道类型`a`会包含什么，直到我们手动指定它或调用它的一个方法，从而传递一个具体值。这在上面的代码片段中有所体现：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the second code snippet, we specified the type of `v1` to be a `Vec` of `u8`,
    and it compiles fine. Another way, as with `v2`, is to call a method that accepts
    any concrete type. After the `push` method call, the compiler can infer that `v2`
    is a `Vec<i32>`. The other way to create the `Vec` is to use the `turbofish` operator,
    as is the case with `v3` binding in the preceding code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个代码片段中，我们将`v1`的类型指定为`u8`的`Vec`，并且它编译正常。另一种方法，就像`v2`一样，是调用一个接受任何具体类型的方法。在`push`方法调用之后，编译器可以推断出`v2`是`Vec<i32>`。创建`Vec`的另一种方法是使用尖括号操作符，就像前面代码中的`v3`绑定一样。
- en: 'The `turbofish` operator in generic functions appears right after the function
    name and before the parenthesis. Another example of this is the generic `parse`
    function from the `std::str` module. `parse` can parse values from a string, and
    many types are able to parse from it, such as `i32`, `f64`, `usize`, and so on,
    so it''s a generic type. So, when using `parse`, you really need to use the `turbofish`
    operator, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数中的尖括号操作符出现在函数名之后和括号之前。另一个例子是`std::str`模块中的泛型`parse`函数。`parse`可以从字符串中解析值，许多类型能够从中解析，例如`i32`、`f64`、`usize`等，因此它是一个泛型类型。所以，当使用`parse`时，你确实需要使用尖括号操作符，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Something to take note of is that only types that implement the `FromStr` interface
    or trait can be passed to the `parse` function. `u8` has an implementation of
    `FromStr`, and so we were able to parse it in the preceding code. The `parse`
    function uses the `FromStr` trait to limit types that can be passed to it. We'll
    get to know how we can mix generics and traits after we're done exploring traits.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，只有实现了`FromStr`接口或特质的类型才能传递给`parse`函数。`u8`有一个`FromStr`的实现，因此我们能够在前面的代码中解析它。`parse`函数使用`FromStr`特质来限制可以传递给它的类型。在探索特质之后，我们将了解如何混合泛型和特质。
- en: With the idea of generics under our belt, let's focus on one of the most ubiquitous
    features in Rust, traits!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握泛型概念的基础上，让我们关注Rust中最常见的一个特性——特质！
- en: Abstracting behavior with traits
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特质抽象行为
- en: From a polymorphism and code reuse perspective, it is often a good idea to separate
    shared behavior and common properties of types from themselves in code and only
    have methods that are unique to themselves. In doing so, we allow different types
    to relate to each other with these common properties, which allows us to program
    for APIs that are more general or inclusive in terms of their parameters. This
    means that we can accept types that have those shared properties while not being
    restricted to one particular type.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从多态和代码重用的角度来看，通常将类型的共享行为和共同属性从它们自身分离出来，在代码中只保留独特的属性是一个好主意。这样做，我们允许不同的类型通过这些共同属性相互关联，这使得我们可以为更通用或包容的
    API 编程，在参数方面。这意味着我们可以接受具有这些共享属性的类型，而不会局限于某一特定类型。
- en: In object-oriented languages such as Java or C#, interfaces convey the same
    idea, where we can define shared behavior that many types can implement. For example,
    instead of having multiple `sort` functions, which take in a list of integer values,
    and other functions that take in a list of string values, we can have a single
    `sort` function that can take a list of items that implement the `Comparable`
    or `Comparator` interface. This allows us to pass anything that is `Comparable` to
    our `sort` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Java 或 C# 这样的面向对象语言中，接口传达了相同的概念，我们可以定义许多类型可以实现的共享行为。例如，我们不必有多个 `sort` 函数，这些函数接受整数值的列表，以及其他接受字符串值列表的函数，我们可以有一个单一的
    `sort` 函数，它可以接受实现了 `Comparable` 或 `Comparator` 接口的项的列表。这允许我们将任何 `Comparable` 的东西传递给我们的
    `sort` 函数。
- en: Rust also has a similar yet powerful construct known as **traits**. There are
    many forms of traits in Rust, and we'll look at most of them and the ways we can
    interact with them briefly. Also, when traits are mixed with generics, we can
    restrict the range of parameters that we can pass to our APIs. We'll see how that
    happens when we learn more about trait bounds.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 也有一个类似但功能强大的结构，称为 **特质**。Rust 中有许多特质的形态，我们将简要地查看它们以及我们如何与之交互。此外，当特质与泛型结合使用时，我们可以限制传递给我们的
    API 的参数范围。当我们更多地了解特质边界时，我们将看到这是如何发生的。
- en: Traits
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质
- en: A trait is an item that defines a set of contracts or shared behavior that types
    can opt to implement. Traits are not usable by themselves and are meant to be
    implemented by types. Traits have the power to establish relationships between
    distinct types. They are the backbone to many language features such as closures,
    operators, smart pointers, loops, compile-time data race checks, and much more.
    Quite a few of the high-level language features in Rust boil down to some type
    calling a trait method that it implements. With that said, let's look at how we
    can define and use a trait in Rust!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 特质是一个定义了一组合同或共享行为的项，类型可以选择实现。特质本身不可用，旨在由类型实现。特质有建立不同类型之间关系的能力。它们是许多语言特性的骨干，如闭包、运算符、智能指针、循环、编译时数据竞争检查等等。Rust
    中许多高级语言特性归结为某些类型调用它们实现的特质方法。话虽如此，让我们看看如何在 Rust 中定义和使用特质！
- en: 'Let''s say we are modeling a simple media player application that can play
    audio and video files. For this demo, we''ll create a project by running `cargo
    new super_player`. To convey the idea of traits and to make this simple, in our
    `main.rs` file, we have represented our audio and video media as tuple structs
    with the name of the media as a `String`, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在模拟一个简单的媒体播放器应用程序，它可以播放音频和视频文件。对于这个演示，我们将通过运行 `cargo new super_player`
    来创建一个项目。为了传达特质的概念并使这个例子简单化，在我们的 `main.rs` 文件中，我们将音频和视频媒体表示为具有媒体名称的元组结构体 `String`，如下所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, at the very minimum, both the `Audio` and `Video` structs need to have
    a `play` and `pause` method. It''s a functionality that''s shared by both of them.
    It''s a good opportunity for us to use a trait here. Here, we''ll define a trait
    called `Playable` with two methods in a separate module called `media.rs`, like
    so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，至少，`Audio` 和 `Video` 结构体都需要有一个 `play` 和 `pause` 方法。这是它们共有的功能。这是一个很好的机会让我们在这里使用一个特质。在这里，我们将在一个名为
    `media.rs` 的单独模块中定义一个名为 `Playable` 的特质，如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use the `trait` keyword to create a trait, followed by its name and a pair
    of braces. Within the braces, we can provide zero or more methods that any type
    implementing the trait should fulfill. We can also define constants within traits,
    which all of the implementers can share. The implementer can be any struct, enum,
    primitive, function, closure, or even a trait.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`trait`关键字来创建一个特性，后面跟着其名称和一对大括号。在大括号内，我们可以提供零个或多个方法，任何实现该特性的类型都应该实现这些方法。我们还可以在特性中定义常量，所有实现者都可以共享这些常量。实现者可以是任何结构体（struct）、枚举（enum）、原始类型（primitive）、函数、闭包（closure），甚至是另一个特性。
- en: You may have noticed the signature of `play`; it takes a reference to a symbol,
    `self`, but does not have a body, and ends with a semicolon.  `self` is just a
    type alias to `Self`, which refers to the type on which the trait is being implemented.
    We'll cover these in detail in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),  *Advanced
    Concepts*. This means that the methods within the traits are like an abstract
    method from Java. It is up to the types to implement this trait and define the
    function according to their use case. However, methods declared within a trait
    can also have default implementations, as is the case with the `pause` function
    in the preceding code. `pause` does not take `self`, and so it's akin to a static
    method that does not require an instance of the implementer to invoke it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了`play`方法的签名；它接受一个符号的引用`self`，但没有方法体，并以分号结束。`self`只是一个类型别名，指向正在实现特性的类型`Self`。我们将在第7章[高级概念](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)中详细讨论这些内容。这意味着特性内的方法类似于Java中的抽象方法。实现这个特性并定义函数的具体实现取决于类型。然而，在特性内声明的函数也可以有默认实现，就像前面代码中的`pause`函数一样。`pause`不接受`self`，因此它类似于一个不需要实现者实例即可调用的静态方法。
- en: 'We can have two kinds of methods within a trait:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个特性（trait）中，我们可以有两种方法：
- en: '**Associated methods**: These are methods that are available directly on the
    type implementing the trait and do not need an instance of the type to invoke
    them. There are also known as static methods in mainstream languages, for example,
    the `from_str` method from the `FromStr` trait in the standard library. It is
    implemented for a `String` and thus allows you to create a `String` from a `&str`
    by calling `String::from_str("foo")`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联方法**：这些方法可以直接在实现特性的类型上使用，不需要该类型的实例来调用它们。它们也被称为主流语言中的静态方法，例如，标准库中`FromStr`特性的`from_str`方法。它为`String`实现，因此允许你通过调用`String::from_str("foo")`从`&str`创建一个`String`。'
- en: '**Instance methods**: These are methods that have their first parameter as `self`.
    These are only available on instances of the type that are implementing the trait.  `self`
    points to the instance of the type implementing the trait. It can be of three
    types: `self`  methods, which consume the instance when called; `&self` methods,
    which only have read access to the instance its members (if any); and `&mut self` methods,
    which have mutable access to its members and can modify them or even replace them
    with another instance. For example, the `as_ref` method from the `AsRef` trait
    in the standard library is an instance method that takes `&self`, and is meant
    to be implemented by types that can be converted to a reference or a pointer.
    We''ll cover references and the `&` and `&mut` parts of the type signature in
    these methods when we get to [Chapter 5](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety.*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例方法**：这些方法的第一参数是`self`。这些方法仅在实现该特性的类型的实例上可用。`self`指向实现该特性的类型的实例。它可以是三种类型：`self`方法，在调用时消耗实例；`&self`方法，只有对实例成员（如果有）的读取访问权限；以及`&mut
    self`方法，对其实例成员有可变访问权限，可以修改它们，甚至可以用另一个实例替换它们。例如，标准库中`AsRef`特性的`as_ref`方法是一个实例方法，它接受`&self`，并且旨在由可以转换为引用或指针的类型实现。当我们到达第5章[内存管理和安全性](db2c2723-8ca0-43be-b135-afd847342146.xhtml)时，我们将涵盖引用和这些方法类型签名中的`&`和`&mut`部分。'
- en: 'Now, we''ll implement the preceding `Playable` trait on our `Audio`  and `Video`
    types, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将像这样在我们的`Audio`和`Video`类型上实现前面的`Playable`特性：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We write trait implementations with the `impl` keyword followed by the trait
    name, followed by the `for` keyword and the type we want to implement the trait
    for, followed by a pair of braces. Within these braces, we are required to provide
    the implementations of methods, and optionally override any default implementation
    that exists in the trait. Let''s compile this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`impl`关键字后跟特质名称，然后是`for`关键字和我们要为其实现特质的类型，之后是一对大括号。在这些大括号内，我们必须提供方法的实现，并且可以选择覆盖特质中存在的任何默认实现。让我们编译这段代码：
- en: '![](img/cfa66081-2815-459f-94f9-16b38038c29f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfa66081-2815-459f-94f9-16b38038c29f.png)'
- en: 'The preceding error highlights an important feature of traits: traits are private
    by default. To be usable by other modules or across crates, they need to be made
    public. There are two steps to this. First, we need to expose our trait to the
    outside world. To do that, we need to prepend our `Playable` trait declaration
    with the `pub` keyword:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误突出了特质的 重要特性：特质默认是私有的。为了能被其他模块或跨crate使用，它们需要被公开。这需要两个步骤。首先，我们需要将我们的特质暴露给外界。为此，我们需要在`Playable`特质声明前加上`pub`关键字：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After we have exposed our trait, we need to use the `use` keyword to bring
    the trait into scope in the module we want to use the trait in. This will allow
    us to call its methods, like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们暴露了我们的特质之后，我们需要使用`use`关键字将特质引入我们想要使用特质的模块的作用域。这将允许我们调用其方法，如下所示：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that, we can play our audio and video media:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以播放我们的音频和视频媒体：
- en: '![](img/6e9db8c6-9ad4-4880-b753-13f114e2fe5e.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e9db8c6-9ad4-4880-b753-13f114e2fe5e.png)'
- en: This is very far from any actual media player implementation, but our aim was
    to explore the use case for traits.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这与任何实际的媒体播放器实现都相去甚远，但我们的目标是探索特质的使用场景。
- en: 'Traits can also specify in their declaration that they depend on other traits;
    this is a feature known as trait inheritance. We can declare inherited traits
    like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 特质也可以在其声明中指定它们依赖于其他特质；这是一个称为特质继承的功能。我们可以这样声明继承的特质：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we declared two traits: a `Vehicle` (a more general)
    trait and a `Car` (more specific) trait, which depends on `Vehicle`. Since `TeslaRoadster`
    is a car, we implemented the `Car` trait for it. Also, notice the body of the
    method `new` on `TeslaRoadster`, which uses `Self` as the return type. This is
    also substituted for the `TeslaRoadster` instance that we return from `new`. `Self`
    is just a convenient type alias for the implementing type within the trait''s
    impl blocks. It can also be used to create other types, such as tuple structs
    and enums, and also in match expressions. Let''s try compiling this code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了两个特质：一个更通用的`Vehicle`特质和一个依赖于`Vehicle`的更具体的`Car`特质。由于`TeslaRoadster`是一辆车，我们为它实现了`Car`特质。注意`TeslaRoadster`上`new`方法的主体，它使用`Self`作为返回类型。这也会被用来替换我们从`new`返回的`TeslaRoadster`实例。`Self`只是特质impl块内实现类型的便利别名。它也可以用来创建其他类型，如元组结构和枚举，以及匹配表达式。让我们尝试编译这段代码：
- en: '![](img/f86789bc-8698-45a2-a43d-017c212d109e.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f86789bc-8698-45a2-a43d-017c212d109e.png)'
- en: 'See that error? In its definition, the `Car` trait specifies the constraint
    that any type that implements the trait must also implement the `Vehicle` trait, `Car:
    Vehicle`. We did not implement `Vehicle` for our `TeslaRoadster`, and Rust caught
    and reported it for us. Therefore, we must implement the `Vehicle` trait like
    so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '看到那个错误吗？在其定义中，`Car`特质指定了任何实现该特质的类型也必须实现`Vehicle`特质，`Car: Vehicle`。我们没有为我们的`TeslaRoadster`实现`Vehicle`，Rust为我们捕获并报告了它。因此，我们必须像这样实现`Vehicle`特质：'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With that implementation satisfied, our program compiles fine with the following
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现满足后，我们的程序编译良好，以下是其输出：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The underscore in `200_200` in the `get_price` method is a handy syntax to create
    readable numeric literals.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_price`方法中的`200_200`中的下划线是一个方便的语法，用于创建可读的数字字面量。
- en: 'As an analogy to object-oriented languages, traits and their implementations
    are similar to interfaces and classes that implement those interfaces. However,
    it is to be noted that traits are very different from interfaces:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为面向对象语言的类比，特质及其实现类似于接口和实现这些接口的类。然而，需要注意的是，特质与接口非常不同：
- en: Even though traits have a form of inheritance in Rust, implementations do not.
    This means that a trait called `Panda` can be declared, which requires another
    trait called `KungFu` to be implemented by types that implement `Panda`. However,
    the types themselves don't have any sort of inheritance. Therefore, instead of
    object inheritance, type composition is used, which relies on trait inheritance
    to model any real-world entity in code.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管特性在Rust中具有一种继承形式，但实现却没有。这意味着可以声明一个名为 `Panda` 的特性，它要求实现 `Panda` 的类型实现另一个名为
    `KungFu` 的特性。然而，这些类型本身并没有任何继承形式。因此，而不是使用对象继承，使用类型组合，这依赖于特性继承来在代码中建模任何现实世界的实体。
- en: You can write trait implementation blocks anywhere, without having access to
    the actual type.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在任何地方编写特性实现块，而不需要访问实际类型。
- en: You can also implement your own traits on any type ranging from built-in primitive
    types to generic types.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在任何类型上实现自己的特性，从内置的基本类型到泛型类型。
- en: You cannot implicitly have return types as traits in a function like you can
    return an *interface* as a return type in Java. You have to return something called
    a trait object, and the syntax to do that is explicit. We'll see how to do that
    when we get to trait objects.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能像在Java中将接口作为返回类型一样隐式地拥有函数中的返回类型作为特性。你必须返回一个称为特性对象的东西，并且执行此操作的语法是明确的。当我们到达特性对象时，我们将看到如何做到这一点。
- en: The many forms of traits
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性的多种形式
- en: In the preceding examples, we had a glimpse of the simplest form of trait. But
    there's more to traits than meets the eye. As you start interacting with traits
    in bigger code bases, you will encounter different forms of them. Depending on
    the complexity of the program and the problem to be solved, the simple form of
    traits might not be suitable. Rust provides us with other forms of traits that
    model the problem well. We'll take a look at some of the standard library traits
    and try to classify them so that we have a good idea when to use what.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们瞥见了特性的最简单形式。但特性比表面看起来要复杂得多。当你开始在更大的代码库中与特性交互时，你会遇到它们的不同形式。根据程序复杂性和要解决的问题，简单的特性形式可能不适合。Rust为我们提供了其他形式的特性，这些特性很好地模拟了问题。我们将查看一些标准库特性，并尝试对它们进行分类，以便我们有一个很好的想法在何时使用什么。
- en: Marker traits
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记特性
- en: Traits defined in the `std::marker` module are called **marker traits**. These
    traits don't have any method, and simply have their declaration with their name
    with an empty body. Examples from the standard library include `Copy`, `Send`,
    and `Sync`. They are called marker traits because they are used to simply mark
    a type as belonging to a particular family for to gain some compile time guarantees.
    Two such examples from the standard library are the `Send` and `Sync` traits that
    are auto-implemented by the language for most types whenever appropriate, and
    convey which values are safe to send and share across threads. We'll get to know
    more about them in [Chapter 8](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml), *Concurrency*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `std::marker` 模块中定义的特性被称为**标记特性**。这些特性没有任何方法，只是简单地声明了它们的名称，并且体为空。标准库中的例子包括
    `Copy`、`Send` 和 `Sync`。它们被称为标记特性，因为它们被用来简单地标记一个类型属于特定的家族，以获得一些编译时保证。标准库中的两个例子是
    `Send` 和 `Sync` 特性，这些特性在适当的时候由语言自动实现，并传达了哪些值是可以在线程间安全发送和共享的。我们将在第8章[并发](8f3cb215-b8a0-4ed7-bce7-68570687fbd0.xhtml)中了解更多关于它们的信息。
- en: Simple traits
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单特性
- en: 'This is the simplest form a trait definition could possibly be. We already
    discussed this as an introduction to traits:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是特性定义可能的最简单形式。我们已经在特性的介绍中讨论了这一点：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An example from the standard library would be the `Default` trait, which is
    implemented for types that can be initialized with a default value. It is documented
    at [https://doc.rust-lang.org/std/default/trait.Default.html](https://doc.rust-lang.org/std/default/trait.Default.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的一个例子是 `Default` 特性，它为可以初始化为默认值的类型实现。它在[https://doc.rust-lang.org/std/default/trait.Default.html](https://doc.rust-lang.org/std/default/trait.Default.html)上有文档说明。
- en: Generic traits
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型特性
- en: 'Traits can also be generic. This is useful in scenarios where you want to implement
    a trait for a wide variety of types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 特性也可以是泛型的。这在需要为广泛的各种类型实现特性时很有用：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Two such examples are is the `From<T>` and `Into<T>` traits, which allow from conversion
    from a type to a type `T` and vice versa. Their use becomes prominent when these
    traits are used as trait bounds in function parameters. We'll see what trait bounds
    are and how they work in a moment. However, generic traits can get quite verbose
    when they are declared with three or four generic types. For those cases, we have
    associated type traits.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两个这样的例子是`From<T>`和`Into<T>`特质，它们允许从类型到类型`T`的转换以及相反的转换。当这些特质用作函数参数的特质界限时，它们的使用变得尤为突出。我们将在稍后看到特质界限是什么以及它们是如何工作的。然而，当泛型特质声明了三个或四个泛型类型时，它们可能会变得相当冗长。对于这些情况，我们有关联类型特质。
- en: Associated type traits
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联类型特质
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These are a better alternative to generic traits due to their ability to declare
    associated types within the trait, like the `Out` type in the declaration of `Foo` in
    the preceding code. They have a less verbose type signature. The advantage of
    them is that, in the implementation, they allow us to declare the associated type
    once and use `Self::Out` as the return type or parameter type in any of the trait
    methods or functions. This removes the redundant specification of types, as is
    the case with generic traits. One of the finest examples of associated type traits
    is the `Iterator` trait, which is used for iterating over the values of a custom
    type. Its documentation can be found at [https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html).
    We'll dig deeper into iterators when we get to [Chapter 8](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),  *Advanced
    Topics*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们能够在特质内声明关联类型，如前面代码中`Foo`声明中的`Out`类型，这些特质是泛型特质的更好替代品。它们具有更简洁的类型签名。它们的优点在于，在实现中，它们允许我们一次性声明关联类型，并在任何特质方法或函数中将`Self::Out`用作返回类型或参数类型。这消除了与泛型特质相同的情况下的类型冗余。关联类型特质的一个最佳例子是`Iterator`特质，它用于遍历自定义类型的值。其文档可以在[https://doc.rust-lang.org/std/iter/trait.Iterator.html](https://doc.rust-lang.org/std/iter/trait.Iterator.html)找到。当我们到达第8章[高级主题](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)时，我们将更深入地探讨迭代器。
- en: Inherited traits
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的特质
- en: 'We already saw these traits in our `trait_inheritance.rs` code example. Unlike
    types in Rust, traits can have an inheritance relationship, for instance:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`trait_inheritance.rs`代码示例中看到了这些特质。与Rust中的类型不同，特质可以具有继承关系，例如：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding snippet , we declared a trait, `Foo`, that depends on a super
    trait, `Bar`. The definition of `Foo` mandates implementing `Bar` whenever you
    are implementing `Foo` for your type. One such example from the standard library
    is the `Copy` trait, which requires  the type to also implement the `Clone` trait.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个特质，名为`Foo`，它依赖于一个超特质，名为`Bar`。`Foo`的定义要求在为你的类型实现`Foo`时，必须实现`Bar`。标准库中的一个例子是`Copy`特质，它要求类型也实现`Clone`特质。
- en: Using traits with generics – trait bounds
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型特质 - 特质界限
- en: 'Now that we have a decent idea about generics and traits, we can explore ways
    in which we can combine them to express more about our interfaces at compile time.
    Consider the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对泛型和特质有了相当的了解，我们可以探索如何将它们结合起来，在编译时表达更多关于我们接口的信息。考虑以下代码：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we have a generic function, `load`, on our `Game` type
    that can take any game entity and load it in our game world by calling `init()`
    on all kinds of `T`. However, this example fails to compile with the following
    error:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个泛型函数`load`，它位于我们的`Game`类型上，可以接受任何游戏实体并通过在所有类型的`T`上调用`init()`来将其加载到我们的游戏世界中。然而，这个例子由于以下错误而无法编译：
- en: '![](img/f9c1cf25-669f-4489-9bb2-f5592e705788.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9c1cf25-669f-4489-9bb2-f5592e705788.png)'
- en: 'So, a generic function taking any type `T` cannot know or assume by default 
    the `init` method exists on `T`. If it did, it wouldn''t be generic at all, and
    would only be able to accept types that have the `init()` method on them. So,
    there is a way that we can let the compiler know of this and constrain the set
    of types that `load` can accept using traits. This is where trait bounds come
    into the picture. We can define a trait called `Loadable` and implement it on
    our our `Enemy` and `Hero` types. Following that, we have to put a couple of symbols
    beside our generic type declaration to specify the trait. We call this a trait
    bound. The changes to the code are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个接受任何类型`T`的泛型函数无法默认知道或假设`T`上存在`init`方法。如果它确实存在，那么它就根本不是泛型，而只能接受具有`init()`方法上的类型。所以，有一种方法可以让我们让编译器知道这一点，并使用traits约束`load`可以接受的一组类型。这就是trait边界发挥作用的地方。我们可以定义一个名为`Loadable`的trait，并在我们的`Enemy`和`Hero`类型上实现它。随后，我们必须在我们的泛型类型声明旁边放置几个符号来指定trait。我们称这为trait边界。代码的更改如下：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this new code, we implement Loadable for both `Enemy` and `Hero` and we
    also modified the load method as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段新代码中，我们为`Enemy`和`Hero`都实现了`Loadable`，并且我们还按如下方式修改了`load`方法：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice the `: Loadable` part. This is how we specify a trait bound. Trait bounds
    allow us to constrain the range of parameters that a generic API can accept. Specifying
    a trait bound on a generic item is similar to how we specify types for variables,
    but here the variable is the generic type `T` and the type is some trait, such
    as `T: SomeTrait`. Trait bounds are almost always needed when defining generic
    functions. If one defines a generic function that takes `T` without any trait
    bounds, we cannot call any of the methods since Rust does not know what implementation
    to use for the given method. It needs to know whether `T` has the `foo` method
    or not to monomorphize the code. Take a look at another example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '注意`: Loadable`部分。这就是我们指定trait边界的做法。Trait边界允许我们约束泛型API可以接受的参数范围。在泛型项上指定trait边界类似于我们为变量指定类型，但在这里变量是泛型类型`T`，而类型是某个trait，例如`T:
    SomeTrait`。在定义泛型函数时，trait边界几乎是必需的。如果定义了一个没有任何trait边界的泛型函数，那么我们不能调用任何方法，因为Rust不知道为给定方法使用哪种实现。它需要知道`T`是否有`foo`方法，以便对代码进行单态化。看看另一个例子：'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have a method,  `add_thing`, that can add any type `T`. If we compile the
    preceding snippet, it does not compile and gives the following error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`add_thing`的方法，它可以添加任何类型`T`。如果我们编译前面的代码片段，它将无法编译并给出以下错误：
- en: '![](img/677a9ad2-011e-4d14-a6ff-adf0b2af2dc0.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/677a9ad2-011e-4d14-a6ff-adf0b2af2dc0.png)'
- en: 'It says to add a trait bound `Add` on `T`. The reason for this is that the
    addition operation is dictated by the `Add` trait, which is generic, and different
    types have different implementations that might even return a different type altogether.
    This means that Rust needs our help to annotate that for us. Here, we need to
    modify our function definition like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示在`T`上添加一个`Add` trait边界。这样做的原因是加法操作由`Add` trait决定，它是泛型的，不同类型有不同的实现，甚至可能返回完全不同的类型。这意味着Rust需要我们的帮助来为我们注解这一点。在这里，我们需要像这样修改我们的函数定义：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We added the `: Add` after `T` and with that change, our code compiles. Now,
    there are two ways to specify trait, bounds depending on how complex the type
    signature gets when defining generic items with trait bounds:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在`T`之后添加了`: Add`，随着这个更改，我们的代码可以编译了。现在，根据在定义带有trait边界的泛型项时类型签名变得有多复杂，有两种方式来指定trait和边界：'
- en: '**In-between generics**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型之间的操作**：'
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the most common syntax to specify trait bounds on generic items. We
    read the preceding function as follows `show_me` is a method that takes any type
    that implements the `Display` trait. This is the usual syntax used to declare
    the trait bound when the length of the type signature of the generic function
    is small. This syntax also works when specifying trait bounds on types. Now, let's
    look at the second way to specify trait bounds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指定泛型项上trait边界的最常见语法。我们读取前面的函数如下：`show_me`是一个接受任何实现了`Display`trait的类型的方法。这是在泛型函数的类型签名长度较小时声明trait边界的常用语法。此语法在指定类型上的trait边界时也适用。现在，让我们看看指定trait边界的第二种方式。
- en: '**Using where clauses:**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用where子句：**'
- en: 'This syntax is used when the type signature of any generic item becomes too
    large to fit on a line. For example, there is a `parse` method in the standard
    library''s `std::str` module, which has the following signature:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何泛型项的类型签名太大而无法在一行中显示时，使用此语法。例如，标准库的 `std::str` 模块中有一个 `parse` 方法，其签名如下：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice the `where F: FromStr` part. This tells us that our `F` type must implement
    the `FromStr` trait. The `where` clause decouples the trait bound from the function
    signature and makes it readable.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到 `where F: FromStr` 部分。这告诉我们我们的 `F` 类型必须实现 `FromStr` 特性。`where` 子句将特征界限从函数签名中解耦，使其易于阅读。'
- en: Having seen how to write trait bounds, it's important to know where can we specify
    these bounds. Trait bounds are applicable in all of the places where you can use
    generics.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 看过如何编写特征界限后，了解我们可以在哪里指定这些界限是很重要的。特征界限适用于所有可以使用泛型的地方。
- en: Trait bounds on types
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型上的特征界限
- en: 'We can specify trait bounds on types too:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在类型上指定特征界限：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, trait bounds on types are discouraged as it places restrictions on
    types themselves. Generally, we want types to be as generic as possible, allowing
    us to create instances using any type, and instead place restrictions on their
    behavior using traits bounds in functions or methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对类型使用特征界限是不推荐的，因为它对类型本身施加了限制。通常，我们希望类型尽可能泛化，允许我们使用任何类型创建实例，并且通过在函数或方法中使用特征界限来限制它们的行为。
- en: Trait bounds on generic functions and impl blocks
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型函数和 impl 块上的特征界限
- en: 'This is the most common place where trait bounds are used. We can specify trait
    bounds on functions and also on generic implementations, as shown in the following
    example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的使用特征界限的地方。我们可以在函数上指定特征界限，也可以在泛型实现上指定，如下面的示例所示：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have a generic type `Food` and a specific food type `Apple` that we put into
    a `Food` instance and bind to variable `apple`. Next, we call the generic method
    `eat`, passing `apple`. Looking at the signature of `eat`, the type `T` has to
    be `Eatable`. To make `apple` eatable, we implement the `Eatable` trait for `Food`,
    also specifying that our type has to be `Debug` to make it printable to the console
    inside our method. This is a dumb example but demonstrates the idea.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个泛型类型 `Food` 和一个特定的食物类型 `Apple`，我们将它放入 `Food` 实例中，并将其绑定到变量 `apple`。接下来，我们调用泛型方法
    `eat`，传递 `apple`。查看 `eat` 方法的签名，类型 `T` 必须是 `Eatable`。为了使 `apple` 可食用，我们为 `Food`
    实现了 `Eatable` 特性，并指定我们的类型必须是 `Debug` 以使其可以在我们的方法中打印到控制台。这是一个愚蠢的例子，但演示了这一概念。
- en: Using + to compose traits as bounds
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `+` 符号组合特征界限
- en: 'We can also specify multiple trait bounds to a generic type using the `+` symbol.
    Let''s take a look at the impl block for the `HashMap` type from the standard
    library:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `+` 符号为泛型类型指定多个特征界限。让我们看看标准库中 `HashMap` 类型的 impl 块：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we can see that `K`, denoting the type of the `HashMap` key, has to implement
    the `Eq` trait, as well as the `Hash` trait.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `K`，表示 `HashMap` 键的类型，必须实现 `Eq` 特性，以及 `Hash` 特性。
- en: 'We can also combine traits to create a new trait, that represents all of them:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合特性来创建一个新的特性，代表所有这些特性：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, we created a new trait `Programmer`, that is a composition
    of three traits, `Eat` `Code` and `Sleep`. In this way, we have put constraints
    on the type, so that if a type `T` implements `Programmer`, it has to implement
    all the other traits. Running the code produces the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个新的特性 `Programmer`，它是三个特性 `Eat`、`Code` 和 `Sleep` 的组合。这样，我们对类型施加了约束，因此如果类型
    `T` 实现 `Programmer`，它必须实现所有其他特性。运行代码产生以下输出：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Trait bounds with impl trait syntax
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 impl 特性语法的特征界限
- en: 'The other syntax for declaring trait bounds is the impl trait syntax, which
    is a recent addition to the compiler. Using this syntax, you can also write a
    generic function with trait bounds like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 声明特征界限的另一种语法是 impl 特性语法，这是编译器最近添加的一个特性。使用这种语法，您也可以编写具有特征界限的泛型函数，如下所示：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Instead of specifying `T: Display`, we directly use `impl Display`. This is
    the impl trait syntax. This provides advantages in cases where we want to return
    a complex or unrepresentable type, such as a closure from a function. Without
    this syntax, you had to return it by putting it behind a pointer using the `Box`
    smart pointer type, which involves heap allocation. Closures under the hood are
    implemented as structs that implement a family of traits. One of these traits
    is the `Fn(T) -> U` trait. So, using the impl trait syntax, it''s now possible
    to write functions where we can write something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不是指定`T: Display`，而是直接使用`impl Display`。这是`impl`特质语法。在需要返回复杂或无法表示的类型的情况下，例如从函数返回闭包，这提供了优势。如果没有这种语法，你必须通过使用`Box`智能指针类型将其放在指针后面来返回它，这涉及到堆分配。闭包在底层被实现为实现了多个特质的结构体。其中一个是`Fn(T)
    -> U`特质。因此，使用`impl`特质语法，现在我们可以编写函数，在其中我们可以写出如下内容：'
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, we created a function, `lazy_adder`, that takes in two
    numbers and returns a closure that adds two numbers. We then call `lazy_adder`,
    passing in two numbers. This creates a closure in `add_later` but does not evaluate
    it. In `main`, we called `add_later` in the `println!` macro. We can even have
    this syntax in both places, like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个函数，名为`lazy_adder`，它接受两个数字并返回一个闭包，该闭包可以将两个数字相加。然后我们调用`lazy_adder`，传入两个数字。这将在`add_later`中创建一个闭包，但不会立即执行它。在`main`中，我们在`println!`宏中调用了`add_later`。我们甚至可以在两个地方都使用这种语法，如下所示：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`surround_with_braces` takes in anything that is `Display` and returns a string
    surrounded with `{}`. Here, both our return types are `impl Display`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`surround_with_braces`接受任何实现了`Display`特质的类型，并返回一个被`{}`包围的字符串。在这里，我们的返回类型都是`impl
    Display`。'
- en: The extra braces are there to escape the brace itself, as `{}` has a special
    meaning in string formatting for string interpolation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 多余的大括号是用来避免大括号本身的特殊含义，因为在字符串格式化中`{}`有特殊的字符串插值意义。
- en: The impl trait syntax for trait bounds is mostly recommended to be used as return
    types from functions. Using it in parameter position means that we can't use the
    turbofish operator. This can cause API incompatibility if some dependent code
    uses the turbofish operator to invoke one of your crate's methods. It should only
    be used when we don't have a concrete type available to us, as is the case with
    closures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特质界限的`impl`语法，主要推荐用作函数的返回类型。在参数位置使用它意味着我们无法使用turbofish运算符。如果某些依赖代码使用turbofish运算符调用你的crate中的某个方法，这可能会导致API不兼容。它只应在没有具体类型可用的情况下使用，例如闭包的情况。
- en: Exploring standard library traits
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索标准库特质
- en: Rust's standard library has a lot of built-in traits. Most of the syntatic sugar
    in Rust is due to traits. These traits also provide a nice baseline upon which
    crate authors can provide an idiomatic interface to their libraries. In this section,
    we'll explore some of the abstractions and conveniences of the standard library
    traits that enhance the experience for a crate author and the consumer. We'll
    base our exploration from a library author's perspective and create a library
    that provides support for complex number types. This example serves well to introduce
    the common traits you have to implement if you are creating a crate of your own.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的标准库中有很多内置的特质。Rust中的大部分语法糖都归因于特质。这些特质还为crate作者提供了一个很好的基线，他们可以在其库上提供一个惯用的接口。在本节中，我们将探讨标准库特质的一些抽象和便利之处，这些特质可以增强crate作者和消费者的体验。我们将从库作者的视角出发，创建一个提供复杂数字类型支持的库。这个例子很好地介绍了如果你创建自己的crate时必须实现的常见特质。
- en: 'We''ll create a new project by running `cargo new complex --lib`. To start
    with, we need to represent our complex number as a type. We''ll use a struct for
    this. Our complex number struct has two fields: the *real* and *imaginary* part
    of a complex number. Here''s how we have defined it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过运行`cargo new complex --lib`来创建一个新的项目。首先，我们需要将我们的复杂数字表示为一个类型。我们将使用一个结构体来完成这个任务。我们的复杂数字结构体有两个字段：复杂数字的*实部*和*虚部*。以下是它的定义方式：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're making it generic over `T`, as `re` and `im` can both be a float or an
    integer value. For this type to be of any use, we want ways to create instances
    of it. The usual way to do this is to implement the associated method `new`, where
    we pass the values for `re` and `im`. What if we also wanted to initialize a complex
    value with defaults (say `re = 0`, `im = 0`) ? For this, we have a trait called
    `Default`. Implementing `Default` is very simple for a user-defined type; we can
    just put a `#[derive(Default)]` attribute over the `Complex` structure to automatically
    implement the `Default` trait for it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使其泛型化于`T`，因为`re`和`im`都可以是浮点数或整数值。为了使这种类型有任何用途，我们希望有创建其实例的方法。通常的做法是实现关联方法`new`，其中我们传递`re`和`im`的值。如果我们还想用默认值（比如`re
    = 0`，`im = 0`）初始化一个复数值怎么办？为此，我们有一个名为`Default`的特性。对于用户定义的类型，实现`Default`非常简单；我们只需在`Complex`结构体上放置一个`#[derive(Default)]`属性，就可以自动为它实现`Default`特性。
- en: 'Note: `Default` can only be implemented for structs, enums, or unions whose
    members and fields themselves implement `Default`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`Default`只能为那些其成员和字段本身实现`Default`的结构体、枚举或联合体实现。
- en: 'Now, our updated code with the method `new` and the `Default` annotation looks
    like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的更新代码带有`new`方法和`Default`注解，看起来是这样的：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We also added a simple initialization test case at the bottom under the `tests`
    module. The `#[derive(Default)]` attribute functionality is implemented as a procedural
    macro that can automatically implement traits for the type on which it appear.
    This auto-deriving requires that the fields of any custom type, such as a struct
    or an enum, also implement the `Default` trait themselves. Deriving a trait using
    them is only applicable to structs, enums, and unions. We'll look at how to write
    our own deriving procedural macros in Chapter 9, *Metaprogramming with Macros*.
    Also, the function `new` is not really a special constructor function (if you
    are familiar with languages with constructors), but just a conventional name adopted
    by the community as a method name to create new instances of types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`tests`模块底部添加了一个简单的初始化测试用例。`#[derive(Default)]`属性的功能是通过一个过程宏实现的，它可以自动为出现的类型实现特性。这种自动推导要求任何自定义类型的字段，如结构体或枚举，也必须自己实现`Default`特性。使用它们推导特性仅适用于结构体、枚举和联合体。我们将在第9章“使用宏进行元编程”中查看如何编写自己的推导过程宏。此外，函数`new`并不是一个特殊的构造函数（如果你熟悉具有构造函数的语言），而只是一个社区采用的常规名称，用作创建类型新实例的方法名。
- en: 'Now, before we get into more complex trait implementations, we need to auto-derive
    some more built-in traits that will help us implement more high-level functionality.
    Let''s look at some of them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们深入研究更复杂的特性实现之前，我们需要自动推导一些更多的内置特性，这将帮助我们实现更高级的功能。让我们看看其中的一些：
- en: '`Debug`: We have already seen this before. As the name suggests, this trait
    helps types to be printed on the console for debugging purposes. In the case of
    a composite type, the types will be printed in a JSON-like format with braces
    and parentheses, and quotes if the type is a string. This is implemented for most
    built-in types in Rust.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug`: 我们之前已经见过这个了。正如其名所示，这个特性帮助类型在控制台上以调试为目的进行打印。在复合类型的情况下，类型将以类似JSON的格式打印，包含花括号和括号，如果类型是字符串，则包含引号。这在Rust中的大多数内置类型中都已实现。'
- en: '`PartialEq` and `Eq`: These traits allow two items to be compared to each other
    for equality. For our complex type, only `PartialEq` makes sense, because when
    our complex type contains `f32` or `f64` values, we cannot compare them since `Eq`
    is not implemented for `f32` and `f64` values. `PartialEq` defines partial ordering.
    whereas `Eq` requires a total ordering, Total ordering is undefined for floats,
    as `NaN` is not equal to `NaN`.  `NaN` is a type in floating point types that
    represents an operation whose result is undefined, such as `0.0 / 0.0`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PartialEq`和`Eq`：这些特性允许两个项目进行比较以确定它们是否相等。对于我们的复数类型，只有`PartialEq`是有意义的，因为当我们的复数类型包含`f32`或`f64`值时，我们无法比较它们，因为`Eq`没有为`f32`和`f64`值实现。`PartialEq`定义了部分排序，而`Eq`要求完全排序。对于浮点数，完全排序是未定义的，因为`NaN`不等于`NaN`。"NaN"是浮点数类型中的一个类型，它表示结果未定义的操作，例如`0.0
    / 0.0`。'
- en: '`Copy` and `Clone`: These traits define how types get duplicated. We have a
    separate section for them in [Chapter 6](db2c2723-8ca0-43be-b135-afd847342146.xhtml),
    *Memory Management and Safety*. In brief, when auto-derived on any custom type,
    these traits allow you to create a new copy from the instance, either implicitly
    when `Copy` is implemented or explicitly by calling `clone()` on them when `Clone`
    is implemented. Please note that the `Copy` trait depends on `Clone` being implemented
    on types.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Copy`和`Clone`：这些特质定义了类型如何被复制。我们在[第6章](db2c2723-8ca0-43be-b135-afd847342146.xhtml)中有一个单独的部分来介绍它们，*内存管理和安全性*。简而言之，当在任何自定义类型上自动推导时，这些特质允许你从实例创建一个新的副本，无论是当`Copy`被实现时隐式地，还是当`Clone`被实现时通过调用`clone()`来显式地。请注意，`Copy`特质依赖于类型上实现了`Clone`。'
- en: 'With those explanations out of the way, we''ll add auto-derives for these built-in
    traits, like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些解释之后，我们将为这些内置特质添加自动推导，如下所示：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let''s enhance our `Complex<T>` type more so that we have better ergonomics
    in terms of its use. Some additional traits we''ll implement (in no particular
    order) are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们增强我们的`Complex<T>`类型，以便在使用方面有更好的用户体验。我们将实现的一些额外特质（不分先后）如下：
- en: The `Add` trait from the `std::ops` module ,which will let us use the `+` operator
    to add `Complex` types
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`std::ops`模块的`Add`特质，它将使我们能够使用`+`运算符来添加`Complex`类型
- en: The `Into` and `From` traits from the `std::convert` module ,which will give
    us the ability to create `Complex` types from other types
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`std::convert`模块的`Into`和`From`特质，它将赋予我们从其他类型创建`Complex`类型的能力
- en: The `Display` trait, will let us print a human readable version of our `Complex`
    type
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Display`特质将使我们能够打印出我们`Complex`类型的人类可读版本'
- en: 'Let''s start with the implementation of the `Add` trait. It is documented at
    [https://doc.rust-lang.org/std/ops/trait.Add.html](https://doc.rust-lang.org/std/ops/trait.Add.html),
    and the trait is declared like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Add`特质的实现开始。它在[https://doc.rust-lang.org/std/ops/trait.Add.html](https://doc.rust-lang.org/std/ops/trait.Add.html)有文档说明，特质的声明如下：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s go through it line by line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析它：
- en: '`pub trait Add<RHS = Self>` says that `Add` is a trait that has a generic type, `RHS`,
    that is set to `Self` by default. Here, `Self` is an alias for the type that implements
    this trait, which is `Complex` in our case. It''s a convenient way to refer to
    the implementer within the trait.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pub trait Add<RHS = Self>`表示`Add`是一个具有泛型类型`RHS`的特质，默认设置为`Self`。在这里，`Self`是一个别名，用于在特质内部引用实现者，在我们的例子中是`Complex`。这是一个在特质内部引用实现者的方便方式。'
- en: '`Output` is an associated type that the implementer needs to declare.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Output`是一个需要由实现者声明的关联类型。'
- en: '`fn add(self, rhs: RHS) -> Self::Output` is the core functionality that''s
    provided by the `Add` trait and is the method that gets invoked whenever we use
    `+` operator between two implementing types. It''s an instance method, takes `self`
    by value and takes in an `rhs` as a parameter, which is `RHS` in the trait definition.
    In our case, the left-hand side and the right-hand side around the `+` operator
    are of the same type by default, but `RHS` can be changed to any other type when
    we are writing impl blocks. For example, we can have an implementation that adds
    the `Meter` and `Centimeter` types. In that case, we''ll write `RHS=Centimeter`
    in our impl block. Finally, it says that the `add` method must return the `Output`
    type that we declared on the second line with the `Self::Output` syntax.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn add(self, rhs: RHS) -> Self::Output`是`Add`特质提供的核心功能，并且是每次我们在两个实现类型之间使用`+`运算符时调用的方法。它是一个实例方法，通过值传递`self`，并接受一个参数`rhs`，在特质定义中为`RHS`。在我们的例子中，`+`运算符两边的左右手边默认为同一类型，但当我们编写`impl`块时，`RHS`可以被更改为任何其他类型。例如，我们可以有一个实现，它将`Meter`和`Centimeter`类型相加。在这种情况下，我们将在我们的`impl`块中写`RHS=Centimeter`。最后，它表示`add`方法必须返回我们在第二行用`Self::Output`语法声明的`Output`类型。'
- en: 'OK, let''s try implementing this. Here''s the code, along with the tests:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尝试实现它。以下是代码，以及相应的测试：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s dig into the `impl` block for `Complex<T>`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入到`Complex<T>`的`impl`块：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The impl block for `Add` seems more complex. Let''s go through this piece by
    piece:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`的`impl`块看起来更复杂。让我们逐个分析：'
- en: 'The `impl<T: Add<T, Output=T>` part says that we are implementing `Add` for
    a generic type `T`, where `T` implements `Add<T, Output=T>`. The `<T, Output=T>`
    part says that the implementation of the `Add` trait must have the same input
    and output types.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`impl<T: Add<T, Output=T>>`部分表示我们正在为泛型类型`T`实现`Add`，其中`T`实现了`Add<T, Output=T>`。`<T,
    Output=T>`部分表示`Add`特质的实现必须具有相同的输入和输出类型。'
- en: '`Add for Complex<T>` says that we are implementing the `Add` trait for the `Complex<T>` type.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add for Complex<T>` 表示我们正在为 `Complex<T>` 类型实现 `Add` 特质。'
- en: '`T: Add` has to implement the `Add` trait. If it doesn''t, we can''t use the
    `+` operator on it.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T: Add` 必须实现 `Add` 特质。如果不实现，我们就不能在它上面使用 `+` 操作符。'
- en: Then comes the `From` trait. It would be convenient if we could also construct
    `Complex` types from a built-in primitive type such as a two-element tuple, where
    the first element is the real part and the second is the imaginary part. We can
    do this by implementing the `From` trait. This trait defines a `from` method,
    giving us a general way to do conversions between types. Its documentation can
    be found at [https://doc.rust-lang.org/std/convert/trait.From.html](https://doc.rust-lang.org/std/convert/trait.From.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `From` 特质。如果我们能够从内置的原始类型（如包含实部和虚部的两个元素的元组）构建 `Complex` 类型，那将很方便。我们可以通过实现
    `From` 特质来实现这一点。这个特质定义了一个 `from` 方法，为我们提供了在类型之间进行转换的通用方式。它的文档可以在 [https://doc.rust-lang.org/std/convert/trait.From.html](https://doc.rust-lang.org/std/convert/trait.From.html)
    找到。
- en: 'Here''s the trait definition:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是特质定义：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is a bit simpler than the previous one. It''s a generic trait, where `T`
    specifies what type to convert from. When we implement this, we just need to substitute
    the `T` with the type we want to implement it for and implement the `from` method.
    Then, we can use the method on our type. Here''s an implementation that converts
    our `Complex` value into a two-element tuple type, which is natively known to
    Rust:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前的要简单一些。它是一个泛型特质，其中 `T` 指定了要转换的类型。当我们实现它时，我们只需要用我们想要实现它的类型替换 `T` 并实现 `from`
    方法。然后，我们就可以在我们的类型上使用这个方法。以下是一个将我们的 `Complex` 值转换为两个元素的元组类型的实现，这是 Rust 中原生已知的：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s look at the `impl` line for this one. This is similar to the `Add` trait,
    except that we don''t have to constrain our generic by any special output type,
    since `From` does not have that:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个的 `impl` 行。这与 `Add` 特质类似，但不同之处在于我们不需要通过任何特殊的输出类型来约束我们的泛型，因为 `From` 没有这个要求：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first `<T>` is a declaration of the generic type `T`, and the second and
    third are the uses of it. We are creating it from a `(T, T)` type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `<T>` 是泛型类型 `T` 的声明，第二个和第三个是它的使用。我们是从 `(T, T)` 类型创建它的。
- en: 'Finally, to be able to let the users view the complex type as in mathematical
    notation, we should implement the `Display` trait. It''s documented at [https://doc.rust-lang.org/std/fmt/trait.Display.html](https://doc.rust-lang.org/std/fmt/trait.Display.html),
    and here''s the trait''s type signature:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了能让用户以数学符号的形式查看复杂类型，我们应该实现 `Display` 特质。它在 [https://doc.rust-lang.org/std/fmt/trait.Display.html](https://doc.rust-lang.org/std/fmt/trait.Display.html)
    中有文档说明，以下是特质的类型签名：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following code shows the implementation of `Display` for the `Complex<T>`
    type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `Complex<T>` 类型的 `Display` 实现：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Display` trait has an `fmt` method, which takes in a `Formatter` type that
    we write into using the `write!` macro. Like before, because our `Complex<T>`
    type uses a generic type for both the `re` and `im` fields, we need to specify
    that it also must satisfy the `Display` trait.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display` 特质有一个 `fmt` 方法，它接受一个 `Formatter` 类型，我们使用 `write!` 宏将其写入。像之前一样，因为我们的
    `Complex<T>` 类型同时使用泛型类型 `re` 和 `im` 字段，我们需要指定它也必须满足 `Display` 特质。'
- en: 'Running `cargo test -- --nocapture`, we get the following output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `cargo test -- --nocapture`，我们得到以下输出：
- en: '![](img/931da4d9-fcd8-4c68-aaaf-2f87d58dfb61.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/931da4d9-fcd8-4c68-aaaf-2f87d58dfb61.png)'
- en: We can see that our complex type is printed in a readable format as `2345 +
    456i` and that all of our tests are green. Next, let's look at the idea of polymorphism
    and how Rust traits model this.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的复杂数型以可读的格式 `2345 + 456i` 打印出来，并且所有的测试都是绿色的。接下来，让我们看看多态的概念以及 Rust 特质如何建模这一点。
- en: True polymorphism using trait objects
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特质对象实现真正的多态
- en: Rust allows a true form of polymorphism through special forms of types implementing
    a trait. These are known as *trait objects*. Before we explain how Rust achieves
    polymorphism using trait objects, we need to understand the idea of **dispatch**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 通过特殊形式的类型实现特质，允许一种真正的多态形式。这些被称为 *特质对象*。在我们解释 Rust 如何使用特质对象实现多态之前，我们需要理解
    **分发** 的概念。
- en: Dispatch
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发
- en: 'Dispatch is a concept that emerged from the object-oriented programming paradigm,
    mainly in the context of one of its features called polymorphism. In the context
    of OOP, when APIs are generic or take parameters implementing an interface, it
    here has to figure out what method implementation to invoke on an instance of
    a type that''s passed to the API. This process of method resolution in a polymorphic
    context is called **dispatch**, and invoking the method is called dispatching.
    In mainstream languages that support polymorphism, the dispatch may happen in
    either of the following ways:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 分发是从面向对象编程范式中的一个概念出现的，主要是在其一个称为多态的特征的上下文中。在OOP的上下文中，当API是泛型或接受实现接口的参数时，它必须确定在传递给API的类型实例上调用哪个方法实现。在多态上下文中进行的方法解析过程称为**分发**，调用方法称为分发。在支持多态的主流语言中，分发可能以下列两种方式之一发生：
- en: '**Static dispatch:** When the method to invoke is decided at compile time,
    it is known as static dispatch or early binding. The method''s signature is used
    to decide the method to call, and all of this is decided at compile time. In Rust,
    generics exhibit this form of dispatch because even though the generic function
    can accept many arguments, a specialized copy of the function is generated at
    compile time with that concrete type.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态分发**：当要调用的方法在编译时确定时，它被称为静态分发或早期绑定。使用方法的签名来决定要调用的方法，所有这些都是在编译时决定的。在Rust中，泛型表现出这种分发形式，因为尽管泛型函数可以接受许多参数，但在编译时会产生一个具有该具体类型的函数的专用副本。'
- en: '**Dynamic dispatch:** In object-oriented languages, there are times when the
    method call can''t be decided until runtime. This is because the concrete type
    is hidden and only interface methods are available to call on the type. In Java,
    this is the case when a function has an argument, which is known as an **interface**.
    Such a scenario can only be handled by dynamic dispatch. In dynamic dispatch,
    the method is determined dynamically by navigating through the list of implementations
    of the interface from the `vtable` and invoking the method. The `vtable` is a
    list of function pointers that point to each type''s implemented method. This
    has a bit of overhead because of the extra pointer indirection in method invocation.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态分发**：在面向对象的语言中，有时方法调用只能在运行时决定。这是因为具体类型是隐藏的，只有接口方法可以调用。在Java中，当一个函数有一个参数时，这种情况就出现了，这个参数被称为**接口**。这种场景只能通过动态分发来处理。在动态分发中，方法通过遍历接口的实现列表从`vtable`中动态确定，并调用该方法。`vtable`是一个指向每个类型实现方法的函数指针列表。这因为方法调用中额外的指针间接引用而有一些开销。'
- en: Let's explore trait objects next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来探索特性对象。
- en: Trait objects
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性对象
- en: Now, up until this point, we have mostly seen traits being used in a static
    dispatch context, where we specified trait bounds in generic APIs. However, we
    also have another way to create polymorphic APIs, where we can specify parameters
    as something that implements a trait rather than a generic or a concrete type.
    This form of type, specified as implementing a trait API, is known as a trait
    object. Trait objects are similar to C++ virtual methods. A trait object is implemented
    as a fat pointer and is an unsized type, which means that they can only be used
    behind references (`&`). We explain unsized types in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. A trait object fat pointer has the first pointer pointing points
    to the actual data associated with the object while the second pointer to a virtual
    table (vtable), which is a structure holding one function pointer per method for
    the object, at a fixed offset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直到这一点，我们主要看到特性被用于静态分发上下文中，我们在泛型API中指定了特性界限。然而，我们还有另一种创建多态API的方法，其中我们可以指定参数为实现了特性而不是泛型或具体类型的东西。这种类型，指定为实现了特性API，被称为特性对象。特性对象类似于C++的虚方法。特性对象实现为一个胖指针，是一个无大小类型，这意味着它们只能用于引用（`&`）之后。我们在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，*高级概念*中解释了无大小类型。特性对象的胖指针的第一个指针指向与对象关联的实际数据，而第二个指针指向一个虚表（vtable），这是一个结构，为对象的每个方法持有固定偏移量处的函数指针。
- en: 'Trait objects are Rust''s way of performing dynamic dispatch where we don''t
    have the actual concrete type information. Method resolution is done by hopping
    down to the vtable and invoking the appropriate method. One of the use cases for
    trait objects is that they allow you to operate on a collection that can have
    multiple types, but with an extra pointer indirection at runtime. To illustrate
    this, consider the following program:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 特性对象是 Rust 执行动态分派的方式，其中我们没有实际的实体类型信息。方法解析是通过跳转到 vtable 并调用适当的方法来完成的。特性对象的一个用例是，它们允许你在可以具有多个类型的集合上操作，但在运行时有一个额外的指针间接引用。为了说明这一点，考虑以下程序：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the elements of shapes are of type `&dyn Area`, a type that
    is represented as a trait. The trait object is represented by `dyn Area`, denoting
    that it's a pointer to some implementation of the `Area` trait. A type in the
    form of a trait object allows you to store different types within a collection
    type such as `Vec`. In the preceding example, `Square` and `Rectangle` were converted
    into trait objects implicitly because we pushed a reference to them. We can also
    make a type, a trait object by casting it manually. This is an advanced case,
    though, and is used when the compiler cannot cast the type as a trait object by
    itself. Do note that we can only create trait objects of types whose sizes we
    know at compile time. A `dyn Trait` is an unsized type and can only be created
    as a reference. We can also create trait objects by putting them behind other
    pointer types such as `Box`, `Rc`, `Arc`, and so on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，形状的元素类型为 `&dyn Area`，这是一种表示为特性的类型。特性对象通过 `dyn Area` 表示，表示它是指向 `Area` 特性某个实现的指针。以特性对象形式存在的类型允许你在集合类型（如
    `Vec`）中存储不同的类型。在前面的例子中，`Square` 和 `Rectangle` 被隐式转换为特性对象，因为我们向它们推送了引用。我们还可以通过手动转换来使类型成为特性对象。这是一个高级案例，并且仅在编译器无法自行将类型转换为特性对象时使用。请注意，我们只能创建在编译时已知大小的类型的特性对象。`dyn
    Trait` 是一个无大小类型，只能作为引用创建。我们还可以通过将它们放在其他指针类型（如 `Box`、`Rc`、`Arc` 等）之后来创建特性对象。
- en: In the older Rust 2015 edition, trait objects are referred to as just the name
    of the trait, for a trait object `dyn Foo` , it is represented as `Foo`. This
    syntax is confusing and it deprecated in the latest 2018 edition.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧的 Rust 2015 版本中，特性对象仅被称为特性的名称，对于一个特性对象 `dyn Foo`，它被表示为 `Foo`。这种语法很令人困惑，并且在最新的
    2018 版本中已被弃用。
- en: 'In the following code, we are illustrating the use of `dyn Trait` as a parameters
    in functions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们展示了如何将 `dyn Trait` 作为函数的参数使用：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Traits, along with generics, provide both kinds of code reuse, either through
    monomorphization (early binding) or through runtime polymorphism (late binding).
    The decision on when to use which depends on the context and the needs of the
    application in question. Often, error types are taken toward the dynamic dispatch
    train as they are supposed to be code paths that rarely get executed. Monomorphization
    can be handy for small use cases, but the downside to it is that it introduces
    code bloat and duplication, which affects the cache line and increases binary
    size. However, of these two options, static dispatch should be preferred unless
    there is a hard constraint on binary size.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 特性，连同泛型一起，提供了两种代码复用方式，要么通过单态化（早期绑定）要么通过运行时多态（晚期绑定）。何时使用哪种方式取决于上下文和所讨论的应用需求。通常，错误类型会被倾向于动态分派，因为它们被认为是很少被执行的代码路径。单态化对于小型用例来说可能很有用，但它的缺点是引入了代码膨胀和重复，这影响了缓存行并增加了二进制文件大小。然而，在这两种选项中，除非有对二进制文件大小的硬性约束，否则静态分派应该是首选的。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Types are one of the most beautiful aspects of any statically typed language.
    They allow you to express so much at compile time. This chapter might not be the
    most advanced in this book, but the content was probably the heaviest. We now
    have a working knowledge of the different ways to reuse code. We also got to know
    about the mighty traits and how Rust's standard library makes heavy use of them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是任何静态类型语言最美丽的方面之一。它们允许你在编译时表达很多内容。本章可能不是本书中最先进的章节，但内容可能是最重的。我们现在对代码的不同复用方式有了实际了解。我们还了解了强大的特性以及
    Rust 标准库如何大量使用它们。
- en: In the next chapter, we'll learn about how programs use memory and how Rust
    provides compile-time memory management.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习程序如何使用内存以及 Rust 如何提供编译时内存管理。
