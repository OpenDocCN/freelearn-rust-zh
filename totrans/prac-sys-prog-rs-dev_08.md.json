["```rs\nrustc --version \ncargo --version\n```", "```rs\n    int open() system call. An example of a flag is O_CREAT, which tells the system call to create a file if the file does not exist, and returns the file descriptor.If there is an error in opening a file, `-1` is returned in place of the file descriptor, and the error number (`errno`) returned specifies the reason for the error. File open calls can fail for a variety of reasons including a *permissions error* and the *incorrect path* being specified in an argument to a system call.\n    ```", "```rs\n    use std::fs::File;\n    fn main() {\n        let file = File::create(\"./stats.txt\");\n    }\n    ```", "```rs\n    use std::fs::File;\n    use std::fs::OpenOptions;\n    fn main() {\n        // Method 1\n        let _file1 = File::open(\"stats1.txt\").expect(\"File \n            not found\");\n        // Method 2\n        let _file2 = OpenOptions::new()\n            .write(true)\n            .create(true)\n            .open(\"stats2.txt\");\n    }\n    ```", "```rs\n    use std::fs;\n    fn main() {\n        fs::copy(\"stats1.txt\", \"stats2.txt\").expect(\"Unable \n            to copy\");\n    }\n    ```", "```rs\n    use std::fs;\n    fn main() {\n        fs::rename(\"stats1.txt\", \"stats3.txt\").expect(\"Unable \n            to rename\");\n    }\n    ```", "```rs\n    use std::fs;\n    fn main() {\n        let byte_arr = fs::read(), we convert the byte_arr into a string for printing purposes, as printing out a byte array is not human-readable.\n    ```", "```rs\n    use std::fs;\n    fn main() {\n        fs::write(\"stats3.txt\", \"Rust is exciting,isn't \n    it?\").expect(\"Unable to write to file\");\n    }\n    ```", "```rs\n    use std::fs;\n    fn main() {\n        let file_metadata = fs::metadata(\"stats.txt\").\n            expect(\"Unable to get file metadata\");\n        println!(\n            \"Len: {}, last accessed: {:?}, modified : {:?}, \n            created: {:?}\",\n            file_metadata.len(),\n            file_metadata.accessed(),\n            file_metadata.modified(),\n            file_metadata.created()\n        );\n        println!(\n            \"Is file: {}, Is dir: {}, is Symlink: {}\",\n            file_metadata.is_file(),\n            file_metadata.is_dir(),\n            file_metadata.file_type().is_symlink()\n        );\n      println!(\"File metadata: {:?}\",fs::metadata\n          (\"stats.txt\"));\n        println!(\"Permissions of file are: {:?}\", \n            file_metadata.permissions());\n    }\n    ```", "```rs\n    use std::fs;\n    fn main() {\n        let mut permissions = fs::metadata(\"stats.txt\").\n            unwrap().permissions();\n        permissions.set_readonly(true);\n        let _ = fs::set_permissions(\"stats.txt\", \n            permissions).expect(\"Unable to set permission\");\n\n        fs::write(\"stats.txt\", \"Hello- Can you see me?\").\n            expect(\"Unable to write to file\");\n    }\n    ```", "```rs\n    use std::fs;\n    use std::path::Path;\n    fn main() {\n        let dir_entries = fs::read_dir(\".\").expect(\"Unable to \n            read directory contents\");\n        // Read directory contents\n        for entry in dir_entries {\n            //Get details of each directory entry\n            let entry = entry.unwrap();\n            let entry_path = entry.path();\n            let entry_metadata = entry.metadata().unwrap();\n            let entry_file_type = entry.file_type().unwrap();\n            let entry_file_name = entry.file_name();\n            println!(\n                \"Path is {:?}.\\n Metadata is {:?}\\n File_type \n                is {:?}.\\n Entry name is{:?}.\\n\",\n                entry_path, entry_metadata, entry_file_type, \n                entry_file_name\n            );\n        }\n        // Get path components\n        let new_path = Path::new(\"/usr/d1/d2/d3/bar.txt\");\n        println!(\"Path parent is: {:?}\", new_path.parent());\n        for component in new_path.components() {\n            println!(\"Path component is: {:?}\", component);\n        }\n    }\n    ```", "```rs\n    use std::fs::DirBuilder;\n    fn main() {\n        let dir_structure = \"/tmp/dir1/dir2/dir3\";\n        DirBuilder::new()\n            .recursive(true)\n            .create(dir_structure)\n            .unwrap();\n    }\n    ```", "```rs\n    use std::path::PathBuf;\n    fn main() {\n        let mut f_path = PathBuf::new();\n        f_path.push(r\"/tmp\");\n        f_path.push(\"packt\");\n        f_path.push(\"rust\");\n        f_path.push(\"book\");\n        f_path.set_extension(\"rs\");\n        println!(\"Path constructed is {:?}\", f_path);\n    }\n    ```", "```rs\n    use std::fs;\n    fn main() -> std::io::Result<()> {\n        fs::hard_link(\"stats.txt\", \"./statsa.txt\")?; // Hard \n                              // link stats.txt to statsa.txt\n        Ok(())\n    }\n    ```", "```rs\n    use std::fs;\n    use std::os::unix::fs as fsunix;\n    fn main() {\n        fsunix::symlink(\"stats.txt\", \"sym_stats.txt\").\n            expect(\"Cannot create symbolic link\");\n        let sym_path = fs::read_link(\"sym_stats.txt\").\n            expect(\"Cannot read link\");\n        println!(\"Link is {:?}\", sym_path);\n    }\n    ```", "```rs\n cargo run --release -- -m src .\n```", "```rs\nSummary stats: SrcStats { number_of_files: 7, loc: 187, comments: 8, blanks: 20 }\n```", "```rs\n    cargo new rstat && cd rstat\n    ```", "```rs\n    cargo build --release\n    ```", "```rs\n     rstat binary to the path, and set LD_LIBRARY PATH to run the shell command like this:\n\n    ```", "```rs\n    export LD_LIBRARY_PATH=$(rustc --print sysroot)/lib:$LD_LIBRARY_PATH\n    ```", "```rs\n\n    ```", "```rs\nuse std::fmt;\nuse std::io;\n\n#[derive(Debug)]\npub struct StatsError {\n    pub message: String,\n}\n\nimpl fmt::Display for StatsError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), \n        fmt::Error> {\n        write!(f, \"{}\", self)\n    }\n}\n```", "```rs\nimpl From<&str> for StatsError {        <1>\n    fn from(s: &str) -> Self {\n        StatsError {\n            message: s.to_string(),\n        }\n    }\n}\nimpl From<io::Error> for StatsError {    <2>\n    fn from(e: io::Error) -> Self {\n        StatsError {\n            message: e.to_string(),\n        }\n    }\n}\nimpl From<std::num::TryFromIntError> for StatsError {   <3>\n    fn from(_e: std::num::TryFromIntError) -> Self {\n        StatsError {\n            message: \"Number conversion error\".to_string(),\n        }\n    }\n}\n```", "```rs\nuse std::convert::TryFrom;     <1>\nuse std::ffi::OsStr;           <2>\nuse std::fs;                   <3>\nuse std::fs::DirEntry;         <4>\nuse std::path::{Path, PathBuf};<5>\nuse super::errors::StatsError; <6>\n```", "```rs\n// Struct to hold the stats\n#[derive(Debug)]\npub struct SrcStats {\n    pub number_of_files: u32,\n    pub loc: u32,\n    pub comments: u32,\n    pub blanks: u32,\n}\n```", "```rs\npub fn get_summary_src_stats(in_dir: &Path) ->   \n    Result<SrcStats, StatsError> {\n    let mut total_loc = 0;\n    let mut total_comments = 0;\n    let mut total_blanks = 0;\n    let mut dir_entries: Vec<PathBuf> = \n        vec![in_dir.to_path_buf()];\n    let mut file_entries: Vec<DirEntry> = vec![];\n\n    // Recursively iterate over directory entries to get flat \n    // list of .rs files\n```", "```rs\n    while let Some(entry) = dir_entries.pop() {\n        for inner_entry in fs::read_dir(&entry)? {\n            if let Ok(entry) = inner_entry {\n                if entry.path().is_dir() {\n                    dir_entries.push(entry.path());\n                } else {\n                    if entry.path().extension() == \n                    Some(OsStr::new(\"rs\")) {\n                        file_entries.push(entry);\n                    }\n                }\n            }\n        }\n    }\n```", "```rs\n    let file_count = file_entries.len();\n    // Compute the stats\n    for entry in file_entries {\n        let stat = get_src_stats_for_file(&entry.path())?;\n        total_loc += stat.loc;\n        total_blanks += stat.blanks;\n        total_comments += stat.comments;\n    }\n\n    Ok(SrcStats {\n        number_of_files: u32::try_from(file_count)?,\n        loc: total_loc,\n        comments: total_comments,\n        blanks: total_blanks,\n    })\n}\n```", "```rs\npub fn get_src_stats_for_file(file_name: &Path) ->  \n    Result<SrcStats, StatsError> {\n    let file_contents = fs::read_to_string(file_name)?;\n    let mut loc = 0;\n    let mut blanks = 0;\n    let mut comments = 0;\n    for line in file_contents.lines() {\n        if line.len() == 0 {\n            blanks += 1;\n        } else if line.trim_start().starts_with(\"//\") {\n            comments += 1;\n        } else {\n            loc += 1;\n        }\n    }\n    let source_stats = SrcStats {\n        number_of_files: u32::try_from(file_contents.lines()\n            .count())?,\n        loc: loc,\n        comments: comments,\n        blanks: blanks,\n    };\n    Ok(source_stats)\n}\n```", "```rs\n[dependencies]\nstructopt = \"0.3.16\"\n```", "```rs\nuse std::path::PathBuf;\nuse structopt::StructOpt;\nmod srcstats;\nuse srcstats::get_summary_src_stats;\nmod errors;\nuse errors::StatsError;\n\n#[derive(Debug, StructOpt)]\n#[structopt(\n    name = \"rstat\",\n    about = \"This is a tool to generate statistics on Rust \n        projects\"\n)]\nstruct Opt {\n    #[structopt(name = \"source directory\", \n        parse(from_os_str))]\n    in_dir: PathBuf,\n    #[structopt(name = \"mode\", short)]\n    mode: String,\n}\n```", "```rs\nfn main() -> Result<(), StatsError> {\n    let opt = Opt::from_args();\n    let mode = &opt.mode[..];\n    match mode {\n        \"src\" => {\n            let stats = get_summary_src_stats(&opt.in_dir)?;\n            println!(\"Summary stats: {:?}\", stats);\n        }\n        _ => println!(\"Sorry, no stats\"),\n    }\n    Ok(())\n}\n```", "```rs\ncargo run --release -- -m src <src-folder>\n```", "```rs\ncargo run --release -- -m src .\n```"]