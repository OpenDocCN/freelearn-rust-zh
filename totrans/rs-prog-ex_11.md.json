["```rs\nfn some_func(v: &[u8]) {\n    // some code...\n}\n```", "```rs\nfn some_code(v: &Vec<u8>) {\n    // some code\n}\n```", "```rs\nfn some_func(s: &str) {\n    // some code...\n}\n```", "```rs\nfn some_func(s: &String) {\n    // some code...\n}\n```", "```rs\nfn print_as_ascii(v: &[u8]) {\n    for c in v {\n        print!(\"{}\", *c as char);\n    }\n    println!(\"\");\n}\n```", "```rs\nlet v = b\"salut!\";\n\nprint_as_ascii(&v[2..]);\n```", "```rs\nlet v = b\"salut!\";\n\nprint_as_ascii(&v[2..].to_vec());\n```", "```rs\nfn some_func(arg: Option<&str>) {\n    // some code\n}\n```", "```rs\nsome_func(Some(\"ratatouille\"));\nsome_func(None);\n```", "```rs\nfn some_func<'a, T: Into<Option<&'a str>>>(arg: T) {\n    // some code\n}\n```", "```rs\nsome_func(Some(\"ratatouille\")); // If you *really* like to write \"Some\"...\nsome_func(\"ratatouille\");\nsome_func(None);\n```", "```rs\nfn some_func(arg: Option<&str>) {\n    if let Some(a) = arg {\n        println!(\"{}\", a);\n    } else {\n        println!(\"nothing...\");\n    }\n}\n```", "```rs\nfn some_func<'a, T: Into<Option<&'a str>>>(arg: T) {\n    let arg = arg.into();\n    if let Some(a) = arg {\n        println!(\"{}\", a);\n    } else {\n        println!(\"nothing...\");\n    }\n}\n```", "```rs\nuse std::path::Path;\n\nfn some_func(p: &Path) {\n    // some code...\n}\n```", "```rs\nsome_func(Path::new(\"tortuga.txt\"));\n```", "```rs\nfn some_func<P: AsRef<Path>>(p: P) {\n    // some code...\n}\n```", "```rs\nsome_func(Path::new(\"tortuga.txt\")); // If you *really* like to build the \"Path\" by yourself...\nsome_func(\"tortuga.txt\");\n```", "```rs\nfn some_func<P: AsRef<Path>>(p: P) {\n    let p: &Path = p.as_ref();\n    // some code...\n}\n```", "```rs\nuse std::fs::OpenOptions;\n\nlet file = OpenOptions::new()\n                       .read(true)\n                       .write(true)\n                       .create(true)\n                       .open(\"foo.txt\");\n```", "```rs\nstruct Number(u32);\n\nimpl Number {\n    fn new(nb: u32) -> Number {\n        Number(nb)\n    }\n\n    fn add(&mut self, other: u32) -> &mut Number {\n        self.0 += other;\n        self\n    }\n\n    fn sub(&mut self, other: u32) -> &mut Number {\n        self.0 -= other;\n        self\n    }\n\n    fn compute(&self) -> u32 {\n        self.0\n    }\n}\n```", "```rs\nlet nb = Number::new(0).add(10).sub(5).add(12).compute();\nassert_eq!(nb, 17);\n```", "```rs\nstruct Number(u32);\n\nimpl Number {\n    fn new(nb: u32) -> Number {\n        Number(nb)\n    }\n\n    fn add(mut self, other: u32) -> Number {\n        self.0 += other;\n        self\n    }\n\n    fn sub(mut self, other: u32) -> Number {\n        self.0 -= other;\n        self\n    }\n}\n```", "```rs\nlet nb = Number::new(0).add(10).sub(5).add(12);\nassert_eq!(nb.0, 17);\n```", "```rs\nlet x = 1000000000;\n```", "```rs\nlet x = 1_000_000_000;\n```", "```rs\nlet x = \"a 10 11 coucou 12 14\".split(' ')\n                              .filter_map(|e| e.parse::<u32>().ok())\n                              .filter(|x| x % 2 == 0)\n                              .map(|s| format!(\"{}\", s))\n                              .collect::<Vec<_>>()\n                              .join(\"::\");\n```", "```rs\nlet x: String = \"a 10 11 coucou 12 14\".split(' ')\n                                      .filter_map(|e| e.parse::<u32>().ok())\n                                      .filter(|x| x % 2 == 0)\n                                      .map(|s| format!(\"{}\", s))\n                                      .collect::<Vec<_>>()\n                                      .join(\"::\");\n```", "```rs\nenum SomeEnum {\n    Ok,\n    Err,\n    Unknown,\n}\n```", "```rs\nlet x = SomeEnum::Err;\n\nmatch x {\n    SomeEnum::Ok => {\n        // Huge code doing a lot of things...\n    }\n    _ => {}\n}\n```", "```rs\nlet x = SomeEnum::Err;\n\nif let SomeEnum::Ok = x {\n    // Huge code doing a lot of things...\n}\n```"]