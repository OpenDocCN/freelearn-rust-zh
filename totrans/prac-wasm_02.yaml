- en: '*Chapter 1*: Understanding LLVM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：理解LLVM'
- en: 'JavaScript is one of the most popular programming languages. However, JavaScript
    has two main disadvantages:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是最受欢迎的编程语言之一。然而，JavaScript有两个主要缺点：
- en: '**Unpredictable performance**'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可预测的性能**'
- en: JavaScript executes inside the environment and runtime provided by JavaScript
    engines. There are various JavaScript engines (V8, WebKit, and Gecko). All of
    them were built differently and run the same JavaScript code in a different way.
    Added to that, JavaScript is dynamically typed. This means JavaScript engines
    should guess the type while executing the JavaScript code. These factors lead
    to unpredictable performance in JavaScript execution. The optimizations for one
    type of JavaScript engine may cause undesirable side effects on other types of
    JavaScript engines. This leads to unpredictable performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在JavaScript引擎提供的环境和运行时中执行。存在各种JavaScript引擎（V8、WebKit和Gecko）。它们都是不同构建的，并以不同的方式运行相同的JavaScript代码。此外，JavaScript是动态类型的。这意味着JavaScript引擎在执行JavaScript代码时应该猜测类型。这些因素导致JavaScript执行性能不可预测。针对一种JavaScript引擎的优化可能会对其他类型的JavaScript引擎产生不希望的影响。这导致性能不可预测。
- en: '**Bundle size**'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包大小**'
- en: The JavaScript engine waits until it downloads the entire JavaScript file before
    parsing and executing. The larger the JavaScript file, the longer the wait will
    be. This will degrade your application's performance. Bundlers such as webpack
    help to minimize the bundle size. But when your application grows, the bundle
    size grows exponentially.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎会等待下载整个JavaScript文件后再进行解析和执行。JavaScript文件越大，等待时间越长。这将降低应用程序的性能。捆绑器如webpack有助于最小化捆绑大小。但当您的应用程序增长时，捆绑大小会呈指数增长。
- en: Is there a tool that provides native performance and comes in a much smaller
    size? Yes, WebAssembly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种工具提供原生性能，并且体积要小得多？是的，WebAssembly。
- en: WebAssembly is the future of web and node development. WebAssembly is statically
    typed and precompiled, and thus it provides better performance than JavaScript.
    Precompilation of the binary provides an option to generate tiny binary bundles.
    WebAssembly allows languages such as Rust, C, and C++ to be compiled into binaries
    that run inside the JavaScript engine along with JavaScript. All WebAssembly compilers
    use LLVM underneath to convert the native code into WebAssembly binary code. Thus,
    it is important to understand what LLVM is and how it works.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是Web和Node开发的未来。WebAssembly是静态类型和预编译的，因此它比JavaScript提供更好的性能。二进制的预编译提供了生成小型二进制捆绑包的选项。WebAssembly允许Rust、C和C++等语言编译成在JavaScript引擎内与JavaScript一起运行的二进制文件。所有WebAssembly编译器都使用LLVM在底层将本地代码转换为WebAssembly二进制代码。因此，了解LLVM是什么以及它是如何工作的是非常重要的。
- en: 'In this chapter, we will learn what the various components of a compiler are
    and how they work. Then, we will explore what LLVM is and how it helps the compiled
    languages. Finally, we will see how the LLVM compiler compiles native code. We
    will cover the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习编译器的各种组件及其工作原理。然后，我们将探讨LLVM是什么以及它是如何帮助编译型语言的。最后，我们将看到LLVM编译器如何编译本地代码。本章将涵盖以下主题：
- en: Understanding compilers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编译器
- en: Exploring LLVM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索LLVM
- en: LLVM in action
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM的实际应用
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will make use of **Clang**, which is a compiler that compiles C/C++ code
    into native code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Clang**，这是一个将C/C++代码编译成本地代码的编译器。
- en: For Linux and Mac users, Clang should be available out of the box.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux和Mac用户，Clang应该直接可用。
- en: 'For Windows users, Clang can be installed from the following link: [https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm](https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm)
    to install Clang.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，可以从以下链接安装Clang：[https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm](https://llvm.org/docs/GettingStarted.html?highlight=installing%20clang%20windows#getting-the-source-code-and-building-llvm)
    以安装Clang。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件，链接为[https://github.com/PacktPublishing/Practical-WebAssembly](https://github.com/PacktPublishing/Practical-WebAssembly)
- en: Understanding compilers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解编译器
- en: Programming languages are broadly classified into compiled and interpreted languages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言被广泛分为编译型和解释型语言。
- en: In the compiled world, the code is first compiled into target machine code.
    This process of converting the code into binary is called *compilation*. The software
    program that converts the code into target machine code is called a *compiler*.
    During the compilation, the compiler runs a series of checks, passes, and validation
    on the code written and generates an efficient and optimized binary. A few examples
    of compiled languages are C, C++, and Rust.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译世界中，代码首先被编译成目标机器码。将代码转换为二进制的过程称为*编译*。将代码转换为目标机器码的软件程序称为*编译器*。在编译过程中，编译器会对编写的代码运行一系列的检查、通过和验证，并生成一个高效且优化的二进制文件。编译语言的一些例子包括C、C++和Rust。
- en: In the interpreted world, the code is read and executed in a single pass. Since
    the compilation happens at runtime, the generated machine code is not as optimized
    as its compiled counterpart. Interpreted languages are significantly slower than
    compiled ones, but they provide dynamic typing and a smaller program size.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释世界中，代码在单次遍历中读取和执行。由于编译是在运行时发生的，因此生成的机器码不如编译后的版本优化。解释语言比编译语言慢得多，但它们提供了动态类型和更小的程序大小。
- en: In this book, we will focus only on compiled languages.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将只关注编译语言。
- en: Compiled languages
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译语言
- en: A compiler is a translator that translates source code into machine code (or
    in a more abstract way, converts the code from one programming language to another).
    A compiler is complicated because it should understand the language in which the
    source code is written (its syntax, semantics, and context); it should also understand
    the target machine code (its syntax, semantics, and context) and should create
    a representation that maps the source code into the target machine code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是一种将源代码翻译成机器码（或者更抽象地说，将代码从一种编程语言转换到另一种编程语言）的翻译器。编译器很复杂，因为它应该理解源代码所写的语言（其语法、语义和上下文）；它还应该理解目标机器码（其语法、语义和上下文），并应该创建一个表示，将源代码映射到目标机器码。
- en: 'A compiler has the following components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器有以下组件：
- en: '**Frontend** – The frontend is responsible for handling the source language.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端** – 前端负责处理源语言。'
- en: '**Optimizer** – The optimizer is responsible for optimizing the code.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化器** – 优化器负责优化代码。'
- en: '**Backend** – The backend is responsible for handling the target language.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后端** – 后端负责处理目标语言。'
- en: '![ Figure 1.1 – Components of a compiler'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![ 图1.1 – 编译器的组件'
- en: '](img/Figure_1.1_B14844.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![ 图1.1 – 编译器的组件'
- en: Figure 1.1 – Components of a compiler
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 编译器的组件
- en: Frontend
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前端
- en: The frontend focuses on handling the source language. The frontend parses the
    code upon receiving it. The code is then checked for any grammar or syntax issues.
    After that, the code is converted (mapped) into an **intermediate representation**
    (**IR**). Consider IR as a format that represents the code that the compiler processes.
    The IR is the compiler's version of your code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前端专注于处理源语言。前端在接收到代码后对其进行解析。然后检查代码中是否存在任何语法或语法错误。之后，代码被转换（映射）成**中间表示**（**IR**）。可以将IR视为表示编译器处理的代码的格式。IR是编译器版本的你的代码。
- en: Optimizer
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化器
- en: The second component in the compiler is the optimizer. This is optional, but
    as the name indicates, the optimizer analyzes the IR and transforms it into a
    much more efficient one. Few compilers have multiple IRs. The compiler efficiently
    optimizes the code on every pass over the IR. The optimizer is an IR-to-IR transformer.
    The optimizer analyzes, runs passes, and rewrites the IR. The optimizations here
    include removing redundant computations, eliminating dead code (code that cannot
    be reached), and various other optimizing options, which will be explored in future
    chapters. It is important to note that the optimizers need not be language-specific.
    Since they act on the IR, they can be built as a generic component and reused
    with multiple languages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的第二个组件是优化器。这是可选的，但正如其名称所示，优化器分析IR并将其转换为一个更高效的版本。少数编译器有多个IR。编译器在每次遍历IR时都会高效地优化代码。优化器是IR到IR的转换器。优化器分析、运行遍历并重写IR。这里的优化包括移除冗余计算、消除死代码（无法到达的代码）以及各种其他优化选项，这些将在未来的章节中探讨。需要注意的是，优化器不必是语言特定的。由于它们作用于IR，因此可以作为通用组件构建并用于多种语言。
- en: Backend
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后端
- en: The backend focuses on producing the target language. The backend receives the
    generated (optimized) IR and converts it into another language (such as machine
    code). It is also possible to chain multiple backends that convert the code into
    some other languages. The backend is responsible for generating the target machine
    code from the IR. This machine code is the actual code that runs on the bare metal.
    In order to produce efficient machine code, the backend should understand the
    architecture in which the code is executed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 后端专注于生成目标语言。后端接收生成的（优化后的）中间表示（IR）并将其转换为另一种语言（例如机器码）。也有可能链式连接多个后端，将代码转换为其他语言。后端负责从IR生成目标机器码。这种机器码是实际在裸机上运行的代码。为了生成高效的机器码，后端应该理解代码执行的架构。
- en: Machine code is a set of instructions that instructs the machine to store some
    values in registers and do some computation on them. For example, the generated
    machine code is responsible for efficiently storing a 64-bit number in 32-bit
    architecture in a free register (and things like that). The backend should understand
    the target environment to efficiently create a set of instructions and properly
    select and schedule the instructions to increase the performance of the application
    execution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 机器码是一组指令，指示机器将某些值存储在寄存器中并对它们进行一些计算。例如，生成的机器码负责在32位架构中高效地将64位数字存储在空闲寄存器中（以及类似的事情）。后端应该理解目标环境，以便高效地创建一组指令，并正确选择和调度指令以提高应用程序执行的效率。
- en: Compiler efficiency
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器效率
- en: '*The faster the execution, the better the performance.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行越快，性能越好。*'
- en: The efficiency of the compiler depends on how it selects the instruction, allocates
    the register, and schedules the instruction execution in the given architecture.
    An instruction set is a set of operations supported by a processor, and this overall
    design is called an **Instruction Set Architecture** (**ISA**). The ISA is an
    abstract model of a computer and is often referred to as computer architecture.
    Various processors convert the ISA in different implementations. The different
    implementations may vary in performance. The ISA is an interface between the hardware
    and the software.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的效率取决于它如何选择指令、分配寄存器以及在给定架构中调度指令执行。指令集是处理器支持的运算集，这种整体设计被称为**指令集架构**（**ISA**）。ISA是计算机的抽象模型，通常被称为计算机架构。不同的处理器以不同的实现方式转换ISA。不同的实现可能在性能上有所不同。ISA是硬件和软件之间的接口。
- en: If you are implementing a new programming language and you want this language
    to be running on different architectures (or, more abstractly, different processors),
    then you should build the backend for each of these architectures/targets. But
    building these backends for every architecture is difficult and will take time,
    cost, and effort to embark on a language creation journey.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一种新的编程语言，并且希望这种语言能在不同的架构（或更抽象地说，不同的处理器）上运行，那么你应该为这些架构/目标中的每一个构建后端。但是，为每个架构构建这些后端是困难的，并且会花费时间、成本和努力来开始语言创建之旅。
- en: What if we create a common IR and build a compiler that converts this IR into
    machine code that runs efficiently on various architecture? Let's call this compiler
    a low-level virtual machine. Now, the role of your frontend in the compiler chain
    is just to convert the source code into an IR that is compatible with a low-level
    virtual machine (such as LLVM). Now, the general purpose of a low-level virtual
    machine is to be a common reusable component that maps the IR into native code
    for various targets. But the low-level virtual machine will only understand the
    common IR. This IR is called the **LLVM IR** and the compiler is called **LLVM**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个通用的IR并构建一个编译器，将这个IR转换为在各种架构上高效运行的机器码，那会怎么样？让我们称这个编译器为低级虚拟机。现在，你的前端在编译器链中的角色仅仅是把源代码转换为与低级虚拟机（如LLVM）兼容的IR。现在，低级虚拟机的一般目的是成为一个通用的可重用组件，将IR映射到各种目标的本机代码。但是，低级虚拟机只会理解通用的IR。这个IR被称为**LLVM
    IR**，编译器被称为**LLVM**。
- en: Exploring LLVM
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索LLVM
- en: LLVM is a part of the LLVM Project. The LLVM Project hosts compilers and toolchain
    technologies. The *LLVM core* is a part of the LLVM Project. The LLVM core is
    responsible for providing source- and target-independent optimization and for
    generating code for many CPU architectures. This enables language developers to
    just create a frontend that generates an LLVM-compatible IR or LLVM IR from the
    source language.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 是 LLVM 项目的一部分。LLVM 项目托管编译器和工具链技术。*LLVM 核心* 是 LLVM 项目的一部分。LLVM 核心负责提供源和目标无关的优化，并为许多
    CPU 架构生成代码。这使得语言开发者只需创建一个前端，即可从源语言生成与 LLVM 兼容的 IR 或 LLVM IR。
- en: Did You Know?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: LLVM is not an acronym. When the project was started as a research project,
    it meant Low-Level Virtual Machine. But later, it was decided to use the name
    as it is rather than as an acronym.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 不是一个缩写。当该项目作为一个研究项目开始时，它代表低级虚拟机（Low-Level Virtual Machine）。但后来，决定使用这个名字而不是缩写。
- en: 'The main advantages of LLVM are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 的主要优势如下：
- en: LLVM uses a simple low-level language that looks similar to C.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 使用一种类似于 C 的简单低级语言。
- en: LLVM is strongly typed.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 是强类型的。
- en: LLVM has strictly defined semantics.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 具有严格定义的语义。
- en: LLVM has accurate and precise garbage collection.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 具有精确和精确的垃圾回收。
- en: LLVM provides various optimizations that you can choose based on the requirement.
    It has *aggressive*, *scalar*, *inter-procedural*, *simple-loop*, and *profile-driven*
    optimizations.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 提供了各种优化，您可以根据需求选择。它有 *激进*、*标量*、*跨过程*、*简单循环* 和 *基于配置文件* 的优化。
- en: LLVM provides various compilation models. They are *link time*, *install time*,
    *runtime*, and *offline*.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 提供了各种编译模型。它们是 *链接时间*、*安装时间*、*运行时* 和 *离线*。
- en: LLVM generates machine code for various target architectures.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 为各种目标架构生成机器代码。
- en: LLVM provides DWARF debugging information.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 提供了 DWARF 调试信息。
- en: Note
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: DWARF is a debugging file format used by many compilers and debuggers to support
    source-level debugging. DWARF is architecture-independent and applicable to any
    processor or operating system. It uses a data structure called a **Debugging Information
    Entry** (**DIE**) to represent each variable, type, procedure, and so on.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DWARF 是许多编译器和调试器使用的调试文件格式，用于支持源级调试。DWARF 是架构无关的，适用于任何处理器或操作系统。它使用一种称为 **调试信息条目**（**DIE**）的数据结构来表示每个变量、类型、过程等。
- en: If you want to explore more about DWARF, refer to [http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf](http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf).
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 DWARF 的信息，请参阅 [http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf](http://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf)。
- en: Important Note
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: LLVM is not a single monolithic project. It is a collection of subprojects and
    other projects. These projects are used by various languages, such as Ruby, Python,
    Haskell, Rust, and D, for compilation.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LLVM 不是一个单一的项目。它是一系列子项目和其它项目的集合。这些项目被各种语言使用，如 Ruby、Python、Haskell、Rust 和 D，用于编译。
- en: Now that we have an understanding of compilers and LLVM, we will see how it
    is used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了编译器和 LLVM，我们将看到它是如何被使用的。
- en: LLVM in action
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM 在行动
- en: In this section, let's use LLVM's Clang compiler to compile native code into
    LLVM IR. This will give a better idea of how LLVM works and will be useful for
    understanding how the compilers use LLVM in future chapters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们使用 LLVM 的 Clang 编译器将原生代码编译成 LLVM IR。这将更好地了解 LLVM 的工作原理，并在未来章节中理解编译器如何使用
    LLVM 时非常有用。
- en: 'We first create a C file called `sum.c` and enter the following contents:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `sum.c` 的 C 文件，并输入以下内容：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `sum.c` file contains a simple `sum` function that takes in two unsigned
    integers and returns the sum of them. LLVM provides the Clang LLVM compiler to
    compile the C source code. In order to generate the LLVM IR, run the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum.c` 文件包含一个简单的 `sum` 函数，该函数接受两个无符号整数并返回它们的和。LLVM 提供了 Clang LLVM 编译器来编译 C
    源代码。为了生成 LLVM IR，请运行以下命令：'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We provided the Clang compiler with the `-S`, `-O3`, and `-emit-llvm` options:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 Clang 编译器提供了 `-S`、`-O3` 和 `-emit-llvm` 选项：
- en: The `-S` option specifies for the compiler to only run the preprocess and compilation
    steps.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-S` 选项指定编译器只运行预处理和编译步骤。'
- en: The `-O3` option specifies for the compiler to generate a well-optimized binary.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O3` 选项指定编译器生成一个经过良好优化的二进制文件。'
- en: The `-emit-llvm` option specifies for the compiler to emit the LLVM IR while
    generating the machine code.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-emit-llvm` 选项指定编译器在生成机器代码时输出 LLVM IR。'
- en: 'The preceding code will print out the following LLVM IR:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印出以下 LLVM IR：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The syntax of the LLVM IR is structurally much closer to C. The `define` keyword
    defines the beginning of a function. Next to that is the return type of the function,
    `i32`. Next, we have the name of the function, `@sum`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR的语法在结构上与C语言非常接近。`define`关键字定义了函数的开始。旁边是函数的返回类型，`i32`。接下来是函数的名称，`@sum`。
- en: Important Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note the `@` symbol there? LLVM uses `@` to identify the global variables and
    function. It uses `%` to identify the local variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那里的`@`符号吗？LLVM使用`@`来标识全局变量和函数。它使用`%`来标识局部变量。
- en: After the function name, we state the types of the input argument (`i32` in
    this case). The `local_unnamed_addr` attribute indicates that the address is known
    not to be significant within the module. The variables in the LLVM IR are *immutable*.
    That is, once you define them, you cannot change them. So inside the `block`,
    we create a new local value, `%3`, and assign it the value of `add`. `add` is
    an opcode that takes in the `type` of the arguments followed by the two arguments,
    `%0` and `%1`. `%0` and `%1` denote the first and second local variables. Finally,
    we return `%3` with the `ret` keyword followed by the `type`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数名之后，我们声明输入参数的类型（在这种情况下为`i32`）。`local_unnamed_addr`属性表示地址在模块内不具有重要意义。LLVM
    IR中的变量是*不可变的*。也就是说，一旦你定义了它们，就不能更改它们。因此，在`block`内部，我们创建一个新的局部值`%3`，并将其赋值为`add`。`add`是一个操作码，它接受参数的类型，然后是两个参数，`%0`和`%1`。`%0`和`%1`表示第一个和第二个局部变量。最后，我们使用`ret`关键字返回`%3`，后面跟着`type`。
- en: This IR is transformable; that is, the IR can be transformed from the textual
    representation into memory and then into actual bit code that run on the bare
    metal. Also, from bit code, you can transform them back to the textual representation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个IR是可以转换的；也就是说，IR可以从文本表示转换为内存，然后转换为在裸金属上运行的实际位码。此外，从位码，你可以将它们转换回文本表示。
- en: Imagine that you are writing a new language. The success of the language depends
    on how versatile the language is at performing on various architectures. Generating
    optimized byte codes for various architectures (such as x86, ARM, and others)
    takes a long time and it is not easy. LLVM provides an easy way to achieve it.
    Instead of targeting the different architecture, create a compiler frontend that
    converts the source code into an LLVM compatible IR. Then, LLVM will convert the
    IR into efficient and optimized byte code that runs on any architecture.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一种新的语言。这种语言的成功取决于它在各种架构上执行时的灵活性。为各种架构（如x86、ARM等）生成优化的字节码需要很长时间，而且并不容易。LLVM提供了一种简单的方法来实现这一点。不是针对不同的架构，而是创建一个编译器前端，将源代码转换为LLVM兼容的IR。然后，LLVM将IR转换为在任何架构上运行的效率高和优化的字节码。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'LLVM is an umbrella project. It has so many components that you could write
    a set of books on them. Covering the whole of LLVM and how to install and run
    them is beyond the scope of this book. If you are interested in learning more
    about various components of LLVM, how they work, and how to use them, then check
    out the website: [https://llvm.org](https://llvm.org).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM是一个伞形项目。它有如此多的组件，你几乎可以为他们写一套书。涵盖整个LLVM以及如何安装和运行它们超出了本书的范围。如果你对学习LLVM的各个组件、它们的工作原理以及如何使用它们感兴趣，请查看网站：[https://llvm.org](https://llvm.org)。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how compiled languages work and how LLVM helps
    to compile them. We have compiled a sample program with LLVM to understand how
    it works. In the next chapter, we'll explore Emscripten, a tool that converts
    C/C++ into a WebAssembly module. Emscripten uses the LLVM backend to do the compilation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了编译型语言是如何工作的，以及LLVM是如何帮助编译它们的。我们已经使用LLVM编译了一个示例程序，以了解它是如何工作的。在下一章中，我们将探讨Emscripten，这是一个将C/C++转换为WebAssembly模块的工具。Emscripten使用LLVM后端进行编译。
