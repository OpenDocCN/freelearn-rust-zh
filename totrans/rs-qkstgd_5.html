<html><head></head><body><div><h1 class="header-title">One Data Type Representing Multiple Kinds of Data</h1>
                
            
            
                
<p>Sometimes, a data value might need to be one of multiple different data types. Rust has three ways of addressing that situation without breaking strict type safety: enumerations, trait objects, and <kbd>Any</kbd>. Each approach has strengths and weaknesses, so we'll examine them all and talk about when each is appropriate.</p>
<p>In this chapter, we're going to learn about the following:</p>
<ul>
<li>What an enumeration is</li>
<li>How to create an enumeration type</li>
<li>How to create enumeration values</li>
<li>How to use the information stored in an enumeration value</li>
<li>What a trait and a trait object are</li>
<li>How to create a trait</li>
<li>How to create a trait object</li>
<li>How to use a trait object</li>
<li>What <kbd>Any</kbd> is</li>
<li>How to use <kbd>Any</kbd></li>
<li>What enumerations are good for, what trait objects are good for, and what <kbd>Any</kbd> is good for</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Enumerations</h1>
                
            
            
                
<p>Like structures, enumerations allow us to establish a new data type. The content is different from a structure, though. When we say that the data type of a variable is an enumeration, we're telling Rust that its contained value is required to be one of the specific choices we've described for that enumeration and can't be anything else.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Basic enumerations</h1>
                
            
            
                
<p>In Rust, an enumeration is a data type representing one of a fixed set of values. For example, we could define an enumeration of the commonly recognized seven colors of the rainbow, as shown here:</p>
<pre>pub enum Color {<br/>    Red,<br/>    Orange,<br/>    Yellow,<br/>    Green,<br/>    Blue,<br/>    Indigo,<br/>    Violet,<br/>}</pre>
<p>Once we define this enumeration, we can use <kbd>Color</kbd> as a data type and <kbd>Color::Red</kbd> or the like as data values of that type:</p>
<pre>let color: Color = Color::Green;</pre>
<p>An enumeration is created with the <kbd>enum</kbd> keyword. Notice that, like a structure, an enumeration needs the <kbd>pub</kbd> keyword if we want it to be directly accessible outside the current module. Between the <kbd>{</kbd> and <kbd>}</kbd>, we have the list of possible values for the data type, listed by name and separated by commas.</p>
<p>Rust is somewhat opinionated about capitalization, so it will warn us if any of the enumeration values start with a lowercase letter, though that is not actually an error.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Parameterized enumerations</h1>
                
            
            
                
<p>Okay, so what do enumerations have to do with representing different kinds of data in one variable? Well, there's one more feature that enumeration values can have that changes everything: parameters.</p>
<p class="mce-root"/>
<p>Imagine we wanted to create a representation of a sequence of driving directions, such as <em>turn right</em>, <em>forward three blocks</em>, or <em>stop.</em> This example is simple enough that we could probably get by with a simple enumeration, but even this will be easier with parameters:</p>
<pre>pub enum Drive {<br/>    Forward(u8),<br/>    Turn{slight: bool, right: bool},<br/>    Stop,<br/>}</pre>
<p>What we have here is an enumeration with parameterized values. The <kbd>Forward</kbd> value has a <kbd>u8</kbd> parameter (unsigned 8 bit integer) , while the <kbd>Turn</kbd> value has two <kbd>bool</kbd> parameters with names. <kbd>Stop</kbd> doesn't need any parameters.</p>
<p>Essentially, the <kbd>Forward</kbd> value carries a 1-tuple along with it, while the <kbd>Turn</kbd> value carries along a structure with two members. That's why parentheses are used around the <kbd>Forward</kbd> parameter and braces are used around the <kbd>Turn</kbd> parameters. Whether we want the parameters to be tuple-like or structure-like is our decision to make. Either way, we can have as many or as few parameters as we need.</p>
<p>Now, we can create a variable of the <kbd>Drive</kbd> type, and it might contain a <kbd>Forward</kbd>, <kbd>Turn</kbd>, or <kbd>Stop</kbd> parameter. If it's a <kbd>Forward</kbd> parameter, that means the variable also contains a <kbd>u8</kbd> number telling us how far to drive. If it's a <kbd>Turn</kbd> parameter, that means the variable also contains a pair of Boolean values that tell us whether to turn right or left, and whether or not the turn is slight. In other words, the variable might contain any one of several different kinds of information.</p>
<p>If you're familiar with C++, or a similar language, keep in mind that Rust enumerations are not very much like C++ enumerations. A Rust enumeration with parameterized values is more like a C++ union, except it's type checked and safe.</p>
<p>Better still, we can create an array of driving instructions, to represent a complete journey:</p>
<pre>let directions = [<br/>    Drive::Forward(3),<br/>    Drive::Turn{slight: false, right: true},<br/>    Drive::Forward(1),<br/>    Drive::Stop,<br/>];</pre>
<p>This array of <kbd>Drive</kbd> values represents driving forward three blocks, turning right, driving forward one more block, and stopping.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Checking the value type and extracting parameter values</h1>
                
            
            
                
<p>When the program runs, it can take different actions depending on the specific enumeration type it's looking at, and it has access to the data values that were stored as parameters. We've already seen the best tool for doing that, <kbd>match</kbd>:</p>
<pre>    for step in directions.iter() {<br/>        match step {<br/>            Drive::Forward(blocks) =&gt; {<br/>                println!("Drive forward {} blocks", blocks);<br/>            },<br/>            Drive::Turn{slight, right} =&gt; {<br/>                println!("Turn {}{}",<br/>                         if *slight {<br/>                             "slightly "<br/>                         }<br/>                         else {<br/>                             ""<br/>                         },<br/>                         if *right {<br/>                             "right"<br/>                         }<br/>                         else {<br/>                             "left"<br/>                         }<br/>                );<br/>            },<br/>            Drive::Stop =&gt; {<br/>                println!("You have reached your destination");<br/>            }<br/>        };<br/>    };</pre>
<p>Here, we have a <kbd>for</kbd> loop that processes each item in our array of directions, one at a time, starting with the first one. Step by step, here's what is going on:</p>
<ol>
<li>We asked <kbd>directions</kbd> to provide us with an iterator, which it's happy to do. The iterator will give us a borrow of each value contained in the array, one at a time.</li>
<li>The <kbd>for</kbd> loop requests a value from the iterator, and assigns the returned borrow to a variable called <kbd>step</kbd>.</li>
</ol>
<ol start="3">
<li>The match expression uses the <kbd>step</kbd> variable to provide the value that it will match against. Because that variable changes each time the loop goes through, the match expression compares against a different value each time:
<ul>
<li>If the <kbd>step</kbd> variable contains (a borrow of) <kbd>Drive::Forward</kbd>, its parameter is assigned to the variable named <kbd>blocks</kbd>. Because <kbd>step</kbd> <em>is</em> a borrow, the value in <kbd>blocks</kbd> is a borrow as well, but, in this instance that doesn't make a significant difference. We pass it on to <kbd>println!</kbd>, which calls a function on it to turn it into a text string, which in turn, dereferences it automatically.</li>
<li>If the <kbd>step</kbd> variable contains (a borrow of) <kbd>Drive::Turn</kbd>, borrows of its parameters are assigned to the <kbd>slight</kbd> and <kbd>right</kbd> names, and we can use the shorthand notation we've seen before for that because <kbd>slight</kbd> and <kbd>right</kbd> are the names of the variables in both the source and the destination. Then comes a print command, but we're using <kbd>if</kbd> expressions to decide exactly what to print. Notice that we have explicitly dereferenced the <kbd>slight</kbd> and <kbd>right</kbd> values; they <em>are</em> borrows and, unlike when we call functions, <kbd>if</kbd> expressions don't automatically dereference for us, so we need to do it ourselves.</li>
<li>If the <kbd>step</kbd> variable contains (a borrow of) <kbd>Drive::Stop</kbd>, there are no parameters to deal with and we just print out a message.</li>
</ul>
</li>
<li>If there are any values left in the iterator, got back to step 2.</li>
</ol>
<p>Pretty cool. We've got some code here that does something kind of real. That's when the fun really starts!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Result is an enumeration, accessed via the prelude</h1>
                
            
            
                
<p>You may have noticed already, but the <kbd>Result</kbd> type with its <kbd>Ok</kbd> and <kbd>Err</kbd> values looks an awful lot like an enumeration. That's because it is an enumeration, which is how it's able to contain different data types depending on whether it represents an error or a success. It's an enumeration with generic type parameters, so we won't be able to pull off quite the same functionality until we learn about those but, at its base, it's still just an enumeration.</p>
<p>We can use <kbd>Ok</kbd> and <kbd>Err</kbd> instead of <kbd>Result::Ok</kbd> and <kbd>Result::Err</kbd> when we write functions that might fail or handle the results of such functions, because those values are added directly to the Rust <em>prelude</em> for our convenience. Actually, we can use the <kbd>Result</kbd> type without saying where it came from for the same reason.</p>
<p class="mce-root"/>
<p>The prelude is a collection of very basic and useful data types, values, and traits that is automatically made available in every Rust module. It contains such things as <kbd>String</kbd>, <kbd>Vec</kbd> (a <em>vector</em>, which has the same relation to arrays that <kbd>String</kbd> does to <kbd>str</kbd>), and <kbd>Box</kbd> (which we'll talk about in the next chapter).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Traits and trait objects</h1>
                
            
            
                
<p>Trait objects are another mechanism Rust has for storing a data value that might be one of several possible types into a single variable, but before we can talk about trait objects, we need to talk about traits.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Traits</h1>
                
            
            
                
<p>A trait is a name and formal definition for a specific bit of functionality that a data type may provide. Previously, we've talked about how data types might have the <kbd>Copy</kbd> trait, and how, when they do, the compiler copies them instead of moving them. That is the general idea: when a trait is implemented for a data type, that data type gains the ability to interact with the rest of the program in some specific way.</p>
<p>Some of the built-in traits, such as <kbd>Copy</kbd>, actually affect how the <em>compiler</em> interacts with the type, but we're more interested in creating our own traits here. We'll talk about those built-in traits in a later chapter.</p>
<p>That's all very abstract, so let's get more concrete by looking at the same "driving directions" problem that we previously solved with an enumeration. We still want to be able to have an array of driving instructions, and print them out in order, so let's create a trait that represents the ability to print out a driving instruction:</p>
<pre>pub trait PrintableDirection {<br/>    fn forward(&amp;self);<br/>    fn reverse(&amp;self);<br/>}</pre>
<p>The <kbd>trait</kbd> keyword introduces a trait, unsurprisingly. Inside of it, we have the signatures of the functions that make up the <em>interface</em> of this trait. In other words, if a data type is going to have the <kbd>PrintableDirection</kbd> trait, it needs to provide implementations of these functions that are specialized for that type and trait.</p>
<p class="mce-root"/>
<p>It's possible for one data type to have multiple implemented functions with the same name, as long as each of those functions is part of a different trait. Traits don't need to worry about name collisions with other traits or the basic data type.</p>
<p>We've expanded the functionality beyond what we did with enumerations, by specifying that a data value that has the <kbd>PrintableDirection</kbd> trait knows how to print itself out in both the <em>going to</em> and <em>coming from</em> directions of travel—or, at least, that's what we intend for the <kbd>forward</kbd> and <kbd>reverse</kbd> functions to mean.</p>
<p>Traits can specify functions by just providing a signature, as before, or they can also provide a default implementation of the function, by simply filling in a complete function definition instead. When the trait is implemented for a particular data type, functions with default implementations do not have to be implemented, though they can be, if necessary.</p>
<p>Notice that the function signatures inside the trait do not have the <kbd>pub</kbd> keyword. The trait itself is public or not, as a whole. In this case (and most cases), the trait is public, so the functions that it requires are automatically public.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Implementing our PrintableDirection trait</h1>
                
            
            
                
<p>Traits don't exist independently; they are something that data types have. So, the first thing we need to do is create data types to represent the various kinds of driving directions:</p>
<pre>pub struct Forward {<br/>    pub blocks: u8,<br/>}<br/><br/>pub struct Turn {<br/>    pub slight: bool,<br/>    pub right: bool,<br/>}<br/><br/>pub struct Stop {}</pre>
<p>We're just using basic structures here, but traits can be implemented for <em>any</em> data type.</p>
<p>These structures contain the same information that we included in the enumeration parameters before. The <kbd>Stop</kbd> structure is interesting, because it's empty. It stores no information at all. Its only purpose is to be a data type.</p>
<p class="mce-root">Now, we have a trait and we have data types, but so far they are not related in any way. Let's implement our trait for each of these types:</p>
<pre>impl PrintableDirection for Forward {<br/>    fn forward(&amp;self) {<br/>        println!("Go forward {} blocks", self.blocks);<br/>    }<br/><br/>    fn reverse(&amp;self) {<br/>        println!("Go forward {} blocks", self.blocks);<br/>    }<br/>}<br/><br/>impl PrintableDirection for Turn {<br/>    fn forward(&amp;self) {<br/>        println!("Turn {}{}",<br/>                 if self.slight {"slightly "} else {""},<br/>                 if self.right {"right"} else {"left"});<br/>    }<br/><br/>    fn reverse(&amp;self) {<br/>        println!("Turn {}{}",<br/>                 if self.slight {"slightly "} else {""},<br/>                 if self.right {"left"} else {"right"});<br/>    }<br/>}<br/><br/>impl PrintableDirection for Stop {<br/>    fn forward(&amp;self) {<br/>        println!("You have reached your destination");<br/>    }<br/><br/>    fn reverse(&amp;self) {<br/>        println!("Turn 180 degrees");<br/>    }<br/>}</pre>
<p class="mce-root">These implementation blocks look similar to the ones we've seen before, but this time instead of just saying <kbd>impl</kbd> and the type name, they say to implement the trait for the type name. Then, inside of it, we place the specific versions of the trait's functions that apply to that data type.</p>
<p>The <kbd>Forward</kbd>, <kbd>Turn</kbd>, and <kbd>Stop</kbd> data types now each have the <kbd>PrintableDirection</kbd> trait, which means that each of them knows how to display the information it contains as a driving instruction.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Trait objects</h1>
                
            
            
                
<p><kbd>Forward</kbd>, <kbd>Turn</kbd>, and <kbd>Stop</kbd> are still three different data types. There's no data type that represents <em>Forward, Turn, Stop</em>, and though we could create one using an enumeration, there's another way. There is a data type that represents a borrow of <em>any</em> data type that has the <kbd>PrintableDirection</kbd> trait. It's written as <kbd>&amp;dyn PrintableDirection</kbd> and is called a trait object reference.</p>
<p>We <em>can't</em> just write something like <kbd>let x: dyn PrintableDirection</kbd> and create a variable that can store anything with the <kbd>PrintableDirection</kbd> trait. It needs to be a borrow, or something that stores contained data outside the stack, such as the <kbd>Box</kbd> type we'll look at in the next chapter.</p>
<p class="mce-root">The <kbd>dyn</kbd> keyword is short for <em>dynamic dispatch</em>, and it means that what looks and acts like a borrow in most ways is actually a little more complicated. The memory address stored in the borrow itself is actually the address of a hidden data structure.</p>
<p class="mce-root">That hidden data structure contains the actual borrow address and the memory addresses of the functions that implement the trait for the borrowed data value. When we assign a data value to a trait object, Rust initializes that hidden data structure, and when we call one of the trait functions, Rust looks up which function to actually call in the same hidden data structure.</p>
<p>That means that calling a function through a trait object will always have a few extra steps that the computer needs to perform, compared to calling a function on a data value with a concrete type. On the other hand, if we think about it, any mechanism that could possibly allow us to work with arbitrary data types has to allocate time and memory for keeping track of what kind of data it's working with and where the data value is stored. If we tried to create the same functionality from scratch, we'd end up doing the same thing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using our PrintableDirection trait</h1>
                
            
            
                
<p class="mce-root">So, instead of an array of enumeration values, this time we're going to create an array of trait object references:</p>
<pre>    let mut directions = [<br/>        &amp;Forward{ blocks: 5 },<br/>        &amp;Turn{ slight: true, right: false },<br/>        &amp;Forward{ blocks: 1 },<br/>        &amp;Turn{ slight: false, right: true },<br/>        &amp;Forward{ blocks: 2 },<br/>        &amp;Stop{},<br/>    ];</pre>
<p>Unfortunately, if we try to compile that, we get an error, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5617fdb-e14d-40db-8366-99a306a591cb.png" width="1172" height="250"/></p>
<p>This time, Rust can't figure out the data type of the array just by looking at the value we're assigning to it, because that value looks like an array containing multiple data types, which is not something we can even do in Rust. The compiler is not going to go looking for traits they all implement, pick one arbitrarily, and decide that the array is actually an array of trait objects. That would be bad more often than it was helpful, so we have to tell Rust what data type the <kbd>directions</kbd> variable should have.</p>
<p>What we actually tell it is that <kbd>directions</kbd> is <kbd>[&amp;dyn PrintableDirection; 6]</kbd>. That means that it's an array of <kbd>PrintableDirection</kbd> trait object references and has room for six of them. Now, the compiler knows how to correctly interpret our array expression:</p>
<pre>    let mut directions: [&amp;dyn PrintableDirection; 6] = [<br/>        &amp;Forward{ blocks: 5 },<br/>        &amp;Turn{ slight: true, right: false },<br/>        &amp;Forward{ blocks: 1 },<br/>        &amp;Turn{ slight: false, right: true },<br/>        &amp;Forward{ blocks: 2 },<br/>        &amp;Stop{},<br/>    ];</pre>
<p class="mce-root">Now, we're ready to actually print out the driving directions:</p>
<pre>for step in directions.iter() {<br/>    step.forward();<br/>};</pre>
<p>Just for fun, we'll also print out the directions for returning home:</p>
<pre>directions.reverse();<br/><br/>for step in directions.iter() {<br/>    step.reverse();<br/>};</pre>
<p>There are two function calls to reverse here, and <em>they're not calling the same function</em>. The <kbd>directions.reverse()</kbd> call is calling a reverse function implemented on arrays, which reverses the order of the items stored in the array. Meanwhile, the <kbd>step.reverse()</kbd> call is calling the reverse function, which all types that have the <kbd>PrintableDirection</kbd> trait must implement, as appropriate for the specific concrete type of the step value. These functions happen to have the same name, but they're not at all the same thing.</p>
<p>When we compile and run all of the trait object code, we get output like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/006f1694-07e1-47f4-b677-690f9b100861.png" style="width:21.58em;height:14.42em;" width="387" height="258"/></p>
<p class="mce-root">Yay, it works!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Trait objects only provide access to the trait interface</h1>
                
            
            
                
<p class="mce-root">When we use a trait object, the <em>only</em> parts of the original object that we have access to are the parts that are defined by the trait. That means that we can call the <kbd>forward</kbd> and <kbd>reverse</kbd> functions, but we have no direct access to the <kbd>blocks</kbd> member of the <kbd>Forward</kbd> type, or the <kbd>slight</kbd> member of the <kbd>Turn</kbd> type, and so on. A trait object only gives us the things that are guaranteed to be present in <em>any</em> of the data types it can represent: the trait's own interface.</p>
<p>That makes sense, when we think about it. What's the computer supposed to do if we ask it to access <kbd>slight</kbd>, but the value we're looking at is actually a <kbd>Forward</kbd> type? Some languages would let us try and just crash the program if we tried it at the wrong time, while others would spend time while the program was running checking things like that and catching errors as they happen, but neither of those is the Rust way. In Rust, if the compiler can't be sure that something is okay, it's usually an error.</p>
<p>That means that a trait's interface needs to be complete, in the sense that anything you can reasonably do with a data value that has the trait should be part of the interface. That's not a burden most of the time. After all, why would we want it any other way?</p>
<p>We've been using the word <strong>interface</strong> a lot. Some languages, such as Java, have a feature that's actually <em>called</em> interface, and yes, Rust traits are similar to Java interfaces, although not identical.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Any</h1>
                
            
            
                
<p><kbd>Any</kbd> is a trait that most data types in Rust implement automatically, which means we can store almost anything in a trait object of <kbd>Any</kbd> type. However, as we've mentioned before, we can only access the stored value in a trait object in terms of that trait's interface, so what does the <kbd>Any</kbd> interface let us do?</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Any can store almost anything</h1>
                
            
            
                
<p>The Rust compiler automatically implements <kbd>Any</kbd> for any data type, <em>unless</em> that data type contains non-static references. So, our <kbd>Forward</kbd>, <kbd>Turn</kbd>, and <kbd>Stop</kbd> structures that we used in the trait objects section already automatically implement <kbd>Any</kbd>, but something like this would not:</p>
<pre>pub struct DoesNotHaveAnyTrait&lt;'a&gt; {<br/>    pub name: &amp;'a str,<br/>    pub count: i32,<br/>}</pre>
<p>More accurately, <kbd>DoesNotHaveAnyTrait</kbd> only has the <kbd>Any</kbd> trait when <kbd>'a</kbd> is equal to <kbd>'static</kbd>, which it is if we use a simple string expression such as <kbd>this is a static string</kbd> to initialize it, but not if we use some other mechanism for retrieving or constructing an <kbd>&amp;str</kbd> value.</p>
<p>The error the compiler will give if we try something impossible along these lines will probably be about lifetimes rather than explicitly about the <kbd>Any</kbd> trait, as in the following example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c1403c83-927e-4e6e-8cac-41c977e6bae8.png" style="width:58.00em;height:12.75em;" width="877" height="193"/></p>
<p>Do you see the note? The code that caused the error was trying to create an <kbd>&amp;dyn Any</kbd>, which told the compiler that the <kbd>'a</kbd> lifetime needed to be compatible with <kbd>'static</kbd>, which told it that the lifetime of <kbd>wrong.as_str()</kbd> was too short, so it reported an error.</p>
<p>Usually, that's not much of a problem, because we have several other reasons to avoid using non-static references in our data types, and we can use <kbd>String</kbd>, <kbd>Vec</kbd>, <kbd>Box</kbd>, and the like to achieve the same result. It's just something to keep in mind.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">But to access it we have to already know about the real data type</h1>
                
            
            
                
<p>Getting back to our example, we'll create our array of driving directions, and we'll add a something else that isn't a driving direction, just to prove that we can.</p>
<p>Here, we have an array of <kbd>Any</kbd> trait references containing driving directions and one other thing:</p>
<pre>use std::any::Any;<br/><br/>//...<br/><br/>pub struct DoesHaveAnyTrait {<br/> pub name: String,<br/> pub count: i32,<br/>}<br/><br/>//...<br/><br/>let okay = String::from("okay");<br/><br/>let directions: [&amp;dyn Any; 7] = [<br/>    &amp;Forward{ blocks: 5 },<br/>    &amp;Turn{ slight: true, right: false },<br/>    &amp;Forward{ blocks: 1 },<br/>    &amp;Turn{ slight: false, right: true },<br/>    &amp;Forward{ blocks: 2 },<br/>    &amp;Stop{},<br/>    &amp;DoesHaveAnyTrait{ name: okay, count: 16},<br/>];</pre>
<p>So far, it looks rather similar to our trait object example, which makes sense since <kbd>Any</kbd> is a trait too, and this is still an array of trait object references. The huge difference here is that we've added one more item to the array, and it doesn't have anything at all to do with driving directions.</p>
<p>Trait object references only give us access to the trait's functions. Now that we've got an array of <kbd>Any</kbd> trait object references, what functions does <kbd>Any</kbd> provide that let us do something useful? <kbd>Any</kbd> gives us two important functions: there is a function that checks whether the contained value has a particular data type, and there is a family of functions that lets us extract the contained value.</p>
<p>For a first example, we'll look at the function that allows us to check the data type:</p>
<pre>    for step in directions.iter() {<br/>        if step.is::&lt;Forward&gt;() {<br/>            println!("Go forward");<br/>        }<br/>        else if step.is::&lt;Turn&gt;() {<br/>            println!("Turn here");<br/>        }<br/>        else if step.is::&lt;Stop&gt;() {<br/>            println!("Stop now");<br/>        }<br/>    }</pre>
<p>There's some new syntax here. When we say <kbd>step.is::&lt;Forward&gt;()</kbd>, we're saying that we want to call the <kbd>is</kbd> function that was defined within the (automatically created) <kbd>impl Any for Forward</kbd> implementation. The compiler knows we're talking about <kbd>Any</kbd> because <kbd>step</kbd> is an <kbd>&amp;dyn Any</kbd>, but it wouldn't know we wanted the <kbd>Forward</kbd> version rather than one of the countless other implementations of <kbd>Any</kbd> for specific types, so we needed to tell it.</p>
<p>This syntax is a little confusing, since it's backwards from what we would write in a <kbd>use</kbd> statement, but it otherwise looks similar. It does read well, though: <em>if step is forward</em> almost works as a sentence.</p>
<p>This version is a little unsatisfying, though, because the printout is entirely based on the data type, without taking into account the information stored in the data values. We could do just as well with an unparameterized enumeration. Fortunately, we can also use the downcast functions of <kbd>Any</kbd> to get access to the referenced value:</p>
<pre>    for step in directions.iter() {<br/>        if let Some(x) = step.downcast_ref::&lt;Forward&gt;() {<br/>            x.forward();<br/>        }<br/>        else if let Some(x) = step.downcast_ref::&lt;Turn&gt;() {<br/>            x.forward();<br/>        }<br/>        else if let Some(x) = step.downcast_ref::&lt;Stop&gt;() {<br/>            x.forward();<br/>        }<br/>    }</pre>
<p class="mce-root">Once again, we're telling Rust that we want to call the versions of the <kbd>Any</kbd> functions that come from specific type implementations of that trait. In the first if let branch, we're asking <kbd>Any</kbd> to give us a reference to a <kbd>Forward</kbd> data value. If the value actually <em>is</em> a <kbd>Forward</kbd> data value, that function will return an enumeration value called <kbd>Some</kbd>, which has the reference as its parameter. If the value <em>is not</em> a <kbd>Forward</kbd> data value, the function will return an enumeration value called <kbd>None</kbd>, which naturally does not match the <kbd>if let</kbd> pattern.</p>
<div><kbd>Some</kbd> and <kbd>None</kbd> are the two possible values of the <kbd>Option</kbd> enumeration, which is another thing included in the prelude. It is used widely to represent data values that might or might not exist, especially when they are not required to exist. It's common in other languages to have a special value such as <kbd>NULL</kbd>, <kbd>null</kbd>, <kbd>None</kbd>, or <kbd>nil</kbd>, which can be assigned to anything. Rust's <kbd>None</kbd> can only be assigned to <kbd>Option</kbd>, which helps the compiler ensure that everything is correct.</div>
<p class="mce-root">The <kbd>x</kbd> variables in this example are actual references to <kbd>Forward</kbd>, <kbd>Turn</kbd>, or <kbd>Stop</kbd> data values, respectively, and so if we make it into the code block for one of the <kbd>if</kbd> branches, we have access to everything that it is possible to do with that data type, not just the features defined by a particular trait. In fact, we're calling the <kbd>forward</kbd> functions implemented in the <kbd>PrintableDirection</kbd> trait for those types, which is a pretty good demonstration that we have full access.</p>
<p>Notice that, with both <kbd>is</kbd> and <kbd>downcast_ref</kbd>, there's no way to use them without specifying which concrete data type we're interested in. If we try to use those functions without specifying exactly which data type to use, we get an error like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e4ede84a-0394-4e2a-bec2-6202629427f5.png" style="width:38.17em;height:11.08em;" width="678" height="197"/></p>
<p>That means that while <kbd>Any</kbd> can be used to store almost anything, we can't access the stored information unless we explicitly handle the correct data type for the stored value. In our example, we didn't have an if branch to handle <kbd>DoesHaveAnyTrait</kbd> values, so the last value in the array ended up being ignored.</p>
<p>In addition to <kbd>downcast_ref</kbd>, the <kbd>Any</kbd> trait also provides <kbd>downcast_mut</kbd>, which gives us a mutable reference. In some circumstances, a <kbd>downcast</kbd> function is also available, which moves the value into our current scope instead of borrowing it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Comparison of these techniques</h1>
                
            
            
                
<p>The Rust community tends to prefer using enumerations to address one-variable-multiple-types problems. In terms of runtime cost, a simple enumeration is maximally efficient, and efficiency is important to Rust programmers.</p>
<p>However, there is a downside to using enumerations, which is that the <kbd>match</kbd> expressions (or similar) that decide how to handle a particular enumeration value and associated data might be spread throughout the source code of the program. If we discover a need to add or remove an enumeration value, or change an enumeration value's parameters, we have to find and change every one of those match expressions.</p>
<p>If we decide to add a <kbd>Reverse</kbd> value to the <kbd>Drive</kbd> enumeration, the match expressions have to be changed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ee4b68b0-a7c7-43e0-93a7-77da803950e9.png" style="width:37.33em;height:11.00em;" width="676" height="199"/></p>
<p>The compiler will point out each <kbd>match</kbd> expression that needs to be updated, but it won't catch places where an <kbd>if let</kbd> expression would need similar changes (because <kbd>if let</kbd> is allowed to handle only some of the possibilities), so this can be a significant problem.</p>
<p>Trait objects on the other hand let us keep all the related code close together, by making the behavior for different data types actually be part of the data type. They also allow us to write code that works with data types we haven't even created yet, but they are less efficient, because the computer needs to maintain and use the hidden trait object structure while the program is running.</p>
<p>We might think we could get the best of both worlds by creating an enumeration and then implementing functions on it that contain match expressions and handle each of the enumeration values differently, and to an extent, we can. However, if those functions work by picking another enumeration value-specific function and calling <em>that</em>, we've just recreated trait objects all over again, but less efficiently.</p>
<p>If we try something like the following to avoid trait objects, we're better off just using trait objects:</p>
<pre>pub enum LikeATraitObject {<br/>    Integer(i32),<br/>    Float(f32),<br/>    Bool(bool),<br/>}<br/><br/>fn handle_integer(x: i32) {<br/>    println!("Integer {}", x);<br/>}<br/><br/>fn handle_float(x: f32) {<br/>    println!("Float {}", x);<br/>}<br/><br/>fn handle_bool(x: bool) {<br/>    println!("Bool {}", x);<br/>}<br/><br/>impl LikeATraitObject {<br/>    pub fn handle(&amp;self) {<br/>        match self {<br/>            LikeATraitObject::Integer(x) =&gt; { handle_integer(*x); }<br/>            LikeATraitObject::Float(x) =&gt; { handle_float(*x); }<br/>            LikeATraitObject::Bool(x) =&gt; { handle_bool(*x); }<br/>        }<br/>    }<br/>}</pre>
<p>That's not to say that such constructions are useless, because they're not. However, if the <em>only</em> reason for doing something like that is to avoid using trait object references, it's a mistake.</p>
<p>It may seem like <kbd>Any</kbd> is actually the best option, since it can store such a wide range of values <em>and</em> gives us full access to the stored value data, but usually one of the other choices is better. Using <kbd>Any</kbd> means we need to check for all of the possibilities in various places throughout the code, as we would with an enumeration and, unlike an enumeration, the compiler can't give us any help at all in finding places that need to change because, like a trait object reference, there's no defined list of possibilities. <kbd>Any</kbd> is, in many ways, the worst of both worlds. </p>
<p>There are <em>some</em> problems that <kbd>Any</kbd> is the right choice for, though. If we really need to handle a collection of unrelated data types, we need <kbd>Any</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Okay, so we have three different ways to approach the same problem, each with different strengths and weaknesses:</p>
<ul>
<li>We learned that enumerations are the most efficient, especially for simple cases</li>
<li>We learned that trait object references produce the simplest code, at the cost of additional overhead</li>
<li>We learned that the <kbd>Any</kbd> trait gives us a way to refer to almost anything, but we have to explicitly extract the type of information we need</li>
</ul>
<p>In the next chapter, we're going to learn how to store data outside the stack, and why we would want to.</p>


            

            
        
    </div>



  </body></html>