- en: Remember, Remember
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main advantages of using Rust over the likes of C is its memory management.
    For example, C programs will run into buffer overruns and associated undefined
    behavior if you attempt to write past the end of an array or past an area reserved
    using `malloc`. Rust protects against most of these problems without compromising
    on efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will delve into how Rust handles memory and will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the memory system used within Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it can go wrong if you're not careful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at pointers, references, stack overflows, and preventing crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and freeing up memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start at the beginning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0039.html#1565U0-a5175cb437d742a9aed0ea574000ee2d)*, Variables*,
    I briefly mentioned how data is stored within memory, and I said that non-compound
    types, such as `i32`, are stored on the stack, whereas, the likes of `String`,
    `Vector<T>`, types, and such are stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Rust stores data on the stack, as it's incredibly fast. There are
    drawbacks though. The stack is limited in size and the allocation only lasts for
    the lifetime of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, how much memory does a function take?
  prefs: []
  type: TYPE_NORMAL
- en: The stack frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once `main` has exited, the stack frame allocated on entry will be released.
    The beauty of both the allocation and deallocation is that they are carried out
    without the user needing to do anything. The amount of memory can also be computed
    ahead of time, as the compiler knows which local variables are in use. This, again,
    gives a speed increase.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every positive, there is a downside: the values stored only exist for the
    lifetime of the method.'
  prefs: []
  type: TYPE_NORMAL
- en: What is meant by the stack?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to think about the stack is to consider memory as a series
    of boxes. For these examples, think of the boxes in groups of four: the function
    name, the address, the variable name, and the value. Here''s a `main` function
    with a single local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack boxes will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `main` | `0` | `i` | `32` |'
  prefs: []
  type: TYPE_TB
- en: 'A slightly different example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will have two unconnected stack boxes. Since the `second` function
    is never called, we never actually allocate memory on the stack for it. The memory
    allocations are therefore exactly same as in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our third example is where we have the `main` function call to the `second`
    function; in this case, we actually reserve memory for the `second` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of our stack boxes, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `second` | `2` | `a` | `32` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `1` | `b` | `12` |'
  prefs: []
  type: TYPE_TB
- en: '| `main` | `0` | `d` | `100` |'
  prefs: []
  type: TYPE_TB
- en: The variable from the `main` function has the address of 0 as it is from the
    top frame-the frame that calls the other function. The value for the address is
    purely for this example; it can be anywhere and, typically, different types require
    a different amount of the stack to hold them. For instance, if the `number` type
    is 4 bytes in length, the address will be the base address of the stack to store
    `d`, then the address + 4 for `b`, and finally the address + 8 for `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `foo` has returned, the stack reverts to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `main` | `0` | `d` | `100` |'
  prefs: []
  type: TYPE_TB
- en: As soon as the `main` function has finished, the stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: This stacking continues for as many different functions as the application has,
    and they always work in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already discussed, the heap is typically used for complex types. The stack
    frame model can still be used, but it will need modifying, as the stack will need
    to point to the base address of the complex type on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s construct a stack frame for the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `main` | `1` | `f` | `42` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0` | `my_ids` | `(an instance of Vector)` |'
  prefs: []
  type: TYPE_TB
- en: Space is allocated correctly for `f`, but `my_ids` is different; it is a `Vector<i64>`
    with pre-allocated space for five `i64s` values. While the vector itself is stored
    in the stack, its contents are allocated in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Values in the heap are considered to be more persistent than those in the stack.
    That means, unlike values in the stack, their lifetime does not have to be as
    short as the block's they were defined in.
  prefs: []
  type: TYPE_NORMAL
- en: Deallocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike when memory is freed up on the stack, when you deallocate memory from
    the heap, you end up with holes in the heap. These are empty and can be reallocated
    to other variables. As with anything to do with memory, the reallocation is handled
    by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Deallocation is handled automatically by Rust with a style typically called
    **Resource acquisition is initialization**. This confusingly named concept means
    that resources (such as heap memory, but also other things such as file pointers)
    are allocated during object creation and released during object destruction. Object
    destruction in Rust happens when the binding goes out of scope. If you need to
    define custom destructors for your own objects, you can implement the `std::ops::Drop()`
    trait. It contains a single method, `drop`, which gets called when your object
    loses its last binding.
  prefs: []
  type: TYPE_NORMAL
- en: What about functions with arguments?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have created two variable bindings, with the second one (`b`) pointing at
    the address for `a`. The `b` variable doesn't contain the value of the `a` variable,
    but it points to the position `a` is held at, from which it can obtain a value
    (in other words, the value of `b` is borrowed from `a`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of our stack diagram, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `main` | `1` | `b` | `→ address 0` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `0` | `a` | `32` |'
  prefs: []
  type: TYPE_TB
- en: 'If we have a function call another function, but with a parameter, our stack
    will look slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| **Function name** | **Address** | **Variable name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '|  | `3` | `c` | `42` |'
  prefs: []
  type: TYPE_TB
- en: '| second | `2` | `i` | `→ address 0` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `1` | `b` | `→ address 0` |'
  prefs: []
  type: TYPE_TB
- en: '| main | `0` | `a` | `32` |'
  prefs: []
  type: TYPE_TB
- en: The `i` binding points to `address 0` and the `b` variable points to `address
    0`, and this is the parameter being passed to `second`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this stack method to think about memory for a complex situation if
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: Static memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have the stack and heap, Rust also has another type of memory allocation,
    that is, statically allocated memory. This is not allocated at runtime, but moves
    into memory with the program's code before the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: The likes of `static` and `const` variables are good examples of static allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Static memory allocation has the same lifetime as that of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collecting time and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're used to any of the .NET languages, you'll be more than accustomed
    to the **garbage collector** (**GC**). Essentially, when all references to an
    object have gone out of scope, the object's heap allocation is freed up by the
    garbage collector. The garbage collector comes around every once in a while, basically
    checks through the whole space of allocated memory to see if something isn't used
    anymore, and removes such content from memory; in other words, the garbage left
    behind by a deallocated pointer is collected and removed.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has a primitive garbage collector in the form of a reference counted container,
    `Rc<T>`. For most cases, it's not required though, as Rust uses a system known
    as **ownership for allocation**.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, when we created a variable, we created variables that mostly
    live on the stack. These have a very short life span. When we create an object
    that lives on the heap, we create a single variable that points to it, but then
    we can have any number of objects point to it, or even through a copy of the pointer,
    have the copy become the base and free up the original. It gets messy and deallocation
    of the heap memory can lead to a variety of memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: We can wrap any type in a generic container, `Box<T>`. This creates an owned
    pointer in Rust, which can only have a single owner, and when that pointer goes
    out of scope, the memory is automatically freed. In this way, Rust prevents a
    large number of the problems that we see in other languages. The point of this
    owned box is that we can hand out the box to other functions, thus being able
    to return heap allocated variables.
  prefs: []
  type: TYPE_NORMAL
- en: An owned pointer example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `x` variable is the single owner of the `my_rectangle` object on the heap.
    As soon as `allocate_rect()` is complete, the memory on the heap allocated to
    `x` is freed, since the last owner is gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The single owner is enforced by the compiler. The following example demonstrates
    transferring ownership. Once the transfer is complete, the original cannot be
    used again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Comparison to C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the preceding code does:'
  prefs: []
  type: TYPE_NORMAL
- en: The `int` line allocates a block of memory large enough to store an integer
    value. The `memblock` variable will be in the stack, and the block of memory it
    points to will be in the heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A value `256` is placed at the location pointed to by `x`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the memory location pointed to by `x` is printed out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The memory allocated to `memblock` is deallocated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This works well, but has the following three major drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the memory is deallocated, it is still entirely possible to use `memblock`.
    Should you try to do this, the application will exhibit undefined behavior; most
    likely, the application will just quit, but there is also a chance that it will
    corrupt memory, which will cause a system crash. The compiler will make no attempt
    to warn you that you've done this, as it assumes you know what you're doing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you allocate a type larger than what was placed into the `sizeof`, this will
    also give rise to undefined behavior. You are essentially trying to put a quart
    into a pint pot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `free` is not called, the memory remains reserved, even though nothing points
    to it anymore, which leads to memory leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can perform something similar in Rust but, as we''ll see, Rust prevents
    this undefined behavior automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of differences between the C and Rust code versions. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In C, you allocate heap memory with the `malloc` function. In Rust, we use an
    owned pointer via the `Box<T>` generic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `malloc` in C returns an `int` pointer (`int *`). In Rust, a smart
    pointer (`Box<T>`) is returned, in this case to an `i64`. A smart pointer is called
    smart as it controls when the object is freed. This can be when the pointer goes
    out of scope without the pointer being given away. Rust keeps track of objects
    and how to clean the memory up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another useful smart pointer type is the reference counted pointer, `Rc<T>`.
    This generic type allows the sharing of the data inside it over multiple locations.
    It works so that whenever the `Rc` binding gets cloned, a reference count is incremented.
    Whenever such a binding gets deallocated, the reference count is decremented.
    Only when the reference count reaches zero is the underlying value deallocated.
    Note that `Rc<T>` works only in single-threaded scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we make several clones of the reference counted pointer. At the
    peak (on the second line of the `secondMethod` function), we have a total of three
    pointers to the underlying heap. When we leave `secondMethod`, the pointer allocated
    via the `secMemBlock` variable gets destructed. Then the `memBlock` clone gets
    deallocated. Finally, when we exit the main function, the last pointer goes away
    and the heap memory is deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit some old code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in [Chapter 4](part0094.html#2PKKS0-a5175cb437d742a9aed0ea574000ee2d)*,
    Conditions, Recursion, and Loops*, we had some code that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It was explained that what it did was assign the result of `x_cube + x_squared
    + x to y`. If, outside of that, we attempted to access either `x_squared` or `x_cubed`,
    then we wouldn't be able to, as they only existed within the scope of that calculation
    for `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, then, what would happen if we made `y` a reference and tried to point
    it to a temporary value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are assigning `y` to the value of a variable that only exists in a small
    scope (the temporary unnamed value of the computation), then we're trying to access
    that value giving rise to undefined behavior. As we've seen, the Rust compiler
    will do everything it can to prevent this sort of error. In this case, the compiler
    keeps track of each and every reference and fails to build if a reference lasts
    longer than the pointer in use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's not race ahead!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with anything to do with memory, we do have times where memory is shared
    between pointers. Typically, when we write an application, we don't consider that,
    at any given time, there may be multiple threads running at the same time, and
    while we can fairly accurately predict what will happen by following the flow,
    we can sometimes face an issue known as a race condition. Quite simply, we don't
    know which condition will *hit* first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This won't compile because the compiler doesn't know which thread will be `0`
    or `1`, as they both attempt to access `counter` at the same time. In Rust terms,
    `counter` gets moved to the inner thread, which means that it cannot be accessed
    anywhere else. Reference counting via the `Rc` type does not help here, because
    it's not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Stop the race...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can this error be avoided?
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another reference counted type with an incredibly cool name: Atomic
    RC. Atomicity, in this case, refers to non-divisible actions and/or containers,
    which means that they are thread-safe. Also, we''ll need to pair the `Arc` type
    with a `Mutex` to allow us to lock the data for access. Here''s the full code
    for a threaded implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Usually, this code will print `0` because the print method tends to be reached
    before the mutation in the thread takes place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As far as memory handling is concerned, Rust does a lot for the developer and
    virtually ensures that it is impossible to run into the same form of issues as
    found in C. Freeing up memory from the heap is automatic, and there is even protection
    when using pointers by having unique and multiple protected pointers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will have some respite from learning and see how you
    can put what we have covered into your own applications.
  prefs: []
  type: TYPE_NORMAL
