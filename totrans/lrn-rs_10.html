<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating Your Own Crate</h1>
                
            
            <article>
                
<p class="calibre1">Most languages allow for external libraries to be created. These typically contain commonly used pieces of code that are for general use. For example, libraries for deserializing JSON are fairly common, as are math libraries. Rust is no exception. It allows for the creation of libraries (known as <strong class="calibre8">crates</strong>). These crates can be kept to yourself or distributed however you see fit. The metadata about crates is stored on a public service, at <a href="https://crates.io/" class="calibre3">https://crates.io/</a>.</p>
<p class="calibre1">In this chapter, we will cover the following topics:</p>
<ul class="calibre12">
<li class="calibre13">How crates are created</li>
<li class="calibre13">How the directory structure is used</li>
<li class="calibre13">How crates are made up of modules</li>
<li class="calibre13">How to include your crate within your code</li>
<li class="calibre13">How scopes are used with your modules</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What exactly is a crate?</h1>
                
            
            <article>
                
<p class="calibre1">As with all languages, Rust can use external libraries that, we've established are called crates. But what are they?</p>
<p class="calibre1">If we think about a crate, we think either of something we use to hold lots of other things. Software developers like to keep their code clean and if they know what they're doing, they tend to keep their libraries fairly specialized. These specialisms within a crate are known as modules.</p>
<div class="packt_infobox">A crate is a container with one or more modules within it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking at modules</h1>
                
            
            <article>
                
<p class="calibre1">To show how crates are put together, we are going to create one. In this case, it will be a simple math crate.</p>
<p class="calibre1">Before we consider this, let's consider something we all know: a car. We will consider the car a crate, as everything to do with the car is held within it.</p>
<p class="calibre1">To start, let's think about the main parts of the car: the engine, fuel, interior, wheels and movement, and electrics.</p>
<p class="calibre1">There are more but, for now, we will ignore them. Let's represent this as a block diagram to make the relationship clearer:</p>
<div class="cdpaligncenter"><img src="../images/00077.jpeg" class="calibre33"/></div>
<p class="calibre1">We can, of course, split up each of these blocks (for example, we can split the electrics into ignition, audio, windows, heated windscreens, lights, and interior fan).</p>
<p class="calibre1">The car is the crate. Each block is a module. Each split is a submodule. It's now quite simple to see how crates can be visualized.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">I can see a problem with this analogy</h1>
                
            
            <article>
                
<p class="calibre1">There was a reason I chose a car. If we think about it, all of the parts aren't really that discrete; the engine requires fuel, the electrics are needed by the engine, but the engine also generates electricity, and so on. In terms of programming, this will lead to a horrid mess.</p>
<p class="calibre1">How can we keep them apart?</p>
<p class="calibre1">The answer is that we use a scope for each. For example, the top level for this crate would be <strong class="calibre8">Car</strong>. We then add <strong class="calibre8">::</strong> followed by the module name (<strong class="calibre8">Car::Engine</strong>, <strong class="calibre8">Car::Fuel</strong>, and so on.). If a module requires access to another module, it can be included using the usual <kbd class="calibre10">use</kbd> directive.</p>
<div class="packt_infobox"><br class="calibre34"/>
The name of the crate is the name used when the library is created using cargo. In this example, the command line to create this crate will be as follows:<br class="calibre34"/>
<strong class="calibre35">cargo new Car</strong><br class="calibre34"/>
Note that we do not use the <kbd class="calibre22">--bin</kbd> flag.</div>
<p class="calibre1">Consider the following example:</p>
<pre class="calibre21">// in Car::Engine 
use Fuel; 
use Electrics; </pre>
<p class="calibre1">If we break the modules down further, we extend the scope in the same way as we did previously in order to access them:</p>
<pre class="calibre21">// in the main code 
use Car::Interior::Audio; 
use Car::Interior::Windows::HeatedRear; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Back to our math library</h1>
                
            
            <article>
                
<p class="calibre1">Now that we know how crates and modules go together and how their scope allows for the modules to not become confused if they function with the same name (<kbd class="calibre10">Car::Engine</kbd> and <kbd class="calibre10">Car::Electics</kbd> can both have a function called <kbd class="calibre10">voltage_to_earth</kbd>, for example, each does a different action), let's consider our math library.</p>
<p class="calibre1">The library will have four modules with a number of submodules:</p>
<ul class="calibre12">
<li class="calibre13">Trigonometry:
<ul class="calibre31">
<li class="calibre13">Sin/Cos/Tan</li>
<li class="calibre13">Arcsin, Arccos, and Arctan</li>
</ul>
</li>
<li class="calibre13">Regression analysis:
<ul class="calibre31">
<li class="calibre13">Intercept on a straight line</li>
<li class="calibre13">Standard deviation and r<sup class="calibre27">2</sup> value</li>
</ul>
</li>
<li class="calibre13">Conversions:
<ul class="calibre31">
<li class="calibre13">Temperature, pressure, and volume</li>
</ul>
</li>
<li class="calibre13">Base functions:
<ul class="calibre31">
<li class="calibre13">Base <em class="calibre9">n</em> to base 10 conversions</li>
<li class="calibre13">Base 10 to base <em class="calibre9">n</em> conversions</li>
<li class="calibre13">Base <em class="calibre9">m</em> to base <em class="calibre9">n</em> addition, subtraction, multiplication, and division</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using a useful name</h1>
                
            
            <article>
                
<p class="calibre1">Naming within a module is very important; it is going to be visible to anyone using it and should therefore describe what it does. The same applies to function names. For example, <em class="calibre9">f_to_c</em> is fine, but the whole point of a library is that you can get what you are after without having to second-guess what the author meant. A function name such as <em class="calibre9">fahrenheit_to_celcius</em> makes much more sense.</p>
<p class="calibre1">The same applies to modules. If I were to use <em class="calibre9">ra</em> for regression analysis, it might seem like a reasonable name to use, but is it clear? The name can mean anything here. It may seem like a lot of effort to create a module called <em class="calibre9">regression_analysis</em>, but it will help other users know what to expect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's create!</h1>
                
            
            <article>
                
<p class="calibre1">To start, we need to create the crate itself.</p>
<p class="calibre1">To do this, instead of writing the following, we need to tell cargo that we are creating a library:</p>
<pre class="calibre21"><strong class="calibre8">cargo new myapp -bin </strong></pre>
<p class="calibre1">To do this, we simply omit the <kbd class="calibre10">-bin</kbd> flag:</p>
<pre class="calibre21"><strong class="calibre8">cargo new MathLib</strong> </pre>
<p class="calibre1">The following screenshot shows this, followed by the tree structure for the module. You'll notice that <kbd class="calibre10">main.rs</kbd> has been replaced by <kbd class="calibre10">lib.rs</kbd>:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00078.jpeg"/></div>
<div class="packt_figref">Figure 1</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating top-level modules</h1>
                
            
            <article>
                
<p class="calibre1">To create a module, we first need to tell the compiler that the code is held in a module. In this example, I will use the <kbd class="calibre10">Trigonometry</kbd> module:</p>
<pre class="calibre21">mod Trigonometry // top level module 
{ 
    mod Natural  // sub module 
    { 
         
    } 
     
    mod Arc      // sub module 
    { 
         
    } 
} </pre>
<p class="calibre1">When we compile this using <kbd class="calibre10">cargo build</kbd> (not <kbd class="calibre10">cargo run</kbd>; there is no <kbd class="calibre10">main</kbd> function within the library) and examine the tree, we'll see the library (highlighted):</p>
<div class="cdpaligncenter"><img class="image-border18" src="../images/00079.jpeg"/></div>
<div class="packt_figref">Figure 2</div>
<div class="packt_infobox"><span class="chapterrefpackt">The structure for this section can be found in </span><kbd class="calibre22">Chapter10/MathsLibStucture</kbd>.</div>
<p class="calibre1">We can't do very much with it currently as all it contains are placeholders that do very little. Before this goes any further, have a look at the <kbd class="calibre10">lib.rs</kbd> source file. With nothing in except for the module names, it hits 62 lines. Let's think of a very simple example for the <kbd class="calibre10">Conversion</kbd> module, <em class="calibre9">fahrenheit_to_celcius</em>.</p>
<p class="calibre1">The formula to do this is <em class="calibre9">(F - 32) * 5/9</em>. Our function will therefore be the following:</p>
<pre class="calibre21">pub fn fahrenheit_to_celcius(a: f32) -&gt; f32 
{ 
    (a - 32f32) * 5f32 / 9f32 
} </pre>
<p class="calibre1">That was just four lines of code. We also need ones to go from C to F, K to C, C to K, F to K, and K to F (K is Kelvin, which denotes absolute temperature, that is, 0K = -273.15<sup class="calibre27">o</sup>C , also known as absolute zero). Including these will take it to a total of around 24 lines of code. This is a simple module. The ones for regression analysis run to around 100.</p>
<p class="calibre1">Our source file is going to be huge. As we want to keep our modules manageable, we are going to need to break the <kbd class="calibre10">lib.rs</kbd> file down a bit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The multifile module</h1>
                
            
            <article>
                
<p class="calibre1">In order to break our current <kbd class="calibre10">lib.rs</kbd> file down, we are going to have to change how we declare modules.</p>
<div class="packt_infobox">The source for this section is in<span class="chapterrefpackt"> </span><kbd class="calibre22">Chapter10/MathsLibMultiFile and Chapter10/MathsLibMultiFileDirs</kbd>.</div>
<p class="calibre1">Currently, we have this:</p>
<pre class="calibre21">mod Trigonometry // top level module 
{ 
    mod Natural  // sub module 
    {  
    } 
     
    mod Arc      // sub module 
    {  
    } 
} </pre>
<p class="calibre1">To break this into separate files, we need to declare only the top-level modules in <kbd class="calibre10">lib.rs</kbd>:</p>
<pre class="calibre21">mod Trigonometry; 
mod RegressionAnalysis; 
mod Conversions; 
mod Bases; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What about submodules?</h1>
                
            
            <article>
                
<p class="calibre1">When we declare top-level modules like this, Rust will expect there to be either a directory for each of these modules or four source files (<kbd class="calibre10">Trigonometry.rs</kbd>, <kbd class="calibre10">RegressionAnalysis.rs</kbd>, <kbd class="calibre10">Conversions.rs</kbd>, and <kbd class="calibre10">Bases.rs</kbd>). If the directory structure is used, Rust will expect a file called <kbd class="calibre10">mod.rs</kbd> in each directory.</p>
<p class="calibre1">Let's compare how these two systems look, and then we can examine the relative benefits of each. The structure of <kbd class="calibre10">MathsLibMultiFile</kbd> will be as follows:</p>
<div class="cdpaligncenter"><img class="image-border19" src="../images/00080.jpeg"/></div>
<div class="packt_figref">Figure 3a</div>
<p class="calibre1">The structure of <kbd class="calibre10">MathsLibMultiFileDirs</kbd> will be as follows:</p>
<div class="cdpaligncenter"><img class="image-border20" src="../images/00081.jpeg"/></div>
<div class="packt_figref">Figure 3b</div>
<p class="calibre1">At first glance, they seem to be very similar; the only difference is that multifiledir (<em class="calibre9">Fig 3b</em>) has modules broken down into separate files whereas multifile (<em class="calibre9">Fig 3a</em>) only has a single file for each module. This is a limitation of the non-directory structure; the submodules are kept in a single file, which is fine for a very small module but no good for larger modules.</p>
<p class="calibre1">In the directory structure version, there is a <kbd class="calibre10">mod.rs</kbd> file. This is completely empty but is there to let the compiler know that we have submodules. If (say) <kbd class="calibre10">RegressionAnalysis::Statistics</kbd> were to be further broken down, it would be a case of creating a new directory within the <kbd class="calibre10">RegressionAnalysis</kbd> directory called <kbd class="calibre10">Statistics</kbd> (the directory must have the same name as the module) and adding a new <kbd class="calibre10">mod.rs</kbd> file as well as new submodules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The mod.rs file</h1>
                
            
            <article>
                
<p class="calibre1">This file should include an interface to the module itself. The name of the module will point to a file with the same name.</p>
<p class="calibre1">Consider the following example:</p>
<pre class="calibre21">mod mycode;<strong class="calibre8"> </strong></pre>
<p class="calibre1">The preceding line will point to <kbd class="calibre10">mycode.rs</kbd>. You will need to include an interface to each file in that module directory (with the exception of <kbd class="calibre10">mod.rs</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's add some code</h1>
                
            
            <article>
                
<p class="calibre1">We now have the structure in place and our basic framework; we can start adding some code to the library. In this case, it will be the <kbd class="calibre10">Conversions::Temperature</kbd> part. We have already seen the function for Fahrenheit to Celcius, so let's add the other functions:</p>
<pre class="calibre21">// Temperature.rs 
mod Temperature 
{ 
    fn fahrenheit_to_celcius(f: f32) -&gt; f32 
    { 
        (f - 32f32) * 5f32/9f32 
    }  
    fn celcius_to_fahrenheit(f: f32) -&gt; f32 
    { 
        (c * (9f32/5f32)) + 32f32 
    }  
    fn celcius_to_kelvin(c: f32) -&gt; f32 
    { 
        c + 273.15 
    }  
    fn kelvin_to_celcius(k: f32) -&gt; f32 
    { 
        k - 273.15; 
    }  
    fn fahrenheit_to_kelvin(f: f32) -&gt; f32 
    { 
        (f + 459.67) * 5f32 / 9f32 
    }  
    fn kelvin_to_fahrenheit(k: f32) -&gt; f32 
    { 
        (k * (9f32 / 5f32)) - 459.67 
    } 
} </pre>
<p class="calibre1">There is nothing earth-shattering about this code, but we do have to stop for a second to think about this. The Kelvin scale goes from 0 to <em class="calibre9">n</em>; it never goes below zero. It's entirely possible for the user to want to use <kbd class="calibre10">celcius_to_kelvin</kbd> and pass -274 instead. This would mean that the answer from the function would be mathematically correct but physically incorrect.</p>
<div class="packt_infobox"><span class="chapterrefpackt">The code for this section is in </span><kbd class="calibre22">Chapter10/MathsLib</kbd>.</div>
<p class="calibre1">We could return <kbd class="calibre10">-1</kbd> but then, for some of the functions, that answer is fine.</p>
<p class="calibre1">What we need to return here is a tuple with the first parameter being a Boolean, signifying whether the calculation is valid or not (<kbd class="calibre10">true</kbd> = valid). If it's <kbd class="calibre10">true</kbd>, the answer is in the second parameter; otherwise, pass back the original value passed in.</p>
<p class="calibre1">As a quick test, the following code can be run:</p>
<div class="packt_infobox">See <kbd class="calibre22">Chapter10/QuickTest</kbd> for the source.</div>
<pre class="calibre21">fn kelvin_to_celcius(k: f32) -&gt; (bool, f32) 
{ 
    if k &lt; 0f32 
    { 
        return (false, k); 
    } 
    else 
    { 
        return (true, k - 273.15); 
    } 
} 
 
fn main()  
{ 
    let mut calc = kelvin_to_celcius(14.5); 
    match calc.0 
    { 
        true =&gt; println!("14.5K = {}C", calc.1), 
        _ =&gt; println!("equation was invalid"), 
    } 
     
    calc = kelvin_to_celcius(-4f32); 
    match calc.0 
    { 
        true =&gt; println!("-4K = {}C", calc.1), 
        _ =&gt; println!("invalid K"), 
    } 
} </pre>
<p class="calibre1">It is convenient here to use the indexed form of the tuple rather than destructuring it into two variables.</p>
<p class="calibre1">When compiled, we get the following output:</p>
<div class="cdpaligncenter"><img src="../images/00082.jpeg" class="image-border6"/></div>
<div class="packt_figref">Figure 4</div>
<p class="calibre1">This is exactly what was expected. It does also show a need for a set of unit tests to be added into the library to determine the validity (or not) of the data being fed in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Beware of double name scopes</h1>
                
            
            <article>
                
<p class="calibre1">It is quite a common problem to create a crate that may run into an issue known as double name scope. Consider the following example:</p>
<pre class="calibre21">mathslib::conversions::temperature::temperature </pre>
<p class="calibre1">Writing the preceding line instead of the following line causes a major problem:</p>
<pre class="calibre21">mathslib::conversions::temperature; </pre>
<p class="calibre1">The problem is down to the mod.rs and the temperature file.</p>
<p class="calibre1">If you look at <kbd class="calibre10">lib.rs</kbd>, it has in it the name of the module that has to marry up with the name of the directory, which, in turn, contains the <kbd class="calibre10">mod.rs</kbd> file. The <kbd class="calibre10">mod.rs</kbd> file (as we have seen) needs to contain a public interface to the module. Now, following this logic, the code in the <kbd class="calibre10">temperature.rs</kbd> file should also have <kbd class="calibre10">pub mod temperature { ... }</kbd>. It is this final <kbd class="calibre10">pub mod</kbd> that gives the double name scope.</p>
<p class="calibre1">To avoid this problem, just leave the <kbd class="calibre10">pub mod temperature</kbd> line out. As long as the filename matches the <kbd class="calibre10">pub mod</kbd> name in <kbd class="calibre10">mod.rs</kbd>, the compiler will consider that code as belonging to the named mod from <kbd class="calibre10"><span>mod.rs</span></kbd>.</p>
<p class="calibre1">Check out the following code snippet:</p>
<pre class="calibre21">// in mod.rs 
pub mod temperature; 
// all code in temperature.rs "belongs" to mod temperature 
fn celcius_to_kelvin(c: f32) -&gt; (bool, f32) { ... } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding unit tests to the library</h1>
                
            
            <article>
                
<p class="calibre1">We can create tests in one of the two ways: either by adding a <kbd class="calibre10">tests</kbd> directory with a <kbd class="calibre10">lib.rs</kbd> file or by simply adding a file with the tests for that module. As we are already using a directory structure, let's stay with that for the unit tests.</p>
<p class="calibre1">As previously discussed in <a href="part0021.html#K0RQ0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3"><span>Chapter 1</span></a>, <em class="calibre9">Introducing and Installing Rust</em>, to add a unit test, we precede the code with the following:</p>
<pre class="calibre21">#[test] </pre>
<p class="calibre1">Then to build, we need to do the following:</p>
<pre class="calibre21"><strong class="calibre8">cargo test</strong> </pre>
<p class="calibre1">When we do this, though, we hit a problem. Our unit test file looks like this:</p>
<pre class="calibre21">extern crate mathslib; 
use mathsLib::conversions::temperature; 
 
#[cfg(test)] 
mod temperature_tests 
{ 
    #[test] 
    fn test_kelvin_to_celcius_pass() 
    { 
        let calc = kelvin_to_celcius(14.5); 
        assert_eq!(calc.0, true); 
    } 
     
    #[test] 
    #[should_panic(expected = "assertion failed")] 
    fn test_kelvin_to_celcius_fail() 
    { 
        let calc = kelvin_to_celcius(-4f32); 
        assert_eq!(calc.0,true); 
    } 
} </pre>
<p class="calibre1">On the face of it, this should work, but it comes back with something that is somewhat perplexing:</p>
<div class="cdpaligncenter"><img src="../images/00083.jpeg" class="image-border6"/></div>
<div class="packt_figref">Figure 5</div>
<p class="calibre1">This doesn't make sense; we know there is a module called <kbd class="calibre10">Temperature</kbd>, so why are we getting this message? The answer is that it's all down to the privacy of the module and functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making something public</h1>
                
            
            <article>
                
<p class="calibre1">We saw in <span><a href="part0143.html#48C0E0-a5175cb437d742a9aed0ea574000ee2d" class="calibre3">Chapter 7</a>, <em class="calibre9">Matching and Structures</em>,</span> how Rust, by default, sets all the functions, <kbd class="calibre10">structs</kbd>, and so on to be private. This is fine, as it prevents some of the nuts and bolts of the code from being exposed to the public interface.</p>
<p class="calibre1">This does mean, though, that we have to explicitly set the module, and all of the functions we want the user to have access to, to be <kbd class="calibre10">pub</kbd> (public). Therefore, our functions for the temperature conversion will be as follows:</p>
<pre class="calibre21">pub mod Temperature 
{ 
    pub fn fahrenheit_to_celcius(f: f32) -&gt; f32 
    { 
        (f - 32f32) * 5f32/9f32 
    } </pre>
<p class="calibre1">The next time we come to run the unit tests, we should not have this issue, except for the following snag:</p>
<div class="cdpaligncenter"><img src="../images/00084.jpeg" class="image-border6"/></div>
<div class="packt_figref">Figure 6</div>
<p class="calibre1">We have definitely got a <kbd class="calibre10">pub</kbd> function in the <kbd class="calibre10">Temperature</kbd> module called <kbd class="calibre10">kelvin_to_celcius</kbd>. The issue is the following line:</p>
<pre class="calibre21">use mathslib::conversions::temperature; </pre>
<p class="calibre1">What this does is import only the module and none of the symbols (the functions). We can fix this in one of the following four ways:</p>
<ul class="calibre12">
<li class="calibre13">We can use the following:</li>
</ul>
<pre class="calibre36">use mathslib::conversions::temperature::*; </pre>
<ul class="calibre12">
<li class="calibre13">We use the following:</li>
</ul>
<pre class="calibre36">use mathslib::conversions::temperature::kelvin_to_celcius; </pre>
<ul class="calibre12">
<li class="calibre13">We use the following:</li>
</ul>
<p class="calibre28"><kbd class="calibre10">use mathslib::conversions::temperature;</kbd> then precede <kbd class="calibre10">kelvin_to_celcius</kbd> with <kbd class="calibre10">temperature::</kbd></p>
<ul class="calibre12">
<li class="calibre13">We remove the <kbd class="calibre10">use mathslib</kbd> line and add the following line inside <kbd class="calibre10">mod temperature_tests</kbd>:</li>
</ul>
<pre class="calibre36">use super::*; </pre>
<p class="calibre1">Using any of these should allow the tests to compile and run. The output you will see should be something like this:</p>
<div class="cdpaligncenter"><img src="../images/00085.jpeg" class="image-border6"/></div>
<div class="packt_figref">Fig 7: chap10_unittest</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Let's give our crate a quick run out</h1>
                
            
            <article>
                
<p class="calibre1">As it stands, our crate is far from finished. However, there is enough code in there to see whether it actually runs.</p>
<div class="packt_infobox">Code for this section is in<span class="chapterrefpackt"> </span><kbd class="calibre22">Chapter10/first_run_out</kbd>.</div>
<p class="calibre1">Our initial code looks like this:</p>
<pre class="calibre21">extern crate mathslib; 
use mathslib::conversions::temperature::*;  
fn main()  
{ 
    let mut testval = celcius_to_fahrenheit(100f32); 
    println!("100C = {}F", testval.1); // should be 212 
} </pre>
<p class="calibre1">When we build this, we get the following:</p>
<div class="cdpaligncenter"><img src="../images/00086.jpeg" class="image-border6"/></div>
<div class="packt_figref">Figure 7</div>
<p class="calibre1">This stands to reason; we're asking the code to include a library that it has no clue about.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">External dependencies</h1>
                
            
            <article>
                
<p class="calibre1">Normally, if a dependency is outside the application, we would add something like this to the <kbd class="calibre10">Cargo.toml</kbd> file:</p>
<pre class="calibre21">[dependencies] 
mathslib = "0.1.0" </pre>
<p class="calibre1">In this case, we're not able to use cargo to make the build; instead, we need to compile using <kbd class="calibre10">rustc</kbd>. The way cargo works is it recompiles the dependencies for each project (there is no guarantee that each project will use the same set of features for a given crate).</p>
<p class="calibre1">We can simulate a cargo run with the following command:</p>
<pre class="calibre21"><strong class="calibre8">rustc -L . src/main.rs &amp;&amp; ./main</strong> </pre>
<p class="calibre1">The <kbd class="calibre10">-L</kbd> links any libraries in <kbd class="calibre10">.</kbd> (the root directory, where you find <kbd class="calibre10">Cargo.toml</kbd>) to the sources after the <kbd class="calibre10">.</kbd> . The <kbd class="calibre10">/main</kbd> part essentially tells the command-line interpreter to execute the binary called <kbd class="calibre10">./main</kbd> in the root directory (the name comes from the file compiled).</p>
<p class="calibre1">Once we have executed this, we can see our application in all its glory:</p>
<div class="cdpaligncenter"><img src="../images/00087.jpeg" class="image-border6"/></div>
<div class="packt_figref">Figure 8</div>
<p class="calibre1">We now know that our crate (as-is) is running as it should do.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Changing the scope</h1>
                
            
            <article>
                
<p class="calibre1">One of the more interesting features that we can perform with our scope names is to change them. We can also customize which modules to include on our use lines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Altering the crate name</h1>
                
            
            <article>
                
<p class="calibre1">Normally, when we import a crate, we use the following:</p>
<pre class="calibre21">extern crate crate_name; </pre>
<p class="calibre1">However, to avoid confusion with something in your code, you may want to refer to the crate with a different name:</p>
<pre class="calibre21">extern crate crate_name as my_crate; </pre>
<p class="calibre1">It looks very similar to casting, which is because it casts the name <kbd class="calibre10">my_crate</kbd> to be <kbd class="calibre10">crate_name</kbd>.</p>
<p class="calibre1">When we now refer to the crate we don't use the following:</p>
<pre class="calibre21">use crate_name::module; </pre>
<p class="calibre1">We rather use the following:</p>
<pre class="calibre21">use my_crate::module; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Optimizing your use statements</h1>
                
            
            <article>
                
<p class="calibre1">One of the very few things Java has done correctly is the degree of granularity in the way it imports libraries; it pushes the developer to only include the parts of the library actually required by the application. This is down to the history of Java, but it's something that should be encouraged. Rust does something similar.</p>
<p class="calibre1">The <kbd class="calibre10">use</kbd> statement can take a number of different styles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The use-everything approach</h1>
                
            
            <article>
                
<p class="calibre1">This takes the following form:</p>
<pre class="calibre21">use my_crate::module_name::*; </pre>
<p class="calibre1">This is often referred to as the sledgehammer approach, as it makes available all the symbols (the functions, traits, and so on that are public) within the <kbd class="calibre10">module_name</kbd> scope. There is nothing wrong with this approach, but it ends up with a larger binary (which may slow down the final application and will certainly require more memory to run the code).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The you-decide approach</h1>
                
            
            <article>
                
<p class="calibre1">This is the very minimum required to use the <kbd class="calibre10">module_name</kbd> scope:</p>
<pre class="calibre21">use my_crate::module_name; </pre>
<p class="calibre1">Here, you are telling the compiler that <kbd class="calibre10">module_name</kbd> exists and that, as long as the function name exists in the symbols, it can be used. However, in order to use <kbd class="calibre10">module_name</kbd>, the function will need to be preceded by <kbd class="calibre10">module_name</kbd>. For example, to use the <kbd class="calibre10">print_me(f32)</kbd> function, which exists in <kbd class="calibre10">module_name</kbd>, you will have the following:</p>
<pre class="calibre21">let some_text = module_name::print_me(10.1f32);   </pre>
<p class="calibre1">The <kbd class="calibre10">module_name::</kbd> has to be added to tell the compiler to use the <kbd class="calibre10">module_name</kbd> scope rather than the current scope of the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The use-me approach</h1>
                
            
            <article>
                
<p class="calibre1">Here, we tell the compiler that we are only allowing the current scope to use a specific function from within the <kbd class="calibre10">module_name</kbd> scope:</p>
<pre class="calibre21">use my_crate::module_name::print_me; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The use-me-but-call-me-something-else approach</h1>
                
            
            <article>
                
<p class="calibre1">This is very similar to referring to the crate by another name:</p>
<pre class="calibre21">use my_crate::module_name as mod_name; </pre>
<p class="calibre1">This doesn't mean what you probably think it means. With the crate example, we said that we are going to use <kbd class="calibre10">my_crate</kbd>, which is the cast of <kbd class="calibre10">crate_name</kbd>. In this case, what we're saying is that <kbd class="calibre10">mod_name</kbd> is a cast of <kbd class="calibre10">my_crate::module_name</kbd>.</p>
<p class="calibre1">Let's use the following after the preceding line:</p>
<pre class="calibre21">use my_crate::module_name; 
let foo = module_name::print_me(10f32); </pre>
<p class="calibre1">If we do so, we now use the following:</p>
<pre class="calibre21">let foo = mod_name::print_me(10f32); </pre>
<p class="calibre1">It looks the same, but really it means the following:</p>
<pre class="calibre21">let foo = my_crate::module_name::print_me(10f32); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The use-glob approach</h1>
                
            
            <article>
                
<p class="calibre1">This approach is similar to the use-me approach, with the exception of using <kbd class="calibre10">{}</kbd> around what we want the code to have access to (known as a <strong class="calibre8">glob</strong>):</p>
<pre class="calibre21">use my_crate::module_name::{print_me, calculate_time}; </pre>
<p class="calibre1">The line means that the code can access <kbd class="calibre10">module_name::print_me</kbd> and <kbd class="calibre10">module_name::calculate_time</kbd> but nothing else from the <kbd class="calibre10">module_name</kbd> scope.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The use-glob-self approach</h1>
                
            
            <article>
                
<p class="calibre1">Here, the first parameter of the glob is <kbd class="calibre10">self</kbd>. In this context, <kbd class="calibre10">self</kbd> refers back to the root context:</p>
<pre class="calibre21">use my_crate::module_name::{self, print as my_print, calculate as my_calc}; </pre>
<p class="calibre1">In an expanded form, this will equate to the following:</p>
<pre class="calibre21">use my_crate::module_name; 
use my_crate::module_name::print as my_print; 
use my_crate::module_name::calculate as my_calc; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">We covered a lot of ground in this chapter and saw that, for most of the time, cargo makes building a Rust application simple. When testing your own crates outside the project it was originally created in, we need to use <kbd class="calibre10">rustc</kbd> in order to compile. We saw how to create our own libraries, how to add unit tests, how to effectively utilize the use statement, and how to call crates and scopes by different names.</p>
<p class="calibre1">In our next chapter, we will be looking at how we can really make use of Rust's in-built memory protection system to fully utilize concurrency and parallelism.</p>


            </article>

            
        </section>
    </body></html>