- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Programming – a Comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A function defines a transformation, accepts data, and returns the result of
    the transformation.
  prefs: []
  type: TYPE_NORMAL
- en: What is a functor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A functor defines data, accepts a transformation, and returns the result of
    the transformation.
  prefs: []
  type: TYPE_NORMAL
- en: What is a tuple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A tuple is a container of a fixed number of miscellaneous values.
  prefs: []
  type: TYPE_NORMAL
- en: What control flow expression was designed for use with Enums?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pattern matching expressions are a match for Enums, and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: What is the name for a function with a function as a parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions of functions are called higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: How many times will `fib` be called in memoized `fib(20)`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fib` will be called 39 times. `fib` will be invoked 21 times.'
  prefs: []
  type: TYPE_NORMAL
- en: What datatypes can be sent over a channel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sent data must implement `Send`, which is usually derived by the compiler automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Why do functions need to be boxed when returned from a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions are traits so they do not have a known size at compile time. Therefore,
    they must either be parameterized or turned into trait objects with something
    like `Box`.
  prefs: []
  type: TYPE_NORMAL
- en: What does the `move` keyword do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `move` keyword transfers ownership of variables to new contexts.
  prefs: []
  type: TYPE_NORMAL
- en: How could two variables share ownership of a single variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indirect references, such as `Rc`, permit sharing references to the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the ternary operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The if condition is the ternary operator but has the unique Rust syntax of `if
    a { b } else { c }`.
  prefs: []
  type: TYPE_NORMAL
- en: What is another name for unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests are also called **whitebox testing**.
  prefs: []
  type: TYPE_NORMAL
- en: What is another name for integration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integration tests are also called **blackbox testing**.
  prefs: []
  type: TYPE_NORMAL
- en: What is declarative programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declarative programming avoids implementation details when describing a program.
  prefs: []
  type: TYPE_NORMAL
- en: What is imperative programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imperative programming focuses on implementation details when describing a program.
  prefs: []
  type: TYPE_NORMAL
- en: What is defined in the iterator trait?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The iterator trait is defined by an associated `Item` type, and the required
    `next` method.
  prefs: []
  type: TYPE_NORMAL
- en: In which direction will fold traverse the iterator sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fold` will traverse an iterator from left to right, or more specifically,
    from first to last.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a dependency graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dependency graph is a directed graph that describes the dependency relationships
    between nodes. In our case, we use this to describe relationships of the form
    *x* must happen before *y*.
  prefs: []
  type: TYPE_NORMAL
- en: What are the two constructors of `Option`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Option` can be created as `Some(x)` or `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a good library to serialize and deserialize data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We recommend `serde`.
  prefs: []
  type: TYPE_NORMAL
- en: What do the hashtag derive lines in front of the struct declarations in `physics.rs`
    do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are macros that will automatically derive trait implementations for these
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Which comes first in parameterized declarations—lifetimes or traits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lifetime parameters must come before trait parameters in parameter declarations.
  prefs: []
  type: TYPE_NORMAL
- en: In a trait implementation, what is the difference between parameters on the
    impl, trait, or type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `impl<A,...>` syntax defines what symbols will be parameterized. The `Trait<A,...>`
    syntax defines what trait is being implemented. The `Type<A,...>` syntax defines
    what type the trait is being implemented for.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a trait and a data class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The term **data class** is not a Rust term. Think of a data class as if it were
    a trait but without fewer limitations than what Rust might impose.
  prefs: []
  type: TYPE_NORMAL
- en: How should you declare that a package has multiple binaries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Cargo.toml`, list all of the binaries and their entry points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How do you declare a structure field as private?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not declare it as `public`. Fields are `private` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Generics and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an algebraic data type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An algebraic data type is a kind of composite type formed by combining other
    types.
  prefs: []
  type: TYPE_NORMAL
- en: What is polymorphism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphism is the quality of having many forms.
  prefs: []
  type: TYPE_NORMAL
- en: What is parametric polymorphism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parametric polymorphism is  the quality of having many forms according to a
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: What is a ground type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A ground type is a type that has no parameters, modifiers, or substitutions.
    For example, `i32` or `String`.
  prefs: []
  type: TYPE_NORMAL
- en: What is Universal Function Call syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Universal Function Call syntax is used to disambiguate functions or methods.
    It looks like `Foo::f(&b)` instead of `b.f()`.
  prefs: []
  type: TYPE_NORMAL
- en: What are the possible type signatures of a trait object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A trait object is any signature for a trait that will give it a known size at
    compile time. Common examples of this are `&Trait` or `Box<Trait>`.
  prefs: []
  type: TYPE_NORMAL
- en: What are two ways to obscure type information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trait objects and traits in general hide information. Associated types also
    reduce the amount of information necessary to interact with code.
  prefs: []
  type: TYPE_NORMAL
- en: How is a subtrait declared?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Code Organization and Application Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are four ways of grouping code into modules?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our workshop model has four ways of grouping code together: by type, by purpose,
    by layer, and by convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: What does FFI stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FFI stands for Foreign Function Interface.
  prefs: []
  type: TYPE_NORMAL
- en: Why are unsafe blocks necessary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `unsafe` syntax in Rust indicates that you want to use superpowers and that
    you accept the responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Is it ever safe to use unsafe blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing is safe. There is an ongoing effort by core Rust developers to rewrite
    standard library code to use fewer unsafe features. Still, depending on how far
    down you look, there is no absolute safety in any context. For example, the core
    compiler is just assumed to always be logically consistent with regards to safety
    checks (hopefully it is).
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a `libc::c_int` and an `i32`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`c_int` is a direct alias—`type c_int = i32;`.'
  prefs: []
  type: TYPE_NORMAL
- en: Can linked libraries define functions with the same name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++ uses something called name mangling to export symbols with the same name.
    However, Rust does not currently recognize this format with `extern`.
  prefs: []
  type: TYPE_NORMAL
- en: What type of files can be linked into a Rust project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linked libraries can be of the form `name.a`*,* `name.lib`, `name.so`, `name.dylib`,
    `name.dll`, or `name.rlib`, each with their own format.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability, Ownership, and Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does `Rc` stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Rc` stands for Reference Counted.'
  prefs: []
  type: TYPE_NORMAL
- en: What does `Arc` stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Arc` stands for Atomically Reference Counted.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a weak reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A weak reference is a reference that is not reference counted or otherwise managed.
  prefs: []
  type: TYPE_NORMAL
- en: Which superpowers are enabled in unsafe blocks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In an unsafe block, you can dereference a raw pointer, call an unsafe function
    or method, access or modify a mutable static variable, or implement and unsafe
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: When will an object be dropped?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An object will be dropped when its owner is dropped or goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between lifetimes and ownership?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lifetimes are a compile-time check. Ownership is a compile-time as well as runtime
    concept. Both concepts describe the tracking of variables, values, and whether
    and who uses them.
  prefs: []
  type: TYPE_NORMAL
- en: How can you be sure that a function is safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Rust, there is no way to declare the absence of unsafe behavior in functions.
  prefs: []
  type: TYPE_NORMAL
- en: What is memory corruption and how would it affect a program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two types of memory corruption—physical memory corruption and software
    memory corruption. If your physical memory is corrupted, then you need to replace
    your hardware. Software memory corruption refers to anything the program has done
    to destroy the semantic structure of its own program. When memory is corrupted,
    everything goes wrong; this is one of the hardest classes of bugs to diagnose
    and treat.
  prefs: []
  type: TYPE_NORMAL
- en: Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a functor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A functor defines data, accepts a function, and returns a transformation of
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: What is a contravariant functor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A contravariant functor is a functor where the accepted function may produce
    0, 1, or many return values. By comparison, functor's accepted functions must
    return exactly 1 value.
  prefs: []
  type: TYPE_NORMAL
- en: What is a monad?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A monad, parameterized by a single type `A`, is a value that has a trait exposing
    two operations, usually named `return` and `bind`. `return` is a function that
    constructs a new `monad<A>` from a provided `A` value. `bind` should incorporate
    new information to produce a related but separate `monad<B>`.
  prefs: []
  type: TYPE_NORMAL
- en: What are the monad laws?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These equivalencies must hold for strict monads. The three horizontal bars
    means equivalence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What is a combinator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A functional combinator combines functions. A combinator more generator combines
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the impl keyword necessary for closure return values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Closures are traits, not types. Therefore they do not have a size known at compile
    time. `impl` for a return type tells the compiler to parameterize the return type.
  prefs: []
  type: TYPE_NORMAL
- en: What is lazy evaluation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lazy evaluation is when computation is delayed until some point in the future.
    This is compared to eager evaluation, where computation occurs immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a subprocess?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A subprocess is a child process started by a parent process. The child process
    must remain under the parent process to continue to be called a **subprocess**.
  prefs: []
  type: TYPE_NORMAL
- en: Why is fork called fork?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fork means a split (process), like a fork in the road, or a forked tongue.
  prefs: []
  type: TYPE_NORMAL
- en: Is fork still useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes! If you have access to it on your system. For example, the heartbeat pattern
    is much more elegant with fork.
  prefs: []
  type: TYPE_NORMAL
- en: When were threads standardized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Threads have never been universally standardized. The Posix standard introduced
    threads in 1995\. Notably, Windows provides no standard or guarantees regarding
    thread behavior. There are similarities, but no standard.
  prefs: []
  type: TYPE_NORMAL
- en: Why is move sometimes needed for thread closures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move tells the compiler that it is OK to transfer ownership of captured variables
    to the closure.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between `Send` and `Sync` traits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Sync` is a stronger assertion of thread-safety—a type is `Send` if it is safe
    to send it to another thread. A type is `Sync` if it is safe to share between
    threads.'
  prefs: []
  type: TYPE_NORMAL
- en: What are we allowed to lock, then mutate Mutex without an unsafe block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler has determined that Mutex is already safe to use and meets certain
    requirements for safety. That is not to say that bad things can't happen—a Mutex
    will poison itself if one of its `MutexGuards` (the thing it returns when a lock
    is obtained) is dropped during a panic. Any future attempts to lock the Mutex
    will return an `Err` or `panic!`.
  prefs: []
  type: TYPE_NORMAL
- en: Performance, Debugging, and Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is release mode different from debug mode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That depends on your Cargo configuration. By default, there are several compiler
    flags that have different default values in release versus debug mode. One such
    flag is the opt-level that gets sent to the llvm code generation—the default debug
    opt-level is 2, and the default release opt-level is 3\. These defaults can be
    changed in `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: How long will an empty loop take to run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test it out. Otherwise, it is hard to say for sure on every platform. loop will
    always be an infinite loop. while true should maybe also be an infinite loop,
    but will generate a warning. `for _ in 0..99999999 {}` will be removed at opt-level
    3 but not opt-level 2.
  prefs: []
  type: TYPE_NORMAL
- en: What is linear time in Big *O* notation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linear time is *O*(*n*) time.
  prefs: []
  type: TYPE_NORMAL
- en: Name a function that grows faster than exponential growth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Factorial *O*(*n*!) grows faster than exponential growth.
  prefs: []
  type: TYPE_NORMAL
- en: What is faster, a disk read or a network read?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure it. There are many physical factors to consider here.
  prefs: []
  type: TYPE_NORMAL
- en: How would you return a Result with multiple error conditions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rust recommends using enum types to describe multiple error conditions. Being
    lazy, you could also use the `std::any::Any` type.
  prefs: []
  type: TYPE_NORMAL
- en: What is a token tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A token tree is a tree data structure containing tokens. As a result of Rust
    lexing, (...), [...], and {...} token groups will become their own branches.
  prefs: []
  type: TYPE_NORMAL
- en: What is an Abstract Syntax Tree?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An abstract syntax tree is like a token tree but it has a strict structure such
    that only well-formed (Rust) code can be represented by it.
  prefs: []
  type: TYPE_NORMAL
- en: Why do procedural macros need to be compiled separately?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Procedural macros are written with normal Rust code. To be used in compilation,
    procedural macros need to have already been compiled.
  prefs: []
  type: TYPE_NORMAL
