- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Functional Programming – a Comparison
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程——比较
- en: What is a function?
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数是什么？
- en: A function defines a transformation, accepts data, and returns the result of
    the transformation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义了一个转换，接受数据，并返回转换的结果。
- en: What is a functor?
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函子是什么？
- en: A functor defines data, accepts a transformation, and returns the result of
    the transformation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函子定义数据，接受一个转换，并返回转换的结果。
- en: What is a tuple?
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元组是什么？
- en: A tuple is a container of a fixed number of miscellaneous values.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元组是一个固定数量不同值的容器。
- en: What control flow expression was designed for use with Enums?
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为与枚举一起使用而设计的控制流表达式是什么？
- en: Pattern matching expressions are a match for Enums, and vice-versa.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配表达式是枚举的匹配，反之亦然。
- en: What is the name for a function with a function as a parameter?
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数作为参数的函数的名称是什么？
- en: Functions of functions are called higher-order functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的函数被称为高阶函数。
- en: How many times will `fib` be called in memoized `fib(20)`?
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在记忆化的`fib(20)`中，`fib`将被调用多少次？
- en: '`fib` will be called 39 times. `fib` will be invoked 21 times.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib`将被调用39次。`fib`将被调用21次。'
- en: What datatypes can be sent over a channel?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些数据类型可以通过通道发送？
- en: Sent data must implement `Send`, which is usually derived by the compiler automatically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的数据必须实现`Send`，这通常由编译器自动派生。
- en: Why do functions need to be boxed when returned from a function?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么函数在从函数返回时需要被封装？
- en: Functions are traits so they do not have a known size at compile time. Therefore,
    they must either be parameterized or turned into trait objects with something
    like `Box`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是特性，因此在编译时没有已知的大小。因此，它们必须被参数化或通过类似`Box`的方式转换为特性对象。
- en: What does the `move` keyword do?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`move`关键字的作用是什么？'
- en: The `move` keyword transfers ownership of variables to new contexts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`move`关键字将变量的所有权转移到新的上下文中。'
- en: How could two variables share ownership of a single variable?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个变量如何共享单个变量的所有权？
- en: Indirect references, such as `Rc`, permit sharing references to the same data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 间接引用，如`Rc`，允许共享对同一数据的引用。
- en: Functional Control Flow
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式控制流
- en: What is the ternary operator?
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三元运算符是什么？
- en: The if condition is the ternary operator but has the unique Rust syntax of `if
    a { b } else { c }`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件是三元运算符，但具有Rust独特的语法`if a { b } else { c }`。
- en: What is another name for unit tests?
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试的另一个名字是什么？
- en: Unit tests are also called **whitebox testing**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试也被称为**白盒测试**。
- en: What is another name for integration tests?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成测试的另一个名字是什么？
- en: Integration tests are also called **blackbox testing**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试也被称为**黑盒测试**。
- en: What is declarative programming?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是声明式编程？
- en: Declarative programming avoids implementation details when describing a program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程在描述程序时避免实现细节。
- en: What is imperative programming?
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令式编程是什么？
- en: Imperative programming focuses on implementation details when describing a program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程在描述程序时关注实现细节。
- en: What is defined in the iterator trait?
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器特质中定义了什么？
- en: The iterator trait is defined by an associated `Item` type, and the required
    `next` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器特质由一个关联的`Item`类型和所需的`next`方法定义。
- en: In which direction will fold traverse the iterator sequence?
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 折叠操作将遍历迭代器序列的方向是什么？
- en: '`fold` will traverse an iterator from left to right, or more specifically,
    from first to last.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`将从左到右遍历迭代器，或者更具体地说，从第一个到最后一个。'
- en: What is a dependency graph?
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖图是什么？
- en: A dependency graph is a directed graph that describes the dependency relationships
    between nodes. In our case, we use this to describe relationships of the form
    *x* must happen before *y*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖图是一个有向图，描述了节点之间的依赖关系。在我们的情况下，我们使用它来描述形式为*x*必须在*y*之前发生的关联。
- en: What are the two constructors of `Option`?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Option`的两个构造函数是什么？'
- en: '`Option` can be created as `Some(x)` or `None`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`可以创建为`Some(x)`或`None`。'
- en: Functional Data Structures
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: What is a good library to serialize and deserialize data?
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有什么好的库可以用来序列化和反序列化数据？
- en: We recommend `serde`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐`serde`。
- en: What do the hashtag derive lines in front of the struct declarations in `physics.rs`
    do?
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`physics.rs`中结构声明前面的`# derive`行的作用是什么？'
- en: These are macros that will automatically derive trait implementations for these
    data structures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是自动为这些数据结构派生特质实现的宏。
- en: Which comes first in parameterized declarations—lifetimes or traits?
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数化声明中哪个先来——生命周期还是特质？
- en: Lifetime parameters must come before trait parameters in parameter declarations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期参数必须在参数声明中的特性参数之前。
- en: In a trait implementation, what is the difference between parameters on the
    impl, trait, or type?
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特质实现中，impl、trait 或类型上的参数之间有什么区别？
- en: The `impl<A,...>` syntax defines what symbols will be parameterized. The `Trait<A,...>`
    syntax defines what trait is being implemented. The `Type<A,...>` syntax defines
    what type the trait is being implemented for.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`impl<A,...>` 语法定义了哪些符号将被参数化。`Trait<A,...>` 语法定义了正在实现的特质。`Type<A,...>` 语法定义了特质正在为哪种类型实现。'
- en: What is the difference between a trait and a data class?
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特质和数据类之间有什么区别？
- en: The term **data class** is not a Rust term. Think of a data class as if it were
    a trait but without fewer limitations than what Rust might impose.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **数据类** 不是一个 Rust 术语。将数据类想象成一个特质，但比 Rust 可能施加的限制要少。
- en: How should you declare that a package has multiple binaries?
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该如何声明一个包有多个二进制文件？
- en: 'In `Cargo.toml`, list all of the binaries and their entry points:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，列出所有二进制文件及其入口点：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How do you declare a structure field as private?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明结构字段为私有？
- en: Do not declare it as `public`. Fields are `private` by default.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不要声明为 `public`。字段默认是 `private`。
- en: Generics and Polymorphism
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型和多态
- en: What is an algebraic data type?
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是代数数据类型？
- en: An algebraic data type is a kind of composite type formed by combining other
    types.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据类型是一种由其他类型组合而成的复合类型。
- en: What is polymorphism?
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是多态？
- en: Polymorphism is the quality of having many forms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是具有多种形式的质量。
- en: What is parametric polymorphism?
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是参数化多态？
- en: Parametric polymorphism is  the quality of having many forms according to a
    parameter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化多态是根据参数具有多种形式的质量。
- en: What is a ground type?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基础类型？
- en: A ground type is a type that has no parameters, modifiers, or substitutions.
    For example, `i32` or `String`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 基础类型是一种没有任何参数、修饰符或替换的类型。例如，`i32` 或 `String`。
- en: What is Universal Function Call syntax?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是通用函数调用语法？
- en: Universal Function Call syntax is used to disambiguate functions or methods.
    It looks like `Foo::f(&b)` instead of `b.f()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数调用语法用于区分函数或方法。它看起来像 `Foo::f(&b)` 而不是 `b.f()`。
- en: What are the possible type signatures of a trait object?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特质对象的可能类型签名有哪些？
- en: A trait object is any signature for a trait that will give it a known size at
    compile time. Common examples of this are `&Trait` or `Box<Trait>`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 特质对象是任何在编译时将具有已知大小的特质签名。常见的例子有 `&Trait` 或 `Box<Trait>`。
- en: What are two ways to obscure type information?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种方法可以隐藏类型信息？
- en: Trait objects and traits in general hide information. Associated types also
    reduce the amount of information necessary to interact with code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 特质对象和特质通常隐藏信息。关联类型也减少了与代码交互所需的信息量。
- en: How is a subtrait declared?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何声明子特质？
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code Organization and Application Architecture
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织和应用程序架构
- en: What are four ways of grouping code into modules?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪四种方式将代码分组到模块中？
- en: 'Our workshop model has four ways of grouping code together: by type, by purpose,
    by layer, and by convenience.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作坊模型有四种方式将代码分组：按类型、按目的、按层和按便利性。
- en: What does FFI stand for?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FFI 代表什么？
- en: FFI stands for Foreign Function Interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: FFI 代表 Foreign Function Interface。
- en: Why are unsafe blocks necessary?
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要 unsafe 块？
- en: The `unsafe` syntax in Rust indicates that you want to use superpowers and that
    you accept the responsibility.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 中的 `unsafe` 语法表示你想要使用超级能力，并且你接受相应的责任。
- en: Is it ever safe to use unsafe blocks?
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否在某个时候可以使用 unsafe 块是安全的？
- en: Nothing is safe. There is an ongoing effort by core Rust developers to rewrite
    standard library code to use fewer unsafe features. Still, depending on how far
    down you look, there is no absolute safety in any context. For example, the core
    compiler is just assumed to always be logically consistent with regards to safety
    checks (hopefully it is).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么是安全的。核心 Rust 开发者正在进行一项持续的努力，将标准库代码重写为使用更少的 `unsafe` 功能。尽管如此，根据你观察的深度，任何上下文中都没有绝对的安全性。例如，核心编译器只是假设在安全性检查方面始终逻辑上一致（希望它是）。
- en: What is the difference between a `libc::c_int` and an `i32`?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`libc::c_int` 和 `i32` 之间有什么区别？'
- en: '`c_int` is a direct alias—`type c_int = i32;`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`c_int` 是一个直接别名——`type c_int = i32;`。'
- en: Can linked libraries define functions with the same name?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接库能否定义具有相同名称的函数？
- en: C++ uses something called name mangling to export symbols with the same name.
    However, Rust does not currently recognize this format with `extern`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 使用名为名称混淆的技术来导出具有相同名称的符号。然而，Rust 目前不通过 `extern` 识别这种格式。
- en: What type of files can be linked into a Rust project?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以将哪种类型的文件链接到 Rust 项目中？
- en: Linked libraries can be of the form `name.a`*,* `name.lib`, `name.so`, `name.dylib`,
    `name.dll`, or `name.rlib`, each with their own format.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 链接库可以是以下形式之一：`name.a`*、`name.lib`、`name.so`、`name.dylib`、`name.dll`或`name.rlib`，每种都有其自己的格式。
- en: Mutability, Ownership, and Pure Functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性、所有权和纯函数
- en: What does `Rc` stand for?
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rc`代表什么？'
- en: '`Rc` stands for Reference Counted.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc`代表引用计数。'
- en: What does `Arc` stand for?
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Arc`代表什么？'
- en: '`Arc` stands for Atomically Reference Counted.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arc`代表原子引用计数。'
- en: What is a weak reference?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是弱引用？
- en: A weak reference is a reference that is not reference counted or otherwise managed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用是一种不计入引用计数或以其他方式管理的引用。
- en: Which superpowers are enabled in unsafe blocks?
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不安全块中启用了哪些超能力？
- en: In an unsafe block, you can dereference a raw pointer, call an unsafe function
    or method, access or modify a mutable static variable, or implement and unsafe
    trait.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在不安全块中，你可以取消引用原始指针，调用不安全函数或方法，访问或修改可变静态变量，或者实现不安全特质。
- en: When will an object be dropped?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象何时会被丢弃？
- en: An object will be dropped when its owner is dropped or goes out of scope.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当其所有者被丢弃或超出作用域时，对象将被丢弃。
- en: What is the difference between lifetimes and ownership?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生命周期和所有权的区别是什么？
- en: Lifetimes are a compile-time check. Ownership is a compile-time as well as runtime
    concept. Both concepts describe the tracking of variables, values, and whether
    and who uses them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期是编译时检查。所有权是编译时以及运行时概念。这两个概念都描述了变量的跟踪、值以及它们的使用者。
- en: How can you be sure that a function is safe?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保一个函数是安全的？
- en: In Rust, there is no way to declare the absence of unsafe behavior in functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，无法在函数中声明不存在不安全行为。
- en: What is memory corruption and how would it affect a program?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是内存损坏以及它会如何影响程序？
- en: There are two types of memory corruption—physical memory corruption and software
    memory corruption. If your physical memory is corrupted, then you need to replace
    your hardware. Software memory corruption refers to anything the program has done
    to destroy the semantic structure of its own program. When memory is corrupted,
    everything goes wrong; this is one of the hardest classes of bugs to diagnose
    and treat.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的内存损坏——物理内存损坏和软件内存损坏。如果你的物理内存损坏了，那么你需要更换你的硬件。软件内存损坏是指程序对其自身程序语义结构的破坏。当内存损坏时，一切都会出错；这是最难诊断和处理的bug类别之一。
- en: Design Patterns
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: What is a functor?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函子？
- en: A functor defines data, accepts a function, and returns a transformation of
    the data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函子定义数据，接受一个函数，并返回数据的转换。
- en: What is a contravariant functor?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是反变函子？
- en: A contravariant functor is a functor where the accepted function may produce
    0, 1, or many return values. By comparison, functor's accepted functions must
    return exactly 1 value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 反变函子是一种接受函数可能产生0、1或多个返回值的函子。相比之下，函子的接受函数必须返回恰好1个值。
- en: What is a monad?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单子？
- en: A monad, parameterized by a single type `A`, is a value that has a trait exposing
    two operations, usually named `return` and `bind`. `return` is a function that
    constructs a new `monad<A>` from a provided `A` value. `bind` should incorporate
    new information to produce a related but separate `monad<B>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一个参数化单一类型`A`的值，它有一个特质暴露两个操作，通常命名为`return`和`bind`。`return`是一个从提供的`A`值构建新的`monad<A>`的函数。`bind`应该结合新信息以产生一个相关但分离的`monad<B>`。
- en: What are the monad laws?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单子法则？
- en: 'These equivalencies must hold for strict monads. The three horizontal bars
    means equivalence:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些等价性必须对严格单子成立。三个水平条表示等价性：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is a combinator?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是组合器？
- en: A functional combinator combines functions. A combinator more generator combines
    things.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合器结合函数。一个更生成型的组合器结合事物。
- en: Why is the impl keyword necessary for closure return values?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么impl关键字对于闭包返回值是必要的？
- en: Closures are traits, not types. Therefore they do not have a size known at compile
    time. `impl` for a return type tells the compiler to parameterize the return type.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是特质，而不是类型。因此，它们在编译时没有已知的大小。`impl`用于返回类型告诉编译器参数化返回类型。
- en: What is lazy evaluation?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是惰性求值？
- en: Lazy evaluation is when computation is delayed until some point in the future.
    This is compared to eager evaluation, where computation occurs immediately.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值是在未来某个时刻延迟计算。这与立即求值相对，立即求值是指计算立即发生。
- en: Implementing Concurrency
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并发
- en: What is a subprocess?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是子进程？
- en: A subprocess is a child process started by a parent process. The child process
    must remain under the parent process to continue to be called a **subprocess**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程是由父进程启动的子进程。子进程必须保持在父进程下，才能继续被称为**子进程**。
- en: Why is fork called fork?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么fork被称为fork？
- en: fork means a split (process), like a fork in the road, or a forked tongue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: fork意味着一个分裂（进程），就像道路上的分叉，或者分叉的舌头。
- en: Is fork still useful?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fork仍然有用吗？
- en: Yes! If you have access to it on your system. For example, the heartbeat pattern
    is much more elegant with fork.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！如果你可以在你的系统上访问它。例如，心跳模式使用fork会更优雅。
- en: When were threads standardized?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程是在何时标准化的？
- en: Threads have never been universally standardized. The Posix standard introduced
    threads in 1995\. Notably, Windows provides no standard or guarantees regarding
    thread behavior. There are similarities, but no standard.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 线程从未被普遍标准化。Posix标准在1995年引入了线程。值得注意的是，Windows没有提供关于线程行为的标准或保证。有相似之处，但没有标准。
- en: Why is move sometimes needed for thread closures?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么有时需要移动线程闭包？
- en: Move tells the compiler that it is OK to transfer ownership of captured variables
    to the closure.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Move告诉编译器，将捕获的变量的所有权转移到闭包中是可以的。
- en: What is the difference between `Send` and `Sync` traits?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Send`和`Sync`特质的区别是什么？'
- en: '`Sync` is a stronger assertion of thread-safety—a type is `Send` if it is safe
    to send it to another thread. A type is `Sync` if it is safe to share between
    threads.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sync`是对线程安全的一个更强声明——如果一个类型是`Send`，那么它可以安全地发送到另一个线程。一个类型是`Sync`，如果它可以安全地在线程之间共享。'
- en: What are we allowed to lock, then mutate Mutex without an unsafe block?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以锁定什么，然后在不使用unsafe块的情况下突变互斥锁（Mutex）？
- en: The compiler has determined that Mutex is already safe to use and meets certain
    requirements for safety. That is not to say that bad things can't happen—a Mutex
    will poison itself if one of its `MutexGuards` (the thing it returns when a lock
    is obtained) is dropped during a panic. Any future attempts to lock the Mutex
    will return an `Err` or `panic!`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器已确定互斥锁（Mutex）已经足够安全以使用，并满足某些安全要求。但这并不意味着不会发生坏事——如果在恐慌期间丢失了其`MutexGuards`（当获取锁时返回的对象）之一，互斥锁会自我中毒。任何未来的尝试锁定互斥锁都将返回一个`Err`或`panic!`。
- en: Performance, Debugging, and Metaprogramming
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能、调试和元编程
- en: How is release mode different from debug mode?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布模式与调试模式有何不同？
- en: That depends on your Cargo configuration. By default, there are several compiler
    flags that have different default values in release versus debug mode. One such
    flag is the opt-level that gets sent to the llvm code generation—the default debug
    opt-level is 2, and the default release opt-level is 3\. These defaults can be
    changed in `Cargo.toml`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你的Cargo配置。默认情况下，有几个编译器标志在发布和调试模式下有不同的默认值。其中一个标志是发送到llvm代码生成的opt-level，默认的调试opt-level是2，默认的发布opt-level是3。这些默认值可以在`Cargo.toml`中更改。
- en: How long will an empty loop take to run?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个空循环将运行多长时间？
- en: Test it out. Otherwise, it is hard to say for sure on every platform. loop will
    always be an infinite loop. while true should maybe also be an infinite loop,
    but will generate a warning. `for _ in 0..99999999 {}` will be removed at opt-level
    3 but not opt-level 2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。否则，很难在每一个平台上确定。循环将始终是一个无限循环。`while true`可能也是一个无限循环，但会生成一个警告。`for _ in 0..99999999
    {}`将在opt-level 3时被移除，但在opt-level 2时则不会。
- en: What is linear time in Big *O* notation?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大O记号中的线性时间是什么？
- en: Linear time is *O*(*n*) time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间是*O*(*n*)时间。
- en: Name a function that grows faster than exponential growth.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个比指数增长更快的函数。
- en: Factorial *O*(*n*!) grows faster than exponential growth.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘*O*(*n*)!比指数增长增长得更快。
- en: What is faster, a disk read or a network read?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 磁盘读取和网络读取哪个更快？
- en: Measure it. There are many physical factors to consider here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测量一下。这里有许多物理因素需要考虑。
- en: How would you return a Result with multiple error conditions?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何返回包含多个错误条件的`Result`？
- en: Rust recommends using enum types to describe multiple error conditions. Being
    lazy, you could also use the `std::any::Any` type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Rust建议使用枚举类型来描述多个错误条件。由于懒惰，你也可以使用`std::any::Any`类型。
- en: What is a token tree?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 令牌树是什么？
- en: A token tree is a tree data structure containing tokens. As a result of Rust
    lexing, (...), [...], and {...} token groups will become their own branches.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌树是一个包含令牌的树形数据结构。由于Rust的词法分析，(...), [...], 和 {...} 令牌组将变成它们自己的分支。
- en: What is an Abstract Syntax Tree?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象语法树（AST）是什么？
- en: An abstract syntax tree is like a token tree but it has a strict structure such
    that only well-formed (Rust) code can be represented by it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象语法树就像一个标记树，但它有一个严格的结构，只有格式良好的（Rust）代码才能由它表示。
- en: Why do procedural macros need to be compiled separately?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么过程宏需要单独编译？
- en: Procedural macros are written with normal Rust code. To be used in compilation,
    procedural macros need to have already been compiled.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 过程宏是用常规Rust代码编写的。为了在编译中使用，过程宏需要已经被编译。
