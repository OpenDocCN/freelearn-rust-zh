["```rs\nstruct Node {\n    value: i32,\n    next: Option<Node>\n}\n```", "```rs\nstruct TransactionLog {\n    head: Option<Node>, \n    tail: Option<Node>,\n    pub length: u64\n}\n```", "```rs\nerror[E0072]: recursive type `Node` has infinite size\n --> ch4/src/lib.rs:5:1\n |\n5 | struct Node {\n | ^^^^^^^^^^^^^ recursive type has infinite size\n6 | value: i32,\n7 | next: Option<Node>\n | ------------------ recursive without indirection\n |\n = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Node` representable\n```", "```rs\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct Node {\n    value: i32,\n    next: Option<Rc<RefCell<Node>>>\n}\n\nstruct TransactionLog {\n    head: Option<Rc<RefCell<Node>>>,\n    tail: Option<Rc<RefCell<Node>>>,\n    pub length: u64\n}\n```", "```rs\ntype SingleLink = Option<Rc<RefCell<Node>>>;\n\n#[derive(Clone)]\nstruct Node {\n    value: i32,\n    next: SingleLink,\n}\n\n```", "```rs\n#[derive(Clone)]\nstruct Node {\n    value: String,\n    next: SingleLink,\n}\n\nimpl Node {\n    // A nice and short way of creating a new node\n    fn new(value: String) -> Rc<RefCell<Node>> {\n        Rc::new(RefCell::new(Node {\n            value: value,\n            next: None,\n        }))\n    }\n}\n\n```", "```rs\nimpl TransactionLog {\n    pub fn new_empty() -> TransactionLog {\n        TransactionLog { head: None, tail: None, length: 0 }\n\n    }\n}\n```", "```rs\npub fn append(&mut self, value: String) {\n    let new = Node::new(value);\n    match self.tail.take() {\n        Some(old) => old.borrow_mut().next = Some(new.clone()), \n        None => self.head = Some(new.clone())\n    }; \n    self.length += 1;\n    self.tail = Some(new);\n}\n```", "```rs\npub fn pop(&mut self) -> Option<String> {\n    self.head.take().map(|head| {\n        if let Some(next) = head.borrow_mut().next.take() {\n            self.head = Some(next);\n        } else {\n            self.tail.take();\n        }\n        self.length -= 1;\n        Rc::try_unwrap(head)\n            .ok()\n            .expect(\"Something is terribly wrong\")\n            .into_inner()\n            .value\n    })\n}\n```", "```rs\n#[derive(Debug, Clone)]\nstruct Node {\n    value: String,\n    next: Link,\n    prev: Link,\n}\n\ntype Link = Option<Rc<RefCell<Node>>>;\n\n#[derive(Debug, Clone)]\npub struct BetterTransactionLog {\n    head: Link, \n    tail: Link,\n    pub length: u64,\n}\n```", "```rs\npub struct ListIterator {\n    current: Link,\n}\n\nimpl ListIterator {\n    fn new(start_at: Link) -> ListIterator {\n        ListIterator {\n            current: start_at,\n        }\n    }\n}\n```", "```rs\nimpl Iterator for ListIterator {\n    type Item = String;\n    fn next(&mut self) -> Option<String> {\n        let current = &self.current;\n        let mut result = None;\n        self.current = match current {\n            Some(ref current) => {\n                let current = current.borrow();\n                result = Some(current.value.clone());\n                current.next.clone()\n            },\n            None => None\n        };\n        result\n    }\n}\n```", "```rs\nimpl DoubleEndedIterator for ListIterator {\n    fn next_back(&mut self) -> Option<String> {\n        let current = &self.current;\n        let mut result = None;\n        self.current = match current {\n            Some(ref current) => {\n                let current = current.borrow();\n                result = Some(current.value.clone());\n                current.prev.clone()\n            },\n            None => None\n        };\n        result\n    }\n}\n```", "```rs\npub struct LinkedList<T> {\n    head: Option<Shared<Node<T>>>,\n    tail: Option<Shared<Node<T>>>,\n    len: usize,\n    marker: PhantomData<Box<Node<T>>>,\n}\n\nstruct Node<T> {\n    next: Option<Shared<Node<T>>>,\n    prev: Option<Shared<Node<T>>>,\n    element: T,\n}\n\n[...]\n\nimpl<T> LinkedList<T> {\n    /// Adds the given node to the front of the list.\n    #[inline]\n    fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n        unsafe {\n            node.next = self.head;\n            node.prev = None;\n            let node = Some(Shared::from(Box::into_unique(node)));\n\n            match self.head {\n                None => self.tail = node,\n                Some(mut head) => head.as_mut().prev = node,\n            }\n\n            self.head = node;\n            self.len += 1;\n        }\n    }\n\n// [...]  The remaining code was left out.\n\n}\n```", "```rs\ntype Link = Option<Rc<RefCell<Node>>>;\n\nstruct Node {\n    next: Vec<Link>,\n    pub value: u64,\n}\n```", "```rs\nstruct SkipList {\n    head: Link,\n    tails: Vec<Link>,\n    max_level: usize,\n    pub length: u64,\n}\n```", "```rs\n#[derive(Clone)]\nstruct Node {\n    next: Vec<Link>,\n    pub offset: u64,\n    pub command: String,\n}\n```", "```rs\n#[derive(Clone)]\npub struct BestTransactionLog {\n    head: Link,\n    tails: Vec<Link>,\n    max_level: usize,\n    pub length: u64,\n}\n```", "```rs\npub fn append(&mut self, offset: u64, value: String) {\n    let level = 1 + if self.head.is_none() {\n        self.max_level   // use the maximum level for the first node\n    } else { \n        self.get_level() // determine the level by coin flips\n    };\n\n    let new = Node::new(vec![None; level], offset, value);\n\n    // update the tails for each level\n    for i in 0..level {\n        if let Some(old) = self.tails[i].take() {\n            let next = &mut old.borrow_mut().next;\n            next[i] = Some(new.clone());\n        }\n        self.tails[i] = Some(new.clone());\n    }\n\n    // this is the first node in the list\n    if self.head.is_none() {\n        self.head = Some(new.clone());\n    }\n    self.length += 1;\n}\n```", "```rs\n    let level = 1 + if self.head.is_none() {\n        self.max_level\n    } else { \n        self.get_level()\n    };\n    let new = Node::new(vec![None; level], offset, value);\n```", "```rs\nrandomLevel()\n    lvl := 1\n    -- random() that returns a random value in [0...1)\n    while random() < p and lvl < MaxLevel do\n        lvl := lvl + 1\n    return lvl \n```", "```rs\nfn get_level(&self) -> usize {\n    let mut n = 0;\n    // bool = p(true) = 0.5\n    while rand::random::<bool>() && n < self.max_level {\n        n += 1;\n    }\n    n\n}\n```", "```rs\npub fn find(&self, offset: u64) -> Option<String> {\n    match self.head {\n        Some(ref head) => {\n            let mut start_level = self.max_level;\n            let node = head.clone();\n            let mut result = None;\n            loop {\n                if node.borrow().next[start_level].is_some() {\n                    break;\n                }\n                start_level -= 1;\n            }\n            let mut n = node;\n            for level in (0..=start_level).rev() {\n                loop {\n                    let next = n.clone();\n                    match next.borrow().next[level] {\n                        Some(ref next) \n                            if next.borrow().offset <= offset => \n                                n = next.clone(),\n                        _ => break\n                    };\n                }\n                if n.borrow().offset == offset {\n                    let tmp = n.borrow();\n                    result = Some(tmp.command.clone());\n                    break;\n                }\n            }\n            result\n        }\n        None => None,\n    }\n}\n```", "```rs\n            let mut start_level = self.max_level;\n            let node = head.clone();\n            loop {\n                if node.borrow().next[start_level].is_some() {\n                    break;\n                }\n                start_level -= 1;\n            }\n\n```", "```rs\n            let mut n = node;\n            for level in (0..=start_level).rev() {\n                loop {\n                    let next = n.clone();\n                    match next.borrow().next[level] {\n                        Some(ref next) \n                            if next.borrow().offset <= offset => \n                                n = next.clone(),\n                        _ => break\n                    };\n                }\n                if n.borrow().offset == offset {\n                    let tmp = n.borrow();\n                    result = Some(tmp.command.clone());\n                    break;\n                }\n            }\n            result\n```", "```rs\npub struct DynamicArray {\n    buf: Box<[Option<u64>]>,\n    cap: usize, \n    pub length: usize,\n}\n```", "```rs\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);  \n\n    if (newCapacity - minCapacity < 0)  \n        newCapacity = minCapacity;\n\n    if (newCapacity - MAX_ARRAY_SIZE > 0)  \n        newCapacity = hugeCapacity(minCapacity);  \n\n    // minCapacity is usually close to size, so this is a win:          \n    elementData = Arrays.copyOf(elementData, newCapacity);  \n}  \n```", "```rs\ntype Node = Option<u64>;\n```", "```rs\npub struct TimestampSaver {\n    buf: Box<[Node]>,\n    cap: usize,\n    pub length: usize,\n}\n```", "```rs\nfn grow(&mut self, min_cap: usize) {\n    let old_cap = self.buf.len();\n    let mut new_cap = old_cap + (old_cap >> 1);\n\n    new_cap = cmp::max(new_cap, min_cap);\n    new_cap = cmp::min(new_cap, usize::max_value());\n    let current = self.buf.clone();\n    self.cap = new_cap;\n\n    self.buf = vec![None; new_cap].into_boxed_slice();\n    self.buf[..current.len()].clone_from_slice(&current);\n}\n```", "```rs\npub fn at(&mut self, index: usize) -> Option<u64> {\n    if self.length > index {\n        self.buf[index]\n    } else {\n        None\n    }\n}\n```", "```rs\npub struct ListIterator {\n    current: usize,\n    data: Box<[Node]>,\n}\n```", "```rs\nimpl Iterator for ListIterator {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        if self.current < self.data.len() {\n            let item = self.data[self.current];\n            self.current += 1;\n            item\n        } else {\n            None\n        }\n    }\n}\n\nimpl DoubleEndedIterator for ListIterator {\n    fn next_back(&mut self) -> Option<u64> {\n        if self.current < self.data.len() {\n            let item = self.data[self.current];\n            if self.current == 0 {\n                self.current = self.data.len() - 1;\n             } else {\n                self.current -= 1;\n            }\n            item\n        } else {\n            None\n        }\n    }\n}\n```"]