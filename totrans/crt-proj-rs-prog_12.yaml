- en: Assessments
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, it is *The Rust Programming Language* by Steve Klabnik and Carol Nichols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In 2015, it was long 64 bits (or 8 bytes). At the end of 2018, it was long 128
    bits (or 16 bytes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They are networking, command-line applications, WebAssembly, and embedded software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks for non-idiomatic syntax and suggests changes to code for better maintainability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It converts a 2015 edition project to a 2018 edition project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this dependency to the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this code to the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dependency used in the previous question, add this code to the `main.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this dependency to the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, insert this code into the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, add this dependency to the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, insert this code into the `main.rs` file and execute `RUST_LOG=warn cargo
    run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this dependency to the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this code to the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because changes applied by software lose all the comments inserted by the user
    and sort the items in alphabetical order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamically typed parsing is better when you are not sure which fields will
    be present in the file and you want to allow some missing fields. Statically typed
    parsing is better when you want to discard files that do not respect the expected
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A derive from `Serialize` is needed when you want to send (write) a data structure
    out of your software. A derive from `Deserialize` is needed when you want to receive
    (read) a data structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a format in which fields are indented to show the structure of the data
    visually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it minimizes the use of memory by loading data into memory a little
    at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SQLite is better when you want to save disk space, memory space, start up time,
    and sometimes also throughput. PostgreSQL is better when you have complex security
    needs, or when your data must be accessible for several users at a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a reference to a slice of references to objects that can be converted
    to `ToSql`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This replaces the parameters in a SQL `SELECT` statement and then creates and
    returns an iterator on the rows selected by that statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `get` function reads a value; the `set` function writes a value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s use a local instance of Redis, already containing the association *aKey
    => a string*. Add this dependency to the `Cargo.toml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this code to the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GET` requests a resource to be downloaded; `PUT` sends some data to replace
    existing data; `POST` sends some data that the server should consider as new;
    `DELETE` requests the removal of a resource.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Curl utility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The handler declares an argument, such as `info: Path<(String,)>`, and then
    the value of the `&info.0` expression is a reference to the first URI parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `content_type` method of the `HttpResponse` type – for example, `HttpResponse::Ok().content_type("application/json")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a pseudo-random number generator, you generate a large integer number,
    format it as a string, and append that string to a prefix. Then, you try to create
    a new file having that name. If such creation fails because another file exists
    with that name, you try to generate another filename, until you find an unused
    combination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To cache information that can be obtained again using any request, but for which
    it would be costly to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the state is shared by all requests, and Actix web uses several threads
    to handle the requests, and so the state must be thread-safe. The typical way
    of declaring a thread-safe object in Rust is to encapsulate it in a Mutex object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the server may have to wait for the arrival of data from a database,
    the filesystem, or another process. During such a wait, it can serve other requests.
    Multithreading is another possible solution, but that yields an inferior performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It chains another future to the current one. The second closure will be executed
    asynchronously after the first one has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`serde`, to serialize anything; `serde_derive`, to automatically implement
    serialization for some data types; and `serde_json` to automatically implement
    serialization for JSON data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The possible strategies for creating HTML code containing variable parts are
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code only**: You have a programming language source file that contains a
    lot of statements that print strings to create the desired HTML page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML with tags**: You write an HTML file containing the desired constant
    HTML elements and the desired constant text, but it also contains some statements
    enclosed in specific markers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML templates**: You write HTML templates containing tags and application
    code that fills those tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double braces are used – for example, `{{id}}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `{%` and `%}` markers are used, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, an object of the `tera::Context` type is created, and then, the necessary name-value
    associations are added to such an object, using its `insert` method. Finally,
    that context is passed as an argument to the `render` method of the Tera engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At an architectural level, a request can be thought of as a data manipulation
    command, or as a request to get a document to display in the browser. Traditionally,
    the two kinds of requests were merged in a data manipulation command whose response
    is the new content of the current page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because some parts (the metadata, the scripts, the styles, and possibly the
    page header and footer) do not change during the session or change rarely. Other
    parts (usually the central part, or a smaller part) change with any click from
    the user. By reloading only the part that changes, the app has better performance
    and usability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The loading of all template files happens at runtime, and so the template's
    subtree must be deployed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The built-in JavaScript `XMLHttpRequest` class can be instantiated, and such
    instances have methods to send HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be stored in a global JavaScript variable inside the current web page
    in the web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A handler can have an argument of the `BasicAuth` type that encapsulates the
    authorization header of the HTTP request. Such an object has the `user_id` and
    `password` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a standard machine language-like programming language, accepted by all
    major web browsers. It can be more efficient than JavaScript, but is more portable
    than other machine language-like programming languages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an architectural pattern for interactive software. It uses the concepts
    of *model*, meaning the data structure that contains the state of the application; *view*,
    meaning the code that uses the current value of the model to display the contents
    of a window or a portion of a window; and *controller*, meaning the code that
    is activated by user actions on the window, updating the value of the model and
    activating the view refresh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The specific version of the MVC implementation used by Yew and the Elm language
    is based on a collection of programmer-defined possible events, named *messages*.
    When the view detects such a possible event, the controller is notified by a message
    that's associated with the kind of event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Yew components are the instances of an MVC pattern. Every triple model-view-controller
    is a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Yew properties are the data that any parent component passes to its child
    component when it creates them. They are needed to share data in a hierarchy of
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create two Yew components – one that handles the inner section and one that
    handles the header and footer – and that one contains the other component as its
    child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Callbacks are callable objects that a component passes as properties to one
    of its child components to let it access features of the parent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You pass it as a property, encapsulating it into an object of the `std::rc::Rc<std::cell::RefCell>` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because if you keep it only in a local variable, it is destroyed when the function
    in which it is created ends. To ensure it survives until the arrival of the response
    from the server, this object must be kept in a structure that lives longer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your model, you declare an object of the `DialogService` type, and you use
    its `alert` and `confirm` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is left to the reader. I've created an example in the book's GitHub repo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is an architecture of interactive software, used mainly in games. At periodic
    intervals, the framework checks the status of input devices, modifies the model
    accordingly, and then invokes the draw routine. Its advantage is that it better
    corresponds to a situation in which input devices have continuous input, such
    as a key being pressed for some time, or screen output changing continuously,
    even if the user does nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When input events are discrete, such as a mouse click on a button or text typed
    into a box, and when output happens only because of a user action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous simulation software, industrial machine monitoring software, or multimedia
    software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a shape, you call the `draw_ex` method of the current window. The first
    argument of that method describes the shape to draw; it may be an instance of
    the `Triangle`, `Rectangle`, or `Circle` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `update` function, you can check the state of any key of the keyboard.
    For example, the `window.keyboard()[Key::Right].is_down()` expression returns
    `true` if the right-arrow key is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The model must implement the `State` trait. In that trait, the `update` method
    is the controller, and the `draw` method is the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quicksilver has two rates, one for the `update` method and one for the `draw`
    method. They have default values, but if you want to change them, set the `update_rate`
    and `draw_rate` fields of the `Settings` structure passed to the `run` function
    that starts the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You start to load a font by calling the `Font::load(filename)` function, you
    start to load a sound by calling the `Sound::load(filename)` function, and so
    on. Such calls return a future waiting for the actual asset to load. Then, you
    call the `Asset::new` function, specifying the future as its argument. The first
    time it is used, it will wait for the complete loading of the asset. The assets
    must be in a folder named `static` at the root of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After having loaded a recorded sound asset in a variable, you may call the `play_sound` function, and
    pass that asset as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After having loaded a font asset in a variable, in the `draw` method,  you may
    call the `execute` method of that asset, which waits for the complete loading
    of the font, and then you call the `render` method of the loaded asset to draw
    the text in an image. Then, you can draw that image on the window by calling the
    `draw` method of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vector is an entity that can be added to another vector and can be multiplied
    by a number. It is senseless to add two points or to multiply a point by a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In geometry, a vector is a translation or displacement; a point is a position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because some events are discrete. For example, when I click on a button, I am
    not interested in how many milliseconds the mouse is pressed; I just want to get
    one click event. If I type a word, I want to get just one character input for
    every key pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because assets are usually loaded only at application startup, or when a level
    is entered or exited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The optional `key_down_event`, `key_up_event`, `mouse_button_down_event`, and
    `mouse_button_up_event` methods can be defined for the `EventHandler` trait. 
    Such methods register in the model that they have been called (that is, that the
    corresponding events have happened in the time frame). Then, the `update` method
    checks and resets such settings in the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a set of shapes to draw. To draw a shape, first, you build a new `Mesh`
    instance, then you add shapes to it (rectangles, triangles, and so on), and then
    you can draw that mesh on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The general way is to create a `MeshBuilder` instance by using `MeshBuilder::new()`;
    add shapes to that builder, with its methods (`rectangle`, `polygon`, and so on);
    and then call the `build` method, which returns a `Mesh` instance. But there are
    shorter ways, such as the `Mesh::new_circle` function, which returns a `Mesh` instance containing
    a single circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `update` method is always called at top speed, but it checks the internal
    timer repeatedly to execute its body only the desired number of times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `draw` function uses as arguments the context to receive the drawing, the
    mesh to draw, and a `DrawParam` structure. This structure can contain the geometric
    transformation to apply to the mesh while drawing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `audio::Source` objects have several methods, including the `play` and `play_detached` methods.
    The first one automatically stops the previous sound before playing the specified
    one; the second one overlaps its sound with existing ones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular languages are ones that can be defined by a regular expression, which
    is a combination of three operators: concatenation, alternation, and repetition.
    Context-free languages are ones that can contain regular operators, plus matching
    symbols (such as parentheses). Context-dependent languages are those in which
    the validity of any expression may depend on any other expression defined previously.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a set of rules in which the program is a symbol, and every symbol is defined
    as the concatenation or alternation of symbols or characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a program that gets as input a formal definition of a programming language
    and generates as output a compiler, which is a program that parses (or even compiles
    to machine language) programs written in the language specified by that formal
    definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a function that takes as input one or more parsers and returns a parser
    that combines the input parsers in some way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because, before the 2018 edition of Rust, the Rust language did not allow functions
    that returned functions without encapsulating them in an allocated object. The
    feature that allows a function to be returned with no allocation is named `impl
    Trait`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `tuple` parser combinator gets a fixed sequence of parsers and returns a
    parser that applies them in sequence. The `alt` parser combinator gets a fixed
    sequence of parsers and returns a parser that applies them alternatively. The
    `map` parser combinator gets a parser and a closure and returns a parser that
    applies that parser and then uses the closure to transform its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lexical analysis, syntax analysis, semantic analysis, and interpretation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lexical analysis, syntax analysis, semantic analysis, generation of intermediate
    code, optimization of intermediate code, generation of relocatable machine code,
    and linking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an identifier is defined, the symbol table is needed to check that such
    a name has not been defined yet in the current scope, if the language does not
    allow the shadowing of an identifier. When an identifier is used, the symbol table
    is needed to check that such a name has already been defined and that it has a
    type compatible with the usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an identifier is defined, the symbol table is needed to store the initial
    value of the identifier. When an identifier is used, the symbol table is needed
    to get or set the value associated with such an identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Possible uses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run a binary program for a computer when that computer is not available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To debug or analyze a binary program when its source code is not available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To disassemble machine code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To translate a binary program into another machine language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To translate a binary program into a high-level programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the main data register. It is the default source and destination of any
    instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is the main address register. It contains the address of the next instruction
    that will be fetched and executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One reason is that the use of numbers is more error-prone than the use of names.
    The other is that when an instruction or a variable is added or removed, the addresses
    of all the following instructions or variables change, and so a lot of addresses
    in code must be incremented or decremented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a variant for every instruction type. The name of the variant is the
    symbolic name of the instruction, and its parameters are the types of the operands
    of the instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Little-endian notation is where the low byte of a word has a lower memory address,
    and big-endian notation is where the high byte has a lower memory address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a parser that accepts text, the input is a reference to a string slice,
    with an `&str` type, while for a parser that accepts binary data, the input is
    a reference to a slice of bytes, with an `&[u8]` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The rules to be respected are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It begins with a little-endian word containing the size of the process in bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the initial word, there is a sequence of valid machine language instructions,
    with no interleaved spaces or data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Terminate` instruction occurs once—and only once—as the last instruction
    so that it marks the end of the sequence of instructions. After this, there is
    only data left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No statement writes on the instructions; only the data can be changed. So, the
    program is not self-modifying; put differently, the program instructions are the
    same as the process instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because a 16-bit number can be usefully regarded sometimes as a pair of bytes
    and sometimes as a single number. Hexadecimal format satisfies both requirements
    because every pair of hexadecimal digits is a byte, and the whole four-digit sequence
    is a 16-bit number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By encapsulating it in a new type and then implementing the `Debug` trait for
    the type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is an extension of the Linux operating system kernel that can be added or
    removed at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The C programming language, with GCC extensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a memory-only log area to which every kernel module can write. When a
    kernel module writes to it, a bracket-enclosed timestamp is added at the beginning
    of every line; this is the number of seconds and microseconds since the start
    of the kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ModInfo` prints some information about a Linux module file; `LsMod` prints
    the list of all the currently loaded modules; `InsMod` loads a Linux module from
    the specified file and adds it to the running kernel; and `RmMod` unloads the
    specified module from the running Linux kernel.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the `#![no_std]` directive prevents the use of the standard heap allocator
    and of all the standard types that use it. This directive is required as any kernel
    module needs a custom allocator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a directive to the linker to keep the exact name of the following function
    so that the kernel can find that function by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It specifies that the function-calling convention must be the one normally used
    by the C language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'They are two entry points of the module: the `init_module` function is invoked
    by the kernel when the module is loaded, and the `cleanup_module` function is
    invoked by the kernel when the module is unloaded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`__register_chrdev` is used to register a character device in the kernel; `__unregister_chrdev`
    is used to deregister it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `_copy_to_user` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
