- en: Assessments
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章
- en: Yes, it is *The Rust Programming Language* by Steve Klabnik and Carol Nichols.
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，这是由 Steve Klabnik 和 Carol Nichols 编著的 **《Rust 编程语言》**。
- en: In 2015, it was long 64 bits (or 8 bytes). At the end of 2018, it was long 128
    bits (or 16 bytes).
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2015 年，它是长 64 位（或 8 字节）。到 2018 年底，它是长 128 位（或 16 字节）。
- en: They are networking, command-line applications, WebAssembly, and embedded software.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们是网络、命令行应用程序、WebAssembly 和嵌入式软件。
- en: It checks for non-idiomatic syntax and suggests changes to code for better maintainability.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查非惯用语法，并建议对代码进行更改以实现更好的可维护性。
- en: It converts a 2015 edition project to a 2018 edition project.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将 2015 版本的项目转换为 2018 版本的项目。
- en: 'Add this dependency to the `Cargo.toml` file:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add this code to the `main.rs` file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码添加到 `main.rs` 文件中：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the dependency used in the previous question, add this code to the `main.rs` file:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前一个问题中使用的依赖项，将此代码添加到 `main.rs` 文件中：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add this dependency to the `Cargo.toml` file:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, insert this code into the `main.rs` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码插入到 `main.rs` 文件中：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, add this dependency to the `Cargo.toml` file:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将此依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, insert this code into the `main.rs` file and execute `RUST_LOG=warn cargo
    run`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码插入到 `main.rs` 文件中并执行 `RUST_LOG=warn cargo run`：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add this dependency to the `Cargo.toml` file:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, add this code to the `main.rs` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码添加到 `main.rs` 文件中：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chapter 2
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章
- en: Because changes applied by software lose all the comments inserted by the user
    and sort the items in alphabetical order.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为软件应用的变化会丢失用户插入的所有注释，并按字母顺序排序项目。
- en: Dynamically typed parsing is better when you are not sure which fields will
    be present in the file and you want to allow some missing fields. Statically typed
    parsing is better when you want to discard files that do not respect the expected
    format.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你不确定文件中哪些字段将存在，并希望允许一些缺失字段时，动态类型解析更好。当你想要丢弃不遵守预期格式的文件时，静态类型解析更好。
- en: A derive from `Serialize` is needed when you want to send (write) a data structure
    out of your software. A derive from `Deserialize` is needed when you want to receive
    (read) a data structure.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要将数据结构从你的软件中发送（写入）时，需要一个从 `Serialize` 派生的类型。当你想要接收（读取）数据结构时，需要一个从 `Deserialize`
    派生的类型。
- en: This is a format in which fields are indented to show the structure of the data
    visually.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个字段缩进以直观显示数据结构的格式。
- en: Because it minimizes the use of memory by loading data into memory a little
    at a time.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为它通过分批将数据加载到内存中来最小化内存的使用。
- en: SQLite is better when you want to save disk space, memory space, start up time,
    and sometimes also throughput. PostgreSQL is better when you have complex security
    needs, or when your data must be accessible for several users at a time.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQLite 在你想节省磁盘空间、内存空间、启动时间和有时也提高吞吐量时更好。PostgreSQL 在你有复杂的安全需求，或者你的数据必须同时供多个用户访问时更好。
- en: This is a reference to a slice of references to objects that can be converted
    to `ToSql`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个指向可以转换为 `ToSql` 的对象的引用的切片的引用。
- en: This replaces the parameters in a SQL `SELECT` statement and then creates and
    returns an iterator on the rows selected by that statement.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这替换了 SQL `SELECT` 语句中的参数，然后创建并返回由该语句选择的行的迭代器。
- en: The `get` function reads a value; the `set` function writes a value.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get` 函数读取值；`set` 函数写入值。'
- en: 'Let''s use a local instance of Redis, already containing the association *aKey
    => a string*. Add this dependency to the `Cargo.toml` file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个包含关联 *aKey => a string* 的本地 Redis 实例。将此依赖项添加到 `Cargo.toml` 文件中：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add this code to the `main.rs` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此代码添加到 `main.rs` 文件中：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Chapter 3
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章
- en: '`GET` requests a resource to be downloaded; `PUT` sends some data to replace
    existing data; `POST` sends some data that the server should consider as new;
    `DELETE` requests the removal of a resource.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET` 请求下载资源；`PUT` 发送数据以替换现有数据；`POST` 发送一些服务器应视为新数据的数据；`DELETE` 请求删除资源。'
- en: The Curl utility.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Curl 工具。
- en: 'The handler declares an argument, such as `info: Path<(String,)>`, and then
    the value of the `&info.0` expression is a reference to the first URI parameter.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '处理器声明一个参数，例如 `info: Path<(String,)>`，然后 `&info.0` 表达式的值是第一个 URI 参数的引用。'
- en: By using the `content_type` method of the `HttpResponse` type – for example, `HttpResponse::Ok().content_type("application/json")`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `HttpResponse` 类型的 `content_type` 方法——例如，`HttpResponse::Ok().content_type("application/json")`。
- en: Using a pseudo-random number generator, you generate a large integer number,
    format it as a string, and append that string to a prefix. Then, you try to create
    a new file having that name. If such creation fails because another file exists
    with that name, you try to generate another filename, until you find an unused
    combination.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用伪随机数生成器生成一个大整数，将其格式化为字符串，并将其附加到前缀。然后，你尝试创建一个具有该名称的新文件。如果创建失败，因为另一个文件已存在且具有该名称，你将尝试生成另一个文件名，直到找到一个未使用的组合。
- en: To cache information that can be obtained again using any request, but for which
    it would be costly to do so.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了缓存可以使用任何请求再次获取的信息，但这样做成本较高。
- en: Because the state is shared by all requests, and Actix web uses several threads
    to handle the requests, and so the state must be thread-safe. The typical way
    of declaring a thread-safe object in Rust is to encapsulate it in a Mutex object.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为状态被所有请求共享，并且Actix web使用多个线程来处理请求，所以状态必须是线程安全的。在Rust中声明线程安全对象的典型方式是将它封装在Mutex对象中。
- en: Because the server may have to wait for the arrival of data from a database,
    the filesystem, or another process. During such a wait, it can serve other requests.
    Multithreading is another possible solution, but that yields an inferior performance.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为服务器可能需要等待从数据库、文件系统或另一个进程获取数据，在此等待期间，它可以处理其他请求。多线程是另一种可能的解决方案，但性能较差。
- en: It chains another future to the current one. The second closure will be executed
    asynchronously after the first one has finished.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将另一个future链接到当前future上。第一个future完成后，第二个闭包将异步执行。
- en: '`serde`, to serialize anything; `serde_derive`, to automatically implement
    serialization for some data types; and `serde_json` to automatically implement
    serialization for JSON data.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`serde` 用于序列化任何内容；`serde_derive` 用于自动为某些数据类型实现序列化；以及 `serde_json` 用于自动为JSON数据实现序列化。'
- en: Chapter 4
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: 'The possible strategies for creating HTML code containing variable parts are
    as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含可变部分的HTML代码的可能策略如下：
- en: '**Code only**: You have a programming language source file that contains a
    lot of statements that print strings to create the desired HTML page.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅代码**：你有一个包含许多打印字符串以创建所需HTML页面的编程语言源文件。'
- en: '**HTML with tags**: You write an HTML file containing the desired constant
    HTML elements and the desired constant text, but it also contains some statements
    enclosed in specific markers.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有标签的HTML**：你编写一个包含所需常量HTML元素和所需常量文本的HTML文件，但它还包含一些用特定标记括起来的语句。'
- en: '**HTML templates**: You write HTML templates containing tags and application
    code that fills those tags.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML模板**：你编写包含标签和填充这些标签的应用代码的HTML模板。'
- en: Double braces are used – for example, `{{id}}`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用双花括号，例如，`{{id}}`。
- en: 'The `{%` and `%}` markers are used, as shown here:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里使用 `{%` 和 `%}` 标记，如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, an object of the `tera::Context` type is created, and then, the necessary name-value
    associations are added to such an object, using its `insert` method. Finally,
    that context is passed as an argument to the `render` method of the Tera engine.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `tera::Context` 类型的对象，然后使用其 `insert` 方法向该对象添加必要的名称-值关联。最后，将此上下文作为参数传递给Tera引擎的
    `render` 方法。
- en: At an architectural level, a request can be thought of as a data manipulation
    command, or as a request to get a document to display in the browser. Traditionally,
    the two kinds of requests were merged in a data manipulation command whose response
    is the new content of the current page.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在架构层面，可以将请求视为数据操作命令，或视为请求在浏览器中显示文档。传统上，这两种类型的请求合并为一个数据操作命令，其响应是当前页面的新内容。
- en: Because some parts (the metadata, the scripts, the styles, and possibly the
    page header and footer) do not change during the session or change rarely. Other
    parts (usually the central part, or a smaller part) change with any click from
    the user. By reloading only the part that changes, the app has better performance
    and usability.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为一些部分（元数据、脚本、样式，以及可能还有页面头部和页脚）在会话期间不会改变或很少改变。其他部分（通常是中心部分或较小部分）会随着用户的任何点击而改变。通过只重新加载改变的部分，应用程序具有更好的性能和可用性。
- en: The loading of all template files happens at runtime, and so the template's
    subtree must be deployed.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有模板文件都是在运行时加载的，因此必须部署模板的子树。
- en: The built-in JavaScript `XMLHttpRequest` class can be instantiated, and such
    instances have methods to send HTTP requests.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置的JavaScript `XMLHttpRequest` 类可以被实例化，并且这些实例有发送HTTP请求的方法。
- en: It should be stored in a global JavaScript variable inside the current web page
    in the web browser.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该存储在当前网页中的全局JavaScript变量中。
- en: A handler can have an argument of the `BasicAuth` type that encapsulates the
    authorization header of the HTTP request. Such an object has the `user_id` and
    `password` methods.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理器可以有一个`BasicAuth`类型的参数，该参数封装了HTTP请求的授权头。这样的对象具有`user_id`和`password`方法。
- en: Chapter 5
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: It is a standard machine language-like programming language, accepted by all
    major web browsers. It can be more efficient than JavaScript, but is more portable
    than other machine language-like programming languages.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种类似于标准机器语言的编程语言，被所有主要网络浏览器接受。它可以比JavaScript更高效，但比其他类似机器语言的编程语言更便携。
- en: It is an architectural pattern for interactive software. It uses the concepts
    of *model*, meaning the data structure that contains the state of the application; *view*,
    meaning the code that uses the current value of the model to display the contents
    of a window or a portion of a window; and *controller*, meaning the code that
    is activated by user actions on the window, updating the value of the model and
    activating the view refresh.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种交互式软件的架构模式。它使用*模型*的概念，即包含应用程序状态的数据库结构；*视图*，即使用模型的当前值来显示窗口或窗口一部分的代码；以及*控制器*，即由用户在窗口上的操作激活的代码，更新模型值并激活视图刷新。
- en: The specific version of the MVC implementation used by Yew and the Elm language
    is based on a collection of programmer-defined possible events, named *messages*.
    When the view detects such a possible event, the controller is notified by a message
    that's associated with the kind of event.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Yew和Elm语言使用的MVC实现的具体版本基于程序员定义的可能事件集合，称为*消息*。当视图检测到此类可能事件时，控制器通过与事件类型相关联的消息通知。
- en: The Yew components are the instances of an MVC pattern. Every triple model-view-controller
    is a component.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Yew组件是MVC模式的一个实例。每个三联模型-视图-控制器都是一个组件。
- en: The Yew properties are the data that any parent component passes to its child
    component when it creates them. They are needed to share data in a hierarchy of
    components.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Yew属性是任何父组件在创建它们时传递给其子组件的数据。它们在组件层次结构中共享数据时是必需的。
- en: You create two Yew components – one that handles the inner section and one that
    handles the header and footer – and that one contains the other component as its
    child.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你创建两个Yew组件——一个处理内部部分，另一个处理页眉和页脚——并且后者包含前者作为其子组件。
- en: Callbacks are callable objects that a component passes as properties to one
    of its child components to let it access features of the parent component.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调是可以作为属性传递给其子组件的可调用对象，以便它能够访问父组件的功能。
- en: You pass it as a property, encapsulating it into an object of the `std::rc::Rc<std::cell::RefCell>` type.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将其作为属性传递，将其封装为`std::rc::Rc<std::cell::RefCell>`类型的对象。
- en: Because if you keep it only in a local variable, it is destroyed when the function
    in which it is created ends. To ensure it survives until the arrival of the response
    from the server, this object must be kept in a structure that lives longer.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为如果你只将其保留在局部变量中，它将在创建它的函数结束时被销毁。为了确保它能够在从服务器收到响应之前存活，这个对象必须保留在一个寿命较长的结构中。
- en: In your model, you declare an object of the `DialogService` type, and you use
    its `alert` and `confirm` methods.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的模型中，你声明一个`DialogService`类型的对象，并使用其`alert`和`confirm`方法。
- en: It is left to the reader. I've created an example in the book's GitHub repo.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这留给读者。我在书的GitHub仓库中创建了一个示例。
- en: Chapter 6
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: It is an architecture of interactive software, used mainly in games. At periodic
    intervals, the framework checks the status of input devices, modifies the model
    accordingly, and then invokes the draw routine. Its advantage is that it better
    corresponds to a situation in which input devices have continuous input, such
    as a key being pressed for some time, or screen output changing continuously,
    even if the user does nothing.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种交互式软件架构，主要用于游戏。在周期性间隔内，框架检查输入设备的状态，相应地修改模型，然后调用绘图例程。其优点是它更好地对应于输入设备具有连续输入的情况，例如某个键被按了一段时间，或者屏幕输出连续变化，即使用户没有进行任何操作。
- en: When input events are discrete, such as a mouse click on a button or text typed
    into a box, and when output happens only because of a user action.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入事件是离散的，例如在按钮上点击鼠标或输入框中输入文本时，并且当输出仅因为用户操作发生时。
- en: Continuous simulation software, industrial machine monitoring software, or multimedia
    software.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a shape, you call the `draw_ex` method of the current window. The first
    argument of that method describes the shape to draw; it may be an instance of
    the `Triangle`, `Rectangle`, or `Circle` type.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `update` function, you can check the state of any key of the keyboard.
    For example, the `window.keyboard()[Key::Right].is_down()` expression returns
    `true` if the right-arrow key is pressed.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The model must implement the `State` trait. In that trait, the `update` method
    is the controller, and the `draw` method is the view.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quicksilver has two rates, one for the `update` method and one for the `draw`
    method. They have default values, but if you want to change them, set the `update_rate`
    and `draw_rate` fields of the `Settings` structure passed to the `run` function
    that starts the application.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You start to load a font by calling the `Font::load(filename)` function, you
    start to load a sound by calling the `Sound::load(filename)` function, and so
    on. Such calls return a future waiting for the actual asset to load. Then, you
    call the `Asset::new` function, specifying the future as its argument. The first
    time it is used, it will wait for the complete loading of the asset. The assets
    must be in a folder named `static` at the root of the project.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After having loaded a recorded sound asset in a variable, you may call the `play_sound` function, and
    pass that asset as an argument.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After having loaded a font asset in a variable, in the `draw` method,  you may
    call the `execute` method of that asset, which waits for the complete loading
    of the font, and then you call the `render` method of the loaded asset to draw
    the text in an image. Then, you can draw that image on the window by calling the
    `draw` method of the window.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vector is an entity that can be added to another vector and can be multiplied
    by a number. It is senseless to add two points or to multiply a point by a number.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In geometry, a vector is a translation or displacement; a point is a position.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because some events are discrete. For example, when I click on a button, I am
    not interested in how many milliseconds the mouse is pressed; I just want to get
    one click event. If I type a word, I want to get just one character input for
    every key pressed.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because assets are usually loaded only at application startup, or when a level
    is entered or exited.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The optional `key_down_event`, `key_up_event`, `mouse_button_down_event`, and
    `mouse_button_up_event` methods can be defined for the `EventHandler` trait. 
    Such methods register in the model that they have been called (that is, that the
    corresponding events have happened in the time frame). Then, the `update` method
    checks and resets such settings in the model.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a set of shapes to draw. To draw a shape, first, you build a new `Mesh`
    instance, then you add shapes to it (rectangles, triangles, and so on), and then
    you can draw that mesh on the screen.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The general way is to create a `MeshBuilder` instance by using `MeshBuilder::new()`;
    add shapes to that builder, with its methods (`rectangle`, `polygon`, and so on);
    and then call the `build` method, which returns a `Mesh` instance. But there are
    shorter ways, such as the `Mesh::new_circle` function, which returns a `Mesh` instance containing
    a single circle.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `update` method is always called at top speed, but it checks the internal
    timer repeatedly to execute its body only the desired number of times.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `draw` function uses as arguments the context to receive the drawing, the
    mesh to draw, and a `DrawParam` structure. This structure can contain the geometric
    transformation to apply to the mesh while drawing it.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `audio::Source` objects have several methods, including the `play` and `play_detached` methods.
    The first one automatically stops the previous sound before playing the specified
    one; the second one overlaps its sound with existing ones.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular languages are ones that can be defined by a regular expression, which
    is a combination of three operators: concatenation, alternation, and repetition.
    Context-free languages are ones that can contain regular operators, plus matching
    symbols (such as parentheses). Context-dependent languages are those in which
    the validity of any expression may depend on any other expression defined previously.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a set of rules in which the program is a symbol, and every symbol is defined
    as the concatenation or alternation of symbols or characters.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a program that gets as input a formal definition of a programming language
    and generates as output a compiler, which is a program that parses (or even compiles
    to machine language) programs written in the language specified by that formal
    definition.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a function that takes as input one or more parsers and returns a parser
    that combines the input parsers in some way.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because, before the 2018 edition of Rust, the Rust language did not allow functions
    that returned functions without encapsulating them in an allocated object. The
    feature that allows a function to be returned with no allocation is named `impl
    Trait`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `tuple` parser combinator gets a fixed sequence of parsers and returns a
    parser that applies them in sequence. The `alt` parser combinator gets a fixed
    sequence of parsers and returns a parser that applies them alternatively. The
    `map` parser combinator gets a parser and a closure and returns a parser that
    applies that parser and then uses the closure to transform its output.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lexical analysis, syntax analysis, semantic analysis, and interpretation.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lexical analysis, syntax analysis, semantic analysis, generation of intermediate
    code, optimization of intermediate code, generation of relocatable machine code,
    and linking.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an identifier is defined, the symbol table is needed to check that such
    a name has not been defined yet in the current scope, if the language does not
    allow the shadowing of an identifier. When an identifier is used, the symbol table
    is needed to check that such a name has already been defined and that it has a
    type compatible with the usage.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当定义一个标识符时，需要符号表来检查在当前作用域中该名称尚未被定义，如果语言不允许标识符的遮蔽。当使用标识符时，需要符号表来检查该名称已经定义，并且它具有与使用兼容的类型。
- en: When an identifier is defined, the symbol table is needed to store the initial
    value of the identifier. When an identifier is used, the symbol table is needed
    to get or set the value associated with such an identifier.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当定义一个标识符时，需要符号表来存储标识符的初始值。当使用标识符时，需要符号表来获取或设置与该标识符关联的值。
- en: Chapter 9
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: 'Possible uses:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能的用途：
- en: To run a binary program for a computer when that computer is not available
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计算机不可用时要运行二进制程序
- en: To debug or analyze a binary program when its source code is not available
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当源代码不可用时，调试或分析二进制程序
- en: To disassemble machine code
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反汇编机器代码
- en: To translate a binary program into another machine language
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制程序翻译成另一种机器语言
- en: To translate a binary program into a high-level programming language
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制程序翻译成高级编程语言
- en: It is the main data register. It is the default source and destination of any
    instruction.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是主要的数据寄存器。它是任何指令的默认源和目标。
- en: It is the main address register. It contains the address of the next instruction
    that will be fetched and executed.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是主要地址寄存器。它包含将要被检索和执行的下一个指令的地址。
- en: One reason is that the use of numbers is more error-prone than the use of names.
    The other is that when an instruction or a variable is added or removed, the addresses
    of all the following instructions or variables change, and so a lot of addresses
    in code must be incremented or decremented.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个原因是使用数字比使用名称更容易出错。另一个原因是当添加或删除指令或变量时，所有后续指令或变量的地址都会改变，因此代码中的许多地址必须增加或减少。
- en: Defining a variant for every instruction type. The name of the variant is the
    symbolic name of the instruction, and its parameters are the types of the operands
    of the instruction.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种指令类型定义一个变体。变体的名称是指令的符号名称，其参数是指令操作数的类型。
- en: Little-endian notation is where the low byte of a word has a lower memory address,
    and big-endian notation is where the high byte has a lower memory address.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小端表示法是指一个字的低字节具有较低的内存地址，而大端表示法是指高字节具有较低的内存地址。
- en: For a parser that accepts text, the input is a reference to a string slice,
    with an `&str` type, while for a parser that accepts binary data, the input is
    a reference to a slice of bytes, with an `&[u8]` type.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于接受文本的解析器，输入是字符串切片的引用，具有`&str`类型，而对于接受二进制数据的解析器，输入是字节切片的引用，具有`&[u8]`类型。
- en: 'The rules to be respected are as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要遵守的规则如下：
- en: It begins with a little-endian word containing the size of the process in bytes.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以包含进程大小的字节数的小端字开始。
- en: After the initial word, there is a sequence of valid machine language instructions,
    with no interleaved spaces or data.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始单词之后，有一系列有效的机器语言指令，没有交错的空间或数据。
- en: The `Terminate` instruction occurs once—and only once—as the last instruction
    so that it marks the end of the sequence of instructions. After this, there is
    only data left.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Terminate`指令只出现一次，作为最后一个指令，以标记指令序列的结束。之后，只剩下数据。'
- en: No statement writes on the instructions; only the data can be changed. So, the
    program is not self-modifying; put differently, the program instructions are the
    same as the process instructions.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有语句写入指令；只有数据可以更改。因此，程序不是自修改的；换句话说，程序指令与过程指令相同。
- en: Because a 16-bit number can be usefully regarded sometimes as a pair of bytes
    and sometimes as a single number. Hexadecimal format satisfies both requirements
    because every pair of hexadecimal digits is a byte, and the whole four-digit sequence
    is a 16-bit number.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为有时一个16位数字可以有用地被视为一对字节，有时又是一个单独的数字。十六进制格式满足这两个要求，因为每对十六进制数字是一个字节，整个四位数序列是一个16位数字。
- en: By encapsulating it in a new type and then implementing the `Debug` trait for
    the type.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其封装在一个新类型中，然后为该类型实现`Debug`特质。
- en: Chapter 10
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: It is an extension of the Linux operating system kernel that can be added or
    removed at runtime.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是Linux操作系统内核的一个扩展，可以在运行时添加或删除。
- en: The C programming language, with GCC extensions.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C编程语言，带有GCC扩展。
- en: It is a memory-only log area to which every kernel module can write. When a
    kernel module writes to it, a bracket-enclosed timestamp is added at the beginning
    of every line; this is the number of seconds and microseconds since the start
    of the kernel.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个仅用于记录内存的区域，每个内核模块都可以向其中写入。当内核模块向其写入时，会在每行的开头添加一个括号包围的时间戳；这是自内核启动以来的秒数和微秒数。
- en: '`ModInfo` prints some information about a Linux module file; `LsMod` prints
    the list of all the currently loaded modules; `InsMod` loads a Linux module from
    the specified file and adds it to the running kernel; and `RmMod` unloads the
    specified module from the running Linux kernel.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ModInfo`打印有关Linux模块文件的一些信息；`LsMod`打印当前所有已加载模块的列表；`InsMod`从指定的文件加载Linux模块并将其添加到正在运行的内核中；`RmMod`从正在运行的Linux内核卸载指定的模块。'
- en: Because the `#![no_std]` directive prevents the use of the standard heap allocator
    and of all the standard types that use it. This directive is required as any kernel
    module needs a custom allocator.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`![no_std]`指令阻止了标准堆分配器的使用以及所有使用它的标准类型。任何内核模块都需要一个自定义分配器，所以这个指令是必需的。
- en: It is a directive to the linker to keep the exact name of the following function
    so that the kernel can find that function by name.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是向链接器的一个指令，以保留以下函数的确切名称，以便内核可以通过名称找到该函数。
- en: It specifies that the function-calling convention must be the one normally used
    by the C language.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它指定函数调用约定必须是C语言通常使用的那个。
- en: 'They are two entry points of the module: the `init_module` function is invoked
    by the kernel when the module is loaded, and the `cleanup_module` function is
    invoked by the kernel when the module is unloaded.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是模块的两个入口点：当模块被加载时，内核会调用`init_module`函数，当模块被卸载时，内核会调用`cleanup_module`函数。
- en: '`__register_chrdev` is used to register a character device in the kernel; `__unregister_chrdev`
    is used to deregister it.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__register_chrdev`用于在内核中注册字符设备；`__unregister_chrdev`用于注销它。'
- en: The `_copy_to_user` function.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_copy_to_user`函数。'
