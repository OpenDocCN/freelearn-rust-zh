- en: Managing Projects with Cargo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo管理项目
- en: 'Now that we are familiar with the language and how to write basic programs,
    we''ll level up towards writing practical projects in Rust. For trivial programs
    that can be contained in a single file, compiling and building them manually is
    no big deal. In the real world, however, programs are split into multiple files
    for managing complexity and also have dependencies on other libraries. Compiling
    all of the source files manually and linking them together becomes a complicated
    process. For large-scale projects, the manual way is not a scalable solution as
    there could be hundreds of files and their dependencies. Fortunately, there are
    tools that automate building of large-scale software projects—package managers.
    This chapter explores how Rust manages large projects with its dedicated package
    manager and what features it provides to the developer to enhance their development
    experience. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了语言以及如何编写基本程序，我们将提升到在Rust中编写实用项目的水平。对于可以包含在单个文件中的简单程序，手动编译和构建它们并不是什么大问题。然而，在现实世界中，程序被分割成多个文件以管理复杂性，并且依赖于其他库。手动编译所有源文件并将它们链接在一起变得非常复杂。对于大型项目，手动方式不是可扩展的解决方案，因为可能有数百个文件及其依赖项。幸运的是，有工具可以自动化构建大型软件项目——包管理器。本章将探讨Rust如何使用其专门的包管理器管理大型项目，以及它为开发者提供了哪些功能来增强他们的开发体验。我们将涵盖以下主题：
- en: Package managers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理器
- en: Modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: The Cargo package manager and crates (libraries) as units of compilation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cargo包管理器和crates（库）作为编译单元
- en: Creating and building projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和构建项目
- en: Running tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行测试
- en: Cargo subcommands and installing third-party binaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货物子命令和第三方二进制文件的安装
- en: Editor integrations and setup in Visual Studio code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio代码中的编辑器集成和设置
- en: As a final exercise, we'll create imgtool, a trivial command-line tool that
    can rotate images from the command line using a library, and use Cargo to build
    and run our program. We have a lot to cover, so let's dive in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的练习，我们将创建imgtool，这是一个简单的命令行工具，可以使用库从命令行旋转图像，并使用Cargo构建和运行我们的程序。我们有很多内容要介绍，所以让我们深入探讨吧！
- en: Package managers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理器
- en: '"The key to efficient development is to make interesting new mistakes."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “高效开发的关键是犯有趣的错误。”
- en: – *Tom Love*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ——*汤姆·洛夫*
- en: A real-world software code base is often organized into multiple files and will
    have many dependencies, and that calls for a dedicated tool for managing them.
    Package managers are a class of command-line tools that help manage projects of
    a large size with multiple dependencies. If you come from a Node.js background,
    you must be familiar with npm/yarn or if you are from Go language, the go tool.
    They do all the heavy lifting of analyzing the project, downloading the correct
    versions of dependencies, checking for version conflicts, compiling and linking
    source files, and much more.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界的软件代码库通常组织成多个文件，并且会有许多依赖项，这就需要一个专门的工具来管理它们。包管理器是一类命令行工具，有助于管理具有多个依赖项的大型项目。如果你来自Node.js背景，你一定熟悉npm/yarn，如果你来自Go语言，那么熟悉go工具。它们执行了分析项目、下载依赖项的正确版本、检查版本冲突、编译和链接源文件等所有繁重的工作。
- en: The problem with low-level languages like C/C++ is that they do not ship with
    a dedicated package manager by default. The C/C++ community have been using the
    GNU make tool for a long time, which is a language-agnostic build system and has
    arcane syntax, that puts off many developers. The problem with make is that it
    does not know what header files are included in your C/C++ sources, so they have
    to be manually given this information. It has no built-in support for downloading
    external dependencies, nor does it know about the platform you are running on.
    Fortunately, this is not the case with Rust as it ships with a dedicated package
    manager which has more context on the project being managed. What follows is a
    tour of Cargo, Rust's package manager, which makes it easy to build and maintain
    Rust projects. But first, we need to dig into Rust's module system a bit more.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 低级语言（如C/C++）的问题在于它们默认不提供专门的包管理器。C/C++社区长期以来一直在使用GNU make工具，这是一个语言无关的构建系统，具有晦涩的语法，这让许多开发者望而却步。make的问题在于它不知道你的C/C++源文件中包含了哪些头文件，因此必须手动提供这些信息。它没有内置的下载外部依赖项的支持，也不知道你正在运行的平台。幸运的是，这种情况并不适用于Rust，因为它提供了一个专门的包管理器，它对正在管理的项目有更多的上下文信息。以下是对Cargo的介绍，Rust的包管理器，它使得构建和维护Rust项目变得容易。但首先，我们需要更深入地了解Rust的模块系统。
- en: Modules
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Before we explore more about Cargo, we need to be familiar with how Rust organizes
    our code. We had a brief glimpse at modules in the previous chapter. Here, we
    will cover them in detail. Every Rust program starts with a root module. If you
    are creating a library, your root module is the lib.rs file. If you are creating
    an executable, the root module is any file with a main function, usually main.rs.
    When your code gets large, Rust lets you split it into modules. To provide flexibility
    in organizing a project, there are multiple ways to create modules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索更多关于 Cargo 之前，我们需要熟悉 Rust 如何组织我们的代码。我们在上一章中简要地看到了模块。在这里，我们将详细讲解它们。每个 Rust
    程序都以根模块开始。如果你正在创建一个库，你的根模块是 lib.rs 文件。如果你正在创建一个可执行文件，根模块是任何包含 main 函数的文件，通常是 main.rs。当你的代码变得很大时，Rust
    允许你将其拆分为模块。为了在组织项目时提供灵活性，有多种创建模块的方法。
- en: Nested modules
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套模块
- en: 'The simplest way to create a module is by using the mod {} block within an
    existing module. Consider the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模块的最简单方法是使用现有模块中的 mod {} 块。考虑以下代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We created an inner module named food. To create a module within an existing
    one, we use the mod keyword, followed by the name of the module, food, followed
    by a pair of braces. Within braces, we can declare any kind of item or even a
    nested module. Within our food module, we declared three structs: Cake, Smoothie,
    and Pizza. In main, we then create a Cake instance from the food module using
    the path syntax food::Cake. Let''s compile this program:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 food 的内部模块。要在现有模块中创建模块，我们使用 mod 关键字，后跟模块名称 food，然后是一对大括号。在大括号内，我们可以声明任何类型的项，甚至嵌套模块。在我们的
    food 模块中，我们声明了三个结构体：Cake、Smoothie 和 Pizza。然后在 main 中，我们使用路径语法 food::Cake 从 food
    模块创建一个 Cake 实例。让我们编译这个程序：
- en: '![](img/ed900518-78ab-4af7-a095-7c3d2d8fc403.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed900518-78ab-4af7-a095-7c3d2d8fc403.png)'
- en: 'Strange! The compiler does not see any Cake type being defined. Let''s do what
    the compiler says and add use food::Cake:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '奇怪！编译器看不到任何 Cake 类型被定义。让我们按照编译器说的去做，添加 use food::Cake:'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We added use food::Cake;. To use any item from a module, we have to add a use
    declaration. Let''s try again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 use food::Cake;。要使用模块中的任何项目，我们必须添加一个 use 声明。让我们再试一次：
- en: '![](img/bc654e50-0700-4568-945f-acd3aa2ec186.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc654e50-0700-4568-945f-acd3aa2ec186.png)'
- en: We get another error saying that Cake is private. This brings us to an important
    aspect about modules, providing privacy. Items within a module are private by
    default. To use any item from a module, we need to bring the item into scope.
    This is a two-step process. First, we need to make the item itself public by prefixing
    our item declaration with the pub keyword. Second, to use the item, we need to
    add a use statement, as we did previously with use food::Cake.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又得到了一个错误，说 Cake 是私有的。这让我们想到了模块的一个重要方面，即提供隐私。模块内的项目默认是私有的。要使用模块中的任何项目，我们需要将项目引入作用域。这是一个两步的过程。首先，我们需要通过在项目声明前加上
    pub 关键字来使项目本身公开。其次，要使用该项目，我们需要添加一个 use 语句，就像我们之前使用 use food::Cake 一样。
- en: What comes after the use keyword is the item path in the module. The path to
    any item within a module is specified using the path syntax, which uses two double
    colons (::) between item names. The path syntax usually starts with the module
    name for importing items, though it is also used for importing individual fields
    of some types, such as enums.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: use 关键字之后是模块中的项目路径。模块中任何项目的路径都使用路径语法指定，它使用两个双冒号(::)分隔项目名称。路径语法通常以模块名称开始，用于导入项目，尽管它也用于导入某些类型的单个字段，例如枚举。
- en: 'Let''s make our Cake public:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的 Cake 公开：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We added pub before our Cake struct and used it in the root module via use food::Cake.
    With those changes, our code compiles. It's not apparently clear now as to why
    one would need to create nested modules like so, but we'll get to see how they
    are used when we write tests in [Chapter 3](16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml),
    Tests, Documentation, and Benchmarks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Cake 结构体前添加了 pub 并通过 use food::Cake 在根模块中使用它。有了这些更改，我们的代码可以编译。现在可能还不清楚为什么需要创建如此嵌套的模块，但当我们编写第
    3 章[测试、文档和基准测试](16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml)中的测试时，我们会看到它们是如何被使用的。
- en: File as a module
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件作为模块
- en: 'Modules can also be created as files. For instance, for a main.rs file in a
    directory named foo, we can create a module bar as a file in the same directory
    as foo/bar.rs. Then in main.rs, we need to tell the compiler of this module, that
    is, declare the module with mod foo;. This is an extra step when using file-based
    modules. To demonstrate using a file as a module, we have created a directory
    named modules_demo, which has the following structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以作为文件创建。例如，对于名为 foo 的目录中的 main.rs 文件，我们可以在与 foo 同一目录中创建一个名为 bar 的模块作为文件
    foo/bar.rs。然后在 main.rs 中，我们需要告诉编译器这个模块，即通过 mod foo; 声明模块。当使用基于文件的模块时，这是一个额外的步骤。为了演示如何使用文件作为模块，我们创建了一个名为
    modules_demo 的目录，其结构如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our foo.rs contains a struct Bar, with its impl block:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 foo.rs 包含一个结构体 Bar，以及它的 impl 块：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We want to use this module in main.rs. Our main.rs, has the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在 main.rs 中使用这个模块。我们的 main.rs 包含以下代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We declare our module, foo, using mod foo;. We then use the Bar struct from
    the module by writing use crate::foo::Bar. Notice the crate prefix in use crate::foo::Bar;
    here. There are three ways to use an item from a module depending on the prefix
    you use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 mod foo; 声明我们的模块，foo。然后，我们通过编写 use crate::foo::Bar. 来使用模块中的 Bar 结构体。注意在
    use crate::foo::Bar; 中的 crate 前缀。根据你使用的不同前缀，有三种方式来使用模块中的项目：
- en: 'Absolute imports:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对导入：
- en: 'crate: An absolute import prefix that refers to the the current crate''s root.
    In the preceding code, this would be the root module, that is, main.rs file. Anything
    after the crate keyword is resolved from the root module.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'crate: 一个绝对导入前缀，指向当前 crate 的根。在前面代码中，这将是指根模块，即 main.rs 文件。crate 关键字之后的所有内容都是从根模块解析的。'
- en: 'Relative imports:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入：
- en: 'self: A relative import prefix that refers to an item relative from the current
    module. This is used when any code wants to refer to its containing module, for
    example, use self::foo::Bar;. This is mostly used when re-exporting items from
    a child module to be available from the parent module.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'self: 一个相对导入前缀，指向当前模块中的项目。当任何代码想要引用其包含的模块时，会使用它，例如，使用 self::foo::Bar;。这通常用于从子模块重新导出项目以便在父模块中使用。'
- en: 'super: A relative import prefix that can use and import an item from the parent
    module. A child module such as the tests module would use this to import items
    from the parent module. For example, if a module bar wants to access an item Foo
    from its parent module foo, it would import it as use super::foo::Foo; in module
    bar.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'super: 一个相对导入前缀，可以用来使用和导入父模块中的项目。例如，测试模块这样的子模块会使用它来从父模块导入项目。例如，如果模块 bar 想要访问其父模块
    foo 中的项目 Foo，它会在模块 bar 中将其导入为 use super::foo::Foo;。'
- en: The third way to create modules, is to organize them as directories.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模块的第三种方式是将它们组织成目录。
- en: Directory as module
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录作为模块
- en: We can also create a directory that represents a module. This approach allows
    us to have submodules within modules as a file and directory hierarchy. Let's
    assume that we have a directory,  my_program, that has a module named foo as a
    file foo.rs. It contains a type called Bar along with foo's functionality. Over
    time, the Bar APIs have grown in number and we wish to separate them as a submodule.
    We can model this use case with directory-based modules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个表示模块的目录。这种方法允许我们在文件和目录层次结构中拥有模块内的子模块。假设我们有一个名为 my_program 的目录，它有一个名为
    foo 的模块作为文件 foo.rs。它包含一个名为 Bar 的类型以及 foo 的功能。随着时间的推移，Bar API 的数量不断增加，我们希望将它们作为子模块分离。我们可以使用基于目录的模块来模拟这个用例。
- en: To demonstrate creating modules as directories, we have created a program in
    a directory named my_program. It has an entry point in main.rs and a directory
    named foo. This directory now contains a submodule within it named bar.rs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何将模块作为目录创建，我们在名为 my_program 的目录中创建了一个程序。它有一个在 main.rs 中的入口点和一个名为 foo 的目录。这个目录现在包含一个名为
    bar.rs 的子模块。
- en: 'Following is the structure of the directory my_program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我_program 目录的结构：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To let Rust know about bar, we also need to create a sibling file named foo.rs
    alongside the directory foo/. The foo.rs file will contain mod declarations for
    any submodules created (here bar.rs) within the directory foo/.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Rust 了解 bar，我们还需要在目录 foo/ 旁边创建一个名为 foo.rs 的同级文件。foo.rs 文件将包含在目录 foo/ 中创建的任何子模块的
    mod 声明（这里为 bar.rs）。
- en: 'Our bar.rs has the following content:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 bar.rs 包含以下内容：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have a unit struct Bar having an associated method hello. We want to use
    this API in main.rs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单元结构体 Bar，它有一个关联的方法 hello。我们想在 main.rs 中使用这个 API。
- en: 'Note: In the older Rust 2015 edition, submodules don''t need a sibling foo.rs
    alongside the foo directory, and instead use a mod.rs file within foo to convey
    to the compiler that the directory is a module. Both of these approaches are supported
    in Rust 2018 edition.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在较旧的 Rust 2015 版本中，子模块不需要在 foo 目录旁边有一个 foo.rs 的同级文件，而是可以在 foo 中使用 mod.rs
    文件来告知编译器该目录是一个模块。这两种方法在 Rust 2018 版本中都得到了支持。
- en: 'Next, our foo.rs has the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的 foo.rs 包含以下代码：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We added a declaration of the module bar. Following that, we re-exported the
    item Bar from the module bar. This requires that Bar is defined as pub. The pub
    use part is how we  re-export an item from a child module to be available from
    the parent module. Here, we used the self keyword to reference the module itself.
    Re-exports are mainly a convenience step when writing use statements, which helps
    remove the clutter when importing an item that is hidden away in nested submodules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了对模块 bar 的声明。随后，我们从模块 bar 中重新导出了项目 Bar。这要求 Bar 被定义为 pub。pub use 部分是我们从子模块重新导出项目以便在父模块中可用的方式。在这里，我们使用了
    self 关键字来引用模块本身。重新导出主要是编写 use 语句时的便利步骤，有助于在导入隐藏在嵌套子模块中的项目时减少混乱。
- en: self is a keyword for relative imports. While it's encouraged to use absolute
    imports using crate, it is much cleaner to use self when re-exporting items from
    submodules in the parent module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: self 是相对导入的关键字。虽然鼓励使用 crate 进行绝对导入，但在父模块中从子模块重新导出项目时，使用 self 会更加简洁。
- en: 'Finally main.rs uses both modules as:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后 main.rs 使用了这两个模块：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our main.rs declares foo and then imports the struct Bar. We then invoke the
    method do_foo from foo and also invoke hello on Bar.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 main.rs 声明了 foo 然后导入了结构体 Bar。然后我们调用了 foo 的方法 do_foo，也调用了 Bar 上的 hello。
- en: There's more to modules than meets the eye and thus we cover some of the details
    about them in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml), Advanced
    Concepts. With modules explored, let's continue with Cargo.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模块远不止表面看起来那么简单，因此我们在 [第 7 章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml) 中介绍了关于它们的详细信息，高级概念。在探索了模块之后，让我们继续了解
    Cargo。
- en: Cargo and crates
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo 和 crates
- en: When projects get large, a usual practice is to refactor code into smaller,
    more manageable units as modules or libraries. You also need tools to render documentation
    for your project, how it should be built, and what libraries it depends on. Furthermore,
    to support the language ecosystem where developers can share their libraries with
    the community, an online registry of some sort is often the norm these days.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目变得庞大时，通常的做法是将代码重构为更小、更易于管理的单元，如模块或库。你还需要工具来渲染项目的文档，包括如何构建以及它依赖哪些库。此外，为了支持开发者可以与社区分享库的语言生态系统，如今通常需要一个在线注册表。
- en: 'Cargo is the tool that empowers you to do all these things, and [https://crates.io](https://crates.io)
    is the centralized place for hosting libraries. A library written in Rust is called
    a crate, and crates.io hosts them for developers to use. Usually, a crate can
    come from three sources: a local directory, an online Git repository like GitHub,
    or a hosted crate registry like crates.io. Cargo supports crates from all of these
    sources.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 是一个工具，它赋予你做所有这些事情的能力，[https://crates.io](https://crates.io) 是托管库的集中地点。用
    Rust 编写的库称为 crate，crates.io 为开发者提供托管服务。通常，crate 可以来自三个来源：本地目录、在线 Git 仓库如 GitHub，或托管
    crate 注册表如 crates.io。Cargo 支持来自所有这些来源的 crate。
- en: 'Let''s see Cargo in action. If you ran rustup, as described in the previous
    chapter, you will already have cargo installed, along with rustc. To see what
    commands are available to us, we can run cargo without any parameters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Cargo 的实际应用。如果你已经按照前一章所述运行了 rustup，那么你将已经安装了 cargo 和 rustc。要查看我们可用的命令，我们可以不带任何参数运行
    cargo：
- en: '![](img/b2149843-d325-4fad-8876-4df2fed185a3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2149843-d325-4fad-8876-4df2fed185a3.png)'
- en: It shows a list of common commands that we can use, along with some flags. Let's
    use the the new subcommand to create a new Cargo project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了一个我们可以使用的常见命令列表，以及一些标志。让我们使用 new 子命令来创建一个新的 Cargo 项目。
- en: Creating a new Cargo project
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的 Cargo 项目
- en: 'The cargo new <name> command creates a new project name as a directory. We
    can get more context on any subcommand by adding a help flag between cargo and
    the subcommand. We can view documentation for the new subcommand by running cargo
    help new, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: cargo new <name> 命令创建一个以目录形式存在的新项目名称。我们可以通过在 cargo 和子命令之间添加 help 标志来获取任何子命令的更多上下文。我们可以通过运行
    cargo help new 来查看 new 子命令的文档，如下面的截图所示：
- en: '![](img/f0564389-29fe-4a03-b87c-e70d3efaf1fa.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f0564389-29fe-4a03-b87c-e70d3efaf1fa.png)'
- en: 'By default, cargo new creates a binary project; the --lib parameter has to
    be used when creating a library project. Let''s try it out by typing cargo new
    imgtool and taking a look at the directory structure it creates:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，cargo new 创建一个二进制项目；创建库项目时必须使用 --lib 参数。让我们通过输入 cargo new imgtool 并查看它创建的目录结构来试一试：
- en: '![](img/4e2d11d0-acc7-4dd3-8777-a6f4d733db08.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e2d11d0-acc7-4dd3-8777-a6f4d733db08.png)'
- en: Cargo has created some starter files, Cargo.toml and src/main.rs, with the function
    main printing Hello World!. For binary crates (executables), Cargo creates a src/main.rs
    file and for library crates it creates,  src/lib.rs under the src/ directory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 创建了一些启动文件，Cargo.toml 和 src/main.rs，其中 main 函数打印出 Hello World！对于二进制crate（可执行文件），Cargo
    创建一个 src/main.rs 文件，而对于库crate，它则在 src/ 目录下创建 src/lib.rs。
- en: Cargo also initializes a Git repository for new projects with the usual defaults,
    like preventing the target directory from being checked in with a .gitignore file,
    and checking in the Cargo.lock file for binary crates and ignoring it in library
    crates. The default Version Control System (VCS) that's used is Git, which can
    be changed by passing the --vcs flag to Cargo ( --vcs hg for mercurial). Cargo
    as of now supports Git, hg (mercurial), pijul (a version control system written
    in Rust), and fossil. If we want to modify this default behavior, we can pass --vcs
    none to instruct Cargo to not configure any vcs when creating our project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 还为新项目初始化了 Git 仓库，并使用了一些常规默认设置，例如通过 .gitignore 文件防止目标目录被提交，以及对于二进制crate提交
    Cargo.lock 文件，而对于库crate则忽略它。默认的版本控制系统（VCS）是 Git，可以通过传递 --vcs 标志给 Cargo 来更改（对于
    mercurial 使用 --vcs hg）。截至目前，Cargo 支持 Git、hg（mercurial）、pijul（用 Rust 编写的版本控制系统）和
    fossil。如果我们想修改这种默认行为，可以通过传递 --vcs none 来指示 Cargo 在创建我们的项目时不要配置任何 vcs。
- en: 'Let''s take a look at Cargo.toml for the project imgtool that we created. This
    file defines your project''s metadata and dependencies. It''s also known as the
    project''s manifest file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们创建的 imgtool 项目的 Cargo.toml 文件。此文件定义了项目的元数据和依赖项。它也被称为项目的清单文件：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the minimal Cargo.toml manifest file needed for a new project. It uses
    the TOML configuration language, which stands for Tom's Obvious Minimal Language.
    It is a file format that was created by Tom Preston-Werner. It is reminiscent
    of standard .INI files, but adds several data types to it, which makes it an ideal
    modern format for configuration files and simpler than YAML or JSON. We'll keep
    this file minimal for now and add things to it later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新项目所需的最低限度的 Cargo.toml 清单文件。它使用 TOML 配置语言，代表 Tom's Obvious Minimal Language。它是一种由
    Tom Preston-Werner 创建的文件格式。它让人联想到标准的 .INI 文件，但向其中添加了几个数据类型，这使得它成为配置文件的理想现代格式，并且比
    YAML 或 JSON 更简单。我们现在将保持此文件最小化，并在以后添加内容。
- en: Cargo and dependencies
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 货物和依赖项
- en: For projects that depend on other libraries, the package manager has to find
    all of the direct dependencies in the project and also any indirect dependencies,
    and then compile and link them to the project. Package managers are not just a
    tool for facilitating dependency resolution; they should also ensure predictable
    and reproducible builds of a project. Before we cover building and running our
    project, let's discuss how Cargo manages dependencies and ensures repeatable builds.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖于其他库的项目，包管理器必须找到项目中的所有直接依赖项以及任何间接依赖项，然后编译并将它们链接到项目中。包管理器不仅仅是促进依赖项解析的工具；它们还应确保项目的可预测和可重复构建。在我们介绍如何构建和运行我们的项目之前，让我们讨论
    Cargo 如何管理依赖项并确保可重复构建。
- en: 'A Rust project managed with Cargo has two files through which it does all its
    magic: Cargo.toml (introduced before) is the file where you, as the developer,
    write dependencies and their needed versions with SemVer syntax (like 1.3.*),
    and a lock file called Cargo.lock, which gets generated by Cargo upon building
    the project and that contains absolute versions (like 1.3.15) of all the immediate
    dependencies and any indirect dependencies. This lock file is what ensures repeatable
    builds in binary crates. Cargo minimizes the work it has to do by referring to
    this lock file for any further changes to the project. As such, it is advised
    that binary crates include the .lock file in their repository, while library crates
    can be stateless and don''t need to include it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cargo 管理的 Rust 项目通过两个文件来完成所有魔法：Cargo.toml（之前已介绍）是开发者写入依赖项及其所需版本（如 1.3.*）的
    SemVer 语法文件的文件，以及一个名为 Cargo.lock 的锁文件，该文件在构建项目时由 Cargo 生成，其中包含所有直接依赖项和任何间接依赖项的绝对版本（如
    1.3.15）。此锁文件确保二进制包的重复构建。Cargo 通过引用此锁文件来最小化对项目进行任何进一步更改时所需的工作。因此，建议二进制包将其 .lock
    文件包含在他们的存储库中，而库包可以是无状态的，不需要包含它。
- en: Dependencies can be updated using the cargo update command. This updates all
    of your dependencies. For updating a single dependency, we can use cargo update
    -p <crate-name>. If you update the version of a single crate, Cargo makes sure
    to only update parts that are related to that crate in the Cargo.lock file and
    leaves other versions untouched.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 cargo update 命令更新依赖项。这将更新所有依赖项。如果要更新单个依赖项，我们可以使用 cargo update -p <crate-name>。如果您更新单个包的版本，Cargo
    会确保只更新与该包在 Cargo.lock 文件中相关的部分，并保留其他版本不变。
- en: 'Cargo follows the semantic versioning system (SemVer), where your library version
    is specified in the format of major.minor.patch. These can be described as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 遵循语义版本控制系统（SemVer），其中您的库版本以 major.minor.patch 格式指定。这些可以描述如下：
- en: 'Major: Is only increased when new breaking changes (including bug fixes) are
    made to a project.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主版本：只有当项目进行新的破坏性更改（包括错误修复）时才会增加。
- en: 'Minor: Is only increased when new features are added in backward compatible
    ways.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小版本：只有在新功能以向后兼容的方式添加时才会增加。
- en: 'Patch: Is only increased when bug fixes are made in backward compatible ways
    and no features are added.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁版本：只有以向后兼容的方式修复错误且没有添加新功能时才会增加。
- en: For example, you might want to include the serialization library, serde, in
    your project. At the time of writing this book, the latest version of serde is
    1.0.85 , and you probably only care about the major version number. Therefore,
    you write serde = "1" as the dependency (this translates to 1.x.x in SemVer format)
    in your Cargo.toml and Cargo will figure it out for you and fix it to 1.0.85 in
    the lock file. The next time you update Cargo.lock with the cargo update command,
    this version might get upgraded to whichever is the latest version in the 1.x.x
    match. If you don't care that much and just want the latest released version of
    a crate, you can use * as the version, but it's not a recommended practice because
    it affects the reproducibility of your builds as you might pull in a major version
    that has breaking changes. Publishing a crate with * as the dependency version
    is also prohibited.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能想在项目中包含序列化库 serde。在撰写本书时，serde 的最新版本是 1.0.85，您可能只关心主版本号。因此，您将 serde =
    "1" 作为依赖项（在 SemVer 格式中表示为 1.x.x）写入 Cargo.toml，Cargo 将为您解决它，并在锁文件中将它固定为 1.0.85。下次您使用
    cargo update 命令更新 Cargo.lock 时，此版本可能会升级到 1.x.x 匹配中的最新版本。如果您不太关心，只想获取包的最新发布版本，您可以使用
    * 作为版本，但这不是推荐的做法，因为它会影响构建的可重复性，您可能会拉入具有破坏性更改的主版本。以 * 作为依赖项版本发布包也是禁止的。
- en: 'With that in mind, let''s take a look at the cargo build command, which is
    used to compile, link, and build our project. This command does the following
    for your project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们看看 cargo build 命令，该命令用于编译、链接和构建我们的项目。此命令对您的项目执行以下操作：
- en: Runs cargo update for you if you don't yet have a Cargo.lock file and puts the
    exact versions in the lock file from Cargo.toml
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您还没有 Cargo.lock 文件，则为您运行 cargo update，并将 Cargo.toml 中的确切版本放入锁文件中
- en: Downloads all of your dependencies that have been resolved in Cargo.lock
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载所有在 Cargo.lock 中已解析的依赖项
- en: Builds all of those dependencies
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建所有这些依赖项
- en: Builds your project and links it with the dependencies
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的项目并将其与依赖项链接
- en: 'By default, cargo build creates a debug build of your project under the target/debug/
    directory. A --release flag can be passed to create an optimized build for production
    code at the target/release/ directory. The debug build offers faster build time,
    shortening the feedback loop, while production builds are a bit slower as the
    compiler runs more optimization passes over your source code. During development,
    you need to have a shorter feedback time of fix-compile-check. For that, one can
    use the cargo check command, which results in even shorter compile times. It basically
    skips the code generation part of the compiler and only runs the source code through
    the frontend phase, that is, parsing and semantic analysis in the compiler. Another
    command is cargo run, which performs double duty. It runs cargo build, followed
    by running your program in the target/debug/ directory. For building/running a
    release version, you can use cargo run --release . On running Cargo run in our
    imgtool/ directory, we get the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`cargo build` 在 `target/debug/` 目录下创建项目的调试版本。可以通过传递 `--release` 标志来创建在
    `target/release/` 目录下的优化版本，用于生产代码。调试版本提供更快的构建时间，缩短了反馈循环，而生产构建则稍微慢一些，因为编译器会对源代码执行更多的优化遍历。在开发过程中，你需要有更短的修复-编译-检查的反馈时间。为此，可以使用
    `cargo check` 命令，这将导致更短的编译时间。它基本上跳过了编译器的代码生成部分，并且只运行源代码的前端阶段，即在编译器中的解析和语义分析。另一个命令是
    `cargo run`，它具有双重功能。它首先运行 `cargo build`，然后在 `target/debug/` 目录下运行你的程序。对于构建/运行发布版本，可以使用
    `cargo run --release .`。在 `imgtool/` 目录下运行 `Cargo run` 后，我们得到以下输出：
- en: '![](img/d0e57dbf-82e0-49e4-b1ef-5fb3bb29458c.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0e57dbf-82e0-49e4-b1ef-5fb3bb29458c.png)'
- en: Running tests with Cargo
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cargo 运行测试
- en: 'Cargo also supports running tests and benchmarks. In-depth testing and benchmarking
    is covered in [Chapter 3](16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml), Tests,
    Documentation, and Benchmarks. In this section, we will go over a brief introduction
    on how to run tests using Cargo. We''ll write tests for a library crate. To work
    our way through this section, let''s create a crate by running cargo new myexponent
    --lib:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 还支持运行测试和基准测试。深入测试和基准测试在[第 3 章](16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml)，测试、文档和基准测试中有详细说明。在本节中，我们将简要介绍如何使用
    Cargo 运行测试。我们将为库 crate 编写测试。为了完成本节，让我们通过运行以下命令创建一个 crate：`cargo new myexponent
    --lib`：
- en: '![](img/9af491de-efdf-4127-8d0b-b01e07016f2c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9af491de-efdf-4127-8d0b-b01e07016f2c.png)'
- en: 'A library crate is similar to a binary crate. The difference is that instead
    of src/main.rs and a main function inside as an entry point, we have src/lib.rs
    with a trivial test function, it_works, which is marked with a #[test] annotation.
    We can run the it_works test function right away using cargo test and see it pass:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 库 crate 与二进制 crate 类似。区别在于，我们不是使用 `src/main.rs` 和作为入口点的 `main` 函数，而是使用 `src/lib.rs`
    和一个简单的测试函数 `it_works`，该函数带有 `#[test]` 注解。我们可以立即使用 `cargo test` 运行 `it_works` 测试函数并查看它是否通过：
- en: '![](img/6b99d64e-4476-42c8-8bfc-f6563fd6962e.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b99d64e-4476-42c8-8bfc-f6563fd6962e.png)'
- en: 'Now,  let''s try a bit of **Test Driven Development** (**TDD**) with Cargo.
    We will extend this library by adding a pow function ,with which the users of
    our library can calculate the exponent for a given number. We''ll write a test
    for this function that initially fails and then fill in the implementation until
    it works. Here''s the new `src/lib.rs`, featuring the pow function without any
    implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用 Cargo 进行一些**测试驱动开发**（**TDD**）。我们将通过添加一个 `pow` 函数来扩展这个库，用户可以使用这个函数来计算给定数字的指数。我们将为这个函数编写一个测试，该测试最初失败，然后填充实现直到它通过。以下是新的
    `src/lib.rs`，其中包含没有实现的 `pow` 函数：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Don''t worry about the details right now. We have created a single pow function
    that takes in a base as i64 and a positive exponent as usize, and returns a number
    that''s been raised to the exponent. Under mod tests {, we have a test function
    called minus_two_raised_three_is_minus_eight that does a single assertion. The
    assert_eq! macro checks for the equality of the two values that were passed to
    it. If the left argument is equal to the right argument, the assertion passes;
    otherwise, it throws an error and the compiler reports the failed test. If we
    run cargo test, the unit tests obviously fails for pow invocation because we have
    an unimplemented!() macro invocation there:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心细节。我们已经创建了一个单独的pow函数，它接受一个i64类型的基数和一个正指数usize，并返回一个被提升到指数的数字。在mod tests
    {中，我们有一个名为minus_two_raised_three_is_minus_eight的测试函数，它执行单个断言。assert_eq!宏检查传递给它的两个值的相等性。如果左边的参数等于右边的参数，则断言通过；否则，它会抛出一个错误，编译器会报告失败的测试。如果我们运行cargo
    test，由于那里有一个unimplemented!()宏调用，单元测试显然会因pow调用而失败：
- en: '![](img/88a4d812-ceea-45d5-972d-451ca723f242.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88a4d812-ceea-45d5-972d-451ca723f242.png)'
- en: In brief, unimplemented!() is just a convenient macro to mark unfinished code
    or code that you wish to implement later, but want the compiler to compile it
    anyway without giving a type error. Internally, this calls panic! with a message,
    "not yet implemented". It can be used in cases where you are implementing multiple
    methods of a trait. For instance, you start implementing one method, but you haven't
    planned on the implementation for other methods. When compiled, you would get
    compile errors for the other unimplemented methods if you just placed the function
    with an empty body. For these methods, we can place an unimplemented!() macro
    call inside them, just to make the type checker happy and compile for us, and
    offload the errors at runtime. We will look at more convenient macros like this
    in [Chapter 9](7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml), Metaprogramming with
    Macros.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，unimplemented!()只是一个方便的宏，用于标记未完成的代码或你打算稍后实现的代码，但希望编译器仍然编译它而不报类型错误。内部，它会调用panic!并传递消息“尚未实现”。它可以用于实现特质多个方法的情况。例如，你开始实现一个方法，但还没有计划其他方法的实现。在编译时，如果你只是放置了一个带有空体的函数，你会得到其他未实现方法的编译错误。对于这些方法，我们可以在它们内部放置一个unimplemented!()宏调用，只是为了让类型检查器满意并为我们编译，并在运行时转移错误。我们将在[第9章](7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml)“使用宏进行元编程”中查看更多这样的方便宏。
- en: 'Now, let''s fix this problem by implementing a quick and dirty version of the pow
    function and try again:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过实现一个快速且简单的pow函数版本来解决这个问题，并再次尝试：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running Cargo test gives the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Cargo test会得到以下输出：
- en: '![](img/4928cbd9-9572-44b0-8832-7c97a5dcf125.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4928cbd9-9572-44b0-8832-7c97a5dcf125.png)'
- en: This time, the test passes. Well, that's the basics. We'll do more testing in
    [Chapter 3](16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml), Tests, Documentation,
    and Benchmarks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，测试通过了。嗯，这就是基础。我们将在[第3章](16c1c837-f1f7-4268-ae8c-6e485a2fd747.xhtml)“测试、文档和基准测试”中进行更多测试。
- en: Running examples with Cargo
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo运行示例
- en: To enable users to quickly get started with your crate, it's a good practice
    to communicate to users how to use your crate with code examples. Cargo standardize
    this practice, meaning that you can add an examples/ directory within your project
    root that can contain one or more .rs files, with a main function showing example
    usage of your crate.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用户能够快速开始使用你的crate，将如何使用你的crate的代码示例传达给用户是一个好习惯。Cargo标准化了这个做法，这意味着你可以在项目根目录下添加一个examples/目录，其中可以包含一个或多个.rs文件，包含一个main函数，展示你的crate的示例用法。
- en: 'The code under the examples/ directory can be run by using cargo run --examples
    <file_name>, where the filename is given without the .rs extension. To demonstrate
    this, we''ve added an example/ directory for our myexponent crate containing a
    file named basic.rs:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用cargo run --examples <file_name>来运行examples/目录下的代码，其中文件名没有.rs扩展名。为了演示这一点，我们为myexponent
    crate添加了一个example/目录，包含一个名为basic.rs的文件：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Under the examples/ directory, we imported our pow function from our myexponent
    crate. The following is the output upon running cargo run --example basic:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在examples/目录下，我们从myexponent crate中导入了pow函数。以下是在运行cargo run --example basic后的输出：
- en: '![](img/97bfeda9-d509-426e-be66-512cda194c05.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97bfeda9-d509-426e-be66-512cda194c05.png)'
- en: Cargo workspace
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo工作空间
- en: 'Over the course of time, your project has gotten quite large. Now, you are
    thinking about whether you could split the common parts of your code as separate
    crates to help manage complexity. Well, a Cargo workspace allows you to do just
    that. The concept of workspaces is that they allow you to have crates locally
    in a directory that can share the same Cargo.lock file and a common target or
    output directory. To demonstrate this, we''ll create a new project that incorporates
    Cargo workspaces. The workspace is nothing but a directory with a Cargo.toml file
    in it. It doesn''t have any [package] section, but has a [workspace] section in
    it. Let''s create a new directory called workspace_demo and add the Cargo.toml file
    like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你的项目已经变得相当大。现在，你正在考虑是否可以将代码的公共部分作为单独的crate分开，以帮助管理复杂性。嗯，Cargo工作区允许你做到这一点。工作区的概念是它们允许你在目录中本地拥有crate，这些crate可以共享相同的Cargo.lock文件和公共目标或输出目录。为了演示这一点，我们将创建一个新的项目，该项目包含Cargo工作区。工作区只是一个包含Cargo.toml文件的目录。它没有任何[package]部分，但在其中有一个[workspace]部分。让我们创建一个新的目录名为workspace_demo，并添加如下所示的Cargo.toml文件：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then add the workspace section to our Cargo.toml file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将工作区部分添加到我们的Cargo.toml文件中：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within [workspace], the members key is a list of crates within the workspace
    directory. Now, within the workspace_demo directory, we''ll create two crates:
    my_crate, a library crate and app, a binary crate that uses my_crate.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在[工作区]中，members键是工作区目录内crate的列表。现在，在workspace_demo目录中，我们将创建两个crate：my_crate，一个库crate和app，一个使用my_crate的二进制crate。
- en: 'To keep things simple, my_crate has a public API that simply prints a greeting
    message:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，my_crate有一个公共API，它只是打印一条问候消息：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, from our app crate, we have the main function, which calls the greet function
    of my_crate:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从我们的app crate中，我们有main函数，它调用my_crate的greet函数：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, we need to let Cargo know about our my_crate dependency. As my_crate
    is a local crate, we need to specify it as a path dependency in the Cargo.toml
    file of app, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要让Cargo知道我们的my_crate依赖项。由于my_crate是一个本地crate，我们需要在app的Cargo.toml文件中将它指定为路径依赖项，如下所示：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, when we run cargo build, the binary gets generated in the workspace_demo
    directory's target directory. Accordingly, we can add multiple local crates within
    the workspace_demo directory. Now, if we want to add a third-party dependency
    from crates.io, we need to add it in all of the crates where we need it. However,
    during cargo build, Cargo makes sure to only have a single version for that dependency
    in the Cargo.lock file. This ensures that third-party dependencies do not get
    rebuilt and duplicated.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行cargo build时，二进制文件将在workspace_demo目录的目标目录中生成。相应地，我们可以在workspace_demo目录中添加多个本地crate。现在，如果我们想从crates.io添加第三方依赖项，我们需要在所有需要它的crate中添加它。然而，在cargo
    build期间，Cargo确保在Cargo.lock文件中只有一个版本的该依赖项。这确保第三方依赖项不会被重建和重复。
- en: Extending Cargo and tools
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Cargo和工具
- en: Cargo can also be extended to incorporate external tools for enhancing the development
    experience. It is designed to be as extensible as possible. Developers can create
    command-line tools and Cargo can invoke them via simple cargo binary-name syntax.
    In this section, we'll take a look at some of these tools.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo也可以扩展以集成外部工具以增强开发体验。它被设计成尽可能可扩展。开发者可以创建命令行工具，Cargo可以通过简单的cargo binary-name语法调用它们。在本节中，我们将查看一些这些工具。
- en: Subcommands and Cargo installation
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子命令和Cargo安装
- en: Custom commands for Cargo fall under the subcommand category. These tools are
    usually binaries from crates.io, GitHub, or a local project directory, and can
    be installed by using cargo install <binary crate name> or just cargo install
    when within a local Cargo project. One such example is the cargo-watch tool.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo的自定义命令属于子命令类别。这些工具通常是来自crates.io、GitHub或本地项目目录的二进制文件，可以通过使用cargo install
    <binary crate name>或仅在本地Cargo项目中使用cargo install来安装。cargo-watch工具就是一个这样的例子。
- en: cargo-watch
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cargo-watch
- en: Cargo-watch helps you shorten your fix, compile, run cycle by automatically
    building your project in the background whenever you make changes to your code.
    By default, this just runs Rust's type checker (the cargo check command) and does
    not undergo the code generation phase (which takes time) and shortens the compile
    time. A custom command can also be provided instead of cargo check using the -x
    flag.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo-watch通过在后台自动构建你的项目来帮助你缩短修复、编译、运行周期。默认情况下，这仅运行Rust的类型检查器（cargo check命令），并且不经过代码生成阶段（这需要时间）并缩短编译时间。也可以使用-x标志提供自定义命令来代替cargo
    check。
- en: 'We can install cargo-watch by running cargo install cargo-watch, and then within
    any Cargo project we can run it by invoking cargo watch. Now, whenever we make
    changes to our project, cargo-watch will run cargo check in the background and
    recompile the project for us. In the following code, we made a typo and corrected
    it, and cargo-watch recompiled the project for us:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 cargo install cargo-watch 来安装 cargo-watch，然后在任何 Cargo 项目中，我们可以通过调用
    cargo watch 来运行它。现在，每当我们对项目进行更改时，cargo-watch 都会在后台运行 cargo check，并为我们重新编译项目。在下面的代码中，我们犯了一个拼写错误并进行了纠正，cargo-watch
    为我们重新编译了项目：
- en: '![](img/90f6a6a7-9790-42d8-b5d2-13d3eba37b50.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90f6a6a7-9790-42d8-b5d2-13d3eba37b50.png)'
- en: This will be a very similar experience if you know about the watchman or nodemon
    packages from the Node.js ecosystem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 Node.js 生态系统中的 watchman 或 nodemon 软件包，这将是一个非常相似的经历。
- en: cargo-edit
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cargo-edit
- en: 'The cargo-edit subcommand is used to automatically add dependencies to your
    Cargo.toml file. It can add dependencies of all kinds, including dev dependencies
    and build dependencies, and also lets you add a specific version of any dependency.
    It can be installed by running cargo install cargo-edit. This subcommand provides
    four commands: cargo add, cargo rm, cargo edit, and cargo upgrade.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: cargo-edit 子命令用于自动将依赖项添加到您的 Cargo.toml 文件中。它可以添加所有类型的依赖项，包括开发依赖项和构建依赖项，还允许您添加任何依赖项的特定版本。您可以通过运行
    cargo install cargo-edit 来安装它。此子命令提供了四个命令：cargo add、cargo rm、cargo edit 和 cargo
    upgrade。
- en: cargo-deb
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cargo-deb
- en: This is another useful community developed subcommand that can create Debian
    packages (.deb) for the easy distribution of Rust executables on Debian Linux.
    We can install it by running cargo install cargo-deb. We'll use this tool at the
    end of this chapter to package our imgtool command-line executable as a .deb package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个有用的社区开发子命令，可以创建 Debian 软件包 (.deb)，以便在 Debian Linux 上轻松分发 Rust 可执行文件。我们可以通过运行
    cargo install cargo-deb 来安装它。我们将在本章末尾使用此工具将我们的 imgtool 命令行可执行文件打包成 .deb 软件包。
- en: cargo-outdated
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cargo-outdated
- en: This command shows the outdated crate dependencies in your Cargo project. This
    can be installed by running cargo install cargo-outdated. Once installed, you
    can see the outdated crates (if any) by running cargo outdated within the project
    directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示您 Cargo 项目中的过时 crate 依赖项。您可以通过运行 cargo install cargo-outdated 来安装它。一旦安装，您可以在项目目录中运行
    cargo outdated 来查看过时的 crate（如果有）。
- en: Now, the way these subcommands work seamlessly with Cargo is that developers
    create these binary crates with a naming convention, such as cargo-[cmd], and
    when you cargo install that binary crate, Cargo exposes the installed binary to
    your $PATH variable, which can then be invoked with cargo <cmd> . It's a simple
    and effective way that's been adopted by Cargo to extend itself with community
    developed subcommands. There are many other such extensions for Cargo. You can
    find a list of all community curated subcommands at [https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands](https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands)
    .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些子命令与 Cargo 无缝协作的方式是，开发者使用命名约定创建这些二进制 crate，例如 cargo-[cmd]，当您安装那个二进制 crate
    时，Cargo 会将安装的二进制文件暴露给您的 $PATH 变量，然后可以通过 cargo <cmd> 来调用。这是一个简单而有效的方法，Cargo 已经采用这种方法来通过社区开发的子命令扩展自身。还有许多其他类似的
    Cargo 扩展。您可以在 [https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands](https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands)
    找到所有社区精选的子命令列表。
- en: cargo install is also used to install any binary crates or executables/applications
    that are developed in Rust. They are installed in the /home/<user>/.cargo/bin/ directory
    by default. We'll use this to install our imgtool application—which we will build
    at the end of this chapter – to make it available system wide.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: cargo install 也用于安装任何在 Rust 中开发的二进制 crate 或可执行文件/应用程序。它们默认安装在 /home/<用户>/.cargo/bin/
    目录中。我们将使用它来安装我们的 imgtool 应用程序——我们将在本章末尾构建它——使其在系统范围内可用。
- en: Linting code with clippy
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 clippy 检查代码
- en: Linting is a practice that helps maintain the quality of your library and have
    it adhere to standard coding idioms and practices. The de facto linting tool in
    the Rust ecosystem is clippy. Clippy provides us with a bunch of lints (about
    291 at the time of writing this book) to ensure high quality Rust code. In this
    section, we'll install clippy and try it out on our libawesome library, add some
    dummy code to it, and see what suggestions we get from clippy. There are various
    ways of using clippy on your project, but we will use the cargo clippy subcommand
    way as that's simple. Clippy can perform analysis on code because it's a compiler
    plugin and has access to a lot of the compiler's internal APIs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码风格检查是一种有助于维护库的质量并使其遵循标准编码习惯和规范的实践。在 Rust 生态系统中的事实上的代码风格检查工具是 clippy。Clippy
    为我们提供了一组 lint（截至本书编写时约为 291 个），以确保 Rust 代码的高质量。在本节中，我们将安装 clippy 并在我们的 libawesome
    库上尝试它，向其中添加一些虚拟代码，并查看 clippy 提出的建议。在项目中使用 clippy 有多种方式，但我们将使用 cargo clippy 子命令方式，因为它很简单。Clippy
    可以对代码进行分析，因为它是一个编译器插件，并且可以访问大量编译器的内部 API。
- en: 'To use clippy, we need to install it by running rustup component add clippy.
    If you don''t have it already, rustup will install it for you. Now, to demonstrate
    how clippy can point out bad style in our code, we have put some dummy statements
    within an if condition inside our pow function in the myexponent crate, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 clippy，我们需要通过运行 rustup component add clippy 来安装它。如果您还没有安装，rustup 会为您安装。现在，为了展示
    clippy 如何指出我们代码中的不良风格，我们在 myexponent crate 的 pow 函数中的 if 条件内放置了一些虚拟语句，如下所示：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With those lines added, by running cargo clippy in our myexponent directory,
    we get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这些行后，通过在 myexponent 目录中运行 cargo clippy，我们得到了以下输出：
- en: '![](img/63b206ea-10ff-42d3-862f-55ab17766869.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63b206ea-10ff-42d3-862f-55ab17766869.png)'
- en: Great! Clippy has found a common code style that is redundant, that is, checking
    for a Boolean value that is either true or false. Alternatively, we could have
    written the preceding if condition directly as if x {} . There are many more checks
    that clippy does, and some of them even point out potential mistakes in your code,
    such as [https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons.](https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons)
    To see all the available lints and various ways of configuring clippy, head over
    to [https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！Clippy 找到了一种常见的代码风格，它是多余的，即检查布尔值是 true 或 false。或者，我们也可以直接将前面的 if 条件写成 if
    x {}。Clippy 还会进行许多其他检查，其中一些甚至可以指出您代码中的潜在错误，例如 [https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons](https://rust-lang-nursery.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons)。要查看所有可用的
    lint 和配置 clippy 的各种方式，请访问 [https://github.com/rust-lang/rust-clippy](https://github.com/rust-lang/rust-clippy)。
- en: Exploring the manifest file – Cargo.toml
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索清单文件 - Cargo.toml
- en: 'Cargo heavily depends on the project''s manifest file, the Cargo.toml file,
    to get all sorts of information for the project. Let''s take a closer look at
    the structure of this file and what items it can contain. As you saw earlier,
    cargo new creates an almost empty manifest file, filled with just the necessary
    fields so that a project can be built. Every manifest file is divided into sections
    that specify the different properties of a project. We will take a look at the
    sections that are typically found in a moderate sized Cargo project''s manifest
    file. Here''s an imaginary Cargo.toml file from a larger application:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 严重依赖于项目的清单文件，即 Cargo.toml 文件，以获取有关项目的各种信息。让我们更详细地看看这个文件的结构和它可以包含的项目。如您之前所见，cargo
    new 创建了一个几乎为空的清单文件，只包含必要的字段，以便项目可以构建。每个清单文件都分为几个部分，指定了项目的不同属性。我们将查看在中等大小的 Cargo
    项目清单文件中通常可以找到的部分。以下是一个来自更大应用程序的假想 Cargo.toml 文件：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s go through the parts that we haven''t explained yet, starting from the
    [package] section:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下尚未解释的部分，从 [package] 部分开始：
- en: 'description: It contains a longer, free-form text field about the project.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：它包含有关项目的较长的自由格式文本字段。
- en: 'license: It contains software license identifiers, as listed in [http://spdx.org/licenses/](http://spdx.org/licenses/).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：它包含软件许可证标识符，如 [http://spdx.org/licenses/](http://spdx.org/licenses/) 中列出的。
- en: 'readme: It allows you to link to a file in your project''s repository. This
    should be shown as the entry point to the project''s introduction.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件：它允许您链接到项目存储库中的文件。这应该显示为项目介绍的入口点。
- en: 'documentation: It contains the link to the crate''s documentation if it''s
    a library crate.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'documentation: 如果是库 crate，它包含 crate 的文档链接。'
- en: 'keywords: It is a list of single words that helps in discovering your project
    either through search engines or through the crates.io website.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'keywords: 它是一个单词列表，有助于通过搜索引擎或通过 crates.io 网站发现您的项目。'
- en: 'authors: It lists the project''s key authors.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'authors: 列出了项目的关键作者。'
- en: 'build: It defines a piece of Rust code (typically build.rs) that is compiled
    and run before the rest of the program is compiled. This is often used to generate
    code or to build native libraries that the crate depends on.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'build: 它定义了一段 Rust 代码（通常是 build.rs），在程序的其他部分编译之前编译并运行。这通常用于生成代码或构建 crate 所依赖的本地库。'
- en: 'edition: This key specifies which edition to use when compiling your project.
    In our case, we are using the 2018 edition. The previous edition was 2015, which
    is assumed to be the default if no edition key exists. Note: projects created
    with the 2018 edition are backward compatible, which means that they can use 2015
    crates as dependencies too.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'edition: 此键指定在编译项目时要使用哪个版本。在我们的例子中，我们使用的是 2018 版本。之前的版本是 2015，如果没有 edition
    键存在，则假定它是默认版本。注意：使用 2018 版本创建的项目是向后兼容的，这意味着它们也可以将 2015 的 crate 作为依赖项。'
- en: Next is [package.metadata.settings]. Typically, Cargo complains about all of
    the keys and sections that it doesn't know about, but the sections with metadata
    in them are an exception. They are ignored by Cargo, so they can be used for any
    configurable key/value pairs you need for your project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 [package.metadata.settings]。通常，Cargo 会对其不认识的键和部分进行抱怨，但包含元数据的部分是一个例外。它们被
    Cargo 忽略，因此可以用于您项目所需的任何可配置的键/值对。
- en: 'The [features], [dependencies], and [build-dependencies] sections tie in together.
    A dependency can be declared by version number, as stated in SemVer''s guidelines:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[features]、[dependencies] 和 [build-dependencies] 部分相互关联。依赖项可以通过版本号声明，如 SemVer
    指南中所述：'
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that serde is a mandatory dependency and that we want the newest
    version, 1.0.*. The actual version will be fixed in Cargo.lock.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 serde 是一个强制依赖项，我们想要最新版本，1.0.*。实际版本将在 Cargo.lock 中固定。
- en: 'Using the caret symbol broadens the version ranges that Cargo is allowed to
    look for:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 caret 符号可以扩展 Cargo 允许查找的版本范围：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we're saying that we want the latest major version, 0.*.*, which must
    be at least 0.58.*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们表示我们想要最新的主要版本，0.*.*，它必须至少是 0.58.*。
- en: 'Cargo also allows you to specify dependencies directly to a Git repository,
    provided that the repository is a project that was created by Cargo and follows
    the directory structure that Cargo expects. We can specify the dependency from
    GitHub like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 还允许您直接将依赖项指定到 Git 仓库，前提是仓库是一个由 Cargo 创建的项目，并且遵循 Cargo 预期的目录结构。我们可以这样指定来自
    GitHub 的依赖项：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This also works for other online Git repositories such as GitLab. Again, the
    actual version (or in the case of Git, changeset revision) will be fixed in Cargo.lock
    by the cargo update command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于其他在线 Git 仓库，如 GitLab。同样，实际的版本（或 Git 的情况下的更改集修订版）将由 cargo update 命令在 Cargo.lock
    中固定。
- en: 'The manifest also has two optional dependencies, mysql and sqlite:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清单还有两个可选依赖项，mysql 和 sqlite：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This means that the program can be built without depending on either. The [features]
    section contains a list of the default features:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着程序可以在不依赖任何一方的情况下构建。[features] 部分包含默认功能的列表：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This means that if you do not manually override the feature set when building
    your program, only mysql, and not sqlite, will be pulled in. An example use of
    features is when your library has certain optimization tweaks. However, this would
    be costly on an embedded platform, so the library author can release them as features,
    which will only be available on capable systems. Another example is when you are
    building a command-line application and also provide a GUI frontend as an extra
    feature.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您在构建程序时没有手动覆盖功能集，则只会拉入 mysql，而不是 sqlite。功能的一个示例用法是当您的库有某些优化调整时。然而，在嵌入式平台上这将是昂贵的，因此库作者可以将它们作为功能发布，这样它们只会在有能力的系统上可用。另一个例子是当您构建一个命令行应用程序，并提供一个作为额外功能的
    GUI 前端时。
- en: That was a quick brief tour on how to describe a Cargo project using the Cargo.toml
    manifest file. There's quite a lot more to explore on how to configure your project
    with Cargo. Take a look at [https://doc.rust-lang.org/cargo/reference/manifest.html](https://doc.rust-lang.org/cargo/reference/manifest.html)
    for more information.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用Cargo.toml清单文件描述Cargo项目的快速简要概述。关于如何使用Cargo配置项目还有很多可以探索的。更多信息请查看[https://doc.rust-lang.org/cargo/reference/manifest.html](https://doc.rust-lang.org/cargo/reference/manifest.html)。
- en: Setting up a Rust development environment
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Rust开发环境
- en: 'Rust has decent support for most code editors out there, whether it be vim,
    Emacs, intellij IDE, Sublime, Atom, or Visual Studio Code. Cargo is also well
    supported by these editors, and the ecosystem has several tools that enhance the
    experience, such as the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Rust对大多数代码编辑器都有良好的支持，无论是vim、Emacs、intellij IDE、Sublime、Atom还是Visual Studio Code。Cargo也受到这些编辑器的良好支持，生态系统中有几个工具可以增强体验，如下所示：
- en: 'rustfmt: It formats code according to conventions that are mentioned in the
    Rust style guide.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rustfmt：它根据Rust风格指南中提到的约定格式化代码。
- en: 'clippy: This warns you of common mistakes and potential code smells. Clippy
    relies on compiler plugins that are marked as unstable, so it is available with
    nightly Rust only. With rustup, you can switch to nightly easily.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: clippy：它会警告你常见的错误和潜在的代码问题。Clippy依赖于标记为不稳定的编译器插件，因此它仅适用于nightly Rust。使用rustup，你可以轻松切换到nightly。
- en: 'racer: It can do lookups into Rust standard libraries and provides code completion
    and tool tips.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: racer：它可以查询Rust标准库，并提供代码补全和工具提示。
- en: Among the aforementioned editors, the most mature IDE experience is provided
    by Intellij IDE and Visual Studio Code (vscode). We will cover setting up the
    development environment for vscode in this chapter as it is more accessible and
    lightweight. For vscode, the Rust community has an extension known as rls-vscode,
    which we'll install here. This extension is consists of the Rust language server
    (RLS), which uses many of the tools that we listed previously internally. We will
    be setting it up on Visual Studio Code 1.23.1 (d0182c341) with Ubuntu 16.04.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述编辑器中，Intellij IDE和Visual Studio Code（vscode）提供了最成熟的IDE体验。在本章中，我们将介绍如何设置vscode的开发环境，因为它更易于访问且更轻量级。对于vscode，Rust社区有一个名为rls-vscode的扩展，我们将在本节中安装它。此扩展由Rust语言服务器（RLS）组成，它内部使用了我们之前列出的许多工具。我们将使用Visual
    Studio Code 1.23.1（d0182c341）和Ubuntu 16.04来设置它。
- en: Installing vscode is beyond the scope of this book. You may look for your operating
    system's package repositories and go to [https://code.visualstudio.com](https://code.visualstudio.com)
    for more information on the same.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 安装vscode超出了本书的范围。你可以在操作系统的软件仓库中查找，并访问[https://code.visualstudio.com](https://code.visualstudio.com)获取更多信息。
- en: 'Let''s actually open our imgtool application we created at the start of this
    chapter in vscode:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际打开本章开头创建的imgtool应用程序在vscode中：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we open our project, vscode recognizes our project automatically as a
    Rust project and gives us recommendations to download the vscode extension. It
    will look something like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打开我们的项目，vscode会自动识别我们的项目为Rust项目，并给我们推荐下载vscode扩展。它看起来可能像这样：
- en: '![](img/0d3dc2e1-222a-4d19-8430-c530e1ec5962.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d3dc2e1-222a-4d19-8430-c530e1ec5962.png)'
- en: 'If you don''t get recommendations, you can always type Rust in the search bar
    on the top left. We can then click on Install and press Reload on the extension
    page, which restarts vscode and makes it available for use in our project:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到推荐，你总是可以在左上角的搜索栏中输入Rust。然后我们可以点击安装，并在扩展页面按“重新加载”，这将重启vscode并使其在我们的项目中可用：
- en: '![](img/666378c4-6986-4f6c-836e-45b167bde200.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/666378c4-6986-4f6c-836e-45b167bde200.png)'
- en: 'Next time you open the main.rs file in the project and start typing, the extension
    will kick in and prompt you to install any missing toolchains related to Rust
    that you can click install. It then starts downloading that toolchain:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你打开项目中main.rs文件并开始输入时，扩展程序会启动并提示你安装任何与Rust相关的缺失工具链，你可以点击安装。然后它开始下载该工具链：
- en: '![](img/330ecea7-31f3-4978-8e8b-bbfe8f703a11.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/330ecea7-31f3-4978-8e8b-bbfe8f703a11.png)'
- en: 'After a few minutes, the status will change, like so:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，状态将发生变化，如下所示：
- en: '![](img/bd7927bb-7700-40de-8dc7-d6a9de758ba3.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd7927bb-7700-40de-8dc7-d6a9de758ba3.png)'
- en: Now, we are good to go.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始了。
- en: 'Note: Since RLS is still in its preview phase, you may experience RLS getting
    stuck when installing on its first go. By restarting vscode and reinstalling RLS
    again after removing it, it should work. If it doesn''t, feel free to raise an
    issue on its GitHub page: [rls-vscode](https://github.com/rust-lang-nursery/rls-vscode).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由于 RLS 还处于预览阶段，您在首次安装时可能会遇到 RLS 卡住的情况。通过重新启动 vscode 并在删除它之后重新安装 RLS，应该可以工作。如果不行，请随意在其
    GitHub 页面 [rls-vscode](https://github.com/rust-lang-nursery/rls-vscode) 上提出问题。
- en: 'With our imgtool project opened, let''s see how RLS responds when we try to
    import a module:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 imgtool 项目打开的情况下，让我们看看当尝试导入一个模块时 RLS 的响应：
- en: '![](img/1ab61d99-ff36-49f1-b770-7535b5c90dc6.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ab61d99-ff36-49f1-b770-7535b5c90dc6.png)'
- en: 'As you can see, it performs auto completion for the items that are available
    in the fs module in the Rust standard library. Finally, let''s take a look at
    how RLS handles formatting code for us. Let''s put all of the code on the same
    line to demonstrate this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它为 Rust 标准库中 fs 模块中可用的项目执行自动完成。最后，让我们看看 RLS 是如何为我们处理代码格式的。让我们将所有代码放在同一行上以演示这一点：
- en: '![](img/fde7a7f9-2ea3-4476-8159-7ea93ab944ca.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fde7a7f9-2ea3-4476-8159-7ea93ab944ca.png)'
- en: 'Let''s save the file. We can then use Ctrl + Shift + I or Ctrl + Shift + P
    and select Format Document. This will instantly format the document and run cargo
    check against your code once you hit Save:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存文件。然后我们可以使用 Ctrl + Shift + I 或 Ctrl + Shift + P 并选择 Format Document。这将立即格式化文档，并在您点击保存时对您的代码运行
    cargo check：
- en: '![](img/6b51de7c-4d6d-4819-a93c-879823274426.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b51de7c-4d6d-4819-a93c-879823274426.png)'
- en: For more information on other code editors, Rust has a page called [https://areweideyet.com](https://areweideyet.com/)
    that lists the status of all editors, along with the categories, showing the extent
    of support they have for the language. Do check them out!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 关于其他代码编辑器的更多信息，Rust 有一个名为 [https://areweideyet.com](https://areweideyet.com/)
    的页面，列出了所有编辑器的状态，包括类别，显示了它们对该语言的支持程度。请务必查看它们！
- en: Now, let's continue to implement our imgtool application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现我们的 imgtool 应用程序。
- en: Building a project with Cargo – imgtool
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cargo 构建项目 – imgtool
- en: We now have a fairly good understanding of how to manage projects using Cargo.
    To drive the concepts in, we will build a command-line application that uses a
    third-party crate. The whole point of this exercise is to become familiar with
    the usual workflow of building projects by using third-party crates, so we're
    going to skip over a lot of details about the code we write here. You are encouraged
    to check out the documentation of the APIs that are used in the code, though.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们相当了解如何使用 Cargo 管理项目。为了深入理解这些概念，我们将构建一个使用第三方 crate 的命令行应用程序。这个练习的全部目的是熟悉使用第三方
    crate 构建项目的常规工作流程，因此我们将跳过我们编写代码的许多细节。尽管如此，我们鼓励您查看代码中使用的 API 的文档。
- en: We'll use a crate called image from crates.io. This crate provides various image
    manipulation APIs. Our command-line application will be simple; it will take a
    path to an image file as its argument, rotate it by 90 degrees, and write back
    to the same file, every time when run.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 image 的 crate，它来自 crates.io。这个 crate 提供了各种图像处理 API。我们的命令行应用程序将很简单；它将接受一个图像文件的路径作为参数，每次运行时都将其旋转
    90 度，并将其写回同一文件。
- en: 'We''ll cd into the imgtool directory, which we created previously. First, we
    need to tell Cargo that we want to use the image crate. We can use the cargo add
    image@0.19.0 command to add the image crate with version 0.19.0 from the command
    line. Here''s our updated Cargo.toml file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进入之前创建的 imgtool 目录。首先，我们需要告诉 Cargo 我们想要使用 image crate。我们可以使用 cargo add image@0.19.0
    命令从命令行添加版本为 0.19.0 的 image crate。以下是我们的更新后的 Cargo.toml 文件：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we''ll invoke cargo build. This pulls the image crate from crates.io and
    pulls its dependencies, before finally compiling our project. Once that is done,
    we are ready to use it in our main.rs file. For our app, we''ll provide an image
    path as an argument. In our main.rs file, we want to read this image''s path:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将调用 cargo build。这将从 crates.io 拉取 image crate 及其依赖项，最后编译我们的项目。一旦完成，我们就可以在
    main.rs 文件中使用它了。对于我们的应用程序，我们将提供一个图像路径作为参数。在我们的 main.rs 文件中，我们想要读取此图像的路径：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we read the argument that was passed to imgtool by invoking the args()
    function from the env module. This returns a string as a path to the image file.
    We then take the image path and create a Path instance out of it. Next comes the
    rotate functionality that comes from the image crate. Note that if you''re running
    Rust 2015 edition, you will need an additional extern crate image; declaration
    on top of main.rs for you to be able to access the image crate''s APIs. With Rust
    2018 edition, this is not needed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过从 env 模块中调用 args() 函数来读取传递给 imgtool 的参数。这返回一个字符串，作为图像文件的路径。然后我们获取图像路径并从中创建一个
    Path 实例。接下来是来自 image crate 的旋转功能。请注意，如果你正在运行 Rust 2015 版本，你需要一个额外的 extern crate
    image; 声明在 main.rs 的顶部，以便你能够访问 image crate 的 API。在 Rust 2018 版本中，这不再需要：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'From the image crate, we use the open function to open our image and store
    it in img. We then call rotate90 on img. This returns an image buffer as rotated,
    which we just save back to the original image path by calling save and passing
    the path. Most of the function calls in the preceding code return a wrapper value
    called Result, and so we call unwrap() on Result values to tell the compiler that
    we don''t care whether the function call failed, assuming that it has succeeded,
    and we just want to get the wrapped value from the Result type. We will learn
    about the Result type and proper error handling methods in [Chapter 6](35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml),
    Error Handling. For the demo, under the project''s asset folder, you will find
    an image of Ferris the crab (assets/ferris.png). Before running the code, we will
    see the following image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从 image crate 中，我们使用 open 函数打开我们的图片并将其存储在 img 中。然后我们在 img 上调用 rotate90。这返回一个旋转后的图像缓冲区，我们通过调用
    save 并传递路径将其保存回原始图像路径。前述代码中的大多数函数调用都返回一个名为 Result 的包装值，因此我们在 Result 值上调用 unwrap()
    来告诉编译器我们不在乎函数调用是否失败，假设它已经成功，我们只想从 Result 类型中获取包装的值。我们将在[第 6 章](35bd7e4b-a6ae-400d-bc25-2c3b92b3b630.xhtml)“错误处理”中学习关于
    Result 类型以及适当的错误处理方法。对于演示，在项目的 asset 文件夹下，你可以找到一个名为 Ferris 的螃蟹的图片（assets/ferris.png）。在运行代码之前，我们将看到以下图片：
- en: '![](img/6ad86620-328b-4554-aa09-40217f42a948.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ad86620-328b-4554-aa09-40217f42a948.png)'
- en: 'Time to run our application with this image as an argument. Now, there are
    two ways you can run the imgtool binary and pass the image as an argument:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用这张图片作为参数来运行我们的应用程序了。现在，你有两种方式可以运行 imgtool 二进制文件并传递图片作为参数：
- en: By doing a cargo build and then invoking the binary manually as ./target/debug/imgtool
    assets/ferris.png.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过先运行 cargo build，然后手动调用二进制文件作为 ./target/debug/imgtool assets/ferris.png 来执行。
- en: By directly running cargo run -- assets/ferris.png. The double dashes mark the
    end of the parameters for Cargo's own arguments. Anything after it is passed to
    our executable (here, this is imgtool).
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接运行 cargo run -- assets/ferris.png。双横线标志着 Cargo 自身参数的结束。之后的所有内容都将传递给我们的可执行文件（这里，这是
    imgtool）。
- en: 'After running cargo run -- assets/ferris.png, we can see that Ferris has taken
    a tumble:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 cargo run -- assets/ferris.png 后，我们可以看到 Ferris 翻了个跟头：
- en: '![](img/bd71b4be-3c8c-46c9-8dbc-072785f58c0c.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd71b4be-3c8c-46c9-8dbc-072785f58c0c.png)'
- en: 'Great! Our application works. We can now install our tool by running cargo
    install inside our imgtool directory and then use it from anywhere in our terminal.
    Also, if you are on Ubuntu, we can use the cargo deb subcommand to create a deb
    package so that you can distribute it to other consumers. Running the cargo deb
    command produces the .deb file, as shown in the following screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的应用程序运行正常。我们现在可以通过在 imgtool 目录中运行 cargo install 来安装我们的工具，然后从终端的任何位置使用它。此外，如果你使用的是
    Ubuntu，我们可以使用 cargo deb 子命令来创建一个 deb 包，以便你可以将其分发给其他用户。运行 cargo deb 命令会产生一个 .deb
    文件，如下面的截图所示：
- en: '![](img/3de74bba-7bbf-4ed5-bf79-7ca9a3391488.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3de74bba-7bbf-4ed5-bf79-7ca9a3391488.png)'
- en: 'Now, it''s time for you to explore more in relation to the preceding code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是你探索与前面代码相关内容的时候了：
- en: Use the Rust standard library docs at [https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/)
    to learn about the unwrap() function in Rust and on what types it is available.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rust 标准库文档[https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/)来了解
    Rust 中的 unwrap() 函数及其可用类型。
- en: Look for the Path type in the standard library docs to see if you can modify
    the program to not overwrite the files, and instead create a new file with  _rotated as
    the new file suffix.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准库文档中查找 Path 类型，看看你是否可以修改程序以不覆盖文件，而是创建一个新文件，其新文件后缀为 _rotated。
- en: Use the search bar in the documentation page of the image crate ([https://docs.rs/image](https://docs.rs/image))
    and try finding other rotate methods with different angles, and modify the code
    to make use of them.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图像crate（[https://docs.rs/image](https://docs.rs/image)）的文档页面中的搜索栏，尝试查找具有不同角度的其他旋转方法，并修改代码以使用它们。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got acquainted with the standard Rust build tool, Cargo.
    We took a cursory look at initializing, building, and running tests using Cargo.
    We also explored tools beyond Cargo that make developer experience smoother and
    more efficient, such as RLS and clippy. We saw how these tools can be integrated
    with the Visual Studio Code editor by installing the RLS extension. Finally, we
    created a small CLI tool to manipulate images by using a third-party crate from
    Cargo.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了标准的Rust构建工具Cargo。我们简要地了解了如何使用Cargo初始化、构建和运行测试。我们还探索了Cargo之外的工具，这些工具可以使开发体验更加流畅和高效，例如RLS和clippy。我们看到了如何通过安装RLS扩展来将这些工具与Visual
    Studio Code编辑器集成。最后，我们创建了一个小型的CLI工具，通过使用Cargo中的第三方crate来操作图像。
- en: In the next chapter, we will be talking about testing, documenting, and benchmarking
    our code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论测试、文档化和基准测试我们的代码。
