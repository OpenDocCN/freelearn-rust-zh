["```rs\nmockito = \"0.15\"\nreqwest = \"0.9\"\n```", "```rs\nuse crate::{start, Comment, LinksMap, UserForm, UserId};\nuse lazy_static::lazy_static;\nuse mockito::{mock, Mock};\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Mutex;\nuse std::time::Duration;\nuse std::thread;\n```", "```rs\n#[derive(Clone)]\nstruct LinksMap {\n    signup: String,\n    signin: String,\n    new_comment: String,\n    comments: String,\n}\n```", "```rs\n#[derive(Clone)]\nstruct State {\n    counter: RefCell<i64>,\n    links: LinksMap,\n}\n```", "```rs\nfn add_mock<T>(method: &str, path: &str, result: T) -> Mock\nwhere\n    T: Serialize,\n{\n    mock(method, path)\n        .with_status(200)\n        .with_header(\"Content-Type\", \"application/json\")\n        .with_body(serde_json::to_string(&result).unwrap())\n        .create()\n}\n```", "```rs\nlazy_static! {\n    static ref STARTED: Mutex<bool> = Mutex::new(false);\n}\n```", "```rs\nfn setup() {\n    let mut started = STARTED.lock().unwrap();\n    if !*started {\n        thread::spawn(|| {\n            let url = mockito::server_url();\n            let _signup = add_mock(\"POST\", \"/signup\", ());\n            let _signin = add_mock(\"POST\", \"/signin\", UserId { id: \"user-id\".into() });\n            let _new_comment = add_mock(\"POST\", \"/new_comment\", ());\n            let comment = Comment {\n                id: None,\n                text: \"comment\".into(),\n                uid: \"user-id\".into(),\n            };\n            let _comments = add_mock(\"GET\", \"/comments\", vec![comment]);\n            let links = LinksMap {\n                signup: mock_url(&url, \"/signup\"),\n                signin: mock_url(&url, \"/signin\"),\n                new_comment: mock_url(&url, \"/new_comment\"),\n                comments: mock_url(&url, \"/comments\"),\n            };\n            start(links);\n        });\n        thread::sleep(Duration::from_secs(5));\n        *started = true;\n    }\n}\n```", "```rs\nfn mock_url(base: &str, path: &str) -> String {\n    format!(\"{}{}\", base, path)\n}\n```", "```rs\nfn start(links: LinksMap) {\n    let sys = actix::System::new(\"router\");\n    let state = State {\n        counter: RefCell::default(),\n        links,\n    };\n    server::new(move || {\n        App::with_state(state.clone())\n            // App resources attached here\n    }).workers(1).bind(\"127.0.0.1:8080\").unwrap().start();\n    sys.run();\n}\n```", "```rs\nfn test_get<T>(path: &str) -> T\nwhere\n    T: for <'de> Deserialize<'de>,\n{\n    let client =  Client::new();\n    let data = client.get(&test_url(path))\n        .send()\n        .unwrap()\n        .text()\n        .unwrap();\n    serde_json::from_str(&data).unwrap()\n}\n```", "```rs\nfn test_url(path: &str) -> String {\n    format!(\"http://127.0.0.1:8080/api{}\", path)\n}\n```", "```rs\nfn test_post<T>(path: &str, data: &T)\nwhere\n    T: Serialize,\n{\n    setup();\n    let client =  Client::new();\n    let resp = client.post(&test_url(path))\n        .form(data)\n        .send()\n        .unwrap();\n    let status = resp.status();\n    assert!(status.is_success());\n}\n```", "```rs\n#[test]\nfn test_signup_with_client() {\n    let user = UserForm {\n        email: \"abc@example.com\".into(),\n        password: \"abc\".into(),\n    };\n    test_post(\"/signup\", &user);\n}\n```", "```rs\n#[test]\nfn test_signin_with_client() {\n    let user = UserForm {\n        email: \"abc@example.com\".into(),\n        password: \"abc\".into(),\n    };\n    test_post(\"/signin\", &user);\n}\n```", "```rs\n#[test]\nfn test_list_with_client() {\n    let _: Vec<Comment> = test_get(\"/comments\");\n}\n```", "```rs\nrunning 3 tests\ntest tests::test_list_with_client ... ok\ntest tests::test_signup_with_client ... ok\ntest tests::test_signin_with_client ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\nrunning 3 tests\ntest tests::test_list_with_client ... ok\ntest tests::test_signin_with_client ... FAILED\ntest tests::test_signup_with_client ... ok\n\nfailures:\n---- tests::test_signin_with_client stdout ----\nthread 'tests::test_signin_with_client' panicked at 'assertion failed: status.is_success()', src/lib.rs:291:9\nnote: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n\nfailures:\n    tests::test_signin_with_client\n\ntest result: FAILED. 2 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n```", "```rs\ndocker build -t rust:nightly nightly\ndocker-compose -f docker-compose.test.yml up\n```", "```rs\ncookie = \"0.11\"\nrand = \"0.6\"\nreqwest = \"0.9\"\nserde = \"1.0\"\nserde_derive = \"1.0\"\nserde_json = \"1.0\"\nuuid = { version = \"0.5\", features = [\"serde\", \"v4\"] }\n```", "```rs\nuse cookie::{Cookie, CookieJar};\nuse rand::{Rng, thread_rng};\nuse rand::distributions::Alphanumeric;\npub use reqwest::{self, Client, Method, RedirectPolicy, StatusCode};\nuse reqwest::header::{COOKIE, SET_COOKIE};\nuse serde::Deserialize;\nuse std::collections::HashMap;\nuse std::iter;\nuse std::time::Duration;\nuse std::thread;\n```", "```rs\nconst USERS: &str = \"http://localhost:8001\";\nconst MAILER: &str = \"http://localhost:8002\";\nconst CONTENT: &str = \"http://localhost:8003\";\nconst ROUTER: &str = \"http://localhost:8000\";\n```", "```rs\npub fn url(url: &str, path: &str) -> String {\n    url.to_owned() + path\n}\n```", "```rs\npub fn rand_str() -> String {\n    let mut rng = thread_rng();\n    iter::repeat(())\n            .map(|()| rng.sample(Alphanumeric))\n            .take(7)\n            .collect()\n}\n```", "```rs\npub fn wait(s: u64) {\n    thread::sleep(Duration::from_secs(s));\n}\n```", "```rs\npub struct WebApi {\n    client: Client,\n    url: String,\n    jar: CookieJar,\n}\n```", "```rs\nimpl WebApi {\n    fn new(url: &str) -> Self {\n        let client = Client::builder()\n            .redirect(RedirectPolicy::none())\n            .build()\n            .unwrap();\n        Self {\n            client,\n            url: url.into(),\n            jar: CookieJar::new(),\n        }\n    }\n}\n```", "```rs\npub fn users() -> Self { WebApi::new(USERS) }\npub fn mailer() -> Self { WebApi::new(MAILER) }\npub fn content() -> Self { WebApi::new(CONTENT) }\npub fn router() -> Self { WebApi::new(ROUTER) }\n```", "```rs\npub fn healthcheck(&mut self, path: &str, content: &str) {\n    let url = url(&self.url, path);\n    let mut resp = reqwest::get(&url).unwrap();\n    assert_eq!(resp.status(), StatusCode::OK);\n    let text = resp.text().unwrap();\n    assert_eq!(text, content);\n}\n```", "```rs\npub fn request<'a, I, J>(&mut self, method: Method, path: &'a str, values: I) -> J\nwhere\n    I: IntoIterator<Item = (&'a str, &'a str)>,\n    J: for <'de> Deserialize<'de>,\n{\n    let url = url(&self.url, path);\n    let params = values.into_iter().collect::<HashMap<_, _>>();\n    let mut resp = self.client.request(method, &url)\n        .form(&params)\n        .send()\n        .unwrap();\n\n    let status = resp.status().to_owned();\n\n    let text = resp\n        .text()\n        .unwrap();\n\n    if status != StatusCode::OK {\n        panic!(\"Bad response [{}] of '{}': {}\", resp.status(), path, text);\n    }\n\n    let value = serde_json::from_str(&text);\n    match value {\n        Ok(value) => value,\n        Err(err) => {\n            panic!(\"Can't convert '{}': {}\", text, err);\n        },\n    }\n}\n```", "```rs\npub fn check_status<'a, I>(&mut self, method: Method, path: &'a str, values: I, status: StatusCode)\nwhere\n    I: IntoIterator<Item = (&'a str, &'a str)>,\n{\n    let url = url(&self.url, path);\n    let params = values.into_iter().collect::<HashMap<_, _>>();\n    let cookies = self.jar.iter()\n        .map(|kv| format!(\"{}={}\", kv.name(), kv.value()))\n        .collect::<Vec<_>>()\n        .join(\";\");\n    let resp = self.client.request(method, &url)\n        .header(COOKIE, cookies)\n        .form(&params)\n        .send()\n        .unwrap();\n    if let Some(value) = resp.headers().get(SET_COOKIE) {\n        let raw_cookie = value.to_str().unwrap().to_owned();\n        let cookie = Cookie::parse(raw_cookie).unwrap();\n        self.jar.add(cookie);\n    }\n    assert_eq!(status, resp.status());\n}\n```", "```rs\nuse serde_derive::Deserialize;\nuse uuid::Uuid;\n```", "```rs\n#[derive(Deserialize)]\npub struct UserId {\n    id: Uuid,\n}\n```", "```rs\n#[derive(Deserialize)]\npub struct Comment {\n    pub id: i32,\n    pub uid: String,\n    pub text: String,\n}\n```", "```rs\nmod types;\nmod utils;\n\nuse self::types::UserId;\nuse self::utils::{Method, WebApi};\n```", "```rs\n#[test]\nfn users_healthcheck() {\n    let mut api = WebApi::users();\n    api.healthcheck(\"/\", \"Users Microservice\");\n}\n```", "```rs\n#[test]\nfn check_signup_and_signin() {\n    let mut api = WebApi::users();\n    let username = utils::rand_str() + \"@example.com\";\n    let password = utils::rand_str();\n    let params = vec![\n        (\"email\", username.as_ref()),\n        (\"password\", password.as_ref()),\n    ];\n    let _: () = api.request(Method::POST, \"/signup\", params);\n\n    let params = vec![\n        (\"email\", username.as_ref()),\n        (\"password\", password.as_ref()),\n    ];\n    let _: UserId = api.request(Method::POST, \"/signin\", params);\n}\n```", "```rs\nmod types;\nmod utils;\n\nuse self::utils::{Method, WebApi};\nuse self::types::Comment;\n```", "```rs\n#[test]\nfn content_healthcheck() {\n    let mut api = WebApi::content();\n    api.healthcheck(\"/\", \"Content Microservice\");\n}\n```", "```rs\n#[test]\nfn add_comment() {\n    let mut api = WebApi::content();\n    let uuid = uuid::Uuid::new_v4().to_string();\n    let comment = utils::rand_str();\n    let params = vec![\n        (\"uid\", uuid.as_ref()),\n        (\"text\", comment.as_ref()),\n    ];\n    let _: () = api.request(Method::POST, \"/new_comment\", params);\n\n    let comments: Vec<Comment> = api.request(Method::GET, \"/list\", vec![]);\n    assert!(comments.into_iter().any(|Comment { text, ..}| { text == comment }))\n}\n```", "```rs\nmod utils;\n\nuse self::utils::{Method, WebApi};\n```", "```rs\n#[test]\nfn mails_healthcheck() {\n    let mut api = WebApi::mailer();\n    api.healthcheck(\"/\", \"Mailer Microservice\");\n}\n```", "```rs\n#[test]\nfn send_mail() {\n    let mut api = WebApi::mailer();\n    let email = utils::rand_str() + \"@example.com\";\n    let code = utils::rand_str();\n    let params = vec![\n        (\"to\", email.as_ref()),\n        (\"code\", code.as_ref()),\n    ];\n    let sent: bool = api.request(Method::POST, \"/send\", params);\n    assert!(sent);\n}\n```", "```rs\nmod types;\nmod utils;\n\nuse self::utils::{Method, StatusCode, WebApi};\nuse self::types::Comment;\n```", "```rs\n#[test]\nfn router_healthcheck() {\n    let mut api = WebApi::router();\n    api.healthcheck(\"/healthcheck\", \"Router Microservice\");\n}\n```", "```rs\n#[test]\nfn check_router_full() {\n    let mut api = WebApi::router();\n    let username = utils::rand_str() + \"@example.com\";\n    let password = utils::rand_str();\n    let params = vec![\n        (\"email\", username.as_ref()),\n        (\"password\", password.as_ref()),\n    ];\n    api.check_status(Method::POST, \"/api/signup\", params, StatusCode::FOUND);\n\n    let params = vec![\n        (\"email\", username.as_ref()),\n        (\"password\", password.as_ref()),\n    ];\n    api.check_status(Method::POST, \"/api/signin\", params, StatusCode::FOUND);\n\n    let comment = utils::rand_str();\n    let params = vec![\n        (\"text\", comment.as_ref()),\n    ];\n    api.check_status(Method::POST, \"/api/new_comment\", params, StatusCode::FOUND);\n\n    let comments: Vec<Comment> = api.request(Method::GET, \"/api/comments\", vec![]);\n    assert!(comments.into_iter().any(|Comment { text, ..}| { text == comment }))\n}\n```", "```rs\ncurl -X POST -H \"Content-Type: application/json\" -d @file.json http://localhost:8080/upload\n```", "```rs\ncurl -X POST -F login=user -F password=secret http://localhost:8080/register\n```", "```rs\nmitmweb --mode reverse:http://localhost:7000 --web-port 7777 --listen-port 7780\n```", "```rs\nrust-lldb ./target/debug/router-microservice\n```", "```rs\n(lldb) command script import \"/home/user/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/etc/lldb_rust_formatters.py\"\n(lldb) type summary add --no-value --python-function lldb_rust_formatters.print_val -x \".*\" --category Rust\n(lldb) type category enable Rust\n(lldb) target create \"./target/debug/router-microservice\"\nCurrent executable set to './target/debug/router-microservice' (x86_64).\n(lldb) \n```", "```rs\nbreakpoint set --name comments\n```", "```rs\nBreakpoint 1: where = router-microservice`router_microservice::comments::h50a827d1180e4955 + 7 at main.rs:152, address = 0x00000000001d3c77\n```", "```rs\nrun\n```", "```rs\nProcess 10143 launched: '/home/user/sources/Chapter15/deploy/microservices/router/target/debug/router-microservice'\n```", "```rs\n   151     fn comments(req: HttpRequest<State>) -> FutureResponse<HttpResponse> {\n-> 152         debug!(\"/api/comments called\");\n   153         let url = format!(\"{}/list\", req.state().content());\n   154         let fut = get_req(&url)\n   155             .map(|data| {\n```", "```rs\nthread list\n```", "```rs\n  thread #3: tid = 10147, 0x00007ffff7e939d7 libc.so.6`.annobin_epoll_wait.c + 87, name = 'actix-web accep'\n  thread #4: tid = 10148, 0x00007ffff7f88b4d libpthread.so.0`__lll_lock_wait + 29, name = 'arbiter:77596ed'\n  thread #5: tid = 10149, 0x00007ffff7f8573c libpthread.so.0`__pthread_cond_wait + 508, name = 'arbiter:77596ed'\n```", "```rs\nslog = \"2.4\"\nslog-async = \"2.3\"\nslog-json = \"2.3\"\nslog-term = \"2.4\"\n```", "```rs\nuse slog::{crit, debug, error, Drain, Duplicate, Level, LevelFilter};\nuse slog_async::Async;\nuse slog_term::{CompactFormat, PlainDecorator};\nuse slog_json::Json;\nuse std::fs::OpenOptions;\nuse std::sync::Mutex;\n```", "```rs\nfn main() {\n   let log_path = \"app.log\";\n   let file = OpenOptions::new()\n      .create(true)\n      .write(true)\n      .truncate(true)\n      .open(log_path)\n      .unwrap();\n\n    let drain = Mutex::new(Json::default(file)).fuse();\n    let file_drain = LevelFilter::new(drain, Level::Error);\n\n    let decorator = PlainDecorator::new(std::io::stderr());\n    let err_drain = CompactFormat::new(decorator).build().fuse();\n\n    let drain_pair = Duplicate::new(file_drain, err_drain).fuse();\n    let drain = Async::new(drain_pair).build().fuse();\n\n    let log = slog::Logger::root(drain, slog::o!(\n        \"version\" => env!(\"CARGO_PKG_VERSION\"),\n        \"host\" => \"localhost\",\n        \"port\" => 8080,\n    ));\n    debug!(log, \"started\");\n    debug!(log, \"{} workers\", 2;);\n    debug!(log, \"request\"; \"from\" => \"example.com\");\n    error!(log, \"worker failed\"; \"worker_id\" => 1);\n    crit!(log, \"server can't continue to work\");\n}\n```", "```rs\ncargo watch --ignore *.log -x run\n```", "```rs\nversion: 0.1.0\n host: localhost\n  port: 8080\n   Jan 20 18:13:53.061 DEBG started\n   Jan 20 18:13:53.062 DEBG 2 workers\n   Jan 20 18:13:53.062 DEBG request, from: example.com\n   Jan 20 18:13:53.062 ERRO worker failed, worker_id: 1\n   Jan 20 18:13:53.063 CRIT server can't continue to work\n```", "```rs\n{\"msg\":\"worker failed\",\"level\":\"ERRO\",\"ts\":\"2019-01-20T18:13:53.061797633+03:00\",\"port\":8080,\"host\":\"localhost\",\"version\":\"0.1.0\",\"worker_id\":1}\n{\"msg\":\"server can't continue to work\",\"level\":\"CRIT\",\"ts\":\"2019-01-20T18:13:53.062762204+03:00\",\"port\":8080,\"host\":\"localhost\",\"version\":\"0.1.0\"}\n```", "```rs\n$ docker run --rm --name jaeger \\\n -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\\n -p 5775:5775/udp \\\n -p 6831:6831/udp \\\n -p 6832:6832/udp \\\n -p 5778:5778 \\\n -p 16686:16686 \\\n -p 14268:14268 \\\n -p 9411:9411 \\\n jaegertracing/all-in-one:1.8\n```", "```rs\nrustracing = \"0.1\"\nrustracing_jaeger = \"0.1\"\n```", "```rs\nuse rustracing::sampler::AllSampler;\nuse rustracing::tag::Tag;\nuse rustracing_jaeger::Tracer;\nuse rustracing_jaeger::reporter::JaegerCompactReporter;\nuse std::time::Duration;\nuse std::thread;\n```", "```rs\nfn wait(ms: u64) {\n    thread::sleep(Duration::from_millis(ms));\n}\n```", "```rs\nlet (tracer1, span_rx1) = Tracer::new(AllSampler);\nlet (tracer2, span_rx2) = Tracer::new(AllSampler);\nthread::spawn(move || {\n    loop {\n        {\n            let req_span = tracer1\n                .span(\"incoming request\")\n                .start();\n            wait(50);\n            {\n                let db_span = tracer2\n                    .span(\"database query\")\n                    .child_of(&req_span)\n                    .tag(Tag::new(\"query\", \"SELECT column FROM table;\"))\n                    .start();\n                wait(100);\n                let _resp_span = tracer2\n                    .span(\"generating response\")\n                    .follows_from(&db_span)\n                    .tag(Tag::new(\"user_id\", \"1234\"))\n                    .start();\n                wait(10);\n            }\n        }\n        wait(150);\n    }\n});\n```", "```rs\nlet reporter1 = JaegerCompactReporter::new(\"router\").unwrap();\nlet reporter2 = JaegerCompactReporter::new(\"dbaccess\").unwrap();\nloop {\n    if let Ok(span) = span_rx1.try_recv() {\n        reporter1.report(&[span]).unwrap();\n    }\n    if let Ok(span) = span_rx2.try_recv() {\n        reporter2.report(&[span]).unwrap();\n    }\n    thread::yield_now();\n}\n```"]