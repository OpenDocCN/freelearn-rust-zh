["```rs\nconst audioContext = new AudioContext();\nlet sound = await fetch(\"SFX_Jump_23.mp3\");\nlet soundBuffer = await sound.arrayBuffer();\nlet decodedArray = await audioContext.decodeAudioData(soundBuffer);\n```", "```rs\nlet trackSource = audioContext.createBufferSource();\ntrackSource.buffer = decodedArray;\ntrackSource.connect(audioContext.destination);\ntrackSource.start();\n```", "```rs\n#[macro_use]\nmod browser;\nmod engine;\nmod game;\nmod segments;\nmod sound;\n```", "```rs\nuse anyhow::{anyhow, Result};\nuse web_sys::AudioContext;\npub fn create_audio_context() -> Result<AudioContext> {\n    AudioContext::new().map_err(|err| anyhow!\n        (\"Could not create audio context: {:#?}\", err))\n}\n```", "```rs\n[dependencies.web-sys]\nversion = \"0.3.55\"\nfeatures = [\"console\",\n           \"Window\",\n           \"Document\",\n           \"HtmlCanvasElement\",\n           \"CanvasRenderingContext2d\",\n           \"Element\",\n           \"HtmlImageElement\",\n           \"Response\",\n           \"Performance\",\n           \"KeyboardEvent\",\n           \"AudioContext\"\n           ]\n```", "```rs\n[dependencies.web-sys]\nversion = \"0.3.55\"\nfeatures = [\"console\",\n           \"Window\",\n           \"Document\",\n           \"HtmlCanvasElement\",\n           \"CanvasRenderingContext2d\",\n           \"Element\",\n           \"HtmlImageElement\",\n           \"Response\",\n           \"Performance\",\n           \"KeyboardEvent\",\n           \"AudioContext\",\n           \"AudioBuffer\",\n           \"AudioBufferSourceNode\",\n           \"AudioDestinationNode\",\n           ]\n```", "```rs\nuse anyhow::{anyhow, Result};\nuse web_sys::{AudioBuffer, AudioBufferSourceNode, AudioContext, AudioDestinationNode, AudioNode};\n...\nfn create_buffer_source(ctx: &AudioContext) -> Result<AudioBufferSourceNode> {\n    ctx.create_buffer_source()\n        .map_err(|err| anyhow!(\"Error creating buffer \n            source {:#?}\", err))\n}\nfn connect_with_audio_node(\n    buffer_source: &AudioBufferSourceNode,\n    destination: &AudioDestinationNode,\n) -> Result<AudioNode> {\n    buffer_source\n        .connect_with_audio_node(&destination)\n        .map_err(|err| anyhow!(\"Error connecting audio \n            source to destination {:#?}\", err))\n}\n```", "```rs\npub fn play_sound(ctx: &AudioContext, buffer: &AudioBuffer) -> Result<()> {\n    let track_source = create_buffer_source(ctx)?;\n    track_source.set_buffer(Some(&buffer));\n    connect_with_audio_node(&track_source, \n    &ctx.destination())?;\n        track_source\n        .start()\n        .map_err(|err| anyhow! \n            (\"Could not start sound!{:#?}\", err))\n}\n```", "```rs\nlet sound = await fetch(\"SFX_Jump_23.mp3\");\nlet soundBuffer = await sound.arrayBuffer();\nlet decodedArray = await audioContext.decodeAudioData(soundBuffer);\n```", "```rs\npub async fn fetch_json(json_path: &str) -> Result<JsValue> {\n    let resp_value = fetch_with_str(json_path).await?;\n    let resp: Response = resp_value\n        .dyn_into()\n        .map_err(|element| anyhow!(\"Error converting {:#?} \n            to Response\", element))?;\n    JsFuture::from(\n        resp.json()\n            .map_err(|err| anyhow!(\"Could not get JSON from \n                response {:#?}\", err))?,\n    )\n    .await\n    .map_err(|err| anyhow!(\"error fetching json {:#?}\", err\n        ))\n}\n```", "```rs\npub async fn fetch_response(resource: &str) -> Result<Response> {\n    fetch_with_str(resource)\n        .await?\n        .dyn_into()\n        .map_err(|err| anyhow!(\"error converting fetch to \n            Response {:#?}\", err))\n}\npub async fn fetch_json(json_path: &str) -> Result<JsValue> {\n    let resp = fetch_response(json_path).await?;\n    JsFuture::from(\n        resp.json()\n            .map_err(|err| anyhow!(\"Could not get JSON from \n                response {:#?}\", err))?,\n    )\n    .await\n    .map_err(|err| anyhow!(\"error fetching JSON {:#?}\", err\n        ))\n}\n```", "```rs\npub async fn fetch_array_buffer(resource: &str) -> Result<ArrayBuffer> {\n    let array_buffer = fetch_response(resource)\n        .await?\n        .array_buffer()\n        .map_err(|err| anyhow!(\"Error loading array buffer \n            {:#?}\", err))?;\n    JsFuture::from(array_buffer)\n        .await\n        .map_err(|err| anyhow!(\"Error converting array \n            buffer into a future {:#?}\", err))?\n        .dyn_into()\n        .map_err(|err| anyhow!(\"Error converting raw \n            JSValue to ArrayBuffer {:#?}\", err))\n}\n```", "```rs\npub async fn decode_audio_data(\n    ctx: &AudioContext,\n    array_buffer: &ArrayBuffer,\n) -> Result<AudioBuffer> {\n    JsFuture::from(\n        ctx.decode_audio_data(&array_buffer)\n            .map_err(|err| anyhow!(\"Could not decode audio from array buffer {:#?}\", err))?,\n    )\n    .await\n    .map_err(|err| anyhow!(\"Could not convert promise to \n        future {:#?}\", err))?\n    .dyn_into()\n    .map_err(|err| anyhow!(\"Could not cast into AudioBuffer \n        {:#?}\", err))\n}\n```", "```rs\n#[derive(Clone)]\npub struct Audio {\n    context: AudioContext,\n}\n#[derive(Clone)]\npub struct Sound {\n    buffer: AudioBuffer,\n}\n```", "```rs\nimpl Audio {\n    pub fn new() -> Result<Self> {\n        Ok(Audio {\n            context: sound::create_audio_context()?,\n        })\n    }\n    pub async fn load_sound(&self, filename: &str) ->         Result<Sound> {\n        let array_buffer = \n            browser::fetch_array_buffer(filename).await?;\n        let audio_buffer = \n            sound::decode_audio_data(&self.context, \n                &array_buffer).await?;\n        Ok(Sound {\n            buffer: audio_buffer,\n        })\n    }\n}\n```", "```rs\nimpl Audio {\n    ...\n    pub fn play_sound(&self, sound: &Sound) -> Result<()> {\n        sound::play_sound(&self.context, &sound.buffer)\n    }\n}\n```", "```rs\nimpl RedHatBoyContext {\n    ...\n    fn play_jump_sound(audio: &Audio) {\n        audio.play_sound(self.sound)\n    }\n}\n```", "```rs\n#[derive(Clone)]\nstruct RedHatBoyContext {\n    frame: u8,\n    position: Point,\n    velocity: Point,\n}\n```", "```rs\nnerror[E0507]: cannot move out of `self.state` which is behind a mutable reference\n   --> src/game.rs:134:22\n    |\n134 |         self.state_machine = self.state_machine.run();\n    |                      ^^^^^^^^^^ move occurs because `self.state` has type `RedHatBoyStateMachine`, which does not implement the `Copy` trait\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn run_right(&mut self) {\n        self.state_machine = self.state_machine.            transition(Event::Run);\n    }\n```", "```rs\nimpl RedHatBoy {\n    ...\n    fn run_right(&mut self) {\n        self.state_machine = self.state_machine\n            clone().transition(Event::Run);\n    }\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self, event) {\n            ...\n            _ => self,\n        }\n    }\n```", "```rs\nimpl RedHatBoyStateMachine {\n    fn transition(self, event: Event) -> Self {\n        match (self.clone(), event) {\n             ...\n             _ => self,\n        }\n    }\n```", "```rs\n#[derive(Clone)]\npub struct RedHatBoyContext {\n    pub frame: u8,\n    pub position: Point,\n    pub velocity: Point,\n    audio: Audio,\n    jump_sound: Sound,\n}\n```", "```rs\nimpl RedHatBoyState<Idle> {\n    fn new(audio: Audio, jump_sound: Sound) -> Self {\n        RedHatBoyState {\n            game_object: RedHatBoyContext {\n                frame: 0,\n                position: Point {\n                    x: STARTING_POINT,\n                    y: FLOOR,\n                },\n                velocity: Point { x: 0, y: 0 },\n                audio,\n                jump_sound,\n            },\n            _state: Idle {},\n        }\n    }\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let audio = Audio::new()?;\n                let sound = audio.load_sound\n                    (\"SFX_Jump_23.mp3\").await?;\n                let rhb = RedHatBoy::new(\n                    sheet,\n                    engine::load_image(\"rhb.png\").await?,\n                    audio,\n                    sound,\n                );\n                ...\n            }\n```", "```rs\nimpl RedHatBoyContext {\n    ...\n    fn play_jump_sound(self) -> Self {\n        if let Err(err) = self.audio.play_sound\n           (&self.jump_sound) {\n            log!(\"Error playing jump sound {:#?}\", err);\n        }\n        self\n    }\n}\n```", "```rs\n    impl RedHatBoyState<Running> {\n        ...\n        pub fn jump(self) -> RedHatBoyState<Jumping> {\n            RedHatBoyState {\n                context: self\n                    .context\n                    .reset_frame()\n                    .set_vertical_velocity(JUMP_SPEED)\n                    .play_jump_sound(),\n                _state: Jumping {},\n            }\n        }\n```", "```rs\nfn create_track_source(ctx: &AudioContext, buffer: &AudioBuffer) -> Result<AudioBufferSourceNode> {\n    let track_source = create_buffer_source(ctx)?;\n    track_source.set_buffer(Some(&buffer));\n    connect_with_audio_node(&track_source, \n        &ctx.destination())?;\n    Ok(track_source)\n}\npub enum LOOPING {\n    NO,\n    YES,\n}\npub fn play_sound(ctx: &AudioContext, buffer: &AudioBuffer, looping: LOOPING) -> Result<()> {\n    let track_source = create_track_source(ctx, buffer)?;\n    if matches!(looping, LOOPING::YES) {\n        track_source.set_loop(true);\n    }\n    track_source\n        .start()\n        .map_err(|err| anyhow!(\"Could not start sound! \n            {:#?}\", err))\n}\n```", "```rs\nplay_sound(ctx, buffer, LOOPING::YES)\nplay_sound(ctx, buffer, true)\n```", "```rs\nimpl Audio {\n    ...\n    pub fn play_sound(&self, sound: &Sound) -> Result<()> {\n        sound::play_sound(&self.context, &sound.buffer, \n            sound::LOOPING::NO)\n    }\n```", "```rs\nimpl Audio {\n    ...\n    pub fn play_looping_sound(&self, sound: &Sound) -> \n        Result<()> {\n        sound::play_sound(&self.context, &sound.buffer, \n            sound::LOOPING::YES)\n    }\n}\n```", "```rs\n#[async_trait(?Send)]\nimpl Game for WalkTheDog {\n    async fn initialize(&mut self) -> Result<Box<dyn Game>> {\n        match self {\n            WalkTheDog::Loading => {\n                ...\n                let audio = Audio::new()?;\n                let sound = audio.load_sound\n                    (\"SFX_Jump_23.mp3\").await?;\n                let background_music = audio.load_sound\n                    (\"background_song.mp3\").await?;\n                    audio.play_looping_sound\n                        (&background_music)?;\n                let rhb = RedHatBoy::new(\n                    sheet,\n                    engine::load_image(\"rhb.png\").await?,\n                    audio,\n                    sound,\n                );\n                ...\n```"]