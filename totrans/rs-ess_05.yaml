- en: Chapter 5. Generalizing Code with Higher-order Functions and Parametrization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用高阶函数和参数化泛化代码
- en: 'Now that we have the data structures and control constructs in place, we can
    start to discover the functional and object-oriented features of Rust, which make
    it a really expressive language. We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了数据结构和控制结构，我们可以开始探索 Rust 的函数式和面向对象特性，这使得它成为一种真正表达性的语言。在本章中，我们将涵盖以下主题：
- en: Higher-order functions and closures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数和闭包
- en: Iterators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Consumers and adapters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者和适配器
- en: Generic data structures and functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型数据结构和函数
- en: Error handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Methods on structs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体上的方法
- en: Traits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特质
- en: Using trait constraints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特质约束
- en: Built-in traits and operator overloading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置特质和运算符重载
- en: Higher-order functions and closures
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数和闭包
- en: 'By now, we know how to use functions, as shown in the following example where
    the `triples` function changes our `strength`, but only if the return value of
    `triples` is assigned to `strength`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何使用函数，如下面的示例所示，其中 `triples` 函数改变了我们的 `strength`，但只有当 `triples` 的返回值赋给
    `strength` 时：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With `triples` defined as `fn triples(s: i32) -> i32 { 3 * s }`, `s` represents
    strength.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '将 `triples` 定义为 `fn triples(s: i32) -> i32 { 3 * s }`，`s` 代表力量。'
- en: 'Suppose our player smashes an amazing power stone so that his strength is tripled
    and the resulting strength is tripled again, so we could write `triples(triples(s))`.
    We can also write a function to do this, but it would be even more general to
    have a function, let''s call it again, that could apply a certain function `f`,
    of the `F` type upon its result, enabling us to create all kinds of new game tricks,
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的玩家砸碎了一块惊人的力量宝石，使得他的力量翻倍，并且结果的力量再次翻倍，因此我们可以写 `triples(triples(s))`。我们也可以写一个函数来做这件事，但有一个更通用的函数，让我们称它为
    `again`，它可以在其结果上应用某种函数 `f`，`F` 类型，使我们能够创建各种新的游戏技巧，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, this is not enough information for Rust; the compiler will ask us
    to explain what the `F` type is. We can make this clear by adding `<F: Fn(i32)
    -> i32>` before the parameter list:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这还不够信息给 Rust；编译器会要求我们解释 `F` 类型是什么。我们可以在参数列表之前添加 `<F: Fn(i32) -> i32>` 来使这一点明确：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The expression between `< >` (angle brackets) tells us that `F` is a function,
    `Fn` ,that takes `i32` as a parameter and returns an `i32` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`< >`（尖括号）之间的表达式告诉我们 `F` 是一个函数，`Fn`，它接受 `i32` 作为参数并返回一个 `i32` 函数。'
- en: 'Now look at the definition of triples. that''s exactly what this function does
    (triples has the signature of type `F`), so we can call again with triples as
    the first parameter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 `triples` 的定义。这正是这个函数所做的（`triples` 有 `F` 类型的签名），因此我们可以再次调用，将 `triples`
    作为第一个参数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `again` function is a *higher-order function*, which means that it is a
    function that takes another function (or more than one function) as a parameter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`again` 函数是一个 *高阶函数*，这意味着它是一个接受另一个函数（或多个函数）作为参数的函数。'
- en: 'Often, simple functions such as `triples` are not even defined as a named function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像 `triples` 这样的简单函数甚至没有定义为命名函数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have an *anonymous function* or *closure*, `|n| { 3 * n }`, that takes
    an `n` parameter and returns its tripled value. The `||` (vertical bars) mark
    the start of a closure, and they contain the parameters that are passed to it
    (when there are no parameters, it is written as `||`). There is no need to indicate
    the type of the parameters or the return value as a closure can infer their types
    from the context in which it is called.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个 *匿名函数* 或 *闭包*，`|n| { 3 * n }`，它接受一个 `n` 参数并返回其三倍值。`||`（竖线）标记闭包的开始，它们包含传递给它的参数（当没有参数时，它写作
    `||`）。没有必要指出参数的类型或返回值，因为闭包可以从其被调用的上下文中推断它们的类型。
- en: 'The `triples` function is only a binding to a name so that we can refer to
    the closure in another code. We can even leave that name out and put the closure
    inline, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`triples` 函数仅是一个对名称的绑定，这样我们就可以在另一段代码中引用闭包。我们甚至可以省略那个名称，将闭包内联，如下所示：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The closure is called with the `n` parameter that takes the value of `s`, which
    is a copy of `strength`. The braces can also be left out to simplify the closure
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包使用 `n` 参数调用，该参数的值为 `s`，它是 `strength` 的一个副本。大括号也可以省略，以简化闭包如下：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, why is it called a closure? This becomes more apparent in the following
    example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么它被称为闭包？这在以下示例中变得更加明显：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `print_add()closure` has one argument and returns a 32-bit integer. The
    `print_add` closure knows the value of `x` and all other variables that are available
    in its surrounding scope—it *closes* them in. A closure with no arguments has
    the empty parameter list, `||`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_add()` 闭包有一个参数并返回一个 32 位整数。`print_add` 闭包知道 `x` 的值以及在其周围作用域中可用的所有其他变量——它将它们“封闭”起来。没有参数的闭包有一个空参数列表，`||`。'
- en: There is also a special kind of closure called a moving closure, which is indicated
    by the `move` keyword. A normal closure only needs a reference to the variables
    that it encloses, but a moving closure takes ownership of all the enclosing variables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种特殊的闭包称为移动闭包，它由 `move` 关键字指示。一个普通的闭包只需要对其封装的变量的引用，但移动闭包会获取所有封装变量的所有权。
- en: 'The preceding example would be written with a moving closure as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子将使用移动闭包如下编写：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Moving closures are mostly used when a program works with different concurrent
    threads (You can see this in [Chapter 8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency
    and Parallelism"), *Concurrency and Parallelism*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '移动闭包主要用于程序与不同的并发线程一起工作时（你可以在 [第 8 章](part0065.xhtml#aid-1TVKI2 "第 8 章。并发和并行")
    的 *并发和并行* 中看到这一点）。 '
- en: As you will see in the following sections, higher-order functions and closures
    are used throughout Rust because they can make code much more concise and readable,
    and they are useful to generalize a computation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在以下章节中看到的那样，Rust 中广泛使用高阶函数和闭包，因为它们可以使代码更加简洁和易读，并且它们对于泛化计算非常有用。
- en: Iterators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'An `Iterator` is an object that returns the items of a collection in sequence,
    from the first item to the last one. To return the following item, it uses a `next()`
    method. Here, we have an opportunity to use `Option`: because an iterator can
    have no more values at a certain `next()` call, `next()` returns `Option`: a `Some(value)`
    when there is a value, and `None` when there are no more values.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` 是一个对象，它按顺序返回集合中的项目，从第一个项目到最后一个项目。为了返回下一个项目，它使用 `next()` 方法。在这里，我们有使用
    `Option` 的机会：因为迭代器在某个 `next()` 调用可能没有更多值，所以 `next()` 返回 `Option`：当有值时返回 `Some(value)`，当没有更多值时返回
    `None`。'
- en: 'The simplest object that has this behavior is a range of numbers, `0...n`.
    Every time we used a `for` loop, such as for `i` in `0...n`, the underlying iterator
    mechanism was put to work. Let''s see an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种行为的简单对象是一个数字范围，`0...n`。每次我们使用 `for` 循环，例如 `for i in 0...n`，底层的迭代器机制就会被激活。让我们看一个例子：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we see `next()` at work, which produces 0, 1, and so on; the `for` loop
    continues until the end.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `next()` 在工作，它产生 0、1 等等；`for` 循环继续到结束。
- en: 'Perform the following exercise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 进行以下练习：
- en: In the previous example, we saw that `next()` returns a `Some` object, a variant
    of the `Option` type (see the *Result and Option* section of [Chapter 4](part0038.xhtml#aid-147LC2
    "Chapter 4. Structuring Data and Matching Patterns"), *Structuring Data and Matching
    Patterns*). Write an endless loop over `rng` with `next()` and see what happens.
    How would you break the endless loop? Use a match on the `Option` value. (for
    an example, see `Chapter 5/exercises/range_next.rs`). In fact, the `for` loop
    that we saw right before this exercise is syntactic sugar for this `loop – match`
    construct.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到 `next()` 返回一个 `Some` 对象，这是 `Option` 类型的变体（参见 [第 4 章](part0038.xhtml#aid-147LC2
    "第 4 章。结构化数据和匹配模式") 的 *结果和 Option* 部分，*结构化数据和匹配模式*）。使用 `next()` 在 `rng` 上编写一个无限循环，看看会发生什么。你将如何打破无限循环？使用
    `Option` 值上的 `match`。 （例如，请参阅 `Chapter 5/exercises/range_next.rs`）。实际上，我们在这个练习之前看到的
    `for` 循环是这个 `loop – match` 构造的语法糖。
- en: 'Iterators are also the preferred way to loop over arrays or slices. Let''s
    revisit the aliens array, `let aliens = ["Cherfer", "Fynock", "Shirack", "Zuxu"];"`,
    from [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring Data and Matching
    Patterns"), *Structuring Data and Matching Patterns*. Instead of using the index
    to show all the items one by one, let''s do it the iterator way with the `iter()`
    function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器也是遍历数组或切片的首选方式。让我们回顾一下来自 [第 4 章](part0038.xhtml#aid-147LC2 "第 4 章。结构化数据和匹配模式")
    的外星人数组，`let aliens = ["Cherfer", "Fynock", "Shirack", "Zuxu"];`，*结构化数据和匹配模式*。而不是使用索引逐个显示所有项目，让我们使用
    `iter()` 函数以迭代器的方式来做：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Which prints out: `Cherfer / Fynock / Shirack / Zuxu /`. The alien variable
    is of the `&str` type, which is a reference to each of the items in turn. (Technically,
    it is of the `&&str` type here because the items themselves are of the `&str`
    type, but this is not relevant to the point being made here.) This is much more
    performant and safe because Rust doesn''t have to do index-bounds checking, we''re
    always certain to move within the memory of the array.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出：`Cherfer / Fynock / Shirack / Zuxu /`。外星变量是`&str`类型，它依次引用每个项目。（技术上，这里它是`&&str`类型，因为项目本身是`&str`类型，但这与这里要说明的点无关。）这要高效得多，也更安全，因为Rust不需要进行索引边界检查，我们总是确定在数组的内存中移动。
- en: 'An even shorter way is to write:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更短的方法是写：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An alien array is also of the `&str` type, but the `print!` macro automatically
    dereferences this. If you want them to print out in the reverse order, do `aliens.iter().rev()`.
    The other iterators that we encountered in the previous chapter were the `chars()`
    and `split()` methods on `Strings`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 外星数组也是`&str`类型，但`print!`宏会自动解引用。如果你想按相反的顺序打印它们，请使用`aliens.iter().rev()`。我们在上一章中遇到的其它迭代器是`Strings`上的`chars()`和`split()`方法。
- en: 'Iterators are lazy by nature; they do not generate values unless asked, and
    we ask them by calling the `next()` method or applying `for` in the loop. This
    makes sense as we don''t want to allocate one million integers in the following
    binding:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器天生是惰性的；除非被询问，否则不会生成值，我们通过调用`next()`方法或在循环中应用`for`来询问它们。这很有意义，因为我们不希望在以下绑定中分配一百万个整数：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We want to allocate memory only when we need it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在我们需要的时候分配内存。
- en: Consumers and adapters
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者和适配器
- en: 'Now, we will see some examples that show why iterators are so useful. Iterators
    are lazy and have to be activated by invoking a *consumer* to start using the
    values. Let''s start with a range of the numbers from 0 to 999\. To make this
    into a vector, we apply the `collect()` consumer:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到一些示例，说明为什么迭代器如此有用。迭代器是惰性的，必须通过调用一个*消费者*来激活以开始使用值。让我们从0到999的数字范围开始。为了将其转换为向量，我们应用`collect()`消费者：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Which prints out the range (we shortened the output with ...): [0, 1, 2, 3,
    4, ... , 999]'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出范围（我们用...缩短了输出）：[0, 1, 2, 3, 4, ... , 999]
- en: 'The `collect()` loops through the entire iterator and collects all of the elements
    into a container, here in the `Vec<i32>` type. That container does not have to
    be an iterator. Notice that we indicate the item type of the vector with `Vec<i32>`,
    but we could have also written it as `Vec<_>`. The `collect::<Vec<i32>>()` notation
    is new; it indicates that collect is a parametrized method that can work with
    generic types, as you will see in the next section. That line could also have
    been written as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect()`遍历整个迭代器，并将所有元素收集到一个容器中，这里在`Vec<i32>`类型中。这个容器不必是迭代器。注意，我们用`Vec<i32>`表示向量的项目类型，但我们也可以写成`Vec<_>`。`collect::<Vec<i32>>()`的表示法是新的；它表示`collect`是一个参数化方法，可以与泛型类型一起工作，正如你将在下一节中看到的。这一行也可以写成：'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `find()` consumer gets the first value of the iterator that makes its condition
    (here, `>= 42`) true and returns it as an `Option` function, for example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()`消费者获取迭代器中第一个满足其条件（这里，`>= 42`）的值，并将其作为`Option`函数返回，例如：'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The value of `find` is an `Option` function because the condition could be false
    for all items and then it would return a `None` value. The condition is wrapped
    in a `|n| *n >= 42` closure, which is applied on every item of the iterator through
    an `n` reference; this is why we have to dereference `*n` to get the value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`的值是一个`Option`函数，因为条件可能对所有项目都为假，然后它将返回一个`None`值。条件被包裹在一个`|n| *n >= 42`闭包中，该闭包通过一个`n`引用应用于迭代器的每个项目；这就是为什么我们必须解引用`*n`来获取值。'
- en: 'Suppose we only want even numbers in our range, producing a new range by testing
    a closure condition on each item. This can be done with the `filter()` function,
    which is an adapter because it produces a new iterator from the old one. Its result
    can be collected just like any iterator:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想在我们的范围内有偶数，通过在每个项目上测试闭包条件来生成一个新的范围。这可以通过`filter()`函数来完成，它是一个适配器，因为它从旧迭代器生成一个新的迭代器。它的结果可以像任何迭代器一样收集：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `is_even` is the following function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`is_even`是以下函数：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This prints out: `[0, 2, 4, ..., 996, 998]` showing that odd integers are filtered
    out.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印出：`[0, 2, 4, ..., 996, 998]`，这表明奇数被过滤掉了。
- en: Notice how we can chain our consumers/adapters by just applying `collect()`
    on the result of `filter()` with `.collect()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何只需在`filter()`的结果上应用`.collect()`就能链式调用我们的消费者/适配器。
- en: 'Now, what would we do if we wanted to cube `(n * n * n)` with every item in
    the resulting iterator? We can produce a new range by applying a closure to each
    item in it with the `map()` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想对结果迭代器中的每个项进行立方运算`(n * n * n)`，我们会怎么做？我们可以通过使用`map()`函数将闭包应用于每个项来生成一个新的范围：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Which now prints out: `[0, 8, 64, ..., 988047936, 994011992]`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打印出：`[0, 8, 64, ..., 988047936, 994011992]`。
- en: If you only want the first five results, insert a `take(5)` adapter before the
    `collect` function. The resulting vector will then contain `[0, 8, 64, 216, 512]`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取前五个结果，请在`collect`函数之前插入一个`take(5)`适配器。结果向量将包含`[0, 8, 64, 216, 512]`。
- en: 'So, if you see the warning, `unused result which must be used: iterator adaptors
    are lazy and do nothing unless consumed message while compiling`, you know what
    to do—call a consumer!'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在编译时看到警告`未使用的必须使用的结果：迭代适配器是惰性的，除非被消费不会做任何事情`，你就知道该怎么做——调用一个消费者！
- en: To see all the consumers and adapters, consult the documentation of the `std::iter`
    module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有消费者和适配器，请查阅`std::iter`模块的文档。
- en: 'Perform the following exercise:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: 'Another very powerful consumer is the `fold()` function. The following example
    calculates the sum of the first hundred integers. It starts with a base value
    0, which is also the initial value of the sum accumulator, and then iterates and
    adds every `n` item to sum:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常强大的消费者是`fold()`函数。以下示例计算前一百个整数的和。它从一个基值0开始，这也是求和累加器的初始值，然后迭代并添加每个`n`项到和中：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, calculate the product of all the cubes of the integers in the range from
    1 to 6\. The result should be 1,728,000, but look out for the base value! As the
    second exercise, subtract all the items from the `[1, 9, 2, 3, 14, 12]` array,
    starting from 0 (that is, 0, 1, 9, 2, and so on). This should result in `41`.
    (As a hint, remember that an iterator item is a reference; for some example code,
    refer to `Chapter 5/exercises/fold.rs`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，计算从1到6的整数的所有立方的乘积。结果应该是1,728,000，但要注意基值！作为第二个练习，从`[1, 9, 2, 3, 14, 12]`数组中减去所有项，从0开始（即0,
    1, 9, 2，以此类推）。这将得到`41`。（作为一个提示，记住迭代器项是一个引用；对于一些示例代码，请参阅`第5章/练习/fold.rs`）。
- en: Generic data structures and functions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型数据结构和函数
- en: Genericity is the capacity to write code once, without or partly specified types,
    so that the code can be used for many different types. Rust has this capacity
    in abundance and applies it for both data structures and functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是编写一次代码的能力，无需或部分指定类型，以便代码可以用于许多不同的类型。Rust具有丰富的这种能力，并将其应用于数据结构和函数。
- en: A composite data structure is generic if the type of its items can be of a general
    `<T>` type. `T` can be an `i32`, an `f64`, a `String`, or a `struct` type such
    as `Person` that we coded ourselves. So, we can have not only `Vec<f64>` but also
    `Vec<Person>`. If you make `T` a concrete type, then you must substitute `T` with
    that type everywhere `T` appears in the definition of the data structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个复合数据结构的项的类型可以是通用的`<T>`类型，则该数据结构是泛型的。`T`可以是`i32`、`f64`、`String`或我们自定义的`Person`等结构体类型。因此，我们不仅可以有`Vec<f64>`，还可以有`Vec<Person>`。如果你将`T`指定为具体类型，那么你必须将数据结构定义中所有出现的`T`替换为该类型。
- en: Our data structure can be parametrized with a generic `<T>` type, so it has
    multiple concrete definitions—it is polymorphic. Rust makes extensive use of this
    concept, which we already encountered in [Chapter 4](part0038.xhtml#aid-147LC2
    "Chapter 4. Structuring Data and Matching Patterns"), *Structuring Data and Matching
    Patterns* when we talked about arrays, vectors, slices, and the `Result` and `Option`
    types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据结构可以用泛型`<T>`类型参数化，因此它有多个具体定义——它是多态的。Rust广泛使用这一概念，我们在[第4章](part0038.xhtml#aid-147LC2
    "第4章。结构化数据和模式匹配")中已经遇到过，当我们讨论数组、向量、切片以及`Result`和`Option`类型时，我们称之为“结构化数据和模式匹配”。
- en: 'Suppose you want to define a struct with two fields, first and second, but
    you want to keep the type of these fields generic. We can define this as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想定义一个具有两个字段的结构体，第一个和第二个，但你希望保持这些字段的类型泛型。我们可以这样定义：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now define a pair of magic numbers, or a pair of magicians, or whatever
    we want, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义一对魔法数字，或一对魔术师，或我们想要的任何东西，如下所示：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What if we wanted to write functions that work with generic data structures?
    They would also have to be generic, right? As a simple example, how would we write
    a function that returns the second item of a pair? We can do it as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要编写与泛型数据结构一起工作的函数，它们也必须是泛型的，对吧？作为一个简单的例子，我们如何编写一个返回一对中第二个元素的函数？我们可以这样做：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We could call it as `let a = second(magic_pair);` producing `42`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其调用为`let a = second(magic_pair);`，产生`42`。
- en: Note the `<T>` character right after the function name; this is how generic
    functions are declared.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数名后面的`<T>`字符；这就是泛型函数的声明方式。
- en: 'Let''s now investigate why `Option` and `Result` are so powerful. Here is the
    definition of the `Option` type again:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨为什么`Option`和`Result`如此强大。再次给出`Option`类型的定义：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From this, we can define multiple concrete types as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以定义多个具体类型如下：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the type does not correspond with the value, a mismatched types error
    occurs, similar to that in `let magic: Option<f32> = Some(42)`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '当类型与值不匹配时，会发生类型不匹配错误，类似于在`let magic: Option<f32> = Some(42)`中使用的`Option`。'
- en: 'We can define a `Person` struct as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个`Person`结构体如下：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also define a few `Person` objects as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义几个`Person`对象如下：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, using these, we can make `Option` or a vector for `Person`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这些对象，我们可以为`Person`创建`Option`或向量：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You should use the `Option` type in a situation where you expect to get a value,
    but there is a possibility that no value will be given. A typical scenario would
    be user input.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在你期望得到一个值，但有可能不会得到值的情况下，你应该使用`Option`类型。一个典型的场景是用户输入。
- en: 'Somewhat related is the `Result` type that we first encountered in the *Result
    and Option* section of [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring
    Data and Matching Patterns"), *Structuring Data and Matching Patterns*. This is
    used when a computation should return a result, but it can also return an error
    if something goes wrong. Result is defined with two generic types—`T` and `E`—as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相关的是我们在第4章的“结果和选项”部分首次遇到的`Result`类型，即[第4章](part0038.xhtml#aid-147LC2 "第4章.
    结构化数据与模式匹配")中的“结构化数据与模式匹配”。当计算应该返回一个结果时，可以使用它，但如果出现错误，它也可以返回一个错误。`Result`是通过以下两个泛型类型——`T`和`E`——定义的：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It again shows Rust's commitment to be on the safe side; if it's `Ok`, it will
    give back a value of the `T` type, if there is a problem, then it will give back
    the error that will be a value of the `E` type (which is usually an error message
    string). So, we could read them also as `Ok(what)` and `Err(why)`, where `what`
    has the `T` type and `why` has the `E` type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次显示了Rust对安全性的承诺；如果它是`Ok`，它将返回一个`T`类型的值，如果存在问题，则返回一个`E`类型的错误（这通常是一个错误消息字符串）。因此，我们也可以将它们读作`Ok(what)`和`Err(why)`，其中`what`具有`T`类型，而`why`具有`E`类型。
- en: 'So, why are Option and Result killer features of Rust? Remember from [Chapter
    4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring Data and Matching Patterns"),
    *Structuring Data and Matching Patterns* in the section *Result and Option* how
    we used `Option` when getting a number input? Here, it is given again:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么`Option`和`Result`是Rust的杀手级特性呢？记得从[第4章](part0038.xhtml#aid-147LC2 "第4章.
    结构化数据与模式匹配")中的“结果和选项”部分，在*结构化数据与模式匹配*节中，我们是如何在获取数字输入时使用`Option`的？这里再次给出：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In other languages such as Java or C#, parsing the input to a number could result
    in an exception (when the input contains non-numeric characters or when it has
    nothing or null), and you would have to use a resource heavy `try/catch` to construct
    to deal with it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言，如Java或C#中，将输入解析为数字可能会导致异常（当输入包含非数字字符或为空或null时），你将不得不使用资源密集型的`try/catch`来处理它。
- en: 'In Rust, the result of `parse()` is a Result, and we just test the `Result`
    return value with a `match`, which is a much simpler mechanism:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，`parse()`的结果是一个`Result`，我们只需使用`match`来测试`Result`的返回值，这是一个更简单的机制：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is another example of how we can use `Result` to return an error condition.
    We calculate the square root of a floating point number with the `std::num::Float::sqrt()`
    function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个如何使用`Result`返回错误条件的例子。我们使用`std::num::Float::sqrt()`函数计算浮点数的平方根：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We guard against taking the square root of a negative number (which would give
    NaN short for Not a Number) by returning an `Err` value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过返回一个`Err`值来防止对负数取平方根（这将给出NaN，即“不是一个数字”）。
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This prints out: `The square root of 42 is 6.480741`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出：“42的平方根是6.480741”。
- en: 'In the calling code, we use our trusted pattern match mechanism to distinguish
    between the two cases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用代码中，我们使用我们信任的模式匹配机制来区分这两种情况：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With `let m = sqroot(-5.0);`, the error message is printed as `Number cannot
    be negative!`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let m = sqroot(-5.0);`时，错误消息会打印为“数字不能为负！”。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of match for both `Option` and `Result` values ensures that no null
    values or errors can propagate through your code, which leaves no room for null
    pointer runtime errors or other exceptions to crash your program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Option`和`Result`值，使用`match`可以确保没有空值或错误可以在你的代码中传播，这避免了空指针运行时错误或其他异常导致程序崩溃。
- en: Error handling
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'A Rust program must be maximally prepared to handle unforeseen errors, but
    unexpected things can always happen, such as the division of an integer by zero:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Rust程序必须尽可能准备好处理未预见的错误，但意外的事情总是可能发生的，比如整数除以零：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When this happens, the program stops with the following message: `thread ''<main>''
    panicked at ''attempted to divide by zero''`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，程序会停止并显示以下消息：“`<main>`线程恐慌于'尝试除以零'”。
- en: Panics
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潘克
- en: 'A situation could occur that is so bad (like when dividing by zero) that it
    is no longer useful to continue running the program, that is, we cannot recover
    from the error. In this case, we can invoke the `panic!("message")` macro, which
    will release all the resources owned by the thread, report the message, and then
    make the program exit. We could improve the previous code as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现一种非常糟糕的情况（比如除以零），以至于继续运行程序已经没有意义，也就是说，我们无法从错误中恢复。在这种情况下，我们可以调用`panic!("message")`宏，这将释放线程拥有的所有资源，报告消息，然后使程序退出。我们可以改进之前的代码如下：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `div` is the following function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`div`是以下函数：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A number of other macros such as the `assert!` family can also be used to signal
    such unwanted conditions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用许多其他宏，如`assert!`系列，来指示这种不受欢迎的条件：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the condition is not true, they result in a panic situation and exit. The
    error message that is given as the second parameter of `assert!` will be printed
    out if it is present, otherwise the general message, `assertion failed`, will
    be given. The `assert!` function is mostly useful to test for pre- and post-conditions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件不成立时，它们会导致恐慌情况并退出。如果`assert!`的第二个参数提供了错误消息，则会打印出来，否则会给出通用消息，“断言失败”。`assert!`函数主要用于测试前置和后置条件。
- en: 'Portions of code that would not be normally executed can contain the `unreachable!`
    macro, which will panic when it is executed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中那些通常不会被执行的部分可以包含`unreachable!`宏，当它被执行时会引发恐慌：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Failures
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败
- en: In most cases, we would like to attempt to recover from the error and let the
    program continue. Fortunately, we have already seen the basic handling techniques
    to do just this in the *Result and Option* section of [Chapter 4](part0038.xhtml#aid-147LC2
    "Chapter 4. Structuring Data and Matching Patterns"), *Structuring Data and Matching
    Patterns* and the *Generic data structures and functions* section of this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们希望尝试从错误中恢复并让程序继续运行。幸运的是，我们已经在[第4章](part0038.xhtml#aid-147LC2 "第4章。结构化数据和模式匹配")的“结果和选项”部分以及本章的“通用数据结构和函数”部分看到了处理这种错误的基本技术。
- en: The `Option<T>` enum can be used when we expect a value; at this point, a `Some(T)`
    enum is given and a `None` value is returned when there was no value or in case
    of failure. In this way, Rust forces *nothingness* to appear in a clear and syntactically
    identifiable form, leaving no room for null pointer runtime errors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们期望一个值时，可以使用`Option<T>`枚举；此时，如果存在值，则给出`Some(T)`枚举，如果没有值或发生失败，则返回`None`值。这样，Rust强制将“无”以清晰和语法上可识别的形式出现，避免了空指针运行时错误。
- en: The `Result<T, E>` enum can be used to return an `Ok(T)` value in the normal
    (success) case and an `Err(E)` value in the failure case, containing information
    about the error. In the examples in the previous section, we used Result to safely
    read a value from the keyboard and make a safe function to calculate the square
    root of a number.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result<T, E>`枚举可以在正常（成功）情况下返回`Ok(T)`值，在失败情况下返回`Err(E)`值，包含有关错误的信息。在前一节的示例中，我们使用了Result来安全地从键盘读取值并创建一个计算数字平方根的安全函数。'
- en: Methods on structs
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体上的方法
- en: Now, we'll see how Rust caters for more object-oriented developers who are used
    to the `object.method()` type of notation instead of `function(object)`. In Rust,
    we can define *methods* on a struct, which pretty much compares to the traditional
    `class` concept.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看 Rust 如何满足那些习惯于 `object.method()` 语法而不是 `function(object)` 的面向对象开发者。在
    Rust 中，我们可以在结构体上定义 *方法*，这基本上与传统概念中的 `class` 相当。
- en: 'Suppose we are building a game in which the action takes place on a planet
    in a distant solar system that is inhabited by hostile aliens. For this game,
    let''s define an `Alien` struct as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个游戏，游戏动作发生在遥远太阳系中的一个星球上，那里居住着敌对外星人。为了这个游戏，让我们定义一个 `Alien` 结构体如下：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, `health` is the alien''s condition, and `damage` is the amount your health
    is decreased when it attacks. We can make an alien as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`health` 是外星人的状态，而 `damage` 是当它攻击时你的健康减少的量。我们可以创建一个外星人如下：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `health` parameter cannot be more than `100`, but we cannot impose this
    constraint when we make a struct instance. The solution is to define a `new` method
    for aliens where we can test the value:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`health` 参数不能超过 `100`，但当我们创建结构体实例时，我们无法强制这个约束。解决方案是为外星人定义一个 `new` 方法，这样我们就可以测试这个值：'
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can then construct a new `Alien` array as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式构建一个新的 `Alien` 数组：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We define the `new` method (and all other methods) inside an `impl Alien` block,
    which is separate from the `Alien` struct definition. It returns an `Alien` object
    after all constraints have been applied. We call it on the `Alien` struct itself
    as `Alien::new()`. Since it is a *static method*, we don''t call it on an `Alien`
    instance. Such a new method closely resembles a constructor from object-oriented
    languages. The fact that it is called `new` is merely by convention since we could
    have called it `create()` or `give_birth()`. Another static method could be a
    warning that is given by all aliens:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `impl Alien` 块内部定义了 `new` 方法（以及所有其他方法），这个块与 `Alien` 结构体的定义是分开的。在应用了所有约束之后，它返回一个
    `Alien` 对象。我们通过 `Alien::new()` 在 `Alien` 结构体本身上调用它。由于它是一个 *静态方法*，所以我们不会在 `Alien`
    实例上调用它。这样一个新的方法与面向对象语言中的构造函数非常相似。之所以叫它 `new`，仅仅是因为惯例，因为我们本可以叫它 `create()` 或 `give_birth()`。另一个静态方法可以是所有外星人给出的警告：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This can be called as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以这样调用：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When a specific alien attacks, we can define a method for that alien as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个特定的外星人攻击时，我们可以为该外星人定义一个方法如下：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And call it on the alien `berserk` as follows: `berserk.attack();`. A reference
    to `berserk` (the `Alien` object on which the method is invoked) is passed as
    `&self` to the method. In fact, `self` is similar to the `self` in Python or this
    in Java or C#. An instance method always has `&self` as parameter, in contrast
    to a static method.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式在 alien `berserk` 上调用它：`berserk.attack();`。将 `berserk`（调用方法时所在的 `Alien`
    对象）的引用作为 `&self` 传递给方法。实际上，`self` 与 Python 中的 `self` 或 Java 或 C# 中的 `this` 类似。实例方法总是有
    `&self` 作为参数，与静态方法相对。
- en: 'Here, the object is passed immutably, but what if attacking you also lowers
    the alien''s own health? Let''s add a second attack method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象以不可变的方式传递，但如果攻击你也会降低外星人的健康值怎么办？让我们添加第二个攻击方法：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, Rust rejects this with two compiler errors. First, it says, `cannot
    assign to immutable field self.health`. We can remedy this by passing a mutable
    reference to `self` like this: `fn attack(&mut self)`. But now Rust complains,
    `duplicate definition of value ''attack''`. This means that Rust does not allow
    two methods with the same name; there is no method overloading in Rust. This is
    because of the way type inference works.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Rust 报错，指出有两个编译错误。首先，它说，`cannot assign to immutable field self.health`。我们可以通过像这样传递一个可变引用来解决这个问题：`fn
    attack(&mut self)`。但现在 Rust 抱怨，`duplicate definition of value 'attack'`。这意味着 Rust
    不允许有两个同名的方法；Rust 中没有方法重载。这是由于类型推断的工作方式造成的。
- en: 'By changing the name to `attack_and_suffer`, we get this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将名称改为 `attack_and_suffer`，我们得到以下内容：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After calling `berserk.attack_and_suffer(31);`, berserk's health is now 69 (where
    `31` is the number of damage points inflicted upon berserk by another attacking
    alien).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `berserk.attack_and_suffer(31);` 之后，berserk 的健康值现在是 69（其中 `31` 是另一个攻击外星人对
    berserk 造成的伤害点数）。
- en: No method overloading means that we can only define one new function (which
    is optional anyway). We could invent different names for our constructors, which
    is good from the point of view of code documentation. Otherwise, you could go
    for what is called the `Builder` pattern on which you can find more information
    at [http://doc.rust-lang.org/book/method-syntax.html#builder-pattern](http://doc.rust-lang.org/book/method-syntax.html#builder-pattern).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 没有方法重载意味着我们只能定义一个新函数（这本身也是可选的）。我们可以为我们的构造函数发明不同的名字，这在代码文档方面是好的。否则，你可以选择所谓的`Builder`模式，你可以在[http://doc.rust-lang.org/book/method-syntax.html#builder-pattern](http://doc.rust-lang.org/book/method-syntax.html#builder-pattern)找到更多信息。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, in Rust, methods can also be defined on tuples and enums.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Rust中，方法也可以定义在元组和枚举上。
- en: 'Perform the following exercise:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: 'Complex numbers such as 2 + 5i (i is the square root of -1) have a real part
    (here 2) and an imaginary part (5); both are floating point numbers. Define a
    `Complex` struct and some methods for it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 复数，如2 + 5i（i是-1的平方根），有一个实部（这里为2）和一个虚部（5）；两者都是浮点数。定义一个`Complex`结构体和一些方法：
- en: A `new` method to construct a complex number.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`new`方法来构造一个复数。
- en: A `to_string` method that prints a complex number such as 2 + 5i or 2 – 5i (As
    a hint, use the `format!` macro that works in the same way as `println!` but returns
    a `String`.)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`to_string`方法，用于打印复数，如2 + 5i或2 – 5i（作为一个提示，使用与`println!`相同方式的`format!`宏，但它返回一个`String`。）
- en: An `add` method to add two complex numbers; this is a new complex number where
    the real part is the sum of the real parts of the operands and the same is applicable
    for the imaginary part as well.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`add`方法来添加两个复数；这是一个新的复数，其实部是操作数的实部之和，同样适用于虚部。
- en: A `times_ten` method that changes the object itself by multiplying both parts
    by 10 (As a hint, think carefully about the method's argument.)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`times_ten`方法，通过将两部分都乘以10来改变对象本身（作为一个提示，仔细思考这个方法参数。）
- en: As a bonus, make an `abs` method that calculates the absolute value of a complex
    number. (go to [http://en.wikipedia.org/wiki/Absolute_value](http://en.wikipedia.org/wiki/Absolute_value).)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为额外奖励，创建一个`abs`方法，用于计算复数的绝对值。（请参阅[http://en.wikipedia.org/wiki/Absolute_value](http://en.wikipedia.org/wiki/Absolute_value)。）
- en: Now, test your methods! (for an example code, refer to `Chapter 5/exercises/complex.rs`.)
    Rust defines a `Complex` type in crate `num`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试你的方法！（有关示例代码，请参阅`第5章/练习/complex.rs`。）Rust在crate `num`中定义了一个`Complex`类型。
- en: Traits
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特质
- en: 'What if our game is really diversely populated? That is, besides aliens, we
    also have zombies and predators and, needless to say, they all want to attack.
    Can we abstract their common behavior into something they all share? Of course,
    in Rust, we say that they have a trait in common, which is analogous to an interface
    or a super class in other languages. Let''s call this trait `Monster` and because
    they all want to attack, the first version could be as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的游戏真的非常多样化呢？也就是说，除了外星人，我们还有僵尸和捕食者，不用说，他们都想攻击。我们能否将它们的共同行为抽象成它们都拥有的东西？当然，在Rust中，我们说它们有一个共同的特质，这类似于其他语言中的接口或超类。让我们称这个特质为`Monster`，因为它们都想攻击，第一个版本可以是这样的：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A trait only contains a description of methods, that is, their type declarations
    or signatures, but it has no real implementation. This is logical because zombies,
    predators, and aliens could each have their own method of attack. So, there is
    no body of code between `{}` after the function signature, but don't forget the
    `;` to close it off.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 特质只包含方法的描述，即它们的类型声明或签名，但它没有真正的实现。这是逻辑的，因为僵尸、捕食者和外星人可能各自有自己的攻击方法。所以，在函数签名之后的`{}`之间没有代码体，但不要忘记用`;`关闭它。
- en: 'When we want to implement the `Monster` trait for the `Alien` struct, we write
    the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为`Alien`结构体实现`Monster`特质时，我们编写以下代码：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we compile this, Rust throws the `not all trait items implemented, missing:
    ''attack''` error. This is nice because Rust reminds us which methods from a trait
    we have forgotten to implement. The following code would make it pass:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们编译这个程序时，Rust抛出`not all trait items implemented, missing: ''attack''`错误。这很好，因为Rust提醒我们哪些特质的函数我们忘记了实现。以下代码可以使其通过：'
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So, the trait implementation for a type must provide the real code, which will
    be executed when that method is called on an `Alien` object. If a Zombie attack
    is twice as bad, its `Monster` implementation could be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为类型实现的特性必须提供实际代码，该代码将在调用`Alien`对象上的该方法时执行。如果僵尸攻击是两倍糟糕，其`Monster`实现可能如下所示：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We could add other methods to our trait, such as a `new` method, a `noise`
    method, and an `attack_with_sound` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向特性添加其他方法，例如`new`方法、`noise`方法和`attack_with_sound`方法：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that in the `new` method, the resulting object is of the `Self` type, which
    becomes the `Alien` or `Zombie` implementer type in a real implementation of the
    trait.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`new`方法中，生成的对象是`Self`类型，在特性的实际实现中，它成为`Alien`或`Zombie`实现类型。
- en: The functions that appear in a trait are called methods. Methods differ from
    functions because they have `&self` as a parameter; this means that they have
    the object on which they are invoked as a parameter, for example, `fn noise(&self)
    -> &'static str`. When we call it with `zmb1.noise()`, the `zmb1` object becomes
    self.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在特性中的函数被称为方法。方法与函数的不同之处在于它们有`&self`作为参数；这意味着它们有被调用的对象作为参数，例如，`fn noise(&self)
    -> &'static str`。当我们用`zmb1.noise()`调用它时，`zmb1`对象成为self。
- en: A trait can provide default code for a method (similar to the `attack_with_sound`
    method here). The implementer type can choose to take this default code or override
    it with its own version. Code in a trait method can also call upon other methods
    in the trait with `self.method()`, similar to `attack_with_sound` where `self.noise()`
    is called.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 特性可以为方法提供默认代码（类似于这里的`attack_with_sound`方法）。实现类型可以选择采用此默认代码或用自己的版本覆盖它。特性方法中的代码也可以使用`self.method()`调用特性中的其他方法，类似于`attack_with_sound`，其中调用了`self.noise()`。
- en: 'The full implementation of the `Monster` trait for the `Zombie` type could
    then be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Zombie`类型，`Monster`特性的完整实现可能如下所示：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is a short fragment of our game scenario:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们游戏场景的一个简短片段：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It prints out: `Oh no, I hear: Aaargh!`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '它打印出：`Oh no, I hear: Aaargh!`'
- en: '`The Zombie bites! Your health lowers with 30 damage points.`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`The Zombie bites! Your health lowers with 30 damage points.`。'
- en: Traits are not limited to structs; they can be implemented on any type. A type
    can also implement many different traits. All the different implemented methods
    are compiled to a version that is specific for their type, so after compilation,
    there exists, for example, a new method for `Alien`, `Zombie`, and `Predator`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 特性不仅限于结构体；它们可以应用于任何类型。一个类型也可以实现多个不同的特性。所有实现的不同方法都被编译成针对它们类型的特定版本，因此编译后，例如，存在针对`Alien`、`Zombie`和`Predator`的新方法。
- en: 'Implementing all of the methods in a trait can be tedious work. For example,
    we probably want to be able to show our creatures in this way:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特性中的所有方法可能是繁琐的工作。例如，我们可能希望以这种方式显示我们的生物：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Unfortunately, this gives us `the trait ''core::fmt::Debug'' is not implemented
    for the type ''Zombie'' compiler` error. So, from the message, we can infer that
    this `{:?}` uses a `Debug` trait. If we look this up in the docs, we will find
    that we must implement an `fmt` method (specifying a way to format the object).
    However, the compiler once again helps us here; if we prefix our `Zombie` struct
    definition with the attribute `#[derive(Debug)]`, then a default code version
    is generated automatically:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这给我们带来了`the trait 'core::fmt::Debug' is not implemented for the type 'Zombie'
    compiler`错误。所以，从消息中，我们可以推断出这个`{:?}`使用了一个`Debug`特性。如果我们查看文档，我们会发现我们必须实现一个`fmt`方法（指定格式化对象的方式）。然而，编译器在这里又一次帮助我们；如果我们用属性`#[derive(Debug)]`前缀我们的`Zombie`结构定义，那么将自动生成默认代码版本：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `println!("{:?}", zmb1);` snippet now shows this: `Zombie { health: 75,
    damage: 15 }`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!("{:?}", zmb1);`片段现在显示为：`Zombie { health: 75, damage: 15 }`。'
- en: This also works for a whole list of other traits. (see the *Built-in traits
    and Operator Overloading* section in this chapter and [http://rustbyexample.com/trait/derive.html](http://rustbyexample.com/trait/derive.html).)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于一系列其他特性。（参见本章的*内置特性和运算符重载*部分和[http://rustbyexample.com/trait/derive.html](http://rustbyexample.com/trait/derive.html)。）
- en: Using trait constraints
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特性约束
- en: 'Back in the *Generic data structures and functions* section, we made a `sqroot`
    function to calculate the square root of a 32-bit floating point number:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在*泛型数据结构和函数*部分，我们创建了一个`sqroot`函数来计算32位浮点数的平方根：
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'What if we want to calculate the square root of an `f64` number? It would be
    very unpractical to make a different version for each type. The first attempt
    would be to just replace `f32` with a generic type `<T>`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想计算一个 `f64` 数字的平方根呢？为每种类型制作不同的版本将非常不实用。第一次尝试可能是将 `f32` 替换为泛型类型 `<T>`：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'However, Rust would not agree because it doesn''t know anything about `T`,
    and it will give multiple errors (`num` is an external library which is imported
    with `extern crate num`, see [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Organizing
    Code and Macros"), *Organizing Code and Macros*):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Rust 不会同意，因为它对 `T` 一无所知，并且会给出多个错误（`num` 是一个外部库，它通过 `extern crate num` 导入，请参阅第
    7 章 [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Organizing Code and Macros")，*组织代码和宏*）：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'All the traits that are missing are implemented by the `Float` trait. We can
    assert that `T` must implement this trait as `fn sqroot<T: num::traits::Float>`.
    This is called putting a trait constraint or a trait bound on the `T` type, and
    this ensures that the function can use all the methods of the specified trait.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '所缺少的所有特性都由 `Float` 特性实现。我们可以断言 `T` 必须实现此特性，作为 `fn sqroot<T: num::traits::Float>`。这被称为在
    `T` 类型上放置特性约束或特性界限，这确保了函数可以使用指定特性的所有方法。'
- en: 'To be as general as possible, we also use the special indicator for `0`, which
    exists in the `num::traits::Float` trait and is named `num::zero();` so, our function
    now becomes as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能通用，我们还使用了 `num::traits::Float` 特性中存在的特殊指示符 `0`，它被命名为 `num::zero();` 因此，我们的函数现在如下所示：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This works for both the following calls:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这对以下两个调用都适用：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This gives the output as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出如下：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'However, we will get an error if we try to call `sqroot` on an integer as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试如下调用 `sqroot` 在一个整数上，我们会得到一个错误：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We get an error, ``the trait `std::num::Float` is not implemented for the type
    `_` [E0277]``, because an integer is not a `Float` type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误，“`std::num::Float` 特性未在类型 `_` 上实现” [E0277]，因为整数不是 `Float` 类型。
- en: Our `sqroot` function is generic and works for any `Float` type. The compiler
    creates a different executable `sqroot` method for any type that it is supposed
    to work with—in this case, `f32` and `f64`. Rust applies this mechanism when a
    function call is polymorphic, that is, when a function can accept arguments of
    different type. This is called `static` dispatch and no runtime overhead is involved.
    This should be contrasted with how Java interfaces work where the dispatching
    is done dynamically at runtime by the Java Virtual Machine. However, Rust also
    has a form of dynamic dispatch; for more details on this, go to [http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html](http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `sqroot` 函数是泛型的，适用于任何 `Float` 类型。编译器为它应该与之一起工作的任何类型创建不同的可执行 `sqroot` 方法——在这种情况下，`f32`
    和 `f64`。当函数调用是多态的，即函数可以接受不同类型的参数时，Rust 应用此机制。这被称为 `静态` 分发，并且没有运行时开销。这应该与 Java
    接口的工作方式形成对比，其中分发是在运行时由 Java 虚拟机动态执行的。然而，Rust 也有动态分发的形式；有关更多详细信息，请参阅 [http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html](http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html)。
- en: 'Another way to write the same trait constraint is with a `where` clause as
    follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以另一种方式编写相同的特性约束是使用 `where` 子句，如下所示：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Why does this other form exist? Well, there can be more than one generic `T`
    and `U` types. In addition, each type can be constrained to multiple traits (which
    is indicated by a `+` between the traits) such as `Trait1`, `Trait2`, and so on,
    like in this fictitious example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么存在这种其他形式？嗯，可能存在多个泛型 `T` 和 `U` 类型。此外，每种类型都可以被约束到多个特性（特性之间用 `+` 连接），例如 `Trait1`、`Trait2`
    等等，就像在这个虚构的例子中：
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With the `where` syntax, this can be made much more readable as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `where` 语法，这可以更易于阅读，如下所示：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Perform the following exercise:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下练习：
- en: Define a `Draw` trait with a `draw` method. Define the `S1` struct type with
    an integer field and the `S2` struct type with a float field.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个具有 `draw` 方法的 `Draw` 特性。定义具有整数字段的 `S1` 结构体类型和具有浮点字段 `S2` 结构体类型。
- en: Implement the `Draw` trait for `S1` and `S2` (draw prints the values and is
    surrounded by ***).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `S1` 和 `S2` 实现特性 `Draw`（绘制打印值，并被 *** 所包围）。
- en: Make a generic `draw_object` function that takes any object that implements
    `Draw`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个泛型 `draw_object` 函数，它接受任何实现了 `Draw` 的对象。
- en: Test these! (see the example code in `Chapter 5/exercises/draw_trait.rs`)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这些！（请参阅第 5 章的示例代码 `exercises/draw_trait.rs`）
- en: Built-in traits and operator overloading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置特性和运算符重载
- en: 'The Rust standard library is packed with traits, which are used all over the
    place. For example, there are traits for:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 标准库中充满了特性，它们被广泛应用于各个地方。例如，有用于：
- en: Comparing objects (the `Eq` and `PartialEq` traits).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较对象（`Eq` 和 `PartialEq` 特性）。
- en: Ordering objects (the `Ord` and `PartialOrd` traits).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序对象（`Ord` 和 `PartialOrd` 特性）。
- en: Creating an empty object (the `Default` trait).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空对象（`Default` 特性）。
- en: Formatting a value using `{:?}` (the `Debug` trait, which defines a `fmt` method).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `{:?}` 格式化值（`Debug` 特性，它定义了一个 `fmt` 方法）。
- en: Copying an object (the `Clone` trait).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制一个对象（`Clone` 特性）。
- en: Adding objects (the `Add` trait, which defines an `add` method)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对象（`Add` 特性，它定义了一个 `add` 方法）
- en: Note
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `+` operator is just a nice way to use; `add: n + m` is the same as `n.add(m)`.
    So, if we implement the `Add` trait, we can use the `+` operator; this is called
    operator overloading. A lot of other traits can also be used to overload operators,
    such as `Sub(-)`, `Mul(*)`, `Deref (*v)`, `Index([])`, and so on.'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`+` 运算符只是使用的一个好方法；`add: n + m` 与 `n.add(m)` 相同。所以，如果我们实现了 `Add` 特性，我们就可以使用
    `+` 运算符；这被称为运算符重载。许多其他特性也可以用来重载运算符，例如 `Sub(-)`、`Mul(*)`、`Deref (*v)`、`Index([])`
    等等。'
- en: Freeing the resources of an object when it goes out of scope (the `Drop` trait
    in other words, the object has a destructor)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象超出作用域时释放对象资源（换句话说，`Drop` 特性，即对象有一个析构函数）
- en: In the *Iterators* section, we described how an iterator works and used it on
    ranges and arrays. In fact, iterator is also defined as a trait in Rust in `std::iter::Iterator`.
    From the docs for iterator (refer to [http://doc.rust-lang.org/core/iter/trait.Iterator.html](http://doc.rust-lang.org/core/iter/trait.Iterator.html)),
    we see that we only need to define the `next()` method, which advances the iterator
    to return the next value as an option. When `next()` is implemented for the type
    of your object, we can then use a `for in` loop to iterate over the object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *迭代器* 部分中，我们描述了迭代器的工作原理，并在范围和数组上使用了它。实际上，迭代器在 Rust 的 `std::iter::Iterator`
    中也被定义为一个特性。从迭代器的文档（参考 [http://doc.rust-lang.org/core/iter/trait.Iterator.html](http://doc.rust-lang.org/core/iter/trait.Iterator.html)）中，我们看到我们只需要定义
    `next()` 方法，该方法将迭代器向前推进以返回下一个值作为选项。当 `next()` 为你的对象类型实现时，我们就可以使用 `for in` 循环来遍历对象。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all kinds of techniques to make our code more flexible
    by using higher-order functions, closures, iterators, and generic types and functions.
    We then reviewed the basic error-handling mechanisms that make good use of generic
    types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了各种技术，通过使用高阶函数、闭包、迭代器和泛型类型和函数来使我们的代码更加灵活。然后我们回顾了利用泛型类型的基本错误处理机制。
- en: We also discovered the object-oriented nature of Rust, by defining methods on
    structs and implementing traits. Finally, we saw that traits are the structuring
    concept of Rust.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了 Rust 的面向对象特性，通过在结构体上定义方法和实现特性。最后，我们看到了特性是 Rust 的结构化概念。
- en: In the next chapter, we will expose the crown jewels of the Rust language, which
    form the foundation of its memory safety behavior.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将揭示 Rust 语言的瑰宝，这些瑰宝构成了其内存安全行为的基础。
