- en: Chapter 5. Generalizing Code with Higher-order Functions and Parametrization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the data structures and control constructs in place, we can
    start to discover the functional and object-oriented features of Rust, which make
    it a really expressive language. We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions and closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumers and adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic data structures and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods on structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using trait constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in traits and operator overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions and closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we know how to use functions, as shown in the following example where
    the `triples` function changes our `strength`, but only if the return value of
    `triples` is assigned to `strength`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With `triples` defined as `fn triples(s: i32) -> i32 { 3 * s }`, `s` represents
    strength.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose our player smashes an amazing power stone so that his strength is tripled
    and the resulting strength is tripled again, so we could write `triples(triples(s))`.
    We can also write a function to do this, but it would be even more general to
    have a function, let''s call it again, that could apply a certain function `f`,
    of the `F` type upon its result, enabling us to create all kinds of new game tricks,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not enough information for Rust; the compiler will ask us
    to explain what the `F` type is. We can make this clear by adding `<F: Fn(i32)
    -> i32>` before the parameter list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The expression between `< >` (angle brackets) tells us that `F` is a function,
    `Fn` ,that takes `i32` as a parameter and returns an `i32` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at the definition of triples. that''s exactly what this function does
    (triples has the signature of type `F`), so we can call again with triples as
    the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `again` function is a *higher-order function*, which means that it is a
    function that takes another function (or more than one function) as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, simple functions such as `triples` are not even defined as a named function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an *anonymous function* or *closure*, `|n| { 3 * n }`, that takes
    an `n` parameter and returns its tripled value. The `||` (vertical bars) mark
    the start of a closure, and they contain the parameters that are passed to it
    (when there are no parameters, it is written as `||`). There is no need to indicate
    the type of the parameters or the return value as a closure can infer their types
    from the context in which it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `triples` function is only a binding to a name so that we can refer to
    the closure in another code. We can even leave that name out and put the closure
    inline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The closure is called with the `n` parameter that takes the value of `s`, which
    is a copy of `strength`. The braces can also be left out to simplify the closure
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, why is it called a closure? This becomes more apparent in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `print_add()closure` has one argument and returns a 32-bit integer. The
    `print_add` closure knows the value of `x` and all other variables that are available
    in its surrounding scope—it *closes* them in. A closure with no arguments has
    the empty parameter list, `||`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a special kind of closure called a moving closure, which is indicated
    by the `move` keyword. A normal closure only needs a reference to the variables
    that it encloses, but a moving closure takes ownership of all the enclosing variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example would be written with a moving closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Moving closures are mostly used when a program works with different concurrent
    threads (You can see this in [Chapter 8](part0065.xhtml#aid-1TVKI2 "Chapter 8. Concurrency
    and Parallelism"), *Concurrency and Parallelism*).
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in the following sections, higher-order functions and closures
    are used throughout Rust because they can make code much more concise and readable,
    and they are useful to generalize a computation.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `Iterator` is an object that returns the items of a collection in sequence,
    from the first item to the last one. To return the following item, it uses a `next()`
    method. Here, we have an opportunity to use `Option`: because an iterator can
    have no more values at a certain `next()` call, `next()` returns `Option`: a `Some(value)`
    when there is a value, and `None` when there are no more values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest object that has this behavior is a range of numbers, `0...n`.
    Every time we used a `for` loop, such as for `i` in `0...n`, the underlying iterator
    mechanism was put to work. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see `next()` at work, which produces 0, 1, and so on; the `for` loop
    continues until the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we saw that `next()` returns a `Some` object, a variant
    of the `Option` type (see the *Result and Option* section of [Chapter 4](part0038.xhtml#aid-147LC2
    "Chapter 4. Structuring Data and Matching Patterns"), *Structuring Data and Matching
    Patterns*). Write an endless loop over `rng` with `next()` and see what happens.
    How would you break the endless loop? Use a match on the `Option` value. (for
    an example, see `Chapter 5/exercises/range_next.rs`). In fact, the `for` loop
    that we saw right before this exercise is syntactic sugar for this `loop – match`
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterators are also the preferred way to loop over arrays or slices. Let''s
    revisit the aliens array, `let aliens = ["Cherfer", "Fynock", "Shirack", "Zuxu"];"`,
    from [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring Data and Matching
    Patterns"), *Structuring Data and Matching Patterns*. Instead of using the index
    to show all the items one by one, let''s do it the iterator way with the `iter()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out: `Cherfer / Fynock / Shirack / Zuxu /`. The alien variable
    is of the `&str` type, which is a reference to each of the items in turn. (Technically,
    it is of the `&&str` type here because the items themselves are of the `&str`
    type, but this is not relevant to the point being made here.) This is much more
    performant and safe because Rust doesn''t have to do index-bounds checking, we''re
    always certain to move within the memory of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An even shorter way is to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: An alien array is also of the `&str` type, but the `print!` macro automatically
    dereferences this. If you want them to print out in the reverse order, do `aliens.iter().rev()`.
    The other iterators that we encountered in the previous chapter were the `chars()`
    and `split()` methods on `Strings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterators are lazy by nature; they do not generate values unless asked, and
    we ask them by calling the `next()` method or applying `for` in the loop. This
    makes sense as we don''t want to allocate one million integers in the following
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We want to allocate memory only when we need it.
  prefs: []
  type: TYPE_NORMAL
- en: Consumers and adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will see some examples that show why iterators are so useful. Iterators
    are lazy and have to be activated by invoking a *consumer* to start using the
    values. Let''s start with a range of the numbers from 0 to 999\. To make this
    into a vector, we apply the `collect()` consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints out the range (we shortened the output with ...): [0, 1, 2, 3,
    4, ... , 999]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `collect()` loops through the entire iterator and collects all of the elements
    into a container, here in the `Vec<i32>` type. That container does not have to
    be an iterator. Notice that we indicate the item type of the vector with `Vec<i32>`,
    but we could have also written it as `Vec<_>`. The `collect::<Vec<i32>>()` notation
    is new; it indicates that collect is a parametrized method that can work with
    generic types, as you will see in the next section. That line could also have
    been written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find()` consumer gets the first value of the iterator that makes its condition
    (here, `>= 42`) true and returns it as an `Option` function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The value of `find` is an `Option` function because the condition could be false
    for all items and then it would return a `None` value. The condition is wrapped
    in a `|n| *n >= 42` closure, which is applied on every item of the iterator through
    an `n` reference; this is why we have to dereference `*n` to get the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we only want even numbers in our range, producing a new range by testing
    a closure condition on each item. This can be done with the `filter()` function,
    which is an adapter because it produces a new iterator from the old one. Its result
    can be collected just like any iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `is_even` is the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out: `[0, 2, 4, ..., 996, 998]` showing that odd integers are filtered
    out.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we can chain our consumers/adapters by just applying `collect()`
    on the result of `filter()` with `.collect()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what would we do if we wanted to cube `(n * n * n)` with every item in
    the resulting iterator? We can produce a new range by applying a closure to each
    item in it with the `map()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Which now prints out: `[0, 8, 64, ..., 988047936, 994011992]`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you only want the first five results, insert a `take(5)` adapter before the
    `collect` function. The resulting vector will then contain `[0, 8, 64, 216, 512]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you see the warning, `unused result which must be used: iterator adaptors
    are lazy and do nothing unless consumed message while compiling`, you know what
    to do—call a consumer!'
  prefs: []
  type: TYPE_NORMAL
- en: To see all the consumers and adapters, consult the documentation of the `std::iter`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very powerful consumer is the `fold()` function. The following example
    calculates the sum of the first hundred integers. It starts with a base value
    0, which is also the initial value of the sum accumulator, and then iterates and
    adds every `n` item to sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, calculate the product of all the cubes of the integers in the range from
    1 to 6\. The result should be 1,728,000, but look out for the base value! As the
    second exercise, subtract all the items from the `[1, 9, 2, 3, 14, 12]` array,
    starting from 0 (that is, 0, 1, 9, 2, and so on). This should result in `41`.
    (As a hint, remember that an iterator item is a reference; for some example code,
    refer to `Chapter 5/exercises/fold.rs`).
  prefs: []
  type: TYPE_NORMAL
- en: Generic data structures and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Genericity is the capacity to write code once, without or partly specified types,
    so that the code can be used for many different types. Rust has this capacity
    in abundance and applies it for both data structures and functions.
  prefs: []
  type: TYPE_NORMAL
- en: A composite data structure is generic if the type of its items can be of a general
    `<T>` type. `T` can be an `i32`, an `f64`, a `String`, or a `struct` type such
    as `Person` that we coded ourselves. So, we can have not only `Vec<f64>` but also
    `Vec<Person>`. If you make `T` a concrete type, then you must substitute `T` with
    that type everywhere `T` appears in the definition of the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Our data structure can be parametrized with a generic `<T>` type, so it has
    multiple concrete definitions—it is polymorphic. Rust makes extensive use of this
    concept, which we already encountered in [Chapter 4](part0038.xhtml#aid-147LC2
    "Chapter 4. Structuring Data and Matching Patterns"), *Structuring Data and Matching
    Patterns* when we talked about arrays, vectors, slices, and the `Result` and `Option`
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to define a struct with two fields, first and second, but
    you want to keep the type of these fields generic. We can define this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a pair of magic numbers, or a pair of magicians, or whatever
    we want, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we wanted to write functions that work with generic data structures?
    They would also have to be generic, right? As a simple example, how would we write
    a function that returns the second item of a pair? We can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We could call it as `let a = second(magic_pair);` producing `42`.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `<T>` character right after the function name; this is how generic
    functions are declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now investigate why `Option` and `Result` are so powerful. Here is the
    definition of the `Option` type again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can define multiple concrete types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When the type does not correspond with the value, a mismatched types error
    occurs, similar to that in `let magic: Option<f32> = Some(42)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a `Person` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define a few `Person` objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using these, we can make `Option` or a vector for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You should use the `Option` type in a situation where you expect to get a value,
    but there is a possibility that no value will be given. A typical scenario would
    be user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhat related is the `Result` type that we first encountered in the *Result
    and Option* section of [Chapter 4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring
    Data and Matching Patterns"), *Structuring Data and Matching Patterns*. This is
    used when a computation should return a result, but it can also return an error
    if something goes wrong. Result is defined with two generic types—`T` and `E`—as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It again shows Rust's commitment to be on the safe side; if it's `Ok`, it will
    give back a value of the `T` type, if there is a problem, then it will give back
    the error that will be a value of the `E` type (which is usually an error message
    string). So, we could read them also as `Ok(what)` and `Err(why)`, where `what`
    has the `T` type and `why` has the `E` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why are Option and Result killer features of Rust? Remember from [Chapter
    4](part0038.xhtml#aid-147LC2 "Chapter 4. Structuring Data and Matching Patterns"),
    *Structuring Data and Matching Patterns* in the section *Result and Option* how
    we used `Option` when getting a number input? Here, it is given again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In other languages such as Java or C#, parsing the input to a number could result
    in an exception (when the input contains non-numeric characters or when it has
    nothing or null), and you would have to use a resource heavy `try/catch` to construct
    to deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, the result of `parse()` is a Result, and we just test the `Result`
    return value with a `match`, which is a much simpler mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of how we can use `Result` to return an error condition.
    We calculate the square root of a floating point number with the `std::num::Float::sqrt()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We guard against taking the square root of a negative number (which would give
    NaN short for Not a Number) by returning an `Err` value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out: `The square root of 42 is 6.480741`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the calling code, we use our trusted pattern match mechanism to distinguish
    between the two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With `let m = sqroot(-5.0);`, the error message is printed as `Number cannot
    be negative!`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of match for both `Option` and `Result` values ensures that no null
    values or errors can propagate through your code, which leaves no room for null
    pointer runtime errors or other exceptions to crash your program.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Rust program must be maximally prepared to handle unforeseen errors, but
    unexpected things can always happen, such as the division of an integer by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When this happens, the program stops with the following message: `thread ''<main>''
    panicked at ''attempted to divide by zero''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Panics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A situation could occur that is so bad (like when dividing by zero) that it
    is no longer useful to continue running the program, that is, we cannot recover
    from the error. In this case, we can invoke the `panic!("message")` macro, which
    will release all the resources owned by the thread, report the message, and then
    make the program exit. We could improve the previous code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `div` is the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A number of other macros such as the `assert!` family can also be used to signal
    such unwanted conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When the condition is not true, they result in a panic situation and exit. The
    error message that is given as the second parameter of `assert!` will be printed
    out if it is present, otherwise the general message, `assertion failed`, will
    be given. The `assert!` function is mostly useful to test for pre- and post-conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Portions of code that would not be normally executed can contain the `unreachable!`
    macro, which will panic when it is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, we would like to attempt to recover from the error and let the
    program continue. Fortunately, we have already seen the basic handling techniques
    to do just this in the *Result and Option* section of [Chapter 4](part0038.xhtml#aid-147LC2
    "Chapter 4. Structuring Data and Matching Patterns"), *Structuring Data and Matching
    Patterns* and the *Generic data structures and functions* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `Option<T>` enum can be used when we expect a value; at this point, a `Some(T)`
    enum is given and a `None` value is returned when there was no value or in case
    of failure. In this way, Rust forces *nothingness* to appear in a clear and syntactically
    identifiable form, leaving no room for null pointer runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `Result<T, E>` enum can be used to return an `Ok(T)` value in the normal
    (success) case and an `Err(E)` value in the failure case, containing information
    about the error. In the examples in the previous section, we used Result to safely
    read a value from the keyboard and make a safe function to calculate the square
    root of a number.
  prefs: []
  type: TYPE_NORMAL
- en: Methods on structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll see how Rust caters for more object-oriented developers who are used
    to the `object.method()` type of notation instead of `function(object)`. In Rust,
    we can define *methods* on a struct, which pretty much compares to the traditional
    `class` concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are building a game in which the action takes place on a planet
    in a distant solar system that is inhabited by hostile aliens. For this game,
    let''s define an `Alien` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `health` is the alien''s condition, and `damage` is the amount your health
    is decreased when it attacks. We can make an alien as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `health` parameter cannot be more than `100`, but we cannot impose this
    constraint when we make a struct instance. The solution is to define a `new` method
    for aliens where we can test the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then construct a new `Alien` array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `new` method (and all other methods) inside an `impl Alien` block,
    which is separate from the `Alien` struct definition. It returns an `Alien` object
    after all constraints have been applied. We call it on the `Alien` struct itself
    as `Alien::new()`. Since it is a *static method*, we don''t call it on an `Alien`
    instance. Such a new method closely resembles a constructor from object-oriented
    languages. The fact that it is called `new` is merely by convention since we could
    have called it `create()` or `give_birth()`. Another static method could be a
    warning that is given by all aliens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When a specific alien attacks, we can define a method for that alien as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And call it on the alien `berserk` as follows: `berserk.attack();`. A reference
    to `berserk` (the `Alien` object on which the method is invoked) is passed as
    `&self` to the method. In fact, `self` is similar to the `self` in Python or this
    in Java or C#. An instance method always has `&self` as parameter, in contrast
    to a static method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the object is passed immutably, but what if attacking you also lowers
    the alien''s own health? Let''s add a second attack method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Rust rejects this with two compiler errors. First, it says, `cannot
    assign to immutable field self.health`. We can remedy this by passing a mutable
    reference to `self` like this: `fn attack(&mut self)`. But now Rust complains,
    `duplicate definition of value ''attack''`. This means that Rust does not allow
    two methods with the same name; there is no method overloading in Rust. This is
    because of the way type inference works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing the name to `attack_and_suffer`, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After calling `berserk.attack_and_suffer(31);`, berserk's health is now 69 (where
    `31` is the number of damage points inflicted upon berserk by another attacking
    alien).
  prefs: []
  type: TYPE_NORMAL
- en: No method overloading means that we can only define one new function (which
    is optional anyway). We could invent different names for our constructors, which
    is good from the point of view of code documentation. Otherwise, you could go
    for what is called the `Builder` pattern on which you can find more information
    at [http://doc.rust-lang.org/book/method-syntax.html#builder-pattern](http://doc.rust-lang.org/book/method-syntax.html#builder-pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, in Rust, methods can also be defined on tuples and enums.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers such as 2 + 5i (i is the square root of -1) have a real part
    (here 2) and an imaginary part (5); both are floating point numbers. Define a
    `Complex` struct and some methods for it:'
  prefs: []
  type: TYPE_NORMAL
- en: A `new` method to construct a complex number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `to_string` method that prints a complex number such as 2 + 5i or 2 – 5i (As
    a hint, use the `format!` macro that works in the same way as `println!` but returns
    a `String`.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `add` method to add two complex numbers; this is a new complex number where
    the real part is the sum of the real parts of the operands and the same is applicable
    for the imaginary part as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `times_ten` method that changes the object itself by multiplying both parts
    by 10 (As a hint, think carefully about the method's argument.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a bonus, make an `abs` method that calculates the absolute value of a complex
    number. (go to [http://en.wikipedia.org/wiki/Absolute_value](http://en.wikipedia.org/wiki/Absolute_value).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, test your methods! (for an example code, refer to `Chapter 5/exercises/complex.rs`.)
    Rust defines a `Complex` type in crate `num`.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if our game is really diversely populated? That is, besides aliens, we
    also have zombies and predators and, needless to say, they all want to attack.
    Can we abstract their common behavior into something they all share? Of course,
    in Rust, we say that they have a trait in common, which is analogous to an interface
    or a super class in other languages. Let''s call this trait `Monster` and because
    they all want to attack, the first version could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A trait only contains a description of methods, that is, their type declarations
    or signatures, but it has no real implementation. This is logical because zombies,
    predators, and aliens could each have their own method of attack. So, there is
    no body of code between `{}` after the function signature, but don't forget the
    `;` to close it off.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to implement the `Monster` trait for the `Alien` struct, we write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile this, Rust throws the `not all trait items implemented, missing:
    ''attack''` error. This is nice because Rust reminds us which methods from a trait
    we have forgotten to implement. The following code would make it pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the trait implementation for a type must provide the real code, which will
    be executed when that method is called on an `Alien` object. If a Zombie attack
    is twice as bad, its `Monster` implementation could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We could add other methods to our trait, such as a `new` method, a `noise`
    method, and an `attack_with_sound` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the `new` method, the resulting object is of the `Self` type, which
    becomes the `Alien` or `Zombie` implementer type in a real implementation of the
    trait.
  prefs: []
  type: TYPE_NORMAL
- en: The functions that appear in a trait are called methods. Methods differ from
    functions because they have `&self` as a parameter; this means that they have
    the object on which they are invoked as a parameter, for example, `fn noise(&self)
    -> &'static str`. When we call it with `zmb1.noise()`, the `zmb1` object becomes
    self.
  prefs: []
  type: TYPE_NORMAL
- en: A trait can provide default code for a method (similar to the `attack_with_sound`
    method here). The implementer type can choose to take this default code or override
    it with its own version. Code in a trait method can also call upon other methods
    in the trait with `self.method()`, similar to `attack_with_sound` where `self.noise()`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full implementation of the `Monster` trait for the `Zombie` type could
    then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a short fragment of our game scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints out: `Oh no, I hear: Aaargh!`'
  prefs: []
  type: TYPE_NORMAL
- en: '`The Zombie bites! Your health lowers with 30 damage points.`'
  prefs: []
  type: TYPE_NORMAL
- en: Traits are not limited to structs; they can be implemented on any type. A type
    can also implement many different traits. All the different implemented methods
    are compiled to a version that is specific for their type, so after compilation,
    there exists, for example, a new method for `Alien`, `Zombie`, and `Predator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing all of the methods in a trait can be tedious work. For example,
    we probably want to be able to show our creatures in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this gives us `the trait ''core::fmt::Debug'' is not implemented
    for the type ''Zombie'' compiler` error. So, from the message, we can infer that
    this `{:?}` uses a `Debug` trait. If we look this up in the docs, we will find
    that we must implement an `fmt` method (specifying a way to format the object).
    However, the compiler once again helps us here; if we prefix our `Zombie` struct
    definition with the attribute `#[derive(Debug)]`, then a default code version
    is generated automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `println!("{:?}", zmb1);` snippet now shows this: `Zombie { health: 75,
    damage: 15 }`.'
  prefs: []
  type: TYPE_NORMAL
- en: This also works for a whole list of other traits. (see the *Built-in traits
    and Operator Overloading* section in this chapter and [http://rustbyexample.com/trait/derive.html](http://rustbyexample.com/trait/derive.html).)
  prefs: []
  type: TYPE_NORMAL
- en: Using trait constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in the *Generic data structures and functions* section, we made a `sqroot`
    function to calculate the square root of a 32-bit floating point number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to calculate the square root of an `f64` number? It would be
    very unpractical to make a different version for each type. The first attempt
    would be to just replace `f32` with a generic type `<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'However, Rust would not agree because it doesn''t know anything about `T`,
    and it will give multiple errors (`num` is an external library which is imported
    with `extern crate num`, see [Chapter 7](part0062.xhtml#aid-1R42S2 "Chapter 7. Organizing
    Code and Macros"), *Organizing Code and Macros*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'All the traits that are missing are implemented by the `Float` trait. We can
    assert that `T` must implement this trait as `fn sqroot<T: num::traits::Float>`.
    This is called putting a trait constraint or a trait bound on the `T` type, and
    this ensures that the function can use all the methods of the specified trait.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be as general as possible, we also use the special indicator for `0`, which
    exists in the `num::traits::Float` trait and is named `num::zero();` so, our function
    now becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for both the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we will get an error if we try to call `sqroot` on an integer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We get an error, ``the trait `std::num::Float` is not implemented for the type
    `_` [E0277]``, because an integer is not a `Float` type.
  prefs: []
  type: TYPE_NORMAL
- en: Our `sqroot` function is generic and works for any `Float` type. The compiler
    creates a different executable `sqroot` method for any type that it is supposed
    to work with—in this case, `f32` and `f64`. Rust applies this mechanism when a
    function call is polymorphic, that is, when a function can accept arguments of
    different type. This is called `static` dispatch and no runtime overhead is involved.
    This should be contrasted with how Java interfaces work where the dispatching
    is done dynamically at runtime by the Java Virtual Machine. However, Rust also
    has a form of dynamic dispatch; for more details on this, go to [http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html](http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to write the same trait constraint is with a `where` clause as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Why does this other form exist? Well, there can be more than one generic `T`
    and `U` types. In addition, each type can be constrained to multiple traits (which
    is indicated by a `+` between the traits) such as `Trait1`, `Trait2`, and so on,
    like in this fictitious example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `where` syntax, this can be made much more readable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `Draw` trait with a `draw` method. Define the `S1` struct type with
    an integer field and the `S2` struct type with a float field.
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `Draw` trait for `S1` and `S2` (draw prints the values and is
    surrounded by ***).
  prefs: []
  type: TYPE_NORMAL
- en: Make a generic `draw_object` function that takes any object that implements
    `Draw`.
  prefs: []
  type: TYPE_NORMAL
- en: Test these! (see the example code in `Chapter 5/exercises/draw_trait.rs`)
  prefs: []
  type: TYPE_NORMAL
- en: Built-in traits and operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rust standard library is packed with traits, which are used all over the
    place. For example, there are traits for:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects (the `Eq` and `PartialEq` traits).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering objects (the `Ord` and `PartialOrd` traits).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an empty object (the `Default` trait).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting a value using `{:?}` (the `Debug` trait, which defines a `fmt` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying an object (the `Clone` trait).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding objects (the `Add` trait, which defines an `add` method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `+` operator is just a nice way to use; `add: n + m` is the same as `n.add(m)`.
    So, if we implement the `Add` trait, we can use the `+` operator; this is called
    operator overloading. A lot of other traits can also be used to overload operators,
    such as `Sub(-)`, `Mul(*)`, `Deref (*v)`, `Index([])`, and so on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Freeing the resources of an object when it goes out of scope (the `Drop` trait
    in other words, the object has a destructor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Iterators* section, we described how an iterator works and used it on
    ranges and arrays. In fact, iterator is also defined as a trait in Rust in `std::iter::Iterator`.
    From the docs for iterator (refer to [http://doc.rust-lang.org/core/iter/trait.Iterator.html](http://doc.rust-lang.org/core/iter/trait.Iterator.html)),
    we see that we only need to define the `next()` method, which advances the iterator
    to return the next value as an option. When `next()` is implemented for the type
    of your object, we can then use a `for in` loop to iterate over the object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all kinds of techniques to make our code more flexible
    by using higher-order functions, closures, iterators, and generic types and functions.
    We then reviewed the basic error-handling mechanisms that make good use of generic
    types.
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered the object-oriented nature of Rust, by defining methods on
    structs and implementing traits. Finally, we saw that traits are the structuring
    concept of Rust.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will expose the crown jewels of the Rust language, which
    form the foundation of its memory safety behavior.
  prefs: []
  type: TYPE_NORMAL
