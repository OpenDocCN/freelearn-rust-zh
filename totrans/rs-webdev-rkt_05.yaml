- en: '*Chapter 4*: Building, Igniting, and Launching Rocket'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many web applications require some kind of object management that can be reused
    again and again, be it a connection pool for a database server, a connection to
    a memory store, an HTTP client to third-party servers, or any other object. Another
    common feature in a web application is **middleware**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss two Rocket features (state and fairings), which
    act as the reusable object management and middleware parts of Rocket. We will
    also learn how to create and use connections to database servers, which is very
    important in almost all web applications.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, we expect you to be able to use and implement
    the reusable object management and middleware parts of the Rocket web framework.
    We also expect you to be able to connect to a database of your own choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching Rocket fairings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the usual requirements of a Rust compiler, a text editor, and an HTTP
    client, starting from this chapter, we're going to work with a database. The database
    we're going to use throughout this book is PostgreSQL, and you can download it
    from [https://www.postgresql.org/](https://www.postgresql.org/), install it from
    your operating system package manager, or use a third-party server such as **Amazon
    Web Services** (**AWS**), Microsoft Azure, or **Google Cloud Platform** (**GCP**).
  prefs: []
  type: TYPE_NORMAL
- en: We're going to see how to connect to other **Relational Database Management
    Systems** (**RDBMSs**) such as SQLite, MySQL, or Microsoft SQL Server, and you
    can adjust the lesson code to make the type suitable to those RDBMSs, but it's
    easier to follow using PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Managing state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a web application, usually, programmers need to create an object that can
    be reused during the request/response life cycle. In the Rocket web framework,
    that object is called a **state**. A state can be anything such as a database
    connection pool, an object to store various customer statistics, an object to
    store a connection to a memory store, a client to send **Simple Mail Transfer
    Protocol** (**SMTP**) emails, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: We can tell Rocket to maintain the state, and this is called a **managed state**.
    The process of creating a managed state is quite simple. We need to initialize
    an object, tell Rocket to manage it, and finally use it in a route. One caveat
    is that we can manage many states from different types, but Rocket can only manage
    one instance of a Rust type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it directly. We are going to have a visitor counter state and tell
    Rocket to manage it and increment the counter for every incoming request. We can
    reuse the previous application from the previous chapter, copy the program from
    `Chapter03/15ErrorCatcher` into `Chapter04/01State`, and rename the application
    in `Cargo.toml` as `chapter4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/main.rs`, define a struct to hold the value of the visitor counter.
    For the state to work, the requirement is `T: Send + Sync + ''static`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We already know that `'static` is a lifetime marker, but what is `Send + Sync`?
  prefs: []
  type: TYPE_NORMAL
- en: In modern computing, due to its complexity, there are many ways a program can
    be executed in a way not intended. For example, multithreading makes it hard to
    know whether a variable value has been changed on another thread or not. Modern
    CPUs also perform branch prediction and execute multiple instructions at the same
    time. Sophisticated compilers also rearrange the resulting binary code execution
    flow to optimize the result. To overcome those problems, some kind of syncing
    is needed in the Rust language.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust language has traits and memory containers to solve syncing problems
    depending on how programmers intended the application to work. We might want to
    create an object in the heap and share the reference to that object in multiple
    other objects. For example, we create object `x`, and we use the reference of
    x, `&x` in other objects field, `y` and `z`. This creates another problem, as
    the program can delete `x` in other routines making the program unstable. The
    solution is to create different containers for different use cases. These include
    `std::cell::Rc` and `std::box::Box`, among others.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::marker::Send` is one of those traits. The `Send` trait is making sure
    any `T` type is safe to be transferred to another thread. Almost all types in
    the `std` library are `Send`, with a few exceptions such as `std::rc::Rc` and
    `std::cell::UnsafeCell`. Rc is a single-threaded reference counted pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, `std::marker::Sync` is saying the `T` type is safe to be shared across
    multiple threads. That only holds `true` if the `&T` reference is safe to be sent
    to another thread. Not all `Send` types are `Sync`. For example, `std::cell::Cell`
    and `std::cell::RefCell` are `Send` but not `Sync`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Both` `Send + Sync` are `Send + Sync` in our type? These types are also `Send`
    automatically becomes a `Send` type. Almost all types in the `std` library are
    `Send + Sync` apart from the raw pointers, `Rc`, `Cell`, and `RefCell`.'
  prefs: []
  type: TYPE_NORMAL
- en: What is `AtomicU64`? With the regular `u64` type, even though it's `Send + Sync`,
    there's no synchronization between threads so a data race condition might happen.
    For example, two threads access the same variable, `x` (which has a value of `64`)
    at the same time, and they increment the value by one. We expect the result to
    be `66` (as there are two threads), but because there's no synchronization between
    threads, the final result is unpredictable. It can be `65` or `66`.
  prefs: []
  type: TYPE_NORMAL
- en: The types in the `std::sync` module provide a couple of ways to share updates
    between multiple threads, including the `std::sync::Mutex`, `std::sync::RwLock`,
    and `std::sync::atomic` types. We can also use other libraries that might provide
    better speed than a standard library, such as the `parking_lot` crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have defined `VisitorCounter`, let''s initialize it and tell Rocket
    to manage it as a state. Write the code inside the `rocket()` function as in the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After we tell Rocket to manage the state, we can use it inside the route handling
    functions. In the previous chapter, we learned about dynamic segments that we
    have to use in `function` arguments. There are other arguments we can use in a
    route handling function, which we call **request guards**. They are called *guards*
    because if a request does not pass the validation inside the guard, the request
    will be rejected, and an error response will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Any type that implements `rocket::request::FromRequest` can be considered a
    request guard. Incoming requests are then validated against each request guard
    from left to right and will short circuit and return an error if the request is
    not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a route handling function as in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Guard1` and `Guard2` types are the request guards. The incoming request
    is then validated against the `Guard1` methods, and if an error occurs, the proper
    error response will be returned immediately.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about and implement request guards throughout the book, but we
    will just use a request guard without implementing it in this chapter. `FromRequest`
    is already implemented for `rocket::State<T>`, so we can use it in the route handling
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned why we use `State` in a route handling function, let''s
    use it in our functions. We want to set the visitor counter so each hit to the
    request should increment the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Why do we add the `'a` lifetime? We are adding a new reference argument, and
    Rust cannot infer which lifetime the returned `&User` should follow. In this case,
    we are saying the lifetime of the `User` reference should be as long as `uuid`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function, we use the AtomicU64 `fetch_add()` method to increment
    the value of the visitor, and we print the value using the AtomicU64 `load()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the same for the `users()` function, but since we have the exact
    same routine with the `user()` function, let''s make another function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This example works fine with the `Atomic` type, but if you ever needed a more
    complex type to work with, such as `String`, `Vec`, or `Struct`, try using `Mutex`
    or `RwLock` from either the standard library or a third-party crate such as `parking_lot`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what `State` is in Rocket, let's expand our application by
    combining it with a database server. We will use `State` for storing the connection
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, in our application, we are storing user data in a static variable.
    This is very cumbersome, as it is inflexible and we cannot update the data easily.
    Most modern applications handling data will use some kind of persistent storage,
    be it filesystem-backed storage, a document-oriented database, or a traditional
    RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has many libraries to connect to various databases or database-like storage.
    There's the `postgres` crate, which works as a PostgreSQL client for Rust. There
    are also other clients such as `mongodb` and `redis`. For `diesel`, which can
    be used to connect to various database systems. For connection pool management,
    there are the `deadpool` and `r2d2` crates. All crates have their strengths and
    limitations, such as not having an asynchronous application.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we're going to use `sqlx` to connect to an RDBMS. `sqlx` claims
    to be an SQL toolkit for Rust. It has abstractions for clients to connect to various
    RDBMSs, it has a connection pool trait, and it can also be used to convert types
    to queries and query responses to Rust types.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the *Technical requirements* section of this chapter, we're
    going to use PostgreSQL as our RDBMS, so please prepare the connection information
    to PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, follow these steps to convert our application into using a database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reuse our application again. The first thing we want to do is to install
    `sqlx-cli` by typing this command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`sqlx-cli` is a useful command-line application to create a database, create
    migrations, and run the migrations. It''s not as sophisticated as migration tools
    in other established frameworks, but it does its job very well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare the connection information and set the `DATABASE_URL` environment variable
    in your terminal. The `DATABASE_URL` format should look as follows, depending
    on which RDBMS you are using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `connect_options`, it''s in query form, and the reference can be found
    at [https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).
    Other DATABASE_URL format for other RDBMS might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Or `sqlite::memory:` or `sqlite://path/to/file.db?connect_options` or `sqlite:///path/to/file.db?connect_options`.
    The connect options for SQLite can be found at [https://www.sqlite.org/uri.html](https://www.sqlite.org/uri.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new database using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create a migration named `create_users` using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sqlx` CLI will create a new folder named `migrations` inside the root
    directory of our application, and inside the folder, there will be a file with
    the `timestamp_migration_name.sql` pattern. In our example, the filename will
    look like `migrations/20210923055406_create_users.sql`. Inside the file, we can
    write SQL queries to create or modify the `User` struct, so let''s write the following
    code into the SQL file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How do we know what the mapping between the database column type and Rust type
    is? `sqlx` provides its own mapping; we can find the documentation at [https://docs.rs/sqlx](https://docs.rs/sqlx).
    The crate has great modules for a supported database. We can search for it in
    the top search bar; for example, we can find the documentation for PostgreSQL
    in [https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html](https://docs.rs/sqlx/0.5.7/sqlx/postgres/index.html).
    On that page, we can see there are `types` modules that we can look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we write the content of the migration file, we can run the migration
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the migration, check the generated database table and see whether the
    table schema is correct or not. Let's insert the data from the previous chapter.
    Also, feel free to fill the table with sample data of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After migration, include the `sqlx` crate in our `Cargo.toml` file. We should
    also include the `uuid` crate as we''re going to use PostgreSQL''s `uuid` type.
    Take a look at the API documentation of the crate if you want to enable another
    RDBMS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can delete `lazy_static` from `Cargo.toml` and remove references of `lazy_static!`,
    `USERS`, and `HashMap` from the `src/main.rs` file. We don''t need those, and
    we are only going to retrieve the `User` data from the database that we inserted
    earlier. Use the following `SQL INSERT` syntax to insert the previous user data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `User` struct to follow the database that we''ve created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When `sqlx` retrieves the result from the database, it will be stored in `sqlx::Database::Row`.
    This type can then be converted to any type that implements `sqlx::FromRow`. Luckily,
    we can derive `FromRow` as long as all the members implement `sqlx::Decode`. There
    are a few exceptions that we can use to override `FromRow`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For `rename_all`, we can use these options: `snake_case`, `lowercase`, `UPPERCASE`,
    `camelCase`, `PascalCase`, `SCREAMING_SNAKE_CASE`, and `kebab-case`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`rename` is used when we have different column names and type member names.
    If a member has no column in the database, and that type has the implementation
    of the `std::default::Default` trait, we can use the `default` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we use `i16`? The answer is the PostgreSQL type has no mapping to the
    Rust `u8` type. We can either use `i8`, use a bigger `i16` type, or try implementing
    `Decode` for `u8`. In this case, we choose to use the `i16` type.
  prefs: []
  type: TYPE_NORMAL
- en: We want the program to read the connection information (`DATABASE_URL`) from
    the environment variable. In [*Chapter 2*](B16825_02_ePub.xhtml#_idTextAnchor032),
    *Building Our First Rocket Web Application*, we learned how to configure Rocket
    using standard configuration, but this time, we want to add extra configuration.
    We can start by adding `serde` to application dependencies in `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: '`serde` is one of the most used and important libraries in Rust. The name comes
    from *serialization and deserialization*. It is used for anything that involves
    serialization and deserialization. It can be used to convert Rust type instances
    to bytes representations and vice versa, to JSON and vice versa, to YAML, and
    any other type, as long as they implement the `serde` traits. It can also be used
    to transcode one type that implements `serde` traits to another type that implements
    `serde` traits.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to look at the `serde` documentation, you can find it on their website
    at [https://serde.rs](https://serde.rs).
  prefs: []
  type: TYPE_NORMAL
- en: The `serde` documentation mentions many native or third-party supports for many
    data formats such as JSON, Bincode, CBOR, YAML, MessagePack, TOML, Pickle, RON,
    BSON, Avro, JSON5, Postcard, URL query strings, Envy, Envy Store, S-expressions,
    D-Bus's binary wire format, and FlexBuffers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following lines into `Cargo.toml` to include `serde` in our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, create a struct that will be used to contain our custom configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`serde` already provides the `Deserialize` macro that can be used in the `derive`
    attribute. So far, we have used a lot of macros providing libraries that can be
    used in the `derive` attribute, such as `Debug`, `FromRow`, `Deserialize`. The
    macro system is one of the important Rust features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the routine to read the configuration and map it into the `rocket()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the application can get the `DATABASE_URL` information from environment
    variables, it''s time to initialize the database connection pool and tell Rocket
    to manage it. Write the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We initialize the connection pool using `PgPoolOptions`. Other databases can
    use their corresponding type, such as `sqlx::mysql::MySqlPoolOptions` or `sqlx::sqlite::SqlitePoolOptions`.
    The `connect()` method is an `async` method, so we must make `rocket()` async
    as well to be able to use the result.
  prefs: []
  type: TYPE_NORMAL
- en: After that, inside the `rocket()` function, we tell Rocket to manage the connection
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the database connection, we used `lazy_static` and created `user`
    objects as references to the `USERS` hash map. Now, we will use the data from
    the database, so we need to use concrete objects instead of references. Remove
    the ampersand (`&`) from the `Responder` implementation for the `User` and `NewUser`
    structs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it''s time to implement the `user()` function to use the database connection
    pool to query from the database. Modify the `user()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We included the connection pool managed state in the function arguments. After
    that, we parsed the UUID `&str` parameter into the `Uuid` instance. If there's
    an error parsing the `uuid` parameter, we change the error to `Status::BadRequest`
    and return the error.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `query_as!` macro to send a query to the database server and
    convert the result to a `User` instance. There are many `sqlx` macros we can use,
    such as `query!`, `query_file!`, `query_as_unchecked!`, and `query_file_as!`.
    You can find the documentation for those macros in the `sqlx` API documentation
    that we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format to use this macro is as follows: `query_as!(RustType, "prepared
    statement", bind parameter1, ...)`. If you don''t need to get the result as a
    Rust type, you can use the `query!` macro instead.'
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `fetch_one()` method. If you want to execute instead of query,
    for example, to update or delete rows, you can use the `execute()` method. If
    you want to get all the results, you can use the `fetch_all()` method. You can
    find other methods to use and their documentation in the `sqlx::query::Query`
    struct documentation.
  prefs: []
  type: TYPE_NORMAL
- en: We can either keep the `user()` function return as `Option<User>` and use `user.ok()`,
    or we change the return to `Status::SomeStatus`. Since we change the return type
    to either `Ok(user)` or `Err(some_error)`, we can just return the `Ok(user)` variant,
    but we want to use `map_err(|_| Status::NotFound)` to change the error to a `Status`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, if we send raw SQL queries to the server, is it possible
    to do a SQL injection attack? Is it possible to mistakenly get any user input
    and execute `sqlx::query_as::<_, User>("SELECT * FROM users WHERE name = ?").bind``).fetch_one(pool.inner())`?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no. `sqlx` prepared and cached each statement. As the result of
    using a prepared statement, it's more secure than a regular SQL query, and the
    type returned is also what we expect from the RDBMS server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also change the `users()` function. Like the `user()` function, we want
    the function to be `async` and get the connection pool from the Rocket managed
    state. We also want to remove the lifetime from `NewUser` as we are not referencing
    `USERS` anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can prepare the prepared statement. We append more conditions
    to `WHERE` if the client sends the `filters` request. For PostgreSQL, the prepared
    statement uses `$1`, `$2`, and so on, but for other RDBMSs, you can use `?` for
    the prepared statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, write the code to execute the query, but the number of bound parameters
    may change depending on whether filters exist or not; we use the `query_as` function
    instead so we can use the `if` branching. We also add `%name%` for the name-bound
    parameter because we use the `LIKE` operator in the SQL statement. We also have
    to cast the `u8` type to the `i16` type. And, finally, we use the `fetch_all`
    method to retrieve all the results. The nice thing with the `query_as!` macro
    and query as function is they both returned `Vec<T>` or not depending on the `fetch_one`
    or `fetch_all`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can return the result as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s try calling the `user()` and `users()` endpoints again. It should
    work as it did when we used `HashMap`. Since we didn''t modify the connection
    options after we wrote `connect()` on the connection pool, the SQL output is written
    on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is some more of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this book, we are not going to use ORM; instead, we are going to use `sqlx`
    only, as it is enough for the scope of this book. If you want to use ORM in your
    application, you can use ORM and query builders from [https://github.com/NyxCode/ormx](https://github.com/NyxCode/ormx)
    or [https://www.sea-ql.org/SeaORM/](https://www.sea-ql.org/SeaORM/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about `State` and how to use databases using `State`,
    it is time to learn about another Rocket middleware capability, attaching fairings.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Rocket fairings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real life, a rocket fairing is a nose cone used to protect the rocket payload.
    In the Rocket framework, a fairing is not used to protect the payload but is instead
    used to hook in to any part of the request life cycle and rewrite the payload.
    Fairings are analogous to middleware in other web frameworks but with few differences.
  prefs: []
  type: TYPE_NORMAL
- en: Other framework middleware may be able to inject any arbitrary data. In Rocket,
    the fairing can be used to modify the request but cannot be used to add information
    that is not part of the request. For example, we can use fairings to add a new
    HTTP header in the requests or responses.
  prefs: []
  type: TYPE_NORMAL
- en: Some web frameworks might be able to terminate and directly respond to incoming
    requests, but in Rocket, the fairings cannot stop the incoming requests directly;
    the request must go through the route handling function, and then the route can
    create the proper response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a fairing by implementing `rocket::fairing::Fairing` for a type.
    Let''s first see the signature of the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of types we are not familiar with, such as `Build` and `Orbit`.
    These types are related to phases in Rocket.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket phases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The types that we want to discuss are `Build` and `Orbit`, with the full module
    paths of `rocket::Orbit` and `rocket::Build`. What are these types? The signature
    for a Rocket instance is `Rocket<P: Phase>`, which means any `P` type that implements
    `rocket::Phase`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Phase` is a `pub trait SomeTrait: private::Sealed {}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Phase` trait is sealed because Rocket authors intended only three phases
    in the Rocket application: `rocket::Build`, `rocket::Ignite`, and `rocket::Orbit`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize a Rocket instance through `rocket::build()`, which uses the `Config::figment()`default,
    or `rocket::custom<T: Provider>(provider: T)`, which uses the custom configuration
    provider. In this phase, we can also chain the generated instance with custom
    configuration using `configure<T: Provider>(self, provider: T)`. We can then add
    a route using `mount()`, register a catcher using `register()`, manage the states
    using `manage()`, and attach fairings using `attach()`.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we can change the Rocket phase to `Ignite` through the `ignite()`
    method. In this phase, we have a Rocket instance with the final configuration.
    We can then send the Rocket to the `Orbit` phase through the `launch()` method
    or return `Rocket<Build>` and use the `#[launch]` attribute. We can also skip
    the `Ignite` phase and use `launch()` directly after `build()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall the code that we have created up to now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This function generates `Rocket<Build>`, and the `#[launch]` attribute generates
    the code that uses `launch()`.
  prefs: []
  type: TYPE_NORMAL
- en: The conclusion for this subsection is that the Rocket phase goes from `Build`
    to `Ignite` to `Launch`. How are those phases related to fairing? Let's discuss
    this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Fairing callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any type implementing fairings must implement one mandatory function, `info()`,
    which returns `rocket::fairing::Info`. The `Info` struct is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: And, `rocket::fairing::Kind` is defined as just an empty struct, `pub struct
    Kind(_);`, but `Kind` has the `Kind::Ignite`, `Kind::Liftoff`, `Kind::Request`,
    `Kind::Response`, and `Kind::Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are associated constants? In Rust, we can declare **associated items**,
    which are items declared in traits or defined in implementations. For example,
    we have this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `Something::new()` `self` as the first parameter. We have already
    implemented an associated method a couple of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define an **associated type** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, we can have an `rocket::fairing::Kind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go back to `Info`. We can make an `Info` instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We are saying the value for `kind` is the result of the `OR` bitwise operation
    between the `kind` associated constants. `Kind::Request` is `1<<2`, which means
    `100` in binary or `4` in decimal. `Kind::Response` is `1<<3`, which means `1000`
    in binary or `8` in decimal. The result of `0100 | 1000` is `1100` in binary or
    `12` in decimal. With this knowledge, we can set the value for the `Info` instance,
    `kind`, from `00000` to `11111`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting configuration using bitwise is a very common design pattern for packing
    multiple values into one variable. Some other languages even make this design
    pattern into its own type and call it **bitset**.
  prefs: []
  type: TYPE_NORMAL
- en: In a type that implements the `Fairing` trait, the mandatory method implementation
    is `info()`, which returns the `Info` instance. We also have to implement `on_ignite()`,
    `on_liftoff()`, `on_request()`, and `on_response()` depending on the `kind` instance
    that we defined. In our case, this means we have to implement `on_request()` and
    `on_response()`.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket executes our fairing method on different occasions. If we have `on_ignite()`,
    it will be executed before launch. This type of fairing is special as `on_ignite()`
    returns `Result`, and if the returned variant is `Err`, it can abort the launch.
  prefs: []
  type: TYPE_NORMAL
- en: For `on_liftoff()`, this method will be executed after launch, which means when
    Rocket is in the `Orbit` phase.
  prefs: []
  type: TYPE_NORMAL
- en: If we have `on_request()`, it will be executed after Rocket gets the request
    but before the request is routed. This method will have access to `Request` and
    `Data`, which means we can modify these two items.
  prefs: []
  type: TYPE_NORMAL
- en: And, `on_response()` will be executed when the route handler has created the
    response but before the response is sent to the HTTP client. This callback has
    access to the `Request` and `Response` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '`Kind::Singleton` is special. We can create multiple instances of fairings
    of the same type and attach them to Rocket. But, maybe we only want to allow one
    instance of the `Fairing` implementing type to be added. We can use `Kind::Singleton`
    and it will make sure only the last attached instance of this type will be added.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know more about Rocket phases and `Fairing` callbacks, let's implement
    the `Fairing` trait in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and attaching fairings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, our Rocket application manages `VisitorCounter`, but we did not add
    `State<VisitorCounter>` to the `favicon()` function. We might also want to add
    new route handling functions, but adding `State<VisitorCounter>` as an argument
    parameter for every route handling function is cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: We can change `VisitorCounter` from a managed state into a fairing. At the same
    time, let's imagine that we have another requirement in our application. We want
    to have a custom header for the request and response for internal logging purposes.
    We can do it by adding another fairing to change the incoming requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s organize our module usage a little bit. We need to add the fairing-related
    modules, `rocket::http::Header`, `rocket::Build`, and `rocket::Orbit`, so we can
    use those for our `VisitorCounter` fairing and another fairing to modify the requests
    and responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `Fairing` trait implementation for `VisitorCounter`. We need to decorate
    the `impl` with `#[rocket::async_trait]`, since this trait is an `async` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: We added the `info()` mandatory method, which returned the `Info` instance.
    Inside the `Info` instance, we only really need `Kind::Request` as we only need
    to increment the visitor counter for every incoming request. But this time, we
    also added `Kind::Ignite` and `Kind::Liftoff` because we want to see when the
    callback is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can add the callbacks inside the `impl Fairing` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: What is the return type on the `on_ignite()` method? `rocket::fairing::Result`
    is defined as `Result<T = Rocket<Build>, E = Rocket<Build>> = Result<T, E>`. This
    method is used to control whether the program continues or not. For example, we
    can check the connection to a third-party server to ensure its readiness. If the
    third-party server is ready to accept connections, we can return `Ok(rocket)`.
    But, if the third-party server is not available, we can return `Err(rocket)` to
    halt the launch of Rocket. Notice that `on_liftoff()`, `on_request()`, and `on_response()`
    do not have a return type, as `Fairing` is designed to only fail when we build
    Rocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `on_liftoff()`, we just want to print something to the application output.
    For `on_request()`, we undertake the real purpose of this fairing: increase the
    counter for every request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After implementing the `Fairing` trait, we can remove `counter: &State<VisitorCounter>`
    from the `user()` and `users()` function arguments. We also need to remove `counter.increment_counter();`
    from the body of those functions.'
  prefs: []
  type: TYPE_NORMAL
- en: After we have modified the `user()` and `users()` functions, we can attach the
    fairing to the Rocket application. Change `manage(visitor_counter)` to `attach(visitor_counter)`
    in the Rocket initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to see the fairing in action! First, take a look at the initialization
    sequence. You can see `on_ignite()` is executed in the beginning, and `on_liftoff()`
    is executed after everything is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, try calling our route handling function again to see the counter
    increase again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the Rocket output, we can see it increase when we use it as a state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's implement our second use case, injecting a tracing ID to our requests
    and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify `Cargo.toml` to ensure the `uuid` crate can generate a random
    UUID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, inside `src/main.rs`, we can define the header name we want to
    inject and a type that works as the fairing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, we can implement the `Fairing` trait for `XtraceId`. This time,
    we want to have `on_request()` and `on_response()` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the `on_request()` and `on_response()` implementations inside the
    `impl Fairing` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: In `on_request()`, we generate a random UUID and inject the resulting string
    as one of the request headers. In `on_response()`, we inject the response with
    the same header from the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to initialize and attach this new fairing to the Rocket build
    and launch process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the application. We should have a new fairing in the application output
    and `"x-trace-id"` in the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we can use both `State` and `Fairing` in our application. Only
    use `Fairing` if we need to call this for every request.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we created a connection pool and told Rocket to manage it using
    managed state but Rocket already has a way to connect to the database via its
    built-in database connection, `rocket_db_pools`, which is a type of fairings.
    Let's see how we can do it in the next part.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database using rocket_db_pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rocket provided a *sanctioned* way to connect to some RDBMSs by using `rocket_db_pools`.
    That crate provides the database driver integration for Rocket. We are going to
    learn how to use this crate for connecting to the database. Let''s change the
    connection pool that we made previously from using state into using fairings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need `serde`, as `rocket_db_pools` already has its own configuration.
    Remove `serde` from `Cargo.toml` and add `rocket_db_pools` as a dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also use different features such as `sqlx_mysql`, `sqlx_sqlite`, `sqlx_mssql`,
    `deadpool_postgres`, `deadpool_redis`, or `mongodb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Rocket.toml`, remove the line containing the `database_url` configuration
    and replace it with these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use `default.databases.main_connection` if you like, and you can also
    change `main_connection` to whatever name you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cargo library project, we can re-export something in `our_library` using
    the `pub use something;` syntax, and another library can then use that through
    `our_library::something`. Remove these `use sqlx...` and `use serde...` lines,
    as `rocket_db_pools` already re-exported `sqlx` and we don''t need `serde` anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following lines to use `rocket_db_pools`. Notice that we can multiline
    the `use` declaration in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the struct `Config` declaration and add the following lines to declare
    the database connection type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The database derives an automatically generated `rocket_db_pools::Database`
    implementation for the `DBConnection` type. Notice that we wrote the connection
    name `"main_connection"`, just like what we have set in `Rocket.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the config and connection pool initializations in the `rocket()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `DBConnection::init()` inside the `rocket()` function and attach it to
    Rocket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `user()` and `users()` functions to use the `rocket_db_pools::Connection`
    request guard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The application should work just like when we managed the connection pool using
    state, but with minor differences. Here''s the output we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: We can see there's a new fairing in the application output but there is no prepared
    SQL statement in the application output.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about two Rocket components, `State` and `Fairing`.
    We can manage state objects and attach fairings upon building rockets, use the
    `state` objects in route handling functions, and use the `fairing` functions to
    execute callbacks on the build, after launch, on request, and on response.
  prefs: []
  type: TYPE_NORMAL
- en: We also created counter states and used them in the route handling functions.
    We also learned how to use `sqlx`, made a database migration, made a database
    connection pool state, and used `state` to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: Afterward, we learned more about the Rocket initialization process and the building,
    igniting, and launching phases.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we changed the counter state into a fairing and created a new fairing
    to inject a custom HTTP header into the incoming requests and outgoing responses.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with that knowledge, you can create reusable objects between route handling
    functions, and create a method that can be executed globally between requests
    and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Our `src/main.rs` file is getting bigger and more complicated; we will learn
    how to manage our Rust code in modules and plan a more complex application in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
