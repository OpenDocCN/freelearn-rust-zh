<html><head></head><body>
        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing an Asynchronous FTP Server</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In the previous chapter, we wrote a synchronous FTP server. Now, we'll write an asynchronous version with <span><kbd class="calibre14">tokio</kbd></span>, the asynchronous IO (Input/Output) library for Rust. We'll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Asynchronous servers</li>
<li class="calibre11">Futures</li>
<li class="calibre11">Streams</li>
<li class="calibre11">Tokio</li>
<li class="calibre11">Async/await</li>
<li class="calibre11">Error handling</li>
</ul>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Advantages of asynchronous IO</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Asynchronous IO allows us to send a request without waiting for its result, we'll get notified somehow later when we receive the response. This enables our programs to be more concurrent and scale better.</p>
<p class="calibre3">In the previous chapter, we used threads in order to avoid blocking other clients while we wait for a response. Using threads has a cost, though, besides the fact that threads require more memory, they also impose a performance cost because they require a context switch when the code goes from one thread to the other.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Disadvantages of asynchronous IO</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">However, using asynchronous IO does not come without drawbacks. Using asynchronous IO is harder than using synchronous IO. With asynchronous IO, we also need a way to know when an event has terminated. So, we need to learn a new way to manage the IO events and it'll take more time to implement the same software that we wrote in the previous chapter.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the new project</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's start by creating a new binary project, as usual:</p>
<pre class="calibre23"><strong class="calibre5"><span>cargo</span> new --bin ftp-server</strong></pre>
<p class="calibre3">We'll add the following dependencies in the <span><kbd class="calibre14">Cargo.toml</kbd></span> file:</p>
<pre class="calibre22">[dependencies]
bytes = "^0.4.5"
tokio-core = "^0.1.10"
tokio-io = "^0.1.3"

[dependencies.futures-await]
git = "https://github.com/alexcrichton/futures-await"</pre>
<p class="calibre3">As you can see here, we specify a dependency via a Git URL. This dependency is using nightly-only features, so make sure you're using the nightly compiler by running this command:</p>
<pre class="calibre23"><strong class="calibre5"><span>rustup</span> default nightly</strong></pre>
<p class="calibre3">Let's start our <span><kbd class="calibre14">main</kbd></span> module by adding the required <span><kbd class="calibre14">extern crate</kbd></span> statements:</p>
<pre class="calibre22"><span>#![</span>feature<span>(</span>proc_macro<span>,</span> conservative_impl_trait<span>,</span> generators<span>)]</span>

<span>extern</span> <span>crate</span> bytes;
<span>extern</span> <span>crate</span> futures_await <span>as</span> futures;
<span>extern</span> <span>crate</span> tokio_core;
<span>extern</span> <span>crate</span> tokio_io;</pre>
<p class="calibre3">As you can see, we're using some nightly features. These are needed by the <span><kbd class="calibre14">futures-await</kbd></span> crate. We also decided to import this crate under another name, <span><kbd class="calibre14">futures</kbd></span>, because it exports the same types and functions as the <span><kbd class="calibre14">futures</kbd></span> crate itself.</p>
<p class="calibre3">We'll copy some code from the previous chapter and put them in the new module, for better organization. Here are the new modules:</p>
<pre class="calibre22"><span>mod</span> cmd;
<span>mod</span> ftp;</pre>
<p class="calibre3">In a new file, called <span><kbd class="calibre14">src/cmd.rs</kbd></span>, put the following code:</p>
<pre class="calibre22"><span>use</span> std::path::<span>{</span>Path, PathBuf<span>}</span>;
<span>use</span> std::<span>str</span>::<span>{</span><span>self</span>, FromStr<span>}</span>;

<span>use</span> error::<span>{</span>Error, <span>Result</span><span>}</span>;

<span>#[</span>derive<span>(</span><span>Clone</span><span>,</span> <span>Debug</span><span>)]</span>
<span>pub</span> <span>enum</span> Command <span>{</span>
    Auth,
    Cwd(PathBuf),
    List(<span>Option</span>&lt;PathBuf&gt;),
    Mkd(PathBuf),
    NoOp,
    Port(<span>u16</span>),
    Pasv,
    Pwd,
    Quit,
    Retr(PathBuf),
    Rmd(PathBuf),
    Stor(PathBuf),
    Syst,
    Type(TransferType),
    CdUp,
    Unknown(<span>String</span>),
    User(<span>String</span>),
<span>}</span></pre>
<p class="calibre3">We first have an enumeration representing the different commands and their parameters:</p>
<pre class="calibre22"><span>impl</span> AsRef&lt;<span>str</span>&gt; <span>for</span> Command <span>{</span>
    <span>fn</span> as_ref(&amp;<span>self</span>) -&gt; &amp;<span>str</span> <span>{</span>
        <span>match</span> *<span>self</span> <span>{</span>
            Command::Auth =&gt; <span>"AUTH"</span>,
            Command::Cwd(_) =&gt; <span>"CWD"</span>,
            Command::List(_) =&gt; <span>"LIST"</span>,
            Command::Pasv =&gt; <span>"PASV"</span>,
            Command::Port(_) =&gt; <span>"PORT"</span>,
            Command::Pwd =&gt; <span>"PWD"</span>,
            Command::Quit =&gt; <span>"QUIT"</span>,
            Command::Retr(_) =&gt; <span>"RETR"</span>,
            Command::Stor(_) =&gt; <span>"STOR"</span>,
            Command::Syst =&gt; <span>"SYST"</span>,
            Command::Type(_) =&gt; <span>"TYPE"</span>,
            Command::User(_) =&gt; <span>"USER"</span>,
            Command::CdUp =&gt; <span>"CDUP"</span>,
            Command::Mkd(_) =&gt; <span>"MKD"</span>,
            Command::Rmd(_) =&gt; <span>"RMD"</span>,
            Command::NoOp =&gt; <span>"NOOP"</span>,
            Command::Unknown(_) =&gt; <span>"UNKN"</span>, <span>// doesn't exist</span>
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, we create a method to get the string representation of a command:</p>
<pre class="calibre22"><span>impl</span> Command <span>{</span>
    <span>pub</span> <span>fn</span> new(input: <span>Vec</span>&lt;<span>u8</span>&gt;) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
        <span>let</span> <span>mut</span> iter = input.split(|&amp;byte| byte == b<span>' '</span>);
        <span>let</span> <span>mut</span> command = iter.next().ok_or_else(<br class="calibre6"/>         || Error::Msg(<span>"empty command"</span>.to_string()))?.to_vec();
        to_uppercase(&amp;<span>mut</span> command);
        <span>let</span> data = iter.next().ok_or_else(|| Error::Msg(<span>"no command  <br class="calibre6"/>         parameter"</span>.to_string()));
        <span>let</span> command =
            <span>match</span> command.as_slice() <span>{</span>
                b<span>"AUTH"</span> =&gt; Command::Auth,
                b<span>"CWD"</span> =&gt; Command::Cwd(data.and_then(|bytes|  <br class="calibre6"/><span>                Ok</span>(Path::new(<span>str</span>::from_utf8(bytes)?).to_path_buf()))?),
                b<span>"LIST"</span> =&gt; Command::List(data.and_then(|bytes|  <br class="calibre6"/><span>                 Ok</span>(Path::new(<span>str</span>::from_utf8(bytes)?).to_path_buf())).ok()),
                b<span>"PASV"</span> =&gt; Command::Pasv,
                b<span>"PORT"</span> =&gt; <span>{</span>
                    <span>let</span> addr = data?.split(|&amp;byte| byte == b<span>','</span>)
                        .filter_map(|bytes| <br class="calibre6"/><span>                         str</span>::from_utf8(bytes).ok()
                         .and_then(|string| <span>u8</span>::from_str(string).ok()))
                        .collect::&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;();
                    <span>if</span> addr.len() != <span>6</span> <span>{</span>
                        <span>return</span> <span>Err</span>(<span>"Invalid address/port"</span>.into());
                    <span>}</span>

                    <span>let</span> port = (addr<span>[</span><span>4</span><span>]</span> <span>as</span> <span>u16</span>) &lt;&lt; <span>8</span> | (addr<span>[</span><span>5</span><span>]</span> <span>as</span> <br class="calibre6"/><span>                     u16</span>);
                    <span>if</span> port &lt;= <span>1024</span> <span>{</span>
                        <span>return</span> <span>Err</span>(<span>"Port can't be less than<br class="calibre6"/>                      10025"</span>.into());
                    <span>}</span>
                    Command::Port(port)
                <span>}</span>,
                b<span>"PWD"</span> =&gt; Command::Pwd,
                b<span>"QUIT"</span> =&gt; Command::Quit,
                b<span>"RETR"</span> =&gt; Command::Retr(data.and_then(|bytes|  <br class="calibre6"/><span>                Ok</span>(Path::new(<span>str</span>::from_utf8(bytes)?).to_path_buf()))?),
                b<span>"STOR"</span> =&gt; Command::Stor(data.and_then(|bytes|   <br class="calibre6"/><span>                Ok</span>(Path::new(<span>str</span>::from_utf8(bytes)?).to_path_buf()))?),
                b<span>"SYST"</span> =&gt; Command::Syst,
                b<span>"TYPE"</span> =&gt; <span>{</span>
                    <span>match</span> TransferType::from(data?<span>[</span><span>0</span><span>]</span>) <span>{</span>
                        TransferType::Unknown =&gt; <span>return</span> <br class="calibre6"/><span>                         Err</span>(<span>"command not implemented <br class="calibre6"/>                        for that parameter"</span>.into()),
                        typ =&gt; <span>{</span>
                            Command::Type(typ)
                        <span>}</span>,
                    <span>}</span>
                <span>}</span>,
                b<span>"CDUP"</span> =&gt; Command::CdUp,
                b<span>"MKD"</span> =&gt; Command::Mkd(data.and_then(|bytes|  <br class="calibre6"/><span>                Ok</span>(Path::new(<span>str</span>::from_utf8(bytes)?).to_path_buf()))?),
                b<span>"RMD"</span> =&gt; Command::Rmd(data.and_then(|bytes|  <br class="calibre6"/><span>                Ok</span>(Path::new(<span>str</span>::from_utf8(bytes)?).to_path_buf()))?),
                b<span>"USER"</span> =&gt; Command::User(data.and_then(|bytes|  <br class="calibre6"/><span>                String</span>::from_utf8(bytes.to_vec()).map_err(Into::into))?),
                b<span>"NOOP"</span> =&gt; Command::NoOp,
                s =&gt; <br class="calibre6"/>                 Command::Unknown(<span>str</span>::from_utf8(s).unwrap_or(<span>""</span>).to_owned()),
            <span>}</span>;
        <span>Ok</span>(command)
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">This constructor parses a byte string as a <span><kbd class="calibre14">Command</kbd></span>. This requires a function to convert a byte string to uppercase:</p>
<pre class="calibre22"><span>fn</span> to_uppercase(data: &amp;<span>mut</span> <span>[</span><span>u8</span><span>]</span>) <span>{</span>
    <span>for</span> byte <span>in</span> data <span>{</span>
        <span>if</span> *byte &gt;= <span>'a'</span> <span>as</span> <span>u8</span> &amp;&amp; *byte &lt;= <span>'z'</span> <span>as</span> <span>u8</span> <span>{</span>
            *byte -= <span>32</span>;
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We simply decrement all lowercase letters by 32 to convert them to uppercase:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span><span>Clone</span><span>,</span> <span>Copy</span><span>,</span> <span>Debug</span><span>)]</span>
<span>pub</span> <span>enum</span> TransferType <span>{</span>
    Ascii,
    Image,
    Unknown,
<span>}</span>

<span>impl</span> From&lt;<span>u8</span>&gt; <span>for</span> TransferType <span>{</span>
    <span>fn</span> from(c: <span>u8</span>) -&gt; TransferType <span>{</span>
        <span>match</span> c <span>{</span>
            b<span>'A'</span> =&gt; TransferType::Ascii,
            b<span>'I'</span> =&gt; TransferType::Image,
            _ =&gt; TransferType::Unknown,
        <span>}</span>
    <span>}</span>
<a class="calibre67"><span>}</span></a></pre>
<p class="calibre3">Here, we have an enumeration for the transfer type and a function to parse a byte character to this type. And in another file, <span><kbd class="calibre14">src/ftp.rs</kbd></span>, let's write the following:</p>
<pre class="calibre22"><span>pub</span> <span>struct</span> Answer <span>{</span>
    <span>pub</span> code: ResultCode,
    <span>pub</span> message: <span>String</span>,
<span>}</span>

<span>impl</span> Answer <span>{</span>
    <span>pub</span> <span>fn</span> new(code: ResultCode, message: &amp;<span>str</span>) -&gt; <span>Self</span> <span>{</span>
        Answer <span>{</span>
            code,
            message: message.to_string(),
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>#[</span>derive<span>(</span><span>Debug</span><span>,</span> <span>Clone</span><span>,</span> <span>Copy</span><span>)]</span>
<span>#[</span>repr<span>(</span><span>u32</span><span>)]</span>
<span>#[</span>allow<span>(</span>dead_code<span>)]</span>
<span>pub</span> <span>enum</span> ResultCode <span>{</span>
    RestartMarkerReply = <span>110</span>,
    ServiceReadInXXXMinutes = <span>120</span>,
    DataConnectionAlreadyOpen = <span>125</span>,
    FileStatusOk = <span>150</span>,
    <span>Ok</span> = <span>200</span>,
    CommandNotImplementedSuperfluousAtThisSite = <span>202</span>,
    SystemStatus = <span>211</span>,
    DirectoryStatus = <span>212</span>,
    FileStatus = <span>213</span>,
    HelpMessage = <span>214</span>,
    SystemType = <span>215</span>,
    ServiceReadyForNewUser = <span>220</span>,
    ServiceClosingControlConnection = <span>221</span>,
    DataConnectionOpen = <span>225</span>,
    ClosingDataConnection = <span>226</span>,
    EnteringPassiveMode = <span>227</span>,
    UserLoggedIn = <span>230</span>,
    RequestedFileActionOkay = <span>250</span>,
    PATHNAMECreated = <span>257</span>,
    UserNameOkayNeedPassword = <span>331</span>,
    NeedAccountForLogin = <span>332</span>,
    RequestedFileActionPendingFurtherInformation = <span>350</span>,
    ServiceNotAvailable = <span>421</span>,
    CantOpenDataConnection = <span>425</span>,
    ConnectionClosed = <span>426</span>,
    FileBusy = <span>450</span>,
    LocalErrorInProcessing = <span>451</span>,
    InsufficientStorageSpace = <span>452</span>,
    UnknownCommand = <span>500</span>,
    InvalidParameterOrArgument = <span>501</span>,
    CommandNotImplemented = <span>502</span>,
    BadSequenceOfCommands = <span>503</span>,
    CommandNotImplementedForThatParameter = <span>504</span>,
    NotLoggedIn = <span>530</span>,
    NeedAccountForStoringFiles = <span>532</span>,
    FileNotFound = <span>550</span>,
    PageTypeUnknown = <span>551</span>,
    ExceededStorageAllocation = <span>552</span>,
    FileNameNotAllowed = <span>553</span>,
<span>}</span></pre>
<p class="calibre3">We're now ready to start working on the FTP server itself.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Using Tokio</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Tokio is based on the lower-level crate mio, which is itself directly based on system calls such as <span><kbd class="calibre14">epoll</kbd></span> (Linux), <span><kbd class="calibre14">kqueue</kbd></span> (FreeBSD), and IOCP (Windows). This crate is also based on the <span><kbd class="calibre14">futures</kbd></span> crate, which provides abstractions to reason about a value (or multiple values) that will be available later. As I told you when using asynchronous I/O, the calls do not block so we need a way to know when the result of a read is available. This is where <span><kbd class="calibre14">Future</kbd></span> and <span><kbd class="calibre14">Stream</kbd></span>, two abstractions from the <span><kbd class="calibre14">futures</kbd></span> crate, come into play.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Tokio event loop</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Tokio also provides an event loop, on which we will be able to execute some code (with <kbd class="calibre14">futures</kbd>) that will be executed when some I/O events happen, such as when the result of a socket read is ready. To do so, the event loop will register events on specific file descriptors that represent sockets. It registers these events using the aforementioned system calls and then waits for any of the registered events to happen. The file descriptors and the system calls are low-level stuff that we do not need to know to use <span><kbd class="calibre14">tokio</kbd></span>, but it is important to understand how it works at the lower level. For instance, <span><kbd class="calibre14">epoll</kbd></span> does not support regular files, so if you try to wait for an event to happen on a regular file, it could block even though we're using asynchronous I/O which should not block.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Using futures</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">A <kbd class="calibre14">future</kbd> represents a value that will be available later, or an error, similar to the <span><kbd class="calibre14">Result</kbd></span> type. A <kbd class="calibre14">stream</kbd> represents multiple values (or errors) that will be available at different times in the <kbd class="calibre14">future</kbd>, similar to an <span><kbd class="calibre14">Iterator&lt;Result&lt;T&gt;&gt;</kbd></span>. This crate provides many combinators such as <span><kbd class="calibre14">and_then()</kbd></span>, <span><kbd class="calibre14">map()</kbd></span>, and others similar to the one available on the <span><kbd class="calibre14">Result</kbd></span> type. But, we won't use them, preferring the <span><kbd class="calibre14">async</kbd></span>/<span><kbd class="calibre14">await</kbd></span> syntax that we'll see later.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Handling errors</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Before we start coding the FTP server, let's talk about how we'll be handling the errors.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Unwrapping</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In the previous projects, we used the <span><kbd class="calibre14">unwrap()</kbd></span> or <span><kbd class="calibre14">expect()</kbd></span> methods a lot. These methods are handy for fast prototyping, but when we want to write high-quality software, we should avoid them in most cases. Since we're writing an FTP server, a software that must keep running for a long time, we don't want it to crash because we called <span><kbd class="calibre14">unwrap()</kbd></span> and a client sent a bad command. So, we'll do proper error handling.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Custom error type</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Since we can get different types of errors and we want to keep track of all of them, we'll create a custom error type. Let's create a new module in which we'll put this new type:</p>
<pre class="calibre22"><span>mod</span> error;</pre>
<p class="calibre3">Add it to the <span><kbd class="calibre14">src/error.rs</kbd></span> file:</p>
<pre class="calibre22"><span>use</span> std::io;
<span>use</span> std::<span>str</span>::Utf8Error;
<span>use</span> std::string::FromUtf8Error;

<span>pub</span> <span>enum</span> Error <span>{</span>
    FromUtf8(FromUtf8Error),
    Io(io::Error),
    Msg(<span>String</span>),
    Utf8(Utf8Error),
<span>}</span></pre>
<p class="calibre3">Here, we have an enum representing the different errors that can happen in our FTP server to be implemented. There are UTF-8 errors since FTP is a string-based protocol and I/O errors because we communicate over the network and communication issues can happen. We created variants for error types coming from the standard library, which will be helpful later when we want to compose different types of errors. We also created a variant <span><kbd class="calibre14">Msg</kbd></span> for our own errors and we represent them as a <span><kbd class="calibre14">String</kbd></span> since we only want to show them in the terminal (we could also log them to <span><kbd class="calibre14">syslog</kbd></span>, for instance).</p>
<p class="calibre3">This is the standard way in Rust to represent an error type. It's a good practice to create this type, especially if your crate is a library, so that the users of your crate can know exactly why an error happened.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Displaying the error</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Since we want to print the error to the terminal, we'll implement the <span><kbd class="calibre14">Display</kbd></span> trait for our <span><kbd class="calibre14">Error</kbd></span> type:</p>
<pre class="calibre22"><span>use</span> std::fmt::<span>{</span><span>self</span>, <span>Display</span>, Formatter<span>}</span>;

<span>use</span> <span>self</span>::Error::*;

<span>impl</span> <span>Display</span> <span>for</span> Error <span>{</span>
    <span>fn</span> fmt(&amp;<span>self</span>, formatter: &amp;<span>mut</span> Formatter) -&gt; fmt::<span>Result</span> <span>{</span>
        <span>match</span> *<span>self</span> <span>{</span>
            FromUtf8(<span>ref</span> error) =&gt; error.fmt(formatter),
            Io(<span>ref</span> error) =&gt; error.fmt(formatter),
            Utf8(<span>ref</span> error) =&gt; error.fmt(formatter),
            Msg(<span>ref</span> msg) =&gt; <span>write!</span>(formatter, <span>"{}"</span>, msg),
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">For the three cases where we wrap an error from another type, we just call the corresponding <span><kbd class="calibre14">fmt()</kbd></span> method of these errors. In the case that it is a <span><kbd class="calibre14">Msg</kbd></span>, we write the string using the <span><kbd class="calibre14">write!</kbd></span> macro. This macro is a bit similar to <span><kbd class="calibre14">print!</kbd></span>, but needs a parameter to specify where to write the formatted data.</p>
<p class="calibre3">It is not very helpful in our case, but it is recommended to also implement the <span><kbd class="calibre14">Error</kbd></span> trait for custom error types:</p>
<pre class="calibre22"><span>use</span> std::error;

<span>impl</span> error::Error <span>for</span> Error <span>{</span>
    <span>fn</span> description(&amp;<span>self</span>) -&gt; &amp;<span>str</span> <span>{</span>
        <span>match</span> *<span>self</span> <span>{</span>
            FromUtf8(<span>ref</span> error) =&gt; error.description(),
            Io(<span>ref</span> error) =&gt; error.description(),
            Utf8(<span>ref</span> error) =&gt; error.description(),
            Msg(<span>ref</span> msg) =&gt; msg,
        <span>}</span>
    <span>}</span>

    <span>fn</span> cause(&amp;<span>self</span>) -&gt; <span>Option</span>&lt;&amp;error::Error&gt; <span>{</span>
        <span>let</span> cause: &amp;error::Error =
            <span>match</span> *<span>self</span> <span>{</span>
                FromUtf8(<span>ref</span> error) =&gt; error,
                Io(<span>ref</span> error) =&gt; error,
                Utf8(<span>ref</span> error) =&gt; error,
                Msg(_) =&gt; <span>return</span> <span>None</span>,
            <span>}</span>;
        <span>Some</span>(cause)
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The only required method of this trait is <span><kbd class="calibre14">description()</kbd></span>, which returns a short description of the error. Again, in the three cases, we just call the <span><kbd class="calibre14">description()</kbd></span> method from the wrapped type itself. And, for our <span><kbd class="calibre14">Msg</kbd></span> variant, we return the wrapped message.</p>
<p class="calibre3">It is possible that we don't have a string to return from this method. If it is the case, we can just return <span><kbd class="calibre14">&amp;'static str</kbd></span>, like this:</p>
<pre class="calibre22">Io(_) =&gt; "IO error",</pre>
<p class="calibre3">The <span><kbd class="calibre14">cause()</kbd></span> method is optional and is used to return the cause of the error. Here, we return the inner error when there's one in the variant and return <span><kbd class="calibre14">None</kbd></span> for our <span><kbd class="calibre14">Msg</kbd></span> variant.</p>
<p class="calibre3">The trait <span><kbd class="calibre14">Error</kbd></span> requires the <span><kbd class="calibre14">Self</kbd></span> type to implement both <span><kbd class="calibre14">Display</kbd></span> and <span><kbd class="calibre14">Debug</kbd></span>. We implemented <span><kbd class="calibre14">Display</kbd></span> earlier, but we don't implement <span><kbd class="calibre14">Debug</kbd></span> yet. Let's fix that by adding an attribute in front of the type declaration:</p>
<pre class="calibre22"><span>#[</span>derive<span>(</span><span>Debug</span><span>)]</span>
<span>pub</span> <span>enum</span> Error <span>{</span>
    FromUtf8(FromUtf8Error),
    Io(io::Error),
    Msg(<span>String</span>),
    Utf8(Utf8Error),
<span>}</span></pre>
<p class="calibre3">It is good practice to provide a type alias named <span><kbd class="calibre14">Result</kbd></span> that is specialized for our error type. Let's write one:</p>
<pre class="calibre22">use std::result;

pub type Result&lt;T&gt; = result::Result&lt;T, Error&gt;;</pre>
<p class="calibre3">By doing so, we hide the original <span><kbd class="calibre14">Result</kbd></span> type from the standard library. That's why we're specifying a qualified version of this type. Otherwise, the compiler will assume that it is a recursive type, which is not the case here. We'll have to be careful when we import this type in other modules, because it hides the <span><kbd class="calibre14">Result</kbd></span> type. In case we want to use the original <span><kbd class="calibre14">Result</kbd></span> type, we'll have to use the same trick; qualifying it.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Composing error types</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The last thing we need to do in order to use all the good practices for error types in Rust is to make them easy to compose, because, for now, if we have another error type, such as <span><kbd class="calibre14">io::Error</kbd></span>, we would need to use the following code every time we have another type:</p>
<pre class="calibre22"><span>let</span> val =
    <span>match</span> result <span>{</span>
        <span>Ok</span>(val) =&gt; val,
        <span>Err</span>(error) =&gt; <span>return</span> <span>Err</span>(Error::Io(error)),
    <span>}</span>;</pre>
<p class="calibre3">This can quickly become cumbersome. To improve that, we'll implement the <span><kbd class="calibre14">From</kbd></span> trait for different error types:</p>
<pre class="calibre22"><span>impl</span> From&lt;io::Error&gt; <span>for</span> Error <span>{</span>
    <span>fn</span> from(error: io::Error) -&gt; <span>Self</span> <span>{</span>
        Io(error)
    <span>}</span>
<span>}</span>

<span>impl</span>&lt;<span>'a</span>&gt; From&lt;&amp;<span>'a</span> <span>str</span>&gt; <span>for</span> Error <span>{</span>
    <span>fn</span> from(message: &amp;<span>'a</span> <span>str</span>) -&gt; <span>Self</span> <span>{</span>
        Msg(message.to_string())
    <span>}</span>
<span>}</span>

<span>impl</span> From&lt;Utf8Error&gt; <span>for</span> Error <span>{</span>
    <span>fn</span> from(error: Utf8Error) -&gt; <span>Self</span> <span>{</span>
        Utf8(error)
    <span>}</span>
<span>}</span>

<span>impl</span> From&lt;FromUtf8Error&gt; <span>for</span> Error <span>{</span>
    <span>fn</span> from(error: FromUtf8Error) -&gt; <span>Self</span> <span>{</span>
        FromUtf8(error)
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">These implementations are easy to understand: if we have an <span><kbd class="calibre14">io::Error</kbd></span>, we just wrap them in the corresponding variant. We also added a convenient conversion from the <span><kbd class="calibre14">&amp;str</kbd></span> type.</p>
<p class="calibre3">This will allow us to use the following, wh<span>ich is not really better, but the good old </span><span><kbd class="calibre14">?</kbd></span><span> operator will help us to reduce the boilerplate</span>:</p>
<pre class="calibre22"><span>let</span> val =
    <span>match</span> result <span>{</span>
        <span>Ok</span>(val) =&gt; val,
        <span>Err</span>(error) =&gt; <span>return</span> <span>Err</span>(error.into()),
    <span>}</span>;</pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">The ? operator, revisited</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">This operator will not only return the error if there is one, but will also convert it to the required type. It converts it with a call to <span><kbd class="calibre14">Into::into()</kbd></span>, <span><kbd class="calibre14">Into</kbd></span> being a trait. But why did we implement the <span><kbd class="calibre14">From</kbd></span> trait, instead of <span><kbd class="calibre14">Into</kbd></span>? Because there's a generic implementation of <span><kbd class="calibre14">Into</kbd></span> which is based on <span><kbd class="calibre14">From</kbd></span>:</p>
<pre class="calibre22"><span>impl</span>&lt;T, U&gt; Into&lt;U&gt; <span>for</span> T
<span>where</span> U: From&lt;T&gt;,</pre>
<p class="calibre3">Thanks to this implementation, we rarely need to implement the <span><kbd class="calibre14">Into</kbd></span> trait ourselves. We only need to implement the <span><kbd class="calibre14">From</kbd></span> trait.</p>
<p class="calibre3">This means that we can rewrite the previous code as follows:</p>
<pre class="calibre22"><span>let</span> val = result?;</pre>
<p class="calibre3">And it will behave exactly the same as before.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Starting the Tokio event loop</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In <span><kbd class="calibre14">tokio</kbd></span>, the object we need to use to manage an event loop is <span><kbd class="calibre14">Core</kbd></span>. Here's how we start an event loop using <span><kbd class="calibre14">tokio</kbd></span> (in the <kbd class="calibre14">main</kbd> module):</p>
<pre class="calibre22"><span>use</span> tokio_core::reactor::Core;

<span>fn</span> main() <span>{</span>
    <span>let</span> <span>mut</span> core = Core::new().expect(<span>"Cannot create tokio Core"</span>);
    <span>if</span> <span>let</span> <span>Err</span>(error) = core.run(server()) <span>{</span>
        <span>println!</span>(<span>"Error running the server: {}"</span>, error);
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We first create a new <span><kbd class="calibre14">Core</kbd></span> object, and then call the <span><kbd class="calibre14">run()</kbd></span> <span>method</span><span> </span><span>to start the event loop. The latter method will return when the provided future ends. Here, we call</span> <span><kbd class="calibre14">server()</kbd></span> <span>to get the future, so let's write this function:</span></p>
<pre class="calibre22"><span>use</span> std::io;

<span>use</span> futures::prelude::async;

<span>#[</span>async<span>]</span>
<span>fn</span> server() -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
    <span>Ok</span>(())
<span>}</span></pre>
<p class="calibre3">As you can see, we use the <span><kbd class="calibre14">#[async]</kbd></span> attribute. Since attributes are currently instable in Rust, we had to specify that we are using the <span><kbd class="calibre14">proc_macro</kbd></span> feature. We also import the <span><kbd class="calibre14">async</kbd></span> attribute from the <span><kbd class="calibre14">futures_await</kbd></span> crate (which was imported under the name <span><kbd class="calibre14">futures</kbd></span>). So don't forget the <span><kbd class="calibre14">#![feature]</kbd></span> attribute and the <span><kbd class="calibre14">extern crate</kbd></span> statements at the top.</p>
<p class="calibre3">This attribute allows us to write a normal function, returning a <span><kbd class="calibre14">Result</kbd></span>, and will convert this function to actually return a <span><kbd class="calibre14">Future</kbd></span>. This function does nothing and returns <span><kbd class="calibre14">Ok(())</kbd></span>, so when you run the program, it will end immediately.</p>
<p class="calibre3">There's another syntax we could have used that is provided by the <span><kbd class="calibre14">futures-await</kbd></span> crate:</p>
<pre class="calibre22"><span>use</span> futures::prelude::async_block;

<span>fn</span> main() <span>{</span>
    <span>let</span> <span>mut</span> core = Core::new().expect(<span>"Cannot create tokio Core"</span>);
    <span>let</span> server = <span>async_block!</span> <span>{</span>
        <span>Ok</span>(())
    <span>}</span>;
    <span>let</span> result: <span>Result</span>&lt;_, io::Error&gt; = core.run(server);
    <span>if</span> <span>let</span> <span>Err</span>(error) = result <span>{</span>
        <span>println!</span>(<span>"Error running the server: {}"</span>, error);
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We won't use this syntax in our FTP server, but it is worth knowing about. By using an <span><kbd class="calibre14">async_block</kbd></span>, we are not required to create a new function.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Starting the server</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The program we just wrote does absolutely nothing, so let's update it so that it at least starts a server, using <span><kbd class="calibre14">tokio</kbd></span>. Let's write an actual body to our <span><kbd class="calibre14">server()</kbd></span> function:</p>
<pre class="calibre22"><span>use</span> std::net::<span>{</span>IpAddr, Ipv4Addr, SocketAddr<span>}</span>;

<span>use</span> tokio_core::reactor::Handle;
<span>use</span> tokio_core::net::TcpListener;

<span>#[</span>async<span>]</span>
<span>fn</span> server(handle: Handle) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
    <span>let</span> port = <span>1234</span>;
    <span>let</span> addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(<span>127</span>, <span>0</span>, <span>0</span>, <span>1</span>)), port);
    <span>let</span> listener = TcpListener::bind(&amp;addr, &amp;handle)?;

    <span>println!</span>(<span>"Waiting clients on port {}..."</span>, port);
    <span>#[</span>async<span>]</span>
    <span>for</span> (stream, addr) <span>in</span> listener.incoming() <span>{</span>
        <span>let</span> address = <span>format!</span>(<span>"[address : {}]"</span>, addr);
        <span>println!</span>(<span>"New client: {}"</span>, address);
        handle.spawn(handle_client(stream));
        <span>println!</span>(<span>"Waiting another client..."</span>);
    <span>}</span>
    <span>Ok</span>(())
<span>}</span></pre>
<p class="calibre3">The function now takes a <span><kbd class="calibre14">Handle</kbd></span>, which will be useful to specify on which event loop the server must run. We start this function by specifying on which port we want to start the server by creating a <span><kbd class="calibre14">SocketAddr</kbd></span>. Then, we create a <span><kbd class="calibre14">TcpListener</kbd></span> in a similar way to how we would create a synchronous <span><kbd class="calibre14">TcpListener</kbd></span> from the standard library. The difference here is that we also send the <span><kbd class="calibre14">handle</kbd></span> as an argument to specify on which event loop we want the server to run. After that, we use the <span><kbd class="calibre14">#[async]</kbd></span> attribute again, but on a <span><kbd class="calibre14">for</kbd></span> loop this time.</p>
<p class="calibre3">Async <span><kbd class="calibre14">for</kbd></span> loops are used to iterate over a <span><kbd class="calibre14">Stream</kbd></span>, returning an error if there is one. These async loops can only be used in an <span><kbd class="calibre14">#[async]</kbd></span> function. In the loop, we spawn the future returned by <span><kbd class="calibre14">handle_client()</kbd></span>. Spawning a future means that it will be executed and handled by the event loop. The difference with <span><kbd class="calibre14">Core::run()</kbd></span> is that the future must return <span><kbd class="calibre14">()</kbd></span> and the error should also be <span><kbd class="calibre14">()</kbd></span>.</p>
<p class="calibre3">Now that this function takes an argument, we'll need to update the <kbd class="calibre14">main</kbd> function:</p>
<pre class="calibre22"><span>fn</span> main() <span>{</span>
    <span>let</span> <span>mut</span> core = Core::new().expect(<span>"Cannot create tokio Core"</span>);
    <span>let</span> handle = core.handle();
    <span>if</span> <span>let</span> <span>Err</span>(error) = core.run(server(handle)) <span>{</span>
        <span>println!</span>(<span>"Error running the server: {}"</span>, error);
    <span>}</span>
<span>}</span></pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Handling clients</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's now see the <span><kbd class="calibre14">handle_client()</kbd></span> function we've just mentioned:</p>
<pre class="calibre22"><span>use</span> std::result;

<span>use</span> futures::prelude::await;

<span>#[</span>async<span>]</span>
<span>use</span> tokio_core::net::TcpStream;

<span>fn</span> handle_client(stream: TcpStream) -&gt; result::<span>Result</span>&lt;(), ()&gt; <span>{</span>
    <span>await!</span>(client(stream))
        .map_err(|error| <span>println!</span>(<span>"Error handling client: {}"</span>, error))
<span>}</span></pre>
<p class="calibre3">It is a simple wrapper over the <span><kbd class="calibre14">client</kbd></span> future. Here, we used a new macro, <span><kbd class="calibre14">await!</kbd></span>, which allows us to write asynchronous code in an asynchronous way. When the result of the future inside <span><kbd class="calibre14">await!()</kbd></span> is not ready, the event loop will execute other stuff, and when it's ready it will continue executing the code after the <span><kbd class="calibre14">await!()</kbd></span>. In this case, we print the error returned by the <span><kbd class="calibre14">client</kbd></span> future. This is why we needed a wrapper.</p>
<p class="calibre3">Now, let's write this <span><kbd class="calibre14">client</kbd></span> future:</p>
<pre class="calibre22"><span>use</span> futures::<span>{</span>Sink, Stream<span>}</span>;
<span>use</span> futures::stream::SplitSink;
<span>use</span> tokio_io::AsyncRead;
<span>use</span> tokio_io::codec::Framed;

<span>use</span> codec::FtpCodec;
<span>use</span> error::<span>Result</span>;
<span>use</span> ftp::<span>{</span>Answer, ResultCode<span>}</span>;

<span>#[</span>async<span>]</span>
<span>fn</span> client(stream: TcpStream) -&gt; <span>Result</span>&lt;()&gt; <span>{</span>
    <span>let</span> (writer, reader) = stream.framed(FtpCodec).split();
    <span>let</span> writer = <span>await!</span>(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser, <br class="calibre6"/><span>    "Welcome to this FTP server!"</span>)))?;
    <span>let</span> <span>mut</span> client = Client::new(writer);
    <span>#[</span>async<span>]</span>
    <span>for</span> cmd <span>in</span> reader <span>{</span>
        client = <span>await!</span>(client.handle_cmd(cmd))?;
    <span>}</span>
    <span>println!</span>(<span>"Client closed"</span>);
    <span>Ok</span>(())
<span>}</span></pre>
<p class="calibre3">Here, we specify that the <span><kbd class="calibre14">stream</kbd></span> will be handled by a <span><kbd class="calibre14">FtpCodec</kbd></span>, which means that we'll be able to encode and decode structured data instead of dealing with bytes directly. We'll write this <span><kbd class="calibre14">FtpCodec</kbd></span> soon. Then, we split the stream between a <kbd class="calibre14">reader</kbd> and a <kbd class="calibre14">writer</kbd>. This <span><kbd class="calibre14">split()</kbd></span> method is very useful in Rust, because of ownership: we cannot have two owners, one that will write to the socket and another that will read to it. To fix this issue, we split the stream and we can now have an owner for the <kbd class="calibre14">reader</kbd> and another owner for the <kbd class="calibre14">writer</kbd>.</p>
<p class="calibre3">Then, we use the <span><kbd class="calibre14">writer</kbd></span> to send a welcome message. Again, we use the <span><kbd class="calibre14">await!</kbd></span> macro to specify that the code after will be executed when the message is sent (but without blocking the whole program, thanks to asynchronous I/O). Next, we create a <span><kbd class="calibre14">Client</kbd></span> which will be the object that will manage a client, by executing the appropriate actions when it receives commands and sending the right responses.</p>
<p class="calibre3">After that, we use again an <span><kbd class="calibre14">#[async] for</kbd></span> loop to iterate over a stream; here, we iterate over the stream of the data received by this specific client. In the <span><kbd class="calibre14">for</kbd></span> loop, we call the <span><kbd class="calibre14">handle_cmd()</kbd></span> method that we will soon write. This method, as its name indicates, will handle the command received from this FTP client, act accordingly, and send a response back. Here, we use <span><kbd class="calibre14">await!()?</kbd></span> with a question mark at the end. The <span><kbd class="calibre14">futures-await</kbd></span> crate allows us to do so; this means that if the future returned an error, this error will propagate to the <span><kbd class="calibre14">client</kbd></span> future, which is the same semantic for the normal <span><kbd class="calibre14">?</kbd></span> operator used in a function returning a <span><kbd class="calibre14">Result</kbd></span>. We'll see why we reassign the result to <span><kbd class="calibre14">client</kbd></span> when we write the <span><kbd class="calibre14">handle_cmd()</kbd></span> method.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Handling commands</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To handle the commands received by the FTP server, we'll have a <span><kbd class="calibre14">Client</kbd></span> struct:</p>
<pre class="calibre22"><span>type</span> Writer = SplitSink&lt;Framed&lt;TcpStream, FtpCodec&gt;&gt;;

<span>struct</span> Client <span>{</span>
    writer: Writer,
<span>}</span></pre>
<p class="calibre3">The client contains a <span><kbd class="calibre14">Writer</kbd></span> object that will be useful to send messages to the client. The <span><kbd class="calibre14">Writer</kbd></span> type represents a <span><kbd class="calibre14">Sink</kbd></span> that has been split, and uses the <span><kbd class="calibre14">FtpCodec</kbd></span> on a <span><kbd class="calibre14">TcpStream</kbd></span>. A <span><kbd class="calibre14">Sink</kbd></span> is the opposite of a <span><kbd class="calibre14">Stream</kbd></span>: instead of representing a sequence of values that are received, it represents a sequence of values that are sent.</p>
<p class="calibre3">We used two methods on <span><kbd class="calibre14">Client</kbd></span>, so let's write them:</p>
<pre class="calibre22"><span>use</span> cmd::Command;

<span>impl</span> Client <span>{</span>
    <span>fn</span> new(writer: Writer) -&gt; Client <span>{</span>
        Client <span>{</span>
            writer,
        <span>}</span>
    <span>}</span>

    <span>#[</span>async<span>]</span>
    <span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
        <span>Ok</span>(<span>self</span>)
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The constructor is very simple and creates the <span><kbd class="calibre14">struct</kbd></span> with the provided argument. The <span><kbd class="calibre14">handle_cmd()</kbd></span> receives the command sent to the FTP server by this specific client and will handle them; we'll write the code to handle them progressively in this chapter and the next. For now, it only returns <kbd class="calibre14">self</kbd>. Also, take note that this method receives <span><kbd class="calibre14">self</kbd></span> by move, instead of by <span><kbd class="calibre14">reference</kbd></span>. This is due to a current limitation of the <span><kbd class="calibre14">futures-await</kbd></span> crate: for now, async functions cannot take a reference. This issue will probably be fixed later, which will make the code even better. This is why we reassigned to the <span><kbd class="calibre14">client</kbd></span> variable in the <span><kbd class="calibre14">client</kbd></span> function:</p>
<pre class="calibre22">client = <span>await!</span>(client.handle_cmd(cmd))?;</pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">FTP codec</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The only remaining thing to code before we can try our FTP server is the <kbd class="calibre14">codec</kbd>. So, let's create a new module for the <kbd class="calibre14">codec</kbd>:</p>
<pre class="calibre22"><span>mod</span> codec;</pre>
<p class="calibre3">In the <span><kbd class="calibre14">src/codec.rs</kbd></span> <span>file</span><span>, we'll create our FTP <kbd class="calibre14">codec</kbd>:</span></p>
<pre class="calibre22"><span>pub</span> <span>struct</span> FtpCodec;</pre>
<p class="calibre3">To create a <kbd class="calibre14">codec</kbd>, we must implement the traits <span><kbd class="calibre14">Decoder</kbd></span> and <span><kbd class="calibre14">Encoder</kbd></span>. These traits come from the <span><kbd class="calibre14">tokio-io</kbd></span> <span>crate</span><span>:</span></p>
<pre class="calibre22"><span>use</span> tokio_io::codec::<span>{</span>Decoder, Encoder<span>}</span>;</pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Decoding FTP commands</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's first write the decoder:</p>
<pre class="calibre22"><span>use</span> std::io;

<span>use</span> bytes::BytesMut;

<span>use</span> cmd::Command;
<span>use</span> error::Error;

<span>impl</span> Decoder <span>for</span> FtpCodec <span>{</span>
    <span>type</span> Item = Command;
    <span>type</span> Error = io::Error;

    <span>fn</span> decode(&amp;<span>mut</span> <span>self</span>, buf: &amp;<span>mut</span> BytesMut) -&gt;<br class="calibre6"/>     io::<span>Result</span>&lt;<span>Option</span>&lt;Command&gt;&gt; <span>{</span>
        <span>if</span> <span>let</span> <span>Some</span>(index) = find_crlf(buf) <span>{</span>
            <span>let</span> line = buf.split_to(index);
            buf.split_to(<span>2</span>); <span>// Remove \r\n.</span>
            Command::new(line.to_vec())
                .map(|command| <span>Some</span>(command))
                .map_err(Error::to_io_error)
        <span>}</span> <span>else</span> <span>{</span>
            <span>Ok</span>(<span>None</span>)
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">Decoder</kbd></span> trait has two associated types, <span><kbd class="calibre14">Item</kbd></span> and <span><kbd class="calibre14">Error</kbd></span>. The former is the type <span>produced</span><span> </span><span>when we're able to decode a sequence of bytes. The latter is the type of the error. We first check if there the bytes</span> <span><kbd class="calibre14">CR</kbd></span> <span>and</span> <span><kbd class="calibre14">LF</kbd></span><span>. If we don't find them, we return</span> <span><kbd class="calibre14">Ok(None)</kbd></span> <span>to indicate that we need more bytes to parse the command. If we find them, we get the line of the command, excluding these bytes. Then, we skip these bytes so that the next parsing does not see them. Finally, we parse the line with</span> <span><kbd class="calibre14">Command::new()</kbd>.</span></p>
<p class="calibre3">We used two new functions here that we must implement. The first one is the <span><kbd class="calibre14">Error::to_io_error()</kbd></span> method that we'll add to the <span><kbd class="calibre14">error</kbd></span> module:</p>
<pre class="calibre22">impl Error {
    pub fn to_io_error(self) -&gt; io::Error {
        match self {
            Io(error) =&gt; error,
            FromUtf8(_) | Msg(_) | Utf8(_) =&gt; <br class="calibre6"/>             io::ErrorKind::Other.into(),
        }
    }
}</pre>
<p class="calibre3">If we have an <span><kbd class="calibre14">Io</kbd></span> error, we return it. Otherwise, we return the <span><kbd class="calibre14">Other</kbd></span> kind of I/O error.</p>
<p class="calibre3">The <span><kbd class="calibre14">decode()</kbd></span> methods also uses the following function:</p>
<pre class="calibre22"><span>fn</span> find_crlf(buf: &amp;<span>mut</span> BytesMut) -&gt; <span>Option</span>&lt;<span>usize</span>&gt; <span>{</span>
    buf.windows(<span>2</span>)
        .position(|bytes| bytes == b<span>"</span><span>\r\n</span><span>"</span>)
<span>}</span></pre>
<p class="calibre3">This returns the position of the byte string <span><kbd class="calibre14">"\r\n"</kbd></span> if it is present. Remember that this string is the delimiter in the FTP protocol.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Encoding FTP commands</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We still need to write an <span><kbd class="calibre14">Encoder</kbd></span> in order to have a <kbd class="calibre14">codec</kbd> that can send commands to FTP clients:</p>
<pre class="calibre22"><span>use</span> ftp::Answer;

<span>impl</span> Encoder <span>for</span> FtpCodec <span>{</span>
    <span>type</span> Item = Answer;
    <span>type</span> Error = io::Error;

    <span>fn</span> encode(&amp;<span>mut</span> <span>self</span>, answer: Answer, buf: &amp;<span>mut</span> BytesMut) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
        <span>let</span> answer =
            <span>if</span> answer.message.is_empty() <span>{</span>
                <span>format!</span>(<span>"{}</span><span>\r\n</span><span>"</span>, answer.code <span>as</span> <span>u32</span>)
            <span>}</span> <span>else</span> <span>{</span>
                <span>format!</span>(<span>"{} {}</span><span>\r\n</span><span>"</span>, answer.code <span>as</span> <span>u32</span>, <br class="calibre6"/>                 answer.message)
            <span>}</span>;
        buf.extend(answer.as_bytes());
        <span>Ok</span>(())
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, if we have a non-empty message, we push it to the buffer, preceded by the FTP code number. Otherwise, we only push this code number to the buffer.</p>
<p class="calibre3">We can now try the FTP server in FileZilla to see the following result:</p>
<div class="mce-root1"><img src="../images/00043.jpeg" class="calibre36"/><em class="calibre21">Figure 9.1</em></div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Handling commands</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Our <span><kbd class="calibre14">handle_cmd()</kbd></span> method does nothing, for now, so let's update it. First of all, we'll need a method to send a response to a client:</p>
<pre class="calibre22">impl Client {
    #[async]
    fn send(mut self, answer: Answer) -&gt; Result&lt;Self&gt; {
        self.writer = await!(self.writer.send(answer))?;
        Ok(self)
    }
}</pre>
<p class="calibre3">This simply calls the <span><kbd class="calibre14">send()</kbd></span> method of the <kbd class="calibre14">writer</kbd>. Since it consumes it, we reassign the result to the attribute.</p>
<p class="calibre3">Now, we'll handle the <span><kbd class="calibre14">USER</kbd></span> FTP command:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>println!</span>(<span>"Received command: {:?}"</span>, cmd);
    <span>match</span> cmd <span>{</span>
        Command::User(content) =&gt; <span>{</span>
            <span>if</span> content.is_empty() <span>{</span>
                <span>self</span> = <span>await! <br class="calibre6"/></span>          (<span>self</span>.send(Answer::new(ResultCode::InvalidParameterOrArgument, <span>"Invalid  <br class="calibre6"/>           username"</span>)))?;
            <span>}</span> <span>else</span> <span>{</span>
                <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::UserLoggedIn,  <br class="calibre6"/>                &amp;<span>format!</span>(<span>"Welcome {}!"</span>, content))))?;
            <span>}</span>
        <span>}</span>
        Command::Unknown(s) =&gt;
            <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::UnknownCommand,
            &amp;<span>format!</span>(<span>"</span><span>\"</span><span>{}</span><span>\"</span><span>: Not implemented"</span>, s))))? ,
        _ =&gt; <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::CommandNotImplemented,  <br class="calibre6"/><span>       "Not implemented"</span>)))?,
    <span>}</span>
    <span>Ok</span>(<span>self</span>)
<span>}</span></pre>
<p class="calibre3">Here, we pattern match to know which command was sent by the client. If it is not <span><kbd class="calibre14">User</kbd></span>, we send a response to say that the command is not implemented. If it is <span><kbd class="calibre14">User</kbd></span>, we check the content and if it is good, we send the welcome message. This is very similar to what we did in the previous chapter.</p>
<p class="calibre3">If we run the server again, we'll see the following:</p>
<div class="mce-root1">&gt;<img src="../images/00044.jpeg" class="calibre36"/><em class="calibre21">Figure 9.2</em></div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Managing the current working directory</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">There are still a few commands missing before we can see the files in the FTP client. Let's now add the command to print the current directory and to change it.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Printing the current directory</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">First of all, we'll need a new attribute for our <span><kbd class="calibre14">Client</kbd></span> structure to specify what the current directory <span>is:</span><span> </span></p>
<pre class="calibre22"><span>use</span> std::path::PathBuf;

<span>struct</span> Client <span>{</span>
    cwd: PathBuf,
    writer: Writer,
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">cwd</kbd></span> attribute stands for current working directory. We also need to update the <span><kbd class="calibre14">Client</kbd></span> constructor accordingly:</p>
<pre class="calibre22"><span>impl</span> Client <span>{</span>
    <span>fn</span> new(writer: Writer) -&gt; Client <span>{</span>
        Client <span>{</span>
            cwd: PathBuf::from(<span>"/"</span>),
            writer,
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Now, we can add the handler for the <span><kbd class="calibre14">PWD</kbd></span> command:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>println!</span>(<span>"Received command: {:?}"</span>, cmd);
    <span>match</span> cmd <span>{</span>
        Command::Pwd =&gt; <span>{</span>
            <span>let</span> msg = <span>format!</span>(<span>"{}"</span>, <span>self</span>.cwd.to_str().unwrap_or(<span>""</span>));
            <span>if</span> !msg.is_empty() <span>{</span>
                <span>let</span> message = <span>format!</span>(<span>"</span><span>\"</span><span>/{}</span><span>\"</span><span> "</span>, msg);
                <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::PATHNAMECreated,  <br class="calibre6"/>                &amp;message)))?;
            <span>}</span> <span>else</span> <span>{</span>
                <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::FileNotFound, <span>"No  <br class="calibre6"/>                such file or directory"</span>)))?;
            <span>}</span>
        <span>}</span>
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">So, again, we have a code similar to the previous chapter.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Changing the current directory</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's add another case in our <span><kbd class="calibre14">match</kbd></span> expression in the <span><kbd class="calibre14">handle_cmd()</kbd></span> method:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>match</span> cmd <span>{</span>
        Command::Cwd(directory) =&gt; <span>self</span> = <span>await!</span>(<span>self</span>.cwd(directory))?,
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">It simply calls the following method:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> cwd(<span>mut</span> <span>self</span>, directory: PathBuf) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>let</span> path = <span>self</span>.cwd.join(&amp;directory);
    <span>let</span> (new_self, res) = <span>self</span>.complete_path(path);
    <span>self</span> = new_self;
    <span>if</span> <span>let</span> <span>Ok</span>(dir) = res <span>{</span>
        <span>let</span> (new_self, res) = <span>self</span>.strip_prefix(dir);
        <span>self</span> = new_self;
        <span>if</span> <span>let</span> <span>Ok</span>(prefix) = res <span>{</span>
            <span>self</span>.cwd = prefix.to_path_buf();
            <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::<span>Ok</span>,
                                                &amp;<span>format!</span>(<span>"Directory changed to </span><span>\" <br class="calibre6"/></span><span>             {}</span><span>\"</span><span>"</span>, directory.display()))))?;
            <span>return</span> <span>Ok</span>(<span>self</span>)
        <span>}</span>
    <span>}</span>
    <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::FileNotFound,
                                        <span>"No such file or directory"</span>)))?;
    <span>Ok</span>(<span>self</span>)
<span>}</span></pre>
<p class="calibre3">This code uses the following two methods, which are similar to those in the previous chapter:</p>
<pre class="calibre22"><span>use</span> std::path::StripPrefixError;

<span>fn</span> complete_path(<span>self</span>, path: PathBuf) -&gt; (<span>Self</span>, result::<span>Result</span>&lt;PathBuf, io::Error&gt;) <span>{</span>
    <span>let</span> directory = <span>self</span>.server_root.join(<span>if</span> path.has_root() <span>{</span>
        path.iter().skip(<span>1</span>).collect()
    <span>}</span> <span>else</span> <span>{</span>
        path
    <span>}</span>);
    <span>let</span> dir = directory.canonicalize();
    <span>if</span> <span>let</span> <span>Ok</span>(<span>ref</span> dir) = dir <span>{</span>
        <span>if</span> !dir.starts_with(&amp;<span>self</span>.server_root) <span>{</span>
            <span>return</span> (<span>self</span>, <br class="calibre6"/><span>             Err</span>(io::ErrorKind::PermissionDenied.into()));
        <span>}</span>
    <span>}</span>
    (<span>self</span>, dir)
<span>}</span>

<span>fn</span> strip_prefix(<span>self</span>, dir: PathBuf) -&gt; (<span>Self</span>, result::<span>Result</span>&lt;PathBuf, StripPrefixError&gt;) <span>{</span>
    <span>let</span> res = dir.strip_prefix(&amp;<span>self</span>.server_root).map(|p| p.to_path_buf());
    (<span>self</span>, res)
<span>}</span></pre>
<p class="calibre3">Since it uses a new attribute, let's add it to the <span><kbd class="calibre14">Client</kbd></span> structure:</p>
<pre class="calibre22"><span>struct</span> Client <span>{</span>
    cwd: PathBuf,
    server_root: PathBuf,
    writer: Writer,
<span>}</span></pre>
<p class="calibre3">We also add its constructor:</p>
<pre class="calibre22"><span>impl</span> Client <span>{</span>
    <span>fn</span> new(writer: Writer, server_root: PathBuf) -&gt; Client <span>{</span>
        Client <span>{</span>
            cwd: PathBuf::from(<span>"/"</span>),
            server_root,
            writer,
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We also need to pass this value in a few places, first, in the <span><kbd class="calibre14">client</kbd></span> function and its wrapper:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> client(stream: TcpStream, server_root: PathBuf) -&gt; <span>Result</span>&lt;()&gt; <span>{</span>
    <span>// …</span>
    <span>let</span> <span>mut</span> client = Client::new(writer, server_root);
    <span>// …</span>
<span>}</span>

<span>#[</span>async<span>]</span>
<span>fn</span> handle_client(stream: TcpStream, server_root: PathBuf) -&gt; result::<span>Result</span>&lt;(), ()&gt; <span>{</span>
    <span>await!</span>(client(stream, server_root))
        .map_err(|error| <span>println!</span>(<span>"Error handling client: {}"</span>, <br class="calibre6"/>         error))
<span>}</span></pre>
<p class="calibre3">Then, we need to update the <span><kbd class="calibre14">server</kbd></span> function:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> server(handle: Handle, server_root: PathBuf) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
    <span>// …</span>
    <span>#[</span>async<span>]</span>
    <span>for</span> (stream, addr) <span>in</span> listener.incoming() <span>{</span>
        <span>let</span> address = <span>format!</span>(<span>"[address : {}]"</span>, addr);
        <span>println!</span>(<span>"New client: {}"</span>, address);
        handle.spawn(handle_client(stream, server_root.clone()));
        <span>println!</span>(<span>"Waiting another client..."</span>);
    <span>}</span>
    <span>Ok</span>(())
<span>}</span></pre>
<p class="calibre3">To send the server root to the <span><kbd class="calibre14">handle_client</kbd></span> function call.</p>
<p class="calibre3">And finally, we'll update the main function to send it to the <span><kbd class="calibre14">server</kbd></span> function:</p>
<pre class="calibre22"><span>use</span> std::env;

<span>fn</span> main() <span>{</span>
    <span>let</span> <span>mut</span> core = Core::new().expect(<span>"Cannot create tokio Core"</span>);
    <span>let</span> handle = core.handle();

    <span>match</span> env::current_dir() <span>{</span>
        <span>Ok</span>(server_root) =&gt; <span>{</span>
            <span>if</span> <span>let</span> <span>Err</span>(error) = core.run(server(handle, <br class="calibre6"/>             server_root)) <span>{</span>
                <span>println!</span>(<span>"Error running the server: {}"</span>, error);
            <span>}</span>
        <span>}</span>
        <span>Err</span>(e) =&gt; <span>println!</span>(<span>"Couldn't start server: {:?}"</span>, e),
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Here, we send the current directory as the server root.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Setting the transfer type</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's add a new command before we test our server <span>again:</span></p>
<pre class="calibre22">use cmd::TransferType;

#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        // …
        Command::Type(typ) =&gt; {
            self.transfer_type = typ;
            self = await!(self.send(Answer::new(ResultCode::Ok, "Transfer type <br class="calibre6"/>            changed successfully")))?;
        }
        // …
    }
}</pre>
<p class="calibre3">This requires a new attribute for our <span><kbd class="calibre14">Client</kbd></span> structure:</p>
<pre class="calibre22"><span>struct</span> Client <span>{</span>
    cwd: PathBuf,
    server_root: PathBuf,
    transfer_type: TransferType,
    writer: Writer,
<span>}</span></pre>
<p class="calibre3">And we need to update the constructor:</p>
<pre class="calibre22"><span>impl</span> Client <span>{</span>
    <span>fn</span> new(writer: Writer, server_root: PathBuf) -&gt; Client <span>{</span>
        Client <span>{</span>
            cwd: PathBuf::from(<span>"/"</span>),
            server_root,
            transfer_type: TransferType::Ascii,
            writer,
        <span>}</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">If we run this new server and connect to it through FileZilla, we'll see the following:</p>
<div class="mce-root1"><img src="../images/00045.jpeg" class="calibre36"/> <em class="calibre21">Figure 9.3</em></div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Entering passive mode</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's now write the code to handle the <span><kbd class="calibre14">PASV</kbd></span> command. Add the following case in <span><kbd class="calibre14">handle_cmd()</kbd></span>:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>match</span> cmd <span>{</span>
        <span>// …</span>
        Command::Pasv =&gt; <span>self</span> = <span>await!</span>(<span>self</span>.pasv())?,
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">For the following, we'll need four new fields in the <span><kbd class="calibre14">Client</kbd></span> structure:</p>
<pre class="calibre22"><span>use</span> futures::stream::SplitStream;

<span>use</span> codec::BytesCodec;

<span>type</span> DataReader = SplitStream&lt;Framed&lt;TcpStream, BytesCodec&gt;&gt;;
<span>type</span> DataWriter = SplitSink&lt;Framed&lt;TcpStream, BytesCodec&gt;&gt;;

<span>struct</span> Client <span>{</span>
    data_port: <span>Option</span>&lt;<span>u16</span>&gt;,
    data_reader: <span>Option</span>&lt;DataReader&gt;,
    data_writer: <span>Option</span>&lt;DataWriter&gt;,
    handle: Handle,
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">And all of them are initialized to <span><kbd class="calibre14">None</kbd></span>:</p>
<pre class="calibre22">impl Client {
    fn new(handle: Handle, writer: Writer, server_root: PathBuf) -&gt; Client {
        Client {
            data_port: None,
            data_reader: None,
            data_writer: None,
            handle,
            // …
        }
    }
}</pre>
<p class="calibre3">This requires changing a few other functions to send the <span><kbd class="calibre14">Handle</kbd></span> to the <span><kbd class="calibre14">Client</kbd></span> constructor. First, the <span><kbd class="calibre14">client</kbd></span> function now requires a new <span><kbd class="calibre14">handle</kbd></span> parameter:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> client(stream: TcpStream, handle: Handle, server_root: PathBuf) -&gt; <span>Result</span>&lt;()&gt; <span>{</span>
    <span>let</span> (writer, reader) = stream.framed(FtpCodec).split();
    <span>let</span> writer = <span>await!</span>(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser,  <br class="calibre6"/><span>    "Welcome to this FTP server!"</span>)))?;
    <span>let</span> <span>mut</span> client = Client::new(handle, writer, server_root);
    <span>// …</span>
<span>}</span></pre>
<p class="calibre3">The <span><kbd class="calibre14">handle_client()</kbd></span> <span>method</span><span> </span><span>also needs to take a new parameter:</span></p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_client(stream: TcpStream, handle: Handle, server_root: PathBuf) -&gt; result::<span>Result</span>&lt;(), ()&gt; <span>{</span>
    <span>await!</span>(client(stream, handle, server_root))
        .map_err(|error| <span>println!</span>(<span>"Error handling client: {}"</span>, error))
<span>}</span></pre>
<p class="calibre3">And in the <span><kbd class="calibre14">server()</kbd></span> function, you need to send the <span><kbd class="calibre14">handler</kbd></span> to the <span><kbd class="calibre14">handle_client()</kbd></span> function:</p>
<pre class="calibre22">#[async]
fn server(handle: Handle, server_root: PathBuf) -&gt; io::Result&lt;()&gt; {
    // …
    #[async]
    for (stream, addr) in listener.incoming() {
        // …
        handle.spawn(handle_client(stream, handle.clone(), server_root.clone()));
    }
}</pre>
<p class="calibre3">And here is the start of the method that does the real stuff for the <span><kbd class="calibre14">PASV</kbd></span> command:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> pasv(<span>mut</span> <span>self</span>) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>let</span> port =
        <span>if</span> <span>let</span> <span>Some</span>(port) = <span>self</span>.data_port <span>{</span>
            port
        <span>}</span> <span>else</span> <span>{</span>
            <span>0</span>
        <span>}</span>;
    <span>if</span> <span>self</span>.data_writer.is_some() <span>{</span>
        <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::DataConnectionAlreadyOpen,  <br class="calibre6"/><span>       "Already listening..."</span>)))?;
        <span>return</span> <span>Ok</span>(<span>self</span>);
    <span>}</span>

    <span>// …</span></pre>
<p class="calibre3">If a port was set by an earlier command, we use it, otherwise, we use zero to ask the system to choose one. As you know from the previous chapter, there are two channels in FTP—the command channel and the data channel. So, here, we check whether the data channel is already open. If that is the case, we send the appropriate response and end the function by returning. Here's the rest of the method:</p>
<pre class="sourcecode">    <span>// …</span>

    <span>let</span> addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(<span>127</span>, <span>0</span>, <span>0</span>, <span>1</span>)), port);
    <span>let</span> listener = TcpListener::bind(&amp;addr, &amp;<span>self</span>.handle)?;
    <span>let</span> port = listener.local_addr()?.port();

    <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::EnteringPassiveMode,
                          &amp;<span>format!</span>(<span>"127,0,0,1,{},{}"</span>, port &gt;&gt; <span>8</span>, port &amp; <span>0xFF</span>))))?;

    <span>println!</span>(<span>"Waiting clients on port {}..."</span>, port);
    <span>#[</span>async<span>]</span>
    <span>for</span> (stream, _rest) <span>in</span> listener.incoming() <span>{</span>
        <span>let</span> (writer, reader) = stream.framed(BytesCodec).split();
        <span>self</span>.data_writer = <span>Some</span>(writer);
        <span>self</span>.data_reader = <span>Some</span>(reader);
        <span>break</span>;
    <span>}</span>
    <span>Ok</span>(<span>self</span>)
<span>}</span></pre>
<p class="calibre3">We start by starting the listener for the data channel. See the following line:</p>
<pre class="calibre22"><span>let</span> port = listener.local_addr()?.port();</pre>
<p class="calibre3">This is used to get the port that was chosen by the system, if we specified port <kbd class="calibre14">0</kbd> to let the operating system choose a port. Then, we use an <span><kbd class="calibre14">async for</kbd></span> loop that breaks immediately after the first iteration because we only have one client that will connect to this new channel. In the loop, we're using the same split trick again; after saying that our stream uses the <span><kbd class="calibre14">BytesCodec</kbd></span>, we split the stream between the <kbd class="calibre14">writer</kbd> and the <kbd class="calibre14">reader</kbd>. We'll describe this new <kbd class="calibre14">codec</kbd> shortly. We then same both the data <kbd class="calibre14">writer</kbd> and <kbd class="calibre14">reader</kbd>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Bytes codec</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We start by creating an empty structure for the <kbd class="calibre14">codec</kbd>:</p>
<pre class="calibre22"><span>pub</span> <span>struct</span> BytesCodec;</pre>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Decoding data bytes</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Then, we implement the <span><kbd class="calibre14">Decoder</kbd></span> trait like we did for the <span><kbd class="calibre14">FtpCodec</kbd></span>:</p>
<pre class="calibre22"><span>impl</span> Decoder <span>for</span> BytesCodec <span>{</span>
    <span>type</span> Item = <span>Vec</span>&lt;<span>u8</span>&gt;;
    <span>type</span> Error = io::Error;

    <span>fn</span> decode(&amp;<span>mut</span> <span>self</span>, buf: &amp;<span>mut</span> BytesMut) -&gt; io::<span>Result</span>&lt;<span>Option</span>&lt;<span>Vec</span>&lt;<span>u8</span>&gt;&gt;&gt; <span>{</span>
        <span>if</span> buf.len() == <span>0</span> <span>{</span>
            <span>return</span> <span>Ok</span>(<span>None</span>);
        <span>}</span>
        <span>let</span> data = buf.to_vec();
        buf.clear();
        <span>Ok</span>(<span>Some</span>(data))
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Since the data of a transmitted file can be binary, we cannot use an <span><kbd class="calibre14">Item</kbd></span> of type <span><kbd class="calibre14">String</kbd></span>. We instead use <span><kbd class="calibre14">Vec&lt;u8&gt;</kbd></span>, which we can contain every possible byte. If the buffer is empty, we return <span><kbd class="calibre14">Ok(None)</kbd></span> to indicate to <kbd class="calibre14">tokio</kbd> that we need more data. Otherwise, we convert it to a vector, clear the buffer and return the vector.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Encoding data bytes</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's now see how to encode data; it's even simpler:</p>
<pre class="calibre22"><span>impl</span> Encoder <span>for</span> BytesCodec <span>{</span>
    <span>type</span> Item = <span>Vec</span>&lt;<span>u8</span>&gt;;
    <span>type</span> Error = io::Error;

    <span>fn</span> encode(&amp;<span>mut</span> <span>self</span>, data: <span>Vec</span>&lt;<span>u8</span>&gt;, buf: &amp;<span>mut</span> BytesMut) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
        buf.extend(data);
        <span>Ok</span>(())
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">We just extend the buffer with the data.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Quitting</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's now implement the <span><kbd class="calibre14">QUIT</kbd></span> command. As always, we need to add a case in the <span><kbd class="calibre14">handle_cmd()</kbd></span> method:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        Command::Quit =&gt; self = await!(self.quit())?,
        // …
    }
}</pre>
<p class="calibre3">And here is the code of the <span><kbd class="calibre14">quit()</kbd></span> method:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> quit(<span>mut</span> <span>self</span>) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>if</span> <span>self</span>.data_writer.is_some() <span>{</span>
        <span>unimplemented!</span>();
    <span>}</span> <span>else</span> <span>{</span>
        <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::ServiceClosingControlConnection, <span>"Closing connection..."</span>)))?;
        <span>self</span>.writer.close()?;
    <span>}</span>
    <span>Ok</span>(<span>self</span>)
<span>}</span></pre>
<p class="calibre3">So, we send a response back to the client and <span><kbd class="calibre14">close()</kbd></span> the <kbd class="calibre14">writer</kbd>.</p>
<p class="calibre3">To finish this chapter, let's implement the command to create and delete directories.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Creating directories</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We'll start by handling the command to create a new directory. So, we add a case in <span><kbd class="calibre14">handle_cmd()</kbd></span>:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>match</span> cmd <span>{</span>
        Command::Mkd(path) =&gt; <span>self</span> = <span>await!</span>(<span>self</span>.mkd(path))?,
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">And the function handling this command is:</p>
<pre class="calibre22"><span>use</span> std::fs::create_dir;

<span>#[</span>async<span>]</span>
<span>fn</span> mkd(<span>mut</span> <span>self</span>, path: PathBuf) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>let</span> path = <span>self</span>.cwd.join(&amp;path);
    <span>let</span> parent = get_parent(path.clone());
    <span>if</span> <span>let</span> <span>Some</span>(parent) = parent <span>{</span>
        <span>let</span> parent = parent.to_path_buf();
        <span>let</span> (new_self, res) = <span>self</span>.complete_path(parent);
        <span>self</span> = new_self;
        <span>if</span> <span>let</span> <span>Ok</span>(<span>mut</span> dir) = res <span>{</span></pre>
<p class="calibre3">We first check that the <kbd class="calibre14">parent</kbd> directory is valid and under the server root:</p>
<pre class="calibre23">            <span>if</span> dir.is_dir() <span>{</span>
                <span>let</span> filename = get_filename(path);
                <span>if</span> <span>let</span> <span>Some</span>(filename) = filename <span>{</span>
                    dir.push(filename);
                    <span>if</span> create_dir(dir).is_ok() <span>{</span>
                        <span>self</span> = <span>await! <br class="calibre6"/></span>               (<span>self</span>.send(Answer::new(ResultCode::PATHNAMECreated,
               <span>"Folder successfully created!"</span>)))?;
                        <span>return</span> <span>Ok</span>(<span>self</span>);
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
    <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::FileNotFound,
                                        <span>"Couldn't create folder"</span>)))?;
    <span>Ok</span>(<span>self</span>)
<span>}</span></pre>
<p class="calibre3">If it is, we create the directory. Otherwise, we send an error.</p>
<p class="calibre3">This requires two new functions:</p>
<pre class="calibre22"><span>use</span> std::ffi::OsString;

<span>fn</span> get_parent(path: PathBuf) -&gt; <span>Option</span>&lt;PathBuf&gt; <span>{</span>
    path.parent().map(|p| p.to_path_buf())
<span>}</span>

<span>fn</span> get_filename(path: PathBuf) -&gt; <span>Option</span>&lt;OsString&gt; <span>{</span>
    path.file_name().map(|p| p.to_os_string())
<span>}</span></pre>
<p class="calibre3">These are simple wrappers over the methods from the standard library, doing type conversion.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Removing directories</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Finally, let's see the code to remove directories:</p>
<pre class="calibre22"><span>#[</span>async<span>]</span>
<span>fn</span> handle_cmd(<span>mut</span> <span>self</span>, cmd: Command) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>match</span> cmd <span>{</span>
        Command::Rmd(path) =&gt; <span>self</span> = <span>await!</span>(<span>self</span>.rmd(path))?,
        <span>// …</span>
    <span>}</span>
<span>}</span></pre>
<p class="calibre3">Like for the previous commands, we add a new case that calls the method that will handle it:</p>
<pre class="calibre22"><span>use</span> std::fs::remove_dir_all;

<span>#[</span>async<span>]</span>
<span>fn</span> rmd(<span>mut</span> <span>self</span>, directory: PathBuf) -&gt; <span>Result</span>&lt;<span>Self</span>&gt; <span>{</span>
    <span>let</span> path = <span>self</span>.cwd.join(&amp;directory);
    <span>let</span> (new_self, res) = <span>self</span>.complete_path(path);
    <span>self</span> = new_self;
    <span>if</span> <span>let</span> <span>Ok</span>(dir) = res <span>{</span>
        <span>if</span> remove_dir_all(dir).is_ok() <span>{</span>
            <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::RequestedFileActionOkay,
                                                <span>"Folder successfully removed"</span>)))?;
            <span>return</span> <span>Ok</span>(<span>self</span>);
        <span>}</span>
    <span>}</span>
    <span>self</span> = <span>await!</span>(<span>self</span>.send(Answer::new(ResultCode::FileNotFound,
                                        <span>"Couldn't remove folder"</span>)))?;
    <span>Ok</span>(<span>self</span>)
<span>}</span></pre>
<p class="calibre3">Here again, we check that the directory is valid and under the server root, and delete it if that is the case. Otherwise, we send an error message.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In this chapter, we implemented a lot of commands for our asynchronous FTP server and learned about using <span><kbd class="calibre14">tokio</kbd></span>. We also saw in more detail what asynchronous I/O <span>is,</span><span> and</span><span> its advantages and disadvantages. We used the new</span> <span><kbd class="calibre14">async</kbd></span><span>/</span><span><kbd class="calibre14">await</kbd></span> <span>syntax to simplify the code using</span> <span><kbd class="calibre14">tokio</kbd></span><span>. We learned what futures and streams </span><span>are,</span><span> </span><span>and how they interact with</span> <span><kbd class="calibre14">tokio</kbd></span><span>. We also saw how to do proper error handling and how to do it concisely. In the next chapter, we'll complete the implementation of the FTP server and see how to test it.</span></p>


            </article>

            
        </section>
    </body></html>