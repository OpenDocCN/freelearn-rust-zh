<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing an Asynchronous FTP Server</h1>
                
            
            
                
<p class="calibre3">In the previous chapter, we wrote a synchronous FTP server. Now, we'll write an asynchronous version with <kbd class="calibre14">tokio</kbd>, the asynchronous IO (Input/Output) library for Rust. We'll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Asynchronous servers</li>
<li class="calibre11">Futures</li>
<li class="calibre11">Streams</li>
<li class="calibre11">Tokio</li>
<li class="calibre11">Async/await</li>
<li class="calibre11">Error handling</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Advantages of asynchronous IO</h1>
                
            
            
                
<p class="calibre3">Asynchronous IO allows us to send a request without waiting for its result, we'll get notified somehow later when we receive the response. This enables our programs to be more concurrent and scale better.</p>
<p class="calibre3">In the previous chapter, we used threads in order to avoid blocking other clients while we wait for a response. Using threads has a cost, though, besides the fact that threads require more memory, they also impose a performance cost because they require a context switch when the code goes from one thread to the other.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Disadvantages of asynchronous IO</h1>
                
            
            
                
<p class="calibre3">However, using asynchronous IO does not come without drawbacks. Using asynchronous IO is harder than using synchronous IO. With asynchronous IO, we also need a way to know when an event has terminated. So, we need to learn a new way to manage the IO events and it'll take more time to implement the same software that we wrote in the previous chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating the new project</h1>
                
            
            
                
<p class="calibre3">Let's start by creating a new binary project, as usual:</p>
<pre class="calibre23"><strong class="calibre5">cargo new --bin ftp-server</strong></pre>
<p class="calibre3">We'll add the following dependencies in the <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre22">[dependencies]
bytes = "^0.4.5"
tokio-core = "^0.1.10"
tokio-io = "^0.1.3"

[dependencies.futures-await]
git = "https://github.com/alexcrichton/futures-await"</pre>
<p class="calibre3">As you can see here, we specify a dependency via a Git URL. This dependency is using nightly-only features, so make sure you're using the nightly compiler by running this command:</p>
<pre class="calibre23"><strong class="calibre5">rustup default nightly</strong></pre>
<p class="calibre3">Let's start our <kbd class="calibre14">main</kbd> module by adding the required <kbd class="calibre14">extern crate</kbd> statements:</p>
<pre class="calibre22">#![feature(proc_macro, conservative_impl_trait, generators)]

extern crate bytes;
extern crate futures_await as futures;
extern crate tokio_core;
extern crate tokio_io;</pre>
<p class="calibre3">As you can see, we're using some nightly features. These are needed by the <kbd class="calibre14">futures-await</kbd> crate. We also decided to import this crate under another name, <kbd class="calibre14">futures</kbd>, because it exports the same types and functions as the <kbd class="calibre14">futures</kbd> crate itself.</p>
<p class="calibre3">We'll copy some code from the previous chapter and put them in the new module, for better organization. Here are the new modules:</p>
<pre class="calibre22">mod cmd;
mod ftp;</pre>
<p class="calibre3">In a new file, called <kbd class="calibre14">src/cmd.rs</kbd>, put the following code:</p>
<pre class="calibre22">use std::path::{Path, PathBuf};
use std::str::{self, FromStr};

use error::{Error, Result};

#[derive(Clone, Debug)]
pub enum Command {
    Auth,
    Cwd(PathBuf),
    List(Option&lt;PathBuf&gt;),
    Mkd(PathBuf),
    NoOp,
    Port(u16),
    Pasv,
    Pwd,
    Quit,
    Retr(PathBuf),
    Rmd(PathBuf),
    Stor(PathBuf),
    Syst,
    Type(TransferType),
    CdUp,
    Unknown(String),
    User(String),
}</pre>
<p class="calibre3">We first have an enumeration representing the different commands and their parameters:</p>
<pre class="calibre22">impl AsRef&lt;str&gt; for Command {
    fn as_ref(&amp;self) -&gt; &amp;str {
        match *self {
            Command::Auth =&gt; "AUTH",
            Command::Cwd(_) =&gt; "CWD",
            Command::List(_) =&gt; "LIST",
            Command::Pasv =&gt; "PASV",
            Command::Port(_) =&gt; "PORT",
            Command::Pwd =&gt; "PWD",
            Command::Quit =&gt; "QUIT",
            Command::Retr(_) =&gt; "RETR",
            Command::Stor(_) =&gt; "STOR",
            Command::Syst =&gt; "SYST",
            Command::Type(_) =&gt; "TYPE",
            Command::User(_) =&gt; "USER",
            Command::CdUp =&gt; "CDUP",
            Command::Mkd(_) =&gt; "MKD",
            Command::Rmd(_) =&gt; "RMD",
            Command::NoOp =&gt; "NOOP",
            Command::Unknown(_) =&gt; "UNKN", // doesn't exist
        }
    }
}</pre>
<p class="calibre3">Here, we create a method to get the string representation of a command:</p>
<pre class="calibre22">impl Command {
    pub fn new(input: Vec&lt;u8&gt;) -&gt; Result&lt;Self&gt; {
        let mut iter = input.split(|&amp;byte| byte == b' ');
        let mut command = iter.next().ok_or_else(<br class="calibre6"/>         || Error::Msg("empty command".to_string()))?.to_vec();
        to_uppercase(&amp;mut command);
        let data = iter.next().ok_or_else(|| Error::Msg("no command  <br class="calibre6"/>         parameter".to_string()));
        let command =
            match command.as_slice() {
                b"AUTH" =&gt; Command::Auth,
                b"CWD" =&gt; Command::Cwd(data.and_then(|bytes|  <br class="calibre6"/>                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),
                b"LIST" =&gt; Command::List(data.and_then(|bytes|  <br class="calibre6"/>                 Ok(Path::new(str::from_utf8(bytes)?).to_path_buf())).ok()),
                b"PASV" =&gt; Command::Pasv,
                b"PORT" =&gt; {
                    let addr = data?.split(|&amp;byte| byte == b',')
                        .filter_map(|bytes| <br class="calibre6"/>                         str::from_utf8(bytes).ok()
                         .and_then(|string| u8::from_str(string).ok()))
                        .collect::&lt;Vec&lt;u8&gt;&gt;();
                    if addr.len() != 6 {
                        return Err("Invalid address/port".into());
                    }

                    let port = (addr[4] as u16) &lt;&lt; 8 | (addr[5] as <br class="calibre6"/>                     u16);
                    if port &lt;= 1024 {
                        return Err("Port can't be less than<br class="calibre6"/>                      10025".into());
                    }
                    Command::Port(port)
                },
                b"PWD" =&gt; Command::Pwd,
                b"QUIT" =&gt; Command::Quit,
                b"RETR" =&gt; Command::Retr(data.and_then(|bytes|  <br class="calibre6"/>                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),
                b"STOR" =&gt; Command::Stor(data.and_then(|bytes|   <br class="calibre6"/>                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),
                b"SYST" =&gt; Command::Syst,
                b"TYPE" =&gt; {
                    match TransferType::from(data?[0]) {
                        TransferType::Unknown =&gt; return <br class="calibre6"/>                         Err("command not implemented <br class="calibre6"/>                        for that parameter".into()),
                        typ =&gt; {
                            Command::Type(typ)
                        },
                    }
                },
                b"CDUP" =&gt; Command::CdUp,
                b"MKD" =&gt; Command::Mkd(data.and_then(|bytes|  <br class="calibre6"/>                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),
                b"RMD" =&gt; Command::Rmd(data.and_then(|bytes|  <br class="calibre6"/>                Ok(Path::new(str::from_utf8(bytes)?).to_path_buf()))?),
                b"USER" =&gt; Command::User(data.and_then(|bytes|  <br class="calibre6"/>                String::from_utf8(bytes.to_vec()).map_err(Into::into))?),
                b"NOOP" =&gt; Command::NoOp,
                s =&gt; <br class="calibre6"/>                 Command::Unknown(str::from_utf8(s).unwrap_or("").to_owned()),
            };
        Ok(command)
    }
}</pre>
<p class="calibre3">This constructor parses a byte string as a <kbd class="calibre14">Command</kbd>. This requires a function to convert a byte string to uppercase:</p>
<pre class="calibre22">fn to_uppercase(data: &amp;mut [u8]) {
    for byte in data {
        if *byte &gt;= 'a' as u8 &amp;&amp; *byte &lt;= 'z' as u8 {
            *byte -= 32;
        }
    }
}</pre>
<p class="calibre3">We simply decrement all lowercase letters by 32 to convert them to uppercase:</p>
<pre class="calibre22">#[derive(Clone, Copy, Debug)]
pub enum TransferType {
    Ascii,
    Image,
    Unknown,
}

impl From&lt;u8&gt; for TransferType {
    fn from(c: u8) -&gt; TransferType {
        match c {
            b'A' =&gt; TransferType::Ascii,
            b'I' =&gt; TransferType::Image,
            _ =&gt; TransferType::Unknown,
        }
    }
<a class="calibre67">}</a></pre>
<p class="calibre3">Here, we have an enumeration for the transfer type and a function to parse a byte character to this type. And in another file, <kbd class="calibre14">src/ftp.rs</kbd>, let's write the following:</p>
<pre class="calibre22">pub struct Answer {
    pub code: ResultCode,
    pub message: String,
}

impl Answer {
    pub fn new(code: ResultCode, message: &amp;str) -&gt; Self {
        Answer {
            code,
            message: message.to_string(),
        }
    }
}

#[derive(Debug, Clone, Copy)]
#[repr(u32)]
#[allow(dead_code)]
pub enum ResultCode {
    RestartMarkerReply = 110,
    ServiceReadInXXXMinutes = 120,
    DataConnectionAlreadyOpen = 125,
    FileStatusOk = 150,
    Ok = 200,
    CommandNotImplementedSuperfluousAtThisSite = 202,
    SystemStatus = 211,
    DirectoryStatus = 212,
    FileStatus = 213,
    HelpMessage = 214,
    SystemType = 215,
    ServiceReadyForNewUser = 220,
    ServiceClosingControlConnection = 221,
    DataConnectionOpen = 225,
    ClosingDataConnection = 226,
    EnteringPassiveMode = 227,
    UserLoggedIn = 230,
    RequestedFileActionOkay = 250,
    PATHNAMECreated = 257,
    UserNameOkayNeedPassword = 331,
    NeedAccountForLogin = 332,
    RequestedFileActionPendingFurtherInformation = 350,
    ServiceNotAvailable = 421,
    CantOpenDataConnection = 425,
    ConnectionClosed = 426,
    FileBusy = 450,
    LocalErrorInProcessing = 451,
    InsufficientStorageSpace = 452,
    UnknownCommand = 500,
    InvalidParameterOrArgument = 501,
    CommandNotImplemented = 502,
    BadSequenceOfCommands = 503,
    CommandNotImplementedForThatParameter = 504,
    NotLoggedIn = 530,
    NeedAccountForStoringFiles = 532,
    FileNotFound = 550,
    PageTypeUnknown = 551,
    ExceededStorageAllocation = 552,
    FileNameNotAllowed = 553,
}</pre>
<p class="calibre3">We're now ready to start working on the FTP server itself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using Tokio</h1>
                
            
            
                
<p class="calibre3">Tokio is based on the lower-level crate mio, which is itself directly based on system calls such as <kbd class="calibre14">epoll</kbd> (Linux), <kbd class="calibre14">kqueue</kbd> (FreeBSD), and IOCP (Windows). This crate is also based on the <kbd class="calibre14">futures</kbd> crate, which provides abstractions to reason about a value (or multiple values) that will be available later. As I told you when using asynchronous I/O, the calls do not block so we need a way to know when the result of a read is available. This is where <kbd class="calibre14">Future</kbd> and <kbd class="calibre14">Stream</kbd>, two abstractions from the <kbd class="calibre14">futures</kbd> crate, come into play.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tokio event loop</h1>
                
            
            
                
<p class="calibre3">Tokio also provides an event loop, on which we will be able to execute some code (with <kbd class="calibre14">futures</kbd>) that will be executed when some I/O events happen, such as when the result of a socket read is ready. To do so, the event loop will register events on specific file descriptors that represent sockets. It registers these events using the aforementioned system calls and then waits for any of the registered events to happen. The file descriptors and the system calls are low-level stuff that we do not need to know to use <kbd class="calibre14">tokio</kbd>, but it is important to understand how it works at the lower level. For instance, <kbd class="calibre14">epoll</kbd> does not support regular files, so if you try to wait for an event to happen on a regular file, it could block even though we're using asynchronous I/O which should not block.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using futures</h1>
                
            
            
                
<p class="calibre3">A <kbd class="calibre14">future</kbd> represents a value that will be available later, or an error, similar to the <kbd class="calibre14">Result</kbd> type. A <kbd class="calibre14">stream</kbd> represents multiple values (or errors) that will be available at different times in the <kbd class="calibre14">future</kbd>, similar to an <kbd class="calibre14">Iterator&lt;Result&lt;T&gt;&gt;</kbd>. This crate provides many combinators such as <kbd class="calibre14">and_then()</kbd>, <kbd class="calibre14">map()</kbd>, and others similar to the one available on the <kbd class="calibre14">Result</kbd> type. But, we won't use them, preferring the <kbd class="calibre14">async</kbd>/<kbd class="calibre14">await</kbd> syntax that we'll see later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handling errors</h1>
                
            
            
                
<p class="calibre3">Before we start coding the FTP server, let's talk about how we'll be handling the errors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Unwrapping</h1>
                
            
            
                
<p class="calibre3">In the previous projects, we used the <kbd class="calibre14">unwrap()</kbd> or <kbd class="calibre14">expect()</kbd> methods a lot. These methods are handy for fast prototyping, but when we want to write high-quality software, we should avoid them in most cases. Since we're writing an FTP server, a software that must keep running for a long time, we don't want it to crash because we called <kbd class="calibre14">unwrap()</kbd> and a client sent a bad command. So, we'll do proper error handling.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Custom error type</h1>
                
            
            
                
<p class="calibre3">Since we can get different types of errors and we want to keep track of all of them, we'll create a custom error type. Let's create a new module in which we'll put this new type:</p>
<pre class="calibre22">mod error;</pre>
<p class="calibre3">Add it to the <kbd class="calibre14">src/error.rs</kbd> file:</p>
<pre class="calibre22">use std::io;
use std::str::Utf8Error;
use std::string::FromUtf8Error;

pub enum Error {
    FromUtf8(FromUtf8Error),
    Io(io::Error),
    Msg(String),
    Utf8(Utf8Error),
}</pre>
<p class="calibre3">Here, we have an enum representing the different errors that can happen in our FTP server to be implemented. There are UTF-8 errors since FTP is a string-based protocol and I/O errors because we communicate over the network and communication issues can happen. We created variants for error types coming from the standard library, which will be helpful later when we want to compose different types of errors. We also created a variant <kbd class="calibre14">Msg</kbd> for our own errors and we represent them as a <kbd class="calibre14">String</kbd> since we only want to show them in the terminal (we could also log them to <kbd class="calibre14">syslog</kbd>, for instance).</p>
<p class="calibre3">This is the standard way in Rust to represent an error type. It's a good practice to create this type, especially if your crate is a library, so that the users of your crate can know exactly why an error happened.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Displaying the error</h1>
                
            
            
                
<p class="calibre3">Since we want to print the error to the terminal, we'll implement the <kbd class="calibre14">Display</kbd> trait for our <kbd class="calibre14">Error</kbd> type:</p>
<pre class="calibre22">use std::fmt::{self, Display, Formatter};

use self::Error::*;

impl Display for Error {
    fn fmt(&amp;self, formatter: &amp;mut Formatter) -&gt; fmt::Result {
        match *self {
            FromUtf8(ref error) =&gt; error.fmt(formatter),
            Io(ref error) =&gt; error.fmt(formatter),
            Utf8(ref error) =&gt; error.fmt(formatter),
            Msg(ref msg) =&gt; write!(formatter, "{}", msg),
        }
    }
}</pre>
<p class="calibre3">For the three cases where we wrap an error from another type, we just call the corresponding <kbd class="calibre14">fmt()</kbd> method of these errors. In the case that it is a <kbd class="calibre14">Msg</kbd>, we write the string using the <kbd class="calibre14">write!</kbd> macro. This macro is a bit similar to <kbd class="calibre14">print!</kbd>, but needs a parameter to specify where to write the formatted data.</p>
<p class="calibre3">It is not very helpful in our case, but it is recommended to also implement the <kbd class="calibre14">Error</kbd> trait for custom error types:</p>
<pre class="calibre22">use std::error;

impl error::Error for Error {
    fn description(&amp;self) -&gt; &amp;str {
        match *self {
            FromUtf8(ref error) =&gt; error.description(),
            Io(ref error) =&gt; error.description(),
            Utf8(ref error) =&gt; error.description(),
            Msg(ref msg) =&gt; msg,
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        let cause: &amp;error::Error =
            match *self {
                FromUtf8(ref error) =&gt; error,
                Io(ref error) =&gt; error,
                Utf8(ref error) =&gt; error,
                Msg(_) =&gt; return None,
            };
        Some(cause)
    }
}</pre>
<p class="calibre3">The only required method of this trait is <kbd class="calibre14">description()</kbd>, which returns a short description of the error. Again, in the three cases, we just call the <kbd class="calibre14">description()</kbd> method from the wrapped type itself. And, for our <kbd class="calibre14">Msg</kbd> variant, we return the wrapped message.</p>
<p class="calibre3">It is possible that we don't have a string to return from this method. If it is the case, we can just return <kbd class="calibre14">&amp;'static str</kbd>, like this:</p>
<pre class="calibre22">Io(_) =&gt; "IO error",</pre>
<p class="calibre3">The <kbd class="calibre14">cause()</kbd> method is optional and is used to return the cause of the error. Here, we return the inner error when there's one in the variant and return <kbd class="calibre14">None</kbd> for our <kbd class="calibre14">Msg</kbd> variant.</p>
<p class="calibre3">The trait <kbd class="calibre14">Error</kbd> requires the <kbd class="calibre14">Self</kbd> type to implement both <kbd class="calibre14">Display</kbd> and <kbd class="calibre14">Debug</kbd>. We implemented <kbd class="calibre14">Display</kbd> earlier, but we don't implement <kbd class="calibre14">Debug</kbd> yet. Let's fix that by adding an attribute in front of the type declaration:</p>
<pre class="calibre22">#[derive(Debug)]
pub enum Error {
    FromUtf8(FromUtf8Error),
    Io(io::Error),
    Msg(String),
    Utf8(Utf8Error),
}</pre>
<p class="calibre3">It is good practice to provide a type alias named <kbd class="calibre14">Result</kbd> that is specialized for our error type. Let's write one:</p>
<pre class="calibre22">use std::result;

pub type Result&lt;T&gt; = result::Result&lt;T, Error&gt;;</pre>
<p class="calibre3">By doing so, we hide the original <kbd class="calibre14">Result</kbd> type from the standard library. That's why we're specifying a qualified version of this type. Otherwise, the compiler will assume that it is a recursive type, which is not the case here. We'll have to be careful when we import this type in other modules, because it hides the <kbd class="calibre14">Result</kbd> type. In case we want to use the original <kbd class="calibre14">Result</kbd> type, we'll have to use the same trick; qualifying it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Composing error types</h1>
                
            
            
                
<p class="calibre3">The last thing we need to do in order to use all the good practices for error types in Rust is to make them easy to compose, because, for now, if we have another error type, such as <kbd class="calibre14">io::Error</kbd>, we would need to use the following code every time we have another type:</p>
<pre class="calibre22">let val =
    match result {
        Ok(val) =&gt; val,
        Err(error) =&gt; return Err(Error::Io(error)),
    };</pre>
<p class="calibre3">This can quickly become cumbersome. To improve that, we'll implement the <kbd class="calibre14">From</kbd> trait for different error types:</p>
<pre class="calibre22">impl From&lt;io::Error&gt; for Error {
    fn from(error: io::Error) -&gt; Self {
        Io(error)
    }
}

impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Error {
    fn from(message: &amp;'a str) -&gt; Self {
        Msg(message.to_string())
    }
}

impl From&lt;Utf8Error&gt; for Error {
    fn from(error: Utf8Error) -&gt; Self {
        Utf8(error)
    }
}

impl From&lt;FromUtf8Error&gt; for Error {
    fn from(error: FromUtf8Error) -&gt; Self {
        FromUtf8(error)
    }
}</pre>
<p class="calibre3">These implementations are easy to understand: if we have an <kbd class="calibre14">io::Error</kbd>, we just wrap them in the corresponding variant. We also added a convenient conversion from the <kbd class="calibre14">&amp;str</kbd> type.</p>
<p class="calibre3">This will allow us to use the following, which is not really better, but the good old <kbd class="calibre14">?</kbd> operator will help us to reduce the boilerplate:</p>
<pre class="calibre22">let val =
    match result {
        Ok(val) =&gt; val,
        Err(error) =&gt; return Err(error.into()),
    };</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The ? operator, revisited</h1>
                
            
            
                
<p class="calibre3">This operator will not only return the error if there is one, but will also convert it to the required type. It converts it with a call to <kbd class="calibre14">Into::into()</kbd>, <kbd class="calibre14">Into</kbd> being a trait. But why did we implement the <kbd class="calibre14">From</kbd> trait, instead of <kbd class="calibre14">Into</kbd>? Because there's a generic implementation of <kbd class="calibre14">Into</kbd> which is based on <kbd class="calibre14">From</kbd>:</p>
<pre class="calibre22">impl&lt;T, U&gt; Into&lt;U&gt; for T
where U: From&lt;T&gt;,</pre>
<p class="calibre3">Thanks to this implementation, we rarely need to implement the <kbd class="calibre14">Into</kbd> trait ourselves. We only need to implement the <kbd class="calibre14">From</kbd> trait.</p>
<p class="calibre3">This means that we can rewrite the previous code as follows:</p>
<pre class="calibre22">let val = result?;</pre>
<p class="calibre3">And it will behave exactly the same as before.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting the Tokio event loop</h1>
                
            
            
                
<p class="calibre3">In <kbd class="calibre14">tokio</kbd>, the object we need to use to manage an event loop is <kbd class="calibre14">Core</kbd>. Here's how we start an event loop using <kbd class="calibre14">tokio</kbd> (in the <kbd class="calibre14">main</kbd> module):</p>
<pre class="calibre22">use tokio_core::reactor::Core;

fn main() {
    let mut core = Core::new().expect("Cannot create tokio Core");
    if let Err(error) = core.run(server()) {
        println!("Error running the server: {}", error);
    }
}</pre>
<p class="calibre3">We first create a new <kbd class="calibre14">Core</kbd> object, and then call the <kbd class="calibre14">run()</kbd> method to start the event loop. The latter method will return when the provided future ends. Here, we call <kbd class="calibre14">server()</kbd> to get the future, so let's write this function:</p>
<pre class="calibre22">use std::io;

use futures::prelude::async;

#[async]
fn server() -&gt; io::Result&lt;()&gt; {
    Ok(())
}</pre>
<p class="calibre3">As you can see, we use the <kbd class="calibre14">#[async]</kbd> attribute. Since attributes are currently instable in Rust, we had to specify that we are using the <kbd class="calibre14">proc_macro</kbd> feature. We also import the <kbd class="calibre14">async</kbd> attribute from the <kbd class="calibre14">futures_await</kbd> crate (which was imported under the name <kbd class="calibre14">futures</kbd>). So don't forget the <kbd class="calibre14">#![feature]</kbd> attribute and the <kbd class="calibre14">extern crate</kbd> statements at the top.</p>
<p class="calibre3">This attribute allows us to write a normal function, returning a <kbd class="calibre14">Result</kbd>, and will convert this function to actually return a <kbd class="calibre14">Future</kbd>. This function does nothing and returns <kbd class="calibre14">Ok(())</kbd>, so when you run the program, it will end immediately.</p>
<p class="calibre3">There's another syntax we could have used that is provided by the <kbd class="calibre14">futures-await</kbd> crate:</p>
<pre class="calibre22">use futures::prelude::async_block;

fn main() {
    let mut core = Core::new().expect("Cannot create tokio Core");
    let server = async_block! {
        Ok(())
    };
    let result: Result&lt;_, io::Error&gt; = core.run(server);
    if let Err(error) = result {
        println!("Error running the server: {}", error);
    }
}</pre>
<p class="calibre3">We won't use this syntax in our FTP server, but it is worth knowing about. By using an <kbd class="calibre14">async_block</kbd>, we are not required to create a new function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting the server</h1>
                
            
            
                
<p class="calibre3">The program we just wrote does absolutely nothing, so let's update it so that it at least starts a server, using <kbd class="calibre14">tokio</kbd>. Let's write an actual body to our <kbd class="calibre14">server()</kbd> function:</p>
<pre class="calibre22">use std::net::{IpAddr, Ipv4Addr, SocketAddr};

use tokio_core::reactor::Handle;
use tokio_core::net::TcpListener;

#[async]
fn server(handle: Handle) -&gt; io::Result&lt;()&gt; {
    let port = 1234;
    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);
    let listener = TcpListener::bind(&amp;addr, &amp;handle)?;

    println!("Waiting clients on port {}...", port);
    #[async]
    for (stream, addr) in listener.incoming() {
        let address = format!("[address : {}]", addr);
        println!("New client: {}", address);
        handle.spawn(handle_client(stream));
        println!("Waiting another client...");
    }
    Ok(())
}</pre>
<p class="calibre3">The function now takes a <kbd class="calibre14">Handle</kbd>, which will be useful to specify on which event loop the server must run. We start this function by specifying on which port we want to start the server by creating a <kbd class="calibre14">SocketAddr</kbd>. Then, we create a <kbd class="calibre14">TcpListener</kbd> in a similar way to how we would create a synchronous <kbd class="calibre14">TcpListener</kbd> from the standard library. The difference here is that we also send the <kbd class="calibre14">handle</kbd> as an argument to specify on which event loop we want the server to run. After that, we use the <kbd class="calibre14">#[async]</kbd> attribute again, but on a <kbd class="calibre14">for</kbd> loop this time.</p>
<p class="calibre3">Async <kbd class="calibre14">for</kbd> loops are used to iterate over a <kbd class="calibre14">Stream</kbd>, returning an error if there is one. These async loops can only be used in an <kbd class="calibre14">#[async]</kbd> function. In the loop, we spawn the future returned by <kbd class="calibre14">handle_client()</kbd>. Spawning a future means that it will be executed and handled by the event loop. The difference with <kbd class="calibre14">Core::run()</kbd> is that the future must return <kbd class="calibre14">()</kbd> and the error should also be <kbd class="calibre14">()</kbd>.</p>
<p class="calibre3">Now that this function takes an argument, we'll need to update the <kbd class="calibre14">main</kbd> function:</p>
<pre class="calibre22">fn main() {
    let mut core = Core::new().expect("Cannot create tokio Core");
    let handle = core.handle();
    if let Err(error) = core.run(server(handle)) {
        println!("Error running the server: {}", error);
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handling clients</h1>
                
            
            
                
<p class="calibre3">Let's now see the <kbd class="calibre14">handle_client()</kbd> function we've just mentioned:</p>
<pre class="calibre22">use std::result;

use futures::prelude::await;

#[async]
use tokio_core::net::TcpStream;

fn handle_client(stream: TcpStream) -&gt; result::Result&lt;(), ()&gt; {
    await!(client(stream))
        .map_err(|error| println!("Error handling client: {}", error))
}</pre>
<p class="calibre3">It is a simple wrapper over the <kbd class="calibre14">client</kbd> future. Here, we used a new macro, <kbd class="calibre14">await!</kbd>, which allows us to write asynchronous code in an asynchronous way. When the result of the future inside <kbd class="calibre14">await!()</kbd> is not ready, the event loop will execute other stuff, and when it's ready it will continue executing the code after the <kbd class="calibre14">await!()</kbd>. In this case, we print the error returned by the <kbd class="calibre14">client</kbd> future. This is why we needed a wrapper.</p>
<p class="calibre3">Now, let's write this <kbd class="calibre14">client</kbd> future:</p>
<pre class="calibre22">use futures::{Sink, Stream};
use futures::stream::SplitSink;
use tokio_io::AsyncRead;
use tokio_io::codec::Framed;

use codec::FtpCodec;
use error::Result;
use ftp::{Answer, ResultCode};

#[async]
fn client(stream: TcpStream) -&gt; Result&lt;()&gt; {
    let (writer, reader) = stream.framed(FtpCodec).split();
    let writer = await!(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser, <br class="calibre6"/>    "Welcome to this FTP server!")))?;
    let mut client = Client::new(writer);
    #[async]
    for cmd in reader {
        client = await!(client.handle_cmd(cmd))?;
    }
    println!("Client closed");
    Ok(())
}</pre>
<p class="calibre3">Here, we specify that the <kbd class="calibre14">stream</kbd> will be handled by a <kbd class="calibre14">FtpCodec</kbd>, which means that we'll be able to encode and decode structured data instead of dealing with bytes directly. We'll write this <kbd class="calibre14">FtpCodec</kbd> soon. Then, we split the stream between a <kbd class="calibre14">reader</kbd> and a <kbd class="calibre14">writer</kbd>. This <kbd class="calibre14">split()</kbd> method is very useful in Rust, because of ownership: we cannot have two owners, one that will write to the socket and another that will read to it. To fix this issue, we split the stream and we can now have an owner for the <kbd class="calibre14">reader</kbd> and another owner for the <kbd class="calibre14">writer</kbd>.</p>
<p class="calibre3">Then, we use the <kbd class="calibre14">writer</kbd> to send a welcome message. Again, we use the <kbd class="calibre14">await!</kbd> macro to specify that the code after will be executed when the message is sent (but without blocking the whole program, thanks to asynchronous I/O). Next, we create a <kbd class="calibre14">Client</kbd> which will be the object that will manage a client, by executing the appropriate actions when it receives commands and sending the right responses.</p>
<p class="calibre3">After that, we use again an <kbd class="calibre14">#[async] for</kbd> loop to iterate over a stream; here, we iterate over the stream of the data received by this specific client. In the <kbd class="calibre14">for</kbd> loop, we call the <kbd class="calibre14">handle_cmd()</kbd> method that we will soon write. This method, as its name indicates, will handle the command received from this FTP client, act accordingly, and send a response back. Here, we use <kbd class="calibre14">await!()?</kbd> with a question mark at the end. The <kbd class="calibre14">futures-await</kbd> crate allows us to do so; this means that if the future returned an error, this error will propagate to the <kbd class="calibre14">client</kbd> future, which is the same semantic for the normal <kbd class="calibre14">?</kbd> operator used in a function returning a <kbd class="calibre14">Result</kbd>. We'll see why we reassign the result to <kbd class="calibre14">client</kbd> when we write the <kbd class="calibre14">handle_cmd()</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handling commands</h1>
                
            
            
                
<p class="calibre3">To handle the commands received by the FTP server, we'll have a <kbd class="calibre14">Client</kbd> struct:</p>
<pre class="calibre22">type Writer = SplitSink&lt;Framed&lt;TcpStream, FtpCodec&gt;&gt;;

struct Client {
    writer: Writer,
}</pre>
<p class="calibre3">The client contains a <kbd class="calibre14">Writer</kbd> object that will be useful to send messages to the client. The <kbd class="calibre14">Writer</kbd> type represents a <kbd class="calibre14">Sink</kbd> that has been split, and uses the <kbd class="calibre14">FtpCodec</kbd> on a <kbd class="calibre14">TcpStream</kbd>. A <kbd class="calibre14">Sink</kbd> is the opposite of a <kbd class="calibre14">Stream</kbd>: instead of representing a sequence of values that are received, it represents a sequence of values that are sent.</p>
<p class="calibre3">We used two methods on <kbd class="calibre14">Client</kbd>, so let's write them:</p>
<pre class="calibre22">use cmd::Command;

impl Client {
    fn new(writer: Writer) -&gt; Client {
        Client {
            writer,
        }
    }

    #[async]
    fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
        Ok(self)
    }
}</pre>
<p class="calibre3">The constructor is very simple and creates the <kbd class="calibre14">struct</kbd> with the provided argument. The <kbd class="calibre14">handle_cmd()</kbd> receives the command sent to the FTP server by this specific client and will handle them; we'll write the code to handle them progressively in this chapter and the next. For now, it only returns <kbd class="calibre14">self</kbd>. Also, take note that this method receives <kbd class="calibre14">self</kbd> by move, instead of by <kbd class="calibre14">reference</kbd>. This is due to a current limitation of the <kbd class="calibre14">futures-await</kbd> crate: for now, async functions cannot take a reference. This issue will probably be fixed later, which will make the code even better. This is why we reassigned to the <kbd class="calibre14">client</kbd> variable in the <kbd class="calibre14">client</kbd> function:</p>
<pre class="calibre22">client = await!(client.handle_cmd(cmd))?;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">FTP codec</h1>
                
            
            
                
<p class="calibre3">The only remaining thing to code before we can try our FTP server is the <kbd class="calibre14">codec</kbd>. So, let's create a new module for the <kbd class="calibre14">codec</kbd>:</p>
<pre class="calibre22">mod codec;</pre>
<p class="calibre3">In the <kbd class="calibre14">src/codec.rs</kbd> file, we'll create our FTP <kbd class="calibre14">codec</kbd>:</p>
<pre class="calibre22">pub struct FtpCodec;</pre>
<p class="calibre3">To create a <kbd class="calibre14">codec</kbd>, we must implement the traits <kbd class="calibre14">Decoder</kbd> and <kbd class="calibre14">Encoder</kbd>. These traits come from the <kbd class="calibre14">tokio-io</kbd> crate:</p>
<pre class="calibre22">use tokio_io::codec::{Decoder, Encoder};</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Decoding FTP commands</h1>
                
            
            
                
<p class="calibre3">Let's first write the decoder:</p>
<pre class="calibre22">use std::io;

use bytes::BytesMut;

use cmd::Command;
use error::Error;

impl Decoder for FtpCodec {
    type Item = Command;
    type Error = io::Error;

    fn decode(&amp;mut self, buf: &amp;mut BytesMut) -&gt;<br class="calibre6"/>     io::Result&lt;Option&lt;Command&gt;&gt; {
        if let Some(index) = find_crlf(buf) {
            let line = buf.split_to(index);
            buf.split_to(2); // Remove \r\n.
            Command::new(line.to_vec())
                .map(|command| Some(command))
                .map_err(Error::to_io_error)
        } else {
            Ok(None)
        }
    }
}</pre>
<p class="calibre3">The <kbd class="calibre14">Decoder</kbd> trait has two associated types, <kbd class="calibre14">Item</kbd> and <kbd class="calibre14">Error</kbd>. The former is the type produced when we're able to decode a sequence of bytes. The latter is the type of the error. We first check if there the bytes <kbd class="calibre14">CR</kbd> and <kbd class="calibre14">LF</kbd>. If we don't find them, we return <kbd class="calibre14">Ok(None)</kbd> to indicate that we need more bytes to parse the command. If we find them, we get the line of the command, excluding these bytes. Then, we skip these bytes so that the next parsing does not see them. Finally, we parse the line with <kbd class="calibre14">Command::new()</kbd>.</p>
<p class="calibre3">We used two new functions here that we must implement. The first one is the <kbd class="calibre14">Error::to_io_error()</kbd> method that we'll add to the <kbd class="calibre14">error</kbd> module:</p>
<pre class="calibre22">impl Error {
    pub fn to_io_error(self) -&gt; io::Error {
        match self {
            Io(error) =&gt; error,
            FromUtf8(_) | Msg(_) | Utf8(_) =&gt; <br class="calibre6"/>             io::ErrorKind::Other.into(),
        }
    }
}</pre>
<p class="calibre3">If we have an <kbd class="calibre14">Io</kbd> error, we return it. Otherwise, we return the <kbd class="calibre14">Other</kbd> kind of I/O error.</p>
<p class="calibre3">The <kbd class="calibre14">decode()</kbd> methods also uses the following function:</p>
<pre class="calibre22">fn find_crlf(buf: &amp;mut BytesMut) -&gt; Option&lt;usize&gt; {
    buf.windows(2)
        .position(|bytes| bytes == b"\r\n")
}</pre>
<p class="calibre3">This returns the position of the byte string <kbd class="calibre14">"\r\n"</kbd> if it is present. Remember that this string is the delimiter in the FTP protocol.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encoding FTP commands</h1>
                
            
            
                
<p class="calibre3">We still need to write an <kbd class="calibre14">Encoder</kbd> in order to have a <kbd class="calibre14">codec</kbd> that can send commands to FTP clients:</p>
<pre class="calibre22">use ftp::Answer;

impl Encoder for FtpCodec {
    type Item = Answer;
    type Error = io::Error;

    fn encode(&amp;mut self, answer: Answer, buf: &amp;mut BytesMut) -&gt; io::Result&lt;()&gt; {
        let answer =
            if answer.message.is_empty() {
                format!("{}\r\n", answer.code as u32)
            } else {
                format!("{} {}\r\n", answer.code as u32, <br class="calibre6"/>                 answer.message)
            };
        buf.extend(answer.as_bytes());
        Ok(())
    }
}</pre>
<p class="calibre3">Here, if we have a non-empty message, we push it to the buffer, preceded by the FTP code number. Otherwise, we only push this code number to the buffer.</p>
<p class="calibre3">We can now try the FTP server in FileZilla to see the following result:</p>
<div><img src="img/00043.jpeg" class="calibre36"/><em class="calibre21">Figure 9.1</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handling commands</h1>
                
            
            
                
<p class="calibre3">Our <kbd class="calibre14">handle_cmd()</kbd> method does nothing, for now, so let's update it. First of all, we'll need a method to send a response to a client:</p>
<pre class="calibre22">impl Client {
    #[async]
    fn send(mut self, answer: Answer) -&gt; Result&lt;Self&gt; {
        self.writer = await!(self.writer.send(answer))?;
        Ok(self)
    }
}</pre>
<p class="calibre3">This simply calls the <kbd class="calibre14">send()</kbd> method of the <kbd class="calibre14">writer</kbd>. Since it consumes it, we reassign the result to the attribute.</p>
<p class="calibre3">Now, we'll handle the <kbd class="calibre14">USER</kbd> FTP command:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    println!("Received command: {:?}", cmd);
    match cmd {
        Command::User(content) =&gt; {
            if content.is_empty() {
                self = await! <br class="calibre6"/>          (self.send(Answer::new(ResultCode::InvalidParameterOrArgument, "Invalid  <br class="calibre6"/>           username")))?;
            } else {
                self = await!(self.send(Answer::new(ResultCode::UserLoggedIn,  <br class="calibre6"/>                &amp;format!("Welcome {}!", content))))?;
            }
        }
        Command::Unknown(s) =&gt;
            self = await!(self.send(Answer::new(ResultCode::UnknownCommand,
            &amp;format!("\"{}\": Not implemented", s))))? ,
        _ =&gt; self = await!(self.send(Answer::new(ResultCode::CommandNotImplemented,  <br class="calibre6"/>       "Not implemented")))?,
    }
    Ok(self)
}</pre>
<p class="calibre3">Here, we pattern match to know which command was sent by the client. If it is not <kbd class="calibre14">User</kbd>, we send a response to say that the command is not implemented. If it is <kbd class="calibre14">User</kbd>, we check the content and if it is good, we send the welcome message. This is very similar to what we did in the previous chapter.</p>
<p class="calibre3">If we run the server again, we'll see the following:</p>
<p>&gt;<img src="img/00044.jpeg" class="calibre36"/><em class="calibre21">Figure 9.2</em></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Managing the current working directory</h1>
                
            
            
                
<p class="calibre3">There are still a few commands missing before we can see the files in the FTP client. Let's now add the command to print the current directory and to change it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Printing the current directory</h1>
                
            
            
                
<p class="calibre3">First of all, we'll need a new attribute for our <kbd class="calibre14">Client</kbd> structure to specify what the current directory is: </p>
<pre class="calibre22">use std::path::PathBuf;

struct Client {
    cwd: PathBuf,
    writer: Writer,
}</pre>
<p class="calibre3">The <kbd class="calibre14">cwd</kbd> attribute stands for current working directory. We also need to update the <kbd class="calibre14">Client</kbd> constructor accordingly:</p>
<pre class="calibre22">impl Client {
    fn new(writer: Writer) -&gt; Client {
        Client {
            cwd: PathBuf::from("/"),
            writer,
        }
    }
}</pre>
<p class="calibre3">Now, we can add the handler for the <kbd class="calibre14">PWD</kbd> command:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    println!("Received command: {:?}", cmd);
    match cmd {
        Command::Pwd =&gt; {
            let msg = format!("{}", self.cwd.to_str().unwrap_or(""));
            if !msg.is_empty() {
                let message = format!("\"/{}\" ", msg);
                self = await!(self.send(Answer::new(ResultCode::PATHNAMECreated,  <br class="calibre6"/>                &amp;message)))?;
            } else {
                self = await!(self.send(Answer::new(ResultCode::FileNotFound, "No  <br class="calibre6"/>                such file or directory")))?;
            }
        }
        // …
    }
}</pre>
<p class="calibre3">So, again, we have a code similar to the previous chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Changing the current directory</h1>
                
            
            
                
<p class="calibre3">Let's add another case in our <kbd class="calibre14">match</kbd> expression in the <kbd class="calibre14">handle_cmd()</kbd> method:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        Command::Cwd(directory) =&gt; self = await!(self.cwd(directory))?,
        // …
    }
}</pre>
<p class="calibre3">It simply calls the following method:</p>
<pre class="calibre22">#[async]
fn cwd(mut self, directory: PathBuf) -&gt; Result&lt;Self&gt; {
    let path = self.cwd.join(&amp;directory);
    let (new_self, res) = self.complete_path(path);
    self = new_self;
    if let Ok(dir) = res {
        let (new_self, res) = self.strip_prefix(dir);
        self = new_self;
        if let Ok(prefix) = res {
            self.cwd = prefix.to_path_buf();
            self = await!(self.send(Answer::new(ResultCode::Ok,
                                                &amp;format!("Directory changed to \" <br class="calibre6"/>             {}\"", directory.display()))))?;
            return Ok(self)
        }
    }
    self = await!(self.send(Answer::new(ResultCode::FileNotFound,
                                        "No such file or directory")))?;
    Ok(self)
}</pre>
<p class="calibre3">This code uses the following two methods, which are similar to those in the previous chapter:</p>
<pre class="calibre22">use std::path::StripPrefixError;

fn complete_path(self, path: PathBuf) -&gt; (Self, result::Result&lt;PathBuf, io::Error&gt;) {
    let directory = self.server_root.join(if path.has_root() {
        path.iter().skip(1).collect()
    } else {
        path
    });
    let dir = directory.canonicalize();
    if let Ok(ref dir) = dir {
        if !dir.starts_with(&amp;self.server_root) {
            return (self, <br class="calibre6"/>             Err(io::ErrorKind::PermissionDenied.into()));
        }
    }
    (self, dir)
}

fn strip_prefix(self, dir: PathBuf) -&gt; (Self, result::Result&lt;PathBuf, StripPrefixError&gt;) {
    let res = dir.strip_prefix(&amp;self.server_root).map(|p| p.to_path_buf());
    (self, res)
}</pre>
<p class="calibre3">Since it uses a new attribute, let's add it to the <kbd class="calibre14">Client</kbd> structure:</p>
<pre class="calibre22">struct Client {
    cwd: PathBuf,
    server_root: PathBuf,
    writer: Writer,
}</pre>
<p class="calibre3">We also add its constructor:</p>
<pre class="calibre22">impl Client {
    fn new(writer: Writer, server_root: PathBuf) -&gt; Client {
        Client {
            cwd: PathBuf::from("/"),
            server_root,
            writer,
        }
    }
}</pre>
<p class="calibre3">We also need to pass this value in a few places, first, in the <kbd class="calibre14">client</kbd> function and its wrapper:</p>
<pre class="calibre22">#[async]
fn client(stream: TcpStream, server_root: PathBuf) -&gt; Result&lt;()&gt; {
    // …
    let mut client = Client::new(writer, server_root);
    // …
}

#[async]
fn handle_client(stream: TcpStream, server_root: PathBuf) -&gt; result::Result&lt;(), ()&gt; {
    await!(client(stream, server_root))
        .map_err(|error| println!("Error handling client: {}", <br class="calibre6"/>         error))
}</pre>
<p class="calibre3">Then, we need to update the <kbd class="calibre14">server</kbd> function:</p>
<pre class="calibre22">#[async]
fn server(handle: Handle, server_root: PathBuf) -&gt; io::Result&lt;()&gt; {
    // …
    #[async]
    for (stream, addr) in listener.incoming() {
        let address = format!("[address : {}]", addr);
        println!("New client: {}", address);
        handle.spawn(handle_client(stream, server_root.clone()));
        println!("Waiting another client...");
    }
    Ok(())
}</pre>
<p class="calibre3">To send the server root to the <kbd class="calibre14">handle_client</kbd> function call.</p>
<p class="calibre3">And finally, we'll update the main function to send it to the <kbd class="calibre14">server</kbd> function:</p>
<pre class="calibre22">use std::env;

fn main() {
    let mut core = Core::new().expect("Cannot create tokio Core");
    let handle = core.handle();

    match env::current_dir() {
        Ok(server_root) =&gt; {
            if let Err(error) = core.run(server(handle, <br class="calibre6"/>             server_root)) {
                println!("Error running the server: {}", error);
            }
        }
        Err(e) =&gt; println!("Couldn't start server: {:?}", e),
    }
}</pre>
<p class="calibre3">Here, we send the current directory as the server root.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting the transfer type</h1>
                
            
            
                
<p class="calibre3">Let's add a new command before we test our server again:</p>
<pre class="calibre22">use cmd::TransferType;

#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        // …
        Command::Type(typ) =&gt; {
            self.transfer_type = typ;
            self = await!(self.send(Answer::new(ResultCode::Ok, "Transfer type <br class="calibre6"/>            changed successfully")))?;
        }
        // …
    }
}</pre>
<p class="calibre3">This requires a new attribute for our <kbd class="calibre14">Client</kbd> structure:</p>
<pre class="calibre22">struct Client {
    cwd: PathBuf,
    server_root: PathBuf,
    transfer_type: TransferType,
    writer: Writer,
}</pre>
<p class="calibre3">And we need to update the constructor:</p>
<pre class="calibre22">impl Client {
    fn new(writer: Writer, server_root: PathBuf) -&gt; Client {
        Client {
            cwd: PathBuf::from("/"),
            server_root,
            transfer_type: TransferType::Ascii,
            writer,
        }
    }
}</pre>
<p class="calibre3">If we run this new server and connect to it through FileZilla, we'll see the following:</p>
<div><img src="img/00045.jpeg" class="calibre36"/> <em class="calibre21">Figure 9.3</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Entering passive mode</h1>
                
            
            
                
<p class="calibre3">Let's now write the code to handle the <kbd class="calibre14">PASV</kbd> command. Add the following case in <kbd class="calibre14">handle_cmd()</kbd>:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        // …
        Command::Pasv =&gt; self = await!(self.pasv())?,
        // …
    }
}</pre>
<p class="calibre3">For the following, we'll need four new fields in the <kbd class="calibre14">Client</kbd> structure:</p>
<pre class="calibre22">use futures::stream::SplitStream;

use codec::BytesCodec;

type DataReader = SplitStream&lt;Framed&lt;TcpStream, BytesCodec&gt;&gt;;
type DataWriter = SplitSink&lt;Framed&lt;TcpStream, BytesCodec&gt;&gt;;

struct Client {
    data_port: Option&lt;u16&gt;,
    data_reader: Option&lt;DataReader&gt;,
    data_writer: Option&lt;DataWriter&gt;,
    handle: Handle,
    // …
}</pre>
<p class="calibre3">And all of them are initialized to <kbd class="calibre14">None</kbd>:</p>
<pre class="calibre22">impl Client {
    fn new(handle: Handle, writer: Writer, server_root: PathBuf) -&gt; Client {
        Client {
            data_port: None,
            data_reader: None,
            data_writer: None,
            handle,
            // …
        }
    }
}</pre>
<p class="calibre3">This requires changing a few other functions to send the <kbd class="calibre14">Handle</kbd> to the <kbd class="calibre14">Client</kbd> constructor. First, the <kbd class="calibre14">client</kbd> function now requires a new <kbd class="calibre14">handle</kbd> parameter:</p>
<pre class="calibre22">#[async]
fn client(stream: TcpStream, handle: Handle, server_root: PathBuf) -&gt; Result&lt;()&gt; {
    let (writer, reader) = stream.framed(FtpCodec).split();
    let writer = await!(writer.send(Answer::new(ResultCode::ServiceReadyForNewUser,  <br class="calibre6"/>    "Welcome to this FTP server!")))?;
    let mut client = Client::new(handle, writer, server_root);
    // …
}</pre>
<p class="calibre3">The <kbd class="calibre14">handle_client()</kbd> method also needs to take a new parameter:</p>
<pre class="calibre22">#[async]
fn handle_client(stream: TcpStream, handle: Handle, server_root: PathBuf) -&gt; result::Result&lt;(), ()&gt; {
    await!(client(stream, handle, server_root))
        .map_err(|error| println!("Error handling client: {}", error))
}</pre>
<p class="calibre3">And in the <kbd class="calibre14">server()</kbd> function, you need to send the <kbd class="calibre14">handler</kbd> to the <kbd class="calibre14">handle_client()</kbd> function:</p>
<pre class="calibre22">#[async]
fn server(handle: Handle, server_root: PathBuf) -&gt; io::Result&lt;()&gt; {
    // …
    #[async]
    for (stream, addr) in listener.incoming() {
        // …
        handle.spawn(handle_client(stream, handle.clone(), server_root.clone()));
    }
}</pre>
<p class="calibre3">And here is the start of the method that does the real stuff for the <kbd class="calibre14">PASV</kbd> command:</p>
<pre class="calibre22">#[async]
fn pasv(mut self) -&gt; Result&lt;Self&gt; {
    let port =
        if let Some(port) = self.data_port {
            port
        } else {
            0
        };
    if self.data_writer.is_some() {
        self = await!(self.send(Answer::new(ResultCode::DataConnectionAlreadyOpen,  <br class="calibre6"/>       "Already listening...")))?;
        return Ok(self);
    }

    // …</pre>
<p class="calibre3">If a port was set by an earlier command, we use it, otherwise, we use zero to ask the system to choose one. As you know from the previous chapter, there are two channels in FTP—the command channel and the data channel. So, here, we check whether the data channel is already open. If that is the case, we send the appropriate response and end the function by returning. Here's the rest of the method:</p>
<pre class="sourcecode">    // …

    let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);
    let listener = TcpListener::bind(&amp;addr, &amp;self.handle)?;
    let port = listener.local_addr()?.port();

    self = await!(self.send(Answer::new(ResultCode::EnteringPassiveMode,
                          &amp;format!("127,0,0,1,{},{}", port &gt;&gt; 8, port &amp; 0xFF))))?;

    println!("Waiting clients on port {}...", port);
    #[async]
    for (stream, _rest) in listener.incoming() {
        let (writer, reader) = stream.framed(BytesCodec).split();
        self.data_writer = Some(writer);
        self.data_reader = Some(reader);
        break;
    }
    Ok(self)
}</pre>
<p class="calibre3">We start by starting the listener for the data channel. See the following line:</p>
<pre class="calibre22">let port = listener.local_addr()?.port();</pre>
<p class="calibre3">This is used to get the port that was chosen by the system, if we specified port <kbd class="calibre14">0</kbd> to let the operating system choose a port. Then, we use an <kbd class="calibre14">async for</kbd> loop that breaks immediately after the first iteration because we only have one client that will connect to this new channel. In the loop, we're using the same split trick again; after saying that our stream uses the <kbd class="calibre14">BytesCodec</kbd>, we split the stream between the <kbd class="calibre14">writer</kbd> and the <kbd class="calibre14">reader</kbd>. We'll describe this new <kbd class="calibre14">codec</kbd> shortly. We then same both the data <kbd class="calibre14">writer</kbd> and <kbd class="calibre14">reader</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Bytes codec</h1>
                
            
            
                
<p class="calibre3">We start by creating an empty structure for the <kbd class="calibre14">codec</kbd>:</p>
<pre class="calibre22">pub struct BytesCodec;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Decoding data bytes</h1>
                
            
            
                
<p class="calibre3">Then, we implement the <kbd class="calibre14">Decoder</kbd> trait like we did for the <kbd class="calibre14">FtpCodec</kbd>:</p>
<pre class="calibre22">impl Decoder for BytesCodec {
    type Item = Vec&lt;u8&gt;;
    type Error = io::Error;

    fn decode(&amp;mut self, buf: &amp;mut BytesMut) -&gt; io::Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
        if buf.len() == 0 {
            return Ok(None);
        }
        let data = buf.to_vec();
        buf.clear();
        Ok(Some(data))
    }
}</pre>
<p class="calibre3">Since the data of a transmitted file can be binary, we cannot use an <kbd class="calibre14">Item</kbd> of type <kbd class="calibre14">String</kbd>. We instead use <kbd class="calibre14">Vec&lt;u8&gt;</kbd>, which we can contain every possible byte. If the buffer is empty, we return <kbd class="calibre14">Ok(None)</kbd> to indicate to <kbd class="calibre14">tokio</kbd> that we need more data. Otherwise, we convert it to a vector, clear the buffer and return the vector.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encoding data bytes</h1>
                
            
            
                
<p class="calibre3">Let's now see how to encode data; it's even simpler:</p>
<pre class="calibre22">impl Encoder for BytesCodec {
    type Item = Vec&lt;u8&gt;;
    type Error = io::Error;

    fn encode(&amp;mut self, data: Vec&lt;u8&gt;, buf: &amp;mut BytesMut) -&gt; io::Result&lt;()&gt; {
        buf.extend(data);
        Ok(())
    }
}</pre>
<p class="calibre3">We just extend the buffer with the data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Quitting</h1>
                
            
            
                
<p class="calibre3">Let's now implement the <kbd class="calibre14">QUIT</kbd> command. As always, we need to add a case in the <kbd class="calibre14">handle_cmd()</kbd> method:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        Command::Quit =&gt; self = await!(self.quit())?,
        // …
    }
}</pre>
<p class="calibre3">And here is the code of the <kbd class="calibre14">quit()</kbd> method:</p>
<pre class="calibre22">#[async]
fn quit(mut self) -&gt; Result&lt;Self&gt; {
    if self.data_writer.is_some() {
        unimplemented!();
    } else {
        self = await!(self.send(Answer::new(ResultCode::ServiceClosingControlConnection, "Closing connection...")))?;
        self.writer.close()?;
    }
    Ok(self)
}</pre>
<p class="calibre3">So, we send a response back to the client and <kbd class="calibre14">close()</kbd> the <kbd class="calibre14">writer</kbd>.</p>
<p class="calibre3">To finish this chapter, let's implement the command to create and delete directories.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating directories</h1>
                
            
            
                
<p class="calibre3">We'll start by handling the command to create a new directory. So, we add a case in <kbd class="calibre14">handle_cmd()</kbd>:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        Command::Mkd(path) =&gt; self = await!(self.mkd(path))?,
        // …
    }
}</pre>
<p class="calibre3">And the function handling this command is:</p>
<pre class="calibre22">use std::fs::create_dir;

#[async]
fn mkd(mut self, path: PathBuf) -&gt; Result&lt;Self&gt; {
    let path = self.cwd.join(&amp;path);
    let parent = get_parent(path.clone());
    if let Some(parent) = parent {
        let parent = parent.to_path_buf();
        let (new_self, res) = self.complete_path(parent);
        self = new_self;
        if let Ok(mut dir) = res {</pre>
<p class="calibre3">We first check that the <kbd class="calibre14">parent</kbd> directory is valid and under the server root:</p>
<pre class="calibre23">            if dir.is_dir() {
                let filename = get_filename(path);
                if let Some(filename) = filename {
                    dir.push(filename);
                    if create_dir(dir).is_ok() {
                        self = await! <br class="calibre6"/>               (self.send(Answer::new(ResultCode::PATHNAMECreated,
               "Folder successfully created!")))?;
                        return Ok(self);
                    }
                }
            }
        }
    }
    self = await!(self.send(Answer::new(ResultCode::FileNotFound,
                                        "Couldn't create folder")))?;
    Ok(self)
}</pre>
<p class="calibre3">If it is, we create the directory. Otherwise, we send an error.</p>
<p class="calibre3">This requires two new functions:</p>
<pre class="calibre22">use std::ffi::OsString;

fn get_parent(path: PathBuf) -&gt; Option&lt;PathBuf&gt; {
    path.parent().map(|p| p.to_path_buf())
}

fn get_filename(path: PathBuf) -&gt; Option&lt;OsString&gt; {
    path.file_name().map(|p| p.to_os_string())
}</pre>
<p class="calibre3">These are simple wrappers over the methods from the standard library, doing type conversion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Removing directories</h1>
                
            
            
                
<p class="calibre3">Finally, let's see the code to remove directories:</p>
<pre class="calibre22">#[async]
fn handle_cmd(mut self, cmd: Command) -&gt; Result&lt;Self&gt; {
    match cmd {
        Command::Rmd(path) =&gt; self = await!(self.rmd(path))?,
        // …
    }
}</pre>
<p class="calibre3">Like for the previous commands, we add a new case that calls the method that will handle it:</p>
<pre class="calibre22">use std::fs::remove_dir_all;

#[async]
fn rmd(mut self, directory: PathBuf) -&gt; Result&lt;Self&gt; {
    let path = self.cwd.join(&amp;directory);
    let (new_self, res) = self.complete_path(path);
    self = new_self;
    if let Ok(dir) = res {
        if remove_dir_all(dir).is_ok() {
            self = await!(self.send(Answer::new(ResultCode::RequestedFileActionOkay,
                                                "Folder successfully removed")))?;
            return Ok(self);
        }
    }
    self = await!(self.send(Answer::new(ResultCode::FileNotFound,
                                        "Couldn't remove folder")))?;
    Ok(self)
}</pre>
<p class="calibre3">Here again, we check that the directory is valid and under the server root, and delete it if that is the case. Otherwise, we send an error message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we implemented a lot of commands for our asynchronous FTP server and learned about using <kbd class="calibre14">tokio</kbd>. We also saw in more detail what asynchronous I/O is, and its advantages and disadvantages. We used the new <kbd class="calibre14">async</kbd>/<kbd class="calibre14">await</kbd> syntax to simplify the code using <kbd class="calibre14">tokio</kbd>. We learned what futures and streams are, and how they interact with <kbd class="calibre14">tokio</kbd>. We also saw how to do proper error handling and how to do it concisely. In the next chapter, we'll complete the implementation of the FTP server and see how to test it.</p>


            

            
        
    </body></html>