["```rs\n[dependencies]\n. . .\nbcrypt = \"0.13.0\"\nuuid = {version = \"1.0.0\", features = [\"serde\", \"v4\"]}\n```", "```rs\n└── user\n    ├── mod.rs\n    ├── new_user.rs\n    └── user.rs\n```", "```rs\nuse uuid::Uuid;\nuse diesel::Insertable;\nuse bcrypt::{DEFAULT_COST, hash};\nuse crate::schema::users;\n```", "```rs\n#[derive(Insertable, Clone)]\n#[table_name=\"users\"]\npub struct NewUser {\n    pub username: String,\n    pub email: String,\n    pub password: String,\n    pub unique_id: String,\n}\n```", "```rs\n    impl NewUser {\n    ```", "```rs\n        pub fn new(username: String,\n    ```", "```rs\n            email: String, password: String) -> NewUser {\n    ```", "```rs\n            let hashed_password: String = hash(\n    ```", "```rs\n                    password.as_str(), DEFAULT_COST\n    ```", "```rs\n                ).unwrap();\n    ```", "```rs\n            let uuid = Uuid::new_v4().to_string();\n    ```", "```rs\n            return NewUser {\n    ```", "```rs\n                username,\n    ```", "```rs\n                email,\n    ```", "```rs\n                password: hashed_password,\n    ```", "```rs\n                unique_id: uuid\n    ```", "```rs\n            }\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    extern crate bcrypt;\n    ```", "```rs\n    use diesel::{Queryable, Identifiable};\n    ```", "```rs\n    use bcrypt::verify;\n    ```", "```rs\n    use crate::schema::users;\n    ```", "```rs\n    #[derive(Queryable, Clone, Identifiable)]\n    ```", "```rs\n    #[table_name=\"users\"]\n    ```", "```rs\n    pub struct User {\n    ```", "```rs\n        pub id: i32,\n    ```", "```rs\n        pub username: String,\n    ```", "```rs\n        pub email: String,\n    ```", "```rs\n        pub password: String,\n    ```", "```rs\n        pub unique_id: String\n    ```", "```rs\n    }\n    ```", "```rs\n    impl User {\n    ```", "```rs\n        pub fn verify(&self, password: String) -> bool {\n    ```", "```rs\n        verify(password.as_str(),\n    ```", "```rs\n        &self.password).unwrap()\n    ```", "```rs\n        }\n    ```", "```rs\n    }\n    ```", "```rs\n    pub mod new_user;\n    ```", "```rs\n    pub mod user;\n    ```", "```rs\n    pub mod item;\n    ```", "```rs\n    pub mod user;\n    ```", "```rs\nuse crate::schema::to_do;\nuse chrono::NaiveDateTime;\nuse super::super::user::user::User;\n```", "```rs\n#[derive(Queryable, Identifiable, Associations)]\n#[belongs_to(User)]\n#[table_name=\"to_do\"]\npub struct Item {\n    pub id: i32,\n    pub title: String,\n    pub status: String,\n    pub date: NaiveDateTime,\n    pub user_id: i32,\n}\n```", "```rs\nuse crate::schema::to_do;\nuse chrono::{NaiveDateTime, Utc};\n#[derive(Insertable)]\n#[table_name=\"to_do\"]\npub struct NewItem {\n    pub title: String,\n    pub status: String,\n    pub date: NaiveDateTime,\n    pub user_id: i32,\n}\nimpl NewItem {\n    pub fn new(title: String, user_id: i32) -> NewItem {\n        let now = Utc::now().naive_local();\n        NewItem{\n            title, status: String::from(\"PENDING\"),\n            date: now,\n            user_id\n        }\n    }\n}\n```", "```rs\ntable! {\n    to_do (id) {\n        id -> Int4,\n        title -> Varchar,\n        status -> Varchar,\n        date -> Timestamp,\n        user_id -> Int4,\n    }\n}\ntable! {\n    users (id) {\n        id -> Int4,\n        username -> Varchar,\n        email -> Varchar,\n        password -> Varchar,\n        unique_id -> Varchar,\n    }\n}\n```", "```rs\ndocker-compose up\n```", "```rs\ndiesel migration generate create_users\n```", "```rs\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    username VARCHAR NOT NULL UNIQUE,\n    email VARCHAR NOT NULL UNIQUE,\n    password VARCHAR NOT NULL,\n    unique_id VARCHAR NOT NULL\n);\n```", "```rs\n INSERT INTO users (username, email, password, unique_id)\nVALUES ('placeholder', 'placeholder email',\n'placeholder password', 'placeholder unique id');\n```", "```rs\nALTER TABLE to_do ADD user_id integer default 1\nCONSTRAINT user_id REFERENCES users NOT NULL;\n```", "```rs\nALTER TABLE to_do DROP COLUMN user_id;\nDROP TABLE users\n```", "```rs\njoinable!(to_do -> users (user_id));\nallow_tables_to_appear_in_same_query!(\n    to_do,\n    users,\n);\n```", "```rs\nlet new_post = NewItem::new(title, 1);\n```", "```rs\nuse serde::Deserialize;\n#[derive(Deserialize)]\npub struct NewUserSchema {\n    pub name: String,\n    pub email: String,\n    pub password: String\n}\n```", "```rs\nviews\n...\n└── users\n    ├── create.rs\n    └── mod.rs\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse actix_web::{web, HttpResponse, Responder};\nuse actix_web::HttpResponseBuilder;\nuse crate::database::DB;\nuse crate::json_serialization::new_user::NewUserSchema;\nuse crate::models::user::new_user::NewUser;\nuse crate::schema::users;\n```", "```rs\npub async fn create(new_user: web::Json<NewUserSchema>,\n                    db: DB) -> impl Responder {\n    . . .\n}\n```", "```rs\nlet new_user = NewUser::new(\n    new_user.name.clone(),\n    new_user.email.clone(),\n    new_user.password.clone()\n);\n```", "```rs\nlet insert_result = diesel::insert_into(users::table)\n                            .values(&new_user)\n                            .execute(&db.connection);\n```", "```rs\nmatch insert_result {\n    Ok(_) => HttpResponse::Created(),\n    Err(_) => HttpResponse::Conflict()\n}\n```", "```rs\nmod create;\nuse actix_web::web::{ServiceConfig, post, scope};\npub fn user_views_factory(app: &mut ServiceConfig) {\n    app.service(\n        scope(\"v1/user\")\n        .route(\"create\", post().to(create::create))\n    );\n}\n```", "```rs\nmod auth;\nmod to_do;\nmod app;\nmod users;\nuse auth::auth_views_factory;\nuse to_do::to_do_views_factory;\nuse app::app_views_factory;\nuse users::user_views_factory;\nuse actix_web::web::ServiceConfig;\npub fn views_factory(app: &mut ServiceConfig) {\n    auth_views_factory(app);\n    to_do_views_factory(app);\n    app_views_factory(app);\n    user_views_factory(app);\n}\n```", "```rs\n id |    name     |       email\n----+-------------+-------------------\n  1 | placeholder | placeholder email\n  2 | maxwell     | test@gmail.com\n                           password\n-------------------------------------------------------------\n placeholder password\n $2b$12$jlfLwu4AHjrvTpZrB311Y.W0JulQ71WVy2g771xl50e5nS1UfqwQ.\n              unique_id\n--------------------------------------\n placeholder unique id\n 543b7aa8-e563-43e0-8f62-55211960a604\n```", "```rs\n[dependencies]\n. . .\nchrono = {version = \"0.4.19\", features = [\"serde\"]}\n. . .\njsonwebtoken = \"8.1.0\"\n```", "```rs\nuse actix_web::dev::Payload;\nuse actix_web::{Error, FromRequest, HttpRequest};\nuse actix_web::error::ErrorUnauthorized;\nuse futures::future::{Ready, ok, err};\nuse serde::{Deserialize, Serialize};\nuse jsonwebtoken::{encode, decode, Algorithm, Header,\n                   EncodingKey, DecodingKey, Validation};\nuse chrono::{DateTime, Utc};\nuse chrono::serde::ts_seconds;\nuse crate::config::Config;\n```", "```rs\n#[derive(Debug, Serialize, Deserialize)]\npub struct JwToken {\n    pub user_id: i32,\n    #[serde(with = \"ts_seconds\")]\n    pub minted: DateTime<Utc>\n}\n```", "```rs\nimpl JwToken {\n    pub fn get_key() -> String {\n        . . .\n    }\n    pub fn encode(self) -> String {\n        . . .\n    }\n    pub fn new(user_id: i32) -> Self {\n        . . .\n    }\n    pub fn from_token(token: String) -> Option<Self> {\n        . . .\n    }\n}\n```", "```rs\npub fn get_key() -> String {\n    let config = Config::new();\n    let key_str = config.map.get(\"SECRET_KEY\")\n                            .unwrap().as_str()\n                            .unwrap();\n    return key_str.to_owned()\n}\n```", "```rs\nDB_URL: postgres://username:password@localhost:5433/to_do\nSECRET_KEY: secret\n```", "```rs\npub fn encode(self) -> String {\n    let key = EncodingKey::\n              from_secret(JwToken::get_key().as_ref());\n    let token = encode(&Header::default(), &self,\n                       &key).unwrap();\n    return token\n}\n```", "```rs\npub fn new(user_id: i32) -> Self {\n    let timestamp = Utc::now();\n    return JwToken { user_id, minted: timestamp};\n}\n```", "```rs\npub fn from_token(token: String) -> Option<Self> {\n    let key = DecodingKey::from_secret(\n                JwToken::get_key().as_ref()\n              );\n    let token_result = decode::<JwToken>(\n                        &token, &key,\n                        &Validation::new(Algorithm::HS256)\n                        );\n    match token_result {\n        Ok(data) => {\n            Some(data.claims)\n        },\n        Err(_) => {\n            return None\n        }\n    }\n}\n```", "```rs\nimpl FromRequest for JwToken {\n    type Error = Error;\n    type Future = Ready<Result<JwToken, Error>>;\n    fn from_request(req: &HttpRequest,\n                    _: &mut Payload) -> Self::Future {\n        . . .\n    }\n}\n```", "```rs\nmatch req.headers().get(\"token\") {\n    Some(data) => {\n        . . .\n    },\n    None => {\n        let error = ErrorUnauthorized(\n                    \"token not in header under key 'token'\"\n                    );\n        return err(error)\n    }\n}\n```", "```rs\nSome(data) => {\n    let raw_token = data.to_str()\n                        .unwrap()\n                        .to_string();\n    let token_result = JwToken::from_token(\n                                raw_token\n                            );\n    match token_result {\n        Some(token) => {\n            return ok(token)\n        },\n        None => {\n            let error = ErrorUnauthorized(\n                            \"token can't be decoded\"\n                        );\n            return err(error)\n        }\n    }\n},\n```", "```rs\nuse serde::Deserialize;\n#[derive(Deserialize)]\npub struct Login {\n    pub username: String,\n    pub password: String\n}\n```", "```rs\nuse crate::diesel;\nuse diesel::prelude::*;\nuse actix_web::{web, HttpResponse, Responder};\nuse crate::database::DB;\nuse crate::models::user::user::User;\nuse crate::json_serialization::login::Login;\nuse crate::schema::users;\nuse crate::jwt::JwToken;\n```", "```rs\n. . .\nUse std::collections::HashMap;\npub async fn login(credentials: web::Json<Login>,\n                   db: DB) -> impl HttpResponse {\n    . . .\n}\n```", "```rs\nlet password = credentials.password.clone();\nlet users = users::table\n    .filter(users::columns::username.eq(\n        credentials.username.clone())\n    ).load::<User>(&db.connection).unwrap();\n```", "```rs\nif users.len() == 0 {\n    return HttpResponse::NotFound().await.unwrap()\n} else if users.len() > 1 {\n    return HttpResponse::Conflict().await.unwrap()\n}\n```", "```rs\nmatch users[0].verify(password) {\n    true => {\n        let token = JwToken::new(users[0].id);\n        let raw_token = token.encode();\n        let mut body = HashMap::new();\n      body.insert(\"token\", raw_token);\n        HttpResponse::Ok().json(body)\n    },\n    false => HttpResponse::Unauthorized()\n}\n```", "```rs\nuse actix_web::HttpResponse;\npub async fn logout() -> HttpResponse {\n    HttpResponse::Ok()\n        .content_type(\"text/html; charset=utf-8\")\n        .body(\"<html>\\\n                <script>\\\n                    localStorage.removeItem('user-token'); \\\n                    window.location.replace(\n                        document.location.origin);\\\n                </script>\\\n              </html>\")\n}\n```", "```rs\n. . .\nuse crate::jwt::JwToken;\nuse crate::database::DB\npub async fn create(token: JwToken,\n                    req: HttpRequest, db: DB) -> HttpResponse {\n    . . .\n```", "```rs\nif items.len() == 0 {\n    let new_post = NewItem::new(title, token.user_id);\n    let _ = diesel::\n            insert_into(to_do::table).values(&new_post)\n        .execute(&db.connection);\n}\nReturn HttpResponse::Ok().json(\n    ToDoItems::get_state(token.user_id)\n)\n```", "```rs\n. . .\nUse crate::database::DB;\n. . .\npub async fn delete(to_do_item: web::Json<ToDoItem>,\n                    token: JwToken, db: DB) -> HttpResponse {\n    let items = to_do::table\n        .filter(to_do::columns::title.eq(\n                    &to_do_item.title.as_str())\n                )\n        .filter(to_do::columns::user_id.eq(&token.user_id))\n        .order(to_do::columns::id.asc())\n        .load::<Item>(&db.connection)\n        .unwrap();\n    let _ = diesel::delete(&items[0]).execute(&db.connection);\n    return HttpResponse::Ok().json(ToDoItems::get_state(\n        token.user_id\n    ))\n}\n```", "```rs\npub async fn edit(to_do_item: web::Json<ToDoItem>,\n                  token: JwToken, db: DB) -> HttpResponse {\n    let results = to_do::table.filter(to_do::columns::title\n                              .eq(&to_do_item.title))\n                              .filter(to_do::columns::user_\n                                      id\n                              .eq(&token.user_id));\n    let _ = diesel::update(results)\n        .set(to_do::columns::status.eq(\"DONE\"))\n        .execute(&db.connection);\n    return HttpResponse::Ok().json(ToDoItems::get_state(\n                                   token.user_id\n    ))\n}\n```", "```rs\nuse actix_web::Responder;\nuse crate::json_serialization::to_do_items::ToDoItems;\nuse crate::jwt::JwToken;\npub async fn get(token: JwToken) -> impl Responder {\n    ToDoItems::get_state(token.user_id)\n}\n```", "```rs\n. . .\nuse crate::database::DBCONNECTION;\n. . .\nimpl ToDoItems {\n    . . .\n    pub fn get_state(user_id: i32) -> ToDoItems {\n        let connection = DBCONNECTION.db_connection.get()\n                         .unwrap();\n        let items = to_do::table\n                    .filter(to_do::columns::user_id.eq\n                           (&user_id))\n                    .order(to_do::columns::id.asc())\n                    .load::<Item>(&connection)\n                    .unwrap();\n        let mut array_buffer = Vec::\n                               with_capacity(items.len());\n        for item in items {\n            let status = TaskStatus::from_string(\n            &item.status.as_str().to_string());\n            let item = to_do_factory(&item.title, status);\n            array_buffer.push(item);\n        }\n        return ToDoItems::new(array_buffer)\n    }\n}\n```", "```rs\nuse serde::Serialize;\n#[derive(Serialize)]\npub struct LoginResponse {\n    pub token: String\n}\n```", "```rs\nmatch users[0].clone().verify(credentials.password.clone()) {\n    true => {\n        let user_id = users[0].clone().id;\n        let token = JwToken::new(user_id);\n        let raw_token = token.encode();\n        let response = LoginResponse{token:\n                                     raw_token.clone()};\n        let body = serde_json::\n                   to_string(&response).unwrap();\n        HttpResponse::Ok().append_header((\"token\",\n                           raw_token)).json(&body)\n    },\n    false => HttpResponse::Unauthorized().finish()\n}\n```", "```rs\nmod login;\nmod logout;\nuse actix_web::web::{ServiceConfig, get, post, scope};\npub fn auth_views_factory(app: &mut ServiceConfig) {\n    app.service(\n            scope(\"v1/auth\")\n            .route(\"login\", get().to(login::login))\n            .route(\"login\", post().to(login::login))\n            .route(\"logout\", get().to(logout::logout))\n    );\n}\n```", "```rs\nmissing required claim: exp\n```", "```rs\nuse serde::{Deserialize, Serialize};\nuse jsonwebtoken::{encode, Algorithm, Header, EncodingKey};\n#[derive(Debug, Serialize, Deserialize)]\nstruct Claims {\n   sub: String,\n   company: String\n}\nlet my_claims = Claims {\n    sub: \"b@b.com\".to_owned(),\n    company: \"ACME\".to_owned()\n};\n// my_claims is a struct that implements Serialize\n// This will create a JWT using HS256 as algorithm\nlet token = encode(&Header::default(), &my_claims,\n&EncodingKey::from_secret(\"secret\".as_ref())).unwrap();\n```", "```rs\n. . .\nuse jsonwebtoken::{encode, decode, Header,\n                   EncodingKey, DecodingKey,\n                   Validation};\nuse chrono::Utc;\n. . .\n```", "```rs\n#[derive(Debug, Serialize, Deserialize)]\npub struct JwToken {\n    pub user_id: i32,\n    pub exp: usize,\n}\n```", "```rs\npub fn new(user_id: i32) -> Self {\n    let config = Config::new();\n    let minutes = config.map.get(\"EXPIRE_MINUTES\")\n                            .unwrap().as_i64().unwrap();\n    let expiration = Utc::now()\n    .checked_add_signed(chrono::Duration::minutes(minutes))\n                            .expect(\"valid timestamp\")\n                            .timestamp();\n    return JwToken { user_id, exp: expiration as usize };\n}\n```", "```rs\npub fn from_token(token: String) -> Result<Self, String> {\n    let key = DecodingKey::\n              from_secret(JwToken::get_key().as_ref());\n    let token_result = decode::<JwToken>(&token.as_str(),\n                              &key,&Validation::default());\n    match token_result {\n        Ok(data) => {\n            return Ok(data.claims)\n        },\n        Err(error) => {\n            let message = format!(\"{}\", error);\n            return Err(message)\n        }\n    }\n}\n```", "```rs\nfn from_request(req: &HttpRequest,\n                _: &mut Payload) -> Self::Future {\n    match req.headers().get(\"token\") {\n        Some(data) => {\n            let raw_token = data.to_str()\n                                .unwrap()\n                                .to_string();\n            let token_result = JwToken::\n                        from_token(raw_token);\n            match token_result {\n                Ok(token) => {\n                    return ok(token)\n                },\n                Err(message) => {\n                    if message == \"ExpiredSignature\"\n                                  .to_owned() {\n                        return err(\n                        ErrorUnauthorized(\"token expired\"))\n                    }\n                    return err(\n                    ErrorUnauthorized(\"token can't be decoded\"))\n                }\n            }\n        },\n        None => {\n            return err(\n            ErrorUnauthorized(\n            \"token not in header under key 'token'\"))\n        }\n    }\n}\n```", "```rs\nimport React, {Component} from 'react';\nimport axios from 'axios';\nimport '../css/LoginForm.css';\n```", "```rs\nclass LoginForm extends Component {\n    state = {\n        username: \"\",\n        password: \"\",\n    }\n    submitLogin = (e) => {\n        . . .\n    }\n    handlePasswordChange = (e) => {\n        this.setState({password: e.target.value})\n    }\n    handleUsernameChange = (e) => {\n        this.setState({username: e.target.value})\n    }\n    render() {\n        . . .\n    }\n}\nexport default LoginForm;\n```", "```rs\n<form className=\"login\" onSubmit={this.submitLogin}>\n    <h1 className=\"login-title\">Login</h1>\n    <input type=\"text\" className=\"login-input\"\n    placeholder=\"Username\"\n    autoFocus onChange={this.handleUsernameChange}\n           value={this.state.username} />\n    <input type=\"password\" className=\"login-input\"\n    placeholder=\"Password\"\n    onChange={this.handlePasswordChange}\n           value={this.state.password} />\n    <input type=\"submit\" value=\"Lets Go\"\n    className=\"login-button\" />\n</form>\n```", "```rs\nsubmitLogin = (e) => {\n    e.preventDefault();\n    axios.post(\"http://localhost:8000/v1/auth/login\",\n        {\"username\": this.state.username,\n         \"password\": this.state.password},\n        {headers: {\"Access-Control-Allow-Origin\": \"*\"}}\n        )\n        .then(response => {\n            this.setState({username: \"\", password: \"\"});\n            this.props.handleLogin(response.data[\"token\"]);\n        })\n        .catch(error => {\n            alert(error);\n            this.setState({password: \"\", firstName: \"\"});\n        });\n}\n```", "```rs\nimport LoginForm from \"./components/LoginForm\";\n```", "```rs\nstate = {\n  \"pending_items\": [],\n  \"done_items\": [],\n  \"pending_items_count\": 0,\n  \"done_items_count\": 0,\n  \"login_status\": false,\n}\n```", "```rs\ngetItems() {\n  axios.get(\"http://127.0.0.1:8000/v1/item/get\",\n  {headers: {\"token\": localStorage.getItem(\"user-token\")}})\n  .then(response => {\n      let pending_items = response.data[\"pending_items\"]\n      let done_items = response.data[\"done_items\"]\n      this.setState({\n        \"pending_items\":\n         this.processItemValues(pending_items),\n        \"done_items\": this.processItemValues(done_items),\n        \"pending_items_count\":\n         response.data[\"pending_item_count\"],\n        \"done_items_count\":\n         response.data[\"done_item_count\"]\n        })\n  }).catch(error => {\n      if (error.response.status === 401) {\n        this.logout();\n      }\n  });\n}\n```", "```rs\nlogout() {\n  localStorage.removeItem(\"token\");\n  this.setState({\"login_status\": false});\n}\n```", "```rs\nprocessItemValues(items) {\n  let itemList = [];\n  items.forEach((item, _)=>{\n      itemList.push(\n          <ToDoItem key={item.title + item.status}\n                    title={item.title}\n                    status={item.status}\n                    passBackResponse={this.handleReturnedState}\n                    logout={this.logout}/>\n      )\n  })\n  return itemList\n}\n```", "```rs\nsendRequest = () => {\n    axios.post(\"http://127.0.0.1:8000/v1/item/\" +\n                this.state.button,\n        {\n            \"title\": this.state.title,\n            \"status\": this.inverseStatus(this.state.status)\n        },\n    {headers: {\"token\": localStorage.getItem(\n         \"user-token\")}})\n        .then(response => {\n            this.props.passBackResponse(response);\n        }).catch(error => {\n            if (error.response.status === 401) {\n                this.props.logout();\n            }\n    });\n}\n```", "```rs\ncomponentDidMount() {\n  let token = localStorage.getItem(\"user-token\");\n  if (token !== null) {\n      this.setState({login_status: true});\n      this.getItems();\n  }\n}\n```", "```rs\nhandleLogin = (token) => {\n  localStorage.setItem(\"user-token\", token);\n  this.setState({\"login_status\": true});\n  this.getItems();\n}\n```", "```rs\nif (this.state.login_status === true) {\n    return (\n        <div className=\"App\">\n            <div className=\"mainContainer\">\n                <div className=\"header\">\n                    <p>complete tasks:\n                       {this.state.done_items_count}</p>\n                    <p>pending tasks:\n                       {this.state.pending_items_count}</p>\n                </div>\n                <h1>Pending Items</h1>\n                {this.state.pending_items}\n                <h1>Done Items</h1>\n                {this.state.done_items}\n                <CreateToDoItem\n                 passBackResponse={this.handleReturnedState}/>\n            </div>\n        </div>\n    )\n}\n```", "```rs\nelse {\n    return (\n        <div className=\"App\">\n            <div className=\"mainContainer\">\n                <LoginForm handleLogin={this.handleLogin}\n                />\n            </div>\n        </div>\n    )\n}\n```", "```rs\nbody {\n    background: #2d343d;\n}\n.login {\n    margin: 20px auto;\n    width: 300px;\n    padding: 30px 25px;\n    background: white;\n    border: 1px solid #c4c4c4;\n    border-radius: 25px;\n}\nh1.login-title {\n    margin: -28px -25px 25px;\n    padding: 15px 25px;\n    line-height: 30px;\n    font-size: 25px;\n    font-weight: 300;\n    color: #ADADAD;\n    text-align:center;\n    background: #f7f7f7;\n    border-radius: 25px 25px 0px 0px;\n}\n.login-input {\n    width: 285px;\n    height: 50px;\n    margin-bottom: 25px;\n    padding-left:10px;\n    font-size: 15px;\n    background: #fff;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n}\n.login-input:focus {\n    border-color:#6e8095;\n    outline: none;\n}\n.login-button {\n    width: 100%;\n    height: 50px;\n    padding: 0;\n    font-size: 20px;\n    color: #fff;\n    text-align: center;\n    background: #f0776c;\n    border: 0;\n    border-radius: 5px;\n    cursor: pointer;\n    outline:0;\n}\n.login-lost\n{\n    text-align:center;\n    margin-bottom:0px;\n}\n.login-lost a\n{\n    color:#666;\n    text-decoration:none;\n    font-size:13px;\n}\n.loggedInTitle {\n    font-family: \"Helvetica Neue\";\n    color: white;\n}\n```"]