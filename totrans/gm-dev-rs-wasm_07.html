<html><head></head><body>
		<div id="_idContainer074">
			<h1 id="_idParaDest-76"><em class="italic"><a id="_idTextAnchor114"/>Chapter 5</em>: Collision Detection</h1>
			<p>To make our game fun, our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) needs to run, jump, and slide. Fortunately, we just implemented all that, but he also needs to have something to jump on, something to slide under, and something to crash into. To make this game fun, we'll need to add <strong class="bold">collision detection</strong>, which is one of the most fun and most complicated aspects of game design. </p>
			<p>Collision detection begins with math, detecting whether or not two shapes intersect, but leads to all kinds of interesting questions. We'll deal with some of those in this chapter, such as, how do we handle transparency in sprites? What do we do to make sure a player lands on a platform from above but crashes into a platform if they're underneath it? What about sprites that have shapes that aren't a simple box? It's going to be a blast!</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating a real scene</li>
				<li>Axis-aligned bounding boxes</li>
				<li>Getting bounding boxes from the sprite sheet</li>
				<li>Crashing into a stone</li>
				<li>Landing on and falling off a platform</li>
			</ul>
			<p>By the end of this chapter, you'll have a real game, although it will be a short one. You'll have the skills to build your own scenes with good-looking collision detection, and you'll know how to integrate collision events with your own programs. You'll be able to, if you want, add your own new objects to the scene and crash into them or jump off them, or even fall off the world. Let's get started!</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor115"/>Technical requirements</h1>
			<p>You'll need to download the latest assets for this chapter from <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. </p>
			<p>You can get the source code for this chapter at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. </p>
			<p>No new assets are in the download, so if you downloaded them earlier, you don't need to do it again.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/36BJYJd">https://bit.ly/36BJYJd</a></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor116"/>Creating a real scene</h1>
			<p>At the moment, RHB can move anywhere he <a id="_idIndexMarker382"/>wants, in an empty void, such as the one in <em class="italic">The Matrix</em>. It's progress; all that animation was real work, but it's not a game. It's time we put RHB in a setting – a background, platforms, maybe something to jump over. Let's start with a background.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor117"/>Adding the background </h2>
			<p>Right now, our game <a id="_idIndexMarker383"/>can only render images from a sprite sheet, which we can use for a background, but that's overkill for one image. Instead, we'll add a new <strong class="source-inline">struct</strong> that draws a simple image from a <strong class="source-inline">.png</strong> file. Then, we'll add that to the <strong class="source-inline">draw</strong> and <strong class="source-inline">initialize</strong> functions in <strong class="source-inline">WalkTheDog</strong>:</p>
			<ol>
				<li>Create an <strong class="source-inline">Image</strong> struct.</li>
			</ol>
			<p>We can work bottom-up for these changes, adding code to the engine and then integrating it into the game. Our <strong class="source-inline">Image</strong> <strong class="source-inline">struct</strong> will use a lot of the same code that we wrote in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, but with a simpler setup because we won't be using a sheet. All of this code should go into the <strong class="source-inline">engine</strong> module. </p>
			<p>Start with a <strong class="source-inline">struct</strong> holding <strong class="source-inline">HtmlImageElement</strong>:</p>
			<p class="source-code">pub struct Image {</p>
			<p class="source-code">    element: HtmlImageElement,</p>
			<p class="source-code">    position: Point,</p>
			<p class="source-code">}</p>
			<p class="source-code">impl Image {</p>
			<p class="source-code">    pub fn new(element: HtmlImageElement, position: </p>
			<p class="source-code">        Point) -&gt; Self {</p>
			<p class="source-code">        Self { element, position }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>There's nothing here<a id="_idIndexMarker384"/> you haven't seen before in another form. The <strong class="source-inline">Image struct</strong> holds the image element, presumably loaded via the <strong class="source-inline">load_image</strong> function, and its position in the scene. <strong class="source-inline">Image</strong> will also need a draw function, but there's no simple way to draw the entire image as it is in <strong class="source-inline">Renderer</strong>. That will need a new method, as shown here:</p>
			<p class="source-code">impl Renderer {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn draw_entire_image(&amp;self, image: </p>
			<p class="source-code">        &amp;HtmlImageElement, position: &amp;Point) </p>
			<p class="source-code">            self.context</p>
			<p class="source-code">            .draw_image_with_html_image_element(image, </p>
			<p class="source-code">                position.x.into(), position.y.into())</p>
			<p class="source-code">            .expect("Drawing is throwing exceptions! </p>
			<p class="source-code">                Unrecoverable error.");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This function is very similar to the <strong class="source-inline">draw_image</strong> function we wrote earlier, but it's using the simpler version of the JavaScript <strong class="source-inline">drawImage</strong> function that only takes an image and a position. To use this method, you'll need to be aware of how large the image<a id="_idIndexMarker385"/> you're drawing is. If it's too big or too small, it will show up just as big or small as the source image.</p>
			<ol>
				<li value="2">Now that you've added a method to <strong class="source-inline">Renderer</strong>, go ahead and update the <strong class="source-inline">Image</strong> implementation to draw an image with it:<p class="source-code">impl HtmlImageElement {</p><p class="source-code">    ...</p><p class="source-code">    pub fn draw(&amp;self, renderer: &amp;Renderer) {</p><p class="source-code">        renderer.draw_entire_image</p><p class="source-code">            (&amp;self.element,&amp;self.position)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that you can draw an image, let's load it.</p>
			<ol>
				<li value="3">Load the image.</li>
			</ol>
			<p>The background image can be found in the downloaded assets, in <strong class="source-inline">original/freetileset/png/BG/BG.png</strong>, and can be copied into the <strong class="source-inline">static</strong> directory. Then, it can be loaded and used to create an <strong class="source-inline">Image</strong> <strong class="source-inline">struct</strong>. That will be done in the <strong class="source-inline">game</strong> module, in the <strong class="source-inline">initialize</strong> function of <strong class="source-inline">WalkTheDog</strong>, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn </p>
			<p class="source-code">        Game&gt;&gt; {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p class="source-code">                let sheet = browser::fetch_json</p>
			<p class="source-code">                    ("rhb.json").await?.into_serde()?;</p>
			<p class="source-code">                <strong class="bold">let background = engine::</strong></p>
			<p class="source-code"><strong class="bold">                    load_image("BG.png").await?;</strong></p>
			<p class="source-code">                ....</p>
			<p>In the preceding code snippet, only the highlighted last line is new, which loads the background from <a id="_idIndexMarker386"/>a file. Our <strong class="source-inline">WalkTheDog</strong> <strong class="source-inline">enum</strong> only holds <strong class="source-inline">RedHatBoy</strong>, so we're going to have to restructure the code a little. While we could have the <strong class="source-inline">WalkTheDog::Loaded</strong> state hold a tuple of <strong class="source-inline">RedHatBoy</strong> and <strong class="source-inline">Background</strong>, that's going to get real annoying, real fast. </p>
			<ol>
				<li value="4">To do that, change <strong class="source-inline">enum</strong> to look like this:<p class="source-code">pub enum WalkTheDog {</p><p class="source-code">    Loading,</p><p class="source-code">    Loaded(Walk),</p><p class="source-code">}</p></li>
			</ol>
			<p>We'll have <strong class="source-inline">WalkTheDog</strong> represent our game, but I decided that RHB takes the dog for "<strong class="bold">walks</strong>," so our level will be <strong class="source-inline">Walk</strong>. In a generic framework, I might call this a "<strong class="bold">scene</strong>" or "<strong class="bold">level</strong>," but this is a specific game, so <strong class="source-inline">Walk</strong> should work. </p>
			<ol>
				<li value="5">The <strong class="source-inline">Walk</strong> struct will need to have the RHB and the background, so go ahead and add that:<p class="source-code">pub struct Walk {</p><p class="source-code">    boy: RedHatBoy,</p><p class="source-code">    background: Image,</p><p class="source-code">}</p></li>
			</ol>
			<p>Make sure you've imported <strong class="source-inline">Image</strong> from the <strong class="source-inline">engine</strong> module. Now, you can work your way down<a id="_idIndexMarker387"/> the <strong class="source-inline">game</strong> module and follow the compiler errors. In the <strong class="source-inline">initialize</strong> function for <strong class="source-inline">WalkTheDog</strong>, you should see an error for "<strong class="source-inline">expected struct `Walk`, found struct `RedHatBoy`</strong>".</p>
			<ol>
				<li value="6">Fix that by creating <strong class="source-inline">Walk</strong> with the background we already loaded and setting it in <strong class="source-inline">WalkTheDog::Loaded</strong> that's returned. This will look as follows:<p class="source-code">impl Game for WalkTheDog {</p><p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn </p><p class="source-code">         Game&gt;&gt; {</p><p class="source-code">        ...</p><p class="source-code">        Ok(Box::new(WalkTheDog::Loaded(Walk {</p><p class="source-code">            boy: rhb,</p><p class="source-code">            background: Image::new(background, Point {                 </p><p class="source-code">                x: 0, y: 0 }),</p><p class="source-code">        })))</p><p class="source-code">    }</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ol>
			<p>This will create <strong class="source-inline">Walk</strong> with a boy and <strong class="source-inline">background</strong> positioned at the upper-left corner, but you should still have several compiler errors in the <strong class="source-inline">update</strong> method of <strong class="source-inline">WalkTheDog</strong> because those all assume that <strong class="source-inline">WalkTheDog::Loaded</strong> contains <strong class="source-inline">RedHatBoy</strong>. Each of those can be changed in the exact same way. The first looks like this:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(<strong class="bold">walk</strong>) = self {</p>
			<p class="source-code">            if keystate.is_pressed("ArrowRight") {</p>
			<p class="source-code">                <strong class="bold">walk.boy.</strong>run_right();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            ...</p>
			<p>The <strong class="source-inline">if let WalkTheDog::Loaded</strong> line is unchanged, except now the variable name is <strong class="source-inline">walk</strong> instead of <strong class="source-inline">rhb</strong>. Then, we call <strong class="source-inline">run_right</strong> on <strong class="source-inline">boy</strong> but via the <strong class="source-inline">walk</strong> structure. You <a id="_idIndexMarker388"/>could argue that we should add methods to <strong class="source-inline">Walk</strong> instead of delegating to <strong class="source-inline">boy</strong>, but we'll hold off on that for now. After all, <strong class="source-inline">walk.run_right()</strong> doesn't really make sense. After fixing all the similar compiler errors in <strong class="source-inline">update</strong>, you can also fix a similar error in <strong class="source-inline">draw</strong>, like so:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(<strong class="bold">walk</strong>) = self {</p>
			<p class="source-code">             <strong class="bold">walk.boy.</strong>draw(renderer);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        ...</p>
			<p>Having done all that, you'll now be drawing… well, you'll be drawing RHB again.</p>
			<ol>
				<li value="7">Next, go ahead and draw the background for our game. Drawing the background is a matter of <a id="_idIndexMarker389"/>using our new draw function, so let's add that right before the <strong class="source-inline">walk.boy.draw</strong> function call, as shown here:<p class="source-code">impl Game for WalkTheDog {</p><p class="source-code">    ...</p><p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p><p class="source-code">        if let WalkTheDog::Loaded(walk) = self {</p><p class="source-code">             <strong class="bold">walk.background.draw(renderer);</strong></p><p class="source-code">             walk.boy.draw(renderer);</p><p class="source-code">        }</p><p class="source-code">        ...</p></li>
			</ol>
			<p>After doing that, you should see RHB standing in front of the background, like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 5.1 – Standing in the forest&#13;&#10;" src="image/Figure_5.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Standing in the forest</p>
			<p>Looking at it, you might<a id="_idIndexMarker390"/> wonder, how come RHB is so far to the right if his <em class="italic">x</em> coordinate is <strong class="source-inline">0</strong>? Hang on to that thought, as we'll deal with it soon. First, let's get a platform onto the screen, using our sprite sheet from <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor118"/>Adding an obstacle </h2>
			<p>It's great that we have<a id="_idIndexMarker391"/> RHB in front of a background, and it looks great, but the scene is still a little empty. What if there was something else in the scene? Something grand, something innovative, something larger than life. Well, the budget for art is low, so how about a stone?</p>
			<p>Our new <strong class="source-inline">Image</strong> class means we won't need much code, and you've seen all of it before. To add an obstacle, follow these steps:</p>
			<ol>
				<li value="1">Start by copying <strong class="source-inline">Stone.png</strong> from <strong class="source-inline">original/freetileset/png/Object/Stone.png</strong> in the assets and into the <strong class="source-inline">static</strong> directory. Now, you can add it to <strong class="source-inline">Walk</strong> in the same way you added <strong class="source-inline">Background</strong>, like so:<p class="source-code">struct Walk {</p><p class="source-code">    boy: RedHatBoy,</p><p class="source-code">    background: Image,</p><p class="source-code">    <strong class="bold">stone: Image,</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>That will start causing compiler<a id="_idIndexMarker392"/> errors again because <strong class="source-inline">Walk</strong> is created without a stone. </p>
			<ol>
				<li value="2">In <strong class="source-inline">initialize</strong>, go ahead and load the stone, just as you loaded the background, as shown here:<p class="source-code">impl Game for WalkTheDog {</p><p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn </p><p class="source-code">        Game&gt;&gt; {</p><p class="source-code">        ...</p><p class="source-code">        match self {</p><p class="source-code">            WalkTheDog::Loading =&gt; {</p><p class="source-code">                ...</p><p class="source-code">                let background = engine::load_image</p><p class="source-code">                    ("BG.png").await?;</p><p class="source-code">                <strong class="bold">let stone = engine::</strong></p><p class="source-code"><strong class="bold">                    load_image("Stone.png").await?;</strong></p><p class="source-code">                ...</p></li>
				<li>Then, you need to take the stone that we just loaded and add it to <strong class="source-inline">Walk</strong>. We'll make sure the stone is on the ground by taking the <strong class="source-inline">FLOOR</strong> value (<strong class="source-inline">600</strong>) and subtracting the <a id="_idIndexMarker393"/>height of the stone image, which happens to be <strong class="source-inline">54</strong> pixels. If we position the stone at a <em class="italic">y</em> position of <strong class="source-inline">546</strong>, it should be sitting right on the ground. Here's the update for creating <strong class="source-inline">Walk</strong>:<p class="source-code">impl Game for WalkTheDog {</p><p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn </p><p class="source-code">        Game&gt;&gt; {</p><p class="source-code">        ....</p><p class="source-code">        Ok(Box::new(WalkTheDog::Loaded(Walk {</p><p class="source-code">            boy: rhb,</p><p class="source-code">            background: Image::new(background, Point { </p><p class="source-code">                x: 0, y: 0 }),</p><p class="source-code">            <strong class="bold">stone: Image::new(stone, Point { x: 150, </strong></p><p class="source-code"><strong class="bold">                y: 546 })</strong>,</p><p class="source-code">        })))</p></li>
				<li>The stone is <strong class="source-inline">150</strong> pixels to the right, so it will be in front of RHB. Finally, draw the stone using the <strong class="source-inline">draw</strong> method. That addition is as follows:<p class="source-code">impl Game for WalkTheDog {</p><p class="source-code">    ...</p><p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p><p class="source-code">        if let WalkTheDog::Loaded(walk) = self {</p><p class="source-code">            walk.background.draw(renderer);</p><p class="source-code">            walk.boy.draw(renderer);</p><p class="source-code">            <strong class="bold">walk.stone.draw(renderer);</strong></p><p class="source-code">        }</p></li>
			</ol>
			<p>The code change is small, just drawing the stone with the same call to <strong class="source-inline">draw</strong> that we've used for <strong class="source-inline">boy</strong> and <strong class="source-inline">background</strong>. Do that, and you'll have RHB walking toward the stone:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 5.2 – Look out for that stone!&#13;&#10;" src="image/Figure_5.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Look out for that stone!</p>
			<p>Now, if RHB walks into <a id="_idIndexMarker394"/>that stone, he'll go safely behind it, like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 5.3 – Easiest game ever&#13;&#10;" src="image/Figure_5.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Easiest game ever</p>
			<p>That's not much fun. While we've learned how to add new objects into the game, and drawn them for a more interactive experience, the game doesn't have any challenges yet. We want the boy to <a id="_idIndexMarker395"/>crash into the stone and fall over, ending the game. To do that, we'll need to learn a little about bounding boxes and collision detection, so let's do that in the next section.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor119"/>Axis-aligned bounding boxes </h1>
			<p>Checking whether two objects in our game have collided can, theoretically, be done by checking every pixel in every object and seeing whether they share a location. That logic, in addition to being very complicated to write, would be computationally extremely expensive. We need to run at <strong class="source-inline">60</strong> frames a second and can't spend our precious processing power trying to get that kind of perfection – not if we want the game to be fun, anyway. Fortunately, we can use a simplification that will be close enough to fool our silly eyes, the same way we can't tell that animation is really just a series of still images. That<a id="_idIndexMarker396"/> simplification is called the <em class="italic">bounding box</em>.</p>
			<p>A bounding box is just a rectangle we'll use for collisions, instead of checking each pixel on the sprite. You can think of every sprite having a box around it, which looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 5.4 – Bounding boxes" src="image/Figure_5.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.4 – Bounding boxes</p>
			<p>These boxes aren't actually drawn; they only exist in the memory of the game, except when you want to debug them. When you use boxes, you only have to check for the values of the box – top (<em class="italic">y</em>), left (<em class="italic">x</em>), right (<em class="italic">x</em> + width), and bottom (<em class="italic">y</em> + height). It makes for a much faster comparison. Let's talk in a<a id="_idIndexMarker397"/> little more detail about how to detect when two boxes intersect.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The term "<strong class="bold">axis-aligned</strong>" sounds pretty<a id="_idIndexMarker398"/> fancy, but all it means is that the boxes <a id="_idIndexMarker399"/> aren't rotated. <em class="italic">Y</em> will be up and down, <em class="italic">X</em> left to right, and always aligned with the game's coordinate system.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor120"/>Collision </h2>
			<p>In order to detect whether two <a id="_idIndexMarker400"/>boxes collide or overlap, they will exist in the same 2D  <a id="_idIndexMarker401"/>coordinate space we've been using since the beginning of this book. They may not be visible, but they are there, sitting where the stone is or running along with RHB. They'll need a position in <em class="italic">x</em> and <em class="italic">y</em>, just like a sprite already has, and also a width and height. When we check whether two boxes are colliding, we check in both the <em class="italic">x</em> and <em class="italic">y</em> axes. Let's first look at how you can tell whether two boxes intersect in the <em class="italic">x</em> axis. Given there are two boxes, box 1 intersects box 2 if the left side (or <em class="italic">x</em> position) of box 1 is less than the right side of box 2 but the right side of box 1 is greater than the left side of box 2. This is easier to explain visually:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 5.5 – Collisions&#13;&#10;" src="image/Figure_5.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Collisions</p>
			<p>The preceding figure shows three sets of two boxes that could potentially collide, in a space where <em class="italic">x</em> increases as you move to the right, just like our canvas. The first two comparisons don't collide, but the third does. </p>
			<p>Take a look at the first <a id="_idIndexMarker402"/>comparison where box 1 is to the left of box 2, with a gap in between them. As you can see, the left side of box 1 is well to the left of the right side of box 2, as shown by the arrows. This passes the first condition for collision – the left side of box 1 must be less than the right side of box 2. However, the right side of box 1 is to the left of box 2's left side, which violates our second condition. To collide, the right side of box 1 must be greater than (to the right) of the left side of box 2, so these two boxes don't collide. </p>
			<p>In the second comparison, box 1 has been moved to the right of box 2, again without overlapping. Box 1's right side is now to the right of box 2's left side, so they meet the second condition of colliding, but the left side of box 1 is now also to the right of box 2's right side, so the boxes don't meet the first condition and still don't collide. </p>
			<p>Finally, in the third comparison, the left side of box 1 is again to the right of box 2's right side, but the left side of box 1 is to the left of box 2's right side. These two boxes collide. Box 1 and box 2 have overlapping <em class="italic">x</em> values, so they collide.</p>
			<p>If images aren't your style, it can also help to look at real numbers to see how this algorithm works. Assuming box 1 and box 2 are both 10 x 10, squares we can form a table, like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="" src="image/Table_5.01_B17151.jpg"/>
				</div>
			</div>
			<p>In every row of this table – that is, every example set of coordinates – box 2 is in the same place. There are actually four examples here. In the first row, box 1 is completely to the left of box 2. In the second, the boxes collide because box 1's right edge hits box 2's left edge. In the third, they collide because box 1's left edge is hitting box 2's right edge. Finally, in the fourth row, box 1 is not completely to the right of box 2. The values hold the same properties of the images; either the left edge or right edge of the first box is between the left and right edge of the second box. This long explanation leads to the following short pseudocode:</p>
			<p class="source-code">if (box_one.x &lt; box_two.right) &amp;&amp;</p>
			<p class="source-code">    (box_one.right &gt; box_two.x) {</p>
			<p class="source-code">        log!("Collision!");</p>
			<p class="source-code">    }</p>
			<p>This satisfies two of the conditions I mentioned at the beginning, but what about the vertical axis (<em class="italic">y</em>)? That works in a similar way, only instead of using the left and right sides, we use the top<a id="_idIndexMarker403"/> and bottom values respectively. The top of box 1 must be above, which means less than, the bottom of box 2. The bottom of box 1 must be below the top of box 2. If both of those are true, the boxes collide. Remember that <em class="italic">y</em> goes up as we go down the screen in our coordinate space:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 5.6 – Vertical collisions" src="image/Figure_5.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Vertical collisions</p>
			<p>Let's take a moment to work through these three comparisons, just as we did before. For the first comparison, the top of box 1 is above the bottom of box 2, but the bottom of box 1 is also above the top of box 2, so they do not overlap. </p>
			<p>In the second case, box 1 is completely below box 2, with no collision. The bottom of box 1 is below the top of box 2, which must be true for a collision, but the top of box 1 is also below the bottom of box 2, so our first rule of vertical collisions does not hold.</p>
			<p>In the third comparison, the top of box 1 is above the bottom of box 2, and the bottom of box 1 is below the top of box 2, so we have a collision. This means we can extend our pseudocode to look like the following:</p>
			<p class="source-code">if (box_one.x &lt; box_two.right) &amp;&amp;</p>
			<p class="source-code">    (box_one.right &gt; box_two.x) &amp;&amp;</p>
			<p class="source-code">    <strong class="bold">(box_one.y &lt; box_two.bottom) &amp;&amp;</strong></p>
			<p class="source-code">    <strong class="bold">(box_one.bottom &gt; box_two.y) {</strong></p>
			<p class="source-code">        log!("Collision!");</p>
			<p class="source-code">    }</p>
			<p>Those are the four<a id="_idIndexMarker404"/> things that must be true to get a collision. So, now that we know our collisions, we can apply bounding boxes to RHB and a stone so that they can collide. Unfortunately, a naive approach will lead to really difficult collisions and a nearly impossible game. That problem can be summarized in one word – transparency.</p>
			<h3>Transparency</h3>
			<p>In <em class="italic">Figure 5.7</em>, I've drawn <a id="_idIndexMarker405"/>bounding boxes in red for both RHB and the stone:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 5.7 – Bounding boxes" src="image/Figure_5.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Bounding boxes</p>
			<p>These bounding boxes were created by using the size of the entire sprite after it was loaded, using the width and height properties of <strong class="source-inline">HTMLImageElement</strong>. As you can see, the boxes are far larger than their corresponding sprites, especially the one for RHB. This is because the sprite has transparency, which we do not want to include in our bounding boxes. Right now, the boxes collide, and RHB would be knocked over by the stone well before touching it. That's not what we want!</p>
			<p>This is an example of the<a id="_idIndexMarker406"/> primary debugging technique for bounding box collisions – drawing the boxes so that you can see what's wrong. In this case, RHB's box is just way too big. It should be the minimum size required to contain the entire image, and the bug this is revealing is that the sprite sheet we used in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, contains a lot of transparency. We'll need to fix that before RHB will properly collide with the stone, so let's start trimming the sprite sheet.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor121"/>Trimming the sprite sheet</h1>
			<p>In order to have<a id="_idIndexMarker407"/> RHB crash into a stone, we're going to have to deal with the transparency. Let's take a look at the raw <strong class="source-inline">.png</strong> file that RHB is coming from. A portion of the image is shown in <em class="italic">Figure 5.8</em>, as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 5.8 – The sprite sheet" src="image/Figure_5.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – The sprite sheet</p>
			<p>This is two frames of the <em class="italic">idle</em> animation, with black lines showing the image borders. As you can see, there is a <strong class="bold">ton</strong> of extra space in these images, so using a bounding box that's the same size as the image won't work. That's the problem you see with the bounding boxes in <em class="italic">Figure 5.7</em>. We have two choices to fix it. The simplest, although annoying, would be to open our sprite sheet in a graphics editor and find out the actual pixels for the bounding boxes for each sprite. Then, we would store that in code or a separate file and use those bounding boxes. That's faster in development time, but it means loading a much larger image than is necessary and rendering a bunch of transparency for no reason. It's a big performance hit to avoid writing some code, but we might do that if we were in a game jam and needed to finish the game in a hurry.</p>
			<p>What we're going to do is use a <em class="italic">trimmed</em> sprite sheet, which has the transparency taken out. This will <a id="_idIndexMarker408"/>mean writing a little code to make sure the sprites still line up, but the memory savings alone (because of a smaller graphic file) will be worth it.</p>
			<p>Our trimmed sprite sheet will look like the following (this is a segment):</p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 5.9 – The trimmed sheet&#13;&#10;" src="image/Figure_5.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – The trimmed sheet</p>
			<p>Note that while the white space is trimmed, it's not all removed. That's because each rectangle is still the same size across the entire sheet. Look at how the knocked-out version of RHB takes up the entire rectangle horizontally but the idle RHB takes it up vertically. This means that we'll have to account for some transparency with our bounding box, but fortunately, our sprite sheet JSON will also have that data. We'll also need to make sure that the sprites are lined up properly so that the animations don't jerk around the screen. Fortunately, the JSON provides that data as well.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the sprite<a id="_idIndexMarker409"/> sheets used here are generated with a tool called <strong class="bold">TexturePacker</strong>. That includes the JSON that goes along with the graphics. While you can make your own texture maps, why would you? TexturePacker (with both free and paid-for versions) can be found here: <a href="https://bit.ly/3hvZtDQ">https://bit.ly/3hvZtDQ</a>. TexturePacker has built-in tools for trimming a sprite sheet and exporting the data we need to make them useful in our game.</p>
			<p>The trimmed<a id="_idIndexMarker410"/> version of the sprite sheet data file will have a little more information to go along with what we used in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>. Here's an example of the first two idle sprites from the new JSON file:</p>
			<p class="source-code">"Idle (1).png":</p>
			<p class="source-code">{</p>
			<p class="source-code">    "frame": {"x":117,"y":122,"w":71,"h":115},</p>
			<p class="source-code">    "rotated": false,</p>
			<p class="source-code">    "trimmed": true,</p>
			<p class="source-code">    "spriteSourceSize": {"x":58,"y":8,"w":71,"h":115},</p>
			<p class="source-code">    "sourceSize": {"w":160,"h":136}</p>
			<p class="source-code">},</p>
			<p class="source-code">"Idle (2).png":</p>
			<p class="source-code">{</p>
			<p class="source-code">    "frame": {"x":234,"y":122,"w":71,"h":115},</p>
			<p class="source-code">    "rotated": false,</p>
			<p class="source-code">    "trimmed": true,</p>
			<p class="source-code">    "spriteSourceSize": {"x":58,"y":8,"w":71,"h":115},</p>
			<p class="source-code">    "sourceSize": {"w":160,"h":136}</p>
			<p class="source-code">},</p>
			<p>Both frames have the <strong class="source-inline">frame</strong> data that we used previously to cut out our sprite, but they also include a <strong class="source-inline">spriteSourceSize</strong> field. That field contains the bounding box for the non-transparent portion of the sprite. In other words, the first two idle frames had their sprite start with <strong class="source-inline">57</strong> transparent pixels on the left and <strong class="source-inline">8</strong> on top. This information is vital to line up the trimmed sprites, which both start at <strong class="source-inline">0,0</strong>. Failing to use this will result<a id="_idIndexMarker411"/> in an animation that jumps all over the page and looks terrible. Fortunately, this is rectified by taking the position of the sprite and adding the <strong class="source-inline">spriteSourceSize</strong> <em class="italic">x</em> and <em class="italic">y</em> coordinates to it. This will result in the sprite not looking like it's in the right place intuitively – that is, when we position the sprite at <strong class="source-inline">0</strong>, it will show up <strong class="source-inline">58</strong> pixels to the right, but as long as we also account for <strong class="source-inline">spriteSourceSize</strong> when doing collision detection, it won't matter. Once we've accounted for <strong class="source-inline">spriteSourceSize</strong>, our bounding boxes will be tight around our sprite sheet, with minimal transparency started:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 5.10 – The correct bounding boxes" src="image/Figure_5.10_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – The correct bounding boxes</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to draw your own bounding boxes for debugging, and I recommend that you do, you can add a <strong class="source-inline">draw_rect</strong> function to <strong class="source-inline">Renderer</strong> and draw the rectangle on the context. The code can be found in the source for <a href="B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Collision Detection</em>, at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/</a>.</p>
			<p>With these new, corrected bounding boxes, RHB and the stone don't collide, and jumping over the stone safely is eventually possible. In the next section, we'll start by adding the new trimmed sprite sheet.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor122"/>Adding the trimmed sheet </h2>
			<p>In the <strong class="source-inline">sprite_sheets</strong> directory of the <strong class="source-inline">assets</strong> folder, you can find new versions of the sprite sheet named <strong class="source-inline">rhb_trimmed.png</strong> and <strong class="source-inline">rhb_trimmed.json</strong>. Copy those over to <strong class="source-inline">static</strong>, but make sure you rename the files <strong class="source-inline">rhb.png</strong> and <strong class="source-inline">rhb.json</strong> respectively. Start your <a id="_idIndexMarker412"/>server if it isn't already running, and you should see RHB bouncing around on screen because the sprites in the sheet aren't lined up correctly anymore. He'll also be hovering a little bit over the ground:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 5.11 – Shaking RHB" src="image/Figure_5.11_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Shaking RHB</p>
			<p>Our first priority will be to fix up his animation so that it isn't so jerky. This is why we spent so much time discussing <strong class="source-inline">spriteSourceSize</strong> earlier – so that we can fix his animation. First, we'll add that field to <strong class="source-inline">Cell</strong>, which you may or may not recall is in the <strong class="source-inline">engine</strong> module, as shown in the following code snippet:</p>
			<p class="source-code">#[derive(Deserialize, Clone)]</p>
			<p class="source-code">#[serde(rename_all = "camelCase")]</p>
			<p class="source-code">pub struct Cell {</p>
			<p class="source-code">    pub frame: SheetRect,</p>
			<p class="source-code">    pub sprite_source_size: SheetRect,</p>
			<p class="source-code">}</p>
			<p>The changes are the additions of the <strong class="source-inline">#[serde(rename_all)]</strong> directive and a <strong class="source-inline">sprite_source_size</strong> field. While <strong class="source-inline">spriteSourceSize</strong> is the name in the JSON, this is Rust, and in Rust, we use snake case for variable names, which is why we use the <strong class="source-inline">serde(rename_all)</strong> directive. <strong class="source-inline">rename_all = "camelCase"</strong> may seem backward because we're actually renaming to snake case, but that's because the directive refers to serialization, not deserialization. If we were to write out this structure to a JSON file, we'd want to<a id="_idIndexMarker413"/> rename any variables to be camelCase, which means to deserialize, we do the opposite. Thanks to the work we did earlier, <strong class="source-inline">sprite_source_size</strong> will be loaded up from the new JSON file, so next, we'll need to adjust the drawing so that the animation lines up again.</p>
			<p>In the <strong class="source-inline">game</strong> module and the <strong class="source-inline">RedHatBoy</strong> implementation, we'll change the <strong class="source-inline">draw</strong> function slightly to account for the trimming. It looks like the following:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        renderer.draw_image(</p>
			<p class="source-code">        &amp;self.image,</p>
			<p class="source-code">        &amp;Rect {</p>
			<p class="source-code">                x: sprite.frame.x.into(),</p>
			<p class="source-code">                y: sprite.frame.y.into(),</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">        &amp;Rect {</p>
			<p class="source-code">                <strong class="bold">x: (self.state_machine.context().position.x </strong></p>
			<p class="source-code"><strong class="bold">                    + sprite.sprite_source_size.x as i16)</strong></p>
			<p class="source-code">                    <strong class="bold">.into(),</strong></p>
			<p class="source-code">                <strong class="bold">y: (self.state_machine.context().position.y </strong></p>
			<p class="source-code"><strong class="bold">                    + sprite.sprite_source_size.y as i16)</strong></p>
			<p class="source-code">                    <strong class="bold">.into()</strong>,</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p>I've reproduced the entire <strong class="source-inline">draw_image</strong> call for context, but only two lines have changed. Remember <a id="_idIndexMarker414"/>that the <strong class="source-inline">draw_image</strong> call takes two rectangles – the source, which is unchanged, and the destination, which is what we changed. Both the <em class="italic">x</em> and <em class="italic">y</em> coordinates are adjusted by <strong class="source-inline">sprite_source_size</strong> and its respective coordinates. The cast to <strong class="source-inline">i16</strong> might make you nervous because it could cause math errors if the <em class="italic">x</em> or <em class="italic">y</em> position in the sprite sheet is over 2<span class="superscript">15</span>, but that would be a very strange sheet. Finally, the <strong class="source-inline">into</strong> call is on the computed result, to turn <strong class="source-inline">i16</strong> back into <strong class="source-inline">f32</strong> for the <strong class="source-inline">Rect</strong> struct. After making those changes, you should see the animation play correctly, and RHB should return to where he was originally, next to the stone:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 5.12 – Good bounding boxes&#13;&#10;" src="image/Figure_5.12_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Good bounding boxes</p>
			<p>If you're drawing the bounding boxes with <strong class="source-inline">draw_rect</strong>, make sure it's using the same bounding box as the images. Note how the bounding boxes don't overlap anymore. Still, it's very close, and RHB does hover over the ground a little bit. So, let's adjust his starting position just <a id="_idIndexMarker415"/>a bit. At the top of the <strong class="source-inline">red_hat_boy_states</strong> module, we are going to change one constant and add a new one, as follows:</p>
			<p class="source-code">const FLOOR: i16 = 479;</p>
			<p class="source-code">const STARTING_POINT: i16 = -20;</p>
			<p>Previously, <strong class="source-inline">FLOOR</strong> was <strong class="source-inline">475</strong>, but let's push RHB down just a few pixels. We'll also give RHB a negative <em class="italic">x</em> position, to give a little room between him and the stone. Remember that RHB is adjusted back to the right to account for animation, so he won't actually be drawn off screen. Next, we'll modify the <strong class="source-inline">RedHatBoyState&lt;Idle&gt;</strong> implementation, specifically the <strong class="source-inline">new</strong> function, to move RHB's starting point. That change is shown here:</p>
			<p class="source-code">impl RedHatBoyState&lt;Idle&gt; {</p>
			<p class="source-code">    fn new() -&gt; Self {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">            context: RedHatBoyContext {</p>
			<p class="source-code">                frame: 0,</p>
			<p class="source-code">                position: Point {</p>
			<p class="source-code">                    x: <strong class="bold">STARTING_POINT</strong>,</p>
			<p class="source-code">                    y: <strong class="bold">FLOOR</strong>,</p>
			<p class="source-code">                },</p>
			<p class="source-code">                velocity: Point { x: 0, y: 0 },</p>
			<p class="source-code">            },</p>
			<p class="source-code">            _state: Idle {},</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Again, I've included the entire <strong class="source-inline">impl</strong> for context, but the only changes are the initial position of RHB's <strong class="source-inline">RedHatBoyContext</strong>, using the new constants. Do this, and you'll have RHB standing <a id="_idIndexMarker416"/>with a little bit of runway so that he can jump the stone, like so:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 5.13 – Get a running start&#13;&#10;" src="image/Figure_5.13_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Get a running start</p>
			<p>The bounding boxes are correct in our images, but we're not actually using them yet. That's why if you push the right arrow, RHB will still start running and pass right behind the stone. It's time to give the stone and RHB proper axis-aligned bounding boxes, rather than just drawing them, and then use them to knock RHB right over. What<a id="_idTextAnchor123"/> fun!</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor124"/>Colliding with an obstacle</h1>
			<p>To have<a id="_idIndexMarker417"/> collisions, we'll have to actually put the bounding boxes we've seen on both RHB and the stone. Then, in the <strong class="source-inline">update</strong> function of <strong class="source-inline">WalkTheDog</strong>, we'll need to detect that collision, and when that collision happens, we'll move RHB into the <strong class="source-inline">Falling</strong> and <strong class="source-inline">KnockedOut</strong> states, which correspond to the <strong class="source-inline">Dead</strong> animation in the sprite sheet. Much of that code, particularly the state machine, will be very familiar, so I'll refrain from reproducing the parts that are repetitive and highlight the differences. I will remind you of what needs to change in new states, and you can always check the final code at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/</a>.</p>
			<p>Let's start with the easiest bounding box, the one for the <a id="_idTextAnchor125"/>stone.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor126"/>A bounding box for a stone</h2>
			<p>The stone is the simplest of the <a id="_idIndexMarker418"/>bounding boxes because we can just use the size of <strong class="source-inline">HTMLImageElement</strong>. This won't always be the case. If you look at the images of the stone with a bounding box around it, you will notice that it is larger than the stone's actual size, particularly at the corners. For the time being, this will be good enough, but as we proceed, we'll need to keep this in mind.</p>
			<p>To add a bounding box to the <strong class="source-inline">Image</strong> implementation, which is in the <strong class="source-inline">engine</strong> module, we'll want to calculate the bounding box when <strong class="source-inline">Image</strong> is created, in its <strong class="source-inline">new</strong> function, as shown here:</p>
			<p class="source-code">pub struct Image {</p>
			<p class="source-code">    element: HtmlImageElement,</p>
			<p class="source-code">    position: Point,</p>
			<p class="source-code">    <strong class="bold">bounding_box: Rect,</strong></p>
			<p class="source-code">}</p>
			<p class="source-code">impl Image {</p>
			<p class="source-code">    pub fn new(element: HtmlImageElement, position: Point) -&gt; Self {</p>
			<p class="source-code"><strong class="bold">        let bounding_box = Rect {</strong></p>
			<p class="source-code"><strong class="bold">            x: position.x.into(),</strong></p>
			<p class="source-code"><strong class="bold">            y: position.y.into(),</strong></p>
			<p class="source-code"><strong class="bold">            width: element.width() as f32,</strong></p>
			<p class="source-code"><strong class="bold">            height: element.height() as f32,</strong></p>
			<p class="source-code"><strong class="bold">        };</strong></p>
			<p class="source-code">        Self {</p>
			<p class="source-code">            element,</p>
			<p class="source-code">            position,</p>
			<p class="source-code">            <strong class="bold">bounding_box,</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ....</p>
			<p class="source-code">}</p>
			<p>Here, we've added <strong class="source-inline">bounding_box</strong> to the <strong class="source-inline">Image</strong> <strong class="source-inline">struct</strong>, and we construct it in the <strong class="source-inline">new</strong> function using <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> from its <strong class="source-inline">HTMLImageElement</strong> backing. It's worth noting that we had to cast the <strong class="source-inline">element.width()</strong> and <strong class="source-inline">element.height()</strong> calls to <strong class="source-inline">f32</strong>. This should be safe, but if later we're drawing a very large image, then it may become a problem. It's also <a id="_idIndexMarker419"/>worth noting that by creating the bounding box in the <strong class="source-inline">new</strong> function, we're ensuring that anytime <strong class="source-inline">position</strong> is updated, we also need to update <strong class="source-inline">bounding_box</strong>. We could work around this by calculating <strong class="source-inline">bounding_box</strong> every time, and that's a fine solution, but it does mean potentially losing performance. In this case, we'll keep both <strong class="source-inline">position</strong> and <strong class="source-inline">bounding_box</strong> private in <strong class="source-inline">struct</strong> to ensure they don't get out of sync. <strong class="source-inline">Image</strong> objects don't move yet, anyway.</p>
			<p>Given that <strong class="source-inline">bounding_box</strong> is private, we'll need to give it an accessor, so let's do that now:</p>
			<p class="source-code">impl Image {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn bounding_box(&amp;self) -&gt;&amp;Rect {</p>
			<p class="source-code">        &amp;self.bounding_box</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>That takes care of the stone; now, let's give RHB a bound<a id="_idTextAnchor127"/>ing box.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor128"/>A bounding box for RedHatBoy</h2>
			<p>The bounding box <a id="_idIndexMarker420"/>on <strong class="source-inline">RedHatBoy</strong> is a little more complicated for the same reasons that the sprite sheet was more complicated. It needs to align with where the <a id="_idIndexMarker421"/>sheet is, and it needs to adjust based on the animation. Therefore, we won't be able to do what we did for <strong class="source-inline">Image</strong> and store one <strong class="source-inline">bounding_box</strong> tied to the object. Instead, we'll calculate its bounding box based on its current state and the sprite sheet. The code will actually look very similar to <strong class="source-inline">draw</strong>, as seen here:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn bounding_box(&amp;self) -&gt;Rect {</p>
			<p class="source-code">        let frame_name = format!(</p>
			<p class="source-code">            "{} ({}).png",</p>
			<p class="source-code">            self.state_machine.frame_name(),</p>
			<p class="source-code">            (self.state_machine.context().frame / 3) + 1</p>
			<p class="source-code">        );</p>
			<p class="source-code">        let sprite = self</p>
			<p class="source-code">            .sprite_sheet</p>
			<p class="source-code">            .frames</p>
			<p class="source-code">            .get(&amp;frame_name)</p>
			<p class="source-code">            .expect("Cell not found");</p>
			<p class="source-code">        Rect {</p>
			<p class="source-code">            x: (self.state_machine.context().position.x + </p>
			<p class="source-code">                sprite.sprite_source_size.x as i16).into(),</p>
			<p class="source-code">            y: (self.state_machine.context().position.y + </p>
			<p class="source-code">                sprite.sprite_source_size.y as i16).into(),</p>
			<p class="source-code">            width: sprite.frame.w.into(),</p>
			<p class="source-code">            height: sprite.frame.h.into(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>To calculate <strong class="source-inline">bounding_box</strong>, we start by creating <strong class="source-inline">frame_name</strong> from the state name and the current frame, just like how we did in the <strong class="source-inline">draw</strong>, and then we calculate <strong class="source-inline">Rect</strong> from those values using the <a id="_idIndexMarker422"/>same calculations we did when we updated the <strong class="source-inline">draw</strong> function. In fact, it's a good time to clean up some of the <a id="_idIndexMarker423"/>duplications in those two pieces of code, using refactoring. Let's extract functions to get the frame and sprite name, still in the <strong class="source-inline">RedHatBoy</strong> implementation:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn frame_name(&amp;self) -&gt; String {</p>
			<p class="source-code">        format!(</p>
			<p class="source-code">            "{} ({}).png",</p>
			<p class="source-code">            self.state_machine.frame_name(),</p>
			<p class="source-code">            (self.state_machine.context().frame / 3) + 1</p>
			<p class="source-code">        )</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn current_sprite(&amp;self) -&gt; Option&lt;&amp;Cell&gt; {</p>
			<p class="source-code">        self.sprite_sheet.frames.get(&amp;self.frame_name())</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>For <strong class="source-inline">current_sprite</strong>, you'll need to make sure you import <strong class="source-inline">engine::Cell</strong>. Now, we can<a id="_idIndexMarker424"/> replace the <a id="_idIndexMarker425"/>duplicated code in the <strong class="source-inline">bounding_box</strong> implementation, as follows:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    fn bounding_box(&amp;self) -&gt;Rect {</p>
			<p class="source-code">        let sprite = self.current_sprite().expect("Cell not</p>
			<p class="source-code">            found");</p>
			<p class="source-code">        Rect {</p>
			<p class="source-code">            x: (self.state_machine.context().position.x + </p>
			<p class="source-code">                sprite.sprite_source_size.x as i16).into(),</p>
			<p class="source-code">            y: (self.state_machine.context().position.y + </p>
			<p class="source-code">                sprite.sprite_source_size.y as i16).into(),</p>
			<p class="source-code">            width: sprite.frame.w.into(),</p>
			<p class="source-code">            height: sprite.frame.h.into(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>Going further, we can shrink <strong class="source-inline">draw</strong> by removing the duplicated code from <strong class="source-inline">bounding_box</strong> and making a much smaller <strong class="source-inline">draw</strong> function:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        let sprite = self.current_sprite().expect("Cell not </p>
			<p class="source-code">            found");</p>
			<p class="source-code">        renderer.draw_image(</p>
			<p class="source-code">        &amp;self.image,</p>
			<p class="source-code">        &amp;Rect {</p>
			<p class="source-code">                x: sprite.frame.x.into(),</p>
			<p class="source-code">                y: sprite.frame.y.into(),</p>
			<p class="source-code">                width: sprite.frame.w.into(),</p>
			<p class="source-code">                height: sprite.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            &amp;self.bounding_box(),</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>This makes for must<a id="_idIndexMarker426"/> smaller, cleaner implementations, but it's worth paying attention to the fact that we're looking up <strong class="source-inline">current_sprite</strong> twice on every frame. We won't work to fix it now<a id="_idIndexMarker427"/> because we're not seeing any troubles, but we may want to memoize this value later.</p>
			<p>Now that we have both bounding boxes, we can actually see whether RHB collides<a id="_idTextAnchor129"/> with the stone.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor130"/>Crashing on the collision</h2>
			<p>To crash on a <a id="_idIndexMarker428"/>collision, we'll need to check whether the two rectangles intersect using the pseudocode from earlier, only with real code. We'll add that code to <strong class="source-inline">Rect</strong>, which if you recall is part of the <strong class="source-inline">engine</strong> module. That code is the implementation on the <strong class="source-inline">Rect</strong> struct, shown here:</p>
			<p class="source-code">impl Rect {</p>
			<p class="source-code">    pub fn intersects(&amp;self, rect: &amp;Rect) -&gt; bool {</p>
			<p class="source-code">        self.x &lt; (rect.x + rect.width)</p>
			<p class="source-code">        &amp;&amp; self.x + self.width &gt; rect.x</p>
			<p class="source-code">        &amp;&amp; self.y &lt; (rect.y + rect.height)</p>
			<p class="source-code">        &amp;&amp; self.y + self.height &gt; rect.y</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This reproduces the previous pseudocode, checking to see whether there is any overlap and returning <strong class="source-inline">true</strong> if there is. Every time you see <strong class="source-inline">rect.x + rect.width</strong>, that's the right side, and <strong class="source-inline">rect.y + height</strong> is the bottom. Personally, I prefer to put the same rectangle on the left-hand side of this function for every condition, as I find it easier to read and think about. We'll use this code in the <strong class="source-inline">update</strong> function of <strong class="source-inline">WalkTheDog</strong>. That code is small, but it will cause a chain reaction. The collision code is as follows:</p>
			<p class="source-code">impl WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(walk) = self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">           walk.boy.update();</p>
			<p class="source-code">            if walk</p>
			<p class="source-code">                .boy</p>
			<p class="source-code">                .bounding_box()</p>
			<p class="source-code">                .intersects(walk.stone.bounding_box())</p>
			<p class="source-code">            {</p>
			<p class="source-code">                walk.boy.knock_out();</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The check for collisions will happen<a id="_idIndexMarker429"/> right after the call to <strong class="source-inline">update</strong> on <strong class="source-inline">boy</strong>. We check whether the boy's bounding box has intersected the stone's with our brand new <strong class="source-inline">intersects</strong> function, and if it has, we use <strong class="source-inline">knock_out</strong> on the RHB. Poor RHB; fortunately, you can always refresh.</p>
			<p>The <strong class="source-inline">knock_out</strong> function doesn't exist yet; creating it will mean updating our state machine. The <strong class="source-inline">KnockOut</strong> event will cause a transition into the <strong class="source-inline">Falling</strong> state, which will then transition into the <strong class="source-inline">KnockedOut</strong> state when the <strong class="source-inline">Falling</strong> animation has completed. What are we waiting for? Let's knock out RHB!</p>
			<h3>A KnockOut event </h3>
			<p>As we did in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, we'll add new states to <strong class="source-inline">RedHatBoyStateMachine</strong> and "follow the compiler" to know where to fill in the <a id="_idIndexMarker430"/>necessary code. Rust's type system does a great job of making this kind of work easy, giving useful error messages along the way, so I'm only going to highlight passages that are unique. Remember that you can always peek ahead using the source code at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly</a>, although I highly recommend you try writing the implementation yourself first.</p>
			<p>You can get started in the <strong class="source-inline">game</strong> module by adding a <strong class="source-inline">KnockOut</strong> event to <strong class="source-inline">Event</strong> <strong class="source-inline">enum</strong> and a <strong class="source-inline">knock_out</strong> method<a id="_idIndexMarker431"/> onto <strong class="source-inline">RedHatBoy</strong> as with the other state machine transitions, as shown below:</p>
			<p class="source-code">pub enum Event {</p>
			<p class="source-code">    Run,</p>
			<p class="source-code">    Jump,</p>
			<p class="source-code">    Slide,</p>
			<p class="source-code">    <strong class="bold">KnockOut</strong>,</p>
			<p class="source-code">    Update,</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn knock_out(&amp;mut self) {</p>
			<p class="source-code">        self.state_machine = </p>
			<p class="source-code">            self.state_machine.transition(Event::KnockOut);</p>
			<p class="source-code">}</p>
			<p class="source-code">    ...</p>
			<p>This will just move the compiler error into <strong class="source-inline">RedHatBoyStateMachine</strong> because match statements are incomplete, so you'll need to add a <strong class="source-inline">KnockOut</strong> event to <strong class="source-inline">RedHatBoyStateMachine</strong> that will transition from <strong class="source-inline">Running</strong> to <strong class="source-inline">Falling</strong>. That transition is like so:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            (RedHatBoyStateMachine::Running(state), </p>
			<p class="source-code">                Event::KnockOut) =&gt; state.knock_out</p>
			<p class="source-code">                    ().into(),</p>
			<p class="source-code">            (RedHatBoyStateMachine::Jumping(state), </p>
			<p class="source-code">                Event::KnockOut) =&gt;   </p>
			<p class="source-code">                    state.knock_out().into(),</p>
			<p class="source-code">            (RedHatBoyStateMachine::Sliding(state), </p>
			<p class="source-code">                Event::KnockOut) =&gt;   </p>
			<p class="source-code">                    state.knock_out().into(),</p>
			<p class="source-code">            _ =&gt; self,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>You might wonder why we also have transitions from <strong class="source-inline">Jumping</strong> and <strong class="source-inline">Sliding</strong> to <strong class="source-inline">Falling</strong>; that's because if we don't do that, then the user can simply hold down the spacebar to jump continuously, or slide at the right time, and they will pass right through the stone. So, we <a id="_idIndexMarker432"/>need to make sure that all three of those states will transition to <strong class="source-inline">Falling</strong> in order for the game not to have any bugs.</p>
			<p>Of course, there's still a lot missing. <strong class="source-inline">Falling</strong> doesn't exist yet, neither as a member of the <strong class="source-inline">RedHatBoyStateMachine</strong> <strong class="source-inline">enum</strong> nor as a struct. The typestates for <strong class="source-inline">Sliding</strong>, <strong class="source-inline">Jumping</strong>, or <strong class="source-inline">Running</strong> don't have <strong class="source-inline">knock_out</strong> methods, and there's no <strong class="source-inline">From</strong> trait implemented to convert from <strong class="source-inline">Falling</strong> into <strong class="source-inline">RedHatBoyStateMachine::Falling</strong>. You'll need to add both of those, just like before, and fill in the rest of the compiler errors. You'll find that you need two new constants, the number of frames in the falling animation and the name of the falling animation in the sprite sheet. You can look at <strong class="source-inline">rhb.json</strong> and figure out the values, or look at the following listings:</p>
			<p class="source-code">const FALLING_FRAMES: u8 = 29; // 10 'Dead' frames in the sheet, * 3 - 1.</p>
			<p class="source-code">const FALLING_FRAME_NAME: &amp;str = "Dead";</p>
			<p>If you've made all the proper boilerplate changes, you'll end up making a transition from <strong class="source-inline">Running</strong> to <strong class="source-inline">Falling</strong> that looks like the following code:</p>
			<p class="source-code">impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">    pub fn knock_out(self) -&gt; RedHatBoyState&lt;Falling&gt; {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">                context: self.context,</p>
			<p class="source-code">                _state: Falling {},</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>Note that you're only transitioning states at this point, not making any changes to <strong class="source-inline">RedHatBoyContext</strong>. This is why things get weird because when RHB collides with the stone, he falls over… and keeps<a id="_idIndexMarker433"/> sliding and falling over forever:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 5.14 – Sliding while falling?" src="image/Figure_5.14_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Sliding while falling?</p>
			<p>The transition properly moves into the <strong class="source-inline">Dead</strong> animation, but it doesn't stop RHB's forward motion. Let's change the transition to stop <strong class="source-inline">RedHatBoy</strong>:</p>
			<p class="source-code">impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">    pub fn knock_out(self) -&gt; RedHatBoyState&lt;Falling&gt; {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">                context: self.context.reset_frame().stop(),</p>
			<p class="source-code">                _state: Falling {},</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p>Now, when setting the new state, we call <strong class="source-inline">reset_frame()</strong> to set the frame to <strong class="source-inline">0</strong>, as we always do when changing animations, and call the new <strong class="source-inline">stop</strong> function that will halt the character's forward motion. Of course, that function isn't written yet. It's attached to the <strong class="source-inline">RedHatBoyContext</strong> implementation, setting the <strong class="source-inline">velocity.x</strong> to <strong class="source-inline">0</strong>:</p>
			<p class="source-code">impl RedHatBoyContext {</p>
			<p class="source-code">      fn stop(mut self) -&gt; Self {</p>
			<p class="source-code">          self.velocity.x = 0;</p>
			<p class="source-code">              self</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">...</p>
			<p>You'll want to do the same transition <a id="_idIndexMarker434"/>when going from <strong class="source-inline">Sliding</strong> to <strong class="source-inline">Falling</strong> and <strong class="source-inline">Jumping</strong> to <strong class="source-inline">Falling</strong> as well so that the transitions match. That will halt the character's forward motion but will not stop the death animation from playing over and over again. That's because we never transition out of the <strong class="source-inline">Falling</strong> state and into <strong class="source-inline">KnockedOut</strong>, which itself doesn't exist yet. Fortunately, we've done code like this before. Remember in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, we transitioned out of the <strong class="source-inline">Sliding</strong> animation and back into the <strong class="source-inline">Running</strong> animation when the slide animation was complete. That code, which is in the <strong class="source-inline">update</strong> function of <strong class="source-inline">RedHatBoyState&lt;Sliding&gt;</strong>, is reproduced here:</p>
			<p class="source-code">impl RedHatBoyState&lt;Sliding&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn update(mut self) -&gt; SlidingEndState {</p>
			<p class="source-code">        self.update_context(SLIDING_FRAMES);</p>
			<p class="source-code">        if self.context.frame &gt;= SLIDING_FRAMES {</p>
			<p class="source-code">            SlidingEndState::Running(self.stand())</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            SlidingEndState::Sliding(self)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this code, we check every update and see whether the <strong class="source-inline">Sliding</strong> animation is complete via <strong class="source-inline">if state_machine.context.frame&gt;= SLIDING_FRAMES</strong>. If it is, we return the <strong class="source-inline">Running</strong> state instead of the <strong class="source-inline">Sliding</strong> state. In order to get this far, you already had to add an <strong class="source-inline">update</strong> method to <strong class="source-inline">RedHatBoyState&lt;Falling&gt;</strong>, likely with a generic default that <a id="_idIndexMarker435"/>played the animation. Now, you'll need to mimic this behavior and transition into the new <strong class="source-inline">KnockedOut</strong> state. Specifically, you'll need to do the following:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">KnockedOut</strong> state.</li>
				<li>Create a transition from <strong class="source-inline">Falling</strong> to <strong class="source-inline">KnockedOut</strong>.</li>
				<li>Check in the <strong class="source-inline">update</strong> action whether the <strong class="source-inline">Falling</strong> animation is complete, and if so, transition to the <strong class="source-inline">KnockedOut</strong> state instead of staying in <strong class="source-inline">Falling</strong>.</li>
				<li>Create an <strong class="source-inline">enum</strong> to handle both end states of the <strong class="source-inline">update</strong> method in <strong class="source-inline">RedHatBoyState&lt;Falling&gt;</strong>, as well as the corresponding <strong class="source-inline">From</strong> trait, to convert from that to the <strong class="source-inline">RedHatBoyStateMachine</strong>-appropriate <strong class="source-inline">enum</strong> variant.</li>
			</ol>
			<p>The only thing new here is that <strong class="source-inline">RedHatBoyState&lt;KnockedOut&gt;</strong> will not need the <strong class="source-inline">update</strong> method because, in the <strong class="source-inline">KnockedOut</strong> state, RHB doesn't do anything. We won't go through that code step by step, and instead, I highly encourage you to try it yourself. If you get stuck, you can look at the code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. When you're done, it should look like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 5.15 – Just taking a nap" src="image/Figure_5.15_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Just taking a nap</p>
			<p>In the meantime, I'll <a id="_idIndexMarker436"/>assume you did it because you're awesome, so we'll move on to j<a id="_idTextAnchor131"/>umping onto a platform.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor132"/>Jumping onto a platform</h1>
			<p>Now that RHB crashes into <a id="_idIndexMarker437"/>a stone, we'll need to find a way to go over it. Play the game and try jumping the rock; you'll that notice it's really difficult. The timing has to be just right, reminiscent of the scorpions in the classic game <em class="italic">Pitfall</em> for the Atari 2600. Later in this chapter, we'll adjust that by shrinking the bounding boxes and increasing the horizontal speed of RHB, but first, we're going to put a platform above the stone that RHB can jump on to avoid the rock. In addition to putting a platform on screen with a new sprite sheet and giving it a bounding box, we'll have to handle a new type of collision. Specifically, we'll need to handle collisions coming from above the platform so that we can land on it.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor133"/>Adding a platform </h2>
			<p>We'll start by adding the platform<a id="_idIndexMarker438"/> from a new sprite sheet. This sprite sheet actually contains the elements that will make up our map in the upcoming chapters, but we'll use it for just one platform for now. The sprite sheet looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 5.16 – Our platforms&#13;&#10;" src="image/Figure_5.16_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – Our platforms</p>
			<p>The image is divided up into <a id="_idIndexMarker439"/>squares that aren't outlined but are visible in the way the <a id="_idIndexMarker440"/>shapes are arranged, called tiles. Those squares are the sprites that we'll be mixing and matching to make various obstacles for RHB to jump over and slide under. The tiles are also jammed together nice and tight, so we won't have to concern ourselves with any offsets. For the time being, we'll only need the platform at the lower-right corner, which will float over the stone:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 5.17 – One platform" src="image/Figure_5.17_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – One platform</p>
			<p>This one is conveniently<a id="_idIndexMarker441"/> set up with the sprites in order, so it will be easy to access in the sprite sheet. You can see those dotted lines now marking the three sprites. Let's get it into our game. In the <strong class="source-inline">sprite_sheets</strong> directory of the assets, you'll find two files, <strong class="source-inline">tiles.json</strong> and <strong class="source-inline">tiles.png</strong>. This is the sheet for the tiles, which we'll need to load at startup. So that we have something to load it into, we'll start by creating a <strong class="source-inline">Platform</strong> struct in the <strong class="source-inline">game</strong> module:</p>
			<p class="source-code">struct Platform {</p>
			<p class="source-code">    sheet: Sheet,</p>
			<p class="source-code">    image: HtmlImageElement,</p>
			<p class="source-code">    position: Point,</p>
			<p class="source-code">}</p>
			<p class="source-code">impl Platform {</p>
			<p class="source-code">    fn new(sheet: Sheet, image: HtmlImageElement, position:         Point) -&gt; Self {</p>
			<p class="source-code">        Platform {</p>
			<p class="source-code">            sheet,</p>
			<p class="source-code">            image,</p>
			<p class="source-code">            position,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>So far, this just loads up the expected data. At this point, you may note that <strong class="source-inline">sheet</strong> and <strong class="source-inline">image</strong> are paired together repeatedly, which means they are good candidates for refactoring into a new structure, such as <strong class="source-inline">SpriteSheet</strong>. We won't do that now because we don't want to be premature and refactor to a bad abstraction, but we'll keep an eye out for the duplication if it shows up again.</p>
			<p>The platform is going to<a id="_idIndexMarker442"/> need two things. It's going to need to be drawn, and it's going to need a bounding box so that we can land on it. To draw the box, we'll need to draw the three tiles that make that platform on the bottom together. Looking at <strong class="source-inline">tiles.json</strong>, it's hard to tell which platforms we want because the frame names are all just numbers such as <strong class="source-inline">14.png</strong>, so just take my word for it that the tiles are <strong class="source-inline">13.png</strong>, <strong class="source-inline">14.png</strong>, and <strong class="source-inline">15.png</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It's significantly easier to tell which tiles you need to look at using a tool such as TexturePacker. If you don't have that available, you can just draw each of the images from the sheet, with their names displayed as well, and then modify their names in the JSON file to be more readable.</p>
			<p>Let's dive into the <strong class="source-inline">draw</strong> function for <strong class="source-inline">Platform</strong> now, which has a little trick in it, as seen here:</p>
			<p class="source-code">impl Platform {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        let platform = self</p>
			<p class="source-code">            .sheet</p>
			<p class="source-code">            .frames</p>
			<p class="source-code">            .get("13.png")</p>
			<p class="source-code">            .expect("13.png does not exist");</p>
			<p class="source-code">        renderer.draw_image(</p>
			<p class="source-code">        &amp;self.image,</p>
			<p class="source-code">        &amp;Rect {</p>
			<p class="source-code">                x: platform.frame.x.into(),</p>
			<p class="source-code">                y: platform.frame.y.into(),</p>
			<p class="source-code">                width: (platform.frame.w * 3).into(),</p>
			<p class="source-code">                height: platform.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            &amp;Rect {</p>
			<p class="source-code">                x: self.position.x.into(),</p>
			<p class="source-code">                y: self.position.y.into(),</p>
			<p class="source-code">                width: (platform.frame.w * 3).into(),</p>
			<p class="source-code">                height: platform.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">        );</p>
			<p class="source-code">}</p>
			<p>The cheat is that we know that<a id="_idIndexMarker443"/> the three tiles happen to be next to each other in the sheet, so instead of getting all three sprites out of the sheet, we'll just get three times the width of the first sprite. That will happen to include the other two tiles. Don't forget that the second <strong class="source-inline">Rect</strong> is the destination and, as such, should use the <strong class="source-inline">position</strong> field. That second rectangle also corresponds to the bounding box of the platform, so let's create the platform's bounding box function and use it there instead. These changes are shown here:</p>
			<p class="source-code">impl Platform {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn bounding_box(&amp;self) -&gt;Rect {</p>
			<p class="source-code">        let platform = self</p>
			<p class="source-code">            .sheet</p>
			<p class="source-code">            .frames</p>
			<p class="source-code">            .get("13.png")</p>
			<p class="source-code">            .expect("13.png does not exist");</p>
			<p class="source-code">        Rect {</p>
			<p class="source-code">            x: self.position.x.into(),</p>
			<p class="source-code">            y: self.position.y.into(),</p>
			<p class="source-code">            width: (platform.frame.w * 3).into(),</p>
			<p class="source-code">            height: platform.frame.h.into(),</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn draw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        renderer.draw_image(</p>
			<p class="source-code">            &amp;self.image,</p>
			<p class="source-code">            &amp;Rect {</p>
			<p class="source-code">                x: platform.frame.x.into(),</p>
			<p class="source-code">                y: platform.frame.y.into(),</p>
			<p class="source-code">                width: (platform.frame.w * 3).into(),</p>
			<p class="source-code">                height: platform.frame.h.into(),</p>
			<p class="source-code">            },</p>
			<p class="source-code">            &amp;self.bounding_box(),</p>
			<p class="source-code">        );</p>
			<p class="source-code">    }</p>
			<p>This code has the same troubles as other code where we search for the frame on every draw and we're doing it twice. We're also constructing <strong class="source-inline">Rect</strong> on every <strong class="source-inline">bounding_box</strong> call, which we explicitly <a id="_idIndexMarker444"/>avoided earlier. Why the change? Because I know the future, and we'll be changing how we construct this shortly, so it's not worth worrying about saving an extra cycle or two here. Trust me.</p>
			<p>Now that we've made a platform that could theoretically be drawn, let's actually draw it. First, we'll add it to the <strong class="source-inline">Walk</strong> struct, as shown here:</p>
			<p class="source-code">struct Walk {</p>
			<p class="source-code">    boy: RedHatBoy,</p>
			<p class="source-code">    background: Image,</p>
			<p class="source-code">    stone: Image,</p>
			<p class="source-code">    platform: Platform,</p>
			<p class="source-code">}</p>
			<p>Of course, that won't compile because when we create <strong class="source-inline">Walk</strong>, we don't have a platform. We need to update the <strong class="source-inline">initialize</strong> function in <strong class="source-inline">WalkTheDog</strong> to include the new <strong class="source-inline">Platform</strong>, as shown here:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                let stone = engine::</p>
			<p class="source-code">                   load_image("Stone.png").await?;</p>
			<p class="source-code">                <strong class="bold">let platform_sheet = browser::</strong></p>
			<p class="source-code"><strong class="bold">                    fetch_json("tiles.json").await?;</strong></p>
			<p class="source-code">                <strong class="bold">let platform = Platform::new(</strong></p>
			<p class="source-code">                    <strong class="bold">platform_sheet.into_serde::&lt;Sheet&gt;()?,</strong></p>
			<p class="source-code">                    <strong class="bold">engine::load_image("tiles.png").await?,</strong></p>
			<p class="source-code">                    <strong class="bold">Point { x: 200, y: 400 },</strong></p>
			<p class="source-code">                <strong class="bold">);</strong></p>
			<p class="source-code">                ...</p>
			<p class="source-code">                Ok(Box::new(WalkTheDog::Loaded(Walk {</p>
			<p class="source-code">                    boy: rhb,</p>
			<p class="source-code">                    background: Image::new(background,</p>
			<p class="source-code">                        Point { x: 0, y: 0 }),</p>
			<p class="source-code">                    stone: Image::new(stone, Point { x: </p>
			<p class="source-code">                        150, y: 546 }),</p>
			<p class="source-code">                    <strong class="bold">platform</strong>,</p>
			<p class="source-code">                })))</p>
			<p class="source-code">                ...</p>
			<p>There are only a few small changes here, which I've highlighted. We then fetch the <strong class="source-inline">tiles.json</strong> and create a new <strong class="source-inline">Platform</strong> with it and <strong class="source-inline">tiles.png</strong>. Finally, we create <strong class="source-inline">Walk</strong> with <strong class="source-inline">platform</strong>. Drawing the<a id="_idIndexMarker445"/> platform is a one-line change, adding it to the <strong class="source-inline">draw</strong> function of <strong class="source-inline">WalkTheDog</strong>, as shown here:</p>
			<p class="source-code">fndraw(&amp;self, renderer: &amp;Renderer) {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    if let WalkTheDog::Loaded(walk) = self {</p>
			<p class="source-code">        walk.background.draw(renderer);</p>
			<p class="source-code">        walk.boy.draw(renderer);</p>
			<p class="source-code">        walk.stone.draw(renderer);</p>
			<p class="source-code">        <strong class="bold">walk.platform.draw(renderer);</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If you've done this correctly, you should see the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 5.18 – An escape!" src="image/Figure_5.18_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – An escape!</p>
			<p>But while the platform has a bounding box, you aren't using it yet, so we'll need to add that collision to the <strong class="source-inline">update</strong> function of <strong class="source-inline">WalkTheDog</strong>. When colliding with the platform, you'll want to transition from <strong class="source-inline">Jumping</strong> back to <strong class="source-inline">Running</strong>. This transition is already written – we do it when we land on the floor – so you'll just need to add a check and an event that can perform <a id="_idIndexMarker446"/>the transition.</p>
			<p>We'll also need to make sure that RHB stays on the platform. Currently, gravity would just pull him right through it, regardless of whether or not there's a collision or the player is in the <strong class="source-inline">Running</strong> state. That solution is a little more complex. A naive solution, and I know because I wrote it, is to stop applying gravity when the player is on the platform. This works until it<a id="_idIndexMarker447"/> doesn't, causing a <strong class="bold">Wile E. Coyote</strong> effect when RHB runs off the platform and stays in the air. Presumably, if he could look down, he would hold up a sign and then crash to the ground.</p>
			<p>Instead, what we do is continue to apply gravity on every frame and check whether RHB is still landing on the platform. If he is, then we adjust him right back onto the top of it. This effectively means that RHB "lands" repeatedly until he reaches the end of the platform, when he falls off. Fortunately, this<a id="_idIndexMarker448"/> isn't visible to the user, since we calculate RHB's new position on every update, and this results in him moving to the right until he falls off the edge, as he should.</p>
			<p>Let's start by adding the check to the <strong class="source-inline">update</strong> function so that RHB can land on a platform:</p>
			<p class="source-code">fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">    if let WalkTheDog::Loaded(walk) = self {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        walk.boy.update();</p>
			<p class="source-code"><strong class="bold">        if walk</strong></p>
			<p class="source-code"><strong class="bold">            .boy</strong></p>
			<p class="source-code"><strong class="bold">            .bounding_box()</strong></p>
			<p class="source-code"><strong class="bold">            .intersects(&amp;walk.platform.bounding_box())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            walk.boy.land();</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">        if walk</p>
			<p class="source-code">            .boy</p>
			<p class="source-code">            .bounding_box()</p>
			<p class="source-code">            .intersects(walk.stone.bounding_box())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            walk.boy.knock_out()</p>
			<p class="source-code">        }</p>
			<p class="source-code">        ...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>I've reproduced the check for <a id="_idIndexMarker449"/>the boy intersecting the stone as well so that you can see that we checked the bounding box before checking the stone. It doesn't really matter which check comes first, but I prefer to check things that can kill the player last. That way we won't kill the player when we really want them to land on a platform. Just as when we created the <strong class="source-inline">knock_out</strong> method on <strong class="source-inline">RedHatBoy</strong>, the <strong class="source-inline">land</strong> method and its corresponding <strong class="source-inline">Event</strong> don't exist yet. You can create them both now, and follow the compiler until you have to write the transition in the state machines, as shown here:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            (RedHatBoyStateMachine::Jumping(state), Event::Land) =&gt; {</p>
			<p class="source-code">                state.land().into()</p>
			<p class="source-code">            }</p>
			<p class="source-code">            ...</p>
			<p>Remember that we already wrote a transition method from <strong class="source-inline">Jumping</strong> to <strong class="source-inline">Running</strong>, so you won't need to write it, but as I mentioned previously, this isn't enough to land on the platform. The transition will happen, but RHB will fall right through the platform and crash into the ground. Not cool. In order to keep RHB on the platform, we need to set its <em class="italic">y</em> position to the top of the bounding box. This will mean changing the <strong class="source-inline">Land</strong> event to store the <em class="italic">y</em> position of the platform's bounding box. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Because we used <strong class="source-inline">enum</strong> for the events, we can pass any data we need by adding it as part of the variant we are using. The Rust <strong class="source-inline">enum</strong> is a great feature of Rust.</p>
			<p>On every intersection with the <a id="_idIndexMarker450"/>platform, we'll transition with the <strong class="source-inline">Land</strong> event. This means that the <strong class="source-inline">Update</strong> event will pull the player down a bit because of gravity, but then the <strong class="source-inline">Land</strong> event will push them right back up. Since we don't draw the in-between state, it will look fine. This system isn't perfect, but we aren't writing a physics engine. Let's do that now; we'll start by modifying the <strong class="source-inline">land</strong> function to be <strong class="source-inline">land_on</strong>, taking a <em class="italic">y</em> position:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        if walk</p>
			<p class="source-code">            .boy</p>
			<p class="source-code">            .bounding_box()</p>
			<p class="source-code">            .intersects(&amp;walk.platform.bounding_box())</p>
			<p class="source-code">        {</p>
			<p class="source-code">            <strong class="bold">walk.boy.land_on(walk.platform.bounding_box().y);</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>Now, <strong class="source-inline">land_on</strong> instead of <strong class="source-inline">land</strong> takes the <em class="italic">y</em> position of <strong class="source-inline">bounding_box</strong> for the platform. If you just follow the compiler errors for that, you will eventually need to modify the <strong class="source-inline">Land</strong> event to hold the position and modify the <strong class="source-inline">land</strong> method on the <strong class="source-inline">Jumping</strong> typestate. It will probably look something like this:</p>
			<p class="source-code">impl RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn <strong class="bold">land_on</strong>(<strong class="bold">mut self</strong>, position: f32) -&gt; </p>
			<p class="source-code">        RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">            <strong class="bold">self.context.position.y = position as i16;</strong></p>
			<p class="source-code">            RedHatBoyState {</p>
			<p class="source-code">                context: self.context.reset_frame(),</p>
			<p class="source-code">                _state: Running,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>As an initial attempt, this seems <a id="_idIndexMarker451"/>fine. It's unfortunate that <strong class="source-inline">self</strong> had to be made mutable, but the transition sets RHB's position back to the top of the platform. The problem is that the <em class="italic">y</em> position of RHB actually represents his top-left corner. This means that if you followed this to its conclusion, you'd get something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 5.19 – This does not look right" src="image/Figure_5.19_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – This does not look right</p>
			<p>Fortunately, <strong class="source-inline">RedHatBoy</strong> knows his height, so we can adjust for the height when setting the <em class="italic">y</em> position. We would need to include <strong class="source-inline">self.bounding_box.height()</strong> as a parameter in the <strong class="source-inline">Land</strong> event<a id="_idIndexMarker452"/> and then account for it during the transition, like so:</p>
			<p class="source-code">impl RedHatBoyState&lt;Jumping&gt;{</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn land_on(mut self, position: f32, height: f32) {</p>
			<p class="source-code">        let position = (position - height) as i16;</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">            context: self.context.reset_frame(),</p>
			<p class="source-code">            _state: Running,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This sort of works, but it has another problem. The bounding box is actually changing size during the animation, based on the current frame of the animation, because the trimmed sprite shrinks and grows slightly. As we check collisions on every frame, we'll call <strong class="source-inline">Land</strong> repeatedly while RHB is on the platform. If we continually change the landing position based on the current frame's height, the walk ends up looking very "bouncy." Even though the bounding box is changing slightly, it looks better if we use a constant value for the player's height for this calculation.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Game development frequently has a lot of trial and error. When the mathematically correct solution doesn't play well or look right, remember that the feel of the game is more important than mathematical accuracy.</p>
			<p>We already have the player height adjustment; we just created it as the <strong class="source-inline">FLOOR</strong> constant. In the <strong class="source-inline">game</strong> module, you'll see that the <strong class="source-inline">FLOOR</strong> constant is set at <strong class="source-inline">479</strong>. Well, that means that we can use the height of the game (which is <strong class="source-inline">600</strong>) and subtract <strong class="source-inline">FLOOR</strong> to get the player's height. We can use that info to create two new constants. The first, <strong class="source-inline">HEIGHT</strong>, can be defined in the game module as <strong class="source-inline">const HEIGHT: i16 = 600</strong> and used wherever we've hardcoded the <strong class="source-inline">600</strong> value. The second, <strong class="source-inline">PLAYER_HEIGHT</strong>, can be defined in the <strong class="source-inline">red_hat_boy_states</strong> module, as shown here:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code"><strong class="bold">use super::HEIGHT;</strong></p>
			<p class="source-code">  ...</p>
			<p class="source-code">    const FLOOR: i16 = 479;</p>
			<p class="source-code">    <strong class="bold">const PLAYER_HEIGHT: i16 = HEIGHT - FLOOR;</strong></p>
			<p><strong class="source-inline">PLAYER_HEIGHT</strong> belongs in the <strong class="source-inline">red_hat_boy_states</strong> module, since it will only be used there, but to calculate it, we need to import <strong class="source-inline">game::HEIGHT</strong> into the <strong class="source-inline">red_hat_boy_states module</strong>. We do that with the highlighted <strong class="source-inline">use</strong> statement. Now that we have the proper<a id="_idIndexMarker453"/> value to adjust RHB when he lands, we can account for it in the <strong class="source-inline">land_on</strong> method and <strong class="source-inline">RedHatBoyContext</strong>:</p>
			<p class="source-code">impl RedHatBoyContext {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn set_on(mut self, position: i16) -&gt; Self {</p>
			<p class="source-code">        let position = position - PLAYER_HEIGHT;</p>
			<p class="source-code">        self.position.y = position;</p>
			<p class="source-code">        self</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p class="source-code">impl RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">    pub fn land_on(<strong class="bold">self</strong>, position: f32) -&gt;         RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">            context: self.context.reset_frame()</p>
			<p class="source-code">            <strong class="bold">.set_on(position as i16)</strong>,</p>
			<p class="source-code">            _state: Running,</p>
			<p class="source-code">          }</p>
			<p class="source-code">     }</p>
			<p class="source-code">...</p>
			<p>We've moved the adjustment of RHB's position into a <strong class="source-inline">set_on</strong> method in <strong class="source-inline">RedHatBoyContext</strong>. The <strong class="source-inline">set_on</strong> method always adjusts for the player's height, which is why it's named <strong class="source-inline">set_on</strong> and not <strong class="source-inline">set_position_y</strong>. It also returns <strong class="source-inline">self</strong> so that we won't require <strong class="source-inline">mut self</strong> anymore, fitting<a id="_idIndexMarker454"/> with the rest of the operations on <strong class="source-inline">RedHatBoyContext</strong>. </p>
			<p>Changing the <strong class="source-inline">land</strong> method to the <strong class="source-inline">land_on</strong> method also requires you to modify what it is called within the <strong class="source-inline">update</strong> method of <strong class="source-inline">RedHatBoyState&lt;Jumping&gt;</strong>. After all, there is no <strong class="source-inline">land</strong> method anymore. Keep in mind that we have to account for the height when calling <strong class="source-inline">set_on</strong>, as shown here:</p>
			<p class="source-code">    impl RedHatBoyState&lt;Jumping&gt; {</p>
			<p class="source-code">        pub fn update(mut self) -&gt; JumpingEndState {</p>
			<p class="source-code">            self.update_context(JUMPING_FRAMES);</p>
			<p class="source-code">            if self.context.position.y &gt;= FLOOR {</p>
			<p class="source-code">                <strong class="bold">JumpingEndState::Landing(self.land_on</strong></p>
			<p class="source-code"><strong class="bold">                    (HEIGHT.into()))</strong></p>
			<p class="source-code">            } else {</p>
			<p class="source-code">                JumpingEndState::Jumping(self)</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p>Here, we are checking whether RHB is past <strong class="source-inline">FLOOR</strong> and pushing it back up to <strong class="source-inline">HEIGHT</strong>. Remember that When we call land_on we send the position of RHB's feet, not his head. You could argue that the <strong class="source-inline">update</strong> method shouldn't check for hitting the ground and that the higher-level <strong class="source-inline">update</strong> method in <strong class="source-inline">WalkTheDog</strong> should check for collisions with the ground and use the <strong class="source-inline">Land</strong> event when appropriate. I think I'd agree, but we've made more than enough changes for this chapter, so we'll stick with it as it is for now.</p>
			<p>This adjusts the position of RHB for landing. He'll be positioned on the platform or the ground at the end of his jump. Now, we need to make sure that the <strong class="source-inline">Land</strong> event prevents RHB from falling through the platform right after he lands. The <strong class="source-inline">Land</strong> event will happen while <strong class="source-inline">Running</strong> occurs <a id="_idIndexMarker455"/>on the platform, but it isn't handled, so you'll fall right through because gravity takes effect. We're going to need a <strong class="source-inline">Land</strong> transition for every state that is valid on the platform, where the state stays the same but the <strong class="source-inline">y</strong> position is forced back to the top of the platform.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If I might steal a line from the <em class="italic">Big Nerd Ranch</em> series of books, programming is hard and you are not stupid. It may appear that these changes emerged fully formed because I am a super-expert, but in many cases, these only came about through much trial and error, rereading old books, and luck. So, don't worry if you wouldn't have come up with this solution off the top of your head or things have gotten a little confusing. Take another try at the code, slow down, and have fun. We're making a game!</p>
			<p>Fortunately, it's harder to explain why we need this code than to actually write it. We'll handle the <strong class="source-inline">Land</strong> event for <strong class="source-inline">Running</strong> in the <strong class="source-inline">transition</strong> method:</p>
			<p class="source-code">impl RedHatBoyStateMachine {</p>
			<p class="source-code">    fn transition(self, event: Event) -&gt; Self {</p>
			<p class="source-code">        match (self, event) {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            (RedHatBoyStateMachine::Running(state), Event::</p>
			<p class="source-code">                Land(position)) =&gt; {</p>
			<p class="source-code">                state.land_on(position).into()</p>
			<p class="source-code">            }</p>
			<p>Then, we'll add a <strong class="source-inline">land_on</strong> method to the <strong class="source-inline">RedHatBoyState&lt;Running&gt;</strong> typestate, as shown here:</p>
			<p class="source-code">...</p>
			<p class="source-code">impl RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    pub fn land_on(self, position: f32) -&gt; </p>
			<p class="source-code">        RedHatBoyState&lt;Running&gt; {</p>
			<p class="source-code">        RedHatBoyState {</p>
			<p class="source-code">            context: self.context.set_on(position as   </p>
			<p class="source-code">                i16),</p>
			<p class="source-code">            _state: Running {},</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>For every <strong class="source-inline">Land</strong> event in the <strong class="source-inline">Running</strong> state, you<a id="_idIndexMarker456"/> adjust the position and stay in the <strong class="source-inline">Running</strong> state. With that, you should see RHB jump onto a platform:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 5.20 – Running on the platform&#13;&#10;" src="image/Figure_5.20_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Running on the platform</p>
			<p>Running on the platform is <a id="_idIndexMarker457"/>beginning to work, but you'll find a strange bug if you try to run past the edge of the platform. RHB falls through the bottom!</p>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 5.21 – My God! How did I get here?" src="image/Figure_5.21_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – My God! How did I get here?</p>
			<p>It turns out there is a fairly sneaky<a id="_idIndexMarker458"/> bug with the way we are handling gravity, which we'll call the "terminal velocity" bug, and we can address that next.</p>
			<h3>Terminal velocity</h3>
			<p>If you log <a id="_idIndexMarker459"/>RHB's <strong class="source-inline">velocity</strong> in <em class="italic">y</em> in the <strong class="source-inline">update</strong> method as you jump on the platform and walk across it, it looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer065">
					<img alt="Figure 5.22 – Gravity forever!" src="image/Figure_5.22_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – Gravity forever!</p>
			<p>If you recall, we add <strong class="source-inline">1</strong> to the gravity on every update until the player jumps again. This means that, eventually, the gravity gets so large that the player is pulled completely below the platform on an update, and he actually stops intersecting it. Our platform is currently at <strong class="source-inline">400</strong>. When the player<a id="_idIndexMarker460"/> lands on it, he is at <strong class="source-inline">279</strong>, the platform's <em class="italic">y-axis</em> minus the player's height. On the first frame, we pull him down by <strong class="source-inline">1</strong> for gravity, check whether that intersects the platform (it does), and land. On the next frame, we pull him down by <strong class="source-inline">2</strong>, the next by <strong class="source-inline">3</strong>, and so on. Eventually, we actually pull him completely beneath the platform, he does not intersect it, and boom –  he's suddenly below the platform. We need to fix that by giving gravity a <strong class="bold">terminal velocity</strong>.</p>
			<p>In the real-world, terminal velocity is the fastest attainable speed by an object as it falls because of the drag of the air around it (see <a href="https://go.nasa.gov/3roAWGL">https://go.nasa.gov/3roAWGL</a> for more information). We aren't going to calculate RHB's true terminal velocity, as there's no air in his world, but we can use the very scientific method of picking a number and seeing whether it works. We'll set a maximum positive <em class="italic">y</em> velocity of RHB to <strong class="source-inline">20</strong> and clamp his updates to that. That will live in the <strong class="source-inline">RedHatBoyContext</strong> <strong class="source-inline">update</strong> method, where we are already modifying <em class="italic">y</em> for gravity. The code for that is shown here:</p>
			<p class="source-code">mod red_hat_boy_states {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    const TERMINAL_VELOCITY: i16 = 20;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    impl RedHatBoyContext {</p>
			<p class="source-code">        pub fn update(mut self, frame_count: u8) -&gt; Self {</p>
			<p class="source-code">            <strong class="bold">if self.velocity.y &lt; TERMINAL_VELOCITY</strong> {</p>
			<p class="source-code">                self.velocity.y += GRAVITY;</p>
			<p class="source-code">            }</p>
			<p class="source-code">           ...</p>
			<p>Clamping the velocity at <strong class="source-inline">20</strong> fixes our issue with falling through the platform, and now RHB falls off the platform at the end as he should. However, if you try to slide (push the arrow down), you'll see that RHB falls right through the platform. That's because the <strong class="source-inline">Sliding</strong> state doesn't respond to the <strong class="source-inline">Land</strong> event. You can fix that in the exact same way you fixed <strong class="source-inline">Running</strong>, which is an <a id="_idIndexMarker461"/>exercise for you. Give it a try, and remember that if you get stuck, the final source code is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. One hint – when you stay in the same state, you don't call <strong class="source-inline">reset_frame</strong>!</p>
			<p>That's almost the end of it, but there are two more things to take care of – crashing into the bottom of the platfor<a id="_idTextAnchor134"/>m and transparency in the bounding boxes.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor135"/>Collision from below</h2>
			<p>At the moment, if RHB<a id="_idIndexMarker462"/> collides with the platform, he is set on the top, which is great for landing but not so great if he comes from beneath the platform. If you were to comment out the collision with the stone right now and run straight ahead, you'd actually find yourself suddenly pop up onto the platform! Why? Because RHB's head actually bumps into the bottom of the platform, and that collision causes the <strong class="source-inline">land_on</strong> event to fire. Instead of banging his head and falling over, he teleports onto the platform!</p>
			<p>We need to have special collision detection here. RHB can only land on the platform if he comes from above it; otherwise, it's game over. Fortunately, this can be handled in the <strong class="source-inline">update</strong> function with two small changes to the way we check collisions. Collisions with the platform where <strong class="source-inline">RedHatBoy</strong> is <em class="italic">above</em> the platform means landing; otherwise, it's the same as hitting a stone, and you <a id="_idIndexMarker463"/>get knocked out. You also need to be <em class="italic">descending</em>; otherwise, you'll get this weird effect where you stick to the platform while still going up in your jump. Let's see that change:</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        if let WalkTheDog::Loaded(walk) = self {</p>
			<p class="source-code">            ...</p>
			<p class="source-code">            walk.boy.update();</p>
			<p class="source-code">            if walk</p>
			<p class="source-code">                .boy</p>
			<p class="source-code">                .bounding_box()</p>
			<p class="source-code">                .intersects(&amp;walk.platform.bounding_box())</p>
			<p class="source-code">            {</p>
			<p class="source-code">                <strong class="bold">if walk.boy.velocity_y() &gt; 0 &amp;&amp; walk.boy.pos_y() &lt; walk.platform.position.y</strong> {</p>
			<p class="source-code">                    walk.boy.land_on(walk.platform.bounding_box().y);</p>
			<p class="source-code">                } else {</p>
			<p class="source-code">                    <strong class="bold">walk.boy.knock_out();</strong></p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            ...</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The changes are to check whether the <strong class="source-inline">RedHatBoy</strong> velocity, in <em class="italic">y</em>, is greater than <strong class="source-inline">0</strong> and, therefore, RHB is moving down. We also check whether the position in <em class="italic">y</em> is less than the top of the platform's <em class="italic">y</em> position. This means that the boy is above the platform, so he's landing on it; otherwise, the boy<a id="_idIndexMarker464"/> has crashed into it, and we knock him out. The <strong class="source-inline">pos_y</strong> and <strong class="source-inline">velocity_y</strong> functions don't exist yet, so we'll add those to <strong class="source-inline">RedHatBoy</strong>, as shown here:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn pos_y(&amp;self) -&gt; i16 {</p>
			<p class="source-code">        self.state_machine.context().position.y</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fn velocity_y(&amp;self) -&gt; i16 {</p>
			<p class="source-code">        self.state_machine.context().velocity.y</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>It's a little tricky to get the <em class="italic">y</em> values for <strong class="source-inline">RedHatBoy</strong> because they are actually on  <strong class="source-inline">RedHatBoyContext</strong>, but we are able to pull it off here and wrap them in a getter for convenience. </p>
			<p class="callout-heading">Info</p>
			<p class="callout">For the sake of the book, the code here is pretty explicit, but you can make it more expressive by extracting a method for <strong class="source-inline">falling</strong> on <strong class="source-inline">RedHatBoy</strong>. We'll leave it as it is for now, but you will want to consider some more expressive names in your own code.</p>
			<p>With that, RHB can finally run, jump over stones, land on platforms, and fall off them. However, you've probably noticed that the collisions are really crude. He crashes into the bottom of the platform easily because the transparent parts of the images collide. He also can walk past the edge<a id="_idIndexMarker465"/> of the platform, again because of the transparent parts of the image:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 5.23 – Believe it or not, I'm walking on air&#13;&#10;" src="image/Figure_5.23_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – Believe it or not, I'm walking on air</p>
			<p>Let's spend a little time tweaking our bounding boxes to deal with the transparency.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor136"/>Transparency in bounding boxes</h2>
			<p>The problem with our bounding boxes is that we're<a id="_idIndexMarker466"/> using the image dimensions as the bounding box. That means we'll have a lot of extra space around our characters for our bounding boxes. In this screenshot, I've used the <strong class="source-inline">draw_rect</strong> method from earlier in this chapter to show the bounding boxes for all three objects in our scene:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 5.24 – Bounding boxes everywhere&#13;&#10;" src="image/Figure_5.24_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24 – Bounding boxes everywhere</p>
			<p>The platform has a lot of white space in the bounding box, particularly at the lower-left and lower-right corners. RHB also has white space near the corners of his hat. When we turn off the collision checks on the stone and try to walk under the platform, RHB "collides" with the lower-left corner of the platform well before he actually hits it. </p>
			<p>The white space around RHB's feet is a<a id="_idIndexMarker467"/> problem too; they are what cause the landing on air effect. The far-right edge of his bounding box intersects with the platform, so he lands before he's really in the right position. If you could see him walk off the edge of the platform, you'd see that it has the same problem when he walks off. He takes several steps in mid-air before he begins to fall. </p>
			<p>We'll start by dealing with RHB's bounding box to make landing and falling off the platform look a little more realistic.</p>
			<h3>Fixing the game to fit</h3>
			<p>There are<a id="_idIndexMarker468"/> algorithms we can use to make the bounding box better match the actual pixels in the image, but ultimately, none of them are necessary. Spend a little time with most platformers and you'll see that the collisions aren't perfect, and 99% of the time, it's just fine. After spending a little time "researching" by playing video games, I determined that if we simply make the box only as wide as the feet, he develops a much more realistic landing. This is a little counter-intuitive. If we narrow<a id="_idIndexMarker469"/> the box, his arm and hat will stick out past the edge of the box; we'll miss collisions! Does this matter?</p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 5.25 – A narrow bounding box" src="image/Figure_5.25_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25 – A narrow bounding box</p>
			<p>The answer is, "maybe." Bounding boxes and collision detection are not just mathematical problems. They are also game design problems. Making the bounding box wrap just around the feet felt right to me when playing the game. Maybe when you play it, that will feel too hard when you land on a platform or the hand not colliding will bother you, so change the box! It's not written in stone. </p>
			<p>After experimenting, I found that I wanted to shorten the box as well so that RHB couldn't be knocked out by grazing his hat. To mimic that, we can start by renaming <strong class="source-inline">bounding_box</strong> <strong class="source-inline">destination_box</strong>, because that represents where the sprite is rendered <em class="italic">to</em>. It needs to be at the position of <strong class="source-inline">RedHatBoy</strong> in the game but with the width and height of the source image; otherwise, the image will appear squished. Then, we can re-implement the <strong class="source-inline">RedHatBoy</strong> bounding box, like so:</p>
			<p class="source-code">impl RedHatBoy {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn bounding_box(&amp;self) -&gt; Rect {</p>
			<p class="source-code">        const X_OFFSET: f32 = 18.0;</p>
			<p class="source-code">        const Y_OFFSET: f32 = 14.0;</p>
			<p class="source-code">        const WIDTH_OFFSET: f32 = 28.0;</p>
			<p class="source-code">        let mut bounding_box =<strong class="bold"> self.destination_box();</strong></p>
			<p class="source-code">        bounding_box.x += X_OFFSET;</p>
			<p class="source-code">        bounding_box.width -= WIDTH_OFFSET;</p>
			<p class="source-code">        bounding_box.y += Y_OFFSET;</p>
			<p class="source-code">        bounding_box.height -= Y_OFFSET;</p>
			<p class="source-code">        bounding_box</p>
			<p class="source-code">    }</p>
			<p>We start with the original <a id="_idIndexMarker470"/>dimensions of the image, <strong class="source-inline">destination_box</strong>, and simply shrink it by some offsets. I chose the numbers by using the high-tech system of picking numbers and looking at them. This gave me a bounding box that looked natural jumping and falling off the cliff while not being so small that RHB never hits anything. </p>
			<p>If you did a global find and replace on <strong class="source-inline">bounding_box</strong> and changed it to <strong class="source-inline">destination_box</strong>, then the collision detection is incorrect. We need to use <strong class="source-inline">bounding_box</strong> for checking collisions and <strong class="source-inline">destination_box</strong> for drawing. Drawing should already be complete; you'll need to go into the <strong class="source-inline">update</strong> method in <strong class="source-inline">WalkTheDog</strong> and make sure that every <strong class="source-inline">intersects</strong> call is on the <strong class="source-inline">bounding_box</strong>, not <strong class="source-inline">destination_box</strong>. </p>
			<p>With the new <strong class="source-inline">bounding_box</strong> method and a properly drawn image, you get a bounding box that looks like this for RHB:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 5.26 – A tight-fit bounding box" src="image/Figure_5.26_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26 – A tight-fit bounding box</p>
			<p>You can see that it's a lot smaller than the image, which makes the game look better and play a little more forgiving. He lands on and falls off the platform much more accurately, without a hovering effect. You also might find it easier to jump the stone now because the transparent part of RHB doesn't crash into the rock. </p>
			<p>That leaves us with the white<a id="_idIndexMarker471"/> space around the edges of the platform. We can shrink the bounding box for it, but that would cause the player to fall through the top of the platform when he lands on the edges. The platform is narrower on the bottom than the top, which is a problem because we crash into the bottom and land on the top. What we really want to do is take the platform and make it into multiple bounding boxes.</p>
			<h3>Subdividing bounding boxes</h3>
			<p>Subdividing the bounding <a id="_idIndexMarker472"/>boxes is just like it sounds – we're going to take the one bounding box that is currently used for the platform and divide it into several. This will dramatically reduce the amount of extra space in the boxes and improve our collision detection. You might think that we'll use a complex algorithm or tool to determine what boxes to use, and we will – it's our eyeballs. </p>
			<p>Specifically, we'll look at the platform, see the white space, and then try out a few versions of the bounding boxes divided up until we find a solution we like. We can begin that process by making it possible for <strong class="source-inline">Platform</strong> to have more than one bounding box. We'll do that by, again, renaming <strong class="source-inline">bounding_box</strong>  to <strong class="source-inline">destination_box</strong> and then creating a new method to construct a vector of <strong class="source-inline">bounding_boxes</strong> from that original box, as shown here:</p>
			<p class="source-code">impl Platform {</p>
			<p class="source-code">    fn bounding_boxes(&amp;self) -&gt; Vec&lt;Rect&gt; {</p>
			<p class="source-code">        const X_OFFSET: f32 = 60.0;</p>
			<p class="source-code">        const END_HEIGHT: f32 = 54.0;</p>
			<p class="source-code">        let destination_box = self.destination_box();</p>
			<p class="source-code">        let bounding_box_one = Rect {</p>
			<p class="source-code">            x: destination_box.x,</p>
			<p class="source-code">            y: destination_box.y,</p>
			<p class="source-code">            width: X_OFFSET,</p>
			<p class="source-code">            height: END_HEIGHT,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        let bounding_box_two = Rect {</p>
			<p class="source-code">            x: destination_box.x + X_OFFSET,</p>
			<p class="source-code">            y: destination_box.y,</p>
			<p class="source-code">            width: destination_box.width - (X_OFFSET * </p>
			<p class="source-code">                2.0),</p>
			<p class="source-code">            height: destination_box.height,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        let bounding_box_three = Rect {</p>
			<p class="source-code">            x: destination_box.x + destination_box.width – </p>
			<p class="source-code">                X_OFFSET,</p>
			<p class="source-code">            y: destination_box.y,</p>
			<p class="source-code">            width: X_OFFSET,</p>
			<p class="source-code">            height: END_HEIGHT,</p>
			<p class="source-code">        };</p>
			<p class="source-code">        vec![bounding_box_one, bounding_box_two,  </p>
			<p class="source-code">            bounding_box_three]</p>
			<p class="source-code">    }</p>
			<p>In this method, we create three<a id="_idIndexMarker473"/> Rects, each meant to match the platform, starting from the destination box of the platform. It's two small rectangles on the edges and one bigger one in the middle. When we draw those boxes, it looks like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 5.27 – Platform bounding boxes&#13;&#10;" src="image/Figure_5.27_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.27 – Platform bounding boxes</p>
			<p>That's a lot less white space that you can collide with. You might wonder where the values for <strong class="source-inline">X_OFFSET</strong> and <strong class="source-inline">END_HEIGHT</strong> came from, and the truth is that I just drew the boxes and looked at them until I was happy. It's not fancy; it's just good enough.</p>
			<p>Now that we're<a id="_idIndexMarker474"/> using a vector of bounding boxes instead of just one, we'll need to change the logic in the <strong class="source-inline">update</strong> method of <strong class="source-inline">WalkTheDog</strong> to make sure that RHB can collide with any of the boxes and make the code compile. That code is reproduced here:</p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    fn update(&amp;mut self, keystate: &amp;KeyState) {</p>
			<p class="source-code">        ...</p>
			<p class="source-code">        <strong class="bold">for bounding_box in &amp;walk.platform.bounding_boxes() {</strong></p>
			<p class="source-code">            if walk.boy.bounding_box()</p>
			<p class="source-code">                .intersects(bounding_box) {</p>
			<p class="source-code">                if walk.boy.velocity_y() &gt; 0 &amp;&amp; </p>
			<p class="source-code">                    walk.boy.pos_y() &lt; </p>
			<p class="source-code">                        walk.platform.position.y {</p>
			<p class="source-code">                    walk.boy.land_on(bounding_box.y);</p>
			<p class="source-code">                    } else {</p>
			<p class="source-code">                        walk.boy.knock_out();</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">           ...</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>The change here is to loop through all the bounding boxes and check for a collision on any box. There are only three boxes here, so we're not worried about checking all three every time. If the computer can't count to three, you probably need a new computer.</p>
			<p>If you temporarily <a id="_idIndexMarker475"/>comment out collisions with the stone again, you'll see that you can just barely walk underneath the platform:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 5.28 – Just short enough&#13;&#10;" src="image/Figure_5.28_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.28 – Just short enough</p>
			<p>At this point, you might wonder whether this should be a collision. After all, his hat does kind of scrape the bottom of the platform. It might be hard for the player to tell if they will fit under the the platform. Can we find a workaround for this?</p>
			<h3>Game design through constants</h3>
			<p>As we've gone through this section, we've been introducing more and more constants for values such as <strong class="source-inline">FLOOR</strong> and <strong class="source-inline">PLAYER_HEIGHT</strong>. Most of the time, we treat magic numbers as "bad" in code because they lead to duplication and bugs. That's true, but for most of the numbers we've <a id="_idIndexMarker476"/>been using, we haven't had duplication. No, in this situation, we can use constants to both clarify what the numbers mean and use those for game design. We can then use game design to hide little quirks, such as our platform being at a height that barely clears the player. </p>
			<p>We used <strong class="source-inline">Point { x: 200, y: 400 }</strong> as the location of <strong class="source-inline">Platform</strong> when we originally created it. Those were magic numbers – sorry about that. We actually know that the <em class="italic">y</em> value of <strong class="source-inline">400</strong> positions the platform at a pretty confusing location. If <em class="italic">y</em> was <strong class="source-inline">370</strong>, then you would need to go under it, and if it's <strong class="source-inline">420</strong>, you need to go over it. We can create two constants for that and set up the position. That change is shown here:</p>
			<p class="source-code"><strong class="bold">const LOW_PLATFORM: i16 = 420;</strong></p>
			<p class="source-code"><strong class="bold">const HIGH_PLATFORM: i16 = 375;</strong></p>
			<p class="source-code">#[async_trait(?Send)]</p>
			<p class="source-code">impl Game for WalkTheDog {</p>
			<p class="source-code">    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {</p>
			<p class="source-code">        match self {</p>
			<p class="source-code">            WalkTheDog::Loading =&gt; {</p>
			<p class="source-code">                ...</p>
			<p class="source-code">                let platform = Platform::new(</p>
			<p class="source-code">                    platform_sheet.into_serde::&lt;Sheet&gt;()?,</p>
			<p class="source-code">                    engine::load_image("tiles.png").await?,</p>
			<p class="source-code">                    Point {</p>
			<p class="source-code">                        x: 370,</p>
			<p class="source-code">                        <strong class="bold">y: LOW_PLATFORM,</strong></p>
			<p class="source-code">                    },</p>
			<p class="source-code">                );</p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 5.29 – You're not gonna make it!" src="image/Figure_5.29_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.29 – You're not gonna make it!</p>
			<p>You might notice that the <a id="_idIndexMarker477"/>platform is a little to the right in this screenshot. I wanted to be able to jump over the rock and then jump onto the platform. It's impossible to do that with the way we constructed it originally, so I moved the platform to the right. I created a constant named <strong class="source-inline">FIRST_PLATFORM</strong> for the <em class="italic">x</em> location of the platform, set it to <strong class="source-inline">370</strong>, and then set the <em class="italic">x</em> position of <strong class="source-inline">Platform</strong> to that. </p>
			<p>I also found it nearly impossible to actually just jump the stone with the user's combination of speed and gravity. Even after narrowing RHB's collision box, he jumps high but not very far. Fortunately, that was very tweakable with constants – by simply upping <strong class="source-inline">RUNNING_SPEED</strong> from <strong class="source-inline">3</strong> to <strong class="source-inline">4</strong>, he moved quickly enough to make jumping the rock easy.</p>
			<p>As we're designing our endless runner, we're going to find that we can hide any imperfections in collisions through game design. You'll constantly need to tweak values such as the speed of the player, bounding box heights, and obstacle locations. The more of the game you can encode into constants, the easier that will be.</p>
			<h3>A quick challenge</h3>
			<p>When we wrote the code to cause RHB to get knocked out if he jumps from below the platform, we introduced a bug seen here:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 5.30 – How did he get there?&#13;&#10;" src="image/Figure_5.30_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.30 – How did he get there?</p>
			<p>What's happening is that when RHB collides with the bottom of the platform, he transitions into the <strong class="source-inline">Falling</strong> state, but he doesn't change his velocity, so he continues the jump. Then, gravity <a id="_idIndexMarker478"/>stops being applied to RHB in the <strong class="source-inline">KnockedOut</strong> state. Your challenge is to fix this defect. You'll need to modify the states to reflect those changes. Give it a try before you check <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. T<a id="_idTextAnchor137"/>he changes are small and all in the existing code.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we made <strong class="source-inline">WalkTheDog</strong> more closely resemble a game by making RHB run into obstacles and jump onto platforms. We did all of this with axis-aligned bounding boxes and in a scene that looks like a real game, with a background, instead of an empty void. We also dealt with some quirks for dealing with trimmed sprite sheets, properly handled bounding boxes, and utilized the state machine we built in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, to handle the new animations and manage the state of <strong class="source-inline">RedHatBoy</strong>. </p>
			<p>We also learned how collisions are more than just drawing a box around an image. Yes, it's the math behind intersecting boxes, but it's also checking to see whether the player is landing or crashing into the platform. We debugged our collision boxes with rectangles and used those rectangles to make a better fitting box. We even subdivided one image into multiple collision boxes!</p>
			<p>This chapter was big, we did a lot, and I encourage you to fiddle with and tweak the code as you see fit. Have RHB jump lower, or higher, or have him move more slowly. Try making the bounding boxes smaller so that it's easier to jump over the stone or put the stone on the platform. Use your imagination!</p>
			<p>All in all, we've set up the game so that it's ready to become an endless runner, with randomly generated terrain and a convincing scroll from left to right. We'll develop that in the next chapter.</p>
		</div>
	</body></html>