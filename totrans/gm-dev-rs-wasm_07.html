<html><head></head><body>
		<div><h1 id="_idParaDest-76"><em class="italic"><a id="_idTextAnchor114"/>Chapter 5</em>: Collision Detection</h1>
			<p>To make our game fun, our little <strong class="bold">Red Hat Boy</strong> (<strong class="bold">RHB</strong>) needs to run, jump, and slide. Fortunately, we just implemented all that, but he also needs to have something to jump on, something to slide under, and something to crash into. To make this game fun, we'll need to add <strong class="bold">collision detection</strong>, which is one of the most fun and most complicated aspects of game design. </p>
			<p>Collision detection begins with math, detecting whether or not two shapes intersect, but leads to all kinds of interesting questions. We'll deal with some of those in this chapter, such as, how do we handle transparency in sprites? What do we do to make sure a player lands on a platform from above but crashes into a platform if they're underneath it? What about sprites that have shapes that aren't a simple box? It's going to be a blast!</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating a real scene</li>
				<li>Axis-aligned bounding boxes</li>
				<li>Getting bounding boxes from the sprite sheet</li>
				<li>Crashing into a stone</li>
				<li>Landing on and falling off a platform</li>
			</ul>
			<p>By the end of this chapter, you'll have a real game, although it will be a short one. You'll have the skills to build your own scenes with good-looking collision detection, and you'll know how to integrate collision events with your own programs. You'll be able to, if you want, add your own new objects to the scene and crash into them or jump off them, or even fall off the world. Let's get started!</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor115"/>Technical requirements</h1>
			<p>You'll need to download the latest assets for this chapter from <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/wiki/Assets</a>. </p>
			<p>You can get the source code for this chapter at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. </p>
			<p>No new assets are in the download, so if you downloaded them earlier, you don't need to do it again.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/36BJYJd">https://bit.ly/36BJYJd</a></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor116"/>Creating a real scene</h1>
			<p>At the moment, RHB can move anywhere he <a id="_idIndexMarker382"/>wants, in an empty void, such as the one in <em class="italic">The Matrix</em>. It's progress; all that animation was real work, but it's not a game. It's time we put RHB in a setting – a background, platforms, maybe something to jump over. Let's start with a background.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor117"/>Adding the background </h2>
			<p>Right now, our game <a id="_idIndexMarker383"/>can only render images from a sprite sheet, which we can use for a background, but that's overkill for one image. Instead, we'll add a new <code>struct</code> that draws a simple image from a <code>.png</code> file. Then, we'll add that to the <code>draw</code> and <code>initialize</code> functions in <code>WalkTheDog</code>:</p>
			<ol>
				<li>Create an <code>Image</code> struct.</li>
			</ol>
			<p>We can work bottom-up for these changes, adding code to the engine and then integrating it into the game. Our <code>Image</code> <code>struct</code> will use a lot of the same code that we wrote in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, but with a simpler setup because we won't be using a sheet. All of this code should go into the <code>engine</code> module. </p>
			<p>Start with a <code>struct</code> holding <code>HtmlImageElement</code>:</p>
			<pre>pub struct Image {
    element: HtmlImageElement,
    position: Point,
}
impl Image {
    pub fn new(element: HtmlImageElement, position: 
        Point) -&gt; Self {
        Self { element, position }
    }
}</pre>
			<p>There's nothing here<a id="_idIndexMarker384"/> you haven't seen before in another form. The <code>Image struct</code> holds the image element, presumably loaded via the <code>load_image</code> function, and its position in the scene. <code>Image</code> will also need a draw function, but there's no simple way to draw the entire image as it is in <code>Renderer</code>. That will need a new method, as shown here:</p>
			<pre>impl Renderer {
    ...
    pub fn draw_entire_image(&amp;self, image: 
        &amp;HtmlImageElement, position: &amp;Point) 
            self.context
            .draw_image_with_html_image_element(image, 
                position.x.into(), position.y.into())
            .expect("Drawing is throwing exceptions! 
                Unrecoverable error.");
    }
}</pre>
			<p>This function is very similar to the <code>draw_image</code> function we wrote earlier, but it's using the simpler version of the JavaScript <code>drawImage</code> function that only takes an image and a position. To use this method, you'll need to be aware of how large the image<a id="_idIndexMarker385"/> you're drawing is. If it's too big or too small, it will show up just as big or small as the source image.</p>
			<ol>
				<li value="2">Now that you've added a method to <code>Renderer</code>, go ahead and update the <code>Image</code> implementation to draw an image with it:<pre>impl HtmlImageElement {
    ...
    pub fn draw(&amp;self, renderer: &amp;Renderer) {
        renderer.draw_entire_image
            (&amp;self.element,&amp;self.position)
    }
}</pre></li>
			</ol>
			<p>Now that you can draw an image, let's load it.</p>
			<ol>
				<li value="3">Load the image.</li>
			</ol>
			<p>The background image can be found in the downloaded assets, in <code>original/freetileset/png/BG/BG.png</code>, and can be copied into the <code>static</code> directory. Then, it can be loaded and used to create an <code>Image</code> <code>struct</code>. That will be done in the <code>game</code> module, in the <code>initialize</code> function of <code>WalkTheDog</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn 
        Game&gt;&gt; {
        match self {
            WalkTheDog::Loading =&gt; {
                let sheet = browser::fetch_json
                    ("rhb.json").await?.into_serde()?;
                <strong class="bold">let background = engine::</strong>
<strong class="bold">                    load_image("BG.png").await?;</strong>
                ....</pre>
			<p>In the preceding code snippet, only the highlighted last line is new, which loads the background from <a id="_idIndexMarker386"/>a file. Our <code>WalkTheDog</code> <code>enum</code> only holds <code>RedHatBoy</code>, so we're going to have to restructure the code a little. While we could have the <code>WalkTheDog::Loaded</code> state hold a tuple of <code>RedHatBoy</code> and <code>Background</code>, that's going to get real annoying, real fast. </p>
			<ol>
				<li value="4">To do that, change <code>enum</code> to look like this:<pre>pub enum WalkTheDog {
    Loading,
    Loaded(Walk),
}</pre></li>
			</ol>
			<p>We'll have <code>WalkTheDog</code> represent our game, but I decided that RHB takes the dog for "<code>Walk</code>. In a generic framework, I might call this a "<code>Walk</code> should work. </p>
			<ol>
				<li value="5">The <code>Walk</code> struct will need to have the RHB and the background, so go ahead and add that:<pre>pub struct Walk {
    boy: RedHatBoy,
    background: Image,
}</pre></li>
			</ol>
			<p>Make sure you've imported <code>Image</code> from the <code>engine</code> module. Now, you can work your way down<a id="_idIndexMarker387"/> the <code>game</code> module and follow the compiler errors. In the <code>initialize</code> function for <code>WalkTheDog</code>, you should see an error for "<code>expected struct `Walk`, found struct `RedHatBoy`</code>".</p>
			<ol>
				<li value="6">Fix that by creating <code>Walk</code> with the background we already loaded and setting it in <code>WalkTheDog::Loaded</code> that's returned. This will look as follows:<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn 
         Game&gt;&gt; {
        ...
        Ok(Box::new(WalkTheDog::Loaded(Walk {
            boy: rhb,
            background: Image::new(background, Point {                 
                x: 0, y: 0 }),
        })))
    }
    ...
}</pre></li>
			</ol>
			<p>This will create <code>Walk</code> with a boy and <code>background</code> positioned at the upper-left corner, but you should still have several compiler errors in the <code>update</code> method of <code>WalkTheDog</code> because those all assume that <code>WalkTheDog::Loaded</code> contains <code>RedHatBoy</code>. Each of those can be changed in the exact same way. The first looks like this:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(<strong class="bold">walk</strong>) = self {
            if keystate.is_pressed("ArrowRight") {
                <strong class="bold">walk.boy.</strong>run_right();
            }
            ...</pre>
			<p>The <code>if let WalkTheDog::Loaded</code> line is unchanged, except now the variable name is <code>walk</code> instead of <code>rhb</code>. Then, we call <code>run_right</code> on <code>boy</code> but via the <code>walk</code> structure. You <a id="_idIndexMarker388"/>could argue that we should add methods to <code>Walk</code> instead of delegating to <code>boy</code>, but we'll hold off on that for now. After all, <code>walk.run_right()</code> doesn't really make sense. After fixing all the similar compiler errors in <code>update</code>, you can also fix a similar error in <code>draw</code>, like so:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        if let WalkTheDog::Loaded(<strong class="bold">walk</strong>) = self {
             <strong class="bold">walk.boy.</strong>draw(renderer);
        }
        ...</pre>
			<p>Having done all that, you'll now be drawing… well, you'll be drawing RHB again.</p>
			<ol>
				<li value="7">Next, go ahead and draw the background for our game. Drawing the background is a matter of <a id="_idIndexMarker389"/>using our new draw function, so let's add that right before the <code>walk.boy.draw</code> function call, as shown here:<pre>impl Game for WalkTheDog {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        if let WalkTheDog::Loaded(walk) = self {
             <strong class="bold">walk.background.draw(renderer);</strong>
             walk.boy.draw(renderer);
        }
        ...</pre></li>
			</ol>
			<p>After doing that, you should see RHB standing in front of the background, like this:</p>
			<div><div><img alt="Figure 5.1 – Standing in the forest&#13;&#10;" src="img/Figure_5.01_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Standing in the forest</p>
			<p>Looking at it, you might<a id="_idIndexMarker390"/> wonder, how come RHB is so far to the right if his <em class="italic">x</em> coordinate is <code>0</code>? Hang on to that thought, as we'll deal with it soon. First, let's get a platform onto the screen, using our sprite sheet from <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor118"/>Adding an obstacle </h2>
			<p>It's great that we have<a id="_idIndexMarker391"/> RHB in front of a background, and it looks great, but the scene is still a little empty. What if there was something else in the scene? Something grand, something innovative, something larger than life. Well, the budget for art is low, so how about a stone?</p>
			<p>Our new <code>Image</code> class means we won't need much code, and you've seen all of it before. To add an obstacle, follow these steps:</p>
			<ol>
				<li value="1">Start by copying <code>Stone.png</code> from <code>original/freetileset/png/Object/Stone.png</code> in the assets and into the <code>static</code> directory. Now, you can add it to <code>Walk</code> in the same way you added <code>Background</code>, like so:<pre>struct Walk {
    boy: RedHatBoy,
    background: Image,
    <strong class="bold">stone: Image,</strong>
}</pre></li>
			</ol>
			<p>That will start causing compiler<a id="_idIndexMarker392"/> errors again because <code>Walk</code> is created without a stone. </p>
			<ol>
				<li value="2">In <code>initialize</code>, go ahead and load the stone, just as you loaded the background, as shown here:<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn 
        Game&gt;&gt; {
        ...
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let background = engine::load_image
                    ("BG.png").await?;
                <strong class="bold">let stone = engine::</strong>
<strong class="bold">                    load_image("Stone.png").await?;</strong>
                ...</pre></li>
				<li>Then, you need to take the stone that we just loaded and add it to <code>Walk</code>. We'll make sure the stone is on the ground by taking the <code>FLOOR</code> value (<code>600</code>) and subtracting the <a id="_idIndexMarker393"/>height of the stone image, which happens to be <code>54</code> pixels. If we position the stone at a <em class="italic">y</em> position of <code>546</code>, it should be sitting right on the ground. Here's the update for creating <code>Walk</code>:<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn 
        Game&gt;&gt; {
        ....
        Ok(Box::new(WalkTheDog::Loaded(Walk {
            boy: rhb,
            background: Image::new(background, Point { 
                x: 0, y: 0 }),
            <strong class="bold">stone: Image::new(stone, Point { x: 150, </strong>
<strong class="bold">                y: 546 })</strong>,
        })))</pre></li>
				<li>The stone is <code>150</code> pixels to the right, so it will be in front of RHB. Finally, draw the stone using the <code>draw</code> method. That addition is as follows:<pre>impl Game for WalkTheDog {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        if let WalkTheDog::Loaded(walk) = self {
            walk.background.draw(renderer);
            walk.boy.draw(renderer);
            <strong class="bold">walk.stone.draw(renderer);</strong>
        }</pre></li>
			</ol>
			<p>The code change is small, just drawing the stone with the same call to <code>draw</code> that we've used for <code>boy</code> and <code>background</code>. Do that, and you'll have RHB walking toward the stone:</p>
			<div><div><img alt="Figure 5.2 – Look out for that stone!&#13;&#10;" src="img/Figure_5.02_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Look out for that stone!</p>
			<p>Now, if RHB walks into <a id="_idIndexMarker394"/>that stone, he'll go safely behind it, like this:</p>
			<div><div><img alt="Figure 5.3 – Easiest game ever&#13;&#10;" src="img/Figure_5.03_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Easiest game ever</p>
			<p>That's not much fun. While we've learned how to add new objects into the game, and drawn them for a more interactive experience, the game doesn't have any challenges yet. We want the boy to <a id="_idIndexMarker395"/>crash into the stone and fall over, ending the game. To do that, we'll need to learn a little about bounding boxes and collision detection, so let's do that in the next section.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor119"/>Axis-aligned bounding boxes </h1>
			<p>Checking whether two objects in our game have collided can, theoretically, be done by checking every pixel in every object and seeing whether they share a location. That logic, in addition to being very complicated to write, would be computationally extremely expensive. We need to run at <code>60</code> frames a second and can't spend our precious processing power trying to get that kind of perfection – not if we want the game to be fun, anyway. Fortunately, we can use a simplification that will be close enough to fool our silly eyes, the same way we can't tell that animation is really just a series of still images. That<a id="_idIndexMarker396"/> simplification is called the <em class="italic">bounding box</em>.</p>
			<p>A bounding box is just a rectangle we'll use for collisions, instead of checking each pixel on the sprite. You can think of every sprite having a box around it, which looks like this:</p>
			<div><div><img alt="Figure 5.4 – Bounding boxes" src="img/Figure_5.04_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.4 – Bounding boxes</p>
			<p>These boxes aren't actually drawn; they only exist in the memory of the game, except when you want to debug them. When you use boxes, you only have to check for the values of the box – top (<em class="italic">y</em>), left (<em class="italic">x</em>), right (<em class="italic">x</em> + width), and bottom (<em class="italic">y</em> + height). It makes for a much faster comparison. Let's talk in a<a id="_idIndexMarker397"/> little more detail about how to detect when two boxes intersect.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The term "<strong class="bold">axis-aligned</strong>" sounds pretty<a id="_idIndexMarker398"/> fancy, but all it means is that the boxes <a id="_idIndexMarker399"/> aren't rotated. <em class="italic">Y</em> will be up and down, <em class="italic">X</em> left to right, and always aligned with the game's coordinate system.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor120"/>Collision </h2>
			<p>In order to detect whether two <a id="_idIndexMarker400"/>boxes collide or overlap, they will exist in the same 2D  <a id="_idIndexMarker401"/>coordinate space we've been using since the beginning of this book. They may not be visible, but they are there, sitting where the stone is or running along with RHB. They'll need a position in <em class="italic">x</em> and <em class="italic">y</em>, just like a sprite already has, and also a width and height. When we check whether two boxes are colliding, we check in both the <em class="italic">x</em> and <em class="italic">y</em> axes. Let's first look at how you can tell whether two boxes intersect in the <em class="italic">x</em> axis. Given there are two boxes, box 1 intersects box 2 if the left side (or <em class="italic">x</em> position) of box 1 is less than the right side of box 2 but the right side of box 1 is greater than the left side of box 2. This is easier to explain visually:</p>
			<div><div><img alt="Figure 5.5 – Collisions&#13;&#10;" src="img/Figure_5.05_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – Collisions</p>
			<p>The preceding figure shows three sets of two boxes that could potentially collide, in a space where <em class="italic">x</em> increases as you move to the right, just like our canvas. The first two comparisons don't collide, but the third does. </p>
			<p>Take a look at the first <a id="_idIndexMarker402"/>comparison where box 1 is to the left of box 2, with a gap in between them. As you can see, the left side of box 1 is well to the left of the right side of box 2, as shown by the arrows. This passes the first condition for collision – the left side of box 1 must be less than the right side of box 2. However, the right side of box 1 is to the left of box 2's left side, which violates our second condition. To collide, the right side of box 1 must be greater than (to the right) of the left side of box 2, so these two boxes don't collide. </p>
			<p>In the second comparison, box 1 has been moved to the right of box 2, again without overlapping. Box 1's right side is now to the right of box 2's left side, so they meet the second condition of colliding, but the left side of box 1 is now also to the right of box 2's right side, so the boxes don't meet the first condition and still don't collide. </p>
			<p>Finally, in the third comparison, the left side of box 1 is again to the right of box 2's right side, but the left side of box 1 is to the left of box 2's right side. These two boxes collide. Box 1 and box 2 have overlapping <em class="italic">x</em> values, so they collide.</p>
			<p>If images aren't your style, it can also help to look at real numbers to see how this algorithm works. Assuming box 1 and box 2 are both 10 x 10, squares we can form a table, like this:</p>
			<div><div><img alt="" src="img/Table_5.01_B17151.jpg"/>
				</div>
			</div>
			<p>In every row of this table – that is, every example set of coordinates – box 2 is in the same place. There are actually four examples here. In the first row, box 1 is completely to the left of box 2. In the second, the boxes collide because box 1's right edge hits box 2's left edge. In the third, they collide because box 1's left edge is hitting box 2's right edge. Finally, in the fourth row, box 1 is not completely to the right of box 2. The values hold the same properties of the images; either the left edge or right edge of the first box is between the left and right edge of the second box. This long explanation leads to the following short pseudocode:</p>
			<pre>if (box_one.x &lt; box_two.right) &amp;&amp;
    (box_one.right &gt; box_two.x) {
        log!("Collision!");
    }</pre>
			<p>This satisfies two of the conditions I mentioned at the beginning, but what about the vertical axis (<em class="italic">y</em>)? That works in a similar way, only instead of using the left and right sides, we use the top<a id="_idIndexMarker403"/> and bottom values respectively. The top of box 1 must be above, which means less than, the bottom of box 2. The bottom of box 1 must be below the top of box 2. If both of those are true, the boxes collide. Remember that <em class="italic">y</em> goes up as we go down the screen in our coordinate space:</p>
			<div><div><img alt="Figure 5.6 – Vertical collisions" src="img/Figure_5.06_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Vertical collisions</p>
			<p>Let's take a moment to work through these three comparisons, just as we did before. For the first comparison, the top of box 1 is above the bottom of box 2, but the bottom of box 1 is also above the top of box 2, so they do not overlap. </p>
			<p>In the second case, box 1 is completely below box 2, with no collision. The bottom of box 1 is below the top of box 2, which must be true for a collision, but the top of box 1 is also below the bottom of box 2, so our first rule of vertical collisions does not hold.</p>
			<p>In the third comparison, the top of box 1 is above the bottom of box 2, and the bottom of box 1 is below the top of box 2, so we have a collision. This means we can extend our pseudocode to look like the following:</p>
			<pre>if (box_one.x &lt; box_two.right) &amp;&amp;
    (box_one.right &gt; box_two.x) &amp;&amp;
    <strong class="bold">(box_one.y &lt; box_two.bottom) &amp;&amp;</strong>
    <strong class="bold">(box_one.bottom &gt; box_two.y) {</strong>
        log!("Collision!");
    }</pre>
			<p>Those are the four<a id="_idIndexMarker404"/> things that must be true to get a collision. So, now that we know our collisions, we can apply bounding boxes to RHB and a stone so that they can collide. Unfortunately, a naive approach will lead to really difficult collisions and a nearly impossible game. That problem can be summarized in one word – transparency.</p>
			<h3>Transparency</h3>
			<p>In <em class="italic">Figure 5.7</em>, I've drawn <a id="_idIndexMarker405"/>bounding boxes in red for both RHB and the stone:</p>
			<div><div><img alt="Figure 5.7 – Bounding boxes" src="img/Figure_5.07_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Bounding boxes</p>
			<p>These bounding boxes were created by using the size of the entire sprite after it was loaded, using the width and height properties of <code>HTMLImageElement</code>. As you can see, the boxes are far larger than their corresponding sprites, especially the one for RHB. This is because the sprite has transparency, which we do not want to include in our bounding boxes. Right now, the boxes collide, and RHB would be knocked over by the stone well before touching it. That's not what we want!</p>
			<p>This is an example of the<a id="_idIndexMarker406"/> primary debugging technique for bounding box collisions – drawing the boxes so that you can see what's wrong. In this case, RHB's box is just way too big. It should be the minimum size required to contain the entire image, and the bug this is revealing is that the sprite sheet we used in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>, contains a lot of transparency. We'll need to fix that before RHB will properly collide with the stone, so let's start trimming the sprite sheet.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor121"/>Trimming the sprite sheet</h1>
			<p>In order to have<a id="_idIndexMarker407"/> RHB crash into a stone, we're going to have to deal with the transparency. Let's take a look at the raw <code>.png</code> file that RHB is coming from. A portion of the image is shown in <em class="italic">Figure 5.8</em>, as follows:</p>
			<div><div><img alt="Figure 5.8 – The sprite sheet" src="img/Figure_5.08_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – The sprite sheet</p>
			<p>This is two frames of the <em class="italic">idle</em> animation, with black lines showing the image borders. As you can see, there is a <strong class="bold">ton</strong> of extra space in these images, so using a bounding box that's the same size as the image won't work. That's the problem you see with the bounding boxes in <em class="italic">Figure 5.7</em>. We have two choices to fix it. The simplest, although annoying, would be to open our sprite sheet in a graphics editor and find out the actual pixels for the bounding boxes for each sprite. Then, we would store that in code or a separate file and use those bounding boxes. That's faster in development time, but it means loading a much larger image than is necessary and rendering a bunch of transparency for no reason. It's a big performance hit to avoid writing some code, but we might do that if we were in a game jam and needed to finish the game in a hurry.</p>
			<p>What we're going to do is use a <em class="italic">trimmed</em> sprite sheet, which has the transparency taken out. This will <a id="_idIndexMarker408"/>mean writing a little code to make sure the sprites still line up, but the memory savings alone (because of a smaller graphic file) will be worth it.</p>
			<p>Our trimmed sprite sheet will look like the following (this is a segment):</p>
			<div><div><img alt="Figure 5.9 – The trimmed sheet&#13;&#10;" src="img/Figure_5.09_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – The trimmed sheet</p>
			<p>Note that while the white space is trimmed, it's not all removed. That's because each rectangle is still the same size across the entire sheet. Look at how the knocked-out version of RHB takes up the entire rectangle horizontally but the idle RHB takes it up vertically. This means that we'll have to account for some transparency with our bounding box, but fortunately, our sprite sheet JSON will also have that data. We'll also need to make sure that the sprites are lined up properly so that the animations don't jerk around the screen. Fortunately, the JSON provides that data as well.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the sprite<a id="_idIndexMarker409"/> sheets used here are generated with a tool called <strong class="bold">TexturePacker</strong>. That includes the JSON that goes along with the graphics. While you can make your own texture maps, why would you? TexturePacker (with both free and paid-for versions) can be found here: <a href="https://bit.ly/3hvZtDQ">https://bit.ly/3hvZtDQ</a>. TexturePacker has built-in tools for trimming a sprite sheet and exporting the data we need to make them useful in our game.</p>
			<p>The trimmed<a id="_idIndexMarker410"/> version of the sprite sheet data file will have a little more information to go along with what we used in <a href="B17151_02_Final_PG_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Drawing Sprites</em>. Here's an example of the first two idle sprites from the new JSON file:</p>
			<pre>"Idle (1).png":
{
    "frame": {"x":117,"y":122,"w":71,"h":115},
    "rotated": false,
    "trimmed": true,
    "spriteSourceSize": {"x":58,"y":8,"w":71,"h":115},
    "sourceSize": {"w":160,"h":136}
},
"Idle (2).png":
{
    "frame": {"x":234,"y":122,"w":71,"h":115},
    "rotated": false,
    "trimmed": true,
    "spriteSourceSize": {"x":58,"y":8,"w":71,"h":115},
    "sourceSize": {"w":160,"h":136}
},</pre>
			<p>Both frames have the <code>frame</code> data that we used previously to cut out our sprite, but they also include a <code>spriteSourceSize</code> field. That field contains the bounding box for the non-transparent portion of the sprite. In other words, the first two idle frames had their sprite start with <code>57</code> transparent pixels on the left and <code>8</code> on top. This information is vital to line up the trimmed sprites, which both start at <code>0,0</code>. Failing to use this will result<a id="_idIndexMarker411"/> in an animation that jumps all over the page and looks terrible. Fortunately, this is rectified by taking the position of the sprite and adding the <code>spriteSourceSize</code> <em class="italic">x</em> and <em class="italic">y</em> coordinates to it. This will result in the sprite not looking like it's in the right place intuitively – that is, when we position the sprite at <code>0</code>, it will show up <code>58</code> pixels to the right, but as long as we also account for <code>spriteSourceSize</code> when doing collision detection, it won't matter. Once we've accounted for <code>spriteSourceSize</code>, our bounding boxes will be tight around our sprite sheet, with minimal transparency started:</p>
			<div><div><img alt="Figure 5.10 – The correct bounding boxes" src="img/Figure_5.10_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – The correct bounding boxes</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you want to draw your own bounding boxes for debugging, and I recommend that you do, you can add a <code>draw_rect</code> function to <code>Renderer</code> and draw the rectangle on the context. The code can be found in the source for <a href="B17151_05_Final_PG_ePub.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Collision Detection</em>, at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/</a>.</p>
			<p>With these new, corrected bounding boxes, RHB and the stone don't collide, and jumping over the stone safely is eventually possible. In the next section, we'll start by adding the new trimmed sprite sheet.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor122"/>Adding the trimmed sheet </h2>
			<p>In the <code>sprite_sheets</code> directory of the <code>assets</code> folder, you can find new versions of the sprite sheet named <code>rhb_trimmed.png</code> and <code>rhb_trimmed.json</code>. Copy those over to <code>static</code>, but make sure you rename the files <code>rhb.png</code> and <code>rhb.json</code> respectively. Start your <a id="_idIndexMarker412"/>server if it isn't already running, and you should see RHB bouncing around on screen because the sprites in the sheet aren't lined up correctly anymore. He'll also be hovering a little bit over the ground:</p>
			<div><div><img alt="Figure 5.11 – Shaking RHB" src="img/Figure_5.11_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Shaking RHB</p>
			<p>Our first priority will be to fix up his animation so that it isn't so jerky. This is why we spent so much time discussing <code>spriteSourceSize</code> earlier – so that we can fix his animation. First, we'll add that field to <code>Cell</code>, which you may or may not recall is in the <code>engine</code> module, as shown in the following code snippet:</p>
			<pre>#[derive(Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Cell {
    pub frame: SheetRect,
    pub sprite_source_size: SheetRect,
}</pre>
			<p>The changes are the additions of the <code>#[serde(rename_all)]</code> directive and a <code>sprite_source_size</code> field. While <code>spriteSourceSize</code> is the name in the JSON, this is Rust, and in Rust, we use snake case for variable names, which is why we use the <code>serde(rename_all)</code> directive. <code>rename_all = "camelCase"</code> may seem backward because we're actually renaming to snake case, but that's because the directive refers to serialization, not deserialization. If we were to write out this structure to a JSON file, we'd want to<a id="_idIndexMarker413"/> rename any variables to be camelCase, which means to deserialize, we do the opposite. Thanks to the work we did earlier, <code>sprite_source_size</code> will be loaded up from the new JSON file, so next, we'll need to adjust the drawing so that the animation lines up again.</p>
			<p>In the <code>game</code> module and the <code>RedHatBoy</code> implementation, we'll change the <code>draw</code> function slightly to account for the trimming. It looks like the following:</p>
			<pre>impl RedHatBoy {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        ...
        renderer.draw_image(
        &amp;self.image,
        &amp;Rect {
                x: sprite.frame.x.into(),
                y: sprite.frame.y.into(),
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
        &amp;Rect {
                <strong class="bold">x: (self.state_machine.context().position.x </strong>
<strong class="bold">                    + sprite.sprite_source_size.x as i16)</strong>
                    <strong class="bold">.into(),</strong>
                <strong class="bold">y: (self.state_machine.context().position.y </strong>
<strong class="bold">                    + sprite.sprite_source_size.y as i16)</strong>
                    <strong class="bold">.into()</strong>,
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
        );
    }</pre>
			<p>I've reproduced the entire <code>draw_image</code> call for context, but only two lines have changed. Remember <a id="_idIndexMarker414"/>that the <code>draw_image</code> call takes two rectangles – the source, which is unchanged, and the destination, which is what we changed. Both the <em class="italic">x</em> and <em class="italic">y</em> coordinates are adjusted by <code>sprite_source_size</code> and its respective coordinates. The cast to <code>i16</code> might make you nervous because it could cause math errors if the <em class="italic">x</em> or <em class="italic">y</em> position in the sprite sheet is over 215, but that would be a very strange sheet. Finally, the <code>into</code> call is on the computed result, to turn <code>i16</code> back into <code>f32</code> for the <code>Rect</code> struct. After making those changes, you should see the animation play correctly, and RHB should return to where he was originally, next to the stone:</p>
			<div><div><img alt="Figure 5.12 – Good bounding boxes&#13;&#10;" src="img/Figure_5.12_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12 – Good bounding boxes</p>
			<p>If you're drawing the bounding boxes with <code>draw_rect</code>, make sure it's using the same bounding box as the images. Note how the bounding boxes don't overlap anymore. Still, it's very close, and RHB does hover over the ground a little bit. So, let's adjust his starting position just <a id="_idIndexMarker415"/>a bit. At the top of the <code>red_hat_boy_states</code> module, we are going to change one constant and add a new one, as follows:</p>
			<pre>const FLOOR: i16 = 479;
const STARTING_POINT: i16 = -20;</pre>
			<p>Previously, <code>FLOOR</code> was <code>475</code>, but let's push RHB down just a few pixels. We'll also give RHB a negative <em class="italic">x</em> position, to give a little room between him and the stone. Remember that RHB is adjusted back to the right to account for animation, so he won't actually be drawn off screen. Next, we'll modify the <code>RedHatBoyState&lt;Idle&gt;</code> implementation, specifically the <code>new</code> function, to move RHB's starting point. That change is shown here:</p>
			<pre>impl RedHatBoyState&lt;Idle&gt; {
    fn new() -&gt; Self {
        RedHatBoyState {
            context: RedHatBoyContext {
                frame: 0,
                position: Point {
                    x: <strong class="bold">STARTING_POINT</strong>,
                    y: <strong class="bold">FLOOR</strong>,
                },
                velocity: Point { x: 0, y: 0 },
            },
            _state: Idle {},
        }
    }
}</pre>
			<p>Again, I've included the entire <code>impl</code> for context, but the only changes are the initial position of RHB's <code>RedHatBoyContext</code>, using the new constants. Do this, and you'll have RHB standing <a id="_idIndexMarker416"/>with a little bit of runway so that he can jump the stone, like so:</p>
			<div><div><img alt="Figure 5.13 – Get a running start&#13;&#10;" src="img/Figure_5.13_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Get a running start</p>
			<p>The bounding boxes are correct in our images, but we're not actually using them yet. That's why if you push the right arrow, RHB will still start running and pass right behind the stone. It's time to give the stone and RHB proper axis-aligned bounding boxes, rather than just drawing them, and then use them to knock RHB right over. What<a id="_idTextAnchor123"/> fun!</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor124"/>Colliding with an obstacle</h1>
			<p>To have<a id="_idIndexMarker417"/> collisions, we'll have to actually put the bounding boxes we've seen on both RHB and the stone. Then, in the <code>update</code> function of <code>WalkTheDog</code>, we'll need to detect that collision, and when that collision happens, we'll move RHB into the <code>Falling</code> and <code>KnockedOut</code> states, which correspond to the <code>Dead</code> animation in the sprite sheet. Much of that code, particularly the state machine, will be very familiar, so I'll refrain from reproducing the parts that are repetitive and highlight the differences. I will remind you of what needs to change in new states, and you can always check the final code at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly/tree/chapter_5/</a>.</p>
			<p>Let's start with the easiest bounding box, the one for the <a id="_idTextAnchor125"/>stone.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor126"/>A bounding box for a stone</h2>
			<p>The stone is the simplest of the <a id="_idIndexMarker418"/>bounding boxes because we can just use the size of <code>HTMLImageElement</code>. This won't always be the case. If you look at the images of the stone with a bounding box around it, you will notice that it is larger than the stone's actual size, particularly at the corners. For the time being, this will be good enough, but as we proceed, we'll need to keep this in mind.</p>
			<p>To add a bounding box to the <code>Image</code> implementation, which is in the <code>engine</code> module, we'll want to calculate the bounding box when <code>Image</code> is created, in its <code>new</code> function, as shown here:</p>
			<pre>pub struct Image {
    element: HtmlImageElement,
    position: Point,
    <strong class="bold">bounding_box: Rect,</strong>
}
impl Image {
    pub fn new(element: HtmlImageElement, position: Point) -&gt; Self {
<strong class="bold">        let bounding_box = Rect {</strong>
<strong class="bold">            x: position.x.into(),</strong>
<strong class="bold">            y: position.y.into(),</strong>
<strong class="bold">            width: element.width() as f32,</strong>
<strong class="bold">            height: element.height() as f32,</strong>
<strong class="bold">        };</strong>
        Self {
            element,
            position,
            <strong class="bold">bounding_box,</strong>
        }
    }
    ....
}</pre>
			<p>Here, we've added <code>bounding_box</code> to the <code>Image</code> <code>struct</code>, and we construct it in the <code>new</code> function using <code>width</code> and <code>height</code> from its <code>HTMLImageElement</code> backing. It's worth noting that we had to cast the <code>element.width()</code> and <code>element.height()</code> calls to <code>f32</code>. This should be safe, but if later we're drawing a very large image, then it may become a problem. It's also <a id="_idIndexMarker419"/>worth noting that by creating the bounding box in the <code>new</code> function, we're ensuring that anytime <code>position</code> is updated, we also need to update <code>bounding_box</code>. We could work around this by calculating <code>bounding_box</code> every time, and that's a fine solution, but it does mean potentially losing performance. In this case, we'll keep both <code>position</code> and <code>bounding_box</code> private in <code>struct</code> to ensure they don't get out of sync. <code>Image</code> objects don't move yet, anyway.</p>
			<p>Given that <code>bounding_box</code> is private, we'll need to give it an accessor, so let's do that now:</p>
			<pre>impl Image {
    ...
    pub fn bounding_box(&amp;self) -&gt;&amp;Rect {
        &amp;self.bounding_box
    }
}</pre>
			<p>That takes care of the stone; now, let's give RHB a bound<a id="_idTextAnchor127"/>ing box.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor128"/>A bounding box for RedHatBoy</h2>
			<p>The bounding box <a id="_idIndexMarker420"/>on <code>RedHatBoy</code> is a little more complicated for the same reasons that the sprite sheet was more complicated. It needs to align with where the <a id="_idIndexMarker421"/>sheet is, and it needs to adjust based on the animation. Therefore, we won't be able to do what we did for <code>Image</code> and store one <code>bounding_box</code> tied to the object. Instead, we'll calculate its bounding box based on its current state and the sprite sheet. The code will actually look very similar to <code>draw</code>, as seen here:</p>
			<pre>impl RedHatBoy {
    ...
    fn bounding_box(&amp;self) -&gt;Rect {
        let frame_name = format!(
            "{} ({}).png",
            self.state_machine.frame_name(),
            (self.state_machine.context().frame / 3) + 1
        );
        let sprite = self
            .sprite_sheet
            .frames
            .get(&amp;frame_name)
            .expect("Cell not found");
        Rect {
            x: (self.state_machine.context().position.x + 
                sprite.sprite_source_size.x as i16).into(),
            y: (self.state_machine.context().position.y + 
                sprite.sprite_source_size.y as i16).into(),
            width: sprite.frame.w.into(),
            height: sprite.frame.h.into(),
        }
    }
    ...
}</pre>
			<p>To calculate <code>bounding_box</code>, we start by creating <code>frame_name</code> from the state name and the current frame, just like how we did in the <code>draw</code>, and then we calculate <code>Rect</code> from those values using the <a id="_idIndexMarker422"/>same calculations we did when we updated the <code>draw</code> function. In fact, it's a good time to clean up some of the <a id="_idIndexMarker423"/>duplications in those two pieces of code, using refactoring. Let's extract functions to get the frame and sprite name, still in the <code>RedHatBoy</code> implementation:</p>
			<pre>impl RedHatBoy {
    ...
    fn frame_name(&amp;self) -&gt; String {
        format!(
            "{} ({}).png",
            self.state_machine.frame_name(),
            (self.state_machine.context().frame / 3) + 1
        )
    }
    fn current_sprite(&amp;self) -&gt; Option&lt;&amp;Cell&gt; {
        self.sprite_sheet.frames.get(&amp;self.frame_name())
    }
    ...
}</pre>
			<p>For <code>current_sprite</code>, you'll need to make sure you import <code>engine::Cell</code>. Now, we can<a id="_idIndexMarker424"/> replace the <a id="_idIndexMarker425"/>duplicated code in the <code>bounding_box</code> implementation, as follows:</p>
			<pre>impl RedHatBoy {
    …
    fn bounding_box(&amp;self) -&gt;Rect {
        let sprite = self.current_sprite().expect("Cell not
            found");
        Rect {
            x: (self.state_machine.context().position.x + 
                sprite.sprite_source_size.x as i16).into(),
            y: (self.state_machine.context().position.y + 
                sprite.sprite_source_size.y as i16).into(),
            width: sprite.frame.w.into(),
            height: sprite.frame.h.into(),
        }
    }
    ...
}</pre>
			<p>Going further, we can shrink <code>draw</code> by removing the duplicated code from <code>bounding_box</code> and making a much smaller <code>draw</code> function:</p>
			<pre>impl RedHatBoy {
    ...
    fn draw(&amp;self, renderer: &amp;Renderer) {
        let sprite = self.current_sprite().expect("Cell not 
            found");
        renderer.draw_image(
        &amp;self.image,
        &amp;Rect {
                x: sprite.frame.x.into(),
                y: sprite.frame.y.into(),
                width: sprite.frame.w.into(),
                height: sprite.frame.h.into(),
            },
            &amp;self.bounding_box(),
        );
    }
    ...
}</pre>
			<p>This makes for must<a id="_idIndexMarker426"/> smaller, cleaner implementations, but it's worth paying attention to the fact that we're looking up <code>current_sprite</code> twice on every frame. We won't work to fix it now<a id="_idIndexMarker427"/> because we're not seeing any troubles, but we may want to memoize this value later.</p>
			<p>Now that we have both bounding boxes, we can actually see whether RHB collides<a id="_idTextAnchor129"/> with the stone.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor130"/>Crashing on the collision</h2>
			<p>To crash on a <a id="_idIndexMarker428"/>collision, we'll need to check whether the two rectangles intersect using the pseudocode from earlier, only with real code. We'll add that code to <code>Rect</code>, which if you recall is part of the <code>engine</code> module. That code is the implementation on the <code>Rect</code> struct, shown here:</p>
			<pre>impl Rect {
    pub fn intersects(&amp;self, rect: &amp;Rect) -&gt; bool {
        self.x &lt; (rect.x + rect.width)
        &amp;&amp; self.x + self.width &gt; rect.x
        &amp;&amp; self.y &lt; (rect.y + rect.height)
        &amp;&amp; self.y + self.height &gt; rect.y
    }
}</pre>
			<p>This reproduces the previous pseudocode, checking to see whether there is any overlap and returning <code>true</code> if there is. Every time you see <code>rect.x + rect.width</code>, that's the right side, and <code>rect.y + height</code> is the bottom. Personally, I prefer to put the same rectangle on the left-hand side of this function for every condition, as I find it easier to read and think about. We'll use this code in the <code>update</code> function of <code>WalkTheDog</code>. That code is small, but it will cause a chain reaction. The collision code is as follows:</p>
			<pre>impl WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
           walk.boy.update();
            if walk
                .boy
                .bounding_box()
                .intersects(walk.stone.bounding_box())
            {
                walk.boy.knock_out();
            }
        }
    }
}</pre>
			<p>The check for collisions will happen<a id="_idIndexMarker429"/> right after the call to <code>update</code> on <code>boy</code>. We check whether the boy's bounding box has intersected the stone's with our brand new <code>intersects</code> function, and if it has, we use <code>knock_out</code> on the RHB. Poor RHB; fortunately, you can always refresh.</p>
			<p>The <code>knock_out</code> function doesn't exist yet; creating it will mean updating our state machine. The <code>KnockOut</code> event will cause a transition into the <code>Falling</code> state, which will then transition into the <code>KnockedOut</code> state when the <code>Falling</code> animation has completed. What are we waiting for? Let's knock out RHB!</p>
			<h3>A KnockOut event </h3>
			<p>As we did in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, we'll add new states to <code>RedHatBoyStateMachine</code> and "follow the compiler" to know where to fill in the <a id="_idIndexMarker430"/>necessary code. Rust's type system does a great job of making this kind of work easy, giving useful error messages along the way, so I'm only going to highlight passages that are unique. Remember that you can always peek ahead using the source code at <a href="https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly">https://github.com/PacktPublishing/Rust-Game-Development-with-WebAssembly</a>, although I highly recommend you try writing the implementation yourself first.</p>
			<p>You can get started in the <code>game</code> module by adding a <code>KnockOut</code> event to <code>Event</code> <code>enum</code> and a <code>knock_out</code> method<a id="_idIndexMarker431"/> onto <code>RedHatBoy</code> as with the other state machine transitions, as shown below:</p>
			<pre>pub enum Event {
    Run,
    Jump,
    Slide,
    <strong class="bold">KnockOut</strong>,
    Update,
}
...
impl RedHatBoy {
    ...
    fn knock_out(&amp;mut self) {
        self.state_machine = 
            self.state_machine.transition(Event::KnockOut);
}
    ...</pre>
			<p>This will just move the compiler error into <code>RedHatBoyStateMachine</code> because match statements are incomplete, so you'll need to add a <code>KnockOut</code> event to <code>RedHatBoyStateMachine</code> that will transition from <code>Running</code> to <code>Falling</code>. That transition is like so:</p>
			<pre>impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            ...
            (RedHatBoyStateMachine::Running(state), 
                Event::KnockOut) =&gt; state.knock_out
                    ().into(),
            (RedHatBoyStateMachine::Jumping(state), 
                Event::KnockOut) =&gt;   
                    state.knock_out().into(),
            (RedHatBoyStateMachine::Sliding(state), 
                Event::KnockOut) =&gt;   
                    state.knock_out().into(),
            _ =&gt; self,
        }
    }
    ...</pre>
			<p>You might wonder why we also have transitions from <code>Jumping</code> and <code>Sliding</code> to <code>Falling</code>; that's because if we don't do that, then the user can simply hold down the spacebar to jump continuously, or slide at the right time, and they will pass right through the stone. So, we <a id="_idIndexMarker432"/>need to make sure that all three of those states will transition to <code>Falling</code> in order for the game not to have any bugs.</p>
			<p>Of course, there's still a lot missing. <code>Falling</code> doesn't exist yet, neither as a member of the <code>RedHatBoyStateMachine</code> <code>enum</code> nor as a struct. The typestates for <code>Sliding</code>, <code>Jumping</code>, or <code>Running</code> don't have <code>knock_out</code> methods, and there's no <code>From</code> trait implemented to convert from <code>Falling</code> into <code>RedHatBoyStateMachine::Falling</code>. You'll need to add both of those, just like before, and fill in the rest of the compiler errors. You'll find that you need two new constants, the number of frames in the falling animation and the name of the falling animation in the sprite sheet. You can look at <code>rhb.json</code> and figure out the values, or look at the following listings:</p>
			<pre>const FALLING_FRAMES: u8 = 29; // 10 'Dead' frames in the sheet, * 3 - 1.
const FALLING_FRAME_NAME: &amp;str = "Dead";</pre>
			<p>If you've made all the proper boilerplate changes, you'll end up making a transition from <code>Running</code> to <code>Falling</code> that looks like the following code:</p>
			<pre>impl RedHatBoyState&lt;Running&gt; {
    pub fn knock_out(self) -&gt; RedHatBoyState&lt;Falling&gt; {
        RedHatBoyState {
                context: self.context,
                _state: Falling {},
        }
    }
    ...</pre>
			<p>Note that you're only transitioning states at this point, not making any changes to <code>RedHatBoyContext</code>. This is why things get weird because when RHB collides with the stone, he falls over… and keeps<a id="_idIndexMarker433"/> sliding and falling over forever:</p>
			<div><div><img alt="Figure 5.14 – Sliding while falling?" src="img/Figure_5.14_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Sliding while falling?</p>
			<p>The transition properly moves into the <code>Dead</code> animation, but it doesn't stop RHB's forward motion. Let's change the transition to stop <code>RedHatBoy</code>:</p>
			<pre>impl RedHatBoyState&lt;Running&gt; {
    pub fn knock_out(self) -&gt; RedHatBoyState&lt;Falling&gt; {
        RedHatBoyState {
                context: self.context.reset_frame().stop(),
                _state: Falling {},
        }
    }
    ...</pre>
			<p>Now, when setting the new state, we call <code>reset_frame()</code> to set the frame to <code>0</code>, as we always do when changing animations, and call the new <code>stop</code> function that will halt the character's forward motion. Of course, that function isn't written yet. It's attached to the <code>RedHatBoyContext</code> implementation, setting the <code>velocity.x</code> to <code>0</code>:</p>
			<pre>impl RedHatBoyContext {
      fn stop(mut self) -&gt; Self {
          self.velocity.x = 0;
              self
        }
    }
...</pre>
			<p>You'll want to do the same transition <a id="_idIndexMarker434"/>when going from <code>Sliding</code> to <code>Falling</code> and <code>Jumping</code> to <code>Falling</code> as well so that the transitions match. That will halt the character's forward motion but will not stop the death animation from playing over and over again. That's because we never transition out of the <code>Falling</code> state and into <code>KnockedOut</code>, which itself doesn't exist yet. Fortunately, we've done code like this before. Remember in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, we transitioned out of the <code>Sliding</code> animation and back into the <code>Running</code> animation when the slide animation was complete. That code, which is in the <code>update</code> function of <code>RedHatBoyState&lt;Sliding&gt;</code>, is reproduced here:</p>
			<pre>impl RedHatBoyState&lt;Sliding&gt; {
    ...
    pub fn update(mut self) -&gt; SlidingEndState {
        self.update_context(SLIDING_FRAMES);
        if self.context.frame &gt;= SLIDING_FRAMES {
            SlidingEndState::Running(self.stand())
        } else {
            SlidingEndState::Sliding(self)
        }
    }
}</pre>
			<p>In this code, we check every update and see whether the <code>Sliding</code> animation is complete via <code>if state_machine.context.frame&gt;= SLIDING_FRAMES</code>. If it is, we return the <code>Running</code> state instead of the <code>Sliding</code> state. In order to get this far, you already had to add an <code>update</code> method to <code>RedHatBoyState&lt;Falling&gt;</code>, likely with a generic default that <a id="_idIndexMarker435"/>played the animation. Now, you'll need to mimic this behavior and transition into the new <code>KnockedOut</code> state. Specifically, you'll need to do the following:</p>
			<ol>
				<li value="1">Create a <code>KnockedOut</code> state.</li>
				<li>Create a transition from <code>Falling</code> to <code>KnockedOut</code>.</li>
				<li>Check in the <code>update</code> action whether the <code>Falling</code> animation is complete, and if so, transition to the <code>KnockedOut</code> state instead of staying in <code>Falling</code>.</li>
				<li>Create an <code>enum</code> to handle both end states of the <code>update</code> method in <code>RedHatBoyState&lt;Falling&gt;</code>, as well as the corresponding <code>From</code> trait, to convert from that to the <code>RedHatBoyStateMachine</code>-appropriate <code>enum</code> variant.</li>
			</ol>
			<p>The only thing new here is that <code>RedHatBoyState&lt;KnockedOut&gt;</code> will not need the <code>update</code> method because, in the <code>KnockedOut</code> state, RHB doesn't do anything. We won't go through that code step by step, and instead, I highly encourage you to try it yourself. If you get stuck, you can look at the code at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. When you're done, it should look like this:</p>
			<div><div><img alt="Figure 5.15 – Just taking a nap" src="img/Figure_5.15_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Just taking a nap</p>
			<p>In the meantime, I'll <a id="_idIndexMarker436"/>assume you did it because you're awesome, so we'll move on to j<a id="_idTextAnchor131"/>umping onto a platform.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor132"/>Jumping onto a platform</h1>
			<p>Now that RHB crashes into <a id="_idIndexMarker437"/>a stone, we'll need to find a way to go over it. Play the game and try jumping the rock; you'll that notice it's really difficult. The timing has to be just right, reminiscent of the scorpions in the classic game <em class="italic">Pitfall</em> for the Atari 2600. Later in this chapter, we'll adjust that by shrinking the bounding boxes and increasing the horizontal speed of RHB, but first, we're going to put a platform above the stone that RHB can jump on to avoid the rock. In addition to putting a platform on screen with a new sprite sheet and giving it a bounding box, we'll have to handle a new type of collision. Specifically, we'll need to handle collisions coming from above the platform so that we can land on it.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor133"/>Adding a platform </h2>
			<p>We'll start by adding the platform<a id="_idIndexMarker438"/> from a new sprite sheet. This sprite sheet actually contains the elements that will make up our map in the upcoming chapters, but we'll use it for just one platform for now. The sprite sheet looks like this:</p>
			<div><div><img alt="Figure 5.16 – Our platforms&#13;&#10;" src="img/Figure_5.16_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – Our platforms</p>
			<p>The image is divided up into <a id="_idIndexMarker439"/>squares that aren't outlined but are visible in the way the <a id="_idIndexMarker440"/>shapes are arranged, called tiles. Those squares are the sprites that we'll be mixing and matching to make various obstacles for RHB to jump over and slide under. The tiles are also jammed together nice and tight, so we won't have to concern ourselves with any offsets. For the time being, we'll only need the platform at the lower-right corner, which will float over the stone:</p>
			<div><div><img alt="Figure 5.17 – One platform" src="img/Figure_5.17_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – One platform</p>
			<p>This one is conveniently<a id="_idIndexMarker441"/> set up with the sprites in order, so it will be easy to access in the sprite sheet. You can see those dotted lines now marking the three sprites. Let's get it into our game. In the <code>sprite_sheets</code> directory of the assets, you'll find two files, <code>tiles.json</code> and <code>tiles.png</code>. This is the sheet for the tiles, which we'll need to load at startup. So that we have something to load it into, we'll start by creating a <code>Platform</code> struct in the <code>game</code> module:</p>
			<pre>struct Platform {
    sheet: Sheet,
    image: HtmlImageElement,
    position: Point,
}
impl Platform {
    fn new(sheet: Sheet, image: HtmlImageElement, position:         Point) -&gt; Self {
        Platform {
            sheet,
            image,
            position,
        }
    }
}</pre>
			<p>So far, this just loads up the expected data. At this point, you may note that <code>sheet</code> and <code>image</code> are paired together repeatedly, which means they are good candidates for refactoring into a new structure, such as <code>SpriteSheet</code>. We won't do that now because we don't want to be premature and refactor to a bad abstraction, but we'll keep an eye out for the duplication if it shows up again.</p>
			<p>The platform is going to<a id="_idIndexMarker442"/> need two things. It's going to need to be drawn, and it's going to need a bounding box so that we can land on it. To draw the box, we'll need to draw the three tiles that make that platform on the bottom together. Looking at <code>tiles.json</code>, it's hard to tell which platforms we want because the frame names are all just numbers such as <code>14.png</code>, so just take my word for it that the tiles are <code>13.png</code>, <code>14.png</code>, and <code>15.png</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It's significantly easier to tell which tiles you need to look at using a tool such as TexturePacker. If you don't have that available, you can just draw each of the images from the sheet, with their names displayed as well, and then modify their names in the JSON file to be more readable.</p>
			<p>Let's dive into the <code>draw</code> function for <code>Platform</code> now, which has a little trick in it, as seen here:</p>
			<pre>impl Platform {
    ...
fn draw(&amp;self, renderer: &amp;Renderer) {
        let platform = self
            .sheet
            .frames
            .get("13.png")
            .expect("13.png does not exist");
        renderer.draw_image(
        &amp;self.image,
        &amp;Rect {
                x: platform.frame.x.into(),
                y: platform.frame.y.into(),
                width: (platform.frame.w * 3).into(),
                height: platform.frame.h.into(),
            },
            &amp;Rect {
                x: self.position.x.into(),
                y: self.position.y.into(),
                width: (platform.frame.w * 3).into(),
                height: platform.frame.h.into(),
            },
        );
}</pre>
			<p>The cheat is that we know that<a id="_idIndexMarker443"/> the three tiles happen to be next to each other in the sheet, so instead of getting all three sprites out of the sheet, we'll just get three times the width of the first sprite. That will happen to include the other two tiles. Don't forget that the second <code>Rect</code> is the destination and, as such, should use the <code>position</code> field. That second rectangle also corresponds to the bounding box of the platform, so let's create the platform's bounding box function and use it there instead. These changes are shown here:</p>
			<pre>impl Platform {
    ...
    fn bounding_box(&amp;self) -&gt;Rect {
        let platform = self
            .sheet
            .frames
            .get("13.png")
            .expect("13.png does not exist");
        Rect {
            x: self.position.x.into(),
            y: self.position.y.into(),
            width: (platform.frame.w * 3).into(),
            height: platform.frame.h.into(),
        }
    }
    fn draw(&amp;self, renderer: &amp;Renderer) {
        ...
        renderer.draw_image(
            &amp;self.image,
            &amp;Rect {
                x: platform.frame.x.into(),
                y: platform.frame.y.into(),
                width: (platform.frame.w * 3).into(),
                height: platform.frame.h.into(),
            },
            &amp;self.bounding_box(),
        );
    }</pre>
			<p>This code has the same troubles as other code where we search for the frame on every draw and we're doing it twice. We're also constructing <code>Rect</code> on every <code>bounding_box</code> call, which we explicitly <a id="_idIndexMarker444"/>avoided earlier. Why the change? Because I know the future, and we'll be changing how we construct this shortly, so it's not worth worrying about saving an extra cycle or two here. Trust me.</p>
			<p>Now that we've made a platform that could theoretically be drawn, let's actually draw it. First, we'll add it to the <code>Walk</code> struct, as shown here:</p>
			<pre>struct Walk {
    boy: RedHatBoy,
    background: Image,
    stone: Image,
    platform: Platform,
}</pre>
			<p>Of course, that won't compile because when we create <code>Walk</code>, we don't have a platform. We need to update the <code>initialize</code> function in <code>WalkTheDog</code> to include the new <code>Platform</code>, as shown here:</p>
			<pre>impl Game for WalkTheDog {
    async fn initialize(&amp;mut self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let stone = engine::
                   load_image("Stone.png").await?;
                <strong class="bold">let platform_sheet = browser::</strong>
<strong class="bold">                    fetch_json("tiles.json").await?;</strong>
                <strong class="bold">let platform = Platform::new(</strong>
                    <strong class="bold">platform_sheet.into_serde::&lt;Sheet&gt;()?,</strong>
                    <strong class="bold">engine::load_image("tiles.png").await?,</strong>
                    <strong class="bold">Point { x: 200, y: 400 },</strong>
                <strong class="bold">);</strong>
                ...
                Ok(Box::new(WalkTheDog::Loaded(Walk {
                    boy: rhb,
                    background: Image::new(background,
                        Point { x: 0, y: 0 }),
                    stone: Image::new(stone, Point { x: 
                        150, y: 546 }),
                    <strong class="bold">platform</strong>,
                })))
                ...</pre>
			<p>There are only a few small changes here, which I've highlighted. We then fetch the <code>tiles.json</code> and create a new <code>Platform</code> with it and <code>tiles.png</code>. Finally, we create <code>Walk</code> with <code>platform</code>. Drawing the<a id="_idIndexMarker445"/> platform is a one-line change, adding it to the <code>draw</code> function of <code>WalkTheDog</code>, as shown here:</p>
			<pre>fndraw(&amp;self, renderer: &amp;Renderer) {
    ...
    if let WalkTheDog::Loaded(walk) = self {
        walk.background.draw(renderer);
        walk.boy.draw(renderer);
        walk.stone.draw(renderer);
        <strong class="bold">walk.platform.draw(renderer);</strong>
    }
}</pre>
			<p>If you've done this correctly, you should see the following:</p>
			<div><div><img alt="Figure 5.18 – An escape!" src="img/Figure_5.18_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – An escape!</p>
			<p>But while the platform has a bounding box, you aren't using it yet, so we'll need to add that collision to the <code>update</code> function of <code>WalkTheDog</code>. When colliding with the platform, you'll want to transition from <code>Jumping</code> back to <code>Running</code>. This transition is already written – we do it when we land on the floor – so you'll just need to add a check and an event that can perform <a id="_idIndexMarker446"/>the transition.</p>
			<p>We'll also need to make sure that RHB stays on the platform. Currently, gravity would just pull him right through it, regardless of whether or not there's a collision or the player is in the <code>Running</code> state. That solution is a little more complex. A naive solution, and I know because I wrote it, is to stop applying gravity when the player is on the platform. This works until it<a id="_idIndexMarker447"/> doesn't, causing a <strong class="bold">Wile E. Coyote</strong> effect when RHB runs off the platform and stays in the air. Presumably, if he could look down, he would hold up a sign and then crash to the ground.</p>
			<p>Instead, what we do is continue to apply gravity on every frame and check whether RHB is still landing on the platform. If he is, then we adjust him right back onto the top of it. This effectively means that RHB "lands" repeatedly until he reaches the end of the platform, when he falls off. Fortunately, this<a id="_idIndexMarker448"/> isn't visible to the user, since we calculate RHB's new position on every update, and this results in him moving to the right until he falls off the edge, as he should.</p>
			<p>Let's start by adding the check to the <code>update</code> function so that RHB can land on a platform:</p>
			<pre>fn update(&amp;mut self, keystate: &amp;KeyState) {
    if let WalkTheDog::Loaded(walk) = self {
        ...
        walk.boy.update();
<strong class="bold">        if walk</strong>
<strong class="bold">            .boy</strong>
<strong class="bold">            .bounding_box()</strong>
<strong class="bold">            .intersects(&amp;walk.platform.bounding_box())</strong>
<strong class="bold">        {</strong>
<strong class="bold">            walk.boy.land();</strong>
<strong class="bold">        }</strong>
        if walk
            .boy
            .bounding_box()
            .intersects(walk.stone.bounding_box())
        {
            walk.boy.knock_out()
        }
        ...
    }
}</pre>
			<p>I've reproduced the check for <a id="_idIndexMarker449"/>the boy intersecting the stone as well so that you can see that we checked the bounding box before checking the stone. It doesn't really matter which check comes first, but I prefer to check things that can kill the player last. That way we won't kill the player when we really want them to land on a platform. Just as when we created the <code>knock_out</code> method on <code>RedHatBoy</code>, the <code>land</code> method and its corresponding <code>Event</code> don't exist yet. You can create them both now, and follow the compiler until you have to write the transition in the state machines, as shown here:</p>
			<pre>impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            (RedHatBoyStateMachine::Jumping(state), Event::Land) =&gt; {
                state.land().into()
            }
            ...</pre>
			<p>Remember that we already wrote a transition method from <code>Jumping</code> to <code>Running</code>, so you won't need to write it, but as I mentioned previously, this isn't enough to land on the platform. The transition will happen, but RHB will fall right through the platform and crash into the ground. Not cool. In order to keep RHB on the platform, we need to set its <em class="italic">y</em> position to the top of the bounding box. This will mean changing the <code>Land</code> event to store the <em class="italic">y</em> position of the platform's bounding box. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Because we used <code>enum</code> for the events, we can pass any data we need by adding it as part of the variant we are using. The Rust <code>enum</code> is a great feature of Rust.</p>
			<p>On every intersection with the <a id="_idIndexMarker450"/>platform, we'll transition with the <code>Land</code> event. This means that the <code>Update</code> event will pull the player down a bit because of gravity, but then the <code>Land</code> event will push them right back up. Since we don't draw the in-between state, it will look fine. This system isn't perfect, but we aren't writing a physics engine. Let's do that now; we'll start by modifying the <code>land</code> function to be <code>land_on</code>, taking a <em class="italic">y</em> position:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        ...
        if walk
            .boy
            .bounding_box()
            .intersects(&amp;walk.platform.bounding_box())
        {
            <strong class="bold">walk.boy.land_on(walk.platform.bounding_box().y);</strong>
        }
    }
    ...
}</pre>
			<p>Now, <code>land_on</code> instead of <code>land</code> takes the <em class="italic">y</em> position of <code>bounding_box</code> for the platform. If you just follow the compiler errors for that, you will eventually need to modify the <code>Land</code> event to hold the position and modify the <code>land</code> method on the <code>Jumping</code> typestate. It will probably look something like this:</p>
			<pre>impl RedHatBoyState&lt;Jumping&gt; {
    ...
    pub fn <strong class="bold">land_on</strong>(<strong class="bold">mut self</strong>, position: f32) -&gt; 
        RedHatBoyState&lt;Running&gt; {
            <strong class="bold">self.context.position.y = position as i16;</strong>
            RedHatBoyState {
                context: self.context.reset_frame(),
                _state: Running,
        }
    }</pre>
			<p>As an initial attempt, this seems <a id="_idIndexMarker451"/>fine. It's unfortunate that <code>self</code> had to be made mutable, but the transition sets RHB's position back to the top of the platform. The problem is that the <em class="italic">y</em> position of RHB actually represents his top-left corner. This means that if you followed this to its conclusion, you'd get something like this:</p>
			<div><div><img alt="Figure 5.19 – This does not look right" src="img/Figure_5.19_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – This does not look right</p>
			<p>Fortunately, <code>RedHatBoy</code> knows his height, so we can adjust for the height when setting the <em class="italic">y</em> position. We would need to include <code>self.bounding_box.height()</code> as a parameter in the <code>Land</code> event<a id="_idIndexMarker452"/> and then account for it during the transition, like so:</p>
			<pre>impl RedHatBoyState&lt;Jumping&gt;{
    ...
    fn land_on(mut self, position: f32, height: f32) {
        let position = (position - height) as i16;
        RedHatBoyState {
            context: self.context.reset_frame(),
            _state: Running,
        }
    }
}</pre>
			<p>This sort of works, but it has another problem. The bounding box is actually changing size during the animation, based on the current frame of the animation, because the trimmed sprite shrinks and grows slightly. As we check collisions on every frame, we'll call <code>Land</code> repeatedly while RHB is on the platform. If we continually change the landing position based on the current frame's height, the walk ends up looking very "bouncy." Even though the bounding box is changing slightly, it looks better if we use a constant value for the player's height for this calculation.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Game development frequently has a lot of trial and error. When the mathematically correct solution doesn't play well or look right, remember that the feel of the game is more important than mathematical accuracy.</p>
			<p>We already have the player height adjustment; we just created it as the <code>FLOOR</code> constant. In the <code>game</code> module, you'll see that the <code>FLOOR</code> constant is set at <code>479</code>. Well, that means that we can use the height of the game (which is <code>600</code>) and subtract <code>FLOOR</code> to get the player's height. We can use that info to create two new constants. The first, <code>HEIGHT</code>, can be defined in the game module as <code>const HEIGHT: i16 = 600</code> and used wherever we've hardcoded the <code>600</code> value. The second, <code>PLAYER_HEIGHT</code>, can be defined in the <code>red_hat_boy_states</code> module, as shown here:</p>
			<pre>mod red_hat_boy_states {
<strong class="bold">use super::HEIGHT;</strong>
  ...
    const FLOOR: i16 = 479;
    <strong class="bold">const PLAYER_HEIGHT: i16 = HEIGHT - FLOOR;</strong></pre>
			<p><code>PLAYER_HEIGHT</code> belongs in the <code>red_hat_boy_states</code> module, since it will only be used there, but to calculate it, we need to import <code>game::HEIGHT</code> into the <code>red_hat_boy_states module</code>. We do that with the highlighted <code>use</code> statement. Now that we have the proper<a id="_idIndexMarker453"/> value to adjust RHB when he lands, we can account for it in the <code>land_on</code> method and <code>RedHatBoyContext</code>:</p>
			<pre>impl RedHatBoyContext {
    ...
    fn set_on(mut self, position: i16) -&gt; Self {
        let position = position - PLAYER_HEIGHT;
        self.position.y = position;
        self
    }
}
...
impl RedHatBoyState&lt;Jumping&gt; {
    pub fn land_on(<strong class="bold">self</strong>, position: f32) -&gt;         RedHatBoyState&lt;Running&gt; {
        RedHatBoyState {
            context: self.context.reset_frame()
            <strong class="bold">.set_on(position as i16)</strong>,
            _state: Running,
          }
     }
...</pre>
			<p>We've moved the adjustment of RHB's position into a <code>set_on</code> method in <code>RedHatBoyContext</code>. The <code>set_on</code> method always adjusts for the player's height, which is why it's named <code>set_on</code> and not <code>set_position_y</code>. It also returns <code>self</code> so that we won't require <code>mut self</code> anymore, fitting<a id="_idIndexMarker454"/> with the rest of the operations on <code>RedHatBoyContext</code>. </p>
			<p>Changing the <code>land</code> method to the <code>land_on</code> method also requires you to modify what it is called within the <code>update</code> method of <code>RedHatBoyState&lt;Jumping&gt;</code>. After all, there is no <code>land</code> method anymore. Keep in mind that we have to account for the height when calling <code>set_on</code>, as shown here:</p>
			<pre>    impl RedHatBoyState&lt;Jumping&gt; {
        pub fn update(mut self) -&gt; JumpingEndState {
            self.update_context(JUMPING_FRAMES);
            if self.context.position.y &gt;= FLOOR {
                <strong class="bold">JumpingEndState::Landing(self.land_on</strong>
<strong class="bold">                    (HEIGHT.into()))</strong>
            } else {
                JumpingEndState::Jumping(self)
            }
        }</pre>
			<p>Here, we are checking whether RHB is past <code>FLOOR</code> and pushing it back up to <code>HEIGHT</code>. Remember that When we call land_on we send the position of RHB's feet, not his head. You could argue that the <code>update</code> method shouldn't check for hitting the ground and that the higher-level <code>update</code> method in <code>WalkTheDog</code> should check for collisions with the ground and use the <code>Land</code> event when appropriate. I think I'd agree, but we've made more than enough changes for this chapter, so we'll stick with it as it is for now.</p>
			<p>This adjusts the position of RHB for landing. He'll be positioned on the platform or the ground at the end of his jump. Now, we need to make sure that the <code>Land</code> event prevents RHB from falling through the platform right after he lands. The <code>Land</code> event will happen while <code>Running</code> occurs <a id="_idIndexMarker455"/>on the platform, but it isn't handled, so you'll fall right through because gravity takes effect. We're going to need a <code>Land</code> transition for every state that is valid on the platform, where the state stays the same but the <code>y</code> position is forced back to the top of the platform.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If I might steal a line from the <em class="italic">Big Nerd Ranch</em> series of books, programming is hard and you are not stupid. It may appear that these changes emerged fully formed because I am a super-expert, but in many cases, these only came about through much trial and error, rereading old books, and luck. So, don't worry if you wouldn't have come up with this solution off the top of your head or things have gotten a little confusing. Take another try at the code, slow down, and have fun. We're making a game!</p>
			<p>Fortunately, it's harder to explain why we need this code than to actually write it. We'll handle the <code>Land</code> event for <code>Running</code> in the <code>transition</code> method:</p>
			<pre>impl RedHatBoyStateMachine {
    fn transition(self, event: Event) -&gt; Self {
        match (self, event) {
            ...
            (RedHatBoyStateMachine::Running(state), Event::
                Land(position)) =&gt; {
                state.land_on(position).into()
            }</pre>
			<p>Then, we'll add a <code>land_on</code> method to the <code>RedHatBoyState&lt;Running&gt;</code> typestate, as shown here:</p>
			<pre>...
impl RedHatBoyState&lt;Running&gt; {
    ...
    pub fn land_on(self, position: f32) -&gt; 
        RedHatBoyState&lt;Running&gt; {
        RedHatBoyState {
            context: self.context.set_on(position as   
                i16),
            _state: Running {},
        }
    }
}</pre>
			<p>For every <code>Land</code> event in the <code>Running</code> state, you<a id="_idIndexMarker456"/> adjust the position and stay in the <code>Running</code> state. With that, you should see RHB jump onto a platform:</p>
			<div><div><img alt="Figure 5.20 – Running on the platform&#13;&#10;" src="img/Figure_5.20_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Running on the platform</p>
			<p>Running on the platform is <a id="_idIndexMarker457"/>beginning to work, but you'll find a strange bug if you try to run past the edge of the platform. RHB falls through the bottom!</p>
			<div><div><img alt="Figure 5.21 – My God! How did I get here?" src="img/Figure_5.21_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21 – My God! How did I get here?</p>
			<p>It turns out there is a fairly sneaky<a id="_idIndexMarker458"/> bug with the way we are handling gravity, which we'll call the "terminal velocity" bug, and we can address that next.</p>
			<h3>Terminal velocity</h3>
			<p>If you log <a id="_idIndexMarker459"/>RHB's <code>velocity</code> in <em class="italic">y</em> in the <code>update</code> method as you jump on the platform and walk across it, it looks like this:</p>
			<div><div><img alt="Figure 5.22 – Gravity forever!" src="img/Figure_5.22_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22 – Gravity forever!</p>
			<p>If you recall, we add <code>1</code> to the gravity on every update until the player jumps again. This means that, eventually, the gravity gets so large that the player is pulled completely below the platform on an update, and he actually stops intersecting it. Our platform is currently at <code>400</code>. When the player<a id="_idIndexMarker460"/> lands on it, he is at <code>279</code>, the platform's <em class="italic">y-axis</em> minus the player's height. On the first frame, we pull him down by <code>1</code> for gravity, check whether that intersects the platform (it does), and land. On the next frame, we pull him down by <code>2</code>, the next by <code>3</code>, and so on. Eventually, we actually pull him completely beneath the platform, he does not intersect it, and boom –  he's suddenly below the platform. We need to fix that by giving gravity a <strong class="bold">terminal velocity</strong>.</p>
			<p>In the real-world, terminal velocity is the fastest attainable speed by an object as it falls because of the drag of the air around it (see <a href="https://go.nasa.gov/3roAWGL">https://go.nasa.gov/3roAWGL</a> for more information). We aren't going to calculate RHB's true terminal velocity, as there's no air in his world, but we can use the very scientific method of picking a number and seeing whether it works. We'll set a maximum positive <em class="italic">y</em> velocity of RHB to <code>20</code> and clamp his updates to that. That will live in the <code>RedHatBoyContext</code> <code>update</code> method, where we are already modifying <em class="italic">y</em> for gravity. The code for that is shown here:</p>
			<pre>mod red_hat_boy_states {
    ...
    const TERMINAL_VELOCITY: i16 = 20;
    ...
    impl RedHatBoyContext {
        pub fn update(mut self, frame_count: u8) -&gt; Self {
            <strong class="bold">if self.velocity.y &lt; TERMINAL_VELOCITY</strong> {
                self.velocity.y += GRAVITY;
            }
           ...</pre>
			<p>Clamping the velocity at <code>20</code> fixes our issue with falling through the platform, and now RHB falls off the platform at the end as he should. However, if you try to slide (push the arrow down), you'll see that RHB falls right through the platform. That's because the <code>Sliding</code> state doesn't respond to the <code>Land</code> event. You can fix that in the exact same way you fixed <code>Running</code>, which is an <a id="_idIndexMarker461"/>exercise for you. Give it a try, and remember that if you get stuck, the final source code is available at <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. One hint – when you stay in the same state, you don't call <code>reset_frame</code>!</p>
			<p>That's almost the end of it, but there are two more things to take care of – crashing into the bottom of the platfor<a id="_idTextAnchor134"/>m and transparency in the bounding boxes.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor135"/>Collision from below</h2>
			<p>At the moment, if RHB<a id="_idIndexMarker462"/> collides with the platform, he is set on the top, which is great for landing but not so great if he comes from beneath the platform. If you were to comment out the collision with the stone right now and run straight ahead, you'd actually find yourself suddenly pop up onto the platform! Why? Because RHB's head actually bumps into the bottom of the platform, and that collision causes the <code>land_on</code> event to fire. Instead of banging his head and falling over, he teleports onto the platform!</p>
			<p>We need to have special collision detection here. RHB can only land on the platform if he comes from above it; otherwise, it's game over. Fortunately, this can be handled in the <code>update</code> function with two small changes to the way we check collisions. Collisions with the platform where <code>RedHatBoy</code> is <em class="italic">above</em> the platform means landing; otherwise, it's the same as hitting a stone, and you <a id="_idIndexMarker463"/>get knocked out. You also need to be <em class="italic">descending</em>; otherwise, you'll get this weird effect where you stick to the platform while still going up in your jump. Let's see that change:</p>
			<pre>impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        if let WalkTheDog::Loaded(walk) = self {
            ...
            walk.boy.update();
            if walk
                .boy
                .bounding_box()
                .intersects(&amp;walk.platform.bounding_box())
            {
                <strong class="bold">if walk.boy.velocity_y() &gt; 0 &amp;&amp; walk.boy.pos_y() &lt; walk.platform.position.y</strong> {
                    walk.boy.land_on(walk.platform.bounding_box().y);
                } else {
                    <strong class="bold">walk.boy.knock_out();</strong>
                }
            }
            ...
        }
    }
}</pre>
			<p>The changes are to check whether the <code>RedHatBoy</code> velocity, in <em class="italic">y</em>, is greater than <code>0</code> and, therefore, RHB is moving down. We also check whether the position in <em class="italic">y</em> is less than the top of the platform's <em class="italic">y</em> position. This means that the boy is above the platform, so he's landing on it; otherwise, the boy<a id="_idIndexMarker464"/> has crashed into it, and we knock him out. The <code>pos_y</code> and <code>velocity_y</code> functions don't exist yet, so we'll add those to <code>RedHatBoy</code>, as shown here:</p>
			<pre>impl RedHatBoy {
    ...
    fn pos_y(&amp;self) -&gt; i16 {
        self.state_machine.context().position.y
    }
    fn velocity_y(&amp;self) -&gt; i16 {
        self.state_machine.context().velocity.y
    }
    ...
}</pre>
			<p>It's a little tricky to get the <em class="italic">y</em> values for <code>RedHatBoy</code> because they are actually on  <code>RedHatBoyContext</code>, but we are able to pull it off here and wrap them in a getter for convenience. </p>
			<p class="callout-heading">Info</p>
			<p class="callout">For the sake of the book, the code here is pretty explicit, but you can make it more expressive by extracting a method for <code>falling</code> on <code>RedHatBoy</code>. We'll leave it as it is for now, but you will want to consider some more expressive names in your own code.</p>
			<p>With that, RHB can finally run, jump over stones, land on platforms, and fall off them. However, you've probably noticed that the collisions are really crude. He crashes into the bottom of the platform easily because the transparent parts of the images collide. He also can walk past the edge<a id="_idIndexMarker465"/> of the platform, again because of the transparent parts of the image:</p>
			<div><div><img alt="Figure 5.23 – Believe it or not, I'm walking on air&#13;&#10;" src="img/Figure_5.23_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23 – Believe it or not, I'm walking on air</p>
			<p>Let's spend a little time tweaking our bounding boxes to deal with the transparency.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor136"/>Transparency in bounding boxes</h2>
			<p>The problem with our bounding boxes is that we're<a id="_idIndexMarker466"/> using the image dimensions as the bounding box. That means we'll have a lot of extra space around our characters for our bounding boxes. In this screenshot, I've used the <code>draw_rect</code> method from earlier in this chapter to show the bounding boxes for all three objects in our scene:</p>
			<div><div><img alt="Figure 5.24 – Bounding boxes everywhere&#13;&#10;" src="img/Figure_5.24_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24 – Bounding boxes everywhere</p>
			<p>The platform has a lot of white space in the bounding box, particularly at the lower-left and lower-right corners. RHB also has white space near the corners of his hat. When we turn off the collision checks on the stone and try to walk under the platform, RHB "collides" with the lower-left corner of the platform well before he actually hits it. </p>
			<p>The white space around RHB's feet is a<a id="_idIndexMarker467"/> problem too; they are what cause the landing on air effect. The far-right edge of his bounding box intersects with the platform, so he lands before he's really in the right position. If you could see him walk off the edge of the platform, you'd see that it has the same problem when he walks off. He takes several steps in mid-air before he begins to fall. </p>
			<p>We'll start by dealing with RHB's bounding box to make landing and falling off the platform look a little more realistic.</p>
			<h3>Fixing the game to fit</h3>
			<p>There are<a id="_idIndexMarker468"/> algorithms we can use to make the bounding box better match the actual pixels in the image, but ultimately, none of them are necessary. Spend a little time with most platformers and you'll see that the collisions aren't perfect, and 99% of the time, it's just fine. After spending a little time "researching" by playing video games, I determined that if we simply make the box only as wide as the feet, he develops a much more realistic landing. This is a little counter-intuitive. If we narrow<a id="_idIndexMarker469"/> the box, his arm and hat will stick out past the edge of the box; we'll miss collisions! Does this matter?</p>
			<div><div><img alt="Figure 5.25 – A narrow bounding box" src="img/Figure_5.25_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25 – A narrow bounding box</p>
			<p>The answer is, "maybe." Bounding boxes and collision detection are not just mathematical problems. They are also game design problems. Making the bounding box wrap just around the feet felt right to me when playing the game. Maybe when you play it, that will feel too hard when you land on a platform or the hand not colliding will bother you, so change the box! It's not written in stone. </p>
			<p>After experimenting, I found that I wanted to shorten the box as well so that RHB couldn't be knocked out by grazing his hat. To mimic that, we can start by renaming <code>bounding_box</code> <code>destination_box</code>, because that represents where the sprite is rendered <em class="italic">to</em>. It needs to be at the position of <code>RedHatBoy</code> in the game but with the width and height of the source image; otherwise, the image will appear squished. Then, we can re-implement the <code>RedHatBoy</code> bounding box, like so:</p>
			<pre>impl RedHatBoy {
    ...
    fn bounding_box(&amp;self) -&gt; Rect {
        const X_OFFSET: f32 = 18.0;
        const Y_OFFSET: f32 = 14.0;
        const WIDTH_OFFSET: f32 = 28.0;
        let mut bounding_box =<strong class="bold"> self.destination_box();</strong>
        bounding_box.x += X_OFFSET;
        bounding_box.width -= WIDTH_OFFSET;
        bounding_box.y += Y_OFFSET;
        bounding_box.height -= Y_OFFSET;
        bounding_box
    }</pre>
			<p>We start with the original <a id="_idIndexMarker470"/>dimensions of the image, <code>destination_box</code>, and simply shrink it by some offsets. I chose the numbers by using the high-tech system of picking numbers and looking at them. This gave me a bounding box that looked natural jumping and falling off the cliff while not being so small that RHB never hits anything. </p>
			<p>If you did a global find and replace on <code>bounding_box</code> and changed it to <code>destination_box</code>, then the collision detection is incorrect. We need to use <code>bounding_box</code> for checking collisions and <code>destination_box</code> for drawing. Drawing should already be complete; you'll need to go into the <code>update</code> method in <code>WalkTheDog</code> and make sure that every <code>intersects</code> call is on the <code>bounding_box</code>, not <code>destination_box</code>. </p>
			<p>With the new <code>bounding_box</code> method and a properly drawn image, you get a bounding box that looks like this for RHB:</p>
			<div><div><img alt="Figure 5.26 – A tight-fit bounding box" src="img/Figure_5.26_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26 – A tight-fit bounding box</p>
			<p>You can see that it's a lot smaller than the image, which makes the game look better and play a little more forgiving. He lands on and falls off the platform much more accurately, without a hovering effect. You also might find it easier to jump the stone now because the transparent part of RHB doesn't crash into the rock. </p>
			<p>That leaves us with the white<a id="_idIndexMarker471"/> space around the edges of the platform. We can shrink the bounding box for it, but that would cause the player to fall through the top of the platform when he lands on the edges. The platform is narrower on the bottom than the top, which is a problem because we crash into the bottom and land on the top. What we really want to do is take the platform and make it into multiple bounding boxes.</p>
			<h3>Subdividing bounding boxes</h3>
			<p>Subdividing the bounding <a id="_idIndexMarker472"/>boxes is just like it sounds – we're going to take the one bounding box that is currently used for the platform and divide it into several. This will dramatically reduce the amount of extra space in the boxes and improve our collision detection. You might think that we'll use a complex algorithm or tool to determine what boxes to use, and we will – it's our eyeballs. </p>
			<p>Specifically, we'll look at the platform, see the white space, and then try out a few versions of the bounding boxes divided up until we find a solution we like. We can begin that process by making it possible for <code>Platform</code> to have more than one bounding box. We'll do that by, again, renaming <code>bounding_box</code>  to <code>destination_box</code> and then creating a new method to construct a vector of <code>bounding_boxes</code> from that original box, as shown here:</p>
			<pre>impl Platform {
    fn bounding_boxes(&amp;self) -&gt; Vec&lt;Rect&gt; {
        const X_OFFSET: f32 = 60.0;
        const END_HEIGHT: f32 = 54.0;
        let destination_box = self.destination_box();
        let bounding_box_one = Rect {
            x: destination_box.x,
            y: destination_box.y,
            width: X_OFFSET,
            height: END_HEIGHT,
        };
        let bounding_box_two = Rect {
            x: destination_box.x + X_OFFSET,
            y: destination_box.y,
            width: destination_box.width - (X_OFFSET * 
                2.0),
            height: destination_box.height,
        };
        let bounding_box_three = Rect {
            x: destination_box.x + destination_box.width – 
                X_OFFSET,
            y: destination_box.y,
            width: X_OFFSET,
            height: END_HEIGHT,
        };
        vec![bounding_box_one, bounding_box_two,  
            bounding_box_three]
    }</pre>
			<p>In this method, we create three<a id="_idIndexMarker473"/> Rects, each meant to match the platform, starting from the destination box of the platform. It's two small rectangles on the edges and one bigger one in the middle. When we draw those boxes, it looks like this:</p>
			<div><div><img alt="Figure 5.27 – Platform bounding boxes&#13;&#10;" src="img/Figure_5.27_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.27 – Platform bounding boxes</p>
			<p>That's a lot less white space that you can collide with. You might wonder where the values for <code>X_OFFSET</code> and <code>END_HEIGHT</code> came from, and the truth is that I just drew the boxes and looked at them until I was happy. It's not fancy; it's just good enough.</p>
			<p>Now that we're<a id="_idIndexMarker474"/> using a vector of bounding boxes instead of just one, we'll need to change the logic in the <code>update</code> method of <code>WalkTheDog</code> to make sure that RHB can collide with any of the boxes and make the code compile. That code is reproduced here:</p>
			<pre>#[async_trait(?Send)]
impl Game for WalkTheDog {
    ...
    fn update(&amp;mut self, keystate: &amp;KeyState) {
        ...
        <strong class="bold">for bounding_box in &amp;walk.platform.bounding_boxes() {</strong>
            if walk.boy.bounding_box()
                .intersects(bounding_box) {
                if walk.boy.velocity_y() &gt; 0 &amp;&amp; 
                    walk.boy.pos_y() &lt; 
                        walk.platform.position.y {
                    walk.boy.land_on(bounding_box.y);
                    } else {
                        walk.boy.knock_out();
                    }
                }
            }
           ...
        }
    }</pre>
			<p>The change here is to loop through all the bounding boxes and check for a collision on any box. There are only three boxes here, so we're not worried about checking all three every time. If the computer can't count to three, you probably need a new computer.</p>
			<p>If you temporarily <a id="_idIndexMarker475"/>comment out collisions with the stone again, you'll see that you can just barely walk underneath the platform:</p>
			<div><div><img alt="Figure 5.28 – Just short enough&#13;&#10;" src="img/Figure_5.28_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 5.28 – Just short enough</p>
			<p>At this point, you might wonder whether this should be a collision. After all, his hat does kind of scrape the bottom of the platform. It might be hard for the player to tell if they will fit under the the platform. Can we find a workaround for this?</p>
			<h3>Game design through constants</h3>
			<p>As we've gone through this section, we've been introducing more and more constants for values such as <code>FLOOR</code> and <code>PLAYER_HEIGHT</code>. Most of the time, we treat magic numbers as "bad" in code because they lead to duplication and bugs. That's true, but for most of the numbers we've <a id="_idIndexMarker476"/>been using, we haven't had duplication. No, in this situation, we can use constants to both clarify what the numbers mean and use those for game design. We can then use game design to hide little quirks, such as our platform being at a height that barely clears the player. </p>
			<p>We used <code>Point { x: 200, y: 400 }</code> as the location of <code>Platform</code> when we originally created it. Those were magic numbers – sorry about that. We actually know that the <em class="italic">y</em> value of <code>400</code> positions the platform at a pretty confusing location. If <em class="italic">y</em> was <code>370</code>, then you would need to go under it, and if it's <code>420</code>, you need to go over it. We can create two constants for that and set up the position. That change is shown here:</p>
			<pre><strong class="bold">const LOW_PLATFORM: i16 = 420;</strong>
<strong class="bold">const HIGH_PLATFORM: i16 = 375;</strong>
#[async_trait(?Send)]
impl Game for WalkTheDog {
    async fn initialize(&amp;self) -&gt; Result&lt;Box&lt;dyn Game&gt;&gt; {
        match self {
            WalkTheDog::Loading =&gt; {
                ...
                let platform = Platform::new(
                    platform_sheet.into_serde::&lt;Sheet&gt;()?,
                    engine::load_image("tiles.png").await?,
                    Point {
                        x: 370,
                        <strong class="bold">y: LOW_PLATFORM,</strong>
                    },
                );</pre>
			<div><div><img alt="Figure 5.29 – You're not gonna make it!" src="img/Figure_5.29_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.29 – You're not gonna make it!</p>
			<p>You might notice that the <a id="_idIndexMarker477"/>platform is a little to the right in this screenshot. I wanted to be able to jump over the rock and then jump onto the platform. It's impossible to do that with the way we constructed it originally, so I moved the platform to the right. I created a constant named <code>FIRST_PLATFORM</code> for the <em class="italic">x</em> location of the platform, set it to <code>370</code>, and then set the <em class="italic">x</em> position of <code>Platform</code> to that. </p>
			<p>I also found it nearly impossible to actually just jump the stone with the user's combination of speed and gravity. Even after narrowing RHB's collision box, he jumps high but not very far. Fortunately, that was very tweakable with constants – by simply upping <code>RUNNING_SPEED</code> from <code>3</code> to <code>4</code>, he moved quickly enough to make jumping the rock easy.</p>
			<p>As we're designing our endless runner, we're going to find that we can hide any imperfections in collisions through game design. You'll constantly need to tweak values such as the speed of the player, bounding box heights, and obstacle locations. The more of the game you can encode into constants, the easier that will be.</p>
			<h3>A quick challenge</h3>
			<p>When we wrote the code to cause RHB to get knocked out if he jumps from below the platform, we introduced a bug seen here:</p>
			<div><div><img alt="Figure 5.30 – How did he get there?&#13;&#10;" src="img/Figure_5.30_B17151.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.30 – How did he get there?</p>
			<p>What's happening is that when RHB collides with the bottom of the platform, he transitions into the <code>Falling</code> state, but he doesn't change his velocity, so he continues the jump. Then, gravity <a id="_idIndexMarker478"/>stops being applied to RHB in the <code>KnockedOut</code> state. Your challenge is to fix this defect. You'll need to modify the states to reflect those changes. Give it a try before you check <a href="https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5">https://github.com/PacktPublishing/Game-Development-with-Rust-and-WebAssembly/tree/chapter_5</a>. T<a id="_idTextAnchor137"/>he changes are small and all in the existing code.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we made <code>WalkTheDog</code> more closely resemble a game by making RHB run into obstacles and jump onto platforms. We did all of this with axis-aligned bounding boxes and in a scene that looks like a real game, with a background, instead of an empty void. We also dealt with some quirks for dealing with trimmed sprite sheets, properly handled bounding boxes, and utilized the state machine we built in <a href="B17151_04_Final_PG_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing Animations with State Machines</em>, to handle the new animations and manage the state of <code>RedHatBoy</code>. </p>
			<p>We also learned how collisions are more than just drawing a box around an image. Yes, it's the math behind intersecting boxes, but it's also checking to see whether the player is landing or crashing into the platform. We debugged our collision boxes with rectangles and used those rectangles to make a better fitting box. We even subdivided one image into multiple collision boxes!</p>
			<p>This chapter was big, we did a lot, and I encourage you to fiddle with and tweak the code as you see fit. Have RHB jump lower, or higher, or have him move more slowly. Try making the bounding boxes smaller so that it's easier to jump over the stone or put the stone on the platform. Use your imagination!</p>
			<p>All in all, we've set up the game so that it's ready to become an endless runner, with randomly generated terrain and a convincing scroll from left to right. We'll develop that in the next chapter.</p>
		</div>
	</body></html>