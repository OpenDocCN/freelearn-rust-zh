<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Conditions, Recursion, and Loops</h1>
                
            
            <article>
                
<p class="calibre1">Loops and conditions within any programming language are a fundamental aspect of operation. You may be looping around a list attempting to find when something matches, and when a match occurs, branching out to perform some other task; or, you may just want to check a value to see whether it meets a condition. In any case, Rust allows you to do this.</p>
<p class="calibre1">In this chapter, we will cover the following topics:</p>
<ul class="calibre12">
<li class="calibre13">Types of loop available</li>
<li class="calibre13">Different types of branching within loops</li>
<li class="calibre13">Recursive methods</li>
<li class="calibre13">When the semicolon (<kbd class="calibre10">;</kbd>) can be omitted and what it means</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Loops</h1>
                
            
            <article>
                
<p class="calibre1">Rust has essentially three types of loops:</p>
<ul class="calibre12">
<li class="calibre13"><kbd class="calibre10">loop</kbd> is the simplest one—it just goes through a block of code again and again until one of the loop-breaking keywords is used</li>
<li class="calibre13"><kbd class="calibre10">while</kbd> is like loop, but with a condition—the block of code is looped again and again as long as the condition is true</li>
<li class="calibre13"><kbd class="calibre10">for</kbd> is different from the above two—it is for iterating through sequences</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The for loop</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">for</kbd> loops are slightly different from the same construct in C-like languages. In C, the <kbd class="calibre10">for</kbd> loops consist of three things: an initialization, a stopping condition, and a stepping instruction. Rust <kbd class="calibre10">for</kbd> loops are a bit higher-level though: they are for iterating through sequences.</p>
<p class="calibre1">Let's take a simple example to start with—a loop that goes from 0 to 10 and outputs the value:</p>
<pre class="calibre21">for x in 0..10 
{ 
    println!("{},", x); 
} </pre>
<p class="calibre1">We create a variable <kbd class="calibre10">x</kbd> that takes an element from the range (<kbd class="calibre10">0..10</kbd>), one by one, and does something with it. In Rust terminology, <kbd class="calibre10">0..10</kbd> is not only a variable but also an <strong class="calibre8">iterator</strong>, as it gives back a value from a series of elements.</p>
<p class="calibre1">This is obviously a very simple example. We can also define the iterator to work in the opposite direction. In C, you will expect something akin to <kbd class="calibre10">for (i = 10; i &gt; 0; --i)</kbd>. In Rust, we use the <kbd class="calibre10">rev()</kbd> method to reverse the iterator, as follows:</p>
<pre class="calibre21">for x in (0..10).rev() 
{ 
    println!("{},", x); 
}  </pre>
<p class="calibre1">It is worth noting that the range excludes the last number. So, for the previous example, the values outputted are <kbd class="calibre10">9</kbd> to <kbd class="calibre10">0</kbd>; essentially, the program generates the output values from 0 to 10 and then outputs them in reverse.</p>
<p class="calibre1">The general syntax for the <kbd class="calibre10">for</kbd> loops is as follows:</p>
<pre class="calibre21"><span>for var in sequence<br class="calibre2"/></span>{ 
    // do something 
}   </pre>
<p class="calibre1">The C# equivalent for the preceding code is as follows:</p>
<pre class="calibre21">foreach(var t in conditionsequence) 
     // do something  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using enumerate</h1>
                
            
            <article>
                
<p class="calibre1">A <kbd class="calibre10">loop</kbd> condition can also be more complex, using multiple conditions and variables. For example, the <kbd class="calibre10">for</kbd> loop can be tracked using <kbd class="calibre10">enumerate</kbd>. This will keep track of how many times the loop has executed, as shown here:</p>
<pre class="calibre21">for(i, j) in (10..20).enumerate() 
{ 
     println!("loop has executed {} times. j = {}", i, j); 
} </pre>
<p class="calibre1">The following is the output:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00029.jpeg"/></div>
<p class="calibre1">Say we have an array that we need to iterate over to obtain the values. Here, the <kbd class="calibre10">enumerate</kbd> method can be used to obtain the value of the array members. The value returned in the condition will be a reference, so a code such as the one shown in the following example will fail to execute (<kbd class="calibre10">line</kbd> is a <kbd class="calibre10">&amp;</kbd> reference whereas an <kbd class="calibre10">i32</kbd> is expected):</p>
<pre class="calibre21">// 04/enumerate/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array: [i32; 7] = [1i32,3,5,7,9,11,13]; 
    let mut value = 0i32; 
    for(_, line) in my_array.iter().enumerate() 
    { 
       value += line; 
    } 
    println!("{}", value); 
} </pre>
<p class="calibre1">This can be simply converted back from the reference value, as follows:</p>
<pre class="calibre21">for(_, line) in my_array.iter().enumerate() 
    { 
       value += *line; 
    } </pre>
<p class="calibre1">The <kbd class="calibre10">iter().enumerate()</kbd> method can equally be used with the <kbd class="calibre10">Vec</kbd> type (or any other type that implements the iterator trait), as shown in the following code:</p>
<pre class="calibre21">// 04/arrayloop/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array = vec![1i32,3,5,7,9,11,13]; 
    let mut value = 0i32; 
 
    for(_,line) in my_array.iter().enumerate() 
    { 
       value += *line; 
    } 
    println!("{}", value); 
} 
 </pre>
<p class="calibre1">In both cases, the value given at the end will be <kbd class="calibre10">49</kbd>, as shown in the following screenshot:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00030.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The _ parameter</h1>
                
            
            <article>
                
<p class="calibre1">You may be wondering what the <kbd class="calibre10">_</kbd> parameter is. In Rust, it is often not allowed to omit variable bindings even if we don't use them. We can use <kbd class="calibre10">_</kbd> to signify that we know that this place needs a variable binding, but we are never going to use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The simple loop</h1>
                
            
            <article>
                
<p class="calibre1">A simple form of the loop is called <kbd class="calibre10">loop</kbd>:</p>
<pre class="calibre21">loop 
{ 
    println!("Hello"); 
} </pre>
<p class="calibre1">The preceding code has no loop-ending keywords, such as break; it will output <kbd class="calibre10">Hello</kbd> until the application is terminated manually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The while condition</h1>
                
            
            <article>
                
<p class="calibre1">The <kbd class="calibre10">while</kbd> condition extends the loop with a condition, as you will see in the following code snippet:</p>
<pre class="calibre21">while (condition) 
{ 
    // do something 
} </pre>
<p class="calibre1">Let's take a look at the following example:</p>
<pre class="calibre21">fn main() { 
    let mut done = 0u32; 
    while done != 32 
    { 
        println!("done = {}", done); 
        done += 1; 
    } 
} </pre>
<p class="calibre1">The preceding code will output <kbd class="calibre10">done = 0</kbd> to <kbd class="calibre10">done = 31</kbd>. The loop terminates when <kbd class="calibre10">done</kbd> equals <kbd class="calibre10">32</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Prematurely terminating a loop</h1>
                
            
            <article>
                
<p class="calibre1">Depending on the size of the data being iterated over within a loop, the loop can be costly on processor time. For example, say the server is receiving data from a data-logging application, such as measuring values from a gas chromatograph; over the entire scan, it may record roughly half a million data points with an associated time position.</p>
<p class="calibre1">For our purposes, we want to add all of the recorded values until the value is over 1.5 and once that is reached, we can stop the loop.</p>
<p class="calibre1">Sound easy? There is one thing not mentioned: there is no guarantee that the recorded value will ever reach over 1.5, so how can we terminate the loop if the value is reached?</p>
<p class="calibre1">We can do this in one of two ways. The first is to use a <kbd class="calibre10">while</kbd> loop and introduce a Boolean to act as the test condition. In the following example, <kbd class="calibre10">my_array</kbd> represents a very small subsection of the data sent to the server:</p>
<pre class="calibre21">// 04/terminate-loop-1/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array = vec![0.6f32, 0.4, 0.2, 0.8, 1.3, 1.1, 1.7, 1.9]; 
    let mut counter: usize = 0; 
    let mut result = 0f32; 
    let mut quit = false; 
 
    while quit != true 
    { 
        if my_array[counter] &gt; 1.5 
        { 
            quit = true; 
        } 
        else 
        { 
            result += my_array[counter]; 
            counter += 1; 
        } 
    } 
     println!("{}", result); 
} </pre>
<p class="calibre1">The result here is <kbd class="calibre10">4.4</kbd>. This code is perfectly acceptable, if slightly long-winded. Rust also allows the use of the <kbd class="calibre10">break</kbd> and <kbd class="calibre10">continue</kbd> keywords (if you're familiar with C, they work in the same way).</p>
<p class="calibre1">Our code using <kbd class="calibre10">break</kbd> will be as follows:</p>
<pre class="calibre21">// 04/terminate-loop-2/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array = vec![0.6f32, 0.4, 0.2, 0.8, 1.3, 1.1, 1.7, 1.9]; 
    let mut result = 0f32; 
 
    for(_, value) in my_array.iter().enumerate() 
    { 
       if *value &gt; 1.5 
       { 
           break; 
       } 
       else 
       { 
           result += *value; 
       } 
    } 
    println!("{}", result); 
} </pre>
<p class="calibre1">Again, this will give an answer of <kbd class="calibre10">4.4</kbd>, indicating that the two methods used are equivalent.</p>
<p class="calibre1">If we replace <kbd class="calibre10">break</kbd> with <kbd class="calibre10">continue</kbd> in the preceding code example, we will get the same result (<kbd class="calibre10">4.4</kbd>). The difference between <kbd class="calibre10">break</kbd> and <kbd class="calibre10">continue</kbd> is that <kbd class="calibre10">continue</kbd> jumps to the next value in the iteration rather than jumping out, so if we had the final value of <kbd class="calibre10">my_array</kbd> as <kbd class="calibre10">1.3</kbd>, the output at the end should be <kbd class="calibre10">5.7</kbd>.</p>
<div class="packt_tip">When using <kbd class="calibre22">break</kbd> and <kbd class="calibre22">continue</kbd>, always keep in mind this difference. While it may not crash the code, mistaking <kbd class="calibre22">break</kbd> and <kbd class="calibre22">continue</kbd> may lead to results that you may not expect or want.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using loop labels</h1>
                
            
            <article>
                
<p class="calibre1">Rust allows us to label our loops. This can be very useful, for example with nested loops. These labels act as symbolic names for the loop and as we have a name for the loop, we can instruct the application to perform a task on that name.</p>
<p class="calibre1">Consider the following simple example:</p>
<pre class="calibre21">// 04/looplabels/src/main.rs<br class="calibre2"/>fn main()  
{ 
    'outer_loop: for x in 0..10  
    { 
        'inner_loop: for y in 0..10  
        { 
            if x % 2 == 0 { continue 'outer_loop; }  
            if y % 2 == 0 { continue 'inner_loop; } 
            println!("x: {}, y: {}", x, y); 
        } 
    } 
} </pre>
<p class="calibre1">What will this code do?</p>
<p class="calibre1">Here, <kbd class="calibre10">x % 2 == 0</kbd> (or <kbd class="calibre10">y % 2 == 0</kbd>) means that if a variable divided by two returns no remainder, then the condition is met and it executes the code in the braces. When <kbd class="calibre10">x % 2 == 0</kbd>, or when the value of the loop is an even number, we will tell the application to skip to the next iteration of <kbd class="calibre10">outer_loop</kbd>, which is an odd number. However, we will also have an inner loop. Again, when <kbd class="calibre10">y % 2</kbd> is an even value, we will tell the application to skip to the next iteration of <kbd class="calibre10">inner_loop</kbd>.</p>
<p class="calibre1">In this case, the application will output the following results:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00031.jpeg"/></div>
<p class="calibre1">While this example may seem very simple, it does allow for a great deal of speed when checking data. Let's go back to our previous example of data being sent to the web service. Recall that we have two values—the recorded data and some other value; for ease, it will be a data point. Each data point is recorded 0.2 seconds apart; therefore, every fifth data point is one second.</p>
<p class="calibre1">This time, we want all of the values where the data is greater than 1.5 and the associated time of that data point, but only on a time when it's dead on a second. As we want the code to be understandable and human-readable, we can use a loop label on each loop.</p>
<p class="calibre1">The following code is not quite correct. Can you spot why? The code compiles as follows:</p>
<pre class="calibre21">// 04/looplabels-2/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array = vec![0.6f32, 0.4, 0.2, 0.8, 1.3, 1.1, 1.7, 1.9, 1.3, 0.1, 1.6, 0.6, 0.9, 1.1, 1.31, 1.49, 1.5, 0.7]; 
    let my_time = vec![0.2f32, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8]; 
 
    'time_loop: for(_, time_value) in my_time.iter().enumerate() 
    { 
       'data_loop: for(_, value) in my_array.iter().enumerate() 
       { 
           if *value &lt; 1.5 
           { 
               continue 'data_loop; 
           } 
           if *time_value % 5f32 == 0f32 
           { 
               continue 'time_loop; 
           } 
           println!("Data point = {} at time {}s", *value, *time_value); 
       } 
    } 
} </pre>
<p class="calibre1">This example is a very good one to demonstrate the correct operator in use. The issue is the <kbd class="calibre10">if *time_value % 5f32 == 0f32</kbd> line. We are taking a float value and using the modulus of another float to see whether we end up with 0 as a float.</p>
<p class="calibre1">Comparing any value that is not a <kbd class="calibre10">string</kbd>, <kbd class="calibre10">int</kbd>, <kbd class="calibre10">long</kbd>, or <kbd class="calibre10">bool</kbd> type to another is never a good plan, especially if the value is returned by some form of calculation. We can also not simply use <kbd class="calibre10">continue</kbd> on the time loop, so how can we solve this problem?</p>
<p class="calibre1">If you recall, we're using <kbd class="calibre10">_</kbd> instead of a named parameter for the enumeration of the loop. These values are always an integer; therefore, if we replace <kbd class="calibre10">_</kbd> for a variable name, then we can use <kbd class="calibre10">% 5</kbd> to perform the calculation and the code becomes the following:</p>
<pre class="calibre21">'time_loop: for(time_enum, time_value) in my_time.iter().enumerate() 
    { 
       'data_loop: for(_, value) in my_array.iter().enumerate() 
       { 
           if *value &lt; 1.5 
           { 
               continue 'data_loop; 
           } 
           if time_enum % 5 == 0 
           { 
               continue 'time_loop; 
           } 
           println!("Data point = {} at time {}s", *value, *time_value); 
       } 
    } 
 </pre>
<p class="calibre1">The next problem is that the output isn't correct. The code gives the following:</p>
<pre class="calibre21">Data point = 1.7 at time 0.4s 
Data point = 1.9 at time 0.4s 
Data point = 1.6 at time 0.4s 
Data point = 1.5 at time 0.4s 
Data point = 1.7 at time 0.6s 
Data point = 1.9 at time 0.6s 
Data point = 1.6 at time 0.6s 
Data point = 1.5 at time 0.6s </pre>
<p class="calibre1">The data point is correct, but the time is way out and continually repeats. We still need the <kbd class="calibre10">continue</kbd> statement for the data point step, but the time step is incorrect. There are a couple of solutions, but possibly the simplest will be to store the data and the time in a new vector and then display that data at the end.</p>
<p class="calibre1">The following code gets closer to what is required:</p>
<pre class="calibre21">// 04/looplabels-3/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array = vec![0.6f32, 0.4, 0.2, 0.8, 1.3, 1.1, 1.7, 1.9, 1.3, 0.1, 1.6, 0.6, 0.9, 1.1, 1.31, 1.49, 1.5, 0.7]; 
    let my_time = vec![0.2f32, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8]; 
    let mut my_new_array = vec![]; 
    let mut my_new_time = vec![]; 
 
    'time_loop: for(t, _) in my_time.iter().enumerate() 
    { 
       'data_loop: for(v, value) in my_array.iter().enumerate() 
       { 
           if *value &lt; 1.5 
           { 
               continue 'data_loop; 
           } 
           else 
           { 
               if t % 5 != 0 
               { 
                    my_new_array.push(*value); 
                    my_new_time.push(my_time[v]); 
               }        
           } 
        
           if v == my_array.len() 
           { 
               break; 
           } 
       } 
    } 
     
    for(m, my_data) in my_new_array.iter().enumerate() 
    { 
        println!("Data = {} at time {}", *my_data, my_new_time[m]); 
    } 
} 
 </pre>
<p class="calibre1">We will now get the following output:</p>
<pre class="calibre21">Data = 1.7 at time 1.4 
Data = 1.9 at time 1.6 
Data = 1.6 at time 2.2 
Data = 1.5 at time 3.4 
Data = 1.7 at time 1.4 </pre>
<p class="calibre1">Yes, we now have the correct data, but the time starts again. We're close, but it's not right yet. We aren't continuing the <kbd class="calibre10">time_loop</kbd> loop and we will also need to introduce a <kbd class="calibre10">break</kbd> statement. To trigger the <kbd class="calibre10">break</kbd>, we will create a new variable called <kbd class="calibre10">done</kbd>. When <kbd class="calibre10">v</kbd>, the enumerator for <kbd class="calibre10">my_array</kbd>, reaches the length of the vector (this is the number of elements in the vector), we will change this from <kbd class="calibre10">false</kbd> to <kbd class="calibre10">true</kbd>. This is then tested outside of the <kbd class="calibre10">data_loop</kbd>. If <kbd class="calibre10">done == true</kbd>, break out of the loop.</p>
<p class="calibre1">The final version of the code is as follows:</p>
<pre class="calibre21">// 04/dataloop/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let my_array = vec![0.6f32, 0.4, 0.2, 0.8, 1.3, 1.1, 1.7, 1.9, 1.3, 0.1, 1.6, 0.6, 0.9, 1.1, 1.31, 1.49, 1.5, 0.7]; 
    let my_time = vec![0.2f32, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6]; 
    let mut my_new_array = vec![]; 
    let mut my_new_time = vec![]; 
    let mut done = false; 
 
    'time_loop: for(t, _) in my_time.iter().enumerate() 
    { 
       'data_loop: for(v, value) in my_array.iter().enumerate() 
       {  
           if v == my_array.len() - 1 
           { 
               done = true; 
           } 
        
           if *value &lt; 1.5 
           { 
               continue 'data_loop; 
           } 
           else 
           { 
                if t % 5 != 0 
                { 
                    my_new_array.push(*value); 
                    my_new_time.push(my_time[v]); 
                } 
                else 
                { 
                    continue 'time_loop; 
                } 
           } 
       } 
       if done {break;} 
    } 
     
    for(m, my_data) in my_new_array.iter().enumerate() 
    { 
        println!("Data = {} at time {}", *my_data, my_new_time[m]); 
    } 
} </pre>
<p class="calibre1">Our final output from the code is this:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00032.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Recursive functions</h1>
                
            
            <article>
                
<p class="calibre1">The final form of loop to consider is known as a <strong class="calibre8">recursive function</strong>. This is a function that calls itself until a condition is met. In pseudocode, the function looks like this:</p>
<pre class="calibre21">float my_function(i32:a: i32) 
{ 
    // do something with a 
    if (a != 32) 
    { 
        my_function(a); 
    } 
    else 
    { 
        return a; 
    } 
} 
 </pre>
<p class="calibre1">An actual implementation of a recursive function would look like this:</p>
<pre class="calibre21">// 04/recurse-1/src/main.rs<br class="calibre2"/>fn recurse(n: i32)  
{ 
     let v = match n % 2  
     { 
         0 =&gt; n / 2, 
         _ =&gt; 3 * n + 1 
     }; 
     println!("{}", v); 
   
     if v != 1  
     {  
         recurse(v)  
     } 
} 
 
fn main()  
{  
     recurse(25)  
} 
 </pre>
<p class="calibre1">The idea of a recursive function is very simple, but we need to consider two parts of this code. The first is the <kbd class="calibre10">let</kbd> line in the <kbd class="calibre10">recurse</kbd> function and what it means:</p>
<pre class="calibre21">let v = match n % 2  
     { 
         0 =&gt; n / 2, 
         _ =&gt; 3 * n + 1 
     }; </pre>
<p class="calibre1">Another way of writing this is as follows:</p>
<pre class="calibre21">let mut v = 0i32; 
if n % 2 == 0 
{ 
     v = n / 2; 
} 
else 
{ 
     v = 3 * n + 1; 
} </pre>
<p class="calibre1">The second part is that the semicolon is not being used everywhere. Consider the following example:</p>
<pre class="calibre21">fn main()  
{  
     recurse(25)  
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is the difference between having and not having a semicolon?</h1>
                
            
            <article>
                
<p class="calibre1">In Rust, almost everything is an expression. This means that almost everything returns a value. One exception is the variable binding statement <kbd class="calibre10">let</kbd>. In a <kbd class="calibre10">let</kbd> statement, and many others, the ending semicolon is a mandatory part of the syntax.</p>
<p class="calibre1">However, in expressions, the semicolon has a double role: it throws away a return value of the expression in addition to allowing further expressions. So if the expression is the last in a block, having a semicolon there means that the last value is thrown away, and not having a semicolon there means to return the last value.</p>
<p class="calibre1">An example should make it clear:</p>
<pre class="calibre21">// 04/semicolon_block/src/main.rs<br class="calibre2"/>fn main()  
{ 
    let x = 5u32; 
 
    let y =  
    { 
        let x_squared = x * x; 
        let x_cube = x_squared * x; 
        x_cube + x_squared + x 
    }; 
 
    let z =  
    { 
        2 * x; 
    }; 
 
    println!("x is {:?}", x); 
    println!("y is {:?}", y); 
    println!("z is {:?}", z); 
} </pre>
<p class="calibre1">We have two different uses of the semicolon. Let's look at the <kbd class="calibre10">let y</kbd> line first:</p>
<pre class="calibre21">let y =  
    { 
        let x_squared = x * x; 
        let x_cube = x_squared * x; 
        x_cube + x_squared + x // no semi-colon 
    }; </pre>
<p class="calibre1">This code does the following:</p>
<ul class="calibre12">
<li class="calibre13">The code within the braces is processed</li>
<li class="calibre13">The final line, without the semicolon, is assigned to <kbd class="calibre10">y</kbd></li>
</ul>
<p class="calibre1">Essentially, this is considered as an inline function that returns the line without the semicolon into the variable.</p>
<p class="calibre1">The second line to consider is for <kbd class="calibre10">z</kbd>:</p>
<pre class="calibre21">    let z =  
    { 
        2 * x; 
    }; </pre>
<p class="calibre1">Again, the code within the braces is evaluated. In this case, the line ends with a semicolon, so the result is thrown away and the empty value <kbd class="calibre10">()</kbd> gets bound to <kbd class="calibre10">z</kbd>.</p>
<p class="calibre1">When it is executed, we will get the following results:</p>
<div class="cdpaligncenter"><img class="image-border6" src="../images/00033.jpeg"/></div>
<p class="calibre1">In the code example, the line within <kbd class="calibre10">fn main</kbd> calling <kbd class="calibre10">recurse</kbd> gives the same result with or without the semicolon, because the Rust runtime doesn't use <kbd class="calibre10">main</kbd>'s return value for anything.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre1">In this chapter, we've covered the different types of loops that are available within Rust, as well as gained an understanding of when to use a semicolon and what it means to omit it. We have also considered enumeration and iteration over a vector and an array and how to handle the data held within them.</p>
<p class="calibre1">In the next chapter, we will see why Rust is a good choice for server applications: memory handling.</p>


            </article>

            
        </section>
    </body></html>