<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Basics of Rust</h1>
                
            
            
                
<p class="calibre3">This chapter introduces you to the basics of Rust, a systems programming language designed to be secure and fast. Rust is a good candidate to write concurrent software and it helps to prevent bugs. After reading this chapter, you'll be ready to code cool projects in the subsequent chapters. After learning about the language itself, you'll install its compiler and package manager, and you'll start programming right away. You'll also learn about the following concepts:</p>
<ul class="calibre10">
<li class="calibre11">Variables</li>
<li class="calibre11">Built-in data types</li>
<li class="calibre11">Control flow (conditions and loops)</li>
<li class="calibre11">Functions</li>
<li class="calibre11">Custom data types</li>
<li class="calibre11">References</li>
<li class="calibre11">Pattern matching</li>
<li class="calibre11">Traits and Generics</li>
<li class="calibre11">Arrays and Slices</li>
<li class="calibre11">Macros</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Getting to know Rust</h1>
                
            
            
                
<p class="calibre3">Rust is a system programming language developed by Mozilla, whose version 1.0 appeared in 2015. A system language means that you have control over the memory used by the program—you decide whether you want to allocate the memory on the stack or the heap, and when the memory is freed. But don't worry; in Rust, the compiler is very helpful and prevents you from making the many mistakes you can make in C and C++ that lead to segmentation faults. A segmentation fault arises when the programmer tries to access some memory that is not accessible to its process. Memory unsafety leads to bugs and security flaws.</p>
<p class="calibre3">Moreover, the compiler is smart enough to know where to insert the memory deallocation instructions so that you don't need to manually free your memory, all of that without a garbage collector, which is one of its greatest features. Since Rust is safe and fast, it is the perfect candidate for writing operating systems, embedded programs, servers, and games, but you can also use it to develop desktop applications and websites. A great example of this power is the <a href="https://servo.org/" class="calibre13">Servo web engine</a>, also developed by Mozilla.</p>
<p class="calibre3">Rust is multi-paradigm: it can be used in an imperative or functional way and you can even write concurrent applications safely. It is statically typed, meaning that every type must be known at compile time, but since it uses type inference, we can omit the type for most local variables. It is also strongly typed, which means that its type system prevents the programmer from some kinds of errors, such as using the wrong type for a function parameter. And Rust is very good at writing concurrent software because it prevents data races, which is concurrent access to a variable where one is a write; this is an undefined behavior in other languages. One thing to remember when reading this book is that Rust prevents you from shooting yourself in the foot. For instance, Rust doesn't have:</p>
<ul class="calibre10">
<li class="calibre11">null pointers</li>
<li class="calibre11">data races</li>
<li class="calibre11">use after free</li>
<li class="calibre11">use before initialization</li>
<li class="calibre11">goto</li>
<li class="calibre11">automatic coercion of Boolean, numbers and enumerations</li>
</ul>
<p class="calibre3">Also, Rust helps to prevent memory leaks. However, all of this is possible with <kbd class="calibre14">unsafe</kbd> code, which is explained in <a target="_blank" href="part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 3</a>, <em class="calibre21">Events and Basic Game Mechanisms</em>.</p>
<p class="calibre3">Without further ado, let's install the tools we'll need throughout the book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing Rust</h1>
                
            
            
                
<p class="calibre3">In this section we'll install <kbd class="calibre14">rustup</kbd>, which allows us to install different versions of the compiler and package manager.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Windows</h1>
                
            
            
                
<p class="calibre3">Go to <a href="https://rustup.rs" class="calibre13">https://rustup.rs</a> and follow the instructions in order to download <kbd class="calibre14">rustup-init.exe</kbd>, then run it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Linux/Mac </h1>
                
            
            
                
<p class="calibre3">Unless your distribution provides a package for <kbd class="calibre14">rustup</kbd>, you'll need to install <kbd class="calibre14">rustup</kbd> by typing the following command in your terminal:</p>
<pre class="calibre23"><strong class="calibre5">$ curl https://sh.rustup.rs -sSf | sh
info: downloading installer

Welcome to Rust!

[...]

Current installation options:

   default host triple: x86_64-unknown-linux-gnu
     default toolchain: stable
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation</strong></pre>
<p class="calibre3">This downloaded <kbd class="calibre14">rustup</kbd> and asked you whether you want to customize the installation. Unless you have particular needs, you'll be okay with the default.</p>
<div><p class="calibre24">Note: The <kbd class="calibre25">$</kbd> represents your shell prompt and should not be typed; you must type the text following it. Also, a line of text that doesn't start with <kbd class="calibre25">$</kbd> represents the text output of the program.</p>
</div>
<p class="calibre3">To proceed with the installation, enter <kbd class="calibre14">1</kbd> and press <em class="calibre21">Enter</em>. This will install the <kbd class="calibre14">rustc</kbd> compiler, and the <kbd class="calibre14">cargo</kbd> package manager, among other things:</p>
<pre class="calibre23"><strong class="calibre5">info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'
info: latest update on 2017-07-20, rust version 1.19.0 (0ade33941 2017-07-17)
info: downloading component 'rustc'

[...]

  stable installed - rustc 1.19.0 (0ade33941 2017-07-17)


Rust is installed now. Great!

To get started you need Cargo's bin directory ($HOME/.cargo/bin) in your PATH
environment variable. Next time you log in this will be done automatically.

To configure your current shell run source $HOME/.cargo/env</strong></pre>
<p class="calibre3">As pointed out by the installer, you need to execute the following command in order to add the directory containing these tools in your <kbd class="calibre14">PATH</kbd>:</p>
<pre class="calibre23"><strong class="calibre5">$ source $HOME/.cargo/env
# Which is the same as executing the following:
$ export PATH="$HOME/.cargo/bin:$PATH"</strong></pre>
<p class="calibre3">(This is only needed once because the rustup installer added it to your <kbd class="calibre14">~/.profile</kbd> file.)</p>
<p class="calibre3">Now, test that you have both <kbd class="calibre14">cargo</kbd> and <kbd class="calibre14">rustc</kbd>, as you'll need them very soon:</p>
<pre class="calibre23"><strong class="calibre5">$ cargo -V
cargo 0.23.0 (61fa02415 2017-11-22)
$ rustc -V
rustc 1.22.1 (05e2e1c41 2017-11-22)</strong></pre>
<p class="calibre3">Cargo is Rust's package manager and build tool: it allows you to compile and run your projects, as well as managing their dependencies.</p>
<p class="calibre3">At the time of writing this book, the stable Rust version was 1.22.0.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Test your installation</h1>
                
            
            
                
<p class="calibre3">Let's try to build a Rust program. First, create a new project with <kbd class="calibre14">cargo</kbd>:</p>
<pre class="calibre23"><strong class="calibre5">$ cargo new --bin hello_world
     Created binary (application) `hello_world` project</strong></pre>
<p class="calibre3">The <kbd class="calibre14">--bin</kbd> flag indicates that we want to create an executable project, as opposed to a library (which is the default without this flag). In the Rust world, a <strong class="calibre5">crate</strong> is a package of libraries and/or executable binaries.</p>
<p class="calibre3">This created a <kbd class="calibre14">hello_world</kbd> directory containing the following files and directory:</p>
<pre class="calibre23"><strong class="calibre5">$ tree hello_world/
hello_world/
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files</strong></pre>
<p class="calibre3">The <kbd class="calibre14">Cargo.toml</kbd> file is where the metadata (name, version, and so on) of your project resides, as well as its dependencies. The source files of your project are in the <kbd class="calibre14">src</kbd> directory. It's now time to run this project:</p>
<pre class="calibre23"><strong class="calibre5">$ cd hello_world/
$ cargo run
   Compiling hello_world v0.1.0 (file:///home/packtpub/projects/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.39 secs
     Running `target/debug/hello_world`
Hello, world!</strong></pre>
<p class="calibre3">The first three lines printed after <kbd class="calibre14">cargo run</kbd> are lines printed by <kbd class="calibre14">cargo</kbd> indicating what it did: it compiled the project and ran it. The last line, <kbd class="calibre14">Hello, world!</kbd>, is the line printed by our project. As you can see, <kbd class="calibre14">cargo</kbd> generates a Rust file that prints text to <kbd class="calibre14">stdout</kbd> (standard output):</p>
<pre class="calibre23"><strong class="calibre5">$ cat src/main.rs
fn main() {
    println!("Hello, world!");
}</strong></pre>
<p class="calibre3">If you only want to compile the project without running it, type the following instead:</p>
<pre class="calibre23"><strong class="calibre5">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs</strong></pre>
<p class="calibre3">This time, we didn't see <kbd class="calibre14">Compiling hello_world</kbd> because <kbd class="calibre14">cargo</kbd> did not see any changes to the project's files, thus, there's no need to compile again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Documentation and reference</h1>
                
            
            
                
<p class="calibre3">You can find the API documentation here: <a href="https://doc.rust-lang.org/stable/std/" class="calibre13">https://doc.rust-lang.org/stable/std/</a>. The reference can be found here: <a href="https://doc.rust-lang.org/stable/reference/" class="calibre13">https://doc.rust-lang.org/stable/reference/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Main function</h1>
                
            
            
                
<p class="calibre3">Let's look again at our first project source code:</p>
<pre class="calibre22">fn main() {
    println!("Hello, world!");
}</pre>
<p class="calibre3">It only contains a <kbd class="calibre14">main</kbd> function—this is where the execution of the program begins. It is a function that takes no arguments (hence the empty parentheses) and returns a unit, also written <kbd class="calibre14">()</kbd>. The body of the function, between curly brackets, contains a call to the <kbd class="calibre14">println!()</kbd> macro—we can see this is a macro because it ends with <kbd class="calibre14">!</kbd>, as opposed to a function. This macro prints the text between parentheses, followed by a new line. We'll see what is a macro in the Macros section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Variables</h1>
                
            
            
                
<p class="calibre3">We'll now change the previous program to add a variable:</p>
<pre class="calibre22">fn main() {
    let name = "world";
    println!("Hello, {}!", name);
}</pre>
<p class="calibre3">The <kbd class="calibre14">{}</kbd> part in the string literal is replaced by the content of the <kbd class="calibre14">name</kbd> variable. Here, we see the type inference in action—we don't have to specify the type of the <kbd class="calibre14">name</kbd> variable and the compiler will infer it for us. We could have also written the type ourselves:</p>
<pre class="calibre22">let name: &amp;str = "world";</pre>
<p class="calibre3">(From now on, I'll omit the <kbd class="calibre14">main</kbd> function, but this code should be written inside the function.)</p>
<p class="calibre3">In Rust, variables are immutable by default. As such, writing the following will cause a compile-time error:</p>
<pre class="calibre22">let age = 42;
age += 1;</pre>
<p class="calibre3">The compiler gives us a very helpful error message:</p>
<pre class="calibre23"><strong class="calibre5">error[E0384]: cannot assign twice to immutable variable `age`
  --&gt; src/main.rs:16:5
   |
15 |     let age = 42;
   |         --- first assignment to `age`
16 |     age += 1;
   |     ^^^^^^^^ cannot assign twice to immutable variable</strong></pre>
<p class="calibre3">To make a variable mutable, we need to use the <kbd class="calibre14">mut</kbd> keyword:</p>
<pre class="calibre22">let mut age = 42;
age += 1;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Built-in data types</h1>
                
            
            
                
<p class="calibre3">Let's look at the basic types provided by the language, such as integers, floats, Booleans, and characters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Integer types</h1>
                
            
            
                
<p class="calibre3">The following integer types are available in Rust:</p>
<table class="calibre26">
<thead class="calibre27">
<tr class="header">
<th class="calibre28">Unsigned</th>
<th class="calibre28">Signed</th>
</tr>
</thead>
<tbody class="calibre29">
<tr class="header">
<td class="calibre30"><kbd class="calibre31">u8</kbd></td>
<td class="calibre30"><kbd class="calibre31">i8</kbd></td>
</tr>
<tr class="header">
<td class="calibre30"><kbd class="calibre31">u16</kbd></td>
<td class="calibre30"><kbd class="calibre31">i16</kbd></td>
</tr>
<tr class="header">
<td class="calibre30"><kbd class="calibre31">u32</kbd></td>
<td class="calibre30"><kbd class="calibre31">i32</kbd></td>
</tr>
<tr class="header">
<td class="calibre30"><kbd class="calibre31">u64</kbd></td>
<td class="calibre30"><kbd class="calibre31">i64</kbd></td>
</tr>
<tr class="header">
<td class="calibre30"><kbd class="calibre31">usize</kbd></td>
<td class="calibre30"><kbd class="calibre31">isize</kbd></td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">The <kbd class="calibre14">u</kbd> means unsigned, while the <kbd class="calibre14">i</kbd> means signed, and the number following it is the number of bits. For instance, a number of the <kbd class="calibre14">u8</kbd> type can be between 0 and 255, inclusive. And a number of the <kbd class="calibre14">i16</kbd> type can be between -32768 and 32767, inclusive. The size variants are the pointer-sized integer types: <kbd class="calibre14">usize</kbd> and <kbd class="calibre14">isize</kbd> are 64-bit on a 64-bit CPU. The default integer type is <kbd class="calibre14">i32</kbd>, which means that this type will be used by the type inference when it cannot choose a more specific type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Floating-point types</h1>
                
            
            
                
<p class="calibre3">There are two floating-point types: <kbd class="calibre14">f32</kbd> and <kbd class="calibre14">f64</kbd>, the latter being the default. The number following <kbd class="calibre14">f</kbd> represents the number of bits for the type. An example value is <kbd class="calibre14">0.31415e1</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Boolean type</h1>
                
            
            
                
<p class="calibre3">The <kbd class="calibre14">bool</kbd> type admits two values: <kbd class="calibre14">true</kbd> and <kbd class="calibre14">false</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Character type</h1>
                
            
            
                
<p class="calibre3">The <kbd class="calibre14">char</kbd> type represents a Unicode character. An example unicode scalar value is <kbd class="calibre14">'€'</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Control flow</h1>
                
            
            
                
<p class="calibre3">We'll now look at how to write conditions and loops in Rust. Conditions are useful to execute a block of code when a certain situation happens, and loops allow you to repeat a block of code a number of times, until a condition is met.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Writing a condition</h1>
                
            
            
                
<p class="calibre3">Similar to other languages, Rust conditions are expressed with the <kbd class="calibre14">if</kbd> and <kbd class="calibre14">else</kbd> keywords:</p>
<pre class="calibre22">let number1 = 24;
let number2 = 42;
if number1 &gt; number2 {
    println!("{} &gt; {}", number1, number2);
} else {
    println!("{} &lt;= {}", number1, number2);
}</pre>
<p class="calibre3">However, they do not require parentheses around the conditional expression. Also, this expression must be of the <kbd class="calibre14">bool</kbd> type: you cannot use a number as you would in other languages.</p>
<p class="calibre3">One particularity of Rust conditions, like many other constructs, is that they are expressions. The last expression of each branch is the value of this branch. Be careful though, the type of each branch must be the same. For instance, we can get the minimum number of the two numbers and put it into a variable:</p>
<pre class="calibre22">let minimum =
    if number1 &lt; number2 {
        number1
    } else {
        number2
    }; // Don't forget the semi-colon here.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating while loops</h1>
                
            
            
                
<p class="calibre3">There are multiple kinds of loop in Rust. One of them is the <kbd class="calibre14">while</kbd> loop.</p>
<p class="calibre3">Let's see how to compute the greatest common divisor using the Euclidean algorithm:</p>
<pre class="calibre22">let mut a = 15;
let mut b = 40;
while b != 0 {
    let temp = b;
    b = a % b;
    a = temp;
}
println!("Greatest common divisor of 15 and 40 is: {}", a);</pre>
<p class="calibre3">This code executes successive divisions and stops doing so when the remainder is <kbd class="calibre14">0</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating functions</h1>
                
            
            
                
<p class="calibre3">We had a brief introduction to functions when we saw the <kbd class="calibre14">main</kbd> function. Let's see how to create functions with parameters and a return value.</p>
<p class="calibre3">Here's how to write a function that returns the maximum of two numbers:</p>
<pre class="calibre22">fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        a
    } else {
        b
    }
}</pre>
<p class="calibre3">The parameters are between parentheses and must be explicitly typed since the type inference only infers the types of local variables. This is a good thing since this acts as a documentation. Moreover, this can prevent bugs when we change how we use the parameters or change the value that is returned. The function can be defined after it is used without any issue. The return type is after <kbd class="calibre14">-&gt;</kbd>. When we return <kbd class="calibre14">()</kbd>, we can omit the <kbd class="calibre14">-&gt;</kbd> and type.</p>
<p class="calibre3">The last expression in the body of a function is the value returned from the function. You don't need to use <kbd class="calibre14">return</kbd>. The <kbd class="calibre14">return</kbd> keyword is only needed when you want to return early.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating structures</h1>
                
            
            
                
<p class="calibre3">Sometimes, we have multiple values that only make sense together, such as the two coordinates of a point. Structures are a way to create new types that contains multiple members.</p>
<p class="calibre3">Here is how we would create the aforementioned <kbd class="calibre14">Point</kbd> structure:</p>
<pre class="calibre22">struct Point {
    x: i32,
    y: i32,
}</pre>
<p class="calibre3">To create a new point and access its members, we use the following syntax:</p>
<pre class="calibre22">let point = Point {
    x: 24,
    y: 42,
};
println!("({}, {})", point.x, point.y);</pre>
<p class="calibre3">What if we want to print the <kbd class="calibre14">point</kbd> as a whole?</p>
<p class="calibre3">Let's try the following:</p>
<pre class="calibre22">println!("{}", point);</pre>
<p class="calibre3">The compiler does not accept this:</p>
<pre class="calibre23"><strong class="calibre5">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
 --&gt; src/main.rs:7:20
  |
7 |     println!("{}", point);
  |                    ^^^^^ `Point` cannot be formatted with the default formatter; try using `:?` instead if you are using a format string
  |
  = help: the trait `std::fmt::Display` is not implemented for `Point`
  = note: required by `std::fmt::Display::fmt`</strong></pre>
<p class="calibre3">The <kbd class="calibre14">{}</kbd> syntax is used to display a value to the end user of the application. Nevertheless, there's no standard way to display arbitrary structures. We can do what the compiler suggests: using the <kbd class="calibre14">{:?}</kbd> syntax. That requires you to add an attribute to the structure, so let's change it:</p>
<pre class="calibre22">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

println!("{:?}", point);</pre>
<p class="calibre3">The <kbd class="calibre14">#[derive(Debug)]</kbd> attribute tells the compiler to automatically generate the code to be able to print a debug representation of the structure. We'll see how this works in the section about traits. It prints the following:</p>
<pre class="calibre23"><strong class="calibre5">Point { x: 24, y: 42 }</strong></pre>
<p class="calibre3">Sometimes, the structure contains a lot of nested fields and this representation is hard to read. To remedy that, we can use the <kbd class="calibre14">{:#?}</kbd> syntax to pretty-print the value:</p>
<pre class="calibre22">println!("{:#?}", point);</pre>
<p class="calibre3">This gives the following output:</p>
<pre class="calibre23"><strong class="calibre5">Point {
    x: 24,
    y: 42
}</strong></pre>
<p class="calibre3">The documentation describes what other formatting syntax can be used: <a href="https://doc.rust-lang.org/stable/std/fmt/" class="calibre13">https://doc.rust-lang.org/stable/std/fmt/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">References</h1>
                
            
            
                
<p class="calibre3">Let's try the following code, which would work in other programming languages:</p>
<pre class="calibre22">let p1 = Point { x: 1, y: 2 };
let p2 = p1;
println!("{}", p1.x);</pre>
<p class="calibre3">We can see that Rust doesn't accept this. It gives the following error:</p>
<pre class="calibre23"><strong class="calibre5">error[E0382]: use of moved value: `p1.x`
 --&gt; src/main.rs:4:20
  |
3 |     let p2 = p1;
  |         -- value moved here
4 |     println!("{}", p1.x);
  |                    ^^^^ value used here after move
  |
  = note: move occurs because `p1` has type `Point`, which does not implement the `Copy` trait</strong></pre>
<p class="calibre3">This means that we cannot use a value after it is moved. In Rust, values are moved by default instead of being copied, except in some cases, as we'll see in the next sub-section.</p>
<p class="calibre3">To avoid moving a value, we can take a reference to it by prefixing it with <kbd class="calibre14">&amp;</kbd>:</p>
<pre class="calibre22">let p1 = Point { x: 1, y: 2 };
let p2 = &amp;p1;
println!("{}", p1.x);</pre>
<p class="calibre3">This code compiles and, in this case, <kbd class="calibre14">p2</kbd> is a reference to <kbd class="calibre14">p1</kbd>, which means that it points to the same memory location. Rust ensures that it is always safe to use a reference, since references are not pointers, they cannot be <kbd class="calibre14">NULL</kbd>.</p>
<p class="calibre3">References can also be used in the type of a function parameter. This is a function that prints a <kbd class="calibre14">point</kbd>, without moving the value:</p>
<pre class="calibre22">fn print_point(point: &amp;Point) {
    println!("x: {}, y: {}", point.x, point.y);
}</pre>
<p class="calibre3">We can use it this way:</p>
<pre class="calibre22">print_point(&amp;p1);
println!("{}", p1.x);</pre>
<p class="calibre3">We can still use the <kbd class="calibre14">point</kbd> after calling <kbd class="calibre14">print_point</kbd>, because we send a reference to the function instead of moving the <kbd class="calibre14">point</kbd> into the function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Clone types</h1>
                
            
            
                
<p class="calibre3">An alternative to using references is to clone values. By cloning a value, we don't move it. To be able to clone a <kbd class="calibre14">point</kbd>, we can add <kbd class="calibre14">derive</kbd> to it:</p>
<pre class="calibre22">#[derive(Clone, Debug)]
struct Point {
    x: i32,
    y: i32,
}</pre>
<p class="calibre3">We can now call the <kbd class="calibre14">clone()</kbd> method to avoid moving our <kbd class="calibre14">p1</kbd> point:</p>
<pre class="calibre22">fn print_point(point: Point) {
    println!("x: {}, y: {}", point.x, point.y);
}

let p1 = Point { x: 1, y: 2 };
let p2 = p1.clone();
print_point(p1.clone());
println!("{}", p1.x);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Copy types</h1>
                
            
            
                
<p class="calibre3">Some types are not moved when we assigned a value of these types to another variable. This is the case for basic types such as integers. For instance, the following code is perfectly valid:</p>
<pre class="calibre22">let num1 = 42;
let num2 = num1;
println!("{}", num1);</pre>
<p class="calibre3">We can still use <kbd class="calibre14">num1</kbd> even thought we assigned it to <kbd class="calibre14">num2</kbd>. This is because the basic types implement a special marker: <kbd class="calibre14">Copy</kbd>. Copy types are copied instead of moved.</p>
<p class="calibre3">We can make our own types <kbd class="calibre14">Copy</kbd> by adding <kbd class="calibre14">derive</kbd> to them:</p>
<pre class="calibre22">#[derive(Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}</pre>
<p class="calibre3">Since <kbd class="calibre14">Copy</kbd> requires <kbd class="calibre14">Clone</kbd>, we also implement the latter for our <kbd class="calibre14">Point</kbd> type. We cannot derive <kbd class="calibre14">Copy</kbd> for a type containing a value that does not implement <kbd class="calibre14">Copy</kbd>. Now, we can use a <kbd class="calibre14">Point</kbd> without having to bother with references:</p>
<pre class="calibre22">fn print_point(point: Point) {
    println!("x: {}, y: {}", point.x, point.y);
}

let p1 = Point { x: 1, y: 2 };
let p2 = p1;
print_point(p1);
println!("{}", p1.x);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mutable references</h1>
                
            
            
                
<p class="calibre3">If we want to be able to mutable thought a reference, we need a mutable reference, since everything is immutable by default in Rust. To get a mutable reference, simply replace <kbd class="calibre14">&amp;</kbd> with <kbd class="calibre14">&amp;mut</kbd>. Let's write a function that will increment the <kbd class="calibre14">x</kbd> field of a <kbd class="calibre14">Point</kbd>:</p>
<pre class="calibre22">fn inc_x(point: &amp;mut Point) {
    point.x += 1;
}</pre>
<p class="calibre3">Here, we see that the <kbd class="calibre14">Point</kbd> type is now <kbd class="calibre14">&amp;mut</kbd>, which allows us to update the point in the method. To use this method, our <kbd class="calibre14">p1</kbd> variable needs to be <kbd class="calibre14">mut</kbd> and we also need to take a mutable reference for this variable:</p>
<pre class="calibre22">let mut p1 = Point { x: 1, y: 2 };
inc_x(&amp;mut p1);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Methods</h1>
                
            
            
                
<p class="calibre3">We can add methods on custom types. Let's write a method to compute the distance of a <kbd class="calibre14">point</kbd> to the origin:</p>
<pre class="calibre22">impl Point {
    fn dist_from_origin(&amp;self) -&gt; f64 {
        let sum_of_squares = self.x.pow(2) + self.y.pow(2);
        (sum_of_squares as f64).sqrt()
    }
}</pre>
<p class="calibre3">There are a lot of new syntaxes here (<kbd class="calibre14">impl Point</kbd>, <kbd class="calibre14">as</kbd>, and <kbd class="calibre14">.method()</kbd>), so let's explain all of them. First of all, methods of a type are declared within the <kbd class="calibre14">impl Type {}</kbd> construct. This method takes a special parameter: <kbd class="calibre14">&amp;self</kbd>. This parameter is the instance the method is called on, like <kbd class="calibre14">this</kbd> in other programming languages. The <kbd class="calibre14">&amp;</kbd> operator before <kbd class="calibre14">self</kbd> means that the instance is passed by immutable reference. As we can see, it is possible to call methods on basic types in Rust—<kbd class="calibre14">self.x.pow(2)</kbd> computes the power of two of the <kbd class="calibre14">x</kbd> field. We can find this method, and many others, in the documentation, at <a href="https://doc.rust-lang.org/stable/std/primitive.i32.html#method.pow" class="calibre13">https://doc.rust-lang.org/stable/std/primitive.i32.html#method.pow</a> . In the last expression of the method, we cast the <kbd class="calibre14">sum_of_squares</kbd> integer to <kbd class="calibre14">f64</kbd> before computing its square root, because the <kbd class="calibre14">sqrt()</kbd> method is defined only on floating points.</p>
<p class="calibre3">Let's create a method that will update the fields of the structure:</p>
<pre class="calibre22">impl Point {
    fn translate(&amp;mut self, dx: i32, dy: i32) {
        self.x += dx;
        self.y += dy;
    }
}</pre>
<p class="calibre3">The difference with the previous method is that <kbd class="calibre14">self</kbd> is now a mutable reference, <kbd class="calibre14">&amp;mut</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Constructors</h1>
                
            
            
                
<p class="calibre3">Rust does not provide constructors, but a common idiom is to create a <kbd class="calibre14">new()</kbd> static method, also called an associated function:</p>
<pre class="calibre22">impl Point {
    fn new(x: i32, y: i32) -&gt; Self {
        Self { x: x, y: y }
    }
}</pre>
<p class="calibre3">The difference with a normal method is that it does not take <kbd class="calibre14">&amp;self</kbd> (or one of its variations) as a parameter.</p>
<p class="calibre3"><kbd class="calibre14">Self</kbd> is the type of the <kbd class="calibre14">self</kbd> value; we could have used <kbd class="calibre14">Point</kbd> instead of <kbd class="calibre14">Self</kbd>.</p>
<p class="calibre3">When the field name is the same as the value assigned, it is possible to omit the value, as a shorthand:</p>
<pre class="calibre22">fn new(x: i32, y: i32) -&gt; Self {
    Self { x, y }
}</pre>
<p class="calibre3">When we create an instance of <kbd class="calibre14">Point</kbd> with the call to its constructor (<kbd class="calibre14">let point = Point::new();</kbd>), this will allocate the value on the stack.</p>
<p class="calibre3">We can provide multiple constructors:</p>
<pre class="calibre22">impl Point {
    fn origin() -&gt; Self {
        Point { x: 0, y: 0 }
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tuples</h1>
                
            
            
                
<p class="calibre3">Tuples and structures are similar, except that tuples' fields are unnamed. Tuples are declared inside parentheses, with the element separated by a comma:</p>
<pre class="calibre22">let tuple = (24, 42);
println!("({}, {})", tuple.0, tuple.1);</pre>
<p class="calibre3">As you can see on the second line, we can access the elements of a tuple with <kbd class="calibre14">.index</kbd>, where <kbd class="calibre14">index</kbd> is a constant and this index starts at 0.</p>
<p class="calibre3">Tuples can be used to return multiple values from a function. For instance, the <kbd class="calibre14">str::split_at()</kbd> method returns two strings:</p>
<pre class="calibre22">let (hello, world) = "helloworld".split_at(5);
println!("{}, {}!", hello, world);</pre>
<p class="calibre3">Here, we assign the two elements of the tuple to the <kbd class="calibre14">hello</kbd> and <kbd class="calibre14">world</kbd> variables. We'll see why this works in the <em class="calibre21">Pattern matching</em> section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Enumerations</h1>
                
            
            
                
<p class="calibre3">While a structure allows us to get multiple values under the same variable, enumerations allow us to choose one value from different types of values.</p>
<p class="calibre3">For example, let's write a type representing an expression:</p>
<pre class="calibre22">enum Expr {
    Null,
    Add(i32, i32),
    Sub(i32, i32),
    Mul(i32, i32),
    Div { dividend: i32, divisor: i32 },
    Val(i32),
}

let quotient = Expr::Div { dividend: 10, divisor: 2 };
let sum = Expr::Add(40, 2);</pre>
<p class="calibre3">The <kbd class="calibre14">Null</kbd> variant does not have a value associated with it, <kbd class="calibre14">Val</kbd> has one associated value, and <kbd class="calibre14">Add</kbd> has two. <kbd class="calibre14">Div</kbd> also has two associated values, but they are named, similar to how we define a structure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pattern matching</h1>
                
            
            
                
<p class="calibre3">So how can we know which variant is in a variable whose type is an enumeration and how to get the values out of it? For that, we need to use pattern matching. The <kbd class="calibre14">match</kbd> expression is one way to do pattern matching. Let's see how to use it to compute the result of an expression:</p>
<pre class="calibre22">fn print_expr(expr: Expr) {
    match expr {
        Expr::Null =&gt; println!("No value"),
        Expr::Add(x, y) =&gt; println!("{}", x + y),
        Expr::Sub(x, y) =&gt; println!("{}", x - y),
        Expr::Mul(x, y) =&gt; println!("{}", x * y),
        Expr::Div { dividend: x, divisor: 0 } =&gt; println!("Divisor <br class="calibre6"/>         is zero"),
        Expr::Div { dividend: x, divisor: y } =&gt; println!("{}",  <br class="calibre6"/>        x/y),
        Expr::Val(x) =&gt; println!("{}", x),
    }
}</pre>
<p class="calibre3">A <kbd class="calibre14">match</kbd> expression is a way to check whether a value follows a certain pattern and executes different codes for different patterns. In this case, we match over an enumerated type, so we check for each variant. If the expression is <kbd class="calibre14">Expr::Add</kbd>, the code on the right of <kbd class="calibre14">=&gt;</kbd> is executed: <kbd class="calibre14">println!("{}", x + y)</kbd>. By writing variable names inside the parentheses next to <kbd class="calibre14">Expr::Add</kbd>, we specify that the actual values of this variant are bound to these names. By doing so, we can use these variable names on the right side of <kbd class="calibre14">=&gt;</kbd>.</p>
<p class="calibre3"/>
<p class="calibre3"><em class="calibre21">Figure</em> 1.1 is a diagram showing how pattern matching works:</p>
<div><img src="img/00005.jpeg" class="calibre32"/></div>
<p class="calibre3"/>
<div><em class="calibre21">Figure 1.1</em></div>
<p class="calibre3">A <kbd class="calibre14">match</kbd> can also be used to check whether a number is within a range. This function converts an ASCII character (represented by <kbd class="calibre14">u8</kbd> in Rust) to uppercase:</p>
<pre class="calibre22">fn uppercase(c: u8) -&gt; u8 {
    match c {
        b'a'...b'z' =&gt; c - 32,
        _ =&gt; c,
    }
}</pre>
<p class="calibre3">Here, the <kbd class="calibre14">...</kbd> syntax represents an inclusive range. And the underscore (<kbd class="calibre14">_</kbd>) is used to mean literally everything else, this is very useful in Rust because <kbd class="calibre14">match</kbd> needs to be exhaustive.</p>
<p class="calibre3">You can convert <kbd class="calibre14">u8</kbd> to <kbd class="calibre14">char</kbd> using the <kbd class="calibre14">as</kbd> syntax, as shown earlier:</p>
<pre class="calibre22">println!("{}", uppercase(b'a') as char);</pre>
<p class="calibre3">It is also possible to match against different patterns in a <kbd class="calibre14">match</kbd> by using the <kbd class="calibre14">|</kbd> operator:</p>
<pre class="calibre22">fn is_alphanumeric(c: char) -&gt; bool {
    match c {
        'a'...'z' | 'A'...'Z' | '0'...'9' =&gt; true,
        _ =&gt; false,
    }
}</pre>
<p class="calibre3">There are alternative syntaxes to do pattern matching. One of them is the <kbd class="calibre14">if let</kbd> construct. Let's rewrite our <kbd class="calibre14">uppercase</kbd> function using <kbd class="calibre14">if let</kbd>:</p>
<pre class="calibre22">fn uppercase(c: u8) -&gt; u8 {
    if let b'a'...b'z' = c {
        c - 32
    } else {
        c
    }
}</pre>
<p class="calibre3">Unlike a <kbd class="calibre14">match</kbd>, <kbd class="calibre14">if let</kbd> does not need to be exhaustive. It does not even require an <kbd class="calibre14">else</kbd> branch, the rules used for the normal <kbd class="calibre14">if</kbd> expression also applies to <kbd class="calibre14">if let</kbd>. This construct can be more appropriate than <kbd class="calibre14">match</kbd> when you only want to match against one or two patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Irrefutable patterns</h1>
                
            
            
                
<p class="calibre3">Another form of pattern matching is <strong class="calibre5">irrefutable patterns</strong>. A pattern is irrefutable when there's only one way to match it and it always succeeds. For instance, another way to get the elements of a tuple is with an irrefutable pattern:</p>
<pre class="calibre22">let tuple = (24, 42);
let (a, b) = tuple;
println!("{}, {}", a, b);</pre>
<p class="calibre3">In the second line, we assign the first element of the tuple to <kbd class="calibre14">a</kbd> and the second to <kbd class="calibre14">b</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Traits</h1>
                
            
            
                
<p class="calibre3">Traits are a way to specify that a type must implement some methods and/or some types. They are similar to interfaces in Java. We can implement a trait on a type and we'll be able to use the methods of this trait on this type as long as this trait is imported. This is how we can add methods to types defined in other crates or even the standard library.</p>
<p class="calibre3">Let's write a trait representing a bit set:</p>
<pre class="calibre22">trait BitSet {
    fn clear(&amp;mut self, index: usize);
    fn is_set(&amp;self, index: usize) -&gt; bool;
    fn set(&amp;mut self, index: usize);
}</pre>
<p class="calibre3">Here, we don't write the body of the methods, as they will be defined when we implement this trait for a type.</p>
<p class="calibre3">Now, let's implement this trait for the <kbd class="calibre14">u64</kbd> type:</p>
<pre class="calibre22">impl BitSet for u64 {
    fn clear(&amp;mut self, index: usize) {
        *self &amp;= !(1 &lt;&lt; index);
    }

    fn is_set(&amp;self, index: usize) -&gt; bool {
        (*self &gt;&gt; index) &amp; 1 == 1
    }

    fn set(&amp;mut self, index: usize) {
        *self |= 1 &lt;&lt; index;
    }
}</pre>
<p class="calibre3">As you can see, the bitwise <kbd class="calibre14">not</kbd> operator is <kbd class="calibre14">!</kbd> in Rust, as opposed to <kbd class="calibre14">~</kbd> in other languages. With this code, we can call these methods on <kbd class="calibre14">u64</kbd>:</p>
<pre class="calibre22">let mut num = 0;
num.set(15);
println!("{}", num.is_set(15));
num.clear(15);</pre>
<p class="calibre3">Remember the <kbd class="calibre14">#[derive(Debug)]</kbd> attribute? This actually implements the <kbd class="calibre14">Debug</kbd> trait on the following type. We could also manually implement the <kbd class="calibre14">Debug</kbd> trait on our type, using the same <kbd class="calibre14">impl</kbd> syntax, if the default implement does not suit our use case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Default methods</h1>
                
            
            
                
<p class="calibre3">Traits can contain default methods, which can be convenient for the implementor of the trait since fewer methods will need to be implemented. Let's add a <kbd class="calibre14">toggle()</kbd> default method in the trait:</p>
<pre class="calibre22">trait BitSet {
    fn clear(&amp;mut self, index: usize);
    fn is_set(&amp;self, index: usize) -&gt; bool;
    fn set(&amp;mut self, index: usize);

    fn toggle(&amp;mut self, index: usize) {
        if self.is_set(index) {
            self.clear(index);
        } else {
            self.set(index);
        }
    }
}</pre>
<p class="calibre3">Since the new method has a body, we don't need to update our previous implementation. However, we could do it to provide a more efficient implementation, for instance:</p>
<pre class="calibre22">impl BitSet for u64 {
    // The other methods are the same as before.

    fn toggle(&amp;mut self, index: usize) {
        *self ^= 1 &lt;&lt; index;
    }
}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Associated types</h1>
                
            
            
                
<p class="calibre3">We can also have types in a trait that need to be specified. For instance, let's implement the <kbd class="calibre14">Add</kbd> trait from the standard library on our <kbd class="calibre14">Point</kbd> type that we declared earlier, which allows us to use the <kbd class="calibre14">+</kbd> operator on our own types:</p>
<pre class="calibre22">use std::ops::Add;

impl Add&lt;Point&gt; for Point {
    type Output = Point;

    fn add(self, point: Point) -&gt; Self::Output {
        Point {
            x: self.x + point.x,
            y: self.y + point.y,
        }
    }
}</pre>
<p class="calibre3">The first line is to import the <kbd class="calibre14">Add</kbd> trait from the standard library so that we can implement it on our type. Here we specify that the associated <kbd class="calibre14">Output</kbd> type is <kbd class="calibre14">Point</kbd>. Associated types are most useful for return types. Here, the <kbd class="calibre14">Output</kbd> of the <kbd class="calibre14">add()</kbd> method is the associated <kbd class="calibre14">Self::Output</kbd> type.</p>
<p class="calibre3">Now, we can use the <kbd class="calibre14">+</kbd> operator on <kbd class="calibre14">Point</kbd>s:</p>
<pre class="calibre22">let p1 = Point { x: 1, y: 2 };
let p2 = Point { x: 3, y: 4 };
let p3 = p1 + p2;</pre>
<p class="calibre3">Having to specify the output parameter with an associated type (instead of setting it to <kbd class="calibre14">Self</kbd>) gives us more flexibility. For instance, we could implement the scalar product for the <kbd class="calibre14">*</kbd> operator, which takes two <kbd class="calibre14">Point</kbd>s and returns a number.</p>
<p class="calibre3">You can find all the operators that can be overloaded on this page, at <a href="https://doc.rust-lang.org/stable/std/ops/index.html" class="calibre13">https://doc.rust-lang.org/stable/std/ops/index.html</a>.</p>
<p class="calibre3">Since Rust 1.20, Rust also supports associated constants in addition to associated types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rules</h1>
                
            
            
                
<p class="calibre3">There are some rules that must be followed in order to use traits. The compiler will throw an error if they are not respected:</p>
<ul class="calibre10">
<li class="calibre11">The trait must be imported in order to use its methods</li>
<li class="calibre11">The implementation of a trait must be in the same crate as the trait or the type</li>
</ul>
<p class="calibre3">The second rule is to avoid conflicts that could otherwise happen when using multiple libraries. We can have such a conflict when two imported traits provide the same method for the same type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generics</h1>
                
            
            
                
<p class="calibre3">Generics are a way to make a function or a type work for multiple types to avoid code duplication. Let's rewrite our <kbd class="calibre14">max</kbd> function to make it generic:</p>
<pre class="calibre22">fn max&lt;T: PartialOrd&gt;(a: T, b: T) -&gt; T {
    if a &gt; b {
        a
    } else {
        b
    }
}</pre>
<p class="calibre3">The first thing to note is that there's a new part after the function name: this is where we declare the generic types. We declare a generic <kbd class="calibre14">T</kbd> type, <kbd class="calibre14">: PartialOrd</kbd> after it means that this <kbd class="calibre14">T</kbd> type must implement the <kbd class="calibre14">PartialOrd</kbd> trait. This is called a trait bound. We then use this <kbd class="calibre14">T</kbd> type for both of our parameters and the return type. Then, we see the same function body as the one from our non-generic function. We needed to add the trait bound because, by default, no operation is allowed on a generic type. The <kbd class="calibre14">PartialOrd</kbd> trait allows us to use the comparison operators.</p>
<p class="calibre3">We can then use this function with any type that implements <kbd class="calibre14">PartialOrd</kbd>:</p>
<pre class="calibre22">println!("{}", max('a', 'z'));</pre>
<p class="calibre3">This is using static dispatch as opposed to dynamic dispatch, meaning that the compiler will generate a <kbd class="calibre14">max</kbd> function specific to <kbd class="calibre14">char</kbd> in the resulting binary. Dynamic dispatch is another approach that resolves the right function to call at runtime, which is less efficient.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Option type</h1>
                
            
            
                
<p class="calibre3">Generics can also be used in a type. The <kbd class="calibre14">Option</kbd> type from the standard library is a generic type, defined as such:</p>
<pre class="calibre22">enum Option&lt;T&gt; {
    Some(T),
    None,
}</pre>
<p class="calibre3">This type is useful to encode the possibility of the absence of a value. <kbd class="calibre14">None</kbd> means no value, while <kbd class="calibre14">Some(value)</kbd> is used when there's a value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Arrays</h1>
                
            
            
                
<p class="calibre3">An array is a fixed-size collection of elements of the same type. We declare them with square brackets:</p>
<pre class="calibre22">let array = [1, 2, 3, 4];
let array: [i16; 4] = [1, 2, 3, 4];</pre>
<p class="calibre3">The second line shows how to specify the type of an array. An alternative way to do that is to use a literal suffix:</p>
<pre class="calibre22">let array = [1u8, 2, 3, 4];</pre>
<p class="calibre3">A literal suffix is the composition of a literal (that is, a constant) and a type suffix, so with the <kbd class="calibre14">1</kbd> constant and the <kbd class="calibre14">u8</kbd> type, we get <kbd class="calibre14">1u8</kbd>. Literal suffixes can only be used on numbers. This declares an array of <kbd class="calibre14">4</kbd> elements of the <kbd class="calibre14">u8</kbd> type. Array indexing starts at 0 and bounds checking is done at runtime. Bounds checking is used to prevent accessing memory that is out of bounds, for instance, trying to access the element after the end of an array. While this can slow down the software a bit, it can be optimized in many cases. The following code will trigger a panic because the <kbd class="calibre14">4</kbd> index is one past the end of the array:</p>
<pre class="calibre22">println!("{}", array[4]);</pre>
<p class="calibre3">At runtime, we see the following message:</p>
<pre class="calibre22">thread 'main' panicked at 'index out of bounds: the len is 4 but the index is 4', src/main.rs:5:20
note: Run with `RUST_BACKTRACE=1` for a backtrace.</pre>
<p class="calibre3">Another way to declare an array is:</p>
<pre class="calibre22">let array = [0u8; 100];</pre>
<p class="calibre3">This declares an array of 100 elements, where all of them are <kbd class="calibre14">0</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Slices</h1>
                
            
            
                
<p class="calibre3">Arrays are fixed-size, but if we want to create a function that works with arrays of any size, we need to use another type: a slice.</p>
<p class="calibre3">A slice is a view into a contiguous sequence: it can be a view of the whole array, or a part of it. Slices are fat pointers, in addition to the pointer to the data, they contain a size. Here's a function that returns a reference to the first element of a slice:</p>
<pre class="calibre22">fn first&lt;T&gt;(slice: &amp;[T]) -&gt; &amp;T {
    &amp;slice[0]
}</pre>
<p class="calibre3">Here, we use a generic type without bound since we don't use any operation on values of the <kbd class="calibre14">T</kbd> type. The <kbd class="calibre14">&amp;[T]</kbd> parameter type is a slice of <kbd class="calibre14">T</kbd>. The return type is <kbd class="calibre14">&amp;T</kbd>, which is a reference on values of the <kbd class="calibre14">T</kbd> type. The body of the function is <kbd class="calibre14">&amp;slice[0]</kbd>, which returns a reference to the first element of the slice. Here's how to call this function with an array:</p>
<pre class="calibre22">println!("{}", first(&amp;array));</pre>
<p class="calibre3">We can create <kbd class="calibre14">slice</kbd> for only a portion of an array, as shown in the following example:</p>
<pre class="calibre22">println!("{}", first(&amp;array[2..]));</pre>
<p class="calibre3"><kbd class="calibre14">&amp;array[2..]</kbd> creates a slice that starts at the <kbd class="calibre14">2</kbd> index until the end of the array (hence no index after <kbd class="calibre14">..</kbd>). Both indices are optional, so we could also write <kbd class="calibre14">&amp;array[..10]</kbd> for the first 10 elements of the array, <kbd class="calibre14">&amp;array[5..10]</kbd> for the elements with the 5 to 9 index (inclusive), or <kbd class="calibre14">&amp;array[..]</kbd> for all the elements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">For loops</h1>
                
            
            
                
<p class="calibre3">The for loop is another form of loops that can be used in Rust. It is used to loop over elements of an iterator. An iterator is a structure that produces a sequence of value: it could produce the same value indefinitely or produce the elements of a collection. We can get an iterator from a slice, so let's do that to compute the sum of the elements in a slice:</p>
<pre class="calibre22">let array = [1, 2, 3, 4];
let mut sum = 0;
for element in &amp;array {
    sum += *element;
}
println!("Sum: {}", sum);</pre>
<p class="calibre3">The only surprising part here is <kbd class="calibre14">*</kbd> in <kbd class="calibre14">sum += *element</kbd>. Since we get a reference to the elements of the slice, we need to dereference them in order to access the integers. We used <kbd class="calibre14">&amp;</kbd> in front of <kbd class="calibre14">array</kbd> to avoid moving it, indeed, we may still want to use this variable after the loop.</p>
<p class="calibre3">Let's write a function that returns the index of an element in a slice, or <kbd class="calibre14">None</kbd> if it is not in the slice:</p>
<pre class="calibre22">fn index&lt;T: PartialEq&gt;(slice: &amp;[T], target: &amp;T) -&gt; Option&lt;usize&gt; {
    for (index, element) in slice.iter().enumerate() {
        if element == target {
            return Some(index);
        }
    }
    None
}</pre>
<div><p class="calibre24">Note: A partial equivalence relation is both symmetric and transitive, but not reflexive. The <kbd class="calibre25">Eq</kbd> trait is used when these three properties are satisfied.</p>
</div>
<p class="calibre3">Here, we use again a generic type, but this time we use the <kbd class="calibre14">PartialEq</kbd> trait bound to be able to use the <kbd class="calibre14">==</kbd> operator on values of the <kbd class="calibre14">T</kbd> type. This function returns <kbd class="calibre14">Option&lt;usize&gt;</kbd>, meaning that it can either return no value (<kbd class="calibre14">None</kbd>) or the index (<kbd class="calibre14">Some(index)</kbd>). In the first line of the body, we use <kbd class="calibre14">slice.iter().enumerate()</kbd> to get the index in addition to the element of the slice. We use pattern matching right after the <kbd class="calibre14">for</kbd> keyword in order to assign the index and the element to variables. Inside the condition, we use the <kbd class="calibre14">return</kbd> keyword to return a value early. So if the value is found, it will return the index; otherwise, the loop will end and the <kbd class="calibre14">None</kbd> value is returned afterward.</p>
<p class="calibre3">Let's write another function that uses a <kbd class="calibre14">for</kbd> loop. It returns the minimum and the maximum of a slice, or <kbd class="calibre14">None</kbd> if the slice is empty:</p>
<pre class="calibre22">fn min_max(slice: &amp;[i32]) -&gt; Option&lt;(i32, i32)&gt; {
    if slice.is_empty() {
        return None;
    }
    let mut min = slice[0];
    let mut max = slice[0];
    for &amp;element in slice {
        if element &lt; min {
            min = element;
        }
        if element &gt; max {
            max = element;
        }
    }
    Some((min, max))
}</pre>
<p class="calibre3">Here we return multiple values from a function by using a tuple. This time, <kbd class="calibre14">&amp;</kbd> is on the left side of <kbd class="calibre14">in</kbd>, while previously it was on the right side of it; this is because this <kbd class="calibre14">for</kbd> loop is pattern matching against a reference by using <kbd class="calibre14">&amp;element</kbd>. This is something we can do in Rust, thus we don't need to dereference the element anymore with <kbd class="calibre14">*</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Macros</h1>
                
            
            
                
<p class="calibre3">Macro rules, also called macros by example, are a way to avoid code duplication by generating code at compile time. We will implement a simple macro to implement our <kbd class="calibre14">BitSet</kbd> trait for integer types:</p>
<pre class="calibre22">macro_rules! int_bitset {
    ($ty:ty) =&gt; {
        impl BitSet for $ty {
            fn clear(&amp;mut self, index: usize) {
                *self &amp;= !(1 &lt;&lt; index);
            }

            fn is_set(&amp;self, index: usize) -&gt; bool {
                (*self &gt;&gt; index) &amp; 1 == 1
            }

            fn set(&amp;mut self, index: usize) {
                *self |= 1 &lt;&lt; index;
            }
        }
    };
}</pre>
<p class="calibre3">The name of the <kbd class="calibre14">int_bitset</kbd> macro is written after <kbd class="calibre14">macro_rules!</kbd>. A macro can have multiple rules, similar to match arms, but it matches on Rust syntactic elements instead, with types, expressions, blocks of code, and so on. Here we only have one rule and it matches against a single type since we use <kbd class="calibre14">:ty</kbd>. The part before <kbd class="calibre14">:ty</kbd> (<kbd class="calibre14">$ty</kbd>) is the name for the element that was matched. Inside the curly brackets, after the <kbd class="calibre14">=&gt;</kbd> symbol, we see the actual code that will be generated. It is the same as our previous implementation of <kbd class="calibre14">BitSet</kbd> for <kbd class="calibre14">u64</kbd>, except that it uses the meta-variable <kbd class="calibre14">$ty</kbd> instead of <kbd class="calibre14">u64</kbd>.</p>
<p class="calibre3">To avoid a lot of boilerplate code, we can then use this macro as follows:</p>
<pre class="calibre22">int_bitset!(i32);
int_bitset!(u8);
int_bitset!(u64);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Multiple pattern rules</h1>
                
            
            
                
<p class="calibre3">Let's write a macro that will simplify the implementation of the traits to overload operators. This macro will have two rules: one for the <kbd class="calibre14">+</kbd> and one for the <kbd class="calibre14">-</kbd> operators. Here's the first rule of the macro:</p>
<pre class="calibre22">macro_rules! op {
    (+ $_self:ident : $self_type:ty, $other:ident $expr:expr) =&gt; {
        impl ::std::ops::Add for $self_type {
            type Output = $self_type;

            fn add($_self, $other: $self_type) -&gt; $self_type {
                $expr
            }
        }
    };
    // …</pre>
<p class="calibre3">In this pattern, we use other types of syntactic elements: <kbd class="calibre14">ident</kbd>, which is an identifier, and <kbd class="calibre14">&lt;span&amp;gt;expr</kbd>, which is an expression. The trait (<kbd class="calibre14">::std::ops::Add</kbd>) is fully qualified so that the code using this macro won't need to import the <kbd class="calibre14">Add</kbd> trait.</p>
<p class="calibre3">And here's the rest of the macro:</p>
<pre class="calibre22">    (- $_self:ident : $self_type:ty, $other:ident $expr:expr) =&gt; {
        impl ::std::ops::Sub for $self_type {
            type Output = $self_type;

            fn sub($_self, $other: $self_type) -&gt; $self_type {
                $expr
            }
        }
    };
}</pre>
<p class="calibre3">We can then use this macro with our <kbd class="calibre14">Point</kbd> type, like this:</p>
<pre class="calibre22">op!(+ self:Point, other {
    Point {
        x: self.x + other.x,
        y: self.y + other.y,
    }
});

op!(- self:Point, other {
    Point {
        x: self.x - other.x,
        y: self.y - other.y,
    }
});</pre>
<p class="calibre3">Let's see how the matching works:</p>
<p class="calibre3">For the first macro call, we start with <kbd class="calibre14">+</kbd>, so the first branch is taken because it matches <kbd class="calibre14">+</kbd>, which is the start of this branch. Next we have <kbd class="calibre14">self</kbd>, which is an identifier, so it matches the <kbd class="calibre14">ident</kbd> pattern and this is assigned to the <kbd class="calibre14">$_self</kbd> meta-variable. Then, we have <kbd class="calibre14">:</kbd> which matches the colon in the pattern. After that, we have <kbd class="calibre14">Point</kbd>, which matches the <kbd class="calibre14">$self_type</kbd> meta-variable of the <kbd class="calibre14">ty</kbd> type (for matching on a type). Then we have <kbd class="calibre14">,</kbd> which matches the comma in the pattern. Next, we have <kbd class="calibre14">other</kbd>, which matches the next item in the pattern, which is the <kbd class="calibre14">$other</kbd> meta-variable of the <kbd class="calibre14">ident</kbd> type. Finally, we have <kbd class="calibre14">{ Point { … } }</kbd>, which matches the expression required at the end of the pattern. This is why these macros are called macros by example, we write what the call should look like and the user must match the example (or pattern).</p>
<p class="calibre3">As an exercise to the reader, try the following:</p>
<ul class="calibre10">
<li class="calibre11">Add the missing operators: <kbd class="calibre14">*</kbd> and <kbd class="calibre14">/</kbd></li>
<li class="calibre11">Add the ability to specify the types of <kbd class="calibre14">$other</kbd> and the return type in the pattern</li>
<li class="calibre11">If you haven't already done this in the previous point, add more tokens so that it looks more like a function declaration: <kbd class="calibre14">+(self: Point, other: Point) -&gt; Point { … }</kbd></li>
<li class="calibre11">Try moving the operator in the pattern after the <kbd class="calibre14">$self_type</kbd> meta-variable to see the limitations of <kbd class="calibre14">macro_rules</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Repetitions</h1>
                
            
            
                
<p class="calibre3">In a macro pattern, it is also possible to match against an unlimited number of patterns, using the repetition operators <kbd class="calibre14">+</kbd> and <kbd class="calibre14">*</kbd>. They behave exactly like the same operators in regular expressions:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">+</kbd> matches 1 or more times.</li>
<li class="calibre11"><kbd class="calibre14">*</kbd> matches 0, 1, or more times.</li>
</ul>
<p class="calibre3">Let's write a very useful macro, a macro to provide syntactic sugar to create <kbd class="calibre14">HashMap</kbd>s:</p>
<div><p class="calibre24">Note: A <kbd class="calibre25">HashMap</kbd> is a data structure from Rust's standard library that maps keys to values.</p>
</div>
<pre class="calibre22">macro_rules! hash {
    ($( $key:expr =&gt; $value:expr ),*) =&gt; {{
        let mut hashmap = ::std::collections::HashMap::new();
        $(hashmap.insert($key, $value);)*
        hashmap
    }};
}</pre>
<p class="calibre3">As we can see, we use the <kbd class="calibre14">*</kbd> operator here. The comma before it specify the separator token: this token must be present between each occurrence of the pattern between parentheses (which is the pattern that can be repeated). Don't forget the leading <kbd class="calibre14">$</kbd> before the opening parenthesis; without it, the macro will match the literal <kbd class="calibre14">(</kbd>. Inside the parentheses, we see a normal pattern, an expression, followed by the <kbd class="calibre14">=&gt;</kbd> operator, followed by another expression. The body of this rule is particular, since it uses two pairs of curly brackets instead of only one.</p>
<p class="calibre3">First, let's look at how we use this macro, and we'll go back to this peculiarity right after:</p>
<pre class="calibre22">let hashmap = hash! {
    "one" =&gt; 1,
    "two" =&gt; 2
};</pre>
<p class="calibre3">If we were to use only one pair of curly brackets, like this:</p>
<pre class="calibre22">macro_rules! hash {
    ($( $key:expr =&gt; $value:expr ),*) =&gt; {
        let mut hashmap = ::std::collections::HashMap::new();
        $(hashmap.insert($key, $value);)*
        hashmap
    };
}</pre>
<p class="calibre3">The compiler will try to generate the following code, which doesn't compile:</p>
<pre class="calibre22">let hashmap = let mut hashmap = ::std::collections::HashMap::new();
    hashmap.insert("one", 1);
    hashmap.insert("two", 2);
    hashmap;</pre>
<p class="calibre3">It doesn't compile because Rust wants an expression on the right-hand side of <kbd class="calibre14">=</kbd>. To transform this code into an expression, we simply need to add the curly brackets:</p>
<pre class="calibre22">let hashmap = {
    let mut hashmap = ::std::collections::HashMap::new();
    hashmap.insert("one", 1);
    hashmap.insert("two", 2);
    hashmap
};</pre>
<p class="calibre3">Hence the second pair of curly brackets.</p>
<p class="calibre3">There's one remaining line that requires an explanation in the body of the macro:</p>
<pre class="calibre23"><strong class="calibre5">$(hashmap.insert($key, $value);)*</strong></pre>
<p class="calibre3">This means that the statement will be repeated as many times as there are pairs of key/values. Notice that <kbd class="calibre14">;</kbd> is inside the parentheses; and there's no separator before <kbd class="calibre14">*</kbd> because every statement needs to end with a semicolon. But it's still possible to specify a separator here, as shown in the following example:</p>
<pre class="calibre22">let keys = [$($key),*];</pre>
<p class="calibre3">This will expand all the <kbd class="calibre14">$key</kbd>s, separating them by a comma. For instance, with a call like:</p>
<pre class="calibre22">hash! {
    "one" =&gt; 1,
    "two" =&gt; 2
}</pre>
<p class="calibre3">It will results in:</p>
<pre class="calibre22">let keys = ["one", "two"];</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Optional quantifier</h1>
                
            
            
                
<p class="calibre3">In the <kbd class="calibre14">macro_rules</kbd> system, there's no way to specify that a pattern is optional, like with the <kbd class="calibre14">?</kbd> quantifier in regular expressions. If we wanted to allow the user of our <kbd class="calibre14">hash</kbd> macro to use a trailing comma, we could change the rule by moving the comma inside the parentheses: <kbd class="calibre14">($( $key:expr =&gt; $value:expr,)*)</kbd>.</p>
<p class="calibre3">However, it will force the user to write a trailing macro. If we want to allow both variants, we can use the following trick, which uses the <kbd class="calibre14">*</kbd> operator: <kbd class="calibre14">($( $key:expr =&gt; $value:expr ),* $(,)* )</kbd>.</p>
<p class="calibre3">This means that a comma must be used between each pattern and we can use any number of commas after the last pattern, including no comma at all.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">This chapter introduced you to the basics of Rust by showing you how to use variables, functions, control flow structures, and types. You also learned more advanced concepts such as references and ownership to manage the memory, and you saw how you can use traits, generics, and macros to avoid code repetition.</p>
<p class="calibre3">In the next chapter, you'll practise what you've just learned by creating a video game.</p>


            

            
        
    </body></html>