<html><head></head><body>
        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Starting with SDL</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3"><span>Before</span> <span>starting to write the Tetris, a few things remain to be talked about, such as crates, which we'll be using a lot (and you'll be using a lot as well once you're <em class="calibre21">rusting</em> on your own!). Let's start with</span> <span>crates!</span><br class="calibre6"/></p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Rust crates</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In Rust, packages (both binaries and libraries) are named crates. You can find a lot of them on <kbd class="calibre14">crates.io</kbd>. Today, we'll use the SDL2 crate in order to make our tetris, but before even thinking about this, we need to install the <kbd class="calibre14">SDL2</kbd> <span>library that is used by the <kbd class="calibre14">SDL2</kbd> crate</span>!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Before going any further, we need to install the SDL library.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2 on Linux</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Depending on your package management tool, run the following to install SDL2 on Linux:</p>
<p class="calibre3"><kbd class="calibre14">apt package mananger</kbd>:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">$ <span>sudo</span> apt-get install libsdl2-dev</strong></pre></div>
<p class="calibre3"><kbd class="calibre14">dnf package manager</kbd>:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">$ <span>sudo</span> dnf install SDL2-devel</strong></pre></div>
<p class="calibre3">yum package manager:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">$ <span>yum</span> install SDL2-devel</strong></pre></div>
<p class="calibre3">Once done, your SDL2 installation is ready!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2 on Mac</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To install SDL2 on Mac, Simply run the following:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">$ <span>brew</span> install sdl2</strong></pre></div>
<p class="calibre3">You're good to go!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2 on Windows</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">All these installation instructions come directly from the Rust SDL2 crate.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Windows with Build Script</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3"><span>A few steps will be required in order to make all of it work. Follow the guide!</span></p>
<ol class="calibre16">
<li value="1" class="calibre11">Download the <kbd class="calibre14">mingw</kbd> and <kbd class="calibre14">msvc</kbd> development libraries from <a href="http://www.libsdl.org/" class="calibre13">http://www.libsdl.org/</a> (<span><kbd class="calibre14">SDL2-devel-2.0.x-mingw.tar.gz</kbd></span> and <span><kbd class="calibre14">SDL2-devel-2.0.x-VC.zip</kbd></span>).</li>
<li value="2" class="calibre11">Unpack to folders of your choice. (You can delete it afterward.)</li>
<li value="3" class="calibre11">Create the following folder structure in the same folder as your <span><kbd class="calibre14">Cargo.toml</kbd></span>:</li>
</ol>
<pre class="calibre23">        gnu-mingw\dll\32
        gnu-mingw\dll\64
        gnu-mingw\lib\32
        gnu-mingw\lib\64
        msvc\dll\32
        msvc\dll\64
        msvc\lib\32
        msvc\lib\64</pre>
<ol start="4" class="calibre16">
<li value="4" class="calibre11">Copy the <kbd class="calibre14">lib</kbd> and <kbd class="calibre14">dll</kbd> files from the source archive to the directories we created in step 3 as follows:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\i686-w64-mingw32\bin    -&gt;     gnu-mingw\dll\32
SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\x86_64-w64-mingw32\bin  -&gt;     gnu-mingw\dll\64
SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\i686-w64-mingw32\lib    -&gt;     gnu-mingw\lib\32
SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\x86_64-w64-mingw32\lib  -&gt;     gnu-mingw\lib\64
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x86\*.dll                 -&gt;     msvc\dll\32
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x64\*.dll                 -&gt;     msvc\dll\64
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x86\*.lib                 -&gt;     msvc\lib\32
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x64\*.lib                 -&gt;     msvc\lib\64</strong></pre>
<ol start="5" class="calibre16">
<li value="5" class="calibre11">Create a Build Script. If you don't already have one, put this in your <span><kbd class="calibre14">Cargo.toml</kbd></span> file under <span><kbd class="calibre14">[package]</kbd></span>:</li>
</ol>
<pre class="calibre23">        build = "build.rs"</pre>
<ol start="6" class="calibre16">
<li value="6" class="calibre11">Create a file in the same directory as <span><kbd class="calibre14">Cargo.toml</kbd></span> called <span><kbd class="calibre14">build.rs</kbd></span> and write this into it:</li>
</ol>
<div class="title-page-name">
<pre class="calibre23"><span>      use</span> std::env;
<span>      use</span> std::path::PathBuf;

<span>      fn</span> main() <span>{</span>
        <span>let</span> target = env::var(<span>"TARGET"</span>).unwrap();
        <span>if</span> target.contains(<span>"pc-windows"</span>) <span>{</span>
          <span>let</span> manifest_dir = <br class="calibre6"/>            PathBuf::from(env::var(<span>"CARGO_MANIFEST_DIR"</span>).unwrap());
          <span>let</span> <span>mut</span> lib_dir = manifest_dir.clone();
        <span>let</span> <span>mut</span> dll_dir = manifest_dir.clone();
        <span>if</span> target.contains(<span>"msvc"</span>) <span>{</span>
            lib_dir.push(<span>"msvc"</span>);
            dll_dir.push(<span>"msvc"</span>);
        <span>}</span> <span>else</span> <span>{</span>
            lib_dir.push(<span>"gnu-mingw"</span>);
            dll_dir.push(<span>"gnu-mingw"</span>);
        <span>}</span>
        lib_dir.push(<span>"lib"</span>);
        dll_dir.push(<span>"dll"</span>);
        <span>if</span> target.contains(<span>"x86_64"</span>) <span>{</span>
            lib_dir.push(<span>"64"</span>);
            dll_dir.push(<span>"64"</span>);
        <span>}</span> <span>else</span> <span>{</span>
            lib_dir.push(<span>"32"</span>);
            dll_dir.push(<span>"32"</span>);
        <span>}</span>
        <span>println!</span>(<span>"cargo:rustc-link-search=all={}"</span>, <br class="calibre6"/>          lib_dir.display());
        <span>for</span> entry <span>in</span> std::fs::read_dir(dll_dir).expect(<span>"Can't<br class="calibre6"/>          read DLL dir"</span>)  <span>{</span>
         <span>let</span> entry_path = entry.expect(<span>"Invalid fs entry"</span>).path();
         <span>let</span> file_name_result = entry_path.file_name();
         <span>let</span> <span>mut</span> new_file_path = manifest_dir.clone();
         <span>if</span> <span>let</span> <span>Some</span>(file_name) = file_name_result <span>{</span>
           <span>let</span> file_name = file_name.to_str().unwrap();
           <span>if</span> file_name.ends_with(<span>".dll"</span>) <span>{</span>
             new_file_path.push(file_name);
           std::fs::copy(&amp;entry_path,<br class="calibre6"/>           new_file_path.as_path()).expect(<span>"Can't copy <br class="calibre6"/>             from DLL dir"</span>);
           <span>}</span>
         <span>}</span>
        <span>}</span>
        <span>}</span>
<span>      }</span></pre></div>
<ol start="7" class="calibre16">
<li value="7" class="calibre11">On build, the Build Script will copy the needed DLLs into the same directory as your <span><kbd class="calibre14">Cargo.toml</kbd></span> file. You probably don't want to commit these to any Git repositories though, so add the following line to your <span><kbd class="calibre14">.gitignore</kbd></span> file:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">        /*.dll</strong></pre>
<ol start="8" class="calibre16">
<li value="8" class="calibre11">When you're shipping your game, make sure that you copy the corresponding <span><kbd class="calibre14">SDL2.dll</kbd></span> to the same directory that your compiled <kbd class="calibre14">exe</kbd> is in; otherwise, the game won't launch.</li>
</ol>
<p class="calibre3">And now your project should build and run on any Windows computer!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Windows (MinGW)</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3"><span>A few steps will be required in order to make all of it work. Follow the guide!</span></p>
<ol class="calibre16">
<li value="1" class="calibre11">Download <kbd class="calibre14">mingw</kbd> development libraries from <a href="http://www.libsdl.org/" class="calibre13">http://www.libsdl.org/</a> (<span><kbd class="calibre14">SDL2-devel-2.0.x-mingw.tar.gz</kbd></span>).</li>
<li value="2" class="calibre11">Unpack to a folder of your choice. (You can delete it afterward.)</li>
</ol>
<p class="calibre3"> </p>
<ol start="3" class="calibre16">
<li value="3" class="calibre11">Copy all <kbd class="calibre14">lib</kbd> files from the following path:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">     SDL2-devel-2.0.x-mingw\SDL2-2.0.x\x86_64-w64-mingw32\lib</strong></pre>
<p class="calibre33">Next, copy it to this path:</p>
<pre class="calibre23"><strong class="calibre5">    C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-gnu\lib</strong></pre>
<p class="calibre33">Alternately, you can copy to your library folder of choice and ensure that you have a system environment variable as follows:</p>
<pre class="calibre23"><strong class="calibre5">    LIBRARY_PATH = C:\your\rust\library\folder</strong></pre>
<p class="calibre33">For Rustup users, this folder will be at the following location:</p>
<pre class="calibre23"><strong class="calibre5">      C:\Users\{Your Username}.multirust\toolchains\{current<br class="calibre6"/>         toolchain}\lib\</strong><strong class="calibre5">rustlib\{current toolchain}\lib</strong></pre>
<p class="calibre33">Here, the current toolchain is probably <span><kbd class="calibre14">stable-x86_64-pc-windows-gnu</kbd></span>.</p>
<ol start="4" class="calibre16">
<li value="4" class="calibre11">Copy <span><kbd class="calibre14">SDL2.dll</kbd></span> from the following:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">     SDL2-devel-2.0.x-mingw\SDL2-2.0.x\x86_64-w64-mingw32\bin</strong></pre>
<p class="calibre33">The copied <kbd class="calibre14">SDL2.dll</kbd> is pasted into your cargo project, right next to your <kbd class="calibre14">Cargo.toml</kbd>.</p>
<ol start="5" class="calibre16">
<li value="5" class="calibre11">When you're shipping your game, make sure that you copy <span><kbd class="calibre14">SDL2.dll</kbd></span> to the same directory that your compiled <kbd class="calibre14">exe</kbd> is in; otherwise, the game won't launch.</li>
</ol>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Windows (MSVC)</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">A few steps will be required in order to make all of it work. Follow the guide!</p>
<ol class="calibre16">
<li value="1" class="calibre11">Download MSVC development libraries from <a href="http://www.libsdl.org/" class="calibre13">http://www.libsdl.org/</a> <span><kbd class="calibre14">SDL2-devel-2.0.x-VC.zip</kbd></span>.</li>
<li value="2" class="calibre11">Unpack <span><kbd class="calibre14">SDL2-devel-2.0.x-VC.zip</kbd></span> to a folder of your choice. (You can delete it afterward.)</li>
<li value="3" class="calibre11">Copy all <kbd class="calibre14">lib</kbd> files from the following path:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">      SDL2-devel-2.0.x-VC\SDL2-2.0.x\lib\x64\</strong></pre>
<p class="calibre33">The <kbd class="calibre14">lib</kbd> files will be pasted here:</p>
<pre class="calibre23"><strong class="calibre5">     C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-msvc\lib</strong></pre>
<p class="calibre33">Alternatively, they'll be pasted to your library folder of choice. Ensure that you have a system environment variable with the following:</p>
<pre class="calibre23"><strong class="calibre5">      LIB = C:\your\rust\library\folder</strong></pre>
<p class="calibre33">Here, the current toolchain is probably <span><kbd class="calibre14">stable-x86_64-pc-windows-msvc</kbd></span>.</p>
<ol start="4" class="calibre16">
<li value="4" class="calibre11">Copy <span><kbd class="calibre14">SDL2.dll</kbd></span> from the following code snippet:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">      SDL2-devel-2.0.x-VC\SDL2-2.0.x\lib\x64\</strong></pre>
<p class="calibre34"><span>The copied </span><kbd class="calibre14">SDL2.dll</kbd><span> is pasted i</span>nto your cargo project, right next to your <span><kbd class="calibre14">Cargo.toml</kbd></span>.</p>
<ol start="5" class="calibre16">
<li value="5" class="calibre11">When you're shipping your game, make sure that you copy <span><kbd class="calibre14">SDL2.dll</kbd></span> to the same directory that your compiled <kbd class="calibre14">exe</kbd> is in; otherwise, the game won't launch.</li>
</ol>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up your Rust project</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The Rust package manager, <span><kbd class="calibre14">cargo</kbd></span>, allows us to create a new project very easily with just one command, <span><kbd class="calibre14">cargo new</kbd></span>. Let's run it as follow:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5"><span>  cargo</span> new tetris --bin</strong></pre></div>
<p class="calibre3">You should have a new folder <kbd class="calibre14">tetris</kbd> containing the following:</p>
<pre class="calibre23">     tetris/
     |
     |- Cargo.toml
     |- src/
         |
         |- main.rs</pre>
<p class="calibre3">Note that if you ran <span><kbd class="calibre14">cargo new</kbd></span> without the <span><kbd class="calibre14">--bin</kbd></span> flag, then you will have a <span><kbd class="calibre14">lib.rs</kbd></span> file instead of <span><kbd class="calibre14">main.rs</kbd></span>.</p>
<p class="calibre3">Now write this into your <span><kbd class="calibre14">Cargo.toml</kbd></span> file:</p>
<pre class="calibre23">    [package]
    name = "tetris"
    version = "0.0.1"

    [dependencies]
    sdl2 = "0.30.0"</pre>
<p class="calibre3">Here, we declare that our project's name is <kbd class="calibre14">tetris</kbd>, its version is <kbd class="calibre14">0.0.1</kbd> (it isn't really important at the moment), and that it has a dependency on the <kbd class="calibre14">sdl2</kbd> crate.</p>
<p class="calibre3">For the versioning, <kbd class="calibre14">Cargo</kbd> follows <strong class="calibre5">SemVer</strong> (<strong class="calibre5">Semantic Versioning</strong>). It works as follows:</p>
<p class="calibre3"><span><kbd class="calibre14">[major].[minor].[path]</kbd></span></p>
<p class="calibre3">So here's exactly what every part means:</p>
<ul class="calibre10">
<li class="calibre11">Update the <span><kbd class="calibre14">[major]</kbd></span> number version when you make incompatible API changes</li>
<li class="calibre11">Update the <span><kbd class="calibre14">[minor]</kbd></span> number version when adding functionalities that don't break backward compatibility</li>
<li class="calibre11">Update the <span><kbd class="calibre14">[patch]</kbd></span> number version when you make bug fixes that don't break backward compatibility</li>
</ul>
<p class="calibre3">It's not vital to know this, but it's always nice to be aware of it in case you intend to write crates in the future.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Cargo and crates.io</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">A very important thing to note with Rust's ecosystem is that <kbd class="calibre14">Cargo</kbd> is really important if not central. It makes things much easier and all Rust projects are using it.</p>
<p class="calibre3">Cargo isn't only a build tool, it's also Rust's default package manager. If you need to download a dependency, <kbd class="calibre14">Cargo</kbd> will do it. You can find all available published crates on <a href="https://crates.io/" class="calibre13">https://crates.io/</a>. Consider the following screenshot:</p>
<div class="mce-root1"><img src="../images/00006.jpeg" class="calibre35"/></div>
<div class="mce-root1"><em class="calibre21">Figure 2.1</em></div>
<p class="calibre3">In the case of the <span><kbd class="calibre14">sdl2</kbd></span> crate, we can see on its page (<a href="https://crates.io/crates/sdl2" class="calibre13">https://crates.io/crates/sdl2</a>) some interesting and useful information:</p>
<div class="mce-root1"><img src="../images/00007.jpeg" class="calibre36"/></div>
<div class="mce-root1"><em class="calibre21">Figure 2.2</em></div>
<p class="calibre3">On the right-hand side, you can see the version history. It can be useful to check whether you have the last version or not and whether the crate is still maintained.</p>
<p class="calibre3">In the middle, you have the crate's dependencies. It's always interesting to know what you'll need to install in addition to your crate if something is missing.</p>
<p class="calibre3">And finally on the left-hand side, you have a few links that might be very useful (not always those ones, it depends on what has been put into the <span><kbd class="calibre14">Cargo.toml</kbd></span> file):</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre5">Documentation</strong>: This is where the documentation is hosted (even though I generally recommend <a href="https://docs.rs/" class="calibre13">docs.rs</a>, I'll talk about it in a moment)</li>
<li class="calibre11"><strong class="calibre5">Repository</strong>: This is where this crate's repository is hosted</li>
<li class="calibre11"><strong class="calibre5">Dependent crates</strong>: This is the list of the crates depending on this one</li>
<li class="calibre11"><strong class="calibre5">Homepage</strong>: If the crate has a website, you can go to its link</li>
</ul>
<p class="calibre3">Time to go back to <kbd class="calibre14">docs.rs</kbd> for a bit.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">The docs.rs documentation</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Every published crate on <kbd class="calibre14">crates.io</kbd> gets its documentation generated and hosted on <a href="https://docs.rs/" class="calibre13">https://docs.rs/</a>. If the crate's documentation hasn't been published by anyone anywhere online, you'll find it there as long as it has been published. With <span><kbd class="calibre14">crates.io</kbd></span> and <span><kbd class="calibre14">rust-lang.org</kbd></span>, it's one of the most known places of the Rust ecosystem, so bookmark it and doesn't lose it!</p>
<p class="calibre3">Here's a screenshot of what <a href="https://docs.rs/" class="calibre13">docs.rs</a> looks like:</p>
<div class="mce-root1"><img src="../images/00008.jpeg" class="calibre37"/></div>
<div class="mce-root1"><em class="calibre21">Figure 2.3</em></div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Back to our Cargo.toml file</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To go back to our <span><kbd class="calibre14">Cargo.toml</kbd></span> file, it's also possible to use crates directly from their repositories; you just have to specify this when adding the dependency in your <span><kbd class="calibre14">Cargo.toml</kbd></span> file. Generally, the published version is less advanced than the one on the corresponding repository but will be more stable.</p>
<p class="calibre3">So for example, if we want to use the repository version for the <span><kbd class="calibre14">sdl2</kbd></span> crate, we need to write in our <span><kbd class="calibre14">Cargo.toml</kbd></span> file:</p>
<pre class="calibre22">[dependencies]
sdl2 = { git = "https://github.com/Rust-SDL2/rust-sdl2" }</pre>
<p class="calibre3">Easy right? <span><kbd class="calibre14">Cargo</kbd></span> can also start tests or benchmarks, install binaries, handle special builds through a build file (by default in <span><kbd class="calibre14">build.rs</kbd></span>), or handle features (we'll come back to this point later in this part).</p>
<p class="calibre3">To put it simply, it's a complete tool, and explaining most of its features would take a lot of time and space, so we'll just stick to the basics for the moment.</p>
<div class="packt_infobox">You can find a very good documentation/tutorial on Cargo at <a href="http://doc.crates.io/index.html" class="calibre38">http://doc.crates.io/index.html</a>.</div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Rust's modules</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Before going any further, we need to talk about how file hierarchy works in Rust through its modules.</p>
<p class="calibre3">The first thing to know is that files and folders are handled as modules in Rust. Consider the following:</p>
<pre class="calibre22">|- src/
    |
    |- main.rs
    |- another_file.rs</pre>
<p class="calibre3">If you want to declare that a module is in the <span><kbd class="calibre14">another_file.rs</kbd></span> <span>file,</span> you'll need to add to your <span><kbd class="calibre14">main.rs</kbd></span> file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    mod</span> another_file;</pre></div>
<p class="calibre3">You will now have access to everything contained in <span><kbd class="calibre14">another_file.rs</kbd></span> (as long as it's public).</p>
<p class="calibre3">Another thing to know: you can only declare modules whose files are on the same level as your current module/file. Here's a short example to sum this up:</p>
<pre class="calibre22">|- src/
    |
    |- main.rs
    |- subfolder/
        |- another_file.rs</pre>
<p class="calibre3">If you try to declare a module referring to <span><kbd class="calibre14">another_file.rs</kbd></span> directly into <span><kbd class="calibre14">main.rs</kbd></span>, as shown preceding, it'll fail because there are no <span><kbd class="calibre14">another_file.rs</kbd></span> in <span><kbd class="calibre14">src/</kbd></span>. In this case, you'll need to do three things:</p>
<ol class="calibre16">
<li value="1" class="calibre11">Add a <span><kbd class="calibre14">mod.rs</kbd></span> file into the <span><kbd class="calibre14">subfolder</kbd></span> folder.</li>
<li value="2" class="calibre11">Declare <span><kbd class="calibre14">another_file</kbd></span> into <span><kbd class="calibre14">mod.rs</kbd></span>.</li>
<li value="3" class="calibre11">Declare <span><kbd class="calibre14">subfolder</kbd></span> into <span><kbd class="calibre14">main.rs</kbd></span>.</li>
</ol>
<p class="calibre3">You certainly wonder, why <span><kbd class="calibre14">mod.rs</kbd></span>? It's the norm in Rust—when you import a module, which is a folder, the compiler will look for a file named <span><kbd class="calibre14">mod.rs</kbd></span> into it. The <span><kbd class="calibre14">mod.rs</kbd></span> files are mainly used for re-exporting modules' content outside.</p>
<p class="calibre3">Let's now write down the code to do this:</p>
<p class="calibre3">Inside <span><kbd class="calibre14">mod.rs</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    pub</span> <span>mod</span> another_file;</pre></div>
<p class="calibre3">Inside <span><kbd class="calibre14">main.rs</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    mod</span> subfolder;</pre></div>
<p class="calibre3">Now, you can use everything that is in <span><kbd class="calibre14">another_file</kbd></span> (as long as it's public<span>!</span>). Consider the following example:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> subfolder::another_file::some_function;</pre></div>
<p class="calibre3">You will certainly have noticed that we declared <span><kbd class="calibre14">another_file</kbd></span> publicly in <span><kbd class="calibre14">mod.rs</kbd></span>. It's simply because <span><kbd class="calibre14">main.rs</kbd></span> won't be able to access its content <span>otherwise, as</span> it's not at the same module level. However, a child module can access a parent's private items.</p>
<p class="calibre3">To conclude this small part, let's talk about the third type of modules: the module blocks (yes, as simple as that).</p>
<p class="calibre3">Just like you import a file or a folder, you can create a module block by using the same keyword:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    mod</span> a_module <span>{</span>
      <span>pub</span> <span>struct</span> Foo;
<span>   }</span></pre></div>
<p class="calibre3">And you now created a new module named <span><kbd class="calibre14">a_module</kbd></span> containing a public structure. The rules described previously are applied the same way to this last kind of module.</p>
<p class="calibre3">You now know how to use modules to import files and folders. Let's start writing down our game!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Tetris</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Okay, we're now ready to start writing down our tetris!</p>
<p class="calibre3">First, let's fulfill our <span><kbd class="calibre14">main.rs</kbd></span> file in order to check whether everything is working as expected:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    extern</span> <span>crate</span> sdl2;

<span>    use</span> sdl2::pixels::Color;
<span>    use</span> sdl2::event::Event;
<span>    use</span> sdl2::keyboard::Keycode;
<span>    use</span> std::time::Duration;<br class="calibre6"/>    use std::thread::sleep;

<span>    pub</span> <span>fn</span> main() <span>{</span>
      <span>let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization   <br class="calibre6"/>      failed"</span>);
      <span>let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't get <br class="calibre6"/>       SDL video subsystem"</span>);

      <span>let</span> window = video_subsystem.window(<span>"rust-sdl2 demo: Video"</span>, <span>800</span>,<br class="calibre6"/>            <span>600</span>)
        .position_centered()
        .opengl()
        .build()
        .expect(<span>"Failed to create window"</span>);

      <span>let</span> <span>mut</span> canvas = window.into_canvas().build().expect(<span>"Failed to<br class="calibre6"/>        convert window into canvas"</span>);

      canvas.set_draw_color(Color::RGB(<span>255</span>, <span>0</span>, <span>0</span>));
      canvas.clear();
      canvas.present();
      <span>let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed to<br class="calibre6"/>        get SDL event pump"</span>);

      <span>'running</span>: <span>loop</span> <span>{</span>
         <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
            <span>match</span> event <span>{</span>
              Event::Quit <span>{</span> .. <span>}</span> |
              Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt;  <br class="calibre6"/><span>              {</span>
                <span>break</span> <span>'running</span>
              <span>}</span>,
              _ =&gt; <span>{}</span>
            <span>}</span>
         <span>}</span>
         sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
      <span>}</span>
<span>    }</span></pre></div>
<p class="calibre3">You'll note the following line:</p>
<div class="title-page-name">
<pre class="calibre23">    ::std::thread::sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));</pre></div>
<p class="calibre3">It allows you to avoid using all your computer CPU time needlessly and only rendering 60 times every second at most.</p>
<p class="calibre3">Now run the following in your terminal:</p>
<pre class="calibre23"><strong class="calibre5">$ cargo run</strong></pre>
<p class="calibre3">If you have a window filled with red (just as shown in the following screenshot), then everything's fine!</p>
<div class="mce-root1"><img src="../images/00009.jpeg" class="calibre39"/></div>
<div class="mce-root1"><em class="calibre21">Figure 2.4</em></div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a window</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The previous example created a window and drew into it. Now let's see how it did that!</p>
<p class="calibre3">Before going any further, we need to import the SDL2 crate, as follows:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    extern</span> <span>crate</span> sdl2;</pre></div>
<p class="calibre3">With this, we now have access to everything it contains.</p>
<p class="calibre3">Now that we've imported <kbd class="calibre14">sdl2</kbd>, we need to initialize an SDL context:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization failed"</span>);</pre></div>
<p class="calibre3">Once done, we need to get the video subsystem:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't get SDL <br class="calibre6"/>      video subsystem"</span>);</pre></div>
<p class="calibre3">We can now create the window:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> window = video_subsystem.window(<span>"Tetris"</span>, <span>800</span>, <span>600</span>)
                            .position_centered()<br class="calibre6"/>                            .opengl()
                            .build()
                            .expect(<span>"Failed to create window"</span>);</pre></div>
<p class="calibre3">A few notes on these methods:</p>
<ul class="calibre10">
<li class="calibre11">The parameters for the <span><kbd class="calibre14">window</kbd></span> method are title, width, height</li>
<li class="calibre11"><span><kbd class="calibre14">.position_centered()</kbd></span> gets the window in the middle of the screen</li>
<li class="calibre11"><kbd class="calibre14">.opengl()</kbd> makes the SDL use <kbd class="calibre14">opengl</kbd> to render </li>
<li class="calibre11"><span><kbd class="calibre14">.build()</kbd></span> creates the window by applying all previously received parameters</li>
<li class="calibre11"><span><kbd class="calibre14">.expect</kbd></span> panics with the given message if an error occurred</li>
</ul>
<p class="calibre3">If you try to run this sample of code, it'll display a window and close it super quickly. We now need to add an event loop in order to keep it running (and then to manage user inputs).</p>
<p class="calibre3">At the top of the file, you need to add this:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> sdl2::event::Event;
<span>    use</span> sdl2::keyboard::Keycode;

<span>    use</span> std::thread::sleep;
<span>    use</span> std::time::Duration;</pre></div>
<p class="calibre3">Now let's actually write our event manager. First, we need to get the event handler as follows:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed to<br class="calibre6"/>       get SDL event pump"</span>);</pre></div>
<p class="calibre3">Then, we create an infinite loop to loop over events:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    'running</span>: <span>loop</span> <span>{</span>
      <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
        <span>match</span> event <span>{</span>
            Event::Quit <span>{</span> .. <span>}</span> |
            Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <span>{</span>
                <span>break</span> <span>'running</span> <span>// We "break" the infinite loop.</span>
            <span>}</span>,
            _ =&gt; <span>{}</span>
        <span>}</span>
      <span>}</span>
    sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
<span>    }</span></pre></div>
<p class="calibre3">To go back on these two lines:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    'running</span>: <span>loop</span> <span>{</span>
<span>      break</span> <span>'running</span></pre></div>
<p class="calibre3"><span><kbd class="calibre14">loop</kbd></span> is a keyword that allows creating an infinite loop in Rust. An interesting feature though is that you can add a label to your loops (so, <span><kbd class="calibre14">while</kbd></span> and <span><kbd class="calibre14">for</kbd></span> as well). In this case, we added the label <span><kbd class="calibre14">running</kbd></span> to the main loop. The point is to be able to break directly an upper loop without having to set a variable.</p>
<p class="calibre3">Now, if we receive a <kbd class="calibre14">quit</kbd> event (pressing the cross of the window) or if you press the <em class="calibre21">Esc</em> key, the program quits.</p>
<p class="calibre3">Now you can run this code and you'll have a window.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Drawing</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">We now have a working window; it'd be nice to draw into it. First, we need to get the window's canvas before starting the main loop:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> canvas = window.into_canvas()
                       .target_texture()
                       .present_vsync()
                       .build()
                       .expect(<span>"Couldn't get window's canvas"</span>);</pre></div>
<p class="calibre3">A few explanations for the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><span><kbd class="calibre14">into_canvas</kbd></span> transforms the window into a canvas so that we can manipulate it more easily</li>
<li class="calibre11"><span><kbd class="calibre14">target_texture</kbd></span> activates texture rendering support</li>
<li class="calibre11"><span><kbd class="calibre14">present_vsync</kbd></span> enables the v-sync (also known as vertical-synchronization) limit</li>
<li class="calibre11"><span><kbd class="calibre14">build</kbd></span> creates the canvas by applying all previously set parameters</li>
</ul>
<p class="calibre3">Then we'll create a texture that we'll paste onto the window's canvas. First, let's get the texture creator, but before that, add this include at the top of the file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> sdl2::render::<span>{</span>Canvas, Texture, TextureCreator<span>}</span>;</pre></div>
<p class="calibre3">Now we can get the texture creator:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();</pre></div>
<p class="calibre3">OK! Now we need to create a rectangle. To make things easier to read, we'll create a constant that will be the texture's size (better to put it at the head of the file, just after the imports, for readability reasons):</p>
<div class="title-page-name">
<pre class="calibre23"><span>    const</span> TEXTURE_SIZE: <span>u32</span> = <span>32</span>;</pre></div>
<p class="calibre3">Let's create a texture with a <kbd class="calibre14">32x32</kbd> size:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> square_texture: Texture =
        texture_creator.create_texture_target(<span>None</span>, TEXTURE_SIZE,<br class="calibre6"/>          TEXTURE_SIZE)
        .expect(<span>"Failed to create a texture"</span>);</pre></div>
<p class="calibre3">Good! Now let's color it. First, add this import at the top of the file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> sdl2::pixels::Color;</pre></div>
<p class="calibre3">We use the canvas to draw our square texture:</p>
<div class="title-page-name">
<pre class="calibre23">    canvas.with_texture_canvas(&amp;<span>mut</span> square_texture, |texture| <span>{</span>
      texture.set_draw_color(Color::RGB(<span>0</span>, <span>255</span>, <span>0</span>));
      texture.clear();
<span>    }</span>);</pre></div>
<p class="calibre3">An explanation of the preceding code is as follows:</p>
<ul class="calibre10">
<li class="calibre11"><span><kbd class="calibre14">set_draw_color</kbd></span> sets the color to be used when drawing occurs. In our case, it's green.</li>
<li class="calibre11"><span><kbd class="calibre14">clear</kbd></span> washes/clears the texture so it'll be filled with green.</li>
</ul>
<p class="calibre3">Now, we just have to draw this square texture onto our window. In order to make it work, we need it to be drawn into the main loop but right after the event loop.</p>
<p class="calibre3">One thing to note before we continue: when drawing with the <kbd class="calibre14">SDL2</kbd>, the (0, 0) coordinates are at the top-left of a window, not at the bottom-left. The same goes for all shapes.</p>
<p class="calibre3">Add this import at the top of your file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> sdl2::rect::Rect;</pre></div>
<p class="calibre3">Now let's draw. In order to be able to update the rendering of your window, you need to draw inside the main loop (and after the event loop). So firstly, let's fill our window with red:</p>
<div class="title-page-name">
<pre class="calibre23">    canvas.set_draw_color(Color::RGB(<span>255</span>, <span>0</span>, <span>0</span>));
    canvas.clear();</pre></div>
<p class="calibre3">Next, we copy our texture into the window in the top-left corner with a 32x32 size:</p>
<div class="title-page-name">
<pre class="calibre23">    canvas.copy(&amp;square_texture,
            <span>None</span>,
            Rect::new(<span>0</span>, <span>0</span>, TEXTURE_SIZE, TEXTURE_SIZE))
        .expect(<span>"Couldn't copy texture into window"</span>);</pre></div>
<p class="calibre3">Finally, we update the window's display:</p>
<div class="title-page-name">
<pre class="calibre23">     canvas.present();</pre></div>
<p class="calibre3">So if we take a look at the full code, we now have the following:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    extern</span> <span>crate</span> sdl2;

<span>    use</span> sdl2::event::Event;
<span>    use</span> sdl2::keyboard::Keycode;
<span>    use</span> sdl2::pixels::Color;
<span>    use</span> sdl2::rect::Rect;
<span>    use</span> sdl2::render::<span>{</span>Texture, TextureCreator<span>}</span>;

<span>    use</span> std::thread::sleep;
<span>    use</span> std::time::Duration;

<span>    fn</span> main() <span>{</span>
      <span>let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization  <br class="calibre6"/>       failed"</span>);
      <span>let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't get<br class="calibre6"/>         SDL video subsystem"</span>);

      <span>// Parameters are: title, width, height</span>
      <span>let</span> window = video_subsystem.window(<span>"Tetris"</span>, <span>800</span>, <span>600</span>)
        .position_centered() <span>// to put it in the middle of the screen</span>
        .build() <span>// to create the window</span>
        .expect(<span>"Failed to create window"</span>);

      <span>let</span> <span>mut</span> canvas = window.into_canvas()
        .target_texture()
        .present_vsync() <span>// To enable v-sync.</span>
        .build()
        .expect(<span>"Couldn't get window's canvas"</span>);

      <span>let</span> texture_creator: TextureCreator&lt;_&gt; =  <br class="calibre6"/>       canvas.texture_creator();
       <span>// To make things easier to read, we'll create a constant <br class="calibre6"/>          which will be the texture's size.</span>
      <span>const</span> TEXTURE_SIZE: <span>u32</span> = <span>32</span>;

      <span>// We create a texture with a 32x32 size.</span>
      <span>let</span> <span>mut</span> square_texture: Texture =
        texture_creator.create_texture_target(<span>None</span>, TEXTURE_SIZE,<br class="calibre6"/>            TEXTURE_SIZE)
          .expect(<span>"Failed to create a texture"</span>);

      <span>// We use the canvas to draw into our square texture.</span>
      canvas.with_texture_canvas(&amp;<span>mut</span> square_texture, |texture| <span>{</span>
        <span>// We set the draw color to green.</span>
        texture.set_draw_color(Color::RGB(<span>0</span>, <span>255</span>, <span>0</span>));
        <span>// We "clear" our texture so it'll be fulfilled with green.</span>
        texture.clear();
      <span>}</span>).expect(<span>"Failed to color a texture"</span>);

      <span>// First we get the event handler:</span>
      <span>let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed <br class="calibre6"/>        to get SDL event pump"</span>);

      <span>// Then we create an infinite loop to loop over events:</span>
      <span>'running</span>: <span>loop</span> <span>{</span>
        <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
          <span>match</span> event <span>{</span>
          <span>// If we receive a 'quit' event or if the user press the<br class="calibre6"/>              'ESC' key, we quit.</span>
          Event::Quit <span>{</span> .. <span>}</span> |
          Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <span>{</span>
              <span>break</span> <span>'running</span> <span>// We "break" the infinite loop.</span>
          <span>}</span>,
          _ =&gt; <span>{}</span>
        <span>}</span>
      <span>}</span>

      <span>// We set fulfill our window with red.</span>
      canvas.set_draw_color(Color::RGB(<span>255</span>, <span>0</span>, <span>0</span>));
      <span>// We draw it.</span>
      canvas.clear();
      <span>// Copy our texture into the window.</span>
      canvas.copy(&amp;square_texture,
        <span>None</span>,
        <span>// We copy it at the top-left of the window with a 32x32 size.</span>
        Rect::new(<span>0</span>, <span>0</span>, TEXTURE_SIZE, TEXTURE_SIZE))
        .expect(<span>"Couldn't copy texture into window"</span>);
        <span>// We update window's display.</span>
        canvas.present();

        <span>// We sleep enough to get ~60 fps. If we don't call this, <br class="calibre6"/>           the program will take</span>
        <span>// 100% of a CPU time.</span>
        sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
      <span>}</span>
<span>    }</span></pre></div>
<p class="calibre3">If you run this code, you should have a red window with a small green rectangle at the top-left (just as shown in the following screenshot):</p>
<div class="mce-root1"><img src="../images/00010.jpeg" class="calibre40"/></div>
<div class="mce-root1"><em class="calibre21">Figure 2.5</em></div>
<p class="calibre3">Now, what about switching the color of our small rectangle every second? Alright, first thing, we need to create another rectangle. To make things easier, we'll write a small function that will create texture.</p>
<p class="calibre3">As usual, add the following import at the top of your file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> sdl2::video::<span>{</span>Window, WindowContext<span>}</span>;</pre></div>
<p class="calibre3">For convenience, we'll create a small enum to indicate the color as well:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    #[</span>derive<span>(</span><span>Clone</span><span>,</span> <span>Copy</span><span>)]</span>
<span>    enum</span> TextureColor <span>{</span>
      Green,
      Blue,
<span>    }</span></pre></div>
<p class="calibre3">To make our lives easier, we'll handle errors outside of the next function, so no need to handle them directly here:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> create_texture_rect&lt;<span>'a</span>&gt;(canvas: &amp;<span>mut</span> Canvas&lt;Window&gt;,
       texture_creator: &amp;<span>'a</span> TextureCreator&lt;WindowContext&gt;,
       color: TextureColor, size: <span>u32</span>) -&gt; <span>Option</span>&lt;Texture&lt;<span>'a</span>&gt;&gt; <span>{</span>
       <span>// We'll want to handle failures outside of this function.</span>
      <span>if</span> <span>let</span> <span>Ok</span>(<span>mut</span> square_texture) =
         texture_creator.create_texture_target(<span>None</span>, size, size) <span>{</span>
           canvas.with_texture_canvas(&amp;<span>mut</span> square_texture, |texture| <span>{</span>
             <span>match</span> color <span>{</span>
                TextureColor::Green =&gt; <br class="calibre6"/>                  texture.set_draw_color(Color::RGB(<span>0</span>, <span>255</span>, <span>0</span>)),
                TextureColor::Blue =&gt; <br class="calibre6"/>                  texture.set_draw_color(Color::RGB(<span>0</span>, <span>0</span>, <span>255</span>)),
             <span>}</span>
             texture.clear();
           <span>}</span>).expect(<span>"Failed to color a texture"</span>);
            <span>Some</span>(square_texture)
         <span>}</span> <span>else</span> <span>{</span>
             <span>None</span>
           <span>}</span>
<span>       }</span></pre></div>
<p class="calibre3">You'll note that the function returns an <span><kbd class="calibre14">Option</kbd></span> type, wrapping a texture. <span><kbd class="calibre14">Option</kbd></span> is an enum containing two variants: <span><kbd class="calibre14">Some</kbd></span> and <span><kbd class="calibre14">None</kbd></span>.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Playing with Options</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To explain briefly how it works, when the <span><kbd class="calibre14">Option</kbd></span> type is <span><kbd class="calibre14">Some</kbd></span>, it simply means it contains a value whereas <span><kbd class="calibre14">None</kbd></span> doesn't. It has already been explained in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, but here's a little recap just in case you need one. We can compare this mechanism with pointers in C-like languages; when the pointer is null, there is no data to access. The same goes for <span><kbd class="calibre14">None</kbd></span>.</p>
<p class="calibre3">Here's a short example:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> divide(nb: <span>u32</span>, divider: <span>u32</span>) -&gt; <span>Option</span>&lt;<span>u32</span>&gt; <span>{</span>
      <span>if</span> divider == <span>0</span> <span>{</span>
        <span>None</span>
      <span>}</span> <span>else</span> <span>{</span>
          <span>Some</span>(nb / divider)
        <span>}</span>
<span>    }  </span></pre></div>
<p class="calibre3">So here, if the divider is <kbd class="calibre14">0</kbd>, we can't divide or we'll get an error. Instead of setting an error or returning a complicated type, we just return an <span><kbd class="calibre14">Option</kbd></span>:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> x = divide(<span>10</span>, <span>3</span>);
<span>    let</span> y = divide(<span>10</span>, <span>0</span>);</pre></div>
<p class="calibre3">Here, <span><kbd class="calibre14">x</kbd></span> is equal to <span><kbd class="calibre14">Some(3)</kbd></span> and <span><kbd class="calibre14">y</kbd></span> is equal to <span><kbd class="calibre14">None</kbd></span>.</p>
<p class="calibre3">The biggest advantage of this type compared to <span><kbd class="calibre14">null</kbd></span> is that if we have <span><kbd class="calibre14">Some</kbd></span>, you're sure that the data is valid. And in addition, when it's <span><kbd class="calibre14">None</kbd></span>, you can't accidentally read its content, it's simply impossible in Rust (and if you try to <span><kbd class="calibre14">unwrap</kbd></span> it, your program will <span>panic</span> immediately, but at least, you'll know what failed and why—no magical segmentation fault).</p>
<p class="calibre3">You can take a look at its documentation at <a href="https://doc.rust-lang.org/std/option/enum.Option.html" class="calibre13">https://doc.rust-lang.org/std/option/enum.Option.html</a>.</p>
<p class="calibre3">Let's explain what happens here:</p>
<ol class="calibre16">
<li value="1" class="calibre11">We create a texture or return <span><kbd class="calibre14">None</kbd></span> if the creation fails.</li>
<li value="2" class="calibre11">We set the color and then fulfill the texture with it.</li>
<li value="3" class="calibre11">We return the texture.</li>
</ol>
<p class="calibre3">If we return <span><kbd class="calibre14">None</kbd></span>, it simply means an error occurred. Also, for now, this function only handles two colors, but it's pretty easy to add more if you want.</p>
<p class="calibre3">It might look a bit complicated at the moment, but it'll make our life easier afterward. Now, let's call this function by creating a blue square of size 32x32:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> blue_square = create_texture_rect(&amp;<span>mut</span> canvas,
        &amp;texture_creator,
        TextureColor::Blue,
        TEXTURE_SIZE).expect(<span>"Failed to create a texture"</span>);</pre></div>
<p class="calibre3">Easy, right?</p>
<div class="packt_tip">Now we can just put pieces together. I'll let you try to handle the color switch. A small tip: take a look at the <span class="packt_screen"><kbd class="calibre25">SystemTime</kbd></span> struct. You can refer to its documentation at <a href="https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html" class="calibre38">https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html</a>.</div>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Solution</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">I guess you did it without any issues, but in any case, here's the code:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    extern</span> <span>crate</span> sdl2;

<span>    use</span> sdl2::event::Event;
<span>    use</span> sdl2::keyboard::Keycode;
<span>    use</span> sdl2::pixels::Color;
<span>    use</span> sdl2::rect::Rect;
<span>    use</span> sdl2::render::<span>{</span>Canvas, Texture, TextureCreator<span>}</span>;
<span>    use</span> sdl2::video::<span>{</span>Window, WindowContext<span>}</span>;

<span>    use</span> std::thread::sleep;
<span>    use</span> std::time::<span>{</span>Duration, SystemTime<span>}</span>;

<span>    // To make things easier to read, we'll create a constant which<br class="calibre6"/>       will be the texture's size.</span>
<span>    const</span> TEXTURE_SIZE: <span>u32</span> = <span>32</span>;

<span>    #[</span>derive<span>(</span><span>Clone</span><span>,</span> <span>Copy</span><span>)]</span>
<span>    enum</span> TextureColor <span>{</span>
      Green,
      Blue,
<span>   }</span>

<span>   fn</span> create_texture_rect&lt;<span>'a</span>&gt;(canvas: &amp;<span>mut</span> Canvas&lt;Window&gt;,
     texture_creator: &amp;<span>'a</span> TextureCreator&lt;WindowContext&gt;,
     color: TextureColor,
     size: <span>u32</span>) -&gt; <span>Option</span>&lt;Texture&lt;<span>'a</span>&gt;&gt; <span>{</span>
      <span>// We'll want to handle failures outside of this function.</span>
    <span>if</span> <span>let</span> <span>Ok</span>(<span>mut</span> square_texture) =
      texture_creator.create_texture_target(<span>None</span>, size, size) <span>{</span>
        canvas.with_texture_canvas(&amp;<span>mut</span> square_texture, |texture| <span>{</span>
          <span>match</span> color <span>{</span>
            <span>// For now, TextureColor only handles two colors.</span>
            TextureColor::Green =&gt; texture.set_draw_color(Color::RGB(<span>0</span>,<br class="calibre6"/>                <span>255</span>, <span>0</span>)),
            TextureColor::Blue =&gt; texture.set_draw_color(Color::RGB(<span>0</span>,<br class="calibre6"/>                <span>0</span>, <span>255</span>)),
          <span>}</span>
          texture.clear();
        <span>}</span>).expect(<span>"Failed to color a texture"</span>);
        <span>Some</span>(square_texture)
      <span>}</span> <br class="calibre6"/><span>      else</span> <span>{</span>
       <span>// An error occured so we return nothing and let the function<br class="calibre6"/>           caller handle the error.</span>
       <span>None</span>
      <span>}</span>
<span>    }</span>

<span>    fn</span> main() <span>{</span>
      <span>let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization  <br class="calibre6"/>       failed"</span>);
      <span>let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't get <br class="calibre6"/>          SDL video subsystem"</span>);

      <span>// Parameters are: title, width, height</span>
      <span>let</span> window = video_subsystem.window(<span>"Tetris"</span>, <span>800</span>, <span>600</span>)
        .position_centered() <span>// to put it in the middle of the screen</span>
        .build() <span>// to create the window</span>
        .expect(<span>"Failed to create window"</span>);

      <span>let</span> <span>mut</span> canvas = window.into_canvas()
        .target_texture()
        .present_vsync() <span>// To enable v-sync.</span>
        .build()
        .expect(<span>"Couldn't get window's canvas"</span>);

      <span>let</span> texture_creator: TextureCreator&lt;_&gt; =  <br class="calibre6"/>       canvas.texture_creator();

      <span>// We create a texture with a 32x32 size.</span>
      <span>let</span> green_square = create_texture_rect(&amp;<span>mut</span> canvas,
         &amp;texture_creator,
         TextureColor::Green,
         TEXTURE_SIZE).expect(<span>"Failed to create a texture"</span>);
      <span>let</span> blue_square = create_texture_rect(&amp;<span>mut</span> canvas,
          &amp;texture_creator,
          TextureColor::Blue,
          TEXTURE_SIZE).expect(<span>"Failed to create a texture"</span>);

      <span>let</span> timer = SystemTime::now();

      <span>// First we get the event handler:</span>
      <span>let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed<br class="calibre6"/>         to get SDL event pump"</span>);

      <span>// Then we create an infinite loop to loop over events:</span>
      <span>'running</span>: <span>loop</span> <span>{</span>
        <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
          <span>match</span> event <span>{</span>
             <span>// If we receive a 'quit' event or if the user press the<br class="calibre6"/>                    'ESC' key, we quit.</span>
             Event::Quit <span>{</span> .. <span>}</span> |
             Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> =&gt; <span>{</span>
                <span>break</span> <span>'running</span> <span>// We "break" the infinite loop.</span>
             <span>}</span>,
             _ =&gt; <span>{}</span>
          <span>}</span>
        <span>}</span>

        <span>// We fill our window with red.</span>
        canvas.set_draw_color(Color::RGB(<span>255</span>, <span>0</span>, <span>0</span>));
        <span>// We draw it.</span>
        canvas.clear();

        <span>// The rectangle switch happens here:</span>
        <span>let</span> display_green = <span>match</span> timer.elapsed() <span>{</span>
            <span>Ok</span>(elapsed) =&gt; elapsed.as_secs() % <span>2</span> == <span>0</span>,
            <span>Err</span>(_) =&gt; <span>{</span>
                <span>// In case of error, we do nothing...</span>
                <span>true</span>
            <span>}</span>
        <span>}</span>;
        <span>let</span> square_texture = <span>if</span> display_green <span>{</span>
            &amp;green_square
        <span>}</span> <span>else</span> <span>{</span>
            &amp;blue_square
        <span>}</span>;
        <span>// Copy our texture into the window.</span>
        canvas.copy(square_texture,
           <span>None</span>,
            <span>// We copy it at the top-left of the window with a 32x32  <br class="calibre6"/>               size.</span>
            Rect::new(<span>0</span>, <span>0</span>, TEXTURE_SIZE, TEXTURE_SIZE))
            .expect(<span>"Couldn't copy texture into window"</span>);
           <span>// We update window's display.</span>
           canvas.present();

        <span>// We sleep enough to get ~60 fps. If we don't call this, <br class="calibre6"/>            the program will take</span>
        <span>// 100% of a CPU time.</span>
        sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
      <span>}</span>
<span>    }</span></pre></div>
<p class="calibre3">You can now see the small rectangle at the top-left switching color every second.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Loading images</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Uptill now, we've only created simple textures, but what about loading images instead?</p>
<p class="calibre3">Before trying to go through this, check whether you have installed the <kbd class="calibre14">SDL2_image</kbd> library (it's not included by default with the SDL2 library!). If not, you can install it by following the upcoming sections.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2_image on Mac</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Just run the following:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">$ <span>brew</span> install SDL2_image</strong></pre></div>
<p class="calibre3">And you're good to go!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2_image on Linux</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Depending on your package management tool, run the following to install <kbd class="calibre14">SDL2_image</kbd> on Linux:</p>
<p class="calibre3">For <kbd class="calibre14">apt package manager</kbd> use the following <span>command:</span></p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">    $ <span>sudo</span> apt-get install libsdl2-image-2.0-0-dev</strong></pre></div>
<p class="calibre3">For <kbd class="calibre14">dnf package manager</kbd> use the following command:</p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">    $ <span>sudo</span> dnf install SDL2_image-devel</strong></pre></div>
<p class="calibre3">For <kbd class="calibre14">yum package manager</kbd> <span>use the following command:</span></p>
<div class="title-page-name">
<pre class="calibre23"><strong class="calibre5">    $ <span>yum</span> install SDL2_image-devel</strong></pre></div>
<p class="calibre3">And you're good to go!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Installing SDL2_image on Windows</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">For the Windows platform, the simplest way is to go to <a href="https://www.libsdl.org/projects/SDL_image/" class="calibre13">https://www.libsdl.org/projects/SDL_image/</a> and download it.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Playing with features</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">By default, you can't use the <span><kbd class="calibre14">image</kbd></span> module with <span><kbd class="calibre14">sdl2</kbd></span>, we need to activate it. To do so, we need to update our <span><kbd class="calibre14">Cargo.toml</kbd></span> file by adding a new section as follows:</p>
<pre class="calibre23">    [features]
    default = ["sdl2/image"]</pre>
<p class="calibre3"><span><kbd class="calibre14">default</kbd></span> means that by default, the following features (<kbd class="calibre14">"sdl2/image"</kbd>) will be enabled. Now, let's explain what <kbd class="calibre14">"sdl2/image"</kbd> means; <kbd class="calibre14">sdl2</kbd> refers to the crate where we want to enable a feature and <kbd class="calibre14">image</kbd> is the feature we want to enable.</p>
<p class="calibre3">Of course, if you want to enable a feature on the current project, you don't need the <kbd class="calibre14">sdl2/</kbd> part. Consider the following example:</p>
<pre class="calibre23">    [features]
    network = []
    default = ["network"]</pre>
<p class="calibre3">As I am sure you understood, it's absolutely possible to chain features activation and even to activate multiple features at once! If you want to enable features depending on a version number, for example:</p>
<pre class="calibre23">    [features]
    network_v1 = []
    network_v2 = ["network_v1"]
    network_v3 = ["network_v2"]
    v1 = ["network_v1"]
    v2 = ["v1", "network_v2"]
    v3 = ["v2", "network_v3"]</pre>
<p class="calibre3">So if you enable the <span><kbd class="calibre14">v3</kbd></span> feature, all the others will be activated as well! It can be incredibly useful when you need to handle multiple versions at once.</p>
<p class="calibre3">Now let's go back to our images.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Playing with images</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Just like textures, we need to initialize the image context. Now that we've activated the <kbd class="calibre14">image</kbd> feature, we can call the linked functions and import them. Let's add some new imports:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> sdl2::image::<span>{</span>LoadTexture, INIT_PNG, INIT_JPG<span>}</span>;</pre></div>
<p class="calibre3">Then we create the image context:</p>
<div class="title-page-name">
<pre class="calibre23">    sdl2::image::init(INIT_PNG | INIT_JPG).expect(<span>"Couldn't initialize<br class="calibre6"/>         image context"</span>);</pre></div>
<p class="calibre3">Now that the context has been initialized, let's actually load the image:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> image_texture =  <br class="calibre6"/>     texture_creator.load_texture(<span>"assets/my_image.png"</span>)
         .expect(<span>"Couldn't load image"</span>);</pre></div>
<p class="calibre3">A few explanations for the preceding code:</p>
<p class="calibre3"><span><kbd class="calibre14">load_texture</kbd></span> takes a file path as an argument. Be very careful with paths, even more when they're relative!</p>
<p class="calibre3">After that, it's just like we did with other textures. Let's put our image into our Window's background:</p>
<div class="title-page-name">
<pre class="calibre23">    canvas.copy(&amp;Image_texture, <span>None</span>, <span>None</span>).expect(<span>"Render failed"</span>);</pre></div>
<p class="calibre3">To sum everything up, here's what your project's folder should look like now:</p>
<pre class="calibre23">|- your_project/
    |
    |- Cargo.toml
    |- src/
    |   |
    |   |- main.rs
    |- assets/
        |
        |- my_image.png</pre>
<p class="calibre3">And that's it!</p>
<p class="calibre3">Here's the full code in case you missed a step:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    extern</span> <span>crate</span> sdl2;
<span>    use</span> sdl2::pixels::Color;
<span>    use</span> sdl2::event::Event;
<span>    use</span> sdl2::keyboard::Keycode;
<span>    use</span> sdl2::render::TextureCreator;
<span>    use</span> sdl2::image::<span>{</span>LoadTexture, INIT_PNG, INIT_JPG<span>}</span>;
<span>    use</span> std::time::Duration;

<span>    pub</span> <span>fn</span> main() <span>{</span>
      <span>let</span> sdl_context = sdl2::init().expect(<span>"SDL initialization <br class="calibre6"/>       failed"</span>);
      <span>let</span> video_subsystem = sdl_context.video().expect(<span>"Couldn't <br class="calibre6"/>         get SDL video subsystem"</span>);

      sdl2::image::init(INIT_PNG | INIT_JPG).expect(<span>"Couldn't  <br class="calibre6"/>      initialize<br class="calibre6"/>        image context"</span>);

      <span>let</span> window = video_subsystem.window(<span>"rust-sdl2 image demo"</span>, <span>800</span>,  <br class="calibre6"/><span>        600</span>)
        .position_centered()
        .opengl()
        .build()
        .expect(<span>"Failed to create window"</span>);

      <span>let</span> <span>mut</span> canvas = window.into_canvas().build().expect(<span>"Failed to <br class="calibre6"/>        convert window into canvas"</span>);


      <span>let</span> texture_creator: TextureCreator&lt;_&gt; = <br class="calibre6"/>       canvas.texture_creator();
      <span>let</span> image_texture = <br class="calibre6"/>        texture_creator.load_texture(<span>"assets/my_image.png"</span>)
         .expect(<span>"Couldn't load image"</span>);

      <span>let</span> <span>mut</span> event_pump = sdl_context.event_pump().expect(<span>"Failed to<br class="calibre6"/>         get SDL event pump"</span>);

     <span>'running</span>: <span>loop</span> <span>{</span>
        <span>for</span> event <span>in</span> event_pump.poll_iter() <span>{</span>
            <span>match</span> event <span>{</span>
                Event::Quit <span>{</span> .. <span>}</span> |
                Event::KeyDown <span>{</span> keycode: <span>Some</span>(Keycode::Escape), .. <span>}</span> <br class="calibre6"/>             =&gt; <span>{</span>
                    <span>break</span> <span>'running</span>
                <span>}</span>,
                _ =&gt; <span>{}</span>
            <span>}</span>
        <span>}</span>
        canvas.set_draw_color(Color::RGB(<span>0</span>, <span>0</span>, <span>0</span>));
        canvas.clear();
        canvas.copy(&amp;image_texture, <span>None</span>, <span>None</span>).expect(<span>"Render <br class="calibre6"/>         failed"</span>);
        canvas.present();
        ::std::thread::sleep(Duration::new(<span>0</span>, <span>1_000_000_000u32</span> / <span>60</span>));
     <span>}</span>
<span>   }</span></pre></div>
<p class="calibre3">In my case, it gives the following output:</p>
<div class="mce-root1"><img src="../images/00011.jpeg" class="calibre41"/></div>
<div class="mce-root1"><em class="calibre21">Figure 2.6</em></div>
<p class="calibre3">Now that we know how to make Windows and play with events and textures, let's see how to save and load high scores from files!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Handling files</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">Let's start with the basics. First, let's open and write into a file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> std::fs::File;
<span>    use</span> std::io::<span>{</span><span>self</span>, Write<span>}</span>;

<span>    fn</span> write_into_file(content: &amp;<span>str</span>, file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span>
      <span>let</span> <span>mut</span> f = File::create(file_name)?;
      f.write_all(content.as_bytes())
<span>    }</span></pre></div>
<p class="calibre3">Now let's explain this code:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> std::fs::File;</pre></div>
<p class="calibre3">Nothing fancy, we just import the <span><kbd class="calibre14">File</kbd></span> type:</p>
<div class="title-page-name">
<pre class="calibre23"><span>   use</span> std::io::<span>{</span><span>self</span>, Write<span>}</span>;</pre></div>
<p class="calibre3">This set of imports is more interesting: we import the <span><kbd class="calibre14">io</kbd></span> module (<span><kbd class="calibre14">self</kbd></span>) and the <span><kbd class="calibre14">Write</kbd></span> trait. For the second, if we didn't import it, we wouldn't be able to use the <span><kbd class="calibre14">write_all</kbd></span> method (because you need to import a trait to use its methods):</p>
<div class="title-page-name">
<pre class="calibre23"><span>   fn</span> write_into_file(content: &amp;<span>str</span>, file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;()&gt; <span>{</span></pre></div>
<p class="calibre3">We declared a function named <span><kbd class="calibre14">write_into_file</kbd></span> that takes a filename and the content you want to write into the file as arguments. (Note that the file will be overwritten by this content!) It returns an <span><kbd class="calibre14">io::Result</kbd></span> type. It is an alias over the normal <span><kbd class="calibre14">Result</kbd></span> type (its documentation is at <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html" class="calibre13">https://doc.rust-lang.org/stable/std/result/enum.Result.html</a>) declared as follows:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    type</span> Result&lt;T&gt; = <span>Result</span>&lt;T, Error&gt;;</pre></div>
<p class="calibre3">The only difference is that in case of error, the error type is already defined.</p>
<div class="packt_tip">I recommend that you to take a look at its documentation in case you want to go further, at <a href="https://doc.rust-lang.org/stable/std/io/type.Result.html" class="calibre38">https://doc.rust-lang.org/stable/std/io/type.Result.html</a>.</div>
<p class="calibre3">So if our function worked without errors, it'll return <span><kbd class="calibre14">Ok(())</kbd></span>; it's the <span><kbd class="calibre14">Ok</kbd></span> variant containing an empty tuple which is considered the Rust equivalent of the <span><kbd class="calibre14">void</kbd></span> type. In case of error, it'll contain an <span><kbd class="calibre14">io::Error</kbd></span>, and it'll be up to you to handle it (or not). We'll come back to error handling a bit later.</p>
<p class="calibre3">Now let's look at the next line:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> f = File::create(file_name)?;</pre></div>
<p class="calibre3">Here, we call the static method <span><kbd class="calibre14">create</kbd></span> of the <span><kbd class="calibre14">File</kbd></span> type. If the file exists, it'll be truncated and if it doesn't, it'll be created. More information about this method can be found at <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create" class="calibre13">https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create</a>.</p>
<p class="calibre3">Now let's look at this strange <kbd class="calibre14">?</kbd> symbol. It's a syntactic sugar over the <span><kbd class="calibre14">try!</kbd></span> macro. The <span><kbd class="calibre14">try!</kbd></span> macro is very simple to understand and its code can be resumed as this:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    match</span> result <span>{</span>
      <span>Ok</span>(value) =&gt; value,
     <span>Err</span>(error) =&gt; <span>return</span> <span>Err</span>(error),
<span>    }</span></pre></div>
<p class="calibre3">So that's pretty easy, but annoying to rewrite over and over, so the Rust teams decided to first introduce the <span><kbd class="calibre14">try!</kbd></span> macro and then after a long consensus, decided to add the <span><kbd class="calibre14">?</kbd></span> syntactic sugar over it (it also works with the <kbd class="calibre14">Option</kbd> type). However, both code pieces are still working, so you can perfectly do as well:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> std::fs::File;
<span>    use</span> std::io::<span>{</span><span>self</span>, Write<span>}</span>;

<span>    fn</span> write_into_file(content: &amp;<span>str</span>, file_name: &amp;<span>str</span>) -&gt; <br class="calibre6"/>    io::<span>Result</span>&lt;()&gt; <span>{</span>
      <span>let</span> <span>mut</span> f = <span>try!</span>(File::create(file_name));
      f.write_all(content.as_bytes())
<span>    }</span></pre></div>
<p class="calibre3">It's exactly the same. Alternatively, you can write the full version too:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> std::fs::File;
<span>    use</span> std::io::<span>{</span><span>self</span>, Write<span>}</span>;

<span>   fn</span> write_into_file(content: &amp;<span>str</span>, file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;()&gt;   <br class="calibre6"/><span>   {</span>
     <span>let</span> <span>mut</span> f = <span>match</span> File::create(file_name) <span>{</span>
        <span>Ok</span>(value) =&gt; value,
        <span>Err</span>(error) =&gt; <span>return</span> <span>Err</span>(error),
     <span>}</span>;
     f.write_all(content.as_bytes())
<span>   }</span></pre></div>
<p class="calibre3">It's up to you, but now you know what options you have!</p>
<p class="calibre3">Now let's check the last line:</p>
<div class="title-page-name">
<pre class="calibre23">    f.write_all(content.as_bytes())</pre></div>
<p class="calibre3">Nothing fancy here; we write all our data into the file. We just need to convert (it's not really a conversion in this case, more like getting internal data) our <span><kbd class="calibre14">&amp;str</kbd></span> into a slice of <span><kbd class="calibre14">u8</kbd></span> (so a <span><kbd class="calibre14">&amp;[u8]</kbd></span>).</p>
<p class="calibre3">Now that we have a function to write a file, it'd be nice to be able to read from a file as well:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    use</span> std::fs::File;
<span>    use</span> std::io::<span>{</span><span>self</span>, Read<span>}</span>;

<span>    fn</span> read_from_file(file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;<span>String</span>&gt; <span>{</span>
      <span>let</span> <span>mut</span> f = File::open(file_name)?;
      <span>let</span> <span>mut</span> content = <span>String</span>::new();
      f.read_to_string(&amp;<span>mut</span> content)?;
      <span>Ok</span>(content)
<span>    }</span></pre></div>
<p class="calibre3">Now let's go over what this function does quickly:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> read_from_file(file_name: &amp;<span>str</span>) -&gt; io::<span>Result</span>&lt;<span>String</span>&gt; <span>{</span></pre></div>
<p class="calibre3">This time, it only takes a filename as an argument and returns a <span><kbd class="calibre14">String</kbd></span> if the reading was successful:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> f = File::open(file_name)?;
<span>    let</span> <span>mut</span> content = <span>String</span>::new();
    f.read_to_string(&amp;<span>mut</span> content)?;</pre></div>
<p class="calibre3">Just like before, we open the file. Then we create a mutable <span><kbd class="calibre14">String</kbd></span> where the file content will be stored and finally we read all the file content at once with the <span><kbd class="calibre14">read_to_string</kbd></span> method (the <span><kbd class="calibre14">String</kbd></span> is reallocated as many times as needed). This method will fail if the string isn't proper UTF-8.</p>
<p class="calibre3">And to finish, if everything went fine, we return our content:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    Ok</span>(content)</pre></div>
<p class="calibre3">So now, let's see how we can use this in our future tetris.</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Saving/loading high scores</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">To keep things simple, we'll have a very simple file format:</p>
<ul class="calibre10">
<li class="calibre11">On the first line, we store the best scores</li>
<li class="calibre11">On the second line, we store the highest number of lines</li>
</ul>
<p class="calibre3">Let's start by writing the <span><kbd class="calibre14">save</kbd></span> function:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> slice_to_string(slice: &amp;<span>[</span><span>u32</span><span>]</span>) -&gt; <span>String</span> <span>{</span>
      slice.iter().map(|highscore| highscore.to_string()).<br class="calibre6"/>        collect::&lt;<span>Vec</span>&lt;<span>String</span>&gt;&gt;().join(<span>" "</span>)
<span>    }</span>

<span>    fn</span> save_highscores_and_lines(highscores: &amp;<span>[</span><span>u32</span><span>]</span>, <br class="calibre6"/>       number_of_lines: &amp;<span>[</span><span>u32</span><span>]</span>) -&gt; <span>bool</span> <span>{</span>
      <span>let</span> s_highscores = slice_to_string(highscores);
      <span>let</span> s_number_of_lines = slice_to_string(number_of_lines);
      write_into_file(<span>format!</span>(<span>"{}</span><span>\n</span><span>{}</span><span>\n</span><span>"</span>, s_highscores, <br class="calibre6"/>         s_number_of_lines)).is_ok()
<span>    }</span></pre></div>
<p class="calibre3">It was a small lie: there are actually two functions. The first one is just here to make the code smaller and easier to read even though we need to explain what it does, because we're about to talk about a big feature from Rust—<strong class="calibre5">iterators</strong>!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Iterators</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">The Rust documentation describes an iterator as <em class="calibre21">Composable external iteration.</em></p>
<p class="calibre3">They're used a lot in idiomatic Rust code on collection types (<span><kbd class="calibre14">slice</kbd></span>, <span><kbd class="calibre14">Vec</kbd></span>, <span><kbd class="calibre14">HashMap</kbd></span>, and so on) so it's very important to learn to master them. This code will allow us to have a nice introduction. Let's look at the code now:</p>
<div class="title-page-name">
<pre class="calibre23">    slice.iter().map(|highscore| highscore.to_string()).<br class="calibre6"/>      collect::&lt;<span>Vec</span>&lt;<span>String</span>&gt;&gt;().join(<span>" "</span>)</pre></div>
<p class="calibre3">This is quite difficult to read and understand for the moment, so let's rewrite it as follows:</p>
<div class="title-page-name">
<pre class="calibre23">    slice.iter()
       .map(|highscore| highscore.to_string())
       .collect::&lt;<span>Vec</span>&lt;<span>String</span>&gt;&gt;()
       .join(<span>" "</span>)</pre></div>
<p class="calibre3">Better (or at least more readable<span>!</span>). Now let's go step by step, as follows:</p>
<div class="title-page-name">
<pre class="calibre23">     slice.iter()</pre></div>
<p class="calibre3">Here, we create an iterator from our slice. A really important and fundamental thing to note about iterators in Rust; they're lazy. Creating an iterator doesn't cost anything more than the size of the type (generally a structure containing a pointer and an index). Until the <span><kbd class="calibre14">next()</kbd></span> method is called, nothing happens.</p>
<p class="calibre3">So now we have an iterator, awesome! Let's check the next step:</p>
<div class="title-page-name">
<pre class="calibre23">    .map(|highscore| highscore.to_string())</pre></div>
<p class="calibre3">We call the iterator's <span><kbd class="calibre14">map</kbd></span> method. What it does is simple: it converts the current type into another one. So here, we convert a <span><kbd class="calibre14">u32</kbd></span> into a <span><kbd class="calibre14">String</kbd></span>.</p>
<p class="calibre3">Really important to note: at this point, the iterator still hasn't done anything. Keep in mind that nothing is done until the <span><kbd class="calibre14">next()</kbd></span> method is called!</p>
<div class="title-page-name">
<pre class="calibre23">    .collect::&lt;<span>Vec</span>&lt;<span>String</span>&gt;&gt;()</pre></div>
<p class="calibre3">And now we call the <span><kbd class="calibre14">collect()</kbd></span> method. It'll call the <span><kbd class="calibre14">next()</kbd></span> method of our iterator as long as it didn't get all elements and store them into a <span><kbd class="calibre14">Vec</kbd></span>. This is where the <span><kbd class="calibre14">map()</kbd></span> method will be called on every element of our iterator.</p>
<p class="calibre3">And finally the last step:</p>
<div class="title-page-name">
<pre class="calibre23">    .join(<span>" "</span>)</pre></div>
<p class="calibre3">This method (as its name indicates) joins all the elements of the <span><kbd class="calibre14">Vec</kbd></span> into a <span><kbd class="calibre14">String</kbd></span> separated by the given <span><kbd class="calibre14">&amp;str</kbd></span> (so, <kbd class="calibre14">" "</kbd> in our case).</p>
<p class="calibre3">Finally, if we give <span><kbd class="calibre14">&amp;[1, 14, 5]</kbd></span> to the <span><kbd class="calibre14">slice_to_string</kbd></span> function, it'll return a <span><kbd class="calibre14">String</kbd></span> containing <kbd class="calibre14">"1 14 5"</kbd>. Pretty convenient, right?</p>
<div class="packt_infobox">If you want to go a bit deeper with the iterators, you can take a look at the blog post at <a href="https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust" class="calibre38">https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust</a> or directly take a look at the iterator official documentation at <a href="https://doc.rust-lang.org/stable/std/iter/index.html" class="calibre38">https://doc.rust-lang.org/stable/std/iter/index.html</a>.</div>
<p class="calibre3">It's time to go back to our saving function:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> save_highscores_and_lines(highscores: &amp;<span>[</span><span>u32</span><span>]</span>, <br class="calibre6"/>        number_of_lines: &amp;<span>[</span><span>u32</span><span>]</span>) -&gt; <span>bool</span> <span>{</span>
      <span>let</span> s_highscores = slice_to_string(highscores);
      <span>let</span> s_number_of_lines = slice_to_string(number_of_lines);
      write_into_file(<span>format!</span>(<span>"{}</span><span>\n</span><span>{}</span><span>\n</span><span>"</span>, s_highscores, <br class="calibre6"/>         s_number_of_lines), <span>"scores.txt"</span>).is_ok()
<span>    }</span></pre></div>
<p class="calibre3">Once we have converted our slices to <span><kbd class="calibre14">String</kbd></span>, we write them into the <span><kbd class="calibre14">scores.txt</kbd></span> file. The <span><kbd class="calibre14">is_ok()</kbd></span> method call just informs the caller of the <span><kbd class="calibre14">save_highscores_and_lines()</kbd></span> function if everything has been saved as expected or not.</p>
<p class="calibre3">Now that we can save scores, it'd be nice to be able to get them back when the tetris game is starting!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Reading formatted data from files</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">As you will certainly have guessed at this point, we'll use iterators once again. This is what the loading function will look like:</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> line_to_slice(line: &amp;<span>str</span>) -&gt; <span>Vec</span>&lt;<span>u32</span>&gt; <span>{</span>
    line.split(<span>" "</span>).filter_map(|nb| nb.parse::&lt;<span>u32</span>&gt;().ok()).collect()
<span>}</span>

<span>fn</span> load_highscores_and_lines() -&gt; <span>Option</span>&lt;(<span>Vec</span>&lt;<span>u32</span>&gt;, <span>Vec</span>&lt;<span>u32</span>&gt;)&gt; <span>{</span>
<span>    if</span> <span>let</span> <span>Ok</span>(content) = read_from_file(<span>"scores.txt"</span>) <span>{</span>
        <span>let</span> <span>mut</span> lines = content.splitn(<span>2</span>, <span>"</span><span>\n</span><span>"</span>).map(|line| <br class="calibre6"/>           line_to_slice(line)).collect::&lt;<span>Vec</span>&lt;_&gt;&gt;();
<span>        if</span> lines.len() == <span>2</span> <span>{</span>
            <span>let</span> (number_lines, highscores) = (lines.pop().unwrap(), <br class="calibre6"/>             lines.pop().unwrap());
            <span>Some</span>((highscores, number_lines))
        <span>}</span> <span>else</span> <span>{</span>
         <span>None</span>
        <span>}</span>
<span>    }</span> <span>else</span> <span>{</span>
        <span>None</span>
    <span>}<br class="calibre6"/></span><span>}</span></pre></div>
<p class="calibre3">Once again, not easy to understand, at first sight. So let's explain all this!</p>
<div class="title-page-name">
<pre class="calibre22"><span>fn</span> line_to_slice(line: &amp;<span>str</span>) -&gt; <span>Vec</span>&lt;<span>u32</span>&gt; <span>{</span></pre></div>
<p class="calibre3">Our <span><kbd class="calibre14">line_to_slice()</kbd></span> function does the opposite of <span><kbd class="calibre14">slice_to_string()</kbd></span>; it transforms a <span><kbd class="calibre14">&amp;str</kbd></span> into a slice of <span><kbd class="calibre14">u32</kbd></span> (or <span><kbd class="calibre14">&amp;[u32]</kbd></span>). Let's see the iterator now:</p>
<div class="title-page-name">
<pre class="calibre23">    line.split(<span>" "</span>).filter_map(|nb| nb.parse::&lt;<span>u32</span>&gt;().ok()).collect()</pre></div>
<p class="calibre3">Just like last time, let's split the calls:</p>
<div class="title-page-name">
<pre class="calibre23">    line.split(<span>" "</span>)
      .filter_map(|nb| nb.parse::&lt;<span>u32</span>&gt;().ok())
      .collect()</pre></div>
<p class="calibre3">A bit better! Now let's explain:</p>
<div class="title-page-name">
<pre class="calibre23">     line.split(<span>" "</span>)</pre></div>
<p class="calibre3">We create an iterator that will contain all strings between spaces. So <kbd class="calibre14">a b</kbd> will contain <kbd class="calibre14">a</kbd> and <kbd class="calibre14">b</kbd>:</p>
<div class="title-page-name">
<pre class="calibre23">    .filter_map(|nb| nb.parse::&lt;<span>u32</span>&gt;().ok())</pre></div>
<p class="calibre3">This method is particularly interesting since it's the merge of two others: <span><kbd class="calibre14">filter()</kbd></span> and <span><kbd class="calibre14">map()</kbd></span>. We already know <span><kbd class="calibre14">map()</kbd></span> but what about <span><kbd class="calibre14">filter()</kbd></span>? If the condition isn't verified (so if the returned value of the closure is <span><kbd class="calibre14">false</kbd></span>), the iterator won't pass the value to the next method call. <span><kbd class="calibre14">filter_map()</kbd></span> works the same at this point: if the closure returns <span><kbd class="calibre14">None</kbd></span>, the value won't be passed to the next method call.</p>
<p class="calibre3">Now let's focus on this part:</p>
<div class="title-page-name">
<pre class="calibre23">    nb.parse::&lt;<span>u32</span>&gt;().ok()</pre></div>
<p class="calibre3">Here, we try to convert <span><kbd class="calibre14">&amp;str</kbd></span> into <span><kbd class="calibre14">u32</kbd></span>. The <span><kbd class="calibre14">parse()</kbd></span> method returns a <span><kbd class="calibre14">Result</kbd></span> but the <span><kbd class="calibre14">filter_map()</kbd></span> expects an <span><kbd class="calibre14">Option</kbd></span> so we need to convert it. That's what the <span><kbd class="calibre14">ok()</kbd></span> method is for! If your <span><kbd class="calibre14">Result</kbd></span> is an <span><kbd class="calibre14">Ok(value)</kbd></span>, then it'll convert it into a <span><kbd class="calibre14">Some(value)</kbd></span>. However, if it's an <span><kbd class="calibre14">Err(err)</kbd></span>, it'll convert it into a <span><kbd class="calibre14">None</kbd></span> (but you'll lose the error value).</p>
<p class="calibre3">To sum this up, this whole line tries to convert a <span><kbd class="calibre14">&amp;str</kbd></span> into a number and ignores it if the conversion fails so it's not added to our final <span><kbd class="calibre14">Vec</kbd></span>. Amazing how much we can do with such small code!</p>
<p class="calibre3">And finally:</p>
<div class="title-page-name">
<pre class="calibre23">    .collect()</pre></div>
<p class="calibre3">We <span><kbd class="calibre14">collect</kbd></span> all the successful conversions into a <span><kbd class="calibre14">Vec</kbd></span> and return it.</p>
<p class="calibre3">That's it for this function, now let's look at the other one:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    fn</span> load_highscores_and_lines() -&gt; <span>Option</span>&lt;(<span>Vec</span>&lt;<span>u32</span>&gt;, <span>Vec</span>&lt;<span>u32</span>&gt;)&gt; <span>{</span></pre></div>
<p class="calibre3">Here, if everything went fine (if the file exists and has two lines), we return an <span><kbd class="calibre14">Option</kbd></span> containing in the first position the highest scores and in the second position the highest number of lines:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    if</span> <span>let</span> <span>Ok</span>(content) = read_from_file(<span>"scores.txt"</span>) <span>{</span></pre></div>
<p class="calibre3">So if the file exists and we can get its content, we parse the data:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> lines = content.splitn(<span>2</span>, <span>"</span><span>\n</span><span>"</span>).map(|line| <br class="calibre6"/>       line_to_slice(line)).collect::&lt;<span>Vec</span>&lt;_&gt;&gt;();</pre></div>
<p class="calibre3">Another iterator! As usual, let's rewrite it a bit:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> <span>mut</span> lines = content.splitn(<span>2</span>, <span>"</span><span>\n</span><span>"</span>)
         .map(|line| line_to_slice(line))
         .collect::&lt;<span>Vec</span>&lt;_&gt;&gt;();</pre></div>
<p class="calibre3">I think you're starting to get how they work, but just in case you don't know, here's how:</p>
<div class="title-page-name">
<pre class="calibre23">    content.splitn(<span>2</span>, <span>"</span><span>\n</span><span>"</span>)</pre></div>
<p class="calibre3">We make an iterator containing at most two entries (because of the <span><kbd class="calibre14">2</kbd></span> as the first argument) splitting lines:</p>
<div class="title-page-name">
<pre class="calibre23">    .map(|line| line_to_slice(line))</pre></div>
<p class="calibre3">We transform each line into a <span><kbd class="calibre14">Vec&lt;u32&gt;</kbd></span> by using the function described in the preceding code:</p>
<div class="title-page-name">
<pre class="calibre23">    .collect::&lt;<span>Vec</span>&lt;_&gt;&gt;();</pre></div>
<p class="calibre3">And finally, we collect those <span><kbd class="calibre14">Vec</kbd></span>s into a <span><kbd class="calibre14">Vec&lt;Vec&lt;u32&gt;&gt;</kbd></span>, which should only contain two entries.</p>
<p class="calibre3">Let's look at the next line now:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    if</span> lines.len() == <span>2</span> <span>{</span></pre></div>
<p class="calibre3">As said before, if we don't have two entries inside our <span><kbd class="calibre14">Vec</kbd></span>, it means something is wrong with the file:</p>
<div class="title-page-name">
<pre class="calibre23"><span>    let</span> (number_lines, highscores) = (lines.pop().unwrap(), <br class="calibre6"/>        lines.pop().unwrap());</pre></div>
<p class="calibre3">In case our <span><kbd class="calibre14">Vec</kbd></span> has two entries, we can get the corresponding values. Since the <kbd class="calibre14">pop</kbd> method removes the last entry of the <span><kbd class="calibre14">Vec</kbd></span>, we get them in reverse (even though we return high scores first then the highest number of lines):</p>
<div class="title-page-name">
<pre class="calibre23"><span>    Some</span>((highscores, number_lines))</pre></div>
<p class="calibre3"/>
<p class="calibre3">Then everything else is just the error handling. As we said previously, if any error occurs, we return <span><kbd class="calibre14">None</kbd></span>. In this case, it's not really important to handle the error since it's just high scores. If we have errors with the <span><kbd class="calibre14">sdl</kbd></span> libraries, nothing will work as expected, so we need to handle them to avoid a panic.</p>
<p class="calibre3">It's now time to really start the game!</p>


            </article>

            
        </section>
    

        <section class="calibre1">

                            <header class="calibre1">
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article class="calibre1">
                
<p class="calibre3">In this chapter, we saw a lot of important things like how to use <kbd class="calibre14">Cargo</kbd> (through the <kbd class="calibre14">Cargo.toml</kbd> file), how to import new crates into a project, thanks to <kbd class="calibre14">Cargo</kbd>, and the basics for Rust modules handling. We even covered how to use iterators and read and write files, <kbd class="calibre14">SDL2</kbd> basics like how to create a window and fill it with colors, and loading/creating new textures and images (thanks to the <kbd class="calibre14">SDL2-image</kbd> library!).</p>
<p class="calibre3">In <a target="_blank" href="part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 3</a>, <em class="calibre21">Events and Basic Game Mechanisms</em>, we'll start the implementation of the tetris game, so be sure to master everything explained in this chapter before starting the next one!</p>


            </article>

            
        </section>
    </body></html>