<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting with SDL</h1>
                
            
            
                
<p class="calibre3">Before starting to write the Tetris, a few things remain to be talked about, such as crates, which we'll be using a lot (and you'll be using a lot as well once you're <em class="calibre21">rusting</em> on your own!). Let's start with crates!<br class="calibre6"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Understanding Rust crates</h1>
                
            
            
                
<p class="calibre3">In Rust, packages (both binaries and libraries) are named crates. You can find a lot of them on <kbd class="calibre14">crates.io</kbd>. Today, we'll use the SDL2 crate in order to make our tetris, but before even thinking about this, we need to install the <kbd class="calibre14">SDL2</kbd> library that is used by the <kbd class="calibre14">SDL2</kbd> crate!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2</h1>
                
            
            
                
<p class="calibre3">Before going any further, we need to install the SDL library.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2 on Linux</h1>
                
            
            
                
<p class="calibre3">Depending on your package management tool, run the following to install SDL2 on Linux:</p>
<p class="calibre3"><kbd class="calibre14">apt package mananger</kbd>:</p>
<div><pre class="calibre23"><strong class="calibre5">$ sudo apt-get install libsdl2-dev</strong></pre></div>
<p class="calibre3"><kbd class="calibre14">dnf package manager</kbd>:</p>
<div><pre class="calibre23"><strong class="calibre5">$ sudo dnf install SDL2-devel</strong></pre></div>
<p class="calibre3">yum package manager:</p>
<div><pre class="calibre23"><strong class="calibre5">$ yum install SDL2-devel</strong></pre></div>
<p class="calibre3">Once done, your SDL2 installation is ready!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2 on Mac</h1>
                
            
            
                
<p class="calibre3">To install SDL2 on Mac, Simply run the following:</p>
<div><pre class="calibre23"><strong class="calibre5">$ brew install sdl2</strong></pre></div>
<p class="calibre3">You're good to go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2 on Windows</h1>
                
            
            
                
<p class="calibre3">All these installation instructions come directly from the Rust SDL2 crate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Windows with Build Script</h1>
                
            
            
                
<p class="calibre3">A few steps will be required in order to make all of it work. Follow the guide!</p>
<ol class="calibre16">
<li value="1" class="calibre11">Download the <kbd class="calibre14">mingw</kbd> and <kbd class="calibre14">msvc</kbd> development libraries from <a href="http://www.libsdl.org/" class="calibre13">http://www.libsdl.org/</a> (<kbd class="calibre14">SDL2-devel-2.0.x-mingw.tar.gz</kbd> and <kbd class="calibre14">SDL2-devel-2.0.x-VC.zip</kbd>).</li>
<li value="2" class="calibre11">Unpack to folders of your choice. (You can delete it afterward.)</li>
<li value="3" class="calibre11">Create the following folder structure in the same folder as your <kbd class="calibre14">Cargo.toml</kbd>:</li>
</ol>
<pre class="calibre23">        gnu-mingw\dll\32
        gnu-mingw\dll\64
        gnu-mingw\lib\32
        gnu-mingw\lib\64
        msvc\dll\32
        msvc\dll\64
        msvc\lib\32
        msvc\lib\64</pre>
<ol start="4" class="calibre16">
<li value="4" class="calibre11">Copy the <kbd class="calibre14">lib</kbd> and <kbd class="calibre14">dll</kbd> files from the source archive to the directories we created in step 3 as follows:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\i686-w64-mingw32\bin    -&gt;     gnu-mingw\dll\32
SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\x86_64-w64-mingw32\bin  -&gt;     gnu-mingw\dll\64
SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\i686-w64-mingw32\lib    -&gt;     gnu-mingw\lib\32
SDL2-devel-2.0.x-mingw.tar.gz\SDL2-2.0.x\x86_64-w64-mingw32\lib  -&gt;     gnu-mingw\lib\64
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x86\*.dll                 -&gt;     msvc\dll\32
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x64\*.dll                 -&gt;     msvc\dll\64
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x86\*.lib                 -&gt;     msvc\lib\32
SDL2-devel-2.0.5-VC.zip\SDL2-2.0.x\lib\x64\*.lib                 -&gt;     msvc\lib\64</strong></pre>
<ol start="5" class="calibre16">
<li value="5" class="calibre11">Create a Build Script. If you don't already have one, put this in your <kbd class="calibre14">Cargo.toml</kbd> file under <kbd class="calibre14">[package]</kbd>:</li>
</ol>
<pre class="calibre23">        build = "build.rs"</pre>
<ol start="6" class="calibre16">
<li value="6" class="calibre11">Create a file in the same directory as <kbd class="calibre14">Cargo.toml</kbd> called <kbd class="calibre14">build.rs</kbd> and write this into it:</li>
</ol>
<div><pre class="calibre23">      use std::env;
      use std::path::PathBuf;

      fn main() {
        let target = env::var("TARGET").unwrap();
        if target.contains("pc-windows") {
          let manifest_dir = <br class="calibre6"/>            PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
          let mut lib_dir = manifest_dir.clone();
        let mut dll_dir = manifest_dir.clone();
        if target.contains("msvc") {
            lib_dir.push("msvc");
            dll_dir.push("msvc");
        } else {
            lib_dir.push("gnu-mingw");
            dll_dir.push("gnu-mingw");
        }
        lib_dir.push("lib");
        dll_dir.push("dll");
        if target.contains("x86_64") {
            lib_dir.push("64");
            dll_dir.push("64");
        } else {
            lib_dir.push("32");
            dll_dir.push("32");
        }
        println!("cargo:rustc-link-search=all={}", <br class="calibre6"/>          lib_dir.display());
        for entry in std::fs::read_dir(dll_dir).expect("Can't<br class="calibre6"/>          read DLL dir")  {
         let entry_path = entry.expect("Invalid fs entry").path();
         let file_name_result = entry_path.file_name();
         let mut new_file_path = manifest_dir.clone();
         if let Some(file_name) = file_name_result {
           let file_name = file_name.to_str().unwrap();
           if file_name.ends_with(".dll") {
             new_file_path.push(file_name);
           std::fs::copy(&amp;entry_path,<br class="calibre6"/>           new_file_path.as_path()).expect("Can't copy <br class="calibre6"/>             from DLL dir");
           }
         }
        }
        }
      }</pre></div>
<ol start="7" class="calibre16">
<li value="7" class="calibre11">On build, the Build Script will copy the needed DLLs into the same directory as your <kbd class="calibre14">Cargo.toml</kbd> file. You probably don't want to commit these to any Git repositories though, so add the following line to your <kbd class="calibre14">.gitignore</kbd> file:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">        /*.dll</strong></pre>
<ol start="8" class="calibre16">
<li value="8" class="calibre11">When you're shipping your game, make sure that you copy the corresponding <kbd class="calibre14">SDL2.dll</kbd> to the same directory that your compiled <kbd class="calibre14">exe</kbd> is in; otherwise, the game won't launch.</li>
</ol>
<p class="calibre3">And now your project should build and run on any Windows computer!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Windows (MinGW)</h1>
                
            
            
                
<p class="calibre3">A few steps will be required in order to make all of it work. Follow the guide!</p>
<ol class="calibre16">
<li value="1" class="calibre11">Download <kbd class="calibre14">mingw</kbd> development libraries from <a href="http://www.libsdl.org/" class="calibre13">http://www.libsdl.org/</a> (<kbd class="calibre14">SDL2-devel-2.0.x-mingw.tar.gz</kbd>).</li>
<li value="2" class="calibre11">Unpack to a folder of your choice. (You can delete it afterward.)</li>
</ol>
<p class="calibre3"> </p>
<ol start="3" class="calibre16">
<li value="3" class="calibre11">Copy all <kbd class="calibre14">lib</kbd> files from the following path:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">     SDL2-devel-2.0.x-mingw\SDL2-2.0.x\x86_64-w64-mingw32\lib</strong></pre>
<p class="calibre33">Next, copy it to this path:</p>
<pre class="calibre23"><strong class="calibre5">    C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-gnu\lib</strong></pre>
<p class="calibre33">Alternately, you can copy to your library folder of choice and ensure that you have a system environment variable as follows:</p>
<pre class="calibre23"><strong class="calibre5">    LIBRARY_PATH = C:\your\rust\library\folder</strong></pre>
<p class="calibre33">For Rustup users, this folder will be at the following location:</p>
<pre class="calibre23"><strong class="calibre5">      C:\Users\{Your Username}.multirust\toolchains\{current<br class="calibre6"/>         toolchain}\lib\</strong><strong class="calibre5">rustlib\{current toolchain}\lib</strong></pre>
<p class="calibre33">Here, the current toolchain is probably <kbd class="calibre14">stable-x86_64-pc-windows-gnu</kbd>.</p>
<ol start="4" class="calibre16">
<li value="4" class="calibre11">Copy <kbd class="calibre14">SDL2.dll</kbd> from the following:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">     SDL2-devel-2.0.x-mingw\SDL2-2.0.x\x86_64-w64-mingw32\bin</strong></pre>
<p class="calibre33">The copied <kbd class="calibre14">SDL2.dll</kbd> is pasted into your cargo project, right next to your <kbd class="calibre14">Cargo.toml</kbd>.</p>
<ol start="5" class="calibre16">
<li value="5" class="calibre11">When you're shipping your game, make sure that you copy <kbd class="calibre14">SDL2.dll</kbd> to the same directory that your compiled <kbd class="calibre14">exe</kbd> is in; otherwise, the game won't launch.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Windows (MSVC)</h1>
                
            
            
                
<p class="calibre3">A few steps will be required in order to make all of it work. Follow the guide!</p>
<ol class="calibre16">
<li value="1" class="calibre11">Download MSVC development libraries from <a href="http://www.libsdl.org/" class="calibre13">http://www.libsdl.org/</a> <kbd class="calibre14">SDL2-devel-2.0.x-VC.zip</kbd>.</li>
<li value="2" class="calibre11">Unpack <kbd class="calibre14">SDL2-devel-2.0.x-VC.zip</kbd> to a folder of your choice. (You can delete it afterward.)</li>
<li value="3" class="calibre11">Copy all <kbd class="calibre14">lib</kbd> files from the following path:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">      SDL2-devel-2.0.x-VC\SDL2-2.0.x\lib\x64\</strong></pre>
<p class="calibre33">The <kbd class="calibre14">lib</kbd> files will be pasted here:</p>
<pre class="calibre23"><strong class="calibre5">     C:\Program Files\Rust\lib\rustlib\x86_64-pc-windows-msvc\lib</strong></pre>
<p class="calibre33">Alternatively, they'll be pasted to your library folder of choice. Ensure that you have a system environment variable with the following:</p>
<pre class="calibre23"><strong class="calibre5">      LIB = C:\your\rust\library\folder</strong></pre>
<p class="calibre33">Here, the current toolchain is probably <kbd class="calibre14">stable-x86_64-pc-windows-msvc</kbd>.</p>
<ol start="4" class="calibre16">
<li value="4" class="calibre11">Copy <kbd class="calibre14">SDL2.dll</kbd> from the following code snippet:</li>
</ol>
<pre class="calibre23"><strong class="calibre5">      SDL2-devel-2.0.x-VC\SDL2-2.0.x\lib\x64\</strong></pre>
<p class="calibre34">The copied <kbd class="calibre14">SDL2.dll</kbd> is pasted into your cargo project, right next to your <kbd class="calibre14">Cargo.toml</kbd>.</p>
<ol start="5" class="calibre16">
<li value="5" class="calibre11">When you're shipping your game, make sure that you copy <kbd class="calibre14">SDL2.dll</kbd> to the same directory that your compiled <kbd class="calibre14">exe</kbd> is in; otherwise, the game won't launch.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Setting up your Rust project</h1>
                
            
            
                
<p class="calibre3">The Rust package manager, <kbd class="calibre14">cargo</kbd>, allows us to create a new project very easily with just one command, <kbd class="calibre14">cargo new</kbd>. Let's run it as follow:</p>
<div><pre class="calibre23"><strong class="calibre5">  cargo new tetris --bin</strong></pre></div>
<p class="calibre3">You should have a new folder <kbd class="calibre14">tetris</kbd> containing the following:</p>
<pre class="calibre23">     tetris/
     |
     |- Cargo.toml
     |- src/
         |
         |- main.rs</pre>
<p class="calibre3">Note that if you ran <kbd class="calibre14">cargo new</kbd> without the <kbd class="calibre14">--bin</kbd> flag, then you will have a <kbd class="calibre14">lib.rs</kbd> file instead of <kbd class="calibre14">main.rs</kbd>.</p>
<p class="calibre3">Now write this into your <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre23">    [package]
    name = "tetris"
    version = "0.0.1"

    [dependencies]
    sdl2 = "0.30.0"</pre>
<p class="calibre3">Here, we declare that our project's name is <kbd class="calibre14">tetris</kbd>, its version is <kbd class="calibre14">0.0.1</kbd> (it isn't really important at the moment), and that it has a dependency on the <kbd class="calibre14">sdl2</kbd> crate.</p>
<p class="calibre3">For the versioning, <kbd class="calibre14">Cargo</kbd> follows <strong class="calibre5">SemVer</strong> (<strong class="calibre5">Semantic Versioning</strong>). It works as follows:</p>
<p class="calibre3"><kbd class="calibre14">[major].[minor].[path]</kbd></p>
<p class="calibre3">So here's exactly what every part means:</p>
<ul class="calibre10">
<li class="calibre11">Update the <kbd class="calibre14">[major]</kbd> number version when you make incompatible API changes</li>
<li class="calibre11">Update the <kbd class="calibre14">[minor]</kbd> number version when adding functionalities that don't break backward compatibility</li>
<li class="calibre11">Update the <kbd class="calibre14">[patch]</kbd> number version when you make bug fixes that don't break backward compatibility</li>
</ul>
<p class="calibre3">It's not vital to know this, but it's always nice to be aware of it in case you intend to write crates in the future.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Cargo and crates.io</h1>
                
            
            
                
<p class="calibre3">A very important thing to note with Rust's ecosystem is that <kbd class="calibre14">Cargo</kbd> is really important if not central. It makes things much easier and all Rust projects are using it.</p>
<p class="calibre3">Cargo isn't only a build tool, it's also Rust's default package manager. If you need to download a dependency, <kbd class="calibre14">Cargo</kbd> will do it. You can find all available published crates on <a href="https://crates.io/" class="calibre13">https://crates.io/</a>. Consider the following screenshot:</p>
<div><img src="img/00006.jpeg" class="calibre35"/></div>
<div><em class="calibre21">Figure 2.1</em></div>
<p class="calibre3">In the case of the <kbd class="calibre14">sdl2</kbd> crate, we can see on its page (<a href="https://crates.io/crates/sdl2" class="calibre13">https://crates.io/crates/sdl2</a>) some interesting and useful information:</p>
<div><img src="img/00007.jpeg" class="calibre36"/></div>
<div><em class="calibre21">Figure 2.2</em></div>
<p class="calibre3">On the right-hand side, you can see the version history. It can be useful to check whether you have the last version or not and whether the crate is still maintained.</p>
<p class="calibre3">In the middle, you have the crate's dependencies. It's always interesting to know what you'll need to install in addition to your crate if something is missing.</p>
<p class="calibre3">And finally on the left-hand side, you have a few links that might be very useful (not always those ones, it depends on what has been put into the <kbd class="calibre14">Cargo.toml</kbd> file):</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre5">Documentation</strong>: This is where the documentation is hosted (even though I generally recommend <a href="https://docs.rs/" class="calibre13">docs.rs</a>, I'll talk about it in a moment)</li>
<li class="calibre11"><strong class="calibre5">Repository</strong>: This is where this crate's repository is hosted</li>
<li class="calibre11"><strong class="calibre5">Dependent crates</strong>: This is the list of the crates depending on this one</li>
<li class="calibre11"><strong class="calibre5">Homepage</strong>: If the crate has a website, you can go to its link</li>
</ul>
<p class="calibre3">Time to go back to <kbd class="calibre14">docs.rs</kbd> for a bit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The docs.rs documentation</h1>
                
            
            
                
<p class="calibre3">Every published crate on <kbd class="calibre14">crates.io</kbd> gets its documentation generated and hosted on <a href="https://docs.rs/" class="calibre13">https://docs.rs/</a>. If the crate's documentation hasn't been published by anyone anywhere online, you'll find it there as long as it has been published. With <kbd class="calibre14">crates.io</kbd> and <kbd class="calibre14">rust-lang.org</kbd>, it's one of the most known places of the Rust ecosystem, so bookmark it and doesn't lose it!</p>
<p class="calibre3">Here's a screenshot of what <a href="https://docs.rs/" class="calibre13">docs.rs</a> looks like:</p>
<div><img src="img/00008.jpeg" class="calibre37"/></div>
<div><em class="calibre21">Figure 2.3</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Back to our Cargo.toml file</h1>
                
            
            
                
<p class="calibre3">To go back to our <kbd class="calibre14">Cargo.toml</kbd> file, it's also possible to use crates directly from their repositories; you just have to specify this when adding the dependency in your <kbd class="calibre14">Cargo.toml</kbd> file. Generally, the published version is less advanced than the one on the corresponding repository but will be more stable.</p>
<p class="calibre3">So for example, if we want to use the repository version for the <kbd class="calibre14">sdl2</kbd> crate, we need to write in our <kbd class="calibre14">Cargo.toml</kbd> file:</p>
<pre class="calibre22">[dependencies]
sdl2 = { git = "https://github.com/Rust-SDL2/rust-sdl2" }</pre>
<p class="calibre3">Easy right? <kbd class="calibre14">Cargo</kbd> can also start tests or benchmarks, install binaries, handle special builds through a build file (by default in <kbd class="calibre14">build.rs</kbd>), or handle features (we'll come back to this point later in this part).</p>
<p class="calibre3">To put it simply, it's a complete tool, and explaining most of its features would take a lot of time and space, so we'll just stick to the basics for the moment.</p>
<p>You can find a very good documentation/tutorial on Cargo at <a href="http://doc.crates.io/index.html" class="calibre38">http://doc.crates.io/index.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rust's modules</h1>
                
            
            
                
<p class="calibre3">Before going any further, we need to talk about how file hierarchy works in Rust through its modules.</p>
<p class="calibre3">The first thing to know is that files and folders are handled as modules in Rust. Consider the following:</p>
<pre class="calibre22">|- src/
    |
    |- main.rs
    |- another_file.rs</pre>
<p class="calibre3">If you want to declare that a module is in the <kbd class="calibre14">another_file.rs</kbd> file, you'll need to add to your <kbd class="calibre14">main.rs</kbd> file:</p>
<div><pre class="calibre23">    mod another_file;</pre></div>
<p class="calibre3">You will now have access to everything contained in <kbd class="calibre14">another_file.rs</kbd> (as long as it's public).</p>
<p class="calibre3">Another thing to know: you can only declare modules whose files are on the same level as your current module/file. Here's a short example to sum this up:</p>
<pre class="calibre22">|- src/
    |
    |- main.rs
    |- subfolder/
        |- another_file.rs</pre>
<p class="calibre3">If you try to declare a module referring to <kbd class="calibre14">another_file.rs</kbd> directly into <kbd class="calibre14">main.rs</kbd>, as shown preceding, it'll fail because there are no <kbd class="calibre14">another_file.rs</kbd> in <kbd class="calibre14">src/</kbd>. In this case, you'll need to do three things:</p>
<ol class="calibre16">
<li value="1" class="calibre11">Add a <kbd class="calibre14">mod.rs</kbd> file into the <kbd class="calibre14">subfolder</kbd> folder.</li>
<li value="2" class="calibre11">Declare <kbd class="calibre14">another_file</kbd> into <kbd class="calibre14">mod.rs</kbd>.</li>
<li value="3" class="calibre11">Declare <kbd class="calibre14">subfolder</kbd> into <kbd class="calibre14">main.rs</kbd>.</li>
</ol>
<p class="calibre3">You certainly wonder, why <kbd class="calibre14">mod.rs</kbd>? It's the norm in Rust—when you import a module, which is a folder, the compiler will look for a file named <kbd class="calibre14">mod.rs</kbd> into it. The <kbd class="calibre14">mod.rs</kbd> files are mainly used for re-exporting modules' content outside.</p>
<p class="calibre3">Let's now write down the code to do this:</p>
<p class="calibre3">Inside <kbd class="calibre14">mod.rs</kbd>:</p>
<div><pre class="calibre23">    pub mod another_file;</pre></div>
<p class="calibre3">Inside <kbd class="calibre14">main.rs</kbd>:</p>
<div><pre class="calibre23">    mod subfolder;</pre></div>
<p class="calibre3">Now, you can use everything that is in <kbd class="calibre14">another_file</kbd> (as long as it's public!). Consider the following example:</p>
<div><pre class="calibre23">    use subfolder::another_file::some_function;</pre></div>
<p class="calibre3">You will certainly have noticed that we declared <kbd class="calibre14">another_file</kbd> publicly in <kbd class="calibre14">mod.rs</kbd>. It's simply because <kbd class="calibre14">main.rs</kbd> won't be able to access its content otherwise, as it's not at the same module level. However, a child module can access a parent's private items.</p>
<p class="calibre3">To conclude this small part, let's talk about the third type of modules: the module blocks (yes, as simple as that).</p>
<p class="calibre3">Just like you import a file or a folder, you can create a module block by using the same keyword:</p>
<div><pre class="calibre23">    mod a_module {
      pub struct Foo;
   }</pre></div>
<p class="calibre3">And you now created a new module named <kbd class="calibre14">a_module</kbd> containing a public structure. The rules described previously are applied the same way to this last kind of module.</p>
<p class="calibre3">You now know how to use modules to import files and folders. Let's start writing down our game!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tetris</h1>
                
            
            
                
<p class="calibre3">Okay, we're now ready to start writing down our tetris!</p>
<p class="calibre3">First, let's fulfill our <kbd class="calibre14">main.rs</kbd> file in order to check whether everything is working as expected:</p>
<div><pre class="calibre23">    extern crate sdl2;

    use sdl2::pixels::Color;
    use sdl2::event::Event;
    use sdl2::keyboard::Keycode;
    use std::time::Duration;<br class="calibre6"/>    use std::thread::sleep;

    pub fn main() {
      let sdl_context = sdl2::init().expect("SDL initialization   <br class="calibre6"/>      failed");
      let video_subsystem = sdl_context.video().expect("Couldn't get <br class="calibre6"/>       SDL video subsystem");

      let window = video_subsystem.window("rust-sdl2 demo: Video", 800,<br class="calibre6"/>            600)
        .position_centered()
        .opengl()
        .build()
        .expect("Failed to create window");

      let mut canvas = window.into_canvas().build().expect("Failed to<br class="calibre6"/>        convert window into canvas");

      canvas.set_draw_color(Color::RGB(255, 0, 0));
      canvas.clear();
      canvas.present();
      let mut event_pump = sdl_context.event_pump().expect("Failed to<br class="calibre6"/>        get SDL event pump");

      'running: loop {
         for event in event_pump.poll_iter() {
            match event {
              Event::Quit { .. } |
              Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt;  <br class="calibre6"/>              {
                break 'running
              },
              _ =&gt; {}
            }
         }
         sleep(Duration::new(0, 1_000_000_000u32 / 60));
      }
    }</pre></div>
<p class="calibre3">You'll note the following line:</p>
<div><pre class="calibre23">    ::std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));</pre></div>
<p class="calibre3">It allows you to avoid using all your computer CPU time needlessly and only rendering 60 times every second at most.</p>
<p class="calibre3">Now run the following in your terminal:</p>
<pre class="calibre23"><strong class="calibre5">$ cargo run</strong></pre>
<p class="calibre3">If you have a window filled with red (just as shown in the following screenshot), then everything's fine!</p>
<div><img src="img/00009.jpeg" class="calibre39"/></div>
<div><em class="calibre21">Figure 2.4</em></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a window</h1>
                
            
            
                
<p class="calibre3">The previous example created a window and drew into it. Now let's see how it did that!</p>
<p class="calibre3">Before going any further, we need to import the SDL2 crate, as follows:</p>
<div><pre class="calibre23">    extern crate sdl2;</pre></div>
<p class="calibre3">With this, we now have access to everything it contains.</p>
<p class="calibre3">Now that we've imported <kbd class="calibre14">sdl2</kbd>, we need to initialize an SDL context:</p>
<div><pre class="calibre23">    let sdl_context = sdl2::init().expect("SDL initialization failed");</pre></div>
<p class="calibre3">Once done, we need to get the video subsystem:</p>
<div><pre class="calibre23">    let video_subsystem = sdl_context.video().expect("Couldn't get SDL <br class="calibre6"/>      video subsystem");</pre></div>
<p class="calibre3">We can now create the window:</p>
<div><pre class="calibre23">    let window = video_subsystem.window("Tetris", 800, 600)
                            .position_centered()<br class="calibre6"/>                            .opengl()
                            .build()
                            .expect("Failed to create window");</pre></div>
<p class="calibre3">A few notes on these methods:</p>
<ul class="calibre10">
<li class="calibre11">The parameters for the <kbd class="calibre14">window</kbd> method are title, width, height</li>
<li class="calibre11"><kbd class="calibre14">.position_centered()</kbd> gets the window in the middle of the screen</li>
<li class="calibre11"><kbd class="calibre14">.opengl()</kbd> makes the SDL use <kbd class="calibre14">opengl</kbd> to render </li>
<li class="calibre11"><kbd class="calibre14">.build()</kbd> creates the window by applying all previously received parameters</li>
<li class="calibre11"><kbd class="calibre14">.expect</kbd> panics with the given message if an error occurred</li>
</ul>
<p class="calibre3">If you try to run this sample of code, it'll display a window and close it super quickly. We now need to add an event loop in order to keep it running (and then to manage user inputs).</p>
<p class="calibre3">At the top of the file, you need to add this:</p>
<div><pre class="calibre23">    use sdl2::event::Event;
    use sdl2::keyboard::Keycode;

    use std::thread::sleep;
    use std::time::Duration;</pre></div>
<p class="calibre3">Now let's actually write our event manager. First, we need to get the event handler as follows:</p>
<div><pre class="calibre23">    let mut event_pump = sdl_context.event_pump().expect("Failed to<br class="calibre6"/>       get SDL event pump");</pre></div>
<p class="calibre3">Then, we create an infinite loop to loop over events:</p>
<div><pre class="calibre23">    'running: loop {
      for event in event_pump.poll_iter() {
        match event {
            Event::Quit { .. } |
            Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
                break 'running // We "break" the infinite loop.
            },
            _ =&gt; {}
        }
      }
    sleep(Duration::new(0, 1_000_000_000u32 / 60));
    }</pre></div>
<p class="calibre3">To go back on these two lines:</p>
<div><pre class="calibre23">    'running: loop {
      break 'running</pre></div>
<p class="calibre3"><kbd class="calibre14">loop</kbd> is a keyword that allows creating an infinite loop in Rust. An interesting feature though is that you can add a label to your loops (so, <kbd class="calibre14">while</kbd> and <kbd class="calibre14">for</kbd> as well). In this case, we added the label <kbd class="calibre14">running</kbd> to the main loop. The point is to be able to break directly an upper loop without having to set a variable.</p>
<p class="calibre3">Now, if we receive a <kbd class="calibre14">quit</kbd> event (pressing the cross of the window) or if you press the <em class="calibre21">Esc</em> key, the program quits.</p>
<p class="calibre3">Now you can run this code and you'll have a window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Drawing</h1>
                
            
            
                
<p class="calibre3">We now have a working window; it'd be nice to draw into it. First, we need to get the window's canvas before starting the main loop:</p>
<div><pre class="calibre23">    let mut canvas = window.into_canvas()
                       .target_texture()
                       .present_vsync()
                       .build()
                       .expect("Couldn't get window's canvas");</pre></div>
<p class="calibre3">A few explanations for the preceding code:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">into_canvas</kbd> transforms the window into a canvas so that we can manipulate it more easily</li>
<li class="calibre11"><kbd class="calibre14">target_texture</kbd> activates texture rendering support</li>
<li class="calibre11"><kbd class="calibre14">present_vsync</kbd> enables the v-sync (also known as vertical-synchronization) limit</li>
<li class="calibre11"><kbd class="calibre14">build</kbd> creates the canvas by applying all previously set parameters</li>
</ul>
<p class="calibre3">Then we'll create a texture that we'll paste onto the window's canvas. First, let's get the texture creator, but before that, add this include at the top of the file:</p>
<div><pre class="calibre23">    use sdl2::render::{Canvas, Texture, TextureCreator};</pre></div>
<p class="calibre3">Now we can get the texture creator:</p>
<div><pre class="calibre23">    let texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();</pre></div>
<p class="calibre3">OK! Now we need to create a rectangle. To make things easier to read, we'll create a constant that will be the texture's size (better to put it at the head of the file, just after the imports, for readability reasons):</p>
<div><pre class="calibre23">    const TEXTURE_SIZE: u32 = 32;</pre></div>
<p class="calibre3">Let's create a texture with a <kbd class="calibre14">32x32</kbd> size:</p>
<div><pre class="calibre23">    let mut square_texture: Texture =
        texture_creator.create_texture_target(None, TEXTURE_SIZE,<br class="calibre6"/>          TEXTURE_SIZE)
        .expect("Failed to create a texture");</pre></div>
<p class="calibre3">Good! Now let's color it. First, add this import at the top of the file:</p>
<div><pre class="calibre23">    use sdl2::pixels::Color;</pre></div>
<p class="calibre3">We use the canvas to draw our square texture:</p>
<div><pre class="calibre23">    canvas.with_texture_canvas(&amp;mut square_texture, |texture| {
      texture.set_draw_color(Color::RGB(0, 255, 0));
      texture.clear();
    });</pre></div>
<p class="calibre3">An explanation of the preceding code is as follows:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre14">set_draw_color</kbd> sets the color to be used when drawing occurs. In our case, it's green.</li>
<li class="calibre11"><kbd class="calibre14">clear</kbd> washes/clears the texture so it'll be filled with green.</li>
</ul>
<p class="calibre3">Now, we just have to draw this square texture onto our window. In order to make it work, we need it to be drawn into the main loop but right after the event loop.</p>
<p class="calibre3">One thing to note before we continue: when drawing with the <kbd class="calibre14">SDL2</kbd>, the (0, 0) coordinates are at the top-left of a window, not at the bottom-left. The same goes for all shapes.</p>
<p class="calibre3">Add this import at the top of your file:</p>
<div><pre class="calibre23">    use sdl2::rect::Rect;</pre></div>
<p class="calibre3">Now let's draw. In order to be able to update the rendering of your window, you need to draw inside the main loop (and after the event loop). So firstly, let's fill our window with red:</p>
<div><pre class="calibre23">    canvas.set_draw_color(Color::RGB(255, 0, 0));
    canvas.clear();</pre></div>
<p class="calibre3">Next, we copy our texture into the window in the top-left corner with a 32x32 size:</p>
<div><pre class="calibre23">    canvas.copy(&amp;square_texture,
            None,
            Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))
        .expect("Couldn't copy texture into window");</pre></div>
<p class="calibre3">Finally, we update the window's display:</p>
<div><pre class="calibre23">     canvas.present();</pre></div>
<p class="calibre3">So if we take a look at the full code, we now have the following:</p>
<div><pre class="calibre23">    extern crate sdl2;

    use sdl2::event::Event;
    use sdl2::keyboard::Keycode;
    use sdl2::pixels::Color;
    use sdl2::rect::Rect;
    use sdl2::render::{Texture, TextureCreator};

    use std::thread::sleep;
    use std::time::Duration;

    fn main() {
      let sdl_context = sdl2::init().expect("SDL initialization  <br class="calibre6"/>       failed");
      let video_subsystem = sdl_context.video().expect("Couldn't get<br class="calibre6"/>         SDL video subsystem");

      // Parameters are: title, width, height
      let window = video_subsystem.window("Tetris", 800, 600)
        .position_centered() // to put it in the middle of the screen
        .build() // to create the window
        .expect("Failed to create window");

      let mut canvas = window.into_canvas()
        .target_texture()
        .present_vsync() // To enable v-sync.
        .build()
        .expect("Couldn't get window's canvas");

      let texture_creator: TextureCreator&lt;_&gt; =  <br class="calibre6"/>       canvas.texture_creator();
       // To make things easier to read, we'll create a constant <br class="calibre6"/>          which will be the texture's size.
      const TEXTURE_SIZE: u32 = 32;

      // We create a texture with a 32x32 size.
      let mut square_texture: Texture =
        texture_creator.create_texture_target(None, TEXTURE_SIZE,<br class="calibre6"/>            TEXTURE_SIZE)
          .expect("Failed to create a texture");

      // We use the canvas to draw into our square texture.
      canvas.with_texture_canvas(&amp;mut square_texture, |texture| {
        // We set the draw color to green.
        texture.set_draw_color(Color::RGB(0, 255, 0));
        // We "clear" our texture so it'll be fulfilled with green.
        texture.clear();
      }).expect("Failed to color a texture");

      // First we get the event handler:
      let mut event_pump = sdl_context.event_pump().expect("Failed <br class="calibre6"/>        to get SDL event pump");

      // Then we create an infinite loop to loop over events:
      'running: loop {
        for event in event_pump.poll_iter() {
          match event {
          // If we receive a 'quit' event or if the user press the<br class="calibre6"/>              'ESC' key, we quit.
          Event::Quit { .. } |
          Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
              break 'running // We "break" the infinite loop.
          },
          _ =&gt; {}
        }
      }

      // We set fulfill our window with red.
      canvas.set_draw_color(Color::RGB(255, 0, 0));
      // We draw it.
      canvas.clear();
      // Copy our texture into the window.
      canvas.copy(&amp;square_texture,
        None,
        // We copy it at the top-left of the window with a 32x32 size.
        Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))
        .expect("Couldn't copy texture into window");
        // We update window's display.
        canvas.present();

        // We sleep enough to get ~60 fps. If we don't call this, <br class="calibre6"/>           the program will take
        // 100% of a CPU time.
        sleep(Duration::new(0, 1_000_000_000u32 / 60));
      }
    }</pre></div>
<p class="calibre3">If you run this code, you should have a red window with a small green rectangle at the top-left (just as shown in the following screenshot):</p>
<div><img src="img/00010.jpeg" class="calibre40"/></div>
<div><em class="calibre21">Figure 2.5</em></div>
<p class="calibre3">Now, what about switching the color of our small rectangle every second? Alright, first thing, we need to create another rectangle. To make things easier, we'll write a small function that will create texture.</p>
<p class="calibre3">As usual, add the following import at the top of your file:</p>
<div><pre class="calibre23">    use sdl2::video::{Window, WindowContext};</pre></div>
<p class="calibre3">For convenience, we'll create a small enum to indicate the color as well:</p>
<div><pre class="calibre23">    #[derive(Clone, Copy)]
    enum TextureColor {
      Green,
      Blue,
    }</pre></div>
<p class="calibre3">To make our lives easier, we'll handle errors outside of the next function, so no need to handle them directly here:</p>
<div><pre class="calibre23">    fn create_texture_rect&lt;'a&gt;(canvas: &amp;mut Canvas&lt;Window&gt;,
       texture_creator: &amp;'a TextureCreator&lt;WindowContext&gt;,
       color: TextureColor, size: u32) -&gt; Option&lt;Texture&lt;'a&gt;&gt; {
       // We'll want to handle failures outside of this function.
      if let Ok(mut square_texture) =
         texture_creator.create_texture_target(None, size, size) {
           canvas.with_texture_canvas(&amp;mut square_texture, |texture| {
             match color {
                TextureColor::Green =&gt; <br class="calibre6"/>                  texture.set_draw_color(Color::RGB(0, 255, 0)),
                TextureColor::Blue =&gt; <br class="calibre6"/>                  texture.set_draw_color(Color::RGB(0, 0, 255)),
             }
             texture.clear();
           }).expect("Failed to color a texture");
            Some(square_texture)
         } else {
             None
           }
       }</pre></div>
<p class="calibre3">You'll note that the function returns an <kbd class="calibre14">Option</kbd> type, wrapping a texture. <kbd class="calibre14">Option</kbd> is an enum containing two variants: <kbd class="calibre14">Some</kbd> and <kbd class="calibre14">None</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing with Options</h1>
                
            
            
                
<p class="calibre3">To explain briefly how it works, when the <kbd class="calibre14">Option</kbd> type is <kbd class="calibre14">Some</kbd>, it simply means it contains a value whereas <kbd class="calibre14">None</kbd> doesn't. It has already been explained in <a target="_blank" href="part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 1</a>, <em class="calibre21">Basics of Rust</em>, but here's a little recap just in case you need one. We can compare this mechanism with pointers in C-like languages; when the pointer is null, there is no data to access. The same goes for <kbd class="calibre14">None</kbd>.</p>
<p class="calibre3">Here's a short example:</p>
<div><pre class="calibre23">    fn divide(nb: u32, divider: u32) -&gt; Option&lt;u32&gt; {
      if divider == 0 {
        None
      } else {
          Some(nb / divider)
        }
    }  </pre></div>
<p class="calibre3">So here, if the divider is <kbd class="calibre14">0</kbd>, we can't divide or we'll get an error. Instead of setting an error or returning a complicated type, we just return an <kbd class="calibre14">Option</kbd>:</p>
<div><pre class="calibre23">    let x = divide(10, 3);
    let y = divide(10, 0);</pre></div>
<p class="calibre3">Here, <kbd class="calibre14">x</kbd> is equal to <kbd class="calibre14">Some(3)</kbd> and <kbd class="calibre14">y</kbd> is equal to <kbd class="calibre14">None</kbd>.</p>
<p class="calibre3">The biggest advantage of this type compared to <kbd class="calibre14">null</kbd> is that if we have <kbd class="calibre14">Some</kbd>, you're sure that the data is valid. And in addition, when it's <kbd class="calibre14">None</kbd>, you can't accidentally read its content, it's simply impossible in Rust (and if you try to <kbd class="calibre14">unwrap</kbd> it, your program will panic immediately, but at least, you'll know what failed and why—no magical segmentation fault).</p>
<p class="calibre3">You can take a look at its documentation at <a href="https://doc.rust-lang.org/std/option/enum.Option.html" class="calibre13">https://doc.rust-lang.org/std/option/enum.Option.html</a>.</p>
<p class="calibre3">Let's explain what happens here:</p>
<ol class="calibre16">
<li value="1" class="calibre11">We create a texture or return <kbd class="calibre14">None</kbd> if the creation fails.</li>
<li value="2" class="calibre11">We set the color and then fulfill the texture with it.</li>
<li value="3" class="calibre11">We return the texture.</li>
</ol>
<p class="calibre3">If we return <kbd class="calibre14">None</kbd>, it simply means an error occurred. Also, for now, this function only handles two colors, but it's pretty easy to add more if you want.</p>
<p class="calibre3">It might look a bit complicated at the moment, but it'll make our life easier afterward. Now, let's call this function by creating a blue square of size 32x32:</p>
<div><pre class="calibre23">    let mut blue_square = create_texture_rect(&amp;mut canvas,
        &amp;texture_creator,
        TextureColor::Blue,
        TEXTURE_SIZE).expect("Failed to create a texture");</pre></div>
<p class="calibre3">Easy, right?</p>
<p>Now we can just put pieces together. I'll let you try to handle the color switch. A small tip: take a look at the <kbd class="calibre25">SystemTime</kbd> struct. You can refer to its documentation at <a href="https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html" class="calibre38">https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Solution</h1>
                
            
            
                
<p class="calibre3">I guess you did it without any issues, but in any case, here's the code:</p>
<div><pre class="calibre23">    extern crate sdl2;

    use sdl2::event::Event;
    use sdl2::keyboard::Keycode;
    use sdl2::pixels::Color;
    use sdl2::rect::Rect;
    use sdl2::render::{Canvas, Texture, TextureCreator};
    use sdl2::video::{Window, WindowContext};

    use std::thread::sleep;
    use std::time::{Duration, SystemTime};

    // To make things easier to read, we'll create a constant which<br class="calibre6"/>       will be the texture's size.
    const TEXTURE_SIZE: u32 = 32;

    #[derive(Clone, Copy)]
    enum TextureColor {
      Green,
      Blue,
   }

   fn create_texture_rect&lt;'a&gt;(canvas: &amp;mut Canvas&lt;Window&gt;,
     texture_creator: &amp;'a TextureCreator&lt;WindowContext&gt;,
     color: TextureColor,
     size: u32) -&gt; Option&lt;Texture&lt;'a&gt;&gt; {
      // We'll want to handle failures outside of this function.
    if let Ok(mut square_texture) =
      texture_creator.create_texture_target(None, size, size) {
        canvas.with_texture_canvas(&amp;mut square_texture, |texture| {
          match color {
            // For now, TextureColor only handles two colors.
            TextureColor::Green =&gt; texture.set_draw_color(Color::RGB(0,<br class="calibre6"/>                255, 0)),
            TextureColor::Blue =&gt; texture.set_draw_color(Color::RGB(0,<br class="calibre6"/>                0, 255)),
          }
          texture.clear();
        }).expect("Failed to color a texture");
        Some(square_texture)
      } <br class="calibre6"/>      else {
       // An error occured so we return nothing and let the function<br class="calibre6"/>           caller handle the error.
       None
      }
    }

    fn main() {
      let sdl_context = sdl2::init().expect("SDL initialization  <br class="calibre6"/>       failed");
      let video_subsystem = sdl_context.video().expect("Couldn't get <br class="calibre6"/>          SDL video subsystem");

      // Parameters are: title, width, height
      let window = video_subsystem.window("Tetris", 800, 600)
        .position_centered() // to put it in the middle of the screen
        .build() // to create the window
        .expect("Failed to create window");

      let mut canvas = window.into_canvas()
        .target_texture()
        .present_vsync() // To enable v-sync.
        .build()
        .expect("Couldn't get window's canvas");

      let texture_creator: TextureCreator&lt;_&gt; =  <br class="calibre6"/>       canvas.texture_creator();

      // We create a texture with a 32x32 size.
      let green_square = create_texture_rect(&amp;mut canvas,
         &amp;texture_creator,
         TextureColor::Green,
         TEXTURE_SIZE).expect("Failed to create a texture");
      let blue_square = create_texture_rect(&amp;mut canvas,
          &amp;texture_creator,
          TextureColor::Blue,
          TEXTURE_SIZE).expect("Failed to create a texture");

      let timer = SystemTime::now();

      // First we get the event handler:
      let mut event_pump = sdl_context.event_pump().expect("Failed<br class="calibre6"/>         to get SDL event pump");

      // Then we create an infinite loop to loop over events:
      'running: loop {
        for event in event_pump.poll_iter() {
          match event {
             // If we receive a 'quit' event or if the user press the<br class="calibre6"/>                    'ESC' key, we quit.
             Event::Quit { .. } |
             Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
                break 'running // We "break" the infinite loop.
             },
             _ =&gt; {}
          }
        }

        // We fill our window with red.
        canvas.set_draw_color(Color::RGB(255, 0, 0));
        // We draw it.
        canvas.clear();

        // The rectangle switch happens here:
        let display_green = match timer.elapsed() {
            Ok(elapsed) =&gt; elapsed.as_secs() % 2 == 0,
            Err(_) =&gt; {
                // In case of error, we do nothing...
                true
            }
        };
        let square_texture = if display_green {
            &amp;green_square
        } else {
            &amp;blue_square
        };
        // Copy our texture into the window.
        canvas.copy(square_texture,
           None,
            // We copy it at the top-left of the window with a 32x32  <br class="calibre6"/>               size.
            Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))
            .expect("Couldn't copy texture into window");
           // We update window's display.
           canvas.present();

        // We sleep enough to get ~60 fps. If we don't call this, <br class="calibre6"/>            the program will take
        // 100% of a CPU time.
        sleep(Duration::new(0, 1_000_000_000u32 / 60));
      }
    }</pre></div>
<p class="calibre3">You can now see the small rectangle at the top-left switching color every second.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Loading images</h1>
                
            
            
                
<p class="calibre3">Uptill now, we've only created simple textures, but what about loading images instead?</p>
<p class="calibre3">Before trying to go through this, check whether you have installed the <kbd class="calibre14">SDL2_image</kbd> library (it's not included by default with the SDL2 library!). If not, you can install it by following the upcoming sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2_image on Mac</h1>
                
            
            
                
<p class="calibre3">Just run the following:</p>
<div><pre class="calibre23"><strong class="calibre5">$ brew install SDL2_image</strong></pre></div>
<p class="calibre3">And you're good to go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2_image on Linux</h1>
                
            
            
                
<p class="calibre3">Depending on your package management tool, run the following to install <kbd class="calibre14">SDL2_image</kbd> on Linux:</p>
<p class="calibre3">For <kbd class="calibre14">apt package manager</kbd> use the following command:</p>
<div><pre class="calibre23"><strong class="calibre5">    $ sudo apt-get install libsdl2-image-2.0-0-dev</strong></pre></div>
<p class="calibre3">For <kbd class="calibre14">dnf package manager</kbd> use the following command:</p>
<div><pre class="calibre23"><strong class="calibre5">    $ sudo dnf install SDL2_image-devel</strong></pre></div>
<p class="calibre3">For <kbd class="calibre14">yum package manager</kbd> use the following command:</p>
<div><pre class="calibre23"><strong class="calibre5">    $ yum install SDL2_image-devel</strong></pre></div>
<p class="calibre3">And you're good to go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing SDL2_image on Windows</h1>
                
            
            
                
<p class="calibre3">For the Windows platform, the simplest way is to go to <a href="https://www.libsdl.org/projects/SDL_image/" class="calibre13">https://www.libsdl.org/projects/SDL_image/</a> and download it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing with features</h1>
                
            
            
                
<p class="calibre3">By default, you can't use the <kbd class="calibre14">image</kbd> module with <kbd class="calibre14">sdl2</kbd>, we need to activate it. To do so, we need to update our <kbd class="calibre14">Cargo.toml</kbd> file by adding a new section as follows:</p>
<pre class="calibre23">    [features]
    default = ["sdl2/image"]</pre>
<p class="calibre3"><kbd class="calibre14">default</kbd> means that by default, the following features (<kbd class="calibre14">"sdl2/image"</kbd>) will be enabled. Now, let's explain what <kbd class="calibre14">"sdl2/image"</kbd> means; <kbd class="calibre14">sdl2</kbd> refers to the crate where we want to enable a feature and <kbd class="calibre14">image</kbd> is the feature we want to enable.</p>
<p class="calibre3">Of course, if you want to enable a feature on the current project, you don't need the <kbd class="calibre14">sdl2/</kbd> part. Consider the following example:</p>
<pre class="calibre23">    [features]
    network = []
    default = ["network"]</pre>
<p class="calibre3">As I am sure you understood, it's absolutely possible to chain features activation and even to activate multiple features at once! If you want to enable features depending on a version number, for example:</p>
<pre class="calibre23">    [features]
    network_v1 = []
    network_v2 = ["network_v1"]
    network_v3 = ["network_v2"]
    v1 = ["network_v1"]
    v2 = ["v1", "network_v2"]
    v3 = ["v2", "network_v3"]</pre>
<p class="calibre3">So if you enable the <kbd class="calibre14">v3</kbd> feature, all the others will be activated as well! It can be incredibly useful when you need to handle multiple versions at once.</p>
<p class="calibre3">Now let's go back to our images.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Playing with images</h1>
                
            
            
                
<p class="calibre3">Just like textures, we need to initialize the image context. Now that we've activated the <kbd class="calibre14">image</kbd> feature, we can call the linked functions and import them. Let's add some new imports:</p>
<div><pre class="calibre23">    use sdl2::image::{LoadTexture, INIT_PNG, INIT_JPG};</pre></div>
<p class="calibre3">Then we create the image context:</p>
<div><pre class="calibre23">    sdl2::image::init(INIT_PNG | INIT_JPG).expect("Couldn't initialize<br class="calibre6"/>         image context");</pre></div>
<p class="calibre3">Now that the context has been initialized, let's actually load the image:</p>
<div><pre class="calibre23">    let image_texture =  <br class="calibre6"/>     texture_creator.load_texture("assets/my_image.png")
         .expect("Couldn't load image");</pre></div>
<p class="calibre3">A few explanations for the preceding code:</p>
<p class="calibre3"><kbd class="calibre14">load_texture</kbd> takes a file path as an argument. Be very careful with paths, even more when they're relative!</p>
<p class="calibre3">After that, it's just like we did with other textures. Let's put our image into our Window's background:</p>
<div><pre class="calibre23">    canvas.copy(&amp;Image_texture, None, None).expect("Render failed");</pre></div>
<p class="calibre3">To sum everything up, here's what your project's folder should look like now:</p>
<pre class="calibre23">|- your_project/
    |
    |- Cargo.toml
    |- src/
    |   |
    |   |- main.rs
    |- assets/
        |
        |- my_image.png</pre>
<p class="calibre3">And that's it!</p>
<p class="calibre3">Here's the full code in case you missed a step:</p>
<div><pre class="calibre23">    extern crate sdl2;
    use sdl2::pixels::Color;
    use sdl2::event::Event;
    use sdl2::keyboard::Keycode;
    use sdl2::render::TextureCreator;
    use sdl2::image::{LoadTexture, INIT_PNG, INIT_JPG};
    use std::time::Duration;

    pub fn main() {
      let sdl_context = sdl2::init().expect("SDL initialization <br class="calibre6"/>       failed");
      let video_subsystem = sdl_context.video().expect("Couldn't <br class="calibre6"/>         get SDL video subsystem");

      sdl2::image::init(INIT_PNG | INIT_JPG).expect("Couldn't  <br class="calibre6"/>      initialize<br class="calibre6"/>        image context");

      let window = video_subsystem.window("rust-sdl2 image demo", 800,  <br class="calibre6"/>        600)
        .position_centered()
        .opengl()
        .build()
        .expect("Failed to create window");

      let mut canvas = window.into_canvas().build().expect("Failed to <br class="calibre6"/>        convert window into canvas");


      let texture_creator: TextureCreator&lt;_&gt; = <br class="calibre6"/>       canvas.texture_creator();
      let image_texture = <br class="calibre6"/>        texture_creator.load_texture("assets/my_image.png")
         .expect("Couldn't load image");

      let mut event_pump = sdl_context.event_pump().expect("Failed to<br class="calibre6"/>         get SDL event pump");

     'running: loop {
        for event in event_pump.poll_iter() {
            match event {
                Event::Quit { .. } |
                Event::KeyDown { keycode: Some(Keycode::Escape), .. } <br class="calibre6"/>             =&gt; {
                    break 'running
                },
                _ =&gt; {}
            }
        }
        canvas.set_draw_color(Color::RGB(0, 0, 0));
        canvas.clear();
        canvas.copy(&amp;image_texture, None, None).expect("Render <br class="calibre6"/>         failed");
        canvas.present();
        ::std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));
     }
   }</pre></div>
<p class="calibre3">In my case, it gives the following output:</p>
<div><img src="img/00011.jpeg" class="calibre41"/></div>
<div><em class="calibre21">Figure 2.6</em></div>
<p class="calibre3">Now that we know how to make Windows and play with events and textures, let's see how to save and load high scores from files!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handling files</h1>
                
            
            
                
<p class="calibre3">Let's start with the basics. First, let's open and write into a file:</p>
<div><pre class="calibre23">    use std::fs::File;
    use std::io::{self, Write};

    fn write_into_file(content: &amp;str, file_name: &amp;str) -&gt; io::Result&lt;()&gt; {
      let mut f = File::create(file_name)?;
      f.write_all(content.as_bytes())
    }</pre></div>
<p class="calibre3">Now let's explain this code:</p>
<div><pre class="calibre23">    use std::fs::File;</pre></div>
<p class="calibre3">Nothing fancy, we just import the <kbd class="calibre14">File</kbd> type:</p>
<div><pre class="calibre23">   use std::io::{self, Write};</pre></div>
<p class="calibre3">This set of imports is more interesting: we import the <kbd class="calibre14">io</kbd> module (<kbd class="calibre14">self</kbd>) and the <kbd class="calibre14">Write</kbd> trait. For the second, if we didn't import it, we wouldn't be able to use the <kbd class="calibre14">write_all</kbd> method (because you need to import a trait to use its methods):</p>
<div><pre class="calibre23">   fn write_into_file(content: &amp;str, file_name: &amp;str) -&gt; io::Result&lt;()&gt; {</pre></div>
<p class="calibre3">We declared a function named <kbd class="calibre14">write_into_file</kbd> that takes a filename and the content you want to write into the file as arguments. (Note that the file will be overwritten by this content!) It returns an <kbd class="calibre14">io::Result</kbd> type. It is an alias over the normal <kbd class="calibre14">Result</kbd> type (its documentation is at <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html" class="calibre13">https://doc.rust-lang.org/stable/std/result/enum.Result.html</a>) declared as follows:</p>
<div><pre class="calibre23">    type Result&lt;T&gt; = Result&lt;T, Error&gt;;</pre></div>
<p class="calibre3">The only difference is that in case of error, the error type is already defined.</p>
<p>I recommend that you to take a look at its documentation in case you want to go further, at <a href="https://doc.rust-lang.org/stable/std/io/type.Result.html" class="calibre38">https://doc.rust-lang.org/stable/std/io/type.Result.html</a>.</p>
<p class="calibre3">So if our function worked without errors, it'll return <kbd class="calibre14">Ok(())</kbd>; it's the <kbd class="calibre14">Ok</kbd> variant containing an empty tuple which is considered the Rust equivalent of the <kbd class="calibre14">void</kbd> type. In case of error, it'll contain an <kbd class="calibre14">io::Error</kbd>, and it'll be up to you to handle it (or not). We'll come back to error handling a bit later.</p>
<p class="calibre3">Now let's look at the next line:</p>
<div><pre class="calibre23">    let mut f = File::create(file_name)?;</pre></div>
<p class="calibre3">Here, we call the static method <kbd class="calibre14">create</kbd> of the <kbd class="calibre14">File</kbd> type. If the file exists, it'll be truncated and if it doesn't, it'll be created. More information about this method can be found at <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create" class="calibre13">https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create</a>.</p>
<p class="calibre3">Now let's look at this strange <kbd class="calibre14">?</kbd> symbol. It's a syntactic sugar over the <kbd class="calibre14">try!</kbd> macro. The <kbd class="calibre14">try!</kbd> macro is very simple to understand and its code can be resumed as this:</p>
<div><pre class="calibre23">    match result {
      Ok(value) =&gt; value,
     Err(error) =&gt; return Err(error),
    }</pre></div>
<p class="calibre3">So that's pretty easy, but annoying to rewrite over and over, so the Rust teams decided to first introduce the <kbd class="calibre14">try!</kbd> macro and then after a long consensus, decided to add the <kbd class="calibre14">?</kbd> syntactic sugar over it (it also works with the <kbd class="calibre14">Option</kbd> type). However, both code pieces are still working, so you can perfectly do as well:</p>
<div><pre class="calibre23">    use std::fs::File;
    use std::io::{self, Write};

    fn write_into_file(content: &amp;str, file_name: &amp;str) -&gt; <br class="calibre6"/>    io::Result&lt;()&gt; {
      let mut f = try!(File::create(file_name));
      f.write_all(content.as_bytes())
    }</pre></div>
<p class="calibre3">It's exactly the same. Alternatively, you can write the full version too:</p>
<div><pre class="calibre23">    use std::fs::File;
    use std::io::{self, Write};

   fn write_into_file(content: &amp;str, file_name: &amp;str) -&gt; io::Result&lt;()&gt;   <br class="calibre6"/>   {
     let mut f = match File::create(file_name) {
        Ok(value) =&gt; value,
        Err(error) =&gt; return Err(error),
     };
     f.write_all(content.as_bytes())
   }</pre></div>
<p class="calibre3">It's up to you, but now you know what options you have!</p>
<p class="calibre3">Now let's check the last line:</p>
<div><pre class="calibre23">    f.write_all(content.as_bytes())</pre></div>
<p class="calibre3">Nothing fancy here; we write all our data into the file. We just need to convert (it's not really a conversion in this case, more like getting internal data) our <kbd class="calibre14">&amp;str</kbd> into a slice of <kbd class="calibre14">u8</kbd> (so a <kbd class="calibre14">&amp;[u8]</kbd>).</p>
<p class="calibre3">Now that we have a function to write a file, it'd be nice to be able to read from a file as well:</p>
<div><pre class="calibre23">    use std::fs::File;
    use std::io::{self, Read};

    fn read_from_file(file_name: &amp;str) -&gt; io::Result&lt;String&gt; {
      let mut f = File::open(file_name)?;
      let mut content = String::new();
      f.read_to_string(&amp;mut content)?;
      Ok(content)
    }</pre></div>
<p class="calibre3">Now let's go over what this function does quickly:</p>
<div><pre class="calibre23">    fn read_from_file(file_name: &amp;str) -&gt; io::Result&lt;String&gt; {</pre></div>
<p class="calibre3">This time, it only takes a filename as an argument and returns a <kbd class="calibre14">String</kbd> if the reading was successful:</p>
<div><pre class="calibre23">    let mut f = File::open(file_name)?;
    let mut content = String::new();
    f.read_to_string(&amp;mut content)?;</pre></div>
<p class="calibre3">Just like before, we open the file. Then we create a mutable <kbd class="calibre14">String</kbd> where the file content will be stored and finally we read all the file content at once with the <kbd class="calibre14">read_to_string</kbd> method (the <kbd class="calibre14">String</kbd> is reallocated as many times as needed). This method will fail if the string isn't proper UTF-8.</p>
<p class="calibre3">And to finish, if everything went fine, we return our content:</p>
<div><pre class="calibre23">    Ok(content)</pre></div>
<p class="calibre3">So now, let's see how we can use this in our future tetris.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Saving/loading high scores</h1>
                
            
            
                
<p class="calibre3">To keep things simple, we'll have a very simple file format:</p>
<ul class="calibre10">
<li class="calibre11">On the first line, we store the best scores</li>
<li class="calibre11">On the second line, we store the highest number of lines</li>
</ul>
<p class="calibre3">Let's start by writing the <kbd class="calibre14">save</kbd> function:</p>
<div><pre class="calibre23">    fn slice_to_string(slice: &amp;[u32]) -&gt; String {
      slice.iter().map(|highscore| highscore.to_string()).<br class="calibre6"/>        collect::&lt;Vec&lt;String&gt;&gt;().join(" ")
    }

    fn save_highscores_and_lines(highscores: &amp;[u32], <br class="calibre6"/>       number_of_lines: &amp;[u32]) -&gt; bool {
      let s_highscores = slice_to_string(highscores);
      let s_number_of_lines = slice_to_string(number_of_lines);
      write_into_file(format!("{}\n{}\n", s_highscores, <br class="calibre6"/>         s_number_of_lines)).is_ok()
    }</pre></div>
<p class="calibre3">It was a small lie: there are actually two functions. The first one is just here to make the code smaller and easier to read even though we need to explain what it does, because we're about to talk about a big feature from Rust—<strong class="calibre5">iterators</strong>!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Iterators</h1>
                
            
            
                
<p class="calibre3">The Rust documentation describes an iterator as <em class="calibre21">Composable external iteration.</em></p>
<p class="calibre3">They're used a lot in idiomatic Rust code on collection types (<kbd class="calibre14">slice</kbd>, <kbd class="calibre14">Vec</kbd>, <kbd class="calibre14">HashMap</kbd>, and so on) so it's very important to learn to master them. This code will allow us to have a nice introduction. Let's look at the code now:</p>
<div><pre class="calibre23">    slice.iter().map(|highscore| highscore.to_string()).<br class="calibre6"/>      collect::&lt;Vec&lt;String&gt;&gt;().join(" ")</pre></div>
<p class="calibre3">This is quite difficult to read and understand for the moment, so let's rewrite it as follows:</p>
<div><pre class="calibre23">    slice.iter()
       .map(|highscore| highscore.to_string())
       .collect::&lt;Vec&lt;String&gt;&gt;()
       .join(" ")</pre></div>
<p class="calibre3">Better (or at least more readable!). Now let's go step by step, as follows:</p>
<div><pre class="calibre23">     slice.iter()</pre></div>
<p class="calibre3">Here, we create an iterator from our slice. A really important and fundamental thing to note about iterators in Rust; they're lazy. Creating an iterator doesn't cost anything more than the size of the type (generally a structure containing a pointer and an index). Until the <kbd class="calibre14">next()</kbd> method is called, nothing happens.</p>
<p class="calibre3">So now we have an iterator, awesome! Let's check the next step:</p>
<div><pre class="calibre23">    .map(|highscore| highscore.to_string())</pre></div>
<p class="calibre3">We call the iterator's <kbd class="calibre14">map</kbd> method. What it does is simple: it converts the current type into another one. So here, we convert a <kbd class="calibre14">u32</kbd> into a <kbd class="calibre14">String</kbd>.</p>
<p class="calibre3">Really important to note: at this point, the iterator still hasn't done anything. Keep in mind that nothing is done until the <kbd class="calibre14">next()</kbd> method is called!</p>
<div><pre class="calibre23">    .collect::&lt;Vec&lt;String&gt;&gt;()</pre></div>
<p class="calibre3">And now we call the <kbd class="calibre14">collect()</kbd> method. It'll call the <kbd class="calibre14">next()</kbd> method of our iterator as long as it didn't get all elements and store them into a <kbd class="calibre14">Vec</kbd>. This is where the <kbd class="calibre14">map()</kbd> method will be called on every element of our iterator.</p>
<p class="calibre3">And finally the last step:</p>
<div><pre class="calibre23">    .join(" ")</pre></div>
<p class="calibre3">This method (as its name indicates) joins all the elements of the <kbd class="calibre14">Vec</kbd> into a <kbd class="calibre14">String</kbd> separated by the given <kbd class="calibre14">&amp;str</kbd> (so, <kbd class="calibre14">" "</kbd> in our case).</p>
<p class="calibre3">Finally, if we give <kbd class="calibre14">&amp;[1, 14, 5]</kbd> to the <kbd class="calibre14">slice_to_string</kbd> function, it'll return a <kbd class="calibre14">String</kbd> containing <kbd class="calibre14">"1 14 5"</kbd>. Pretty convenient, right?</p>
<p>If you want to go a bit deeper with the iterators, you can take a look at the blog post at <a href="https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust" class="calibre38">https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust</a> or directly take a look at the iterator official documentation at <a href="https://doc.rust-lang.org/stable/std/iter/index.html" class="calibre38">https://doc.rust-lang.org/stable/std/iter/index.html</a>.</p>
<p class="calibre3">It's time to go back to our saving function:</p>
<div><pre class="calibre23">    fn save_highscores_and_lines(highscores: &amp;[u32], <br class="calibre6"/>        number_of_lines: &amp;[u32]) -&gt; bool {
      let s_highscores = slice_to_string(highscores);
      let s_number_of_lines = slice_to_string(number_of_lines);
      write_into_file(format!("{}\n{}\n", s_highscores, <br class="calibre6"/>         s_number_of_lines), "scores.txt").is_ok()
    }</pre></div>
<p class="calibre3">Once we have converted our slices to <kbd class="calibre14">String</kbd>, we write them into the <kbd class="calibre14">scores.txt</kbd> file. The <kbd class="calibre14">is_ok()</kbd> method call just informs the caller of the <kbd class="calibre14">save_highscores_and_lines()</kbd> function if everything has been saved as expected or not.</p>
<p class="calibre3">Now that we can save scores, it'd be nice to be able to get them back when the tetris game is starting!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reading formatted data from files</h1>
                
            
            
                
<p class="calibre3">As you will certainly have guessed at this point, we'll use iterators once again. This is what the loading function will look like:</p>
<div><pre class="calibre22">fn line_to_slice(line: &amp;str) -&gt; Vec&lt;u32&gt; {
    line.split(" ").filter_map(|nb| nb.parse::&lt;u32&gt;().ok()).collect()
}

fn load_highscores_and_lines() -&gt; Option&lt;(Vec&lt;u32&gt;, Vec&lt;u32&gt;)&gt; {
    if let Ok(content) = read_from_file("scores.txt") {
        let mut lines = content.splitn(2, "\n").map(|line| <br class="calibre6"/>           line_to_slice(line)).collect::&lt;Vec&lt;_&gt;&gt;();
        if lines.len() == 2 {
            let (number_lines, highscores) = (lines.pop().unwrap(), <br class="calibre6"/>             lines.pop().unwrap());
            Some((highscores, number_lines))
        } else {
         None
        }
    } else {
        None
    }<br class="calibre6"/>}</pre></div>
<p class="calibre3">Once again, not easy to understand, at first sight. So let's explain all this!</p>
<div><pre class="calibre22">fn line_to_slice(line: &amp;str) -&gt; Vec&lt;u32&gt; {</pre></div>
<p class="calibre3">Our <kbd class="calibre14">line_to_slice()</kbd> function does the opposite of <kbd class="calibre14">slice_to_string()</kbd>; it transforms a <kbd class="calibre14">&amp;str</kbd> into a slice of <kbd class="calibre14">u32</kbd> (or <kbd class="calibre14">&amp;[u32]</kbd>). Let's see the iterator now:</p>
<div><pre class="calibre23">    line.split(" ").filter_map(|nb| nb.parse::&lt;u32&gt;().ok()).collect()</pre></div>
<p class="calibre3">Just like last time, let's split the calls:</p>
<div><pre class="calibre23">    line.split(" ")
      .filter_map(|nb| nb.parse::&lt;u32&gt;().ok())
      .collect()</pre></div>
<p class="calibre3">A bit better! Now let's explain:</p>
<div><pre class="calibre23">     line.split(" ")</pre></div>
<p class="calibre3">We create an iterator that will contain all strings between spaces. So <kbd class="calibre14">a b</kbd> will contain <kbd class="calibre14">a</kbd> and <kbd class="calibre14">b</kbd>:</p>
<div><pre class="calibre23">    .filter_map(|nb| nb.parse::&lt;u32&gt;().ok())</pre></div>
<p class="calibre3">This method is particularly interesting since it's the merge of two others: <kbd class="calibre14">filter()</kbd> and <kbd class="calibre14">map()</kbd>. We already know <kbd class="calibre14">map()</kbd> but what about <kbd class="calibre14">filter()</kbd>? If the condition isn't verified (so if the returned value of the closure is <kbd class="calibre14">false</kbd>), the iterator won't pass the value to the next method call. <kbd class="calibre14">filter_map()</kbd> works the same at this point: if the closure returns <kbd class="calibre14">None</kbd>, the value won't be passed to the next method call.</p>
<p class="calibre3">Now let's focus on this part:</p>
<div><pre class="calibre23">    nb.parse::&lt;u32&gt;().ok()</pre></div>
<p class="calibre3">Here, we try to convert <kbd class="calibre14">&amp;str</kbd> into <kbd class="calibre14">u32</kbd>. The <kbd class="calibre14">parse()</kbd> method returns a <kbd class="calibre14">Result</kbd> but the <kbd class="calibre14">filter_map()</kbd> expects an <kbd class="calibre14">Option</kbd> so we need to convert it. That's what the <kbd class="calibre14">ok()</kbd> method is for! If your <kbd class="calibre14">Result</kbd> is an <kbd class="calibre14">Ok(value)</kbd>, then it'll convert it into a <kbd class="calibre14">Some(value)</kbd>. However, if it's an <kbd class="calibre14">Err(err)</kbd>, it'll convert it into a <kbd class="calibre14">None</kbd> (but you'll lose the error value).</p>
<p class="calibre3">To sum this up, this whole line tries to convert a <kbd class="calibre14">&amp;str</kbd> into a number and ignores it if the conversion fails so it's not added to our final <kbd class="calibre14">Vec</kbd>. Amazing how much we can do with such small code!</p>
<p class="calibre3">And finally:</p>
<div><pre class="calibre23">    .collect()</pre></div>
<p class="calibre3">We <kbd class="calibre14">collect</kbd> all the successful conversions into a <kbd class="calibre14">Vec</kbd> and return it.</p>
<p class="calibre3">That's it for this function, now let's look at the other one:</p>
<div><pre class="calibre23">    fn load_highscores_and_lines() -&gt; Option&lt;(Vec&lt;u32&gt;, Vec&lt;u32&gt;)&gt; {</pre></div>
<p class="calibre3">Here, if everything went fine (if the file exists and has two lines), we return an <kbd class="calibre14">Option</kbd> containing in the first position the highest scores and in the second position the highest number of lines:</p>
<div><pre class="calibre23">    if let Ok(content) = read_from_file("scores.txt") {</pre></div>
<p class="calibre3">So if the file exists and we can get its content, we parse the data:</p>
<div><pre class="calibre23">    let mut lines = content.splitn(2, "\n").map(|line| <br class="calibre6"/>       line_to_slice(line)).collect::&lt;Vec&lt;_&gt;&gt;();</pre></div>
<p class="calibre3">Another iterator! As usual, let's rewrite it a bit:</p>
<div><pre class="calibre23">    let mut lines = content.splitn(2, "\n")
         .map(|line| line_to_slice(line))
         .collect::&lt;Vec&lt;_&gt;&gt;();</pre></div>
<p class="calibre3">I think you're starting to get how they work, but just in case you don't know, here's how:</p>
<div><pre class="calibre23">    content.splitn(2, "\n")</pre></div>
<p class="calibre3">We make an iterator containing at most two entries (because of the <kbd class="calibre14">2</kbd> as the first argument) splitting lines:</p>
<div><pre class="calibre23">    .map(|line| line_to_slice(line))</pre></div>
<p class="calibre3">We transform each line into a <kbd class="calibre14">Vec&lt;u32&gt;</kbd> by using the function described in the preceding code:</p>
<div><pre class="calibre23">    .collect::&lt;Vec&lt;_&gt;&gt;();</pre></div>
<p class="calibre3">And finally, we collect those <kbd class="calibre14">Vec</kbd>s into a <kbd class="calibre14">Vec&lt;Vec&lt;u32&gt;&gt;</kbd>, which should only contain two entries.</p>
<p class="calibre3">Let's look at the next line now:</p>
<div><pre class="calibre23">    if lines.len() == 2 {</pre></div>
<p class="calibre3">As said before, if we don't have two entries inside our <kbd class="calibre14">Vec</kbd>, it means something is wrong with the file:</p>
<div><pre class="calibre23">    let (number_lines, highscores) = (lines.pop().unwrap(), <br class="calibre6"/>        lines.pop().unwrap());</pre></div>
<p class="calibre3">In case our <kbd class="calibre14">Vec</kbd> has two entries, we can get the corresponding values. Since the <kbd class="calibre14">pop</kbd> method removes the last entry of the <kbd class="calibre14">Vec</kbd>, we get them in reverse (even though we return high scores first then the highest number of lines):</p>
<div><pre class="calibre23">    Some((highscores, number_lines))</pre></div>
<p class="calibre3"/>
<p class="calibre3">Then everything else is just the error handling. As we said previously, if any error occurs, we return <kbd class="calibre14">None</kbd>. In this case, it's not really important to handle the error since it's just high scores. If we have errors with the <kbd class="calibre14">sdl</kbd> libraries, nothing will work as expected, so we need to handle them to avoid a panic.</p>
<p class="calibre3">It's now time to really start the game!</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we saw a lot of important things like how to use <kbd class="calibre14">Cargo</kbd> (through the <kbd class="calibre14">Cargo.toml</kbd> file), how to import new crates into a project, thanks to <kbd class="calibre14">Cargo</kbd>, and the basics for Rust modules handling. We even covered how to use iterators and read and write files, <kbd class="calibre14">SDL2</kbd> basics like how to create a window and fill it with colors, and loading/creating new textures and images (thanks to the <kbd class="calibre14">SDL2-image</kbd> library!).</p>
<p class="calibre3">In <a target="_blank" href="part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7" class="calibre13">Chapter 3</a>, <em class="calibre21">Events and Basic Game Mechanisms</em>, we'll start the implementation of the tetris game, so be sure to master everything explained in this chapter before starting the next one!</p>


            

            
        
    </body></html>