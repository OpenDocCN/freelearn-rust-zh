<html><head></head><body>
		<div><h1 id="_idParaDest-70"><em class="italic"><a id="_idTextAnchor078"/>Chapter 6</em>: Installing and Using Binaryen</h1>
			<p>During the compilation process, compiled languages produce their own <strong class="bold">Intermediate Representation</strong> (<strong class="bold">IR</strong>). The compilers then optimize the IR<a id="_idIndexMarker259"/> to generate optimized code. Before passing it to LLVM, compilers should convert this IR into something that LLVM understands (LLVM IR). LLVM optimizes LLVM IR and produces native code (like the WebAssembly binary). These multiple IR generations and optimizations at different levels make the compilation process slower and not very effective. Binaryen<a id="_idIndexMarker260"/> tries to eliminate these multiple IR generations and uses its own IR. </p>
			<p><strong class="bold">(WebAssembly) Binary + Emscripten = Binaryen</strong></p>
			<p class="author-quote">Binaryen is a compiler and toolchain infrastructure library for WebAssembly, written in C++. It aims to make compiling to WebAssembly easy, fast, and effective. </p>
			<p class="author-quote">- Binaryen's GitHub repository (<a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>)</p>
			<p>Binaryen uses its own version of IR. Binaryen's IR is a subset of WebAssembly. Thus, it makes compiling Binaryen to WebAssembly faster and easier. Binaryen's IR uses a compact data structure and is designed with modern CPU architecture in mind. That is, the WebAssembly binary can be generated and optimized in parallel using all the available CPU cores.</p>
			<p>In addition to that, Binaryen's optimizer has many passes that can improve the code significantly. Binaryen's optimizer uses techniques such as local coloring to coalesce local variables, dead code elimination, and precomputing expressions wherever possible. Binaryen also provides a way to shrink the WebAssembly binary.</p>
			<p>Binaryen is easy to use. It accepts the WebAssembly binary or even the control graph to generate a highly optimized WebAssembly binary. Binaryen also provides Binaryen.js, which enables the use of Binaryen from JavaScript. Similar to WABT, Binaryen includes a different set of tools that are useful while dealing with WebAssembly.</p>
			<p>These toolchain utilities help in parsing the WebAssembly binary and then optimizing it further, and finally, emit a highly optimized WebAssembly binary (in other words, wasm-to-wasm optimizer), providing a polyfill for WebAssembly when the browser does not have WebAssembly support.</p>
			<p>In this chapter, we will understand how to install and use various tools provided by Binaryen. Understanding Binaryen and the tools provided by it will help you to optimize the WebAssembly binaries in terms of performance and size. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Installing and using Binaryen</li>
				<li><code>wasm-as</code></li>
				<li><code>wasm-dis</code></li>
				<li><code>wasm-opt</code></li>
				<li><code>wasm2js</code></li>
			</ul>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor079"/>Technical requirements</h1>
			<p>We'll be requiring Binaryen and Visual C++ installed. You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor080"/>Installing and using Binaryen</h1>
			<p>In order to install Binaryen, first clone<a id="_idIndexMarker261"/> the repository from<a id="_idIndexMarker262"/> GitHub:</p>
			<pre>$ git clone https://github.com/WebAssembly/binaryen</pre>
			<p>After the repository is cloned, go into the folder:</p>
			<pre>$ cd binaryen</pre>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor081"/>Linux/macOS</h2>
			<p>Generate the project build system<a id="_idIndexMarker263"/> by running the <code>cmake</code> command with the path to the <code>binaryen</code> folder:</p>
			<pre>$ cmake .</pre>
			<p>Next, build the project<a id="_idIndexMarker264"/> using the <code>make</code> command:</p>
			<pre>$ make .</pre>
			<p>This generates all the binaries in the <code>bin</code> fo<a id="_idTextAnchor082"/>lder.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor083"/>Windows</h2>
			<p>For Windows, once the repository<a id="_idIndexMarker265"/> is cloned, we will create a <code>build</code> directory and go inside it:</p>
			<pre>$ mkdir build
$ cd build</pre>
			<p>By default, Windows does not have the cmake command available. Install the Visual C++ tools to make the <code>cmake</code> command available<a id="_idIndexMarker266"/> in the system. To install the Visual C++ tools, check out the following link: <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160&amp;viewFallbackFrom=vs-2019">https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160&amp;viewFallbackFrom=vs-2019</a>. Then, run the following command inside the <code>build</code> folder:</p>
			<pre>$ "&lt;path-to-visual-studio-root&gt;\Common7\IDE\CommonExtensions\
  Microsoft\CMake\CMake\bin\cmake.exe" ..</pre>
			<p>The preceding command will generate all the necessary build files in the <code>build</code> directory. Then, we can build the project using the <code>binaryen.vcxproj</code> file generated by <code>cmake</code>:</p>
			<pre>$ msbuild binaryen.vcxproj</pre>
			<p>The generated binary includes the following:</p>
			<pre>$ tree -L 1
├── wasm-as
├── wasm-ctor-eval
├── wasm-dis
├── wasm-emscripten-finalize
├── wasm-metadce
├── wasm-opt
├── wasm-reduce
├── wasm-shell
└── wasm2js </pre>
			<p>The various tools generated<a id="_idIndexMarker267"/> by Binaryen are as follows: </p>
			<ul>
				<li><code>wasm-as</code> – This tool is similar to <code>wat2wasm</code> in WABT. This tool converts WebAssembly text format (<code>.wast</code>) into WebAssembly binary format (<code>.wasm</code>).</li>
				<li><code>wasm-ctor-eval</code> – This tool executes C++ global constructors ahead of time and has them ready. This optimization speeds up the WebAssembly execution.</li>
				<li><code>wasm-dis</code> – This tool is similar to <code>wasm2wat</code> in wabt. That is, it converts WebAssembly binary format (<code>.wasm</code>) into WebAssembly text format (<code>.wat</code>).</li>
				<li><code>wasm-emscripten-finalize</code> – This tool performs Emscripten-specific transforms on the given <code>.wasm</code> files.</li>
				<li><code>wasm-metadce</code> – This tool removes dead code in the provided WebAssembly binary.</li>
				<li><code>wasm-opt</code> – This tool optimizes the provided WebAssembly binary.</li>
				<li><code>wasm-reduce</code> – This tool reduces the given WebAssembly binary into a smaller binary.</li>
				<li><code>wasm-shell</code> – This tool creates a shell that can load and interpret WebAssembly code.</li>
				<li><code>wasm2js</code> – This tool is useful in polyfill. It converts WebAssembly into a JavaScript compiler.</li>
				<li><code>binaryen.js</code> – A standalone JavaScript library that exposes Binaryen methods for creating and optimizing the WebAssembly modules. This JavaScript file is just like any other JavaScript file that can be loaded into the browser.</li>
			</ul>
			<p>Now that we have built and generated the tools provided by Binaryen, let's explore the tools generated.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor084"/>wasm-as</h1>
			<p>The <code>wasm-as</code> tool converts WAST<a id="_idIndexMarker268"/> into WASM. Let's look at the steps:</p>
			<ol>
				<li>Let's create a new folder, called <code>binaryen-playground</code>, and go into the folder:<pre><strong class="bold">$ mkdir binaryen-playground</strong>
<strong class="bold">$ cd binaryen-playground</strong></pre></li>
				<li>Create a <code>.wat</code> file called <code>add.wat</code>:<pre><strong class="bold">$ touch add.wat</strong></pre></li>
				<li>Add the following contents to <code>add.wat</code>:<pre>(module
    (func $add (param $x i32) (param $y i32) 
      (result i32)
        (i32.add
            (local.get $x)
            (local.get $y)
        )
    )
)</pre></li>
				<li>Convert the Web Assembly text format into a WebAssembly module, using the <code>wasm-as</code> binary:<pre><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-as add.wat</strong></pre></li>
			</ol>
			<p>This generates the <code>add.wasm</code> file:</p>
			<pre>00 61 73 6d 01 00 00 00 01 07 01 60 02 7f 7f 01
7f 03 02 01 00 0a 09 01 07 00 20 00 20 01 6a 0b</pre>
			<p class="callout-heading">Note </p>
			<p class="callout">The size of the binary generated is just 32 bytes. </p>
			<p><code>wasm-as</code> first validates<a id="_idIndexMarker269"/> the given file (<code>.wat</code>) and then converts it into a <code>.wasm</code> file. To check various options supported by <code>wasm-as</code>, we can run the following command:</p>
			<pre>$ /path/to/build/directory/of/binaryen/wasm-as --help
wasm-as INFILE
Assemble a .wat (WebAssembly text format) into a .wasm (WebAssembly binary
format)
Options:
  --version                        Output version information     and exit
  --help,-h                        Show this help message and     exit
  --debug,-d                       Print debug information to     stderr
....
  --output,-o                      Output file (stdout if not 
    specified)
  --validate,-v                    Control validation of the 
    output module
  --debuginfo,-g                   Emit names section and debug
    info
  --source-map,-sm                 Emit source map to the 
    specified file
  --source-map-url,-su             Use specified string as 
    source map URL
  --symbolmap,-s                   Emit a symbol map (indexes 
    =&gt; names)</pre>
			<p>If we need to generate the WebAssembly module file in a different name, we will use the <code>-o</code> option with the filename. For example, <code>wasm-as add.wat -o customAdd.wasm</code> will generate <code>customAdd.wasm</code>.</p>
			<p><code>wasm-as</code> also provides verbose<a id="_idIndexMarker270"/> output that clearly explains how the WebAssembly module is structured. In order to see the structure of the WebAssembly module, we run it with the <code>-d</code> option:</p>
			<pre><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-as add.wat -d</strong>
<strong class="bold">Loading 'add.wat'...</strong>
<strong class="bold">s-parsing...</strong>
<strong class="bold">w-parsing</strong>...
<strong class="bold">Validating...</strong>
<strong class="bold">writing...</strong>
<strong class="bold">writing binary to add.wasm</strong>
<strong class="bold">Opening 'add.wasm'</strong>
<strong class="bold">== writeHeader</strong>
<strong class="bold">...</strong>
<strong class="bold">== writeTypes</strong>
<strong class="bold">...</strong>
<strong class="bold">== writeFunctionSignatures</strong>
<strong class="bold">...</strong>
<strong class="bold">== writeFunctions</strong>
<strong class="bold">...</strong>
<strong class="bold">finishUp</strong>
<strong class="bold">Done.</strong></pre>
			<p>The previous output is a detailed description<a id="_idIndexMarker271"/> of how the binary is generated. First, it loads the given <code>.wat</code> file. After that, it parses and validates the file. Finally, it creates <code>add.wasm</code> and writes the header, the type, function signatures, and functions. While generating the binary, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <code>enable-*</code> and <code>disable-*</code> options. Additionally, you can generate <code>sourcemap</code> using the <code>--sm</code> option.</p>
			<p>Now that we have seen how to convert WAST to WASM, let's see how to convert WASM to WAST.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor085"/>wasm-dis</h1>
			<p>The <code>wasm-dis</code> tool converts<a id="_idIndexMarker272"/> WAST into WASM. We will use the <code>add.wasm</code> file that we created in the previous example here. Let's look at the steps:</p>
			<ol>
				<li value="1">In order to convert the WebAssembly module into WebAssembly text format, using the <code>wasm-dis</code> binary, run the following command:<pre><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-dis add.wasm -o gen-add.wast</strong></pre></li>
				<li>We generate the <code>gen-add.wast</code> file using the <code>-o</code> option with the filename (<code>gen-add.wast</code>):<pre>(module
(type $i32_i32_=&gt;_i32 (func (param i32 i32) 
  (result i32)))
(func $0 (param $0 i32) (param $1 i32) (result i32)
           (i32.add  (local.get $0)  (local.get $1) )
)
)</pre></li>
				<li><code>wasm-dis</code> first validates the given file (<code>.wasm</code>) and then converts it into a <code>.wat</code> file. To check various options<a id="_idIndexMarker273"/> supported by <code>wasm-dis</code>, run the following command:<pre><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-dis --help</strong>
<strong class="bold">wasm-dis INFILE </strong>
<strong class="bold">Un-assemble a .wasm (WebAssembly binary format) into a .wat (WebAssembly text</strong>
<strong class="bold">format)</strong>
<strong class="bold">Options:</strong>
<strong class="bold">  --version        Output version information and exit</strong>
<strong class="bold">  --help,-h        Show this help message and exit</strong>
<strong class="bold">  --debug,-d       Print debug information to stderr</strong>
<strong class="bold">  --output,-o      Output file (stdout if not specified)</strong>
<strong class="bold">  --source-map,-sm Consume source map from the specified file to add location</strong></pre></li>
				<li><code>wasm-dis</code> also provides verbose output that clearly explains how the WebAssembly module is structured. In order to see the structure of the WebAssembly module, we run it with the <code>-d</code> option:<pre><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-dis</strong>
<strong class="bold">  add.wat -o gen-add.wast -d</strong>
<strong class="bold">parsing binary...</strong>
<strong class="bold">reading binary from add.wasm</strong>
<strong class="bold">Loading 'add.wasm'...</strong>
<strong class="bold">== readHeader</strong>
<strong class="bold">...</strong>
<strong class="bold">== readSignatures</strong>
<strong class="bold">...</strong>
<strong class="bold">== readFunctionSignatures</strong>
<strong class="bold">...</strong>
<strong class="bold">== processExpressions</strong>
<strong class="bold">...</strong>
<strong class="bold">== processExpressions finished</strong>
<strong class="bold">end function bodies</strong>
<strong class="bold">Printing...</strong>
<strong class="bold">Opening 'gen-add.wast'</strong>
<strong class="bold">Done.</strong></pre></li>
			</ol>
			<p>The previous output is a detailed<a id="_idIndexMarker274"/> description of how the <code>.wast</code> file is generated. First, it loads the given <code>.wasm</code> file. After that, it parses and validates the file. Finally, it creates <code>gen-add.wast</code> after reading the header, type, function signatures, and functions.</p>
			<p>While generating the file, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <code>enable-*</code> and <code>disable-*</code> options, respectively.</p>
			<p>Additionally, we can also input <code>sourcemap</code> using the <code>--sm &lt;filename&gt; </code>option.</p>
			<p>Now that we have seen how to convert WASM to WAST, let's see how to optimize the WebAssembly binaries further.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor086"/>wasm-opt</h1>
			<p>The <code>wasm-opt</code> tool is a <code>wasm-to-wasm</code> optimizer. It will receive<a id="_idIndexMarker275"/> a WebAssembly module as input and run transformation passes on it to optimize and generate the optimized WebAssembly module. Let's look at the steps:</p>
			<ol>
				<li value="1">Let's first create the <code>inline-optimizer.wast</code> file and add the following content:<pre>(module
    (func $parent (export "parent") (result i32)
        (i32.add
            (call $child)
            (i32.const 13)
        )
    )
    (func $child (result i32) (call $grandChild))
    (func $grandChild (result i32) (call
       $greatGrandChild))
    (func $greatGrandChild (result i32) (i32.const 7))
)</pre></li>
				<li>To generate the WebAssembly<a id="_idIndexMarker276"/> module, we will run the following:<pre><code>  optimizer.wast -o inline.wasm --print</code>
<strong class="bold">(module</strong>
<strong class="bold">(type $0 (func (result i32)))</strong>
<strong class="bold">(export "parent" (func $parent))</strong>
<strong class="bold">(func $parent (; 0 ;) (type $0) (result i32)</strong>
<strong class="bold">(i32.add</strong>
<strong class="bold">(call $child)</strong>
<strong class="bold">(i32.const 13)</strong>
<strong class="bold">  )</strong>
<strong class="bold">)</strong>
<strong class="bold">(func $child (; 1 ;) (type $0) (result i32)</strong>
<strong class="bold">  (call $grandChild)</strong>
<strong class="bold">)</strong>
<strong class="bold">(func $grandChild (; 2 ;) (type $0) (result i32)</strong>
<strong class="bold">  (call $greatGrandChild)</strong>
<strong class="bold">)</strong>
<strong class="bold">(func $greatGrandChild (; 3 ;) (type $0) (result i32)</strong>
<strong class="bold">  (i32.const 7)</strong>
<strong class="bold">)</strong>
<strong class="bold">)</strong></pre></li>
			</ol>
			<p>This will generate <code>inline.wasm</code>. The <code>--print</code> option prints the WebAssembly text format before converting<a id="_idIndexMarker277"/> it to the WebAssembly binary. We also passed in the <code>-o</code> option to output the WebAssembly module as <code>inline.wasm</code>:</p>
			<pre><strong class="bold">60B inline-optimize.wasm</strong>
<strong class="bold">273B inline-optimize.wat</strong></pre>
			<p>This generated binary of 60 bytes in memory. </p>
			<ol>
				<li value="3">We can further optimize the binary with the <code>--inlining-optimizing</code> option:<pre><code>  optimizer.wast -o inline.wasm --print --inlining-</code>
<strong class="bold">  optimizing</strong></pre></li>
			</ol>
			<p>This will optimize the functions and inline the functions where the binary is called. Let's check what the file size generated is:</p>
			<pre><strong class="bold">39B inline-optimize.wasm</strong>
<strong class="bold">273B inline-optimize.wat</strong></pre>
			<p>The generated file is just 39 bytes, which is 35% less than the original binary. </p>
			<ol>
				<li value="4">To check various options supported by <code>wasm-opt</code>, run the following command:<pre><strong class="bold">/path/to/bin/folder/of/binaryen/wasm-opt –help</strong></pre></li>
			</ol>
			<p>The <code>wasm-opt</code> tool helps us to optimize<a id="_idIndexMarker278"/> the WebAssembly binaries further. Let's next explore the <code>wasm2js</code> tool.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor087"/>wasm2js</h1>
			<p>The <code>wasm2js</code> tool converts WASM/WAST files<a id="_idIndexMarker279"/> into JavaScript files. Let's look at the steps:</p>
			<ol>
				<li value="1">Create a file called <code>add-with-export.wast</code>:<pre><strong class="bold">$ touch add-with-export.wast</strong></pre></li>
			</ol>
			<p>Then, add the following code:</p>
			<pre>(module
    (export "add" (func $add))
    (func $add (param $x i32) (param $y i32) 
      (result i32)
        (i32.add
            (local.get $x)
            (local.get $y)
        )
    )
)</pre>
			<ol>
				<li value="2">In order to convert the WebAssembly text format into JavaScript using <code>wasm2js</code>, run the following command:<pre><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm2js add-</strong>
<strong class="bold">  with-export.wast</strong></pre></li>
			</ol>
			<p>This will print out the generated<a id="_idIndexMarker280"/> JavaScript:</p>
			<pre>function asmFunc(global, env) {
var Math_imul = global.Math.imul;
var Math_fround = global.Math.fround;
var Math_abs = global.Math.abs;
var Math_clz32 = global.Math.clz32;
var Math_min = global.Math.min;
var Math_max = global.Math.max;
var Math_floor = global.Math.floor;
var Math_ceil = global.Math.ceil;
var Math_sqrt = global.Math.sqrt;
var abort = env.abort;
var nan = global.NaN;
var infinity = global.Infinity;
function add(x, y) {
  x = x | 0;
  y = y | 0;
  return x + y | 0 | 0;
}
return {
  "add": add
};
}
var retasmFunc = asmFunc({
    Math,
    Int8Array,
    Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    NaN,
    Infinity
  }, {
    abort: function() { throw new Error('abort'); }
  });
export var add = retasmFunc.add;</pre>
			<p>The <code>asmFunc</code> function<a id="_idIndexMarker281"/> is defined. In <code>asmFunc</code>, we import the math functions from the global object. After that, we have an <code>add</code> function. The <code>add</code> function initializes <code>x</code> and <code>y</code>. The function returns the sum of two values. Finally, we return the <code>add</code> function.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The generated JavaScript is <code>asmjs</code> and not normal JavaScript. We also imported a lot of functions from the global namespace in JavaScript into <code>asmFunc</code>.</p>
			<p>The <code>wasm2js</code> tool makes it easy to generate JavaScript from a WebAssembly module. The generated JavaScript module<a id="_idIndexMarker282"/> is faster than its normal JavaScript counterpart. This can be used as a polyfill for browsers that do not support WebAssembly yet.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we have seen how to install Binaryen and what the various tools provided by the Binaryen toolkit are. Binaryen makes it easier to convert WebAssembly modules into various formats. It is an important tool that makes your WebAssembly journey easier and more efficient.</p>
			<p>In the next chapter, we will start our Rust and WebAssembly journey.</p>
		</div>
	</body></html>