<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-70"><em class="italic"><a id="_idTextAnchor078"/>Chapter 6</em>: Installing and Using Binaryen</h1>
			<p>During the compilation process, compiled languages produce their own <strong class="bold">Intermediate Representation</strong> (<strong class="bold">IR</strong>). The compilers then optimize the IR<a id="_idIndexMarker259"/> to generate optimized code. Before passing it to LLVM, compilers should convert this IR into something that LLVM understands (LLVM IR). LLVM optimizes LLVM IR and produces native code (like the WebAssembly binary). These multiple IR generations and optimizations at different levels make the compilation process slower and not very effective. Binaryen<a id="_idIndexMarker260"/> tries to eliminate these multiple IR generations and uses its own IR. </p>
			<p><strong class="bold">(WebAssembly) Binary + Emscripten = Binaryen</strong></p>
			<p class="author-quote">Binaryen is a compiler and toolchain infrastructure library for WebAssembly, written in C++. It aims to make compiling to WebAssembly easy, fast, and effective. </p>
			<p class="author-quote">- Binaryen's GitHub repository (<a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>)</p>
			<p>Binaryen uses its own version of IR. Binaryen's IR is a subset of WebAssembly. Thus, it makes compiling Binaryen to WebAssembly faster and easier. Binaryen's IR uses a compact data structure and is designed with modern CPU architecture in mind. That is, the WebAssembly binary can be generated and optimized in parallel using all the available CPU cores.</p>
			<p>In addition to that, Binaryen's optimizer has many passes that can improve the code significantly. Binaryen's optimizer uses techniques such as local coloring to coalesce local variables, dead code elimination, and precomputing expressions wherever possible. Binaryen also provides a way to shrink the WebAssembly binary.</p>
			<p>Binaryen is easy to use. It accepts the WebAssembly binary or even the control graph to generate a highly optimized WebAssembly binary. Binaryen also provides Binaryen.js, which enables the use of Binaryen from JavaScript. Similar to WABT, Binaryen includes a different set of tools that are useful while dealing with WebAssembly.</p>
			<p>These toolchain utilities help in parsing the WebAssembly binary and then optimizing it further, and finally, emit a highly optimized WebAssembly binary (in other words, wasm-to-wasm optimizer), providing a polyfill for WebAssembly when the browser does not have WebAssembly support.</p>
			<p>In this chapter, we will understand how to install and use various tools provided by Binaryen. Understanding Binaryen and the tools provided by it will help you to optimize the WebAssembly binaries in terms of performance and size. We will cover the following sections in this chapter:</p>
			<ul>
				<li>Installing and using Binaryen</li>
				<li><strong class="source-inline">wasm-as</strong></li>
				<li><strong class="source-inline">wasm-dis</strong></li>
				<li><strong class="source-inline">wasm-opt</strong></li>
				<li><strong class="source-inline">wasm2js</strong></li>
			</ul>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor079"/>Technical requirements</h1>
			<p>We'll be requiring Binaryen and Visual C++ installed. You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-WebAssembly">https://github.com/PacktPublishing/Practical-WebAssembly</a>.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor080"/>Installing and using Binaryen</h1>
			<p>In order to install Binaryen, first clone<a id="_idIndexMarker261"/> the repository from<a id="_idIndexMarker262"/> GitHub:</p>
			<p class="source-code">$ git clone https://github.com/WebAssembly/binaryen</p>
			<p>After the repository is cloned, go into the folder:</p>
			<p class="source-code">$ cd binaryen</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor081"/>Linux/macOS</h2>
			<p>Generate the project build system<a id="_idIndexMarker263"/> by running the <strong class="source-inline">cmake</strong> command with the path to the <strong class="source-inline">binaryen</strong> folder:</p>
			<p class="source-code">$ cmake .</p>
			<p>Next, build the project<a id="_idIndexMarker264"/> using the <strong class="source-inline">make</strong> command:</p>
			<p class="source-code">$ make .</p>
			<p>This generates all the binaries in the <strong class="source-inline">bin</strong> fo<a id="_idTextAnchor082"/>lder.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor083"/>Windows</h2>
			<p>For Windows, once the repository<a id="_idIndexMarker265"/> is cloned, we will create a <strong class="source-inline">build</strong> directory and go inside it:</p>
			<p class="source-code">$ mkdir build</p>
			<p class="source-code">$ cd build</p>
			<p>By default, Windows does not have the cmake command available. Install the Visual C++ tools to make the <strong class="source-inline">cmake</strong> command available<a id="_idIndexMarker266"/> in the system. To install the Visual C++ tools, check out the following link: <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160&amp;viewFallbackFrom=vs-2019">https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160&amp;viewFallbackFrom=vs-2019</a>. Then, run the following command inside the <strong class="source-inline">build</strong> folder:</p>
			<p class="source-code">$ "&lt;path-to-visual-studio-root&gt;\Common7\IDE\CommonExtensions\</p>
			<p class="source-code">  Microsoft\CMake\CMake\bin\cmake.exe" ..</p>
			<p>The preceding command will generate all the necessary build files in the <strong class="source-inline">build</strong> directory. Then, we can build the project using the <strong class="source-inline">binaryen.vcxproj</strong> file generated by <strong class="source-inline">cmake</strong>:</p>
			<p class="source-code">$ msbuild binaryen.vcxproj</p>
			<p>The generated binary includes the following:</p>
			<p class="source-code">$ tree -L 1</p>
			<p class="source-code">├── wasm-as</p>
			<p class="source-code">├── wasm-ctor-eval</p>
			<p class="source-code">├── wasm-dis</p>
			<p class="source-code">├── wasm-emscripten-finalize</p>
			<p class="source-code">├── wasm-metadce</p>
			<p class="source-code">├── wasm-opt</p>
			<p class="source-code">├── wasm-reduce</p>
			<p class="source-code">├── wasm-shell</p>
			<p class="source-code">└── wasm2js </p>
			<p>The various tools generated<a id="_idIndexMarker267"/> by Binaryen are as follows: </p>
			<ul>
				<li><strong class="source-inline">wasm-as</strong> – This tool is similar to <strong class="source-inline">wat2wasm</strong> in WABT. This tool converts WebAssembly text format (<strong class="source-inline">.wast</strong>) into WebAssembly binary format (<strong class="source-inline">.wasm</strong>).</li>
				<li><strong class="source-inline">wasm-ctor-eval</strong> – This tool executes C++ global constructors ahead of time and has them ready. This optimization speeds up the WebAssembly execution.</li>
				<li><strong class="source-inline">wasm-dis</strong> – This tool is similar to <strong class="source-inline">wasm2wat</strong> in wabt. That is, it converts WebAssembly binary format (<strong class="source-inline">.wasm</strong>) into WebAssembly text format (<strong class="source-inline">.wat</strong>).</li>
				<li><strong class="source-inline">wasm-emscripten-finalize</strong> – This tool performs Emscripten-specific transforms on the given <strong class="source-inline">.wasm</strong> files.</li>
				<li><strong class="source-inline">wasm-metadce</strong> – This tool removes dead code in the provided WebAssembly binary.</li>
				<li><strong class="source-inline">wasm-opt</strong> – This tool optimizes the provided WebAssembly binary.</li>
				<li><strong class="source-inline">wasm-reduce</strong> – This tool reduces the given WebAssembly binary into a smaller binary.</li>
				<li><strong class="source-inline">wasm-shell</strong> – This tool creates a shell that can load and interpret WebAssembly code.</li>
				<li><strong class="source-inline">wasm2js</strong> – This tool is useful in polyfill. It converts WebAssembly into a JavaScript compiler.</li>
				<li><strong class="source-inline">binaryen.js</strong> – A standalone JavaScript library that exposes Binaryen methods for creating and optimizing the WebAssembly modules. This JavaScript file is just like any other JavaScript file that can be loaded into the browser.</li>
			</ul>
			<p>Now that we have built and generated the tools provided by Binaryen, let's explore the tools generated.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor084"/>wasm-as</h1>
			<p>The <strong class="source-inline">wasm-as</strong> tool converts WAST<a id="_idIndexMarker268"/> into WASM. Let's look at the steps:</p>
			<ol>
				<li>Let's create a new folder, called <strong class="source-inline">binaryen-playground</strong>, and go into the folder:<p class="source-code"><strong class="bold">$ mkdir binaryen-playground</strong></p><p class="source-code"><strong class="bold">$ cd binaryen-playground</strong></p></li>
				<li>Create a <strong class="source-inline">.wat</strong> file called <strong class="source-inline">add.wat</strong>:<p class="source-code"><strong class="bold">$ touch add.wat</strong></p></li>
				<li>Add the following contents to <strong class="source-inline">add.wat</strong>:<p class="source-code">(module</p><p class="source-code">    (func $add (param $x i32) (param $y i32) </p><p class="source-code">      (result i32)</p><p class="source-code">        (i32.add</p><p class="source-code">            (local.get $x)</p><p class="source-code">            (local.get $y)</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">)</p></li>
				<li>Convert the Web Assembly text format into a WebAssembly module, using the <strong class="source-inline">wasm-as</strong> binary:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-as add.wat</strong></p></li>
			</ol>
			<p>This generates the <strong class="source-inline">add.wasm</strong> file:</p>
			<p class="source-code">00 61 73 6d 01 00 00 00 01 07 01 60 02 7f 7f 01</p>
			<p class="source-code">7f 03 02 01 00 0a 09 01 07 00 20 00 20 01 6a 0b</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The size of the binary generated is just 32 bytes. </p>
			<p><strong class="source-inline">wasm-as</strong> first validates<a id="_idIndexMarker269"/> the given file (<strong class="source-inline">.wat</strong>) and then converts it into a <strong class="source-inline">.wasm</strong> file. To check various options supported by <strong class="source-inline">wasm-as</strong>, we can run the following command:</p>
			<p class="source-code">$ /path/to/build/directory/of/binaryen/wasm-as --help</p>
			<p class="source-code">wasm-as INFILE</p>
			<p class="source-code">Assemble a .wat (WebAssembly text format) into a .wasm (WebAssembly binary</p>
			<p class="source-code">format)</p>
			<p class="source-code">Options:</p>
			<p class="source-code">  --version                        Output version information     and exit</p>
			<p class="source-code">  --help,-h                        Show this help message and     exit</p>
			<p class="source-code">  --debug,-d                       Print debug information to     stderr</p>
			<p class="source-code">....</p>
			<p class="source-code">  --output,-o                      Output file (stdout if not </p>
			<p class="source-code">    specified)</p>
			<p class="source-code">  --validate,-v                    Control validation of the </p>
			<p class="source-code">    output module</p>
			<p class="source-code">  --debuginfo,-g                   Emit names section and debug</p>
			<p class="source-code">    info</p>
			<p class="source-code">  --source-map,-sm                 Emit source map to the </p>
			<p class="source-code">    specified file</p>
			<p class="source-code">  --source-map-url,-su             Use specified string as </p>
			<p class="source-code">    source map URL</p>
			<p class="source-code">  --symbolmap,-s                   Emit a symbol map (indexes </p>
			<p class="source-code">    =&gt; names)</p>
			<p>If we need to generate the WebAssembly module file in a different name, we will use the <strong class="source-inline">-o</strong> option with the filename. For example, <strong class="source-inline">wasm-as add.wat -o customAdd.wasm</strong> will generate <strong class="source-inline">customAdd.wasm</strong>.</p>
			<p><strong class="source-inline">wasm-as</strong> also provides verbose<a id="_idIndexMarker270"/> output that clearly explains how the WebAssembly module is structured. In order to see the structure of the WebAssembly module, we run it with the <strong class="source-inline">-d</strong> option:</p>
			<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-as add.wat -d</strong></p>
			<p class="source-code"><strong class="bold">Loading 'add.wat'...</strong></p>
			<p class="source-code"><strong class="bold">s-parsing...</strong></p>
			<p class="source-code"><strong class="bold">w-parsing</strong>...</p>
			<p class="source-code"><strong class="bold">Validating...</strong></p>
			<p class="source-code"><strong class="bold">writing...</strong></p>
			<p class="source-code"><strong class="bold">writing binary to add.wasm</strong></p>
			<p class="source-code"><strong class="bold">Opening 'add.wasm'</strong></p>
			<p class="source-code"><strong class="bold">== writeHeader</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">== writeTypes</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">== writeFunctionSignatures</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">== writeFunctions</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">finishUp</strong></p>
			<p class="source-code"><strong class="bold">Done.</strong></p>
			<p>The previous output is a detailed description<a id="_idIndexMarker271"/> of how the binary is generated. First, it loads the given <strong class="source-inline">.wat</strong> file. After that, it parses and validates the file. Finally, it creates <strong class="source-inline">add.wasm</strong> and writes the header, the type, function signatures, and functions. While generating the binary, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <strong class="source-inline">enable-*</strong> and <strong class="source-inline">disable-*</strong> options. Additionally, you can generate <strong class="source-inline">sourcemap</strong> using the <strong class="source-inline">--sm</strong> option.</p>
			<p>Now that we have seen how to convert WAST to WASM, let's see how to convert WASM to WAST.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor085"/>wasm-dis</h1>
			<p>The <strong class="source-inline">wasm-dis</strong> tool converts<a id="_idIndexMarker272"/> WAST into WASM. We will use the <strong class="source-inline">add.wasm</strong> file that we created in the previous example here. Let's look at the steps:</p>
			<ol>
				<li value="1">In order to convert the WebAssembly module into WebAssembly text format, using the <strong class="source-inline">wasm-dis</strong> binary, run the following command:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-dis add.wasm -o gen-add.wast</strong></p></li>
				<li>We generate the <strong class="source-inline">gen-add.wast</strong> file using the <strong class="source-inline">-o</strong> option with the filename (<strong class="source-inline">gen-add.wast</strong>):<p class="source-code">(module</p><p class="source-code">(type $i32_i32_=&gt;_i32 (func (param i32 i32) </p><p class="source-code">  (result i32)))</p><p class="source-code">(func $0 (param $0 i32) (param $1 i32) (result i32)</p><p class="source-code">           (i32.add  (local.get $0)  (local.get $1) )</p><p class="source-code">)</p><p class="source-code">)</p></li>
				<li><strong class="source-inline">wasm-dis</strong> first validates the given file (<strong class="source-inline">.wasm</strong>) and then converts it into a <strong class="source-inline">.wat</strong> file. To check various options<a id="_idIndexMarker273"/> supported by <strong class="source-inline">wasm-dis</strong>, run the following command:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-dis --help</strong></p><p class="source-code"><strong class="bold">wasm-dis INFILE </strong></p><p class="source-code"><strong class="bold">Un-assemble a .wasm (WebAssembly binary format) into a .wat (WebAssembly text</strong></p><p class="source-code"><strong class="bold">format)</strong></p><p class="source-code"><strong class="bold">Options:</strong></p><p class="source-code"><strong class="bold">  --version        Output version information and exit</strong></p><p class="source-code"><strong class="bold">  --help,-h        Show this help message and exit</strong></p><p class="source-code"><strong class="bold">  --debug,-d       Print debug information to stderr</strong></p><p class="source-code"><strong class="bold">  --output,-o      Output file (stdout if not specified)</strong></p><p class="source-code"><strong class="bold">  --source-map,-sm Consume source map from the specified file to add location</strong></p></li>
				<li><strong class="source-inline">wasm-dis</strong> also provides verbose output that clearly explains how the WebAssembly module is structured. In order to see the structure of the WebAssembly module, we run it with the <strong class="source-inline">-d</strong> option:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm-dis</strong></p><p class="source-code"><strong class="bold">  add.wat -o gen-add.wast -d</strong></p><p class="source-code"><strong class="bold">parsing binary...</strong></p><p class="source-code"><strong class="bold">reading binary from add.wasm</strong></p><p class="source-code"><strong class="bold">Loading 'add.wasm'...</strong></p><p class="source-code"><strong class="bold">== readHeader</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">== readSignatures</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">== readFunctionSignatures</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">== processExpressions</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">== processExpressions finished</strong></p><p class="source-code"><strong class="bold">end function bodies</strong></p><p class="source-code"><strong class="bold">Printing...</strong></p><p class="source-code"><strong class="bold">Opening 'gen-add.wast'</strong></p><p class="source-code"><strong class="bold">Done.</strong></p></li>
			</ol>
			<p>The previous output is a detailed<a id="_idIndexMarker274"/> description of how the <strong class="source-inline">.wast</strong> file is generated. First, it loads the given <strong class="source-inline">.wasm</strong> file. After that, it parses and validates the file. Finally, it creates <strong class="source-inline">gen-add.wast</strong> after reading the header, type, function signatures, and functions.</p>
			<p>While generating the file, we can enable the compiler to include the new and shiny features and disable various existing features using the appropriate <strong class="source-inline">enable-*</strong> and <strong class="source-inline">disable-*</strong> options, respectively.</p>
			<p>Additionally, we can also input <strong class="source-inline">sourcemap</strong> using the <strong class="source-inline">--sm &lt;filename&gt; </strong>option.</p>
			<p>Now that we have seen how to convert WASM to WAST, let's see how to optimize the WebAssembly binaries further.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor086"/>wasm-opt</h1>
			<p>The <strong class="source-inline">wasm-opt</strong> tool is a <strong class="source-inline">wasm-to-wasm</strong> optimizer. It will receive<a id="_idIndexMarker275"/> a WebAssembly module as input and run transformation passes on it to optimize and generate the optimized WebAssembly module. Let's look at the steps:</p>
			<ol>
				<li value="1">Let's first create the <strong class="source-inline">inline-optimizer.wast</strong> file and add the following content:<p class="source-code">(module</p><p class="source-code">    (func $parent (export "parent") (result i32)</p><p class="source-code">        (i32.add</p><p class="source-code">            (call $child)</p><p class="source-code">            (i32.const 13)</p><p class="source-code">        )</p><p class="source-code">    )</p><p class="source-code">    (func $child (result i32) (call $grandChild))</p><p class="source-code">    (func $grandChild (result i32) (call</p><p class="source-code">       $greatGrandChild))</p><p class="source-code">    (func $greatGrandChild (result i32) (i32.const 7))</p><p class="source-code">)</p></li>
				<li>To generate the WebAssembly<a id="_idIndexMarker276"/> module, we will run the following:<p class="source-code"><strong class="bold">$ /path/to/bin/folder/of/binaryen/wasm-opt inline-</strong></p><p class="source-code"><strong class="bold">  optimizer.wast -o inline.wasm --print</strong></p><p class="source-code"><strong class="bold">(module</strong></p><p class="source-code"><strong class="bold">(type $0 (func (result i32)))</strong></p><p class="source-code"><strong class="bold">(export "parent" (func $parent))</strong></p><p class="source-code"><strong class="bold">(func $parent (; 0 ;) (type $0) (result i32)</strong></p><p class="source-code"><strong class="bold">(i32.add</strong></p><p class="source-code"><strong class="bold">(call $child)</strong></p><p class="source-code"><strong class="bold">(i32.const 13)</strong></p><p class="source-code"><strong class="bold">  )</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code"><strong class="bold">(func $child (; 1 ;) (type $0) (result i32)</strong></p><p class="source-code"><strong class="bold">  (call $grandChild)</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code"><strong class="bold">(func $grandChild (; 2 ;) (type $0) (result i32)</strong></p><p class="source-code"><strong class="bold">  (call $greatGrandChild)</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code"><strong class="bold">(func $greatGrandChild (; 3 ;) (type $0) (result i32)</strong></p><p class="source-code"><strong class="bold">  (i32.const 7)</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code"><strong class="bold">)</strong></p></li>
			</ol>
			<p>This will generate <strong class="source-inline">inline.wasm</strong>. The <strong class="source-inline">--print</strong> option prints the WebAssembly text format before converting<a id="_idIndexMarker277"/> it to the WebAssembly binary. We also passed in the <strong class="source-inline">-o</strong> option to output the WebAssembly module as <strong class="source-inline">inline.wasm</strong>:</p>
			<p class="source-code"><strong class="bold">60B inline-optimize.wasm</strong></p>
			<p class="source-code"><strong class="bold">273B inline-optimize.wat</strong></p>
			<p>This generated binary of 60 bytes in memory. </p>
			<ol>
				<li value="3">We can further optimize the binary with the <strong class="source-inline">--inlining-optimizing</strong> option:<p class="source-code"><strong class="bold">$ /path/to/bin/folder/of/binaryen/wasm-opt inline-</strong></p><p class="source-code"><strong class="bold">  optimizer.wast -o inline.wasm --print --inlining-</strong></p><p class="source-code"><strong class="bold">  optimizing</strong></p></li>
			</ol>
			<p>This will optimize the functions and inline the functions where the binary is called. Let's check what the file size generated is:</p>
			<p class="source-code"><strong class="bold">39B inline-optimize.wasm</strong></p>
			<p class="source-code"><strong class="bold">273B inline-optimize.wat</strong></p>
			<p>The generated file is just 39 bytes, which is 35% less than the original binary. </p>
			<ol>
				<li value="4">To check various options supported by <strong class="source-inline">wasm-opt</strong>, run the following command:<p class="source-code"><strong class="bold">/path/to/bin/folder/of/binaryen/wasm-opt –help</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">wasm-opt</strong> tool helps us to optimize<a id="_idIndexMarker278"/> the WebAssembly binaries further. Let's next explore the <strong class="source-inline">wasm2js</strong> tool.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor087"/>wasm2js</h1>
			<p>The <strong class="source-inline">wasm2js</strong> tool converts WASM/WAST files<a id="_idIndexMarker279"/> into JavaScript files. Let's look at the steps:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">add-with-export.wast</strong>:<p class="source-code"><strong class="bold">$ touch add-with-export.wast</strong></p></li>
			</ol>
			<p>Then, add the following code:</p>
			<p class="source-code">(module</p>
			<p class="source-code">    (export "add" (func $add))</p>
			<p class="source-code">    (func $add (param $x i32) (param $y i32) </p>
			<p class="source-code">      (result i32)</p>
			<p class="source-code">        (i32.add</p>
			<p class="source-code">            (local.get $x)</p>
			<p class="source-code">            (local.get $y)</p>
			<p class="source-code">        )</p>
			<p class="source-code">    )</p>
			<p class="source-code">)</p>
			<ol>
				<li value="2">In order to convert the WebAssembly text format into JavaScript using <strong class="source-inline">wasm2js</strong>, run the following command:<p class="source-code"><strong class="bold">$ /path/to/build/directory/of/binaryen/wasm2js add-</strong></p><p class="source-code"><strong class="bold">  with-export.wast</strong></p></li>
			</ol>
			<p>This will print out the generated<a id="_idIndexMarker280"/> JavaScript:</p>
			<p class="source-code">function asmFunc(global, env) {</p>
			<p class="source-code">var Math_imul = global.Math.imul;</p>
			<p class="source-code">var Math_fround = global.Math.fround;</p>
			<p class="source-code">var Math_abs = global.Math.abs;</p>
			<p class="source-code">var Math_clz32 = global.Math.clz32;</p>
			<p class="source-code">var Math_min = global.Math.min;</p>
			<p class="source-code">var Math_max = global.Math.max;</p>
			<p class="source-code">var Math_floor = global.Math.floor;</p>
			<p class="source-code">var Math_ceil = global.Math.ceil;</p>
			<p class="source-code">var Math_sqrt = global.Math.sqrt;</p>
			<p class="source-code">var abort = env.abort;</p>
			<p class="source-code">var nan = global.NaN;</p>
			<p class="source-code">var infinity = global.Infinity;</p>
			<p class="source-code">function add(x, y) {</p>
			<p class="source-code">  x = x | 0;</p>
			<p class="source-code">  y = y | 0;</p>
			<p class="source-code">  return x + y | 0 | 0;</p>
			<p class="source-code">}</p>
			<p class="source-code">return {</p>
			<p class="source-code">  "add": add</p>
			<p class="source-code">};</p>
			<p class="source-code">}</p>
			<p class="source-code">var retasmFunc = asmFunc({</p>
			<p class="source-code">    Math,</p>
			<p class="source-code">    Int8Array,</p>
			<p class="source-code">    Uint8Array,</p>
			<p class="source-code">    Int16Array,</p>
			<p class="source-code">    Uint16Array,</p>
			<p class="source-code">    Int32Array,</p>
			<p class="source-code">    Uint32Array,</p>
			<p class="source-code">    Float32Array,</p>
			<p class="source-code">    Float64Array,</p>
			<p class="source-code">    NaN,</p>
			<p class="source-code">    Infinity</p>
			<p class="source-code">  }, {</p>
			<p class="source-code">    abort: function() { throw new Error('abort'); }</p>
			<p class="source-code">  });</p>
			<p class="source-code">export var add = retasmFunc.add;</p>
			<p>The <strong class="source-inline">asmFunc</strong> function<a id="_idIndexMarker281"/> is defined. In <strong class="source-inline">asmFunc</strong>, we import the math functions from the global object. After that, we have an <strong class="source-inline">add</strong> function. The <strong class="source-inline">add</strong> function initializes <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. The function returns the sum of two values. Finally, we return the <strong class="source-inline">add</strong> function.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The generated JavaScript is <strong class="source-inline">asmjs</strong> and not normal JavaScript. We also imported a lot of functions from the global namespace in JavaScript into <strong class="source-inline">asmFunc</strong>.</p>
			<p>The <strong class="source-inline">wasm2js</strong> tool makes it easy to generate JavaScript from a WebAssembly module. The generated JavaScript module<a id="_idIndexMarker282"/> is faster than its normal JavaScript counterpart. This can be used as a polyfill for browsers that do not support WebAssembly yet.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we have seen how to install Binaryen and what the various tools provided by the Binaryen toolkit are. Binaryen makes it easier to convert WebAssembly modules into various formats. It is an important tool that makes your WebAssembly journey easier and more efficient.</p>
			<p>In the next chapter, we will start our Rust and WebAssembly journey.</p>
		</div>
	</body></html>