- en: Storing and Retrieving Data
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和检索数据
- en: A typical need of any software application is to input/output data by reading/writing
    data files or data streams or by querying/manipulating a database. Regarding files
    and streams, unstructured data, or even binary data, is hard to manipulate, and
    so they are not recommended.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件应用的典型需求是通过读取/写入数据文件或数据流或通过查询/操作数据库来输入/输出数据。至于文件和流，非结构化数据，甚至二进制数据，很难操作，因此不建议使用。
- en: Also, proprietary data formats are not recommended because of the vendor lock-in
    risk, and so only standard data formats should be used. Fortunately, there are
    free Rust libraries that come to the rescue in these situations. There are Rust
    crates available to manipulate some of the most popular file formats, such as
    TOML, JSON, and XML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于供应商锁定风险，不建议使用专有数据格式，因此应仅使用标准数据格式。幸运的是，在这些情况下，有免费的 Rust 库可以提供帮助。有 Rust crate
    可以操作一些最受欢迎的文件格式，例如 TOML、JSON 和 XML。
- en: In terms of databases, there are Rust crates to manipulate data using some of
    the most popular databases, such as SQLite, PostgreSQL, and Redis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库方面，有 Rust crate 可以用来操作一些最受欢迎的数据库，例如 SQLite、PostgreSQL 和 Redis。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How to read configuration data from a TOML file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从 TOML 文件中读取配置数据
- en: How to read or write a JSON data file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取或写入 JSON 数据文件
- en: How to read an XML data file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取 XML 数据文件
- en: How to query or manipulate data in a SQLite database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询或操作 SQLite 数据库中的数据
- en: How to query or manipulate data in a PostgreSQL database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询或操作 PostgreSQL 数据库中的数据
- en: How to query or manipulate data in a Redis database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询或操作 Redis 数据库中的数据
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is required for you to install the SQLite runtime library when you're running
    the SQLite code. However, it is also useful (although not required) to install
    a SQLite interactive manager. You can download the precompiled binaries of SQLite
    tools from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).
    However, version 3.11 or higher would be ideal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 SQLite 代码时，需要安装 SQLite 运行时库。然而，安装 SQLite 交互式管理器也是有用的（尽管不是必需的）。你可以从[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)下载
    SQLite 工具的预编译二进制文件。然而，版本 3.11 或更高版本是理想的。
- en: Please note that if you're using Debian-derived Linux distribution, the `libsqlite3-dev` package should
    be installed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用的是基于 Debian 的 Linux 发行版，应该安装`libsqlite3-dev`包。
- en: It is also required for you to install and run the PostgreSQL **Database Management
    System** (**DBMS**) when you're running the PostgreSQL code. As with SQLite, it
    is useful but not required to install a PostgreSQL interactive manager. You can
    download the precompiled binary of PostgreSQL DBMS from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    However, version 7.4 or higher would be acceptable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 PostgreSQL 代码时，还需要安装和运行 PostgreSQL **数据库管理系统**（**DBMS**）。与 SQLite 类似，安装
    PostgreSQL 交互式管理器是有用的，但不是必需的。你可以从[https://www.postgresql.org/download/](https://www.postgresql.org/download/)下载
    PostgreSQL DBMS 的预编译二进制文件。然而，版本 7.4 或更高版本是可以接受的。
- en: Installing and running the Redis server is necessary when you're running the
    Redis code. You can download it from [https://redis.io/download](https://redis.io/download).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 Redis 代码时，安装和运行 Redis 服务器是必要的。你可以从[https://redis.io/download](https://redis.io/download)下载它。
- en: The complete source code for this chapter can be found in the `Chapter02` folder of
    the repository at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
    In this folder, there is a sub-folder for every project, plus a folder named `data`,
    which contains the data that we'll use as input for the projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers)存储库的`Chapter02`文件夹中找到。在这个文件夹中，每个项目都有一个子文件夹，还有一个名为`data`的文件夹，其中包含我们将用作项目输入的数据。
- en: Project overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'In this chapter, we''ll look at how to build a program that loads a JSON file
    and an XML file into three databases: a SQLite database, a PostgreSQL database,
    and a Redis key-value store. To avoid hardwiring the names and positions of the
    files and the database credentials into the program, we are going to load them
    from a TOML configuration file.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何构建一个程序，该程序将JSON文件和XML文件加载到三个数据库中：SQLite数据库、PostgreSQL数据库和Redis键值存储。为了避免将文件名和位置以及数据库凭据硬编码到程序中，我们将从TOML配置文件中加载它们。
- en: 'The final project is named `transformer`, but we''ll explain this through several
    preliminary small projects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个项目命名为 `transformer`，但我们将通过几个初步的小项目来解释这一点：
- en: '`toml_dynamic` and `toml_static`: These read a TOML file in two different ways.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toml_dynamic` 和 `toml_static`: 这两种方式以不同的方式读取一个TOML文件。'
- en: '`json_dynamic` and `json_static`: These read a JSON file in two different ways.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json_dynamic` 和 `json_static`: 这两种方式以不同的方式读取一个JSON文件。'
- en: '`xml_example`: This reads an XML file.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xml_example`: 这将读取一个XML文件。'
- en: '`sqlite_example`: This creates two tables in a SQLite database, inserts records
    into them, and queries them.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite_example`: 这将在SQLite数据库中创建两个表，向它们插入记录并查询它们。'
- en: '`postgresql_example`: This creates two tables in a PostgreSQL database, inserts
    records into them, and queries them.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postgresql_example`: 这将在PostgreSQL数据库中创建两个表，向它们插入记录并查询它们。'
- en: '`redis_example`: This adds some data to a key-value store and queries it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redis_example`: 这向一个键值存储添加一些数据并查询它。'
- en: Reading a TOML file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取一个TOML文件
- en: One simple and maintainable way to store information in a filesystem is to use
    a text file. This is also very efficient for data spanning no more than 100 KB.
    However, there are several competing standards for storing information in text
    files, such as INI, CSV, JSON, XML, YAML, and others.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中存储信息的一个简单且易于维护的方法是使用文本文件。这对于数据量不超过100 KB的情况也非常高效。然而，在文本文件中存储信息存在几个相互竞争的标准，如INI、CSV、JSON、XML、YAML等。
- en: The one used by Cargo is TOML. This is a really powerful format that is used
    by many Rust developers to store the configuration data of their apps. It is designed
    to be written by hand, using a text editor, but it can also be written by an application
    very easily.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo使用的格式是TOML。这是一个非常强大的格式，被许多Rust开发者用来存储他们应用程序的配置数据。它设计为手动编写，使用文本编辑器，但它也可以很容易地由应用程序编写。
- en: The `toml_dynamic` and `toml_static` projects (using the `toml` crate) load
    data from a TOML file. Reading a TOML file is useful when configuring a software
    application, and this is what we'll do. We will use the `data/config.toml` file,
    which contains all of the parameters for the projects of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`toml_dynamic` 和 `toml_static` 项目（使用 `toml` 包）从TOML文件加载数据。在配置软件应用程序时读取TOML文件非常有用，这正是我们将要做的。我们将使用
    `data/config.toml` 文件，它包含本章所有项目的所有参数。'
- en: You can also create or modify a TOML file by using code, but we are not going
    to do that. Being able to modify a TOML file can be useful in some scenarios,
    such as to save user preferences.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用代码来创建或修改一个TOML文件，但我们不会这么做。在某些场景下，能够修改TOML文件可能很有用，例如保存用户偏好设置。
- en: 'It is important to consider that when a TOML file is changed by a program,
    it undergoes dramatic restructuring:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要考虑，当TOML文件被程序修改时，它会经历重大的重构：
- en: It acquires specific formatting, which you may dislike.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它获得了特定的格式，你可能不喜欢。
- en: It loses all of its comments.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它失去了所有的注释。
- en: Its items are sorted alphabetically.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的项目按字母顺序排序。
- en: 'So, if you want to use the TOML format both for manually edited parameters
    and for program-saved data, you would be better off using two distinct files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想同时使用TOML格式手动编辑参数和程序保存的数据，您最好使用两个不同的文件：
- en: One edited only by humans
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个仅由人类编辑的
- en: One edited primarily by your software, but occasionally also by humans
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要由你的软件编辑，但偶尔也由人类编辑
- en: 'This chapter describes two projects in which a TOML file is read using different
    techniques. These techniques are to be used in two different cases:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了两个项目，在这些项目中使用不同的技术读取TOML文件。这些技术将在两种不同的情况下使用：
- en: In a situation where we are not sure which fields are contained in the file,
    and so we want to explore it. In this case, we use the `toml_dynamic` program.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们不确定文件中包含哪些字段的情况下，我们想要探索它。在这种情况下，我们使用 `toml_dynamic` 程序。
- en: In another situation where, in our program, we describe exactly which fields
    should be contained in the file and we don't accept a different format. In this
    case, we use the `toml_static` program.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一种情况下，在我们的程序中，我们精确地描述了文件中应包含哪些字段，并且不接受不同的格式。在这种情况下，我们使用`toml_static`程序。
- en: Using toml_dynamic
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 toml_dynamic
- en: 'The purpose of this section is to read the `config.toml` file, located in the
    `data` folder, when we want to explore the content of that file. The first three
    lines of this file are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的在于在我们想要探索该文件内容时读取位于`data`文件夹中的`config.toml`文件。该文件的最初三行如下：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After these lines, the file contains other sections. Among them is the `[postgresql]` section,
    which contains the following line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行之后，文件包含其他部分。其中之一是`[postgresql]`部分，它包含以下行：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run this project, enter the `toml_dynamic` folder and type in `cargo run
    ../data/config.toml`. A long output should be printed. It will begin with the
    following lines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此项目，请进入`toml_dynamic`文件夹，并输入`cargo run ../data/config.toml`。应该打印出长输出。它将从以下行开始：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that this is just a verbose representation of the first three lines
    of the `config.toml` file. This output proceeds with emitting a similar representation
    for the rest of the file. After having printed the whole data structure representing
    the file that is read, the following line is added to the output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅仅是`config.toml`文件前三行的详细表示。此输出随后继续发出文件其余部分的类似表示。在打印出表示读取的文件的整个数据结构之后，输出中添加了以下行：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the result of a specific query on the data structure loaded when the
    file is read.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读取文件时加载数据结构的具体查询结果。
- en: 'Let''s look at the code of the `toml_dynamic` program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`toml_dynamic`程序的代码：
- en: 'Declare a variable that will contain a description of the whole file. This
    variable is initialized in the next three statements:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量，该变量将包含整个文件的描述。此变量在接下来的三个语句中初始化：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We add the pathname of the file from the first argument in the command line to
    `config_path`. Then, we load the contents of this file into the `config_text` string and
    we parse this string into a `toml::Value` structure. This is a recursive structure
    because it can have a `Value` property among its fields:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将命令行中的第一个参数中的文件路径添加到`config_path`中。然后，我们将此文件的 内容加载到`config_text`字符串中，并将此字符串解析为`toml::Value`结构。这是一个递归结构，因为它可以在其字段中具有`Value`属性：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This structure is then printed using the debug structured formatting (`:#?`),
    and a value is retrieved from it:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用调试结构化格式（`:#?`）打印此结构，并从中检索一个值：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that to get the value of the `"database"` item contained the `"postgresql"`
    section, a lot of code is required. The `get` function needs to look for a string,
    which may fail. That is the price of uncertainty.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要获取包含在`"postgresql"`部分中的`"database"`项的值，需要编写大量的代码。`get`函数需要查找一个字符串，这可能会失败。这就是不确定性的代价。
- en: Using toml_static
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 toml_static
- en: On the other hand, if we are quite sure of the organization of our TOML file,
    we should use another technique shown in the project, `toml_static`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们对TOML文件的组织结构非常有信心，我们应该使用项目中展示的另一种技术，即`toml_static`。
- en: 'To run it, open the `toml_static` folder and type in `cargo run ../data/config.toml`.
    The program will only print the following line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，请打开`toml_static`文件夹，并输入`cargo run ../data/config.toml`。程序将仅打印以下行：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This project uses two additional crates:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目使用两个额外的crate：
- en: '`serde`: This enables the use of the basic serialization/deserialization operations.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serde`: 这启用了基本序列化/反序列化操作。'
- en: '`serde_derive`: This provides a powerful additional feature known as the **custom-derive**
    feature, which allows you to serialize/deserialize using a struct.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serde_derive`: 这提供了一个名为**custom-derive**的强大附加功能，允许您使用结构体进行序列化/反序列化。'
- en: '`serde` is the standard serialization/deserialization library. **Serialization**
    is the process of converting data structures of the program into a string (or
    a stream). **Deserialization** is the reverse process; it is the process of converting
    a string (or a stream) into some data structures of the program.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`serde`是标准的序列化/反序列化库。**序列化**是将程序中的数据结构转换为字符串（或流）的过程。**反序列化**是相反的过程；它是将字符串（或流）转换为程序中的某些数据结构的过程。'
- en: To read a TOML file, we need to use deserialization.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取TOML文件，我们需要使用反序列化。
- en: In these two projects, we don't need to use serialization as we are not going
    to write a TOML file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个项目中，我们不需要使用序列化，因为我们不打算编写TOML文件。
- en: In the code, first, a struct is defined for any section contained in the `data/config.toml` file.
    That file contains the `Input`, `Redis`, `Sqlite`, and `Postgresql` sections,
    and so we declare as many Rust structs as the sections of the file we want to
    read; then, the `Config` struct is defined to represent the whole file, having
    these sections as members.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，首先，为`data/config.toml`文件中包含的任何部分定义了一个结构。该文件包含`Input`、`Redis`、`Sqlite`和`Postgresql`部分，因此我们声明了与我们要读取的文件部分一样多的Rust结构；然后，定义了`Config`结构来表示整个文件，这些部分作为其成员。
- en: 'For example, this is the structure for the `Input` section:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是`Input`部分的架构：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the preceding declaration is preceded by two attributes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的声明前面有两个属性。
- en: The `allow(unused)` attribute is used to prevent the compiler from warning us
    about unused fields in the following structure. It is convenient for us to avoid
    these noisy warnings. The `derive(Deserialize)` attribute is used to activate
    the automatic deserialization initiated by `serde` for the following structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`allow(unused)`属性来防止编译器警告我们关于以下结构中未使用的字段。这对于我们避免这些嘈杂的警告很方便。使用`derive(Deserialize)`属性来激活`serde`对以下结构的自动反序列化。
- en: 'After these declarations, it is possible to write the following line of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些声明之后，可以编写以下代码行：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This invokes the `from_str` function, which parses the text of the file into
    a struct. The type of that struct is not specified in this expression, but its
    value is assigned to the variable declared in the first line of the `main` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用`from_str`函数，该函数将文件的文本解析为结构。此表达式中未指定该结构的类型，但其值被分配给`main`函数第一行中声明的变量：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, its type is `Config`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它的类型是`Config`。
- en: Any discrepancies between the file's contents and the struct type will be considered
    an error in this operation. So, if this operation is successful, any other operation
    on the structure cannot fail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件内容与结构类型之间存在任何差异，将在此操作中视为错误。因此，如果此操作成功，对结构的任何其他操作都不会失败。
- en: While the previous program (`toml_dynamic`) had a kind of dynamic typing, such
    as that of Python or JavaScript, this program has a kind of static typing, similar
    to Rust or C++.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的程序（`toml_dynamic`）具有类似于Python或JavaScript的动态类型，但此程序具有类似于Rust或C++的静态类型。
- en: The advantage of static typing appears in the last statement, where the same
    behavior as the long statement of the previous project is obtained by simply writing
    `config_const_values.postgresql.database`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型的优势体现在最后一条语句中，通过简单地编写`config_const_values.postgresql.database`，就获得了与先前项目长语句相同的行为。
- en: Reading and writing a JSON file
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入JSON文件
- en: For storing data that is more complex than that which is stored in a configuration
    file, JSON format is more appropriate. This format is quite popular, particularly
    among those who use the JavaScript language.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储比配置文件中存储的数据更复杂的数据，JSON格式更为合适。这种格式相当流行，尤其是在使用JavaScript语言的人中。
- en: We are going to read and parse the `data/sales.json` file. This file contains
    a single anonymous object, which contains two arrays—`"products"` and `"sales"`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取并解析`data/sales.json`文件。此文件包含一个单个匿名对象，该对象包含两个数组——`"products"`和`"sales"`。
- en: 'The `"products"` array contains two objects, each one having three fields:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`"products"`数组包含两个对象，每个对象都有三个字段：'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `"sales"` array contains three objects, each one containing five fields:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`"sales"`数组包含三个对象，每个对象包含五个字段：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The information in the arrays is about some products to sell and some sale transactions
    associated with those products. Notice that the second field of each sale (`"product_id"`)
    is a reference to a product, and so it should be processed after the corresponding
    product object has been created.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的信息涉及一些要出售的产品以及与这些产品相关的销售交易。请注意，每个销售的第二字段（`"product_id"`）是对一个产品的引用，因此它应该在相应的产品对象创建后进行处理。
- en: We will see a pair of programs with the same behavior. They read the JSON file,
    increment the quantity of the second sale object by `1.5`, and then save the whole
    updated structure into another JSON file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到具有相同行为的两个程序。它们读取JSON文件，将第二个销售对象的数量增加`1.5`，然后将整个更新后的结构保存到另一个JSON文件中。
- en: Similarly to the TOML format case, there can also be a dynamic parsing technique used for
    JSON files, where the existence and type of any data field is checked by the application
    code, and a static parsing technique, where it uses the deserialization library
    to check the existence and type of any field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 TOML 格式的情况，对于 JSON 文件也可以使用动态解析技术，其中任何数据字段的存在的类型由应用程序代码检查，以及静态解析技术，其中它使用反序列化库来检查任何字段的存在的类型。
- en: So, we have two projects: `json_dynamic` and `json_static`. To run each of them,
    open its folder and type in `cargo run ../data/sales.json ../data/sales2.json`.
    The program will not print anything, but it will read the first file specified
    in the command line and create the second file that is specified.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两个项目：`json_dynamic` 和 `json_static`。要运行每个项目，打开其文件夹，并输入 `cargo run ../data/sales.json
    ../data/sales2.json`。程序将不会打印任何内容，但它将读取命令行中指定的第一个文件，并创建指定的第二个文件。
- en: 'The created file is similar to the read file, but with the following differences:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件与读取的文件相似，但有以下不同之处：
- en: The fields of the file created by `json_dynamic` are sorted in alphabetical
    order, while the fields of the file created by `json_static` are sorted in the
    same order as in the Rust data structure.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `json_dynamic` 创建的文件的字段按字母顺序排序，而由 `json_static` 创建的文件的字段按 Rust 数据结构的相同顺序排序。
- en: The quantity of the second sale is incremented from `2.14` to `3.64`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次销售的量从 `2.14` 增加到 `3.64`。
- en: The final empty line is removed in both created files.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个创建的文件中，最后的空行都被移除了。
- en: Now, we can see the implementations of the two techniques of serialization and
    deserialization.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到序列化和反序列化的两种技术的实现。
- en: The json_dynamic project
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`json_dynamic` 项目'
- en: 'Let''s look at the source code of the project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个项目的源代码：
- en: This project gets the pathnames of two files from the command line—the existing
    JSON file (`"input_path"`) to read into a memory structure and a JSON file to
    create (`"output_path"`) by saving the loaded structure, after having modified
    it a bit.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '此项目从命令行获取两个文件的路径名——现有的 JSON 文件（`"input_path"`)，将其读入内存结构中，以及一个要创建的 JSON 文件（`"output_path"`)，通过保存修改后的结构来创建。 '
- en: Then, the input file is loaded into the string named `sales_and_products_text` and
    the generic `serde_json::from_str::<Value>` function is used to parse the string
    into a dynamically typed structure representing the JSON file. This structure
    is stored in the `sales_and_products` local variable.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将输入文件加载到名为 `sales_and_products_text` 的字符串中，并使用 `serde_json::from_str::<Value>`
    函数将字符串解析为表示 JSON 文件的动态类型结构。此结构存储在 `sales_and_products` 本地变量中。
- en: 'Imagine that we want to change the quantity sold by the second sale transaction,
    incrementing it by `1.5` kilograms:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要改变第二个销售交易的销量，增加 `1.5` 公斤：
- en: 'First, we must get to this value using the following expression:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用以下表达式获取此值：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This retrieves the `"sales"` sub-object of the general object. It is an array
    containing three objects.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这检索了通用对象的 `"sales"` 子对象。它是一个包含三个对象的数组。
- en: Then, this expression gets the second item (starting from zero (`[1]`)) of this
    array. This is an object representing a single sale transaction.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，这个表达式获取这个数组的第二个项目（从零开始计数 `[1]`）。这是一个表示单个销售交易的对象。
- en: After this, it gets the `"quantity"` sub-object of the sale transaction object.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它获取销售交易对象的 `"quantity"` 子对象。
- en: The value we have reached has a dynamic type that we think should be `serde_json::Value::Number`,
    and so we make a pattern matching with this type, specifying the `if let Value::Number(n)` clause.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们达到的值具有动态类型，我们认为应该是 `serde_json::Value::Number`，因此我们与该类型进行模式匹配，指定 `if let Value::Number(n)`
    子句。
- en: 'If all is good, the matching succeeds and we get a variable named `n`—containing
    a number, or something that can be converted into a Rust floating-point number
    by using the `as_f64` function. Lastly, we can increment the Rust number and then
    create a JSON number from it using the `from_f64` function. We can then assign
    this object to the JSON structure using the same expression we used to get it:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，匹配成功，我们将得到一个名为 `n` 的变量——包含一个数字，或者可以通过使用 `as_f64` 函数将其转换为 Rust 浮点数的东西。最后，我们可以增加
    Rust 数字，然后使用 `from_f64` 函数从它创建一个 JSON 数字。然后我们可以使用相同的表达式将此对象分配给 JSON 结构：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last statement of the program saves the JSON structure to a file. Here,
    the `serde_json::to_string_pretty` function is used. As the name suggests, this
    function adds formatting whitespace (blanks and new lines) to make the resulting
    JSON file more human-readable. There is also the `serde_json::to_string` function,
    which creates a more compact version of the same information. It is much harder for
    people to read, but it is somewhat quicker to process for a computer:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的最后一条语句将 JSON 结构保存到文件中。在这里，使用了 `serde_json::to_string_pretty` 函数。正如其名所示，这个函数添加了格式化空白（空格和新行），使得生成的
    JSON 文件更易于人类阅读。还有一个 `serde_json::to_string` 函数，它创建了一个更紧凑的相同信息版本。对于人类来说，阅读起来更困难，但对于计算机来说处理速度更快：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The json_static project
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`json_static` 项目'
- en: If, for our program, we are sure that we know the structure of the JSON file,
    a statically typed technique can and should be used instead. It is shown in the `json_static` project.
    The situation here is similar to that of the projects processing the TOML file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确信我们的程序知道 JSON 文件的结构，可以使用静态类型技术，这是在 `json_static` 项目中展示的。这里的情形与处理 TOML 文件的项目类似。
- en: 'The source code of the static version first declares three structs—one for
    every object type contained in the JSON file we are going to process. Each struct
    is preceded by the following attribute:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 静态版本源代码首先声明了三个结构体——每个结构体对应于我们将要处理的 JSON 文件中包含的对象类型。每个结构体前面都有以下属性：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s understand the preceding snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码片段：
- en: The `Deserialize` trait is required to parse (that is, read) JSON strings into
    this struct.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deserialize` 特性是必需的，用于将 JSON 字符串解析（即读取）到这个结构体中。'
- en: The `Serialize` trait is required to format (that is, write) this struct into
    a JSON string.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Serialize` 特性是必需的，用于将这个结构体格式化（即写入）为 JSON 字符串。'
- en: The `Debug` trait is just handy for printing this struct on a debug trace.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug` 特性非常适合在调试跟踪中打印这个结构体。'
- en: 'The JSON string is parsed using the `serde_json::from_str::<SalesAndProducts>` function.
    Then, the code to increment the quantity of sold oranges becomes quite simple:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `serde_json::from_str::<SalesAndProducts>` 函数解析 JSON 字符串。然后，增加已售橙子的数量的代码变得相当简单：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rest of the program is unchanged.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分保持不变。
- en: Reading an XML file
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 XML 文件
- en: Another very popular text format is XML. Unfortunately, there is no stable serialization/deserialization
    library to manage XML format. However, this is not necessarily a shortcoming.
    In actual fact, XML format is often used to store large datasets; so large, in
    fact, that it would be inefficient to load them all before we start converting
    the data into an internal format. In these cases, it may be more efficient to
    scan the file or incoming stream and process it as long as it is read.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常流行的文本格式是 XML。不幸的是，没有稳定的序列化/反序列化库来管理 XML 格式。然而，这并不一定是缺点。实际上，XML 格式通常用于存储大型数据集；实际上非常大，以至于在我们开始将数据转换为内部格式之前，加载所有这些数据可能是不高效的。在这些情况下，扫描文件或传入的流并读取时进行处理可能更有效。
- en: 'The `xml_example` project is a rather convoluted program that scans the XML
    file specified on the command line and, in a procedural fashion, loads information
    from the file into a Rust data structure. It is meant to read the `../data/sales.xml` file.
    This file has a structure corresponding to the JSON file we sought in the previous
    section. The following lines show an excerpt of that file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`xml_example` 项目是一个相当复杂的程序，它扫描命令行上指定的 XML 文件，并以过程式的方式将文件中的信息加载到 Rust 数据结构中。它的目的是读取
    `../data/sales.xml` 文件。这个文件的结构与我们在上一节中寻找的 JSON 文件相对应。以下是一些该文件的摘录：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All XML files have a header in the first line and then one root element; in
    this case, the root element it is named `sales-and-products`. This element contains
    two kinds of elements—`product` and `sale`. Both kinds of elements have specific
    sub-elements, which are the fields of the corresponding data. In this example,
    only the `id` fields are shown.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 XML 文件的第一行都有一个头部，然后是一个根元素；在这个例子中，根元素被命名为 `sales-and-products`。这个元素包含两种类型的元素——`product`
    和 `sale`。这两种类型的元素都有特定的子元素，它们是对应数据的字段。在这个例子中，只显示了 `id` 字段。
- en: 'To run the project, open its folder and type in `cargo run ../data/sales.xml`.
    Some lines will be printed on the console. The first four of them should be as
    follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，打开其文件夹，输入 `cargo run ../data/sales.xml`。控制台将打印出一些行。前四行应该是这样的：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These describe the contents of the specified XML file. In particular, the program
    found a product with ID `862`, then it detected that it is a fruit, then that
    it is a cherry, and then, when the whole product had been read, the whole struct
    representing the product was printed. A similar output will appear for sales.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些描述了指定XML文件的内容。特别是，程序找到了一个ID为`862`的产品，然后检测到它是一种水果，然后是樱桃，最后，当整个产品被读取完毕后，整个表示产品的结构被打印出来。对于销售也会有类似的输出。
- en: 'The parsing is performed using only the `xml-rs` crate. This crate enables
    a mechanism of parsing, shown in the following code excerpt:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 解析仅使用`xml-rs` crate执行。这个crate提供了一个解析机制，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An object of the `EventReader` type scans the buffered file and it generates
    an event whenever a step is performed in the parsing. The application code handles
    these kinds of events according to their needs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventReader`类型的对象扫描缓冲文件，并在解析过程中执行每一步时生成一个事件。应用程序代码根据其需求处理这些类型的事件。'
- en: The word **event** is used by this crate, but the word **transition** would probably be
    a better description of the data extracted by the parser.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个crate使用**事件**这个词，但**转换**这个词可能更准确地描述了解析器提取的数据。
- en: A complex language is hard to parse, but for languages as simple as our data,
    the situation during the parsing can be modeled by a state machine. To that purpose,
    three `enum` variables are declared in the source code: `location_item`, with
    the `LocationItem` type; `location_product`, with the `LocationProduct` type;
    and `location_sale`, with the `LocationSale` type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的语言难以解析，但对我们这样的简单数据语言，解析过程中的情况可以通过状态机来建模。为此，源代码中声明了三个`enum`变量：`location_item`，类型为`LocationItem`；`location_product`，类型为`LocationProduct`；以及`location_sale`，类型为`LocationSale`。
- en: The first one indicates the current position of the parsing in general. We can
    be inside a product (`InProduct`), inside a sale (`InSale`), or outside of both
    (`Other`). If we are inside a product, the `LocationProduct` enum indicates the
    current position of parsing inside the current product. This can be within any
    of the allowed fields or outside of all of them. Similar states happen for sales.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表示解析的一般位置。我们可能处于一个产品内部（`InProduct`），处于一个销售内部（`InSale`），或者处于两者之外（`Other`）。如果我们处于产品内部，`LocationProduct`枚举表示当前产品内部解析的位置。这可以是在任何允许的字段内，或者在外部所有字段之外。对于销售也会有类似的状态。
- en: 'The iteration encounters several kinds of events. The main ones are the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代遇到几种类型的事件。主要的有以下几种：
- en: '`XmlEvent::StartElement`: Signals that an XML element is beginning. It is decorated
    by the name of the beginning element and the possible attributes of that element.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlEvent::StartElement`：表示一个XML元素开始。它被开始元素的名称和该元素的可能的属性所装饰。'
- en: '`XmlEvent::EndElement`: Signals that an XML element is ending. It is decorated
    by the name of the ending element.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlEvent::EndElement`：表示一个XML元素结束。它被结束元素的名称所装饰。'
- en: '`XmlEvent::Characters`: Signals that the textual contents of an element is
    available. It is decorated by that available text.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlEvent::Characters`：表示一个元素的文本内容可用。它被该可用文本所装饰。'
- en: The program declares a mutable `product` struct, with the `Product` type, and
    a mutable `sale` struct, with the `Sale` type. They are initialized with default
    values. Whenever there are some characters available, they are stored in the corresponding
    field of the current struct.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序声明了一个可变的`product`结构体，类型为`Product`，和一个可变的`sale`结构体，类型为`Sale`。它们使用默认值初始化。每当有字符可用时，它们被存储在当前结构体的相应字段中。
- en: 'For example, consider a situation where the value of `location_item` is `LocationItem::InProduct` and
    the value of `location_product` is `LocationProduct::InCategory`—that is, we are
    in a category of a product. In this situation, there can be the name of the category
    or the end of the category. To get the name of the category, the code contains
    this pattern of a `match` statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个`location_item`的值为`LocationItem::InProduct`而`location_product`的值为`LocationProduct::InCategory`的情况——即，我们处于一个产品的类别中。在这种情况下，可能会有类别的名称或类别的结束。要获取类别的名称，代码中包含了一个`match`语句的模式：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this statement, the `characters` variable gets the name of the category and
    a clone of it is assigned to the `product.category` field. Then, the name is printed
    to the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，`characters`变量获取类别的名称，并将其克隆赋值给`product.category`字段。然后，名称被打印到控制台。
- en: Accessing databases
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数据库
- en: Text files are good when they are small and when they don't need to be changed
    often. Actually, the only way that a text file can be changed is if you append
    something to the end of it or rewrite it completely. If you want to change the
    information in a large dataset quickly, the only way to do so is to use a database
    manager. In this section, we are going to learn how to manipulate a SQLite database
    with a simple example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本文件很小且不需要经常更改时，文本文件是好的。实际上，更改文本文件的唯一方法是在其末尾追加内容或完全重写它。如果您想快速更改大型数据集中的信息，唯一的方法是使用数据库管理器。在本节中，我们将通过一个简单的示例学习如何操作SQLite数据库。
- en: 'But first, let''s look at three popular, broad categories of database managers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看三种流行的、广泛的数据库管理器类别：
- en: '**Single-user databases**: These store all of the databases in a single file,
    which must be accessible by the application code. The database code is linked
    into the application (it may be a static-link library or a dynamic-link library).
    Only one user at a time is allowed to access it, and all users have administrative
    privileges. To move the database anywhere, you simply move the file. The most
    popular choices in this category are SQLite and Microsoft Access.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单用户数据库**：这些数据库将所有数据库存储在一个单独的文件中，该文件必须可通过应用程序代码访问。数据库代码被链接到应用程序中（它可能是一个静态链接库或动态链接库）。一次只允许一个用户访问它，并且所有用户都具有管理权限。要将数据库移动到任何地方，只需移动文件即可。在这个类别中最受欢迎的选择是SQLite和Microsoft
    Access。'
- en: '**DBMS**: This is a process that has to be started as a service. Multiple clients
    can connect to it at the same time, and they can also apply changes at the same
    time without any data corruption. It requires more storage space, more memory,
    and much more start up time (for the server). There are several popular choices
    in this category, such as Oracle, Microsoft SQL Server, IBM DB2, MySQL, and PostgreSQL.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库管理系统（DBMS）**：这是一个必须作为服务启动的过程。多个客户端可以同时连接到它，并且它们可以同时应用更改而不会导致数据损坏。它需要更多的存储空间、更多的内存以及更长的启动时间（对于服务器）。在这个类别中有几个流行的选择，例如Oracle、Microsoft
    SQL Server、IBM DB2、MySQL和PostgreSQL。'
- en: '**Key-value stores**: This is a process that has to be started as a service. Multiple
    clients can connect to it at the same time and apply changes at the same time. It
    is essentially a large memory hash map that can be queried by other processes
    and that can optionally store its data in a file and reload it when it is restarted.
    This category is less popular than the other two, but it is gaining ground as
    the backend of high-performance websites. One of the most popular choices is Redis.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值存储**：这是一个必须作为服务启动的过程。多个客户端可以同时连接到它，并且可以同时应用更改。它本质上是一个大型的内存哈希表，可以被其他进程查询，并且可以选择将其数据存储在文件中，并在重启时重新加载。这个类别比其他两个类别不太受欢迎，但随着高性能网站后端的需求增加，它正在获得更多的关注。最受欢迎的选择之一是Redis。'
- en: In the following sections, we are going to show you how to access SQLite single-user
    databases (in the `sqlite_example` project), PostgreSQL DBMSes (in the `postgreSQL_example` project),
    and Redis key-value stores (in the `redis_example` project). Then, in the `transformer` project,
    all three kinds of databases will be used together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将向您展示如何访问SQLite单用户数据库（在`sqlite_example`项目中）、PostgreSQL数据库管理系统（在`postgreSQL_example`项目中）和Redis键值存储（在`redis_example`项目中）。然后，在`transformer`项目中，将使用这三种类型的数据库。
- en: Accessing a SQLite database
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问SQLite数据库
- en: The source code for this section is found in the `sqlite_example` project. To
    run it, open its folder and type in `cargo run`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的源代码位于`sqlite_example`项目中。要运行它，打开其文件夹并输入`cargo run`。
- en: 'This will create the `sales.db` file in the current folder. This file contains
    a SQLite database. Then, it will create the `Products` and `Sales` tables in this
    database, it will insert a row into each of these tables, and it will perform
    a query on the database. The query asks for all the sales, joining each of them
    with its associated product. For each extracted row, a line will be printed onto
    the console, showing the timestamp of the sale, the weight of the sale, and the
    name of the associated product. As there is only one sale in the database, you
    will see just the following line printed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前文件夹中创建`sales.db`文件。此文件包含一个SQLite数据库。然后，它将在该数据库中创建`Products`和`Sales`表，并在每个表中插入一行，然后对数据库执行查询。查询要求获取所有销售信息，并将每个销售与其相关联的产品结合起来。对于每个提取的行，将在控制台上打印一行，显示销售的日期时间、销售重量和关联产品的名称。由于数据库中只有一个销售记录，您将看到以下行被打印出来：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This project only uses the `rusqlite` crate. Its name is a contraction of **Rust
    SQLite**. To use this crate, the `Cargo.toml` file must contain the following
    line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目仅使用 `rusqlite` 包。其名称是 **Rust SQLite** 的缩写。要使用此包，`Cargo.toml` 文件必须包含以下行：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing the project
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现项目
- en: 'Let''s look at how the code for the `sqlite_example` project works. The `main`
    function is quite simple:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `sqlite_example` 项目的代码是如何工作的。`main` 函数相当简单：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It invokes `create_db` to open or create a database with its empty tables, and
    to open and return a connection to this database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用 `create_db` 来打开或创建一个包含空表的数据库，并打开并返回到此数据库的连接。
- en: Then, it invokes `populate_db` to insert rows into the tables of the database
    referred to by that connection.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它调用 `populate_db` 来将行插入由该连接引用的数据库的表中。
- en: Then, it invokes `print_db` to execute a query on this database and prints the
    data extracted by that query.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它调用 `print_db` 来执行对这个数据库的查询，并打印出该查询提取的数据。
- en: 'The `create_db` function is long but easy to understand:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_db` 函数虽然长，但很容易理解：'
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Connection::open` function simply uses a path to a SQLite database file to
    open a connection. If this file does not exist, it will be created. As you can
    see, the created `sales.db` file is very small. Typically, empty databases of
    DBMSes are 1,000 times larger.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection::open` 函数简单地使用一个指向 SQLite 数据库文件的路径来打开一个连接。如果此文件不存在，它将被创建。正如你所见，创建的
    `sales.db` 文件非常小。通常，DBMS 的空数据库比这大 1,000 倍。'
- en: To perform a data manipulation command, the `execute` method of the connection
    is called. Its first argument is a SQL statement, possibly containing some parameters,
    specified as `$1`, `$2`, `$3`, and so on. The second argument of the function
    is a reference to a slice of values that are used to replace such parameters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行数据操作命令，调用连接的 `execute` 方法。它的第一个参数是一个 SQL 语句，可能包含一些参数，指定为 `$1`、`$2`、`$3` 等。函数的第二个参数是一个值切片的引用，用于替换这些参数。
- en: Of course, if there are no parameters, the parameter values list must be empty. The
    first parameter value, which has an index of `0`, replaces the `$1` parameter,
    the second one replaces the `$2` parameter, and so on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有参数，参数值列表必须为空。第一个参数值（索引为 `0`）替换 `$1` 参数，第二个替换 `$2` 参数，依此类推。
- en: Notice that the arguments of a parameterized SQL statement can be of different
    data types (numeric, alpha-numeric, BLOBs, and so on), but Rust collections can only contain
    objects of the same data type. Therefore, the `params!` macro is used to perform
    a bit of magic. The data type of the second argument of the `execute` method must
    be that of a collection that can be iterated over and whose items implement the
    `ToSql` trait. The objects implementing this trait, as its name implies, can be
    used as parameters of a SQL statement. The `rusqlite` crate contains an implementation
    of this trait for many Rust basic types, such as numbers and strings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数化 SQL 语句的参数可以是不同的数据类型（数值、字母数字、BLOBs 等），但 Rust 集合只能包含相同数据类型的对象。因此，使用 `params!`
    宏来执行一些魔法操作。`execute` 方法的第二个参数的数据类型必须是可以迭代的集合，其项目实现了 `ToSql` 特性。实现此特性的对象，正如其名所示，可以用作
    SQL 语句的参数。`rusqlite` 包含了许多 Rust 基本类型（如数字和字符串）的此特性的实现。
- en: So, for example, the `params!(34, "abc")` expression generates a collection
    that can be iterated over. The first item of this iteration can be converted into
    an object containing the number `34`, and that number can be used to replace a
    SQL parameter of a numeric type. The second item of this iteration can be converted
    into an object containing the `"abc"` string, and that string can be used to replace
    a SQL parameter of an alpha-numeric type.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`params!(34, "abc")` 表达式生成一个可以迭代的集合。这个迭代的第一个项目可以转换成一个包含数字 `34` 的对象，这个数字可以用来替换一个数值类型的
    SQL 参数。第二个项目可以转换成一个包含 `"abc"` 字符串的对象，这个字符串可以用来替换一个字母数字类型的 SQL 参数。
- en: 'Now, let''s look at the `populate_db` function. It contains statements to insert
    rows into the database. Here is one of those statements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `populate_db` 函数。它包含将行插入数据库的语句。以下是其中之一：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As explained before, this statement will have the effect of executing the following
    SQL statement:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此语句将执行以下 SQL 语句：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At last, we see the whole `print_db` function, which is more complex than the
    others:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到整个 `print_db` 函数，它比其他函数更复杂：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To perform a SQL query, first, the `SELECT` SQL statement must be prepared by
    calling the `prepare` method of the connection, to convert it into an efficient
    internal format, with the `Statement` data type. This object is assigned to the
    `command` variable. A prepared statement must be mutable to allow the following
    replacement of parameters. In this case, however, we don't have any parameters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 SQL 查询，首先必须通过调用连接的 `prepare` 方法来准备 `SELECT` SQL 语句，将其转换为高效的内部格式，使用 `Statement`
    数据类型。此对象被分配给 `command` 变量。准备好的语句必须是可变的，以便允许以下参数的替换。然而，在这种情况下，我们没有任何参数。
- en: A query can generate several rows, and we want to process one at a time, so
    we must create an iterator from this command. It is performed by calling the `query_map`
    method of the command. This method receives two arguments—a slice of parameter
    values and a closure—and it returns an iterator. The `query_map` function performs
    two jobs—first, it replaces the specified parameters, and then it uses the closure
    to map (or transform) each extracted row into a more handy structure. But in our
    case, we have no parameters to replace, and so we just create a specific structure
    with the `SaleWithProduct` type. To extract the fields from a row, the `get` method
    is used. It has a zero-based index on the fields specified in the `SELECT` query. This
    structure is the object returned by the iterator for any row extracted by the
    query, and it is assigned to the iteration variable named `sale_with_product`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个查询可以生成多行，我们希望逐行处理，因此必须从这个命令创建一个迭代器。这是通过调用命令的 `query_map` 方法来完成的。此方法接收两个参数——一个参数值切片和一个闭包——并返回一个迭代器。`query_map`
    函数执行两个任务——首先，它替换指定的参数，然后使用闭包将提取的每一行映射（或转换）为更方便的结构。但在我们的情况下，我们没有要替换的参数，所以我们只使用
    `SaleWithProduct` 类型创建一个特定的结构。要从行中提取字段，使用 `get` 方法。它具有在 `SELECT` 查询中指定的字段上的零基索引。此结构是迭代器返回的对象，用于查询提取的任何行，并将其分配给名为
    `sale_with_product` 的迭代变量。
- en: Now that we have learned how to access a SQLite database, let's check the PostgreSQL
    database management system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何访问 SQLite 数据库，让我们来检查 PostgreSQL 数据库管理系统。
- en: Accessing a PostgreSQL database
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 PostgreSQL 数据库
- en: What we did in the SQLite database is similar to what we will be doing in the
    PostgreSQL database. This is because they are both based on the SQL language,
    but mostly because SQLite is designed to be similar to PostgreSQL. It may be harder
    to convert an application from PostgreSQL into SQLite because the former has many
    advanced features that are not available in the latter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 SQLite 数据库中做的事情与我们将要在 PostgreSQL 数据库中做的事情相似。这是因为它们都基于 SQL 语言，但主要是因为 SQLite
    被设计成与 PostgreSQL 类似。将应用程序从 PostgreSQL 转换为 SQLite 可能会更困难，因为前者有许多后者没有的先进功能。
- en: In this section, we are going to convert the example from the previous section
    so that it works with a PostgreSQL database instead of SQLite. So, we'll explain
    the differences.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将转换上一节的示例，使其与 PostgreSQL 数据库而不是 SQLite 一起工作。因此，我们将解释其中的差异。
- en: 'The source code for this section can be found in the `postgresql_example` folder.
    To run it, open its folder and type in `cargo run`. This will carry out essentially
    the same operations that we saw for `sqlite_example`, and so after creating and
    populating the database, it will print the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本节源代码位于 `postgresql_example` 文件夹中。要运行它，打开其文件夹并输入 `cargo run`。这将执行与 `sqlite_example`
    中看到的基本相同的操作，因此创建并填充数据库后，将打印以下内容：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementation of the project
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目的实现
- en: This project only uses the crate named `postgres`. Its name is a popular contraction
    of the `postgresql` name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目仅使用名为 `postgres` 的 crate。其名称是 `postgresql` 名称的流行缩写。
- en: Creating a connection to a PostgreSQL database is very different from creating
    a connection to a SQLite database. As the latter is only a file, you do so in
    a similar way to opening a file, and you should write `Connection::open(<pathname
    of the db file>)`. Instead, to connect to a PostgreSQL database, you need access
    to a computer where a server is running, then access to the TCP port where that
    server is listening, and then you need to specify your credentials on this server
    (your username and password). Optionally, you can then specify which of the databases
    managed by this server you want to use.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建到PostgreSQL数据库的连接与创建到SQLite数据库的连接非常不同。因为后者只是一个文件，所以你以类似打开文件的方式执行，你应该写`Connection::open(<db文件路径>)`。相反，要连接到PostgreSQL数据库，你需要访问一个运行服务器的计算机，然后访问该服务器监听的TCP端口，然后你需要在此服务器上指定你的凭据（你的用户名和密码）。可选地，然后你可以指定你想要使用此服务器管理的哪个数据库。
- en: So, the general form of the call is `Connection::connect(<URL>, <TlsMode>)`,
    where the URL can be, for example, `postgres://postgres:post@localhost:5432/Rust2018`.
    The general form of the URL is `postgres://username[:password]@host[:port][/database]`,
    where the password, the port, and the database parts are optional. The `TlsMode`
    argument specifies whether the connection must be encrypted.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调用的一般形式是`Connection::connect(<URL>, <TlsMode>)`，其中URL可以是例如`postgres://postgres:post@localhost:5432/Rust2018`。URL的一般形式是`postgres://username[:password]@host[:port][/database]`，其中密码、端口和数据库部分是可选的。`TlsMode`参数指定连接是否必须加密。
- en: The port is optional because it has a value of `5432` by default. Another difference
    is that this crate does not use the `params!` macro. Instead, it allows us to
    specify a reference to a slice. In this case, it is an empty slice (`&[]`) because
    we don't need to specify parameters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是可选的，因为它默认值为 `5432`。另一个区别是，这个crate不使用`params!`宏。相反，它允许我们指定一个切片的引用。在这种情况下，它是一个空切片（`&[]`），因为我们不需要指定参数。
- en: 'The table creation and population process is similar to the way it was done
    for `sqlite_example`. The query is different, however. This is the body of the
    `print_db` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表创建和填充过程与`sqlite_example`中执行的方式相似。然而，查询是不同的。这是`print_db`函数的主体：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With PostgreSQL, the `query` method of the connection class carries out parameter
    substitution, similarly to the `execute` method, but it does not map the row to
    a structure. Instead, it returns an iterator, which can be immediately used in
    a `for` statement. Then, in the body of the loop, the `row` variable can be used
    (as it is in the example) to fill a struct.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中，连接类的`query`方法执行参数替换，类似于`execute`方法，但它不将行映射到结构中。相反，它返回一个迭代器，可以立即在`for`语句中使用。然后，在循环体中，可以使用`row`变量（如示例中所示）来填充一个结构体。
- en: As we now know how to access data in the SQLite and PostgreSQL databases, let's
    see how to store and retrieve data from a Redis store.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何访问SQLite和PostgreSQL数据库中的数据，让我们看看如何从Redis存储中存储和检索数据。
- en: Storing and retrieving data from a Redis store
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Redis存储中存储和检索数据
- en: Some applications need a very fast response time for certain kinds of data;
    faster than what a DBMS can offer. Usually, a DBMS dedicated to one user would
    be fast enough, but for some applications (typically large-scale web applications)
    there are hundreds of concurrent queries and many concurrent updates. You can
    use many computers, but the data must be kept coherent among them, and keeping
    coherence can cause a bottleneck of performance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序需要某些类型的数据具有非常快的响应时间；比数据库管理系统（DBMS）能提供的还要快。通常，针对单个用户的DBMS会足够快，但对于某些应用程序（通常是大规模Web应用程序）来说，有数百个并发查询和许多并发更新。你可以使用多台计算机，但必须在它们之间保持数据的一致性，而保持一致性可能会造成性能瓶颈。
- en: A solution to this problem is to use a key-value store, which is a very simple
    database that can be replicated across a network. This keeps the data in memory
    to maximize the speed, but it also supports the option to save the data in a file.
    This avoids losing information if the server is stopped.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是用一个键值存储，这是一个非常简单的数据库，可以在网络上进行复制。这可以将数据保存在内存中以最大化速度，但它也支持将数据保存到文件中的选项。这可以避免在服务器停止时丢失信息。
- en: A key-value store is similar to the `HashMap` collection of the Rust standard
    library, but it is managed by a server process, which could possibly be running
    on a different computer. A query is a message exchanged between the client and
    a server. Redis is one of the most used key-value stores.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储类似于Rust标准库中的`HashMap`集合，但它由一个服务器进程管理，该进程可能运行在不同的计算机上。查询是客户端和服务器之间交换的消息。Redis是最常用的键值存储之一。
- en: 'The source code for this project is found in the `redis_example` folder. To
    run it, open the folder and type in `cargo run`. This will print the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的源代码位于`redis_example`文件夹中。要运行它，请打开文件夹并输入`cargo run`。这将打印以下内容：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This simply creates a data store in the current computer and stores in it the
    following three key-value pairs:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在当前计算机上创建一个数据存储，并在其中存储以下三个键值对：
- en: '`"aKey"`, associated with `"a string"`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"aKey"`，与`"a string"`相关联'
- en: '`"anotherKey"`, associated with `4567`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"anotherKey"`，与`4567`相关联'
- en: '`45`, associated with `12345`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`45`，与`12345`相关联'
- en: 'Then, it queries the store for the following keys:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它查询以下键：
- en: '`"aKey"`, which obtains an `"a string"` value'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"aKey"`，它获得一个`"a string"`值'
- en: '`"anotherKey"`, which obtains a `4567` value'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"anotherKey"`，它获得一个`4567`值'
- en: '`45`, which obtains a `12345` value'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`45`，它获得一个`12345`值'
- en: '`40`, which obtains an error'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`40`，它获得一个错误'
- en: Then, it queries whether the `40` key exists in the store, which obtains `false`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它查询存储中是否存在`40`键，它返回`false`。
- en: Implementing the project
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施项目
- en: Only the `redis` crate is used in this project.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中只使用了`redis`crate。
- en: 'The code is quite short and simple. Let''s look at how it works:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简短且简单。让我们看看它是如何工作的：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, a client must be obtained. The call to `redis::Client::open` receives
    a URL and just checks whether this URL is valid. If the URL is valid, a `redis::Client` object
    is returned, which has no open connections. Then, the `get_connection` method
    of the client tries to connect, and if it is successful, it returns an open connection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须获取一个客户端。对`redis::Client::open`的调用接收一个URL并仅检查此URL是否有效。如果URL有效，则返回一个`redis::Client`对象，该对象没有打开的连接。然后，客户端的`get_connection`方法尝试连接，如果成功，则返回一个打开的连接。
- en: 'Any connection essentially has three important methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 任何连接本质上都有三个重要的方法：
- en: '`set`: This tries to store a key-value pair.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`: 这尝试存储一个键值对。'
- en: '`get`: This tries to retrieve the value associated with the specified key.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 这尝试检索与指定键关联的值。'
- en: '`exists`: This tries to detect whether the specified key is present in the
    store, without retrieving its associated value.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists`: 这尝试检测指定的键是否存在于存储中，而不检索其关联的值。'
- en: 'Then, `set` is invoked three times, with different types for the key and value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`set`被调用了三次，键和值的类型不同：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At last, `get` is invoked four times and `exists` is invoked once. The first
    three calls get the stored value. The fourth call specifies a non-existent value,
    so a null value is returned, which cannot be converted into `String`, as is required,
    and so an error is generated:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`get`被调用了四次，`exists`被调用了一次。前三次调用获取存储的值。第四次调用指定了一个不存在的值，因此返回了一个null值，它不能转换为所需的`String`，因此生成了一个错误：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can always check the error to find out whether your key is present, but
    a cleaner solution is to call the `exists` method, which returns a Boolean value
    specifying whether the key is present.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以始终检查错误以找出你的键是否存在，但更干净的方法是调用`exists`方法，它返回一个布尔值，指定键是否存在。
- en: With this, we now know how Rust crates are used to access, store, and retrieve
    data using the most popular databases.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在知道如何使用Rust crates通过最流行的数据库访问、存储和检索数据。
- en: Putting it all together
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'You should now know enough to build an example that does what we described
    at the beginning of the chapter. We have learned the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该知道足够的信息来构建一个示例，它执行了本章开头所描述的内容。我们学习了以下内容：
- en: How to read a TOML file to parameterize the program
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取TOML文件以参数化程序
- en: How to load the data regarding products and sales into memory, specified in
    a JSON file and in an XML file
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将有关产品和销售的数据加载到内存中，这些数据指定在JSON文件和XML文件中
- en: 'How to store all of this data in three places: a SQLite DB file, a PostgreSQL
    database, and a Redis key-value store'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将所有这些数据存储在三个地方：一个SQLite数据库文件、一个PostgreSQL数据库和一个Redis键值存储
- en: 'The source code of the complete example is found in the `transformer` project.
    To run it, open its folder and type in `cargo run ../data/config.toml`. If everything
    is successful, it will recreate and populate the SQLite database contained in
    the `data/sales.db` file, the PostgreSQL database, which can be accessed from
    `localhost` on port `5432` and is named `Rust2018`, and the Redis store, which
    can be accessed from `localhost`. Then, it will query the SQLite and PostgreSQL
    databases for the number of rows in their tables, and it will print the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例的源代码可以在 `transformer` 项目中找到。要运行它，打开其文件夹并输入 `cargo run ../data/config.toml`。如果一切顺利，它将重新创建并填充
    `data/sales.db` 文件中包含的 SQLite 数据库，PostgreSQL 数据库，该数据库可以通过 `localhost` 的 `5432`
    端口访问，并命名为 `Rust2018`，以及 Redis 存储库，可以从 `localhost` 访问。然后，它将查询 SQLite 和 PostgreSQL
    数据库中它们的表中的行数，并将打印以下内容：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, we have now seen a rather broad example of data manipulation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经看到了一个相当广泛的数据操作示例。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some basic techniques to access data in popular
    text formats (TOML, JSON, and XML) or data managed by popular database managers
    (SQLite, PostgreSQL, and Redis). Of course, many other file formats and database
    managers exist, and there is still a lot to be learned about these formats and
    these database managers. Nevertheless, you should now have a grasp of what they
    do. These techniques are useful for many kinds of applications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了访问流行文本格式（TOML、JSON 和 XML）或由流行数据库管理器（SQLite、PostgreSQL 和 Redis）管理的数据的一些基本技术。当然，还存在许多其他文件格式和数据库管理器，关于这些格式和数据库管理器还有很多东西要学习。尽管如此，你现在应该已经掌握了它们的功能。这些技术对许多类型的应用程序都很有用。
- en: In the next chapter, we will learn how to build a web backend service using
    the REST architecture. To keep that chapter self-contained, we will only use a
    framework to receive and respond to web requests, and not use a database. Of course,
    that is quite unrealistic; but by combining those web techniques with the ones
    introduced in this chapter, you can build a real-world web service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 REST 架构构建 Web 后端服务。为了使该章节独立，我们将仅使用框架来接收和响应 Web 请求，而不使用数据库。当然，这相当不切实际；但通过将这些
    Web 技术与本章中介绍的技术相结合，你可以构建一个现实世界的 Web 服务。
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it not a good idea to change programmatically a TOML file edited by a
    user?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么用程序方式更改用户编辑的 TOML 文件不是一个好主意？
- en: When is it better to use a dynamically typed parsing of TOML or JSON files and
    when is it better to use statically typed parsing?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下使用 TOML 或 JSON 文件的动态类型解析更好，而在什么情况下使用静态类型解析更好？
- en: When is it required to derive a structure from the `Serialize` and the `Deserialize`
    trait?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下需要从 `Serialize` 和 `Deserialize` 特性派生结构？
- en: What is a pretty generation of a JSON string?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 JSON 字符串的漂亮生成？
- en: Why could it be better to use a stream parser, rather than a single-call parser?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用流解析器而不是单次调用解析器可能更好？
- en: When is SQLite a better choice and when is it better to use PostgreSQL?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下 SQLite 是更好的选择，而在什么情况下使用 PostgreSQL 更好？
- en: Which is the type of the parameters passed with a SQL command to a SQLite database
    manager?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 SQL 命令传递给 SQLite 数据库管理器的参数类型是什么？
- en: What does the `query` method do on a PostgreSQL database?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`query` 方法在 PostgreSQL 数据库上做什么？'
- en: What are the names of the functions to read and write values in a Redis key-value
    store?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取和写入 Redis 键值存储中值的函数名称是什么？
- en: Can you try to write a program that gets an ID from the command line, queries
    SQLite, PostgreSQL, or the Redis database for the ID, and prints some information
    regarding the data found?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能尝试编写一个程序，从命令行获取一个 ID，查询 SQLite、PostgreSQL 或 Redis 数据库以获取该 ID，并打印有关找到的数据的一些信息吗？
