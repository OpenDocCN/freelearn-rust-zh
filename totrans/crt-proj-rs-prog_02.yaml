- en: Storing and Retrieving Data
  prefs: []
  type: TYPE_NORMAL
- en: A typical need of any software application is to input/output data by reading/writing
    data files or data streams or by querying/manipulating a database. Regarding files
    and streams, unstructured data, or even binary data, is hard to manipulate, and
    so they are not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Also, proprietary data formats are not recommended because of the vendor lock-in
    risk, and so only standard data formats should be used. Fortunately, there are
    free Rust libraries that come to the rescue in these situations. There are Rust
    crates available to manipulate some of the most popular file formats, such as
    TOML, JSON, and XML.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of databases, there are Rust crates to manipulate data using some of
    the most popular databases, such as SQLite, PostgreSQL, and Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to read configuration data from a TOML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read or write a JSON data file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read an XML data file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query or manipulate data in a SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query or manipulate data in a PostgreSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to query or manipulate data in a Redis database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is required for you to install the SQLite runtime library when you're running
    the SQLite code. However, it is also useful (although not required) to install
    a SQLite interactive manager. You can download the precompiled binaries of SQLite
    tools from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).
    However, version 3.11 or higher would be ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that if you're using Debian-derived Linux distribution, the `libsqlite3-dev` package should
    be installed.
  prefs: []
  type: TYPE_NORMAL
- en: It is also required for you to install and run the PostgreSQL **Database Management
    System** (**DBMS**) when you're running the PostgreSQL code. As with SQLite, it
    is useful but not required to install a PostgreSQL interactive manager. You can
    download the precompiled binary of PostgreSQL DBMS from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    However, version 7.4 or higher would be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running the Redis server is necessary when you're running the
    Redis code. You can download it from [https://redis.io/download](https://redis.io/download).
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this chapter can be found in the `Chapter02` folder of
    the repository at [https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers](https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers).
    In this folder, there is a sub-folder for every project, plus a folder named `data`,
    which contains the data that we'll use as input for the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at how to build a program that loads a JSON file
    and an XML file into three databases: a SQLite database, a PostgreSQL database,
    and a Redis key-value store. To avoid hardwiring the names and positions of the
    files and the database credentials into the program, we are going to load them
    from a TOML configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final project is named `transformer`, but we''ll explain this through several
    preliminary small projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toml_dynamic` and `toml_static`: These read a TOML file in two different ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json_dynamic` and `json_static`: These read a JSON file in two different ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xml_example`: This reads an XML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite_example`: This creates two tables in a SQLite database, inserts records
    into them, and queries them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgresql_example`: This creates two tables in a PostgreSQL database, inserts
    records into them, and queries them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redis_example`: This adds some data to a key-value store and queries it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a TOML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One simple and maintainable way to store information in a filesystem is to use
    a text file. This is also very efficient for data spanning no more than 100 KB.
    However, there are several competing standards for storing information in text
    files, such as INI, CSV, JSON, XML, YAML, and others.
  prefs: []
  type: TYPE_NORMAL
- en: The one used by Cargo is TOML. This is a really powerful format that is used
    by many Rust developers to store the configuration data of their apps. It is designed
    to be written by hand, using a text editor, but it can also be written by an application
    very easily.
  prefs: []
  type: TYPE_NORMAL
- en: The `toml_dynamic` and `toml_static` projects (using the `toml` crate) load
    data from a TOML file. Reading a TOML file is useful when configuring a software
    application, and this is what we'll do. We will use the `data/config.toml` file,
    which contains all of the parameters for the projects of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create or modify a TOML file by using code, but we are not going
    to do that. Being able to modify a TOML file can be useful in some scenarios,
    such as to save user preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to consider that when a TOML file is changed by a program,
    it undergoes dramatic restructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: It acquires specific formatting, which you may dislike.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loses all of its comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its items are sorted alphabetically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if you want to use the TOML format both for manually edited parameters
    and for program-saved data, you would be better off using two distinct files:'
  prefs: []
  type: TYPE_NORMAL
- en: One edited only by humans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One edited primarily by your software, but occasionally also by humans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter describes two projects in which a TOML file is read using different
    techniques. These techniques are to be used in two different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: In a situation where we are not sure which fields are contained in the file,
    and so we want to explore it. In this case, we use the `toml_dynamic` program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In another situation where, in our program, we describe exactly which fields
    should be contained in the file and we don't accept a different format. In this
    case, we use the `toml_static` program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using toml_dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this section is to read the `config.toml` file, located in the
    `data` folder, when we want to explore the content of that file. The first three
    lines of this file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After these lines, the file contains other sections. Among them is the `[postgresql]` section,
    which contains the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this project, enter the `toml_dynamic` folder and type in `cargo run
    ../data/config.toml`. A long output should be printed. It will begin with the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this is just a verbose representation of the first three lines
    of the `config.toml` file. This output proceeds with emitting a similar representation
    for the rest of the file. After having printed the whole data structure representing
    the file that is read, the following line is added to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the result of a specific query on the data structure loaded when the
    file is read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code of the `toml_dynamic` program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a variable that will contain a description of the whole file. This
    variable is initialized in the next three statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the pathname of the file from the first argument in the command line to
    `config_path`. Then, we load the contents of this file into the `config_text` string and
    we parse this string into a `toml::Value` structure. This is a recursive structure
    because it can have a `Value` property among its fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure is then printed using the debug structured formatting (`:#?`),
    and a value is retrieved from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that to get the value of the `"database"` item contained the `"postgresql"`
    section, a lot of code is required. The `get` function needs to look for a string,
    which may fail. That is the price of uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: Using toml_static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the other hand, if we are quite sure of the organization of our TOML file,
    we should use another technique shown in the project, `toml_static`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it, open the `toml_static` folder and type in `cargo run ../data/config.toml`.
    The program will only print the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This project uses two additional crates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serde`: This enables the use of the basic serialization/deserialization operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serde_derive`: This provides a powerful additional feature known as the **custom-derive**
    feature, which allows you to serialize/deserialize using a struct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serde` is the standard serialization/deserialization library. **Serialization**
    is the process of converting data structures of the program into a string (or
    a stream). **Deserialization** is the reverse process; it is the process of converting
    a string (or a stream) into some data structures of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: To read a TOML file, we need to use deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: In these two projects, we don't need to use serialization as we are not going
    to write a TOML file.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, first, a struct is defined for any section contained in the `data/config.toml` file.
    That file contains the `Input`, `Redis`, `Sqlite`, and `Postgresql` sections,
    and so we declare as many Rust structs as the sections of the file we want to
    read; then, the `Config` struct is defined to represent the whole file, having
    these sections as members.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is the structure for the `Input` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the preceding declaration is preceded by two attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The `allow(unused)` attribute is used to prevent the compiler from warning us
    about unused fields in the following structure. It is convenient for us to avoid
    these noisy warnings. The `derive(Deserialize)` attribute is used to activate
    the automatic deserialization initiated by `serde` for the following structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these declarations, it is possible to write the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This invokes the `from_str` function, which parses the text of the file into
    a struct. The type of that struct is not specified in this expression, but its
    value is assigned to the variable declared in the first line of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, its type is `Config`.
  prefs: []
  type: TYPE_NORMAL
- en: Any discrepancies between the file's contents and the struct type will be considered
    an error in this operation. So, if this operation is successful, any other operation
    on the structure cannot fail.
  prefs: []
  type: TYPE_NORMAL
- en: While the previous program (`toml_dynamic`) had a kind of dynamic typing, such
    as that of Python or JavaScript, this program has a kind of static typing, similar
    to Rust or C++.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of static typing appears in the last statement, where the same
    behavior as the long statement of the previous project is obtained by simply writing
    `config_const_values.postgresql.database`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing a JSON file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For storing data that is more complex than that which is stored in a configuration
    file, JSON format is more appropriate. This format is quite popular, particularly
    among those who use the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to read and parse the `data/sales.json` file. This file contains
    a single anonymous object, which contains two arrays—`"products"` and `"sales"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `"products"` array contains two objects, each one having three fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `"sales"` array contains three objects, each one containing five fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The information in the arrays is about some products to sell and some sale transactions
    associated with those products. Notice that the second field of each sale (`"product_id"`)
    is a reference to a product, and so it should be processed after the corresponding
    product object has been created.
  prefs: []
  type: TYPE_NORMAL
- en: We will see a pair of programs with the same behavior. They read the JSON file,
    increment the quantity of the second sale object by `1.5`, and then save the whole
    updated structure into another JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the TOML format case, there can also be a dynamic parsing technique used for
    JSON files, where the existence and type of any data field is checked by the application
    code, and a static parsing technique, where it uses the deserialization library
    to check the existence and type of any field.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have two projects: `json_dynamic` and `json_static`. To run each of them,
    open its folder and type in `cargo run ../data/sales.json ../data/sales2.json`.
    The program will not print anything, but it will read the first file specified
    in the command line and create the second file that is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The created file is similar to the read file, but with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The fields of the file created by `json_dynamic` are sorted in alphabetical
    order, while the fields of the file created by `json_static` are sorted in the
    same order as in the Rust data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quantity of the second sale is incremented from `2.14` to `3.64`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final empty line is removed in both created files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can see the implementations of the two techniques of serialization and
    deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: The json_dynamic project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the source code of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: This project gets the pathnames of two files from the command line—the existing
    JSON file (`"input_path"`) to read into a memory structure and a JSON file to
    create (`"output_path"`) by saving the loaded structure, after having modified
    it a bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the input file is loaded into the string named `sales_and_products_text` and
    the generic `serde_json::from_str::<Value>` function is used to parse the string
    into a dynamically typed structure representing the JSON file. This structure
    is stored in the `sales_and_products` local variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Imagine that we want to change the quantity sold by the second sale transaction,
    incrementing it by `1.5` kilograms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must get to this value using the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This retrieves the `"sales"` sub-object of the general object. It is an array
    containing three objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, this expression gets the second item (starting from zero (`[1]`)) of this
    array. This is an object representing a single sale transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, it gets the `"quantity"` sub-object of the sale transaction object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value we have reached has a dynamic type that we think should be `serde_json::Value::Number`,
    and so we make a pattern matching with this type, specifying the `if let Value::Number(n)` clause.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If all is good, the matching succeeds and we get a variable named `n`—containing
    a number, or something that can be converted into a Rust floating-point number
    by using the `as_f64` function. Lastly, we can increment the Rust number and then
    create a JSON number from it using the `from_f64` function. We can then assign
    this object to the JSON structure using the same expression we used to get it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last statement of the program saves the JSON structure to a file. Here,
    the `serde_json::to_string_pretty` function is used. As the name suggests, this
    function adds formatting whitespace (blanks and new lines) to make the resulting
    JSON file more human-readable. There is also the `serde_json::to_string` function,
    which creates a more compact version of the same information. It is much harder for
    people to read, but it is somewhat quicker to process for a computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The json_static project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If, for our program, we are sure that we know the structure of the JSON file,
    a statically typed technique can and should be used instead. It is shown in the `json_static` project.
    The situation here is similar to that of the projects processing the TOML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of the static version first declares three structs—one for
    every object type contained in the JSON file we are going to process. Each struct
    is preceded by the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Deserialize` trait is required to parse (that is, read) JSON strings into
    this struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Serialize` trait is required to format (that is, write) this struct into
    a JSON string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Debug` trait is just handy for printing this struct on a debug trace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSON string is parsed using the `serde_json::from_str::<SalesAndProducts>` function.
    Then, the code to increment the quantity of sold oranges becomes quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the program is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Reading an XML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very popular text format is XML. Unfortunately, there is no stable serialization/deserialization
    library to manage XML format. However, this is not necessarily a shortcoming.
    In actual fact, XML format is often used to store large datasets; so large, in
    fact, that it would be inefficient to load them all before we start converting
    the data into an internal format. In these cases, it may be more efficient to
    scan the file or incoming stream and process it as long as it is read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `xml_example` project is a rather convoluted program that scans the XML
    file specified on the command line and, in a procedural fashion, loads information
    from the file into a Rust data structure. It is meant to read the `../data/sales.xml` file.
    This file has a structure corresponding to the JSON file we sought in the previous
    section. The following lines show an excerpt of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All XML files have a header in the first line and then one root element; in
    this case, the root element it is named `sales-and-products`. This element contains
    two kinds of elements—`product` and `sale`. Both kinds of elements have specific
    sub-elements, which are the fields of the corresponding data. In this example,
    only the `id` fields are shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the project, open its folder and type in `cargo run ../data/sales.xml`.
    Some lines will be printed on the console. The first four of them should be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These describe the contents of the specified XML file. In particular, the program
    found a product with ID `862`, then it detected that it is a fruit, then that
    it is a cherry, and then, when the whole product had been read, the whole struct
    representing the product was printed. A similar output will appear for sales.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parsing is performed using only the `xml-rs` crate. This crate enables
    a mechanism of parsing, shown in the following code excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An object of the `EventReader` type scans the buffered file and it generates
    an event whenever a step is performed in the parsing. The application code handles
    these kinds of events according to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: The word **event** is used by this crate, but the word **transition** would probably be
    a better description of the data extracted by the parser.
  prefs: []
  type: TYPE_NORMAL
- en: A complex language is hard to parse, but for languages as simple as our data,
    the situation during the parsing can be modeled by a state machine. To that purpose,
    three `enum` variables are declared in the source code: `location_item`, with
    the `LocationItem` type; `location_product`, with the `LocationProduct` type;
    and `location_sale`, with the `LocationSale` type.
  prefs: []
  type: TYPE_NORMAL
- en: The first one indicates the current position of the parsing in general. We can
    be inside a product (`InProduct`), inside a sale (`InSale`), or outside of both
    (`Other`). If we are inside a product, the `LocationProduct` enum indicates the
    current position of parsing inside the current product. This can be within any
    of the allowed fields or outside of all of them. Similar states happen for sales.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iteration encounters several kinds of events. The main ones are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XmlEvent::StartElement`: Signals that an XML element is beginning. It is decorated
    by the name of the beginning element and the possible attributes of that element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlEvent::EndElement`: Signals that an XML element is ending. It is decorated
    by the name of the ending element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlEvent::Characters`: Signals that the textual contents of an element is
    available. It is decorated by that available text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program declares a mutable `product` struct, with the `Product` type, and
    a mutable `sale` struct, with the `Sale` type. They are initialized with default
    values. Whenever there are some characters available, they are stored in the corresponding
    field of the current struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a situation where the value of `location_item` is `LocationItem::InProduct` and
    the value of `location_product` is `LocationProduct::InCategory`—that is, we are
    in a category of a product. In this situation, there can be the name of the category
    or the end of the category. To get the name of the category, the code contains
    this pattern of a `match` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this statement, the `characters` variable gets the name of the category and
    a clone of it is assigned to the `product.category` field. Then, the name is printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text files are good when they are small and when they don't need to be changed
    often. Actually, the only way that a text file can be changed is if you append
    something to the end of it or rewrite it completely. If you want to change the
    information in a large dataset quickly, the only way to do so is to use a database
    manager. In this section, we are going to learn how to manipulate a SQLite database
    with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, let''s look at three popular, broad categories of database managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-user databases**: These store all of the databases in a single file,
    which must be accessible by the application code. The database code is linked
    into the application (it may be a static-link library or a dynamic-link library).
    Only one user at a time is allowed to access it, and all users have administrative
    privileges. To move the database anywhere, you simply move the file. The most
    popular choices in this category are SQLite and Microsoft Access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DBMS**: This is a process that has to be started as a service. Multiple clients
    can connect to it at the same time, and they can also apply changes at the same
    time without any data corruption. It requires more storage space, more memory,
    and much more start up time (for the server). There are several popular choices
    in this category, such as Oracle, Microsoft SQL Server, IBM DB2, MySQL, and PostgreSQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key-value stores**: This is a process that has to be started as a service. Multiple
    clients can connect to it at the same time and apply changes at the same time. It
    is essentially a large memory hash map that can be queried by other processes
    and that can optionally store its data in a file and reload it when it is restarted.
    This category is less popular than the other two, but it is gaining ground as
    the backend of high-performance websites. One of the most popular choices is Redis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we are going to show you how to access SQLite single-user
    databases (in the `sqlite_example` project), PostgreSQL DBMSes (in the `postgreSQL_example` project),
    and Redis key-value stores (in the `redis_example` project). Then, in the `transformer` project,
    all three kinds of databases will be used together.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this section is found in the `sqlite_example` project. To
    run it, open its folder and type in `cargo run`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create the `sales.db` file in the current folder. This file contains
    a SQLite database. Then, it will create the `Products` and `Sales` tables in this
    database, it will insert a row into each of these tables, and it will perform
    a query on the database. The query asks for all the sales, joining each of them
    with its associated product. For each extracted row, a line will be printed onto
    the console, showing the timestamp of the sale, the weight of the sale, and the
    name of the associated product. As there is only one sale in the database, you
    will see just the following line printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This project only uses the `rusqlite` crate. Its name is a contraction of **Rust
    SQLite**. To use this crate, the `Cargo.toml` file must contain the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how the code for the `sqlite_example` project works. The `main`
    function is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It invokes `create_db` to open or create a database with its empty tables, and
    to open and return a connection to this database.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it invokes `populate_db` to insert rows into the tables of the database
    referred to by that connection.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it invokes `print_db` to execute a query on this database and prints the
    data extracted by that query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_db` function is long but easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `Connection::open` function simply uses a path to a SQLite database file to
    open a connection. If this file does not exist, it will be created. As you can
    see, the created `sales.db` file is very small. Typically, empty databases of
    DBMSes are 1,000 times larger.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a data manipulation command, the `execute` method of the connection
    is called. Its first argument is a SQL statement, possibly containing some parameters,
    specified as `$1`, `$2`, `$3`, and so on. The second argument of the function
    is a reference to a slice of values that are used to replace such parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if there are no parameters, the parameter values list must be empty. The
    first parameter value, which has an index of `0`, replaces the `$1` parameter,
    the second one replaces the `$2` parameter, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the arguments of a parameterized SQL statement can be of different
    data types (numeric, alpha-numeric, BLOBs, and so on), but Rust collections can only contain
    objects of the same data type. Therefore, the `params!` macro is used to perform
    a bit of magic. The data type of the second argument of the `execute` method must
    be that of a collection that can be iterated over and whose items implement the
    `ToSql` trait. The objects implementing this trait, as its name implies, can be
    used as parameters of a SQL statement. The `rusqlite` crate contains an implementation
    of this trait for many Rust basic types, such as numbers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, the `params!(34, "abc")` expression generates a collection
    that can be iterated over. The first item of this iteration can be converted into
    an object containing the number `34`, and that number can be used to replace a
    SQL parameter of a numeric type. The second item of this iteration can be converted
    into an object containing the `"abc"` string, and that string can be used to replace
    a SQL parameter of an alpha-numeric type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `populate_db` function. It contains statements to insert
    rows into the database. Here is one of those statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As explained before, this statement will have the effect of executing the following
    SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At last, we see the whole `print_db` function, which is more complex than the
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To perform a SQL query, first, the `SELECT` SQL statement must be prepared by
    calling the `prepare` method of the connection, to convert it into an efficient
    internal format, with the `Statement` data type. This object is assigned to the
    `command` variable. A prepared statement must be mutable to allow the following
    replacement of parameters. In this case, however, we don't have any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A query can generate several rows, and we want to process one at a time, so
    we must create an iterator from this command. It is performed by calling the `query_map`
    method of the command. This method receives two arguments—a slice of parameter
    values and a closure—and it returns an iterator. The `query_map` function performs
    two jobs—first, it replaces the specified parameters, and then it uses the closure
    to map (or transform) each extracted row into a more handy structure. But in our
    case, we have no parameters to replace, and so we just create a specific structure
    with the `SaleWithProduct` type. To extract the fields from a row, the `get` method
    is used. It has a zero-based index on the fields specified in the `SELECT` query. This
    structure is the object returned by the iterator for any row extracted by the
    query, and it is assigned to the iteration variable named `sale_with_product`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to access a SQLite database, let's check the PostgreSQL
    database management system.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we did in the SQLite database is similar to what we will be doing in the
    PostgreSQL database. This is because they are both based on the SQL language,
    but mostly because SQLite is designed to be similar to PostgreSQL. It may be harder
    to convert an application from PostgreSQL into SQLite because the former has many
    advanced features that are not available in the latter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to convert the example from the previous section
    so that it works with a PostgreSQL database instead of SQLite. So, we'll explain
    the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this section can be found in the `postgresql_example` folder.
    To run it, open its folder and type in `cargo run`. This will carry out essentially
    the same operations that we saw for `sqlite_example`, and so after creating and
    populating the database, it will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project only uses the crate named `postgres`. Its name is a popular contraction
    of the `postgresql` name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connection to a PostgreSQL database is very different from creating
    a connection to a SQLite database. As the latter is only a file, you do so in
    a similar way to opening a file, and you should write `Connection::open(<pathname
    of the db file>)`. Instead, to connect to a PostgreSQL database, you need access
    to a computer where a server is running, then access to the TCP port where that
    server is listening, and then you need to specify your credentials on this server
    (your username and password). Optionally, you can then specify which of the databases
    managed by this server you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: So, the general form of the call is `Connection::connect(<URL>, <TlsMode>)`,
    where the URL can be, for example, `postgres://postgres:post@localhost:5432/Rust2018`.
    The general form of the URL is `postgres://username[:password]@host[:port][/database]`,
    where the password, the port, and the database parts are optional. The `TlsMode`
    argument specifies whether the connection must be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: The port is optional because it has a value of `5432` by default. Another difference
    is that this crate does not use the `params!` macro. Instead, it allows us to
    specify a reference to a slice. In this case, it is an empty slice (`&[]`) because
    we don't need to specify parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table creation and population process is similar to the way it was done
    for `sqlite_example`. The query is different, however. This is the body of the
    `print_db` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With PostgreSQL, the `query` method of the connection class carries out parameter
    substitution, similarly to the `execute` method, but it does not map the row to
    a structure. Instead, it returns an iterator, which can be immediately used in
    a `for` statement. Then, in the body of the loop, the `row` variable can be used
    (as it is in the example) to fill a struct.
  prefs: []
  type: TYPE_NORMAL
- en: As we now know how to access data in the SQLite and PostgreSQL databases, let's
    see how to store and retrieve data from a Redis store.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving data from a Redis store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some applications need a very fast response time for certain kinds of data;
    faster than what a DBMS can offer. Usually, a DBMS dedicated to one user would
    be fast enough, but for some applications (typically large-scale web applications)
    there are hundreds of concurrent queries and many concurrent updates. You can
    use many computers, but the data must be kept coherent among them, and keeping
    coherence can cause a bottleneck of performance.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this problem is to use a key-value store, which is a very simple
    database that can be replicated across a network. This keeps the data in memory
    to maximize the speed, but it also supports the option to save the data in a file.
    This avoids losing information if the server is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: A key-value store is similar to the `HashMap` collection of the Rust standard
    library, but it is managed by a server process, which could possibly be running
    on a different computer. A query is a message exchanged between the client and
    a server. Redis is one of the most used key-value stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this project is found in the `redis_example` folder. To
    run it, open the folder and type in `cargo run`. This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply creates a data store in the current computer and stores in it the
    following three key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"aKey"`, associated with `"a string"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"anotherKey"`, associated with `4567`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`45`, associated with `12345`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, it queries the store for the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"aKey"`, which obtains an `"a string"` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"anotherKey"`, which obtains a `4567` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`45`, which obtains a `12345` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`40`, which obtains an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it queries whether the `40` key exists in the store, which obtains `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only the `redis` crate is used in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is quite short and simple. Let''s look at how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, a client must be obtained. The call to `redis::Client::open` receives
    a URL and just checks whether this URL is valid. If the URL is valid, a `redis::Client` object
    is returned, which has no open connections. Then, the `get_connection` method
    of the client tries to connect, and if it is successful, it returns an open connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any connection essentially has three important methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set`: This tries to store a key-value pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: This tries to retrieve the value associated with the specified key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exists`: This tries to detect whether the specified key is present in the
    store, without retrieving its associated value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, `set` is invoked three times, with different types for the key and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At last, `get` is invoked four times and `exists` is invoked once. The first
    three calls get the stored value. The fourth call specifies a non-existent value,
    so a null value is returned, which cannot be converted into `String`, as is required,
    and so an error is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can always check the error to find out whether your key is present, but
    a cleaner solution is to call the `exists` method, which returns a Boolean value
    specifying whether the key is present.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we now know how Rust crates are used to access, store, and retrieve
    data using the most popular databases.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now know enough to build an example that does what we described
    at the beginning of the chapter. We have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to read a TOML file to parameterize the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load the data regarding products and sales into memory, specified in
    a JSON file and in an XML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to store all of this data in three places: a SQLite DB file, a PostgreSQL
    database, and a Redis key-value store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code of the complete example is found in the `transformer` project.
    To run it, open its folder and type in `cargo run ../data/config.toml`. If everything
    is successful, it will recreate and populate the SQLite database contained in
    the `data/sales.db` file, the PostgreSQL database, which can be accessed from
    `localhost` on port `5432` and is named `Rust2018`, and the Redis store, which
    can be accessed from `localhost`. Then, it will query the SQLite and PostgreSQL
    databases for the number of rows in their tables, and it will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: So, we have now seen a rather broad example of data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at some basic techniques to access data in popular
    text formats (TOML, JSON, and XML) or data managed by popular database managers
    (SQLite, PostgreSQL, and Redis). Of course, many other file formats and database
    managers exist, and there is still a lot to be learned about these formats and
    these database managers. Nevertheless, you should now have a grasp of what they
    do. These techniques are useful for many kinds of applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to build a web backend service using
    the REST architecture. To keep that chapter self-contained, we will only use a
    framework to receive and respond to web requests, and not use a database. Of course,
    that is quite unrealistic; but by combining those web techniques with the ones
    introduced in this chapter, you can build a real-world web service.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it not a good idea to change programmatically a TOML file edited by a
    user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it better to use a dynamically typed parsing of TOML or JSON files and
    when is it better to use statically typed parsing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it required to derive a structure from the `Serialize` and the `Deserialize`
    trait?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a pretty generation of a JSON string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why could it be better to use a stream parser, rather than a single-call parser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is SQLite a better choice and when is it better to use PostgreSQL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the type of the parameters passed with a SQL command to a SQLite database
    manager?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `query` method do on a PostgreSQL database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the names of the functions to read and write values in a Redis key-value
    store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you try to write a program that gets an ID from the command line, queries
    SQLite, PostgreSQL, or the Redis database for the ID, and prints some information
    regarding the data found?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
