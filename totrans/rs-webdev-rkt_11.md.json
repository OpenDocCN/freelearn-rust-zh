["```rs\npub struct Post {\n```", "```rs\n    pub uuid: Uuid,\n```", "```rs\n    pub user_uuid: Uuid,\n```", "```rs\n    pub post_type: PostType,\n```", "```rs\n    pub content: String,\n```", "```rs\n    pub created_at: OurDateTime,\n```", "```rs\n}\n```", "```rs\n    sqlx migrate add create_posts\n    ```", "```rs\n    CREATE TABLE IF NOT EXISTS posts\n    (\n        uuid       UUID PRIMARY KEY,\n        user_uuid  UUID NOT NULL,\n        post_type  INTEGER NOT NULL DEFAULT 0,\n        content    VARCHAR NOT NULL UNIQUE,\n        created_at TIMESTAMPTZ NOT NULL DEFAULT CUR-\n        RENT_TIMESTAMP,\n        FOREIGN KEY (user_uuid) REFERENCES \"users\" (uuid)\n    );\n    ```", "```rs\n    sqlx migrate run\n    ```", "```rs\n    fn raw_html(&self) -> String;\n    ```", "```rs\n    pub struct TextPost(pub Post);\n    impl DisplayPostContent for TextPost {\n        fn raw_html(&self) -> String {\n            format!(\"<p>{}</p>\", self.0.content)\n        }\n    }\n    ```", "```rs\n    pub struct PhotoPost(pub Post);\n    impl DisplayPostContent for PhotoPost {\n        fn raw_html(&self) -> String {\n            format!(\n    r#\"<figure><img src=\"img/{}\" class=\"section \n                media\"/></figure>\"#,\n                self.0.content\n            )\n        }\n    }\n    ```", "```rs\n    pub struct VideoPost(pub Post);\n    impl DisplayPostContent for VideoPost {\n        fn raw_html(&self) -> String {\n            format!(\n                r#\"<video width=\"320\" height=\"240\" con-\n                trols>\n        <source src=\"img/{}\" type=\"video/mp4\">\n        Your browser does not support the video tag.\n        </video>\"#,\n                self.0.content\n            )\n        }\n    }\n    ```", "```rs\n    <div class=\"card fluid\">\n      {{ post.post_html | safe }}\n    </div>\n    ```", "```rs\n    {% extends \"template\" %}\n    {% block body %}\n      {% include \"posts/_post\" %}\n      <button type=\"submit\" value=\"Submit\" form=\"delete-\n      Post\">Delete</button>\n      <a href=\"/users/{{user.uuid}}/posts\" class=\"but-\n      ton\">Post List</a>\n    {% endblock %}\n    ```", "```rs\n    {% extends \"template\" %}\n    {% block body %}\n      {% for post in posts %}\n        <div class=\"container\">\n          <div><mark class=\"tag\">{{ loop.index \n          }}</mark></div>\n          {% include \"posts/_post\" %}\n          <a href=\"/users/{{ user.uuid }}/posts/{{ \n          post.uuid }}\" class=\"button\">See Post</a>\n        </div>\n      {% endfor %}\n      {% if pagination %}\n        <a href=\"/users/{{ user.uuid }}/posts?pagina\n        tion.next={{ pagination.next }}&paginat-\n        ion.limit={{ pagination.limit }}\" class=\"button\">\n          Next\n        </a>\n      {% endif %}\n      <a href=\"/users/{{ user.uuid }}/posts/new\" \n      class=\"button\">Upload Post</a>\n    {% endblock %}\n    ```", "```rs\n    use super::bool_wrapper::BoolWrapper;\n    use super::pagination::{Pagination, DEFAULT_LIMIT};\n    use super::photo_post::PhotoPost;\n    use super::post_type::PostType;\n    use super::text_post::TextPost;\n    use super::video_post::VideoPost;\n    use crate::errors::our_error::OurError;\n    use crate::fairings::db::DBConnection;\n    use crate::traits::DisplayPostContent;\n    use rocket::form::FromForm;\n    use rocket_db_pools::sqlx::{FromRow, PgConnection};\n    use rocket_db_pools::{sqlx::Acquire, Connection};\n    ```", "```rs\n    #[derive(FromRow, FromForm)]\n    pub struct Post {\n        ...\n    }\n    ```", "```rs\n    impl Post {}\n    ```", "```rs\n    pub async fn find(connection: &mut PgConnection, uuid: &str) -> Result<Post, OurError> {\n        let parsed_uuid = \n        Uuid::parse_str(uuid).map_err(Our\n        Error::from_uuid_error)?;\n        let query_str = \"SELECT * FROM posts WHERE uuid = \n        $1\";\n        Ok(sqlx::query_as::<_, Self>(query_str)\n            .bind(parsed_uuid)\n            .fetch_one(connection)\n            .await\n            .map_err(OurError::from_sqlx_error)?)\n    }\n    ```", "```rs\n    pub async fn find_all(\n        db: &mut Connection<DBConnection>,\n        user_uuid: &str,\n        pagination: Option<Pagination>,\n    ) -> Result<(Vec<Self>, Option<Pagination>), OurError> {\n        if pagination.is_some() {\n            return Self::find_all_with_pagination(db, \n            user_uuid, &pagination.unwrap()).await;\n        } else {\n            return Self::find_all_without_pagination(db, user_uuid).await;\n        }\n    }\n    ```", "```rs\n    async fn find_all_without_pagination(\n        db: &mut Connection<DBConnection>,\n        user_uuid: &str,\n    ) -> Result<(Vec<Self>, Option<Pagination>), OurError> {\n        let parsed_uuid = \n        Uuid::parse_str(user_uuid).map_err(Our-\n        Error::from_uuid_error)?;\n        let query_str = r#\"SELECT *\n    FROM posts\n    WHERE user_uuid = $1\n    ORDER BY created_at DESC\n    LIMIT $2\"#;\n        let connection = db.acquire().await.map_err(Our-\n        Error::from_sqlx_error)?;\n        let posts = sqlx::query_as::<_, Self>(query_str)\n            .bind(parsed_uuid)\n            .bind(DEFAULT_LIMIT as i32)\n            .fetch_all(connection)\n            .await\n            .map_err(OurError::from_sqlx_error)?;\n        let mut new_pagination: Option<Pagination> = None;\n        if posts.len() == DEFAULT_LIMIT {\n            let query_str = \"SELECT EXISTS(SELECT 1 FROM \n            posts WHERE created_at < $1 ORDER BY \n            created_at DESC LIMIT 1)\";\n            let connection = db.acquire().\n            await.map_err(OurError::from_sqlx_error)?;\n            let exists = sqlx::query_as::<_,\n            BoolWrapper>(query_str)\n                .bind(&posts.last().unwrap().created_at)\n                .fetch_one(connection)\n                .await\n                .map_err(OurError::from_sqlx_error)?;\n            if exists.0 {\n                new_pagination = Some(Pagination {\n                    next: posts.last().unwrap()\n                    .created_at.to_owned(),\n                    limit: DEFAULT_LIMIT,\n                });\n            }\n        }\n        Ok((posts, new_pagination))\n    }\n    ```", "```rs\n    async fn find_all_with_pagination(\n        db: &mut Connection<DBConnection>,\n        user_uuid: &str,\n        pagination: &Pagination,\n    ) -> Result<(Vec<Self>, Option<Pagination>), OurError> {\n        let parsed_uuid = \n        Uuid::parse_str(user_uuid).map_err(\n        OurError::from_uuid_error)?;\n        let query_str = r#\"SELECT *\n    FROM posts\n    WHERE user_uuid = $1 AND☐created_at < $2\n    ORDER BY created_at☐DESC\n    LIMIT $3\"#;\n        let connection = db.acquire().await.map_err(\n        OurError::from_sqlx_error)?;\n        let posts = sqlx::query_as::<_, Self>(query_str)\n            .bind(&parsed_uuid)\n            .bind(&pagination.next)\n            .bind(DEFAULT_LIMIT as i32)\n            .fetch_all(connection)\n            .await\n            .map_err(OurError::from_sqlx_error)?;\n        let mut new_pagination: Option<Pagination> = None;\n        if posts.len() == DEFAULT_LIMIT {\n            let query_str = \"SELECT EXISTS(SELECT 1 FROM \n            posts WHERE created_at < $1 ORDER BY \n            created_at DESC LIMIT 1)\";\n            let connection = db.\n            acquire().await.map_err(\n            OurError::from_sqlx_error)?;\n            let exists = sqlx::query_as::<_,\n            BoolWrapper>(query_str)\n                .bind(&posts.last().unwrap().created_at)\n                .fetch_one(connection)\n                .await\n                .map_err(OurError::from_sqlx_error)?;\n            if exists.0 {\n                new_pagination = Some(Pagination {\n                    next: posts.last().unwrap().\n                    created_at.to_owned(),\n                    limit: DEFAULT_LIMIT,\n                });\n            }\n        }\n        Ok((posts, new_pagination))\n    }\n    ```", "```rs\n    pub fn to_text(self) -> TextPost {\n        TextPost(self)\n    }\n    pub fn to_photo(self) -> PhotoPost {\n        PhotoPost(self)\n    }\n    pub fn to_video(self) -> VideoPost {\n        VideoPost(self)\n    }\n    ```", "```rs\n    use crate::models::{pagination::Pagination, post::Post, post_type::PostType, user::User};\n    use crate::traits::DisplayPostContent;\n    use rocket::http::Status;\n    use rocket::serde::Serialize;\n    use rocket_db_pools::{sqlx::Acquire, Connection};\n    use rocket_dyn_templates::{context, Template};\n    ```", "```rs\n    #[get(\"/users/<user_uuid>/posts/<uuid>\", format = \"text/html\")]\n    pub async fn get_post(\n        mut db: Connection<DBConnection>,\n        user_uuid: &str,\n        uuid: &str,\n    ) -> HtmlResponse {}\n    ```", "```rs\n    let connection = db\n        .acquire()\n        .await\n        .map_err(|_| Status::InternalServerError)?;\n    let user = User::find(connection, user_uuid)\n        .await\n        .map_err(|e| e.status)?;\n    let connection = db\n        .acquire()\n        .await\n        .map_err(|_| Status::InternalServerError)?;\n    let post = Post::find(connection, uuid).await.map_err(|e| e.status)?;\n    if post.user_uuid != user.uuid {\n        return Err(Status::InternalServerError);\n    }\n    ```", "```rs\n    #[derive(Serialize)]\n    struct ShowPost {\n        post_html: String,\n    }\n    #[derive(Serialize)]\n    struct Context {\n        user: User,\n        post: ShowPost,\n    }\n    ```", "```rs\n    let mut post_html = String::new();\n        match post.post_type {\n            PostType::Text => post_html = \n            post.to_text().raw_html(),\n            PostType::Photo => post_html = \n            post.to_photo().raw_html(),\n            PostType::Video => post_html = \n            post.to_video().raw_html(),\n        }\n        let context = Context {\n            user,\n            post: ShowPost { post_html },\n        };\n        Ok(Template::render(\"posts/show\", context))\n    ```", "```rs\n    #[get(\"/users/<user_uuid>/posts?<pagination>\", format = \"text/html\")]\n    pub async fn get_posts(\n        mut db: Connection<DBConnection>,\n        user_uuid: &str,\n        pagination: Option<Pagination>,\n    ) -> HtmlResponse {\n        let user = User::find(&mut db, \n        user_uuid).await.map_err(|e| e.status)?;\n    let (posts, new_pagination) = Post::find_all(&mut \n        db, user_uuid, pagination)\n            .await\n            .map_err(|e| e.status)?;\n    }\n    ```", "```rs\n    #[derive(Serialize)]\n    struct ShowPost {\n     uuid: String,\n     post_html: String,\n    }\n    let show_posts: Vec<ShowPost> = posts\n        .into_iter()\n        .map(|post| {\n            let uuid = post.uuid.to_string();\n            let mut post_html = String::new();\n            match post.post_type {\n                PostType::Text => post_html = \n                post.to_text().raw_html(),\n                PostType::Photo => post_html = \n                post.to_photo().raw_html(),\n                PostType::Video => post_html = \n                post.to_video().raw_html(),\n            };\n            ShowPost { uuid, post_html }\n        })\n        .collect();\n    let context =\n        context! {user, posts: show_posts, pagination: \n        new_pagination.map(|pg|pg.to_context())};\n    Ok(Template::render(\"posts/index\", context))\n    ```", "```rs\nfn multiplication<T>(a: T, b: T) -> T {}\n```", "```rs\nstruct Something<T>{\n```", "```rs\n    a: T,\n```", "```rs\n    b: T,\n```", "```rs\n}\n```", "```rs\nenum Shapes<T, U> {\n```", "```rs\n    Rectangle(T, U),\n```", "```rs\n    Circle(T),\n```", "```rs\n}\n```", "```rs\nimpl<T, U> Something<T, U> {\n```", "```rs\n    fn add(&self, T, U) -> T {}\n```", "```rs\n}\n```", "```rs\n    pub fn to_media(self) -> Box<dyn DisplayPostContent> {\n        match self.post_type {\n            PostType::Text => Box::new(self.to_text()),\n            PostType::Photo => Box::new(self.to_photo()),\n            PostType::Video => Box::new(self.to_video()),\n        }\n    }\n    ```", "```rs\n    struct Context {\n        …\n    }\n    fn create_context<T>(user: User, media: T) -> Context {\n        Context {\n            user,\n            post: ShowPost {\n                post_html: media.raw_html(),\n            },\n        }\n    }\n    ```", "```rs\n    let context = Context {...};\n    ```", "```rs\nlet media = post.to_media();\nlet context = create_context(user, media);\n```", "```rs\nfn create_context<T: DisplayPostContent>(user: User, media: T) -> Context {...}\n```", "```rs\nfn create_context<T: DisplayPostContent + ?Sized>(user: User, media: &T) -> Context {...}\n```", "```rs\nfn create_context<T>(user: User, media: &T) -> Context\n```", "```rs\nwhere T: DisplayPostContent + ?Sized {...}\n```", "```rs\nlet context = create_context(user, &*media);\n```", "```rs\nfn something() -> User {\n```", "```rs\n    let user = User::find(...).unwrap();\n```", "```rs\n    user\n```", "```rs\n}\n```", "```rs\nlet user = something()\n```", "```rs\nfn something() {\n```", "```rs\n    let user = User::find(...).unwrap();\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\n...\n```", "```rs\n{\n```", "```rs\n    let user = User::find(...).unwrap();\n```", "```rs\n}\n```", "```rs\n...\n```", "```rs\nStack: ☐☐☐☐☐☐☐☐☐☐☐☐\n```", "```rs\nHeap:  ☐☐☐☐☐☐☐☐☐☐☐☐\n```", "```rs\nStack: ☐☒☒☒☐☐☐☐☐☐☐☐\n```", "```rs\nHeap:  ☐☐☐☐☐☐☐☐☐☐☐☐\n```", "```rs\nStack: ☐☒☐☐☐☐☐☐☐☐☐☐\n```", "```rs\n         ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☐☐☐☐☐☐\n```", "```rs\nlet show_posts: Vec<ShowPost> = posts\n```", "```rs\n    .into_iter()\n```", "```rs\n    .map(|post| ShowPost {\n```", "```rs\n        post_html: post.to_media().raw_html(),\n```", "```rs\n        uuid: post.uuid.to_string(),\n```", "```rs\n    })\n```", "```rs\n    .collect();\n```", "```rs\nlet context = ...\n```", "```rs\nerror[E0382]: borrow of moved value: `post`\n  --> src/routes/post.rs:78:19\n   |\n76 |         .map(|post| ShowPost {\n   |               ---- move occurs because `post` has type `models::post::Post`, which does not implement the `Copy` trait\n77 |             post_html: post.to_media().raw_html(),\n   |                             ---------- `post` moved due to this method call\n78 |             uuid: post.uuid.to_string(),\n   |                   ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n```", "```rs\nStack: ☐☒☐☐☒☐☐☐☐☐☐☐\n```", "```rs\n         ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☐☐☐☐☐☐\n```", "```rs\nStack: ☐☒☐☐☒☐☐☐☐☐☐☐\n```", "```rs\n              ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☐☐☐☐☐☐\n```", "```rs\nlet show_posts: Vec<ShowPost> = posts\n```", "```rs\n    .into_iter()\n```", "```rs\n    .map(|post| ShowPost {\n```", "```rs\n        uuid: post.uuid.to_string(),\n```", "```rs\n        post_html: post.to_media().raw_html(),\n```", "```rs\n    })\n```", "```rs\n    .collect();\n```", "```rs\nlet x: u8 = 8;\n```", "```rs\nlet y = x;\n```", "```rs\nStack: ☐☒☐☐☒☐☐☐☐☐☐☐\n```", "```rs\nHeap:  ☐☐☐☐☐☐☐☐☐☐☐☐\n```", "```rs\n#[derive(Copy, Clone)]\n```", "```rs\nstruct Circle {\n```", "```rs\n    r: u8,\n```", "```rs\n}\n```", "```rs\n#[derive(Copy, Clone)]\n```", "```rs\npub struct Sheep {\n```", "```rs\n    ...\n```", "```rs\n    pub name: String,\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\n#[derive(Clone)]\n```", "```rs\npub struct Sheep {\n```", "```rs\n    ...\n```", "```rs\n    pub name: String,\n```", "```rs\n    ...\n```", "```rs\n}\n```", "```rs\nlet dolly = Sheep::new(...);\n```", "```rs\nStack: ☐☒☐☐☐☐☐☐☐☐☐☐\n```", "```rs\n         ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☐☐☐☐☐☐\n```", "```rs\nlet debbie = dolly;\n```", "```rs\nStack: ☐☒☐☐☐☐☒☐☐☐☐☐\n```", "```rs\n         ↓                ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☒☒☒☒☐☐\n```", "```rs\nStack: ☐☒☐☐☐☐☐☐☐☐☐☐\n```", "```rs\n         ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☐☐☐☐☐☐\n```", "```rs\nStack: ☐☒←☒☐☐☐☐☐☐☐☐\n```", "```rs\n         ↓\n```", "```rs\nHeap:  ☐☒☒☒☒☐☐☐☐☐☐☐\n```", "```rs\n#[derive(Debug)]\n```", "```rs\nstruct Helicopter {\n```", "```rs\n    height: u8,\n```", "```rs\n    cargo: Vec<u8>,    \n```", "```rs\n}\n```", "```rs\nlet mut airwolf = Helicopter {\n```", "```rs\n    height: 0,\n```", "```rs\n    cargo: Vec::new(),\n```", "```rs\n};\n```", "```rs\nairwolf.height = 10;\n```", "```rs\nlet camera_monitor_a = &airwolf;\n```", "```rs\nlet camera_monitor_a = &airwolf;\n```", "```rs\nlet camera_monitor_b = &airwolf;\n```", "```rs\n...\n```", "```rs\nlet camera_monitor_z = &airwolf;\n```", "```rs\nlet remote_control = &mut airwolf;\n```", "```rs\nremote_control.height = 15;\n```", "```rs\nlet last_load = camera_monitor_a.cargo.last(); // None\n```", "```rs\nremote_control.cargo.push(100);\n```", "```rs\n    pub struct TextPost(pub Post);\n    ```", "```rs\n    pub fn to_text(self) -> TextPost { // self is post instance\n        TextPost(self) // post is moved into TextPost instance \n    }\n    ```", "```rs\n    pub struct TextPost(&Post);\n    ```", "```rs\n    impl TextPost {\n        pub fn new(post: &Post) -> Self {\n            TextPost(post)\n        }\n    }\n    ```", "```rs\npub fn to_text(&self) -> TextPost {\n    TextPost::new(self)\n}\n```", "```rs\npub fn to_media(self) -> Box<dyn DisplayPostContent> {\n    match self.post_type {\n        PostType::Text => Box::new((&self).to_text()),\n        ...\n    }\n}\n```", "```rs\n    error[E0106]: missing lifetime specifier\n     --> src/models/text_post.rs:4:21\n      |\n    4 | pub struct TextPost(&Post);\n      |                     ^ expected named lifetime parameter\n    ```", "```rs\nfn main() {\n    let x;\n    {\n        let y = 5;\n        x = &y;\n    } // y is out of scope\n    println!(\"{}\", *x);\n}\n```", "```rs\n    fn main() {\n        let x;\n        {\n            let y = 5;\n            x = &y;\n            println!(\"{}\", *x);\n        }\n    }\n    ```", "```rs\n    pub struct TextPost(&Post);\n    ```", "```rs\npub struct TextPost<'a>(&'a Post);\n```", "```rs\nlet pi: &'static f64 = &3.14;\n```", "```rs\n    impl<'a> TextPost<'a> {\n        pub fn new(post: &'a Post) -> Self {...}\n    }\n    impl<'a> DisplayPostContent for TextPost<'a> {...}\n    ```", "```rs\n    pub struct PhotoPost<'a>(&'a Post);\n    impl<'a> PhotoPost<'a> {\n        pub fn new(post: &'a Post) -> Self {\n            PhotoPost(post)\n        }\n    }\n    impl<'a> DisplayPostContent for PhotoPost<'a> {...}\n    ```", "```rs\n    pub struct VideoPost<'a>(&'a Post);\n    impl<'a> VideoPost<'a> {\n        pub fn new(post: &'a Post) -> Self {\n            VideoPost(post)\n        }\n    }\n    impl<'a> DisplayPostContent for VideoPost<'a> {...}\n    ```", "```rs\n    impl Post {\n        pub fn to_text(&self) -> TextPost {\n            TextPost::new(self)\n        }\n        pub fn to_photo(&self) -> PhotoPost {\n            PhotoPost::new(self)\n        }\n        pub fn to_video(&self) -> VideoPost {\n            VideoPost::new(self)\n        }\n        pub fn to_media<'a>(&'a self) -> Box<dyn \n        DisplayPostContent + 'a> {\n            match self.post_type {\n                PostType::Photo => Box::new(self.to_photo()),\n                PostType::Text => Box::new(self.to_text()),\n                PostType::Video => Box::new(self.to_video()),\n            }\n        }\n        ...\n    }\n    ```", "```rs\n    use rocket::serde::Serialize;\n    ...\n    #[derive(Serialize)]\n    pub struct ShowPost {\n        pub uuid: String,\n        pub post_html: String,\n    }\n    ```", "```rs\n    impl Post {\n        ...\n        pub fn to_show_post<'a>(&'a self) -> ShowPost {\n            ShowPost {\n                uuid: self.uuid.to_string(),\n                post_html: self.to_media().raw_html(),\n            }\n        }\n        ...\n    }\n    ```", "```rs\n    use crate::models::{\n        pagination::Pagination,\n        post::{Post, ShowPost},\n        user::User,\n    };\n    ```", "```rs\n    #[derive(Serialize)]\n    struct ShowPost {\n        post_html: String,\n    }\n    #[derive(Serialize)]\n    struct Context {\n        user: User,\n        post: ShowPost,\n    }\n    fn create_context<T: DisplayPostContent + ?Sized>(user: User, media: &T) -> Context {\n        Context {\n            user,\n            post: ShowPost {\n                post_html: media.raw_html(),\n            },\n        }\n    }\n    let media = post.to_media();\n    let context = create_context(user, &*media);\n    ```", "```rs\n    let context = context! { user, post: &(post.to_show_post())};\n    ```", "```rs\n    #[derive(Serialize)]\n    struct ShowPost {\n        uuid: String,\n        post_html: String,\n    }\n    let show_posts: Vec<ShowPost> = posts\n        .into_iter()\n        .map(|post| ShowPost {\n            uuid: post.uuid.to_string(),\n            post_html: post.to_media().raw_html(),\n        })\n        .collect();\n    ```", "```rs\nlet show_posts: Vec<ShowPost> = posts.into_iter().map(|post| post.to_show_post()).collect();\n```", "```rs\n    let context = context! {user, posts: &show_posts, pagination: new_pagination.map(|pg|pg.to_context())};\n    ```", "```rs\n    use crate::traits::DisplayPostContent;\n    use rocket::serde::Serialize;\n    ```"]