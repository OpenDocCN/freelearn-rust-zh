<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Going Further with Advanced Rust</h1>
                </header>
            
            <article>
                
<p>There are no doubts as to the difficulties that the Rust language poses to the avid learner. However, if you are reading this, you have gone further than most and invested the time needed to improve. The language and the way it forces you to think about memory is going to introduce new concepts into your programming habits. Rust does not necessarily provide new tools to accomplish things, but the borrowing and ownership rules help us to concern ourselves more with scopes, lifetimes, and freeing memory appropriately, regardless of the language. Hence, let's go deeper into more advanced concepts in Rust in order to complete our understanding of the language – when, why, and how to apply concepts such as the following:</p>
<ul>
<li class="mce-root">Creating meaningful numbers with enums</li>
<li class="mce-root">There is no null</li>
<li class="mce-root">Complex conditions with pattern matching</li>
<li class="mce-root"><span>Implementing custom iterators</span></li>
<li class="mce-root">Filtering and transforming sequences efficiently</li>
<li>Reading memory the unsafe way</li>
<li class="mce-root">Shared ownership</li>
<li>Shared mutable ownership</li>
<li class="mce-root">References with explicit lifetimes</li>
<li>Enforcing behavior with trait bounds</li>
<li>Working with generic data types</li>
</ul>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating meaningful numbers with enums</h1>
                </header>
            
            <article>
                
<p>Enums, short for enumerations, are well-known programming constructs that many languages feature. These special cases of types allow a number to be mapped to a name. This can be used to tie constants together under a single name and lets us declare values as variants. For example, we could have pi, as well as Euler's number, as variants of an enum, <kbd>MathConstants</kbd>. Rust is no different, but it can go a lot further. Instead of simply relying on <em>naming numbers</em>, Rust allows enums the same flexibility as other Rust types have. Let's see what this means in practice.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to explore enums:</p>
<ol>
<li><span>Create a new project with </span><kbd>cargo new enums --lib</kbd><span> and open this folder in Visual Studio Code, or any IDE of your choosing. </span></li>
<li>Open <kbd>src/lib.rs</kbd> <span>and declare an enum containing some data:</span></li>
</ol>
<pre style="padding-left: 60px">use std::io;<br/><br/>pub enum ApplicationError {<br/>    Code { full: usize, short: u16 },<br/>    Message(String),<br/>    IOWrapper(io::Error),<br/>    Unknown<br/>}</pre>
<ol start="3">
<li>In addition to the declaration, we also implement a simple function:</li>
</ol>
<pre style="padding-left: 60px">impl ApplicationError {<br/><br/>    pub fn print_kind(&amp;self, mut to: &amp;mut impl io::Write) -&gt; <br/>    io::Result&lt;()&gt; {<br/>        let kind = match self {<br/>            ApplicationError::Code { full: _, short: _ } =&gt; "Code",<br/>            ApplicationError::Unknown =&gt; "Unknown",<br/>            ApplicationError::IOWrapper(_) =&gt; "IOWrapper",<br/>            ApplicationError::Message(_) =&gt; "Message"<br/>        };<br/>        write!(&amp;mut to, "{}", kind)?; <br/>        Ok(())<br/>    }<br/>}</pre>
<ol start="4">
<li>Now, we also need to do something with the enum, so let's implement a dummy function called <kbd>do_work</kbd>:</li>
</ol>
<pre style="padding-left: 60px">pub fn do_work(choice: i32) -&gt; Result&lt;(), ApplicationError&gt; {<br/>    if choice &lt; -100 {<br/>        <br/>            Err(ApplicationError::IOWrapper(io::Error::<br/>             from(io::ErrorKind::Other<br/>  )))<br/>    } else if choice == 42 {<br/>        Err(ApplicationError::Code { full: choice as usize, short: <br/>        (choice % u16::max_value() as i32) as u16 } )<br/>    } else if choice &gt; 42 {<br/>        Err(ApplicationError::Message(<br/>            format!("{} lead to a terrible error", choice)<br/>        ))<br/>    } else {<br/>        Err(ApplicationError::Unknown)<br/>    }<br/>}</pre>
<ol start="5">
<li>Nothing is true until it's tested! Now, add a number of tests that show the powerful matching of enums, starting with the <kbd>do_work()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><br/>#[cfg(test)]<br/>mod tests {<br/>    use super::{ApplicationError, do_work};<br/>    use std::io;<br/><br/>    #[test]<br/>    fn test_do_work() {<br/>        let choice = 10;<br/>        if let Err(error) = do_work(choice) {<br/>            match error {<br/>                ApplicationError::Code { full: code, short: _ } =&gt; <br/>                assert_eq!(choice as usize, code),<br/>                // the following arm matches both variants (OR)<br/>                ApplicationError::Unknown | <br/>                ApplicationError::IOWrapper(_) =&gt; assert!(choice &lt; <br/>                42),<br/>                ApplicationError::Message(msg) =&gt; <br/>                assert_eq!(format!<br/>                ("{} lead to a terrible error", choice), msg)<br/>            }<br/>        }<br/>    }</pre>
<p style="padding-left: 60px">For the <kbd>get_kind()</kbd> function, we also require a test: </p>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_application_error_get_kind() {<br/>        let mut target = vec![];<br/>        let _ = ApplicationError::Code { full: 100, short: 100 <br/>        }.print_kind(&amp;mut target);<br/>        assert_eq!(String::from_utf8(target).unwrap(), <br/>        "Code".to_string());<br/>        <br/>        let mut target = vec![];<br/>        let _ = ApplicationError::Message("0".to_string()).<br/>        print_kind(&amp;mut target);<br/>        assert_eq!(String::from_utf8(target).unwrap(), <br/>        "Message".to_string());<br/>        <br/>        let mut target = vec![];<br/>        let _ = ApplicationError::Unknown.print_kind(&amp;mut target);<br/>        assert_eq!(String::from_utf8(target).unwrap(), <br/>        "Unknown".to_string());<br/>        <br/>        let mut target = vec![];<br/>        let error = io::Error::from(io::ErrorKind::WriteZero);<br/>        let _ = ApplicationError::IOWrapper(error).print_kind(&amp;mut <br/>        target);<br/>        assert_eq!(String::from_utf8(target).unwrap(), <br/>        "IOWrapper".to_string());<br/><br/>    }<br/>}</pre>
<ol start="6">
<li>In a call to <kbd>cargo test</kbd> in the root directory of the project, we can observe the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling enums v0.1.0 (Rust-Cookbook/Chapter02/enums)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.61s<br/>     Running target/debug/deps/enums-af52cbd5cd8d54cb<br/><br/>running 2 tests<br/>test tests::test_do_work ... ok<br/>test tests::test_application_error_get_kind ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests enums<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's see how enums work under the hood.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Enums in Rust encapsulate choices—just as in any language. However, they behave similarly to regular structures in a lot of ways:</p>
<ul>
<li>They can have <kbd>impl</kbd> blocks for traits and functions.</li>
<li>Unnamed and named properties can carry different values.</li>
</ul>
<p>These aspects make them really great candidates for choices of all kinds, be it configuration values, flags, constants, or wrapping errors, as we did in <em>Step 2</em>. Typical enums in other languages map a name to a numerical value of your choice, but Rust goes one step further. Instead of just numerical values, Rust's enum can have any value and even named properties. Take a look at the definition in <em>Step 2</em>:</p>
<pre>pub enum ApplicationError {<br/>    Code { full: usize, short: u16 },<br/>    Message(String),<br/>    IOWrapper(io::Error),<br/>    Unknown<br/>}</pre>
<p><kbd>ApplicationError::Code</kbd> features two properties, one called <kbd>full</kbd> and one called <kbd>short</kbd>—assignable just like any other <kbd>struct</kbd> instance. The second and third variations, <kbd>Message</kbd> and <kbd>IOWrapper</kbd>, encapsulate another type instance entirely, one a <kbd>String</kbd>, and the other an <kbd>std::io::Error</kbd>, similar to tuples.</p>
<p>The additional ability to work in match clauses makes these constructs very useful, especially for large code bases where readability is important—an example of which can be found in <em>Step 3</em>, where we implement a function at the enum's type. This function maps explicit enum instances to strings for easier printing. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><em>Step 4</em> implements a helper function that provides us with different kinds of errors and values to work with, something that we require in <em>Step 5</em>, where we create two extensive tests of these functions. There, we use the <kbd>match</kbd> clause (which will also be discussed in a later recipe in this chapter) to extract values from the errors and match on multiple enum variants in a single arm. Additionally, we created a test to show that the <kbd>print_kind()</kbd> function works by using a <kbd>Vec</kbd> as a stream (thanks to it implementing the <kbd>Write</kbd> trait). </p>
<p><span>We've successfully learned how to create meaningful numbers with enums. Now, let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There is no null</h1>
                </header>
            
            <article>
                
<p>Functional languages typically don't have a concept of <strong>null</strong> for the simple reason that it's always a special case. If you strictly follow functional principles, each input must have a workable output—but what is null? Is it an error? Or within normal operating parameters, but a negative result?</p>
<p>As a legacy feature, null has been around since C/C++, when a pointer could actually point to the (invalid) address, <kbd>0</kbd>. However, many new languages try to move away from that. Rust does not have null, and no return value as a normal case with the <kbd>Option</kbd> type. The case of error is covered by the <kbd>Result</kbd> type, to which we dedicated an entire chapter, <a href="898e8c94-b6e0-41d4-a06a-6fd95fb88466.xhtml">Chapter 5</a>, <em>Handling Errors and Other Results</em>.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Since we are exploring a built-in library feature, we'll create several tests that cover everything:</p>
<ol>
<li><span>Create a new project using </span><kbd>cargo new not-null --lib</kbd><span> and open the project folder using Visual Studio code. </span></li>
<li>To start off, let's see what <kbd>unwrap()</kbd> <span>does and replace the default test in</span> <kbd>src/lib.rs</kbd> <span>with the following code:</span></li>
</ol>
<pre>    #[test]<br/>    #[should_panic]<br/>    fn option_unwrap() {<br/>        // Options to unwrap Options<br/>        assert_eq!(Some(10).unwrap(), 10);<br/>        assert_eq!(None.unwrap_or(10), 10);<br/>        assert_eq!(None.unwrap_or_else(|| 5 * 2), 10);<br/>        <br/>        Option::&lt;i32&gt;::None.unwrap();<br/>        Option::&lt;i32&gt;::None.expect("Better say something when <br/>        panicking");<br/>    }</pre>
<ol start="3">
<li><kbd>Option</kbd> also wraps values well, and it's sometimes complicated (or simply verbose) to get them out. Here are a number of ways of getting the value out:</li>
</ol>
<pre>    #[test]<br/>    fn option_working_with_values() {<br/>        let mut o = Some(42);<br/><br/>        let nr = o.take();<br/>        assert!(o.is_none());<br/>        assert_eq!(nr, Some(42));<br/><br/>        let mut o = Some(42);<br/>        assert_eq!(o.replace(1535), Some(42));<br/>        assert_eq!(o, Some(1535));<br/><br/>        let o = Some(1535);<br/>        assert_eq!(o.map(|v| format!("{:#x}", v)), <br/>        Some("0x5ff".to_owned()));<br/><br/>        let o = Some(1535);<br/>        match o.ok_or("Nope") {<br/>            Ok(nr) =&gt; assert_eq!(nr, 1535),<br/>            Err(_) =&gt; assert!(false)<br/>        }<br/>    }</pre>
<ol start="4">
<li>Due to their functional origins, where it's often not important whether one works on a single value or a collection, <kbd>Option</kbd> also behaves like a collection in some ways:</li>
</ol>
<pre>    #[test]<br/>    fn option_sequentials() {<br/>        let a = Some(42);<br/>        let b = Some(1535);<br/>        // boolean logic with options. Note the returned values<br/>        assert_eq!(a.and(b), Some(1535));<br/>        assert_eq!(a.and(Option::&lt;i32&gt;::None), None);<br/>        assert_eq!(a.or(None), Some(42));<br/>        assert_eq!(a.or(b), Some(42));<br/>        assert_eq!(None.or(a), Some(42));<br/>        let new_a = a.and_then(|v| Some(v + 100))<br/>                     .filter(|&amp;v| v != 42);<br/><br/>        assert_eq!(new_a, Some(142));<br/>        let mut a_iter = new_a.iter();<br/>        assert_eq!(a_iter.next(), Some(&amp;142));<br/>        assert_eq!(a_iter.next(), None);<br/>    }</pre>
<ol start="5">
<li>Lastly, using the <kbd>match</kbd> clause on <kbd>Option</kbd> is very popular and often necessary:</li>
</ol>
<pre>    #[test]<br/>    fn option_pattern_matching() {<br/><br/>        // Some trivial pattern matching since this is common<br/>        <br/>        match Some(100) {<br/>            Some(v) =&gt; assert_eq!(v, 100),<br/>            None =&gt; assert!(false) <br/>        };<br/><br/>        if let Some(v) = Some(42) {<br/>            assert_eq!(v, 42);<br/>        }<br/>        else {<br/>            assert!(false);<br/>        }<br/>    }</pre>
<ol start="6">
<li>To see it all working, we should also run <kbd>cargo test</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling not-null v0.1.0 (Rust-Cookbook/Chapter02/not-null)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.58s<br/>     Running target/debug/deps/not_null-ed3a746487e7e3fc<br/><br/>running 4 tests<br/>test tests::option_pattern_matching ... ok<br/>test tests::option_sequentials ... ok<br/>test tests::option_unwrap ... ok<br/>test tests::option_working_with_values ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests not-null<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p class="mce-root"/>
<p><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>Options</kbd> are, to our initial surprise, an enum. While this almost guarantees great <kbd>match</kbd> compatibility, enums behave a lot like structs in the remaining aspects. In <em>Step 2</em>, we see that it's not just a regular enum, but also a typed enum—which forces us to add a type declaration to <kbd>None</kbd> as well. <em>Step 2</em> also shows ways how to get values out of the <kbd>Option</kbd> type, with and without panicking. <kbd>unwrap()</kbd> is a popular choice, but it comes with some variations that don't halt the thread if <kbd>None</kbd> is encountered. </p>
<p><kbd>unwrap()</kbd><span> is always a dangerous thing, and should only be used in non-production code. It panics, which can bring the entire program to a sudden, unexpected halt, and doesn't even leave you with a proper error message. If stopping the program is the desired outcome, </span><kbd>expect()</kbd><span> is a better choice since it lets you add a simple message. This is why we added the <kbd>#[should_panic]</kbd> attribute to the unit test, so that we can prove to you that it actually panics (or otherwise the test fails).</span></p>
<p><em>Step 3</em> shows some non-intrusive ways to <em>unwrap</em> the value of <kbd>Option</kbd>. Especially since <kbd>unwrap()</kbd> returns the owned value while destroying <kbd>Option</kbd> itself, other ways can be more useful if <kbd>Option</kbd> remains part of a data structure and only temporarily holds a value. <kbd>take()</kbd> was designed for these situations that replace the value with <kbd>None</kbd>, similar to <kbd>replace()</kbd>, which does the same for the replacement value. Furthermore, there is <kbd>map()</kbd>, which lets you work directly with the value (if present) and ignore the usual <kbd>if</kbd>-then or <kbd>match</kbd> constructs, which add a lot of code verbosity (refer to <em>step 5</em>).</p>
<p><em>Step 4</em> features an interesting tidbit in the middle: <kbd>Options</kbd> can be used like Booleans to perform logic operations, similar to Python, where AND/OR operations return a particular operand (<a href="https://docs.python.org/3/reference/expressions.html#boolean-operations">https://docs.python.org/3/reference/expressions.html#boolean-operations</a>) in either case. Last but not least, <kbd>Options</kbd> can also be treated like collections using an iterator. </p>
<p>Rust's options are very versatile and, by looking at the documents (<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>), you can find out many different ways to transform values on the fly without tedious guard clauses with <kbd>if</kbd>, <kbd>let</kbd>, and <kbd>match</kbd>.</p>
<p>Now that we have<span> successfully learned that there is no null in Rust, let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Complex conditions with pattern matching</h1>
                </header>
            
            <article>
                
<p>As shown in the previous recipe, pattern matching is very useful with enums. However, there is more! Pattern matching is a construct that originates in functional languages and curtails much of the choice between conditional branches and the assignment of properties in <kbd>struct</kbd> that commonly follows. These steps are taken at once, reducing the amount of code on the screen and creating something akin to a higher-order <kbd>switch-case</kbd> statement. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Just a few steps need to be followed in order to learn more about pattern matching:</p>
<ol>
<li><span>Create a new binary project using </span><kbd>cargo new pattern-matching</kbd><span>. This time, we'll run an actual executable! Again, open the project using Visual Studio Code or another editor. </span></li>
<li>Let's check out literal matching. Just like a <kbd>switch-case</kbd> statement in other languages, each matching arm can match to literals as well:</li>
</ol>
<pre style="padding-left: 60px">fn literal_match(choice: usize) -&gt; String {<br/>    match choice {<br/>        0 | 1 =&gt; "zero or one".to_owned(),<br/>        2 ... 9 =&gt; "two to nine".to_owned(),<br/>        10 =&gt; "ten".to_owned(),<br/>        _ =&gt; "anything else".to_owned()<br/>    }<br/>}</pre>
<ol start="3">
<li>However, pattern matching is way more powerful than that. For example, tuple elements can be extracted and selectively matched:</li>
</ol>
<pre style="padding-left: 60px">fn tuple_match(choices: (i32, i32, i32, i32)) -&gt; String {<br/>    match choices {<br/>        (_, second, _, fourth) =&gt; format!("Numbers at positions 1 <br/>        and 3 are {} and {} respectively", second, fourth)<br/>    }<br/>}</pre>
<ol start="4">
<li><strong>Destructuring</strong> (moving properties out of a <kbd>struct</kbd> into their own variables) is a powerful feature in conjunction with structs and enums. First, this facilitates the assigning of multiple variables in a single matching arm to values that are assigned to properties at the incoming struct instance. Now, let's define a few structs and enums:</li>
</ol>
<pre style="padding-left: 60px">enum Background {<br/>    Color(u8, u8, u8),<br/>    Image(&amp;'static str),<br/>}<br/><br/>enum UserType {<br/>    Casual,<br/>    Power<br/>}<br/><br/>struct MyApp {<br/>    theme: Background,<br/>    user_type: UserType,<br/>    secret_user_id: usize<br/>}</pre>
<p style="padding-left: 60px">Then, the individual properties can be matched in a destructuring match. Enums work just as well—however, be sure to cover all possible variations; the compiler will notice (or use the special <kbd>_</kbd> to match all). <span>Matching is also done from top to bottom, so whichever rule applies first will be executed. </span>The following snippet matches variations of the structs we just defined. It matches and assigns variables if a particular user type and theme is detected:</p>
<pre style="padding-left: 60px">fn destructuring_match(app: MyApp) -&gt; String {<br/>    match app {<br/>        MyApp { user_type: UserType::Power, <br/>                secret_user_id: uid, <br/>                theme: Background::Color(b1, b2, b3) } =&gt; <br/>            format!("A power user with id &gt;{}&lt; and color background <br/>            (#{:02x}{:02x}{:02x})", uid, b1, b2, b3),<br/>        MyApp { user_type: UserType::Power, <br/>                secret_user_id: uid, <br/>                theme: Background::Image(path) } =&gt; <br/>            format!("A power user with id &gt;{}&lt; and image background <br/>            (path: {})", uid, path),<br/>        MyApp { user_type: _, secret_user_id: uid, .. } =&gt; format!<br/>        ("A regular user with id &gt;{}&lt;, individual backgrounds not <br/>        supported", uid), <br/>    }<br/>}</pre>
<ol start="5">
<li>On top of the powerful regular matching, a guard can also enforce certain conditions. Similar to destructuring, we can add more constraints:</li>
</ol>
<pre style="padding-left: 60px">fn guarded_match(app: MyApp) -&gt; String { <br/>    match app {<br/>        MyApp { secret_user_id: uid, .. } if uid &lt;= 100 =&gt; "You are <br/>        an early bird!".to_owned(),<br/>        MyApp { .. } =&gt; "Thank you for also joining".to_owned()<br/>    }<br/>}</pre>
<ol start="6">
<li>So far, borrowing and ownership has not been a significant concern. However, the <kbd>match</kbd> clauses so far have all taken ownership and transferred it to the scope of the matching arm (anything after <kbd>=&gt;</kbd>), which, unless you return it, means that the outside scope cannot do any other work with it. To remedy that, references can be matched as well:</li>
</ol>
<pre style="padding-left: 60px">fn reference_match(m: &amp;Option&lt;&amp;str&gt;) -&gt; String {<br/>    match m {<br/>        Some(ref s) =&gt; s.to_string(),<br/>        _ =&gt; "Nothing".to_string()<br/>    }<br/>}</pre>
<ol start="7">
<li>In order to go full circle, we have not yet matched a particular type of literal: the string literal. Due to their heap allocation, they are fundamentally different from types such as <kbd>i32</kbd> or <kbd>usize</kbd>. Syntactically, however, they don't look different from any other form of matching:</li>
</ol>
<pre style="padding-left: 90px">fn literal_str_match(choice: &amp;str) -&gt; String {<br/>    match choice {<br/>        "<img class="inline-image" src="Images/c61110a2-3a8e-4f65-86a8-cfdf19962203.png"/>" =&gt; "Power lifting".to_owned(),<br/>        "<img class="inline-image" src="Images/87e3d4e9-c712-4ee9-b394-ec70295764d2.png"/>" =&gt; "Football".to_owned(),<br/>        "<img class="inline-image" src="Images/ebf8a334-dbc9-4b88-84f7-0cafef311521.png"/>" =&gt; "BJJ".to_owned(),<br/>        _ =&gt; "Competitive BBQ".to_owned()<br/>    }<br/>}</pre>
<ol start="8">
<li>Now, let's tie it all together and build a <kbd>main</kbd> function that calls the various functions with the right parameters. Let's begin by printing a few simpler matches:</li>
</ol>
<pre style="padding-left: 60px">pub fn main() {<br/>    let opt = Some(42);<br/>    match opt {<br/>        Some(nr) =&gt; println!("Got {}", nr),<br/>        _ =&gt; println!("Found None") <br/>    }<br/>    println!();<br/>    println!("Literal match for 0: {}", literal_match(0));<br/>    println!("Literal match for 10: {}", literal_match(10));<br/>    println!("Literal match for 100: {}", literal_match(100));<br/><br/>    println!();<br/>    println!("Literal match for 0: {}", tuple_match((0, 10, 0, <br/>    100)));<br/>    <br/>    println!();<br/>    let mystr = Some("Hello");<br/>    println!("Matching on a reference: {}", <br/>    reference_match(&amp;mystr));<br/>    println!("It's still owned here: {:?}", mystr);</pre>
<p style="padding-left: 60px">Next, we can also print the destructured matches:</p>
<pre style="padding-left: 60px">    println!();<br/>    let power = MyApp {<br/>        secret_user_id: 99,<br/>        theme: Background::Color(255, 255, 0),<br/>        user_type: UserType::Power<br/>    };<br/>    println!("Destructuring a power user: {}", <br/>    destructuring_match(power));<br/>    <br/>    let casual = MyApp {<br/>        secret_user_id: 10,<br/>        theme: Background::Image("my/fav/image.png"),<br/>        user_type: UserType::Casual<br/>    };<br/>    println!("Destructuring a casual user: {}", <br/>    destructuring_match(casual));<br/><br/>    let power2 = MyApp {<br/>        secret_user_id: 150,<br/>        theme: Background::Image("a/great/landscape.png"),<br/>        user_type: UserType::Power<br/>    };<br/>    println!("Destructuring another power user: {}", <br/>    destructuring_match(power2));</pre>
<p style="padding-left: 60px">And lastly, let's see about guards and literal string matches on UTF symbols:</p>
<pre style="padding-left: 60px">    println!();<br/>    let early = MyApp {<br/>        secret_user_id: 4,<br/>        theme: Background::Color(255, 255, 0),<br/>        user_type: UserType::Power<br/>    };<br/>    println!("Guarded matching (early): {}", guarded_match(early));<br/><br/>     let not_so_early = MyApp {<br/>        secret_user_id: 1003942,<br/>        theme: Background::Color(255, 255, 0),<br/>        user_type: UserType::Power<br/>    };<br/>    println!("Guarded matching (late): {}", <br/>    guarded_match(not_so_early));<br/>    println!();<br/><br/>    println!("Literal match for <img class="inline-image" src="Images/ebf8a334-dbc9-4b88-84f7-0cafef311521.png"/>: {}", literal_str_match("<img class="inline-image" src="Images/ebf8a334-dbc9-4b88-84f7-0cafef311521.png"/>"));<br/>    println!("Literal match for <img class="inline-image" src="Images/87e3d4e9-c712-4ee9-b394-ec70295764d2.png"/>: {}", literal_str_match("<img class="inline-image" src="Images/87e3d4e9-c712-4ee9-b394-ec70295764d2.png"/>"));<br/>    println!("Literal match for <img class="inline-image" src="Images/c61110a2-3a8e-4f65-86a8-cfdf19962203.png"/>: {}", literal_str_match("<img class="inline-image" src="Images/c61110a2-3a8e-4f65-86a8-cfdf19962203.png"/>"));<br/>    println!("Literal match for <img class="inline-image" src="Images/f63f8d82-7691-440a-b3be-1adf3a9191be.png"/>: {}", literal_str_match("<img class="inline-image" src="Images/f63f8d82-7691-440a-b3be-1adf3a9191be.png"/>"));<br/>}</pre>
<ol start="9">
<li>The last step again involves running the program. Since this is not a library project, the results will be printed on the command line. Feel free to change any of the variables in the <kbd>main</kbd> function to see how it affects the output. Here's what the output <em>should</em> be:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling pattern-matching v0.1.0 (Rust-<br/>   Cookbook/Chapter02/pattern-matching)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.43s<br/>     Running `target/debug/pattern-matching`<br/>Got 42<br/><br/>Literal match for 0: zero or one<br/>Literal match for 10: ten<br/>Literal match for 100: anything else<br/><br/>Literal match for 0: Numbers at positions 1 and 3 are 10 and 100 respectively<br/><br/>Matching on a reference: Hello<br/>It's still owned here: Some("Hello")<br/><br/>Destructuring a power user: A power user with id &gt;99&lt; and color background (#ffff00)<br/>Destructuring a casual user: A regular user with id &gt;10&lt;, individual backgrounds not supported<br/>Destructuring another power user: A power user with id &gt;150&lt; and image background (path: a/great/landscape.png)<br/><br/>Guarded matching (early): You are an early bird!<br/>Guarded matching (late): Thank you for also joining<br/><br/>Literal match for <img class="inline-image" src="Images/ebf8a334-dbc9-4b88-84f7-0cafef311521.png"/>: BJJ<br/>Literal match for <img class="inline-image" src="Images/87e3d4e9-c712-4ee9-b394-ec70295764d2.png"/>: Football<br/>Literal match for <img class="inline-image" src="Images/c61110a2-3a8e-4f65-86a8-cfdf19962203.png"/>: Power lifting<br/>Literal match for <img class="inline-image" src="Images/f63f8d82-7691-440a-b3be-1adf3a9191be.png"/>: Competitive BBQ</pre>
<p class="mce-root"><span>Now, let's take a peek behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Ever since we came across pattern matching in the Scala programming language, we fell in love with its simplicity. As a major pillar of functional programming, the technique provides a quick way to transform values in various ways without sacrificing Rust's type safety. </p>
<p>The literal matches in <em>Steps 2</em> and <em>7 </em>are a great way to save on <kbd>if-else</kbd> chains. However, the most common matching is probably done to unpack <kbd>Result</kbd> or <kbd>Option</kbd> types for extracting the encapsulated values. While multiple matches are only possible using the <kbd>|</kbd> symbol , there are special operators to match to particular variations: <kbd>...</kbd> denotes a range, while <kbd>..</kbd> means to skip the remaining members of a struct. <kbd>_</kbd> is almost always a wildcard for ignoring a particular thing and, as a <kbd>match</kbd> clause, it is a catch-all and should be placed last. In <em>Step 3</em>, we did a lot of unpacking of tuples; we skipped some of the matches using an <kbd>_</kbd> in place of a variable name.</p>
<p>In a similar fashion, <em>Step 4</em> sets up and uses Rust's mechanism to match properties inside types when using the <kbd>match</kbd> clause (also called destructuring). This feature supports nesting and lets us pick values and sub-structs out of a complex struct instance. Neat! </p>
<p>However, it is often not done with matching on the type and then working with the unpacked values only in the match arm. Instead, having the match conditions lined up is a much better way to deal with allowed values within types. Rust's <kbd>match</kbd> clause supports guards for exactly that reason. <em>Step 5</em> shows what they are capable of. </p>
<p><em>Steps 8</em> and <em>9</em> both then show the use of the previously implemented <kbd>match</kbd> functions. We highly recommend going through some experiments yourself and seeing what changes. The typed matching allows for complex architectures without verbose safeguards or workarounds, which is exactly what we want!</p>
<p><span>We've successfully learned about complex conditions with pattern matching. Now, let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing custom iterators</h1>
                </header>
            
            <article>
                
<p>The true power of a great language is the way in which it lets the programmer integrate with types in the standard library and around the general ecosystem. One way to do this is the iterator pattern: defined by the Gang of Four in their book <em>Design Patterns</em> (Addison-Wesley Professional, 1994), an iterator is an encapsulation of a pointer moving through a collection. Rust provides a range of implementations on top of the <kbd>Iterator</kbd> trait. Let's see how we can leverage that power with only a few lines of code.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will build an iterator for the linked list we built in an earlier recipe. We recommend either using the <kbd>Chapter01/testing</kbd> project or walking with us through construction of the iterator. In case you are too busy for that, the full solution can be found in <kbd>Chapter02/custom-iterators</kbd>. These paths refer to the GitHub repository for this book at <a href="https://github.com/PacktPublishing/Rust-Programming-Cookbook">https://github.com/PacktPublishing/Rust-Programming-Cookbook</a>.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Iterators are typically their own structs and, since there can be different types (for example, for returning references instead of owned values), they are a good choice architecturally as well:</p>
<ol>
<li>Let's create the struct for the iterator of <kbd>List&lt;T&gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px">pub struct ConsumingListIterator&lt;T&gt;<br/>where<br/>    T: Clone + Sized,<br/>{<br/>    list: List&lt;T&gt;,<br/>}<br/><br/>impl&lt;T&gt; ConsumingListIterator&lt;T&gt;<br/>where<br/>    T: Clone + Sized,<br/>{<br/>    fn new(list: List&lt;T&gt;) -&gt; ConsumingListIterator&lt;T&gt; {<br/>        ConsumingListIterator { list: list }<br/>    }<br/>}</pre>
<ol start="2">
<li>So far, this is only a regular <kbd>struct</kbd> that lacks everything an iterator should have. Their defining nature is a <kbd>next()</kbd> function that advances the internal pointer and returns the value that it just moved off of. In typical Rust fashion, the returned value is wrapped in an <kbd>Option</kbd> that becomes <kbd>None</kbd> once the collection runs out of items. Let's implement the <kbd>Iterator</kbd> trait to get all of these features:</li>
</ol>
<pre style="padding-left: 60px">impl&lt;T&gt; Iterator for ConsumingListIterator&lt;T&gt;<br/>where<br/>    T: Clone + Sized,<br/>{<br/>    type Item = T;<br/><br/>    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {<br/>        self.list.pop_front()<br/>    }<br/>}</pre>
<ol start="3">
<li>Right now, we could instantiate <kbd>ConsumingListIterator</kbd> and pass our own <kbd>List</kbd> instance to it and it would work well. However, that is far from a seamless integration! The Rust standard library offers an additional trait to implement <kbd>IntoIterator</kbd>. By implementing this trait's functions, even a <kbd>for</kbd> loop knows what to do, and it looks just like any other collection and is easily interchangeable:</li>
</ol>
<pre style="padding-left: 60px">impl&lt;T&gt; IntoIterator for List&lt;T&gt;<br/>where<br/>    T: Clone + Sized,<br/>{<br/>    type Item = T;<br/>    type IntoIter = ConsumingListIterator&lt;Self::Item&gt;;<br/><br/>    fn into_iter(self) -&gt; Self::IntoIter {<br/>        ConsumingListIterator::new(self)<br/>    }<br/>}</pre>
<ol start="4">
<li>Lastly, we need to write a test to prove that everything is working. Let's add this to the existing test suite:</li>
</ol>
<pre style="padding-left: 60px"><br/>    fn new_list(n: usize, value: Option&lt;usize&gt;) -&gt; List&lt;usize&gt;{<br/>        let mut list = List::new_empty();<br/>        for i in 1..=n {<br/>            if let Some(v) = value {<br/>                list.append(v);<br/>            } else {<br/>                list.append(i);<br/>            }<br/>        }<br/>        return list;<br/>    }<br/><br/>    #[test]<br/>    fn test_list_iterator() {<br/>        let list = new_list(4, None);<br/>        assert_eq!(list.length, 4);<br/><br/>        let mut iter = list.into_iter();<br/>        assert_eq!(iter.next(), Some(1));<br/>        assert_eq!(iter.next(), Some(2));<br/>        assert_eq!(iter.next(), Some(3));<br/>        assert_eq!(iter.next(), Some(4));<br/>        assert_eq!(iter.next(), None);<br/><br/>        let list = new_list(4, Some(1));<br/>        assert_eq!(list.length, 4);<br/><br/>        for item in list {<br/>            assert_eq!(item, 1);<br/>        } <br/><br/>        let list = new_list(4, Some(1));<br/>        assert_eq!(list.length, 4);<br/>        assert_eq!(list.into_iter().fold(0, |s, e| s + e), 4);<br/>    }</pre>
<ol start="5">
<li>Running the tests will show how well this integration works. The <kbd>cargo test</kbd> command's output demonstrates this:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s<br/>     Running target/debug/deps/custom_iterators-77e564edad00bd16<br/><br/>running 7 tests<br/>test tests::bench_list_append ... ok<br/>test tests::test_list_append ... ok<br/>test tests::test_list_new_empty ... ok<br/>test tests::test_list_split ... ok<br/>test tests::test_list_iterator ... ok<br/>test tests::test_list_split_panics ... ok<br/>test tests::test_list_pop_front ... ok<br/><br/>test result: ok. 7 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests custom-iterators<br/><br/>running 5 tests<br/>test src/lib.rs - List (line 52) ... ignored<br/>test src/lib.rs - List&lt;T&gt;::append (line 107) ... ok<br/>test src/lib.rs - List&lt;T&gt;::new_empty (line 80) ... ok<br/>test src/lib.rs - List&lt;T&gt;::pop_front (line 134) ... ok<br/>test src/lib.rs - List&lt;T&gt;::split (line 173) ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out</pre>
<p>The next section is going to dive deeper into what's happening behind the scenes!</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Iterators are a great way of providing advanced capabilities to custom data structures. With their simple, unified interface, collection types can be switched out easily as well and programmers don't have to get used to new APIs for every data structure. </p>
<p>By implementing the <kbd>Iterator</kbd> trait in <em>Steps 1</em> and <em>2</em>, it becomes easy to provide exactly the desired access level to a collection's elements. In the case of this recipe (and similar to <kbd>Vec&lt;T&gt;</kbd>), it will consume the list entirely and remove the items one by one, starting at the front.</p>
<p>In <em>Step 3</em>, we implement <kbd>IntoIterator</kbd>, a trait that makes this construct available to the <kbd>for</kbd> loop and other users who call <kbd>into_iter()</kbd>. Not every collection implements this trait to provide multiple different iterators; for example, the second iterator of <kbd>Vec&lt;T&gt;</kbd> is reference-based, and only accessible via an <kbd>iter()</kbd> function on the type. By the way, a reference is a data type, just like the actual instance, so it's all about the type definition in this case. These definitions are made inside the trait implementation with the <kbd>type Item</kbd> declaration (so-called <strong>associated types</strong>: <a href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html">https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html</a>). These types are called associated types, and can be referenced using <kbd>Self::Item</kbd>—just like generics, but without the added syntax verbosity. </p>
<p>With these interfaces, you can get access to a large library of functions that only assume a working iterator to be present! Check out <em>Steps 4</em> and <em>5</em> to see the implementation and outcome of using the iterator on a newly created list type. </p>
<p><span>We've successfully learned how to implement custom iterators. Now, let's move on to the next recipe.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Filtering and transforming sequences efficiently</h1>
                </header>
            
            <article>
                
<p>While in the previous recipe we discussed implementing a custom iterator, it's now time to make use of the functions they provide. Iterators can transform, filter, reduce, or simply convert the underlying elements in a single go, thereby making it a very efficient endeavor. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>First, create a new project using <kbd>cargo new iteration --lib</kbd> and add the following to the newly created <kbd>Cargo.toml</kbd> file in the project's directory:</p>
<pre>[dev-dependencies]<br/>rand = "^0.5"</pre>
<p>This adds a dependency to the <kbd>rand</kbd> (<a href="https://github.com/rust-random/rand">https://github.com/rust-random/rand</a>) crate to the project, which will be installed upon running <kbd>cargo test</kbd> the first time. Open the entire project (or the <kbd>src/lib.rs</kbd> file) in Visual Studio Code.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In four easy steps, we'll be able to filter and transform collections in Rust:</p>
<ol>
<li>In order to use an iterator, you have to retrieve it first! Let's do that and implement a test that <span>quickly</span> shows how an iterator works on a regular Rust <kbd>Vec&lt;T&gt;</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn getting_the_iterator() {<br/>        let v = vec![10, 10, 10];<br/>        let mut iter = v.iter();<br/>        assert_eq!(iter.next(), Some(&amp;10));<br/>        assert_eq!(iter.next(), Some(&amp;10));<br/>        assert_eq!(iter.next(), Some(&amp;10));<br/>        assert_eq!(iter.next(), None);<br/><br/>        for i in v {<br/>            assert_eq!(i, 10);<br/>        }<br/>    }</pre>
<ol start="2">
<li>With one test added, let's explore the notion of iterator functions further. They are compose able and let you perform multiple steps in a single iteration (think of adding more things to a single <kbd>for</kbd> loop). Additionally, the outcome's type can be completely different from what you started with! Here is another test to add to the project that performs some data transformations:</li>
</ol>
<pre style="padding-left: 60px">    fn count_files(path: &amp;String) -&gt; usize {<br/>        path.len()<br/>    }<br/><br/>    #[test]<br/>    fn data_transformations() {<br/>        let v = vec![10, 10, 10];<br/>        let hexed = v.iter().map(|i| format!("{:x}", i));<br/>        assert_eq!(<br/>            hexed.collect::&lt;Vec&lt;String&gt;&gt;(),<br/>            vec!["a".to_string(), "a".to_string(), "a".to_string()]<br/>        );<br/>        assert_eq!(v.iter().fold(0, |p, c| p + c), 30);<br/>        let dirs = vec![<br/>            "/home/alice".to_string(),<br/>            "/home/bob".to_string(),<br/>            "/home/carl".to_string(),<br/>            "/home/debra".to_string(),<br/>        ];<br/><br/>        let file_counter = dirs.iter().map(count_files);<br/><br/>        let dir_file_counts: Vec&lt;(&amp;String, usize)&gt; = <br/>        dirs.iter().zip(file_counter).collect();<br/><br/>        assert_eq!(<br/>            dir_file_counts,<br/>            vec![<br/>                (&amp;"/home/alice".to_string(), 11),<br/>                (&amp;"/home/bob".to_string(), 9),<br/>                (&amp;"/home/carl".to_string(), 10),<br/>                (&amp;"/home/debra".to_string(), 11)<br/>            ]<br/>        )<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>As the final step, let's also look at some filtering and splitting. These have proven to be the most useful in our personal experience—it removes a lot of code verbosity. Here is some code:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn data_filtering() {<br/>        let data = vec![1, 2, 3, 4, 5, 6, 7, 8];<br/>        assert!(data.iter().filter(|&amp;n| n % 2 == 0).all(|&amp;n| n % 2 <br/>        == 0));<br/><br/>        assert_eq!(data.iter().find(|&amp;&amp;n| n == 5), Some(&amp;5));<br/>        assert_eq!(data.iter().find(|&amp;&amp;n| n == 0), None);<br/>        assert_eq!(data.iter().position(|&amp;n| n == 5), Some(4));<br/><br/>        assert_eq!(data.iter().skip(1).next(), Some(&amp;2));<br/>        let mut data_iter = data.iter().take(2);<br/>        assert_eq!(data_iter.next(), Some(&amp;1));<br/>        assert_eq!(data_iter.next(), Some(&amp;2));<br/>        assert_eq!(data_iter.next(), None);<br/><br/>        let (validation, train): (Vec&lt;i32&gt;, Vec&lt;i32&gt;) = data<br/>            .iter()<br/>            .partition(|&amp;_| (rand::random::&lt;f32&gt;() % 1.0) &gt; 0.8);<br/><br/>        assert!(train.len() &gt; validation.len());<br/>    }</pre>
<ol start="4">
<li>As always, we want to see the examples working! Run <kbd>cargo test</kbd> to do just that:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling libc v0.2.50<br/>   Compiling rand_core v0.4.0<br/>   Compiling iteration v0.1.0 (Rust-Cookbook/Chapter02/iteration)<br/>   Compiling rand_core v0.3.1<br/>   Compiling rand v0.5.6<br/>    Finished dev [unoptimized + debuginfo] target(s) in 5.44s<br/>     Running target/debug/deps/iteration-a23e5d58a97c9435<br/><br/>running 3 tests<br/>test tests::data_transformations ... ok<br/>test tests::getting_the_iterator ... ok<br/>test tests::data_filtering ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests iteration<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p><span>Do you want to know more? Let's see how it works.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Rust's iterators are heavily inspired by functional programming languages, which makes them very handy to use. As an iterator, every operation is applied sequentially one element at a time, but only as far as the iterator is moved forward. There are several types of operations shown in this recipe. The most important ones are as follows:</p>
<ul>
<li><kbd>map()</kbd> operations execute a value or type transformation, and they are very common and easy to use.</li>
<li><kbd>filter()</kbd>, in the same way as many similar operations, executes a predicate (a function with a Boolean return value) in order to determine whether an element is to be included in the output. Examples are <kbd>find()</kbd>, <kbd>take_while()</kbd>, <kbd>skip_while()</kbd>, and <kbd>any()</kbd>.</li>
<li>Aggregation functions such as <kbd>fold()</kbd>, <kbd>sum()</kbd>, <kbd>min()</kbd>, and <kbd>max()</kbd> are used to reduce the entire iterator's contents into a single object. That could be a number (<kbd>sum()</kbd>) or a hash map (for example, by using <kbd>fold()</kbd>).</li>
<li><kbd>chain()</kbd>, <kbd>zip()</kbd>, <kbd>fuse()</kbd>, and many more combine iterators so that they can be iterated over in a single loop. Typically, we use these if multiple run-throughs are otherwise <span>required</span>.</li>
</ul>
<p>This more functional style of programming not only reduces the amount of code that has to be written, but also acts as a universal vocabulary: instead of reading through the entire <kbd>for</kbd> loop that pushes items into a previously defined list if a condition applies, a function call to <kbd>filter()</kbd> tells the reader what to expect. <em>Steps 2</em> and <em>3</em> show different function invocations to transform (<em>Step 2</em>) or filter (<em>Step 3</em>) collections based on various use cases. </p>
<p class="mce-root"/>
<p>Additionally, iterators can be chained together, so a call to <kbd>iterator.filter().map().fold()</kbd> is not unusual and typically quicker to reason about than a loop that does the same thing. As the last step, most iterators are collected into their target collection or variable type. <kbd>collect()</kbd> evaluates the entire chain, which means that its execution is costly. Since the entire topic is very specific to the tasks at hand, check out the code we wrote and the outcomes/invocations to get the most out of it. <em>Step 4</em> only shows running the tests, but the real story is inside the code. </p>
<p><span>Done! We've successfully learned how to filter and transform sequences efficiently. Move on to the next recipe to learn more!</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading memory the unsafe way</h1>
                </header>
            
            <article>
                
<p><kbd>unsafe</kbd> is a concept in Rust where some compiler safety mechanisms are turned off. These <strong>superpowers</strong> bring Rust closer to C's abilities to manipulate (almost) arbitrary parts of the memory. <kbd>unsafe</kbd> itself qualifies a scope (or function) to be able to use these four superpowers (from <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html</a> ):</p>
<ul>
<li>Dereference a raw pointer.</li>
<li>Call an <kbd>unsafe</kbd> function or method.</li>
<li>Access or modify a mutable static variable.</li>
<li>Implement an unsafe trait.</li>
</ul>
<p class="mce-root">In most projects, <kbd>unsafe</kbd> is only required for using the <strong>FFI</strong> (short for <strong>Foreign Function Interface</strong>) because it's outside of the borrow checker's reach. Regardless, in this recipe, we are going to explore some unsafe ways to read memory.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In just a few steps, we are <kbd>unsafe</kbd>:</p>
<ol>
<li><span>Create a new library project using</span><span> </span><kbd>cargo new unsafe-ways --lib</kbd><span>. Open the project using Visual Studio Code or another editor. </span></li>
<li>Open <kbd>src/libr.rs</kbd> <span>to add the following function before the test module:</span></li>
</ol>
<pre style="padding-left: 60px">#![allow(dead_code)]<br/>use std::slice;<br/><br/>fn split_into_equal_parts&lt;T&gt;(slice: &amp;mut [T], parts: usize) -&gt; Vec&lt;&amp;mut [T]&gt; {<br/>    let len = slice.len();<br/>    assert!(parts &lt;= len);<br/>    let step = len / parts;<br/>    unsafe {<br/>        let ptr = slice.as_mut_ptr();<br/><br/>        (0..step + 1)<br/>            .map(|i| {<br/>                let offset = (i * step) as isize;<br/>                let a = ptr.offset(offset);<br/>                slice::from_raw_parts_mut(a, step)<br/>            })<br/>            .collect()<br/>    }<br/>}</pre>
<ol start="3">
<li>With that ready, we now have to add some tests inside <kbd>mod tests {}</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><br/>#[cfg(test)]<br/>mod tests {<br/>    use super::*;<br/>    #[test]<br/>    fn test_split_into_equal_parts() {<br/>        let mut v = vec![1, 2, 3, 4, 5, 6];<br/>        assert_eq!(<br/>            split_into_equal_parts(&amp;mut v, 3),<br/>            &amp;[&amp;[1, 2], &amp;[3, 4], &amp;[5, 6]]<br/>        );<br/>    }<br/>}</pre>
<ol start="4">
<li>Recalling the <kbd>unsafe</kbd> superpowers, we could try and change the way we are reading memory. Let's add this test to see how it works:</li>
</ol>
<pre style="padding-left: 60px">#[test]<br/>fn test_str_to_bytes_horribly_unsafe() {<br/>    let bytes = unsafe { std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;("Going <br/>               off the menu") };<br/>    assert_eq!(<br/>        bytes,<br/>            &amp;[<br/>                71, 111, 105, 110, 103, 32, 111, 102, 102, 32, 116, <br/>                104, 101, 32, 109, 101, 110, 117<br/>            ]<br/>        );<br/>    }<br/><br/></pre>
<ol start="5">
<li>The last step is to see the positive test results after running <kbd>cargo test</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling unsafe-ways v0.1.0 (Rust-Cookbook/Chapter02/unsafe-ways)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.41s<br/>     Running target/debug/deps/unsafe_ways-e7a1d3ffcc456d53<br/><br/>running 2 tests<br/>test tests::test_str_to_bytes_horribly_unsafe ... ok<br/>test tests::test_split_into_equal_parts ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests unsafe-ways<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Safety is an important concept in Rust, so let's find out what we trade off by using <kbd>unsafe</kbd>.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>While <kbd>unsafe</kbd> is one way to enable easier solutions to sometimes tricky situations, this book (<a href="https://rust-unofficial.github.io/too-many-lists/index.html">https://rust-unofficial.github.io/too-many-lists/index.html</a>) describes the limitations of safe programming perfectly with something as simple as a linked list.</p>
<div class="packt_infobox">Rust is a safe programming language, which means that the compiler makes sure that all the memory is accounted for. Thus, it is impossible for programs to obtain multiple mutable references to the same memory address, use memory after it has been freed, or incorrect type safety, among other things. This lets Rust avoid undefined behavior. For some limited use cases, however, these constraints prohibit valid use cases, which is why <kbd>unsafe</kbd> loosens some of these guarantees to accommodate some of the things only C would allow.</div>
<p class="mce-root"/>
<p>After setting up the project in <em>Step 1</em>, we are adding the first function in <em>Step 2</em>. Its purpose is similar to <kbd>chunks()</kbd> (<a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut">https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut</a>), but instead of an iterator, we are returning the entire collection right away, which is OK as an example, but should be thought about when implementing it for production use. Our function splits a provided (mutable) slice into a <kbd>parts</kbd> number of chunks of equal size and returns mutable references to them. Since the input is also a mutable reference to the entire part of the memory, we will have <kbd>parts + 1</kbd> number of mutable references to the same memory area; clearly, a violation of safe Rust! On top of that, this function allows going beyond the allocated memory with the <kbd>ptr.offset()</kbd> call (which does pointer arithmetic). </p>
<p>In the test created in <em>Step 3</em>, we show that it compiles and executes without any major problems. <em>Step 4</em> provides another example for unsafe code: changing the data type without casting. The <kbd>transmute</kbd> (<a href="https://doc.rust-lang.org/std/mem/fn.transmute.html">https://doc.rust-lang.org/std/mem/fn.transmute.html</a>) function can easily change the data type of a variable with all the consequences that come with that. Had we changed the type to something else, such as <kbd>u64</kbd>, we would end up with a totally different result and read memory that does not belong to the program. In <em>Step 5</em>, we run the whole test suite. </p>
<p><kbd>unsafe</kbd> Rust can be interesting to get that last bit of performance out of a data structure, do some magic bin-packing, or to implement <kbd>Send</kbd> and <kbd>Sync</kbd> (<a href="https://doc.rust-lang.org/std/mem/fn.transmute.html">https://doc.rust-lang.org/std/mem/fn.transmute.html</a>). Whatever you intend to do with <kbd>unsafe</kbd>, check out the nomicon (<a href="https://doc.rust-lang.org/nightly/nomicon/">https://doc.rust-lang.org/nightly/nomicon/</a>) to delve deeper into the depths. </p>
<p>Equipped with that knowledge, let's move on to the next recipe.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shared ownership</h1>
                </header>
            
            <article>
                
<p>Ownership and borrowing are fundamental concepts in Rust; they are the reason no runtime garbage collection is required. As a quick primer: how do they work? In short: scopes. Rust (and many other languages) use (nested) scopes to determine the validity of a variable, so it cannot be used outside of the scope (like a function). In Rust, these scopes <em>own</em> their variables, so they will be gone after the scope finishes. In order for the program to <em>move</em> around values, it can transfer ownership to a nested scope or return it to the parent scope. </p>
<p>For temporary transfers (and multiple viewers), Rust has <strong>borrowing</strong>, which creates a reference back to the owned value. However, these references are less powerful, and sometimes more complex to maintain (for example, can the reference outlive the original value?), and they are probably the reason why the compiler complains.</p>
<p>In this recipe, we are getting around this problem by sharing ownership using a reference counter that only drops the variable after the counter reaches zero. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Using <kbd>new sharing-ownership --lib</kbd>, create a new library project and open the directory in your favorite editor. We will also use the <kbd>nightly</kbd> compiler for benchmarks, so running <kbd>rustup default nightly</kbd> is highly recommended.</p>
<p>To enable benchmarks, add <kbd>#![feature(test)]</kbd> to the top of the <kbd>lib.rs</kbd> file.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Understanding shared ownership only requires eight steps:</p>
<ol>
<li>In the fairly young ecosystem that is Rust, APIs and function signatures are not always the most efficient, especially when they require somewhat advanced knowledge of memory layout. So, consider a simple <kbd>length</kbd> function (add it to the <kbd>mod tests</kbd> scope): </li>
</ol>
<pre style="padding-left: 60px">    /// <br/>    /// A length function that takes ownership of the input <br/>    /// variable<br/>    /// <br/>    fn length(s: String) -&gt; usize {<br/>        s.len()<br/>    } </pre>
<p style="padding-left: 60px">While unnecessary, the function requires that you pass your owned variable to the scope. </p>
<p class="mce-root"/>
<ol start="2">
<li>Luckily, the <kbd>clone()</kbd> function is ready for you if you still need ownership after the function call. This is similar to a loop, by the way, where ownership is moved in the first iteration, which means it is <strong>gone</strong> by the second iteration—leading to a compiler error. Let's add a simple test to illustrate these moves:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn cloning() {<br/>        let s = "abcdef".to_owned();<br/>        assert_eq!(length(s), 6);<br/>        // s is now "gone", we can't use it anymore<br/>        // therefore we can't use it in a loop either!<br/>        // ... unless we clone s - at a cost! (see benchmark)<br/>        let s = "abcdef".to_owned();<br/><br/>        for _ in 0..10 {<br/>            // clone is typically an expensive deep copy<br/>            assert_eq!(length(s.clone()), 6);<br/>        }<br/>    }</pre>
<ol start="3">
<li>This works, but creates a lot of clones of a string, only then to drop it shortly after. This leads to wasting resources and, with large enough strings, slows down the program. To establish a baseline, let's check this by adding a benchmark:</li>
</ol>
<pre style="padding-left: 60px"><br/>    extern crate test;<br/>    use std::rc::Rc;<br/>    use test::{black_box, Bencher};<br/><br/>    #[bench]<br/>    fn bench_string_clone(b: &amp;mut Bencher) {<br/>        let s: String = (0..100_000).map(|_| 'a').collect();<br/>        b.iter(|| {<br/>            black_box(length(s.clone()));<br/>        });<br/>    }</pre>
<ol start="4">
<li>Some APIs require ownership of the input variables without a semantic meaning. For example, the <kbd>length</kbd> function from <em>Step 1</em> pretends to require variable ownership, but unless mutability is also necessary, Rust's <kbd>std::rc::Rc</kbd> (short for <strong>Reference Counted</strong>) type is a great choice for avoiding heavyweight cloning or taking away ownership from the calling scope. Let's try it out by creating a better <kbd>length</kbd> function:</li>
</ol>
<pre style="padding-left: 60px"><br/>    ///<br/>    /// The same length function, taking ownership of a Rc<br/>    /// <br/>    fn rc_length(s: Rc&lt;String&gt;) -&gt; usize {<br/>        s.len() // calls to the wrapped object require no additions <br/>    }</pre>
<ol start="5">
<li>We can now continue to use the <kbd>owned</kbd> type after passing it into the function:</li>
</ol>
<pre>     #[test]<br/>    fn refcounting() {<br/>        let s = Rc::new("abcdef".to_owned());<br/>        // we can clone Rc (reference counters) with low cost<br/>        assert_eq!(rc_length(s.clone()), 6);<br/><br/>        for _ in 0..10 {<br/>            // clone is typically an expensive deep copy<br/>            assert_eq!(rc_length(s.clone()), 6);<br/>        }<br/>    }</pre>
<ol start="6">
<li>After we have created a baseline benchmark, we certainly want to know how well the <kbd>Rc</kbd> version fares:</li>
</ol>
<pre style="padding-left: 60px">    #[bench]<br/>    fn bench_string_rc(b: &amp;mut Bencher) {<br/>        let s: String = (0..100_000).map(|_| 'a').collect();<br/>        let rc_s = Rc::new(s);<br/>        b.iter(|| {<br/>            black_box(rc_length(rc_s.clone()));<br/>        });<br/>    }</pre>
<ol start="7">
<li>First, we should check whether the implementations are correct by running <kbd>cargo test</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling sharing-ownership v0.1.0 (Rust-<br/>   Cookbook/Chapter02/sharing-ownership)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.81s<br/>     Running target/debug/deps/sharing_ownership-f029377019c63d62<br/><br/>running 4 tests<br/>test tests::cloning ... ok<br/>test tests::refcounting ... ok<br/>test tests::bench_string_rc ... ok<br/>test tests::bench_string_clone ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests sharing-ownership<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="8">
<li>Now, we can check which variation is faster, and what the differences are:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo bench</strong><br/>   Compiling sharing-ownership v0.1.0 (Rust-<br/>   Cookbook/Chapter02/sharing-ownership)<br/>    Finished release [optimized] target(s) in 0.54s<br/>     Running target/release/deps/sharing_ownership-68bc8eb23caa9948<br/><br/>running 4 tests<br/>test tests::cloning ... ignored<br/>test tests::refcounting ... ignored<br/>test tests::bench_string_clone ... bench: 2,703 ns/iter (+/- 289)<br/>test tests::bench_string_rc ... bench: 1 ns/iter (+/- 0)<br/><br/>test result: ok. 0 passed; 0 failed; 2 ignored; 2 measured; 0 filtered out</pre>
<p><span>After we have explored shared ownership with <kbd>Rc</kbd>, let's go behind the scenes to understand them better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The impressive benchmark results are no accident: <kbd>Rc</kbd> objects are smart pointers to locations on the heap, and while we still call clone to do a <em>deep copy</em>, <kbd>Rc</kbd> only duplicates a pointer and increments the number of references to it. While the actual example function is kept simple so that we don't have to worry about it, it does have all the properties of complex functions we often encounter. We define the first version<span>, which only works with owned memory (the input parameter is not a reference), </span>in <em>Step 1</em>. <em>Steps 2</em> and <em>3</em> show the consequences of the API chosen in <em>Step 1</em>: we need to call the clone function if we want to keep (a copy of) the data we pass in. </p>
<p>In <em>Steps 4</em> to <em>6,</em> we do the equivalent with a Rust construct called <kbd>Rc</kbd>. Having ownership of one of those means that you own the pointer location, but not the actual value, which makes the entire construct very lightweight. In fact, allocating the memory for the original value once and pointing to it from multiple locations is a common way to improve performance in applications that require a lot of moving around of a string. This is a result that can be observed in <em>Steps 7</em> and <em>8</em>, where we execute tests and benchmarks.</p>
<p>One caveat remains. <kbd>Rc</kbd> constructs do not allow for mutable ownership, something that we'll solve in the <span>next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shared mutable ownership</h1>
                </header>
            
            <article>
                
<p>Sharing ownership is great for read-only data. However, mutability is sometimes required, and Rust provides a great way to achieve this. If you recall the rules of ownership and borrowing, if there is a mutable reference, it has to be the only reference to avoid anomalies.</p>
<p>This is typically where the borrow checker comes in: at compile time, it makes sure that the condition holds true. This is where Rust introduces the pattern of interior mutability. By wrapping the data into a <kbd>RefCell</kbd> or <kbd>Cell</kbd>-type object, immutable and mutable access can be handed out dynamically. Let's see how this works in practice. </p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new library project using <kbd>cargo new --lib mut-shared-ownership</kbd> and open <kbd>src/lib.rs</kbd> in your favorite editor. To enable benchmarks, please switch to <kbd>nightly</kbd> Rust using <kbd>rustup default nightly</kbd>, and add <span><kbd>#![feature(test)]</kbd> (which facilitates the use of the types required for benchmark-type tests) at the top of the <kbd>lib.rs</kbd> file. </span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's create a test to establish the best way to share mutable ownership in just a few steps:</p>
<ol>
<li>Let's create a couple of new functions inside the testing module:</li>
</ol>
<pre style="padding-left: 60px">    use std::cell::{Cell, RefCell};<br/>    use std::borrow::Cow;<br/>    use std::ptr::eq;<br/><br/>    fn min_sum_cow(min: i32, v: &amp;mut Cow&lt;[i32]&gt;) {<br/>        let sum: i32 = v.iter().sum();<br/>        if sum &lt; min {<br/>            v.to_mut().push(min - sum);<br/>        }<br/>    }<br/><br/>    fn min_sum_refcell(min: i32, v: &amp;RefCell&lt;Vec&lt;i32&gt;&gt;) {<br/>        let sum: i32 = v.borrow().iter().sum();<br/>        if sum &lt; min {<br/>            v.borrow_mut().push(min - sum);<br/>        }<br/>    }<br/><br/>    fn min_sum_cell(min: i32, v: &amp;Cell&lt;Vec&lt;i32&gt;&gt;) {<br/>        let mut vec = v.take();<br/>        let sum: i32 = vec.iter().sum();<br/>        if sum &lt; min {<br/>            vec.push(min - sum);<br/>        }<br/>        v.set(vec);<br/>    }</pre>
<ol start="2">
<li>These functions dynamically (based on incoming data) mutate a list of integers to fit a particular condition (such as the sum needs to be at least <em>X</em>) and rely on three ways of sharing mutable ownership. Let's explore how these behave on the outside! <kbd>Cell</kbd> objects (and <kbd>RefCell</kbd> objects) are simply wrappers that either return a reference or ownership of a value:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn about_cells() {<br/>        // we allocate memory and use a RefCell to dynamically<br/>        // manage ownership<br/>        let ref_cell = RefCell::new(vec![10, 20, 30]);<br/><br/>        // mutable borrows are fine,<br/>        min_sum_refcell(70, &amp;ref_cell);<br/><br/>        // they are equal!<br/>        assert!(ref_cell.borrow().eq(&amp;vec![10, 20, 30, 10]));<br/><br/>        // cells are a bit different<br/>        let cell = Cell::from(vec![10, 20, 30]);<br/><br/>        // pass the immutable cell into the function<br/>        min_sum_cell(70, &amp;cell);<br/><br/>        // unwrap<br/>        let v = cell.into_inner();<br/><br/>        // check the contents, and they changed!<br/>        assert_eq!(v, vec![10, 20, 30, 10]);<br/>    }</pre>
<ol start="3">
<li>Since this seems very familiar to other programming languages, where references can be passed around freely, we should also know the caveats. One important aspect is that these <kbd>Cell</kbd> threads panic if the borrow check fails, which brings the current thread <span>at least </span>to a sudden halt. In a few lines of code, this is what this looks like:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    #[should_panic]<br/>    fn failing_cells() {<br/>        let ref_cell = RefCell::new(vec![10, 20, 30]);<br/><br/>        // multiple borrows are fine<br/>        let _v = ref_cell.borrow();<br/>        min_sum_refcell(60, &amp;ref_cell);<br/><br/>        // ... until they are mutable borrows<br/>        min_sum_refcell(70, &amp;ref_cell); // panics!<br/>    }</pre>
<ol start="4">
<li>Intuitively, these cells should add runtime overhead and thereby be slower than a regular – precompiled – borrow check. In order to confirm this, let's add a benchmark:</li>
</ol>
<pre style="padding-left: 60px">    extern crate test;<br/>    use test::{ Bencher};<br/><br/>    #[bench]<br/>    fn bench_regular_push(b: &amp;mut Bencher) {<br/>        let mut v = vec![];<br/>        b.iter(|| {<br/>            for _ in 0..1_000 {<br/>                v.push(10);<br/>            }<br/>        });<br/>    }<br/><br/>    #[bench]<br/>    fn bench_refcell_push(b: &amp;mut Bencher) {<br/>        let v = RefCell::new(vec![]);<br/>        b.iter(|| {<br/>            for _ in 0..1_000 {<br/>                v.borrow_mut().push(10);<br/>            }<br/>        });<br/>    }<br/><br/>    #[bench]<br/>    fn bench_cell_push(b: &amp;mut Bencher) {<br/>        let v = Cell::new(vec![]);<br/>        b.iter(|| {<br/>            for _ in 0..1_000 {<br/>                let mut vec = v.take();<br/>                vec.push(10);<br/>                v.set(vec);<br/>            }<br/>        });<br/>    }</pre>
<ol start="5">
<li>However, we did not address the dangers of unforeseen panics in <kbd>Cell</kbd>, which might be prohibitive in complex applications. This is where <kbd>Cow</kbd> comes in. <kbd>Cow</kbd> is a <strong>Copy-on-Write</strong> type that <span>replaces the value it wraps by</span> lazily cloning if mutable access is requested. By using this <kbd>struct</kbd>, we can be certain to avoid panics<span> with this code</span>:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn handling_cows() {<br/>        let v = vec![10, 20, 30];<br/><br/>        let mut cow = Cow::from(&amp;v);<br/>        assert!(eq(&amp;v[..], &amp;*cow));<br/><br/>        min_sum_cow(70, &amp;mut cow);<br/><br/>        assert_eq!(v, vec![10, 20, 30]);<br/>        assert_eq!(cow, vec![10, 20, 30, 10]);<br/>        assert!(!eq(&amp;v[..], &amp;*cow));<br/><br/>        let v2 = cow.into_owned();<br/><br/>        let mut cow2 = Cow::from(&amp;v2);<br/>        min_sum_cow(70, &amp;mut cow2);<br/><br/>        assert_eq!(cow2, v2);<br/>        assert!(eq(&amp;v2[..], &amp;*cow2));<br/>    }</pre>
<ol start="6">
<li>Lastly, let's verify that the tests and benchmarks are successful by running <kbd>cargo test</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling mut-sharing-ownership v0.1.0 (Rust-<br/>   Cookbook/Chapter02/mut-sharing-ownership)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.81s<br/>     Running target/debug/deps/mut_sharing_ownership-<br/>     d086077040f0bd34<br/><br/>running 6 tests<br/>test tests::about_cells ... ok<br/>test tests::bench_cell_push ... ok<br/>test tests::bench_refcell_push ... ok<br/>test tests::failing_cells ... ok<br/>test tests::handling_cows ... ok<br/>test tests::bench_regular_push ... ok<br/><br/>test result: ok. 6 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests mut-sharing-ownership<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<ol start="7">
<li>Let's see the benchmark timings in the output of <span><kbd>cargo bench</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo bench</strong><br/>    Finished release [optimized] target(s) in 0.02s<br/>     Running target/release/deps/mut_sharing_ownership-<br/>     61f1f68a32def1a8<br/><br/>running 6 tests<br/>test tests::about_cells ... ignored<br/>test tests::failing_cells ... ignored<br/>test tests::handling_cows ... ignored<br/>test tests::bench_cell_push ... bench: 10,352 ns/iter (+/- 595)<br/>test tests::bench_refcell_push ... bench: 3,141 ns/iter (+/- 6,389)<br/>test tests::bench_regular_push ... bench: 3,341 ns/iter (+/- 124)<br/><br/>test result: ok. 0 passed; 0 failed; 3 ignored; 3 measured; 0 filtered out</pre>
<p><span>Sharing memory in various ways is complex, so let's dive deeper into how they work.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This recipe is set up like a large benchmark or testing scheme: in <em>Step 1</em>, we define the functions to be tested, each with different input parameters, but the same behavior; it fills <kbd>Vec</kbd> up to a minimum sum. These parameters reflect different ways of sharing ownership, including <kbd>RefCell</kbd>, <kbd>Cell</kbd>, and <kbd>Cow</kbd>. </p>
<p><em>Steps 2</em> and <em>3</em> create tests that work exclusively on the different ways adopted by <kbd>RefCell</kbd> and <kbd>Cell</kbd> of handling and failing these values. <em>Step 5</em> does something similar to the <kbd>Cow</kbd> type; all are great opportunities to test out your own theories as well! </p>
<p>In <em>Steps 4</em> and <em>6</em>, we are creating and running benchmarks and tests on the functions we created in this recipe. The results are surprising. In fact, we tried different computers and versions and arrived at the same conclusion: <kbd>RefCell</kbd> is almost as fast as the regular way of retrieving a mutable reference (the runtime behavior results in a higher variance). The <kbd>Cell</kbd> parameter's slowdown is also expected; they move the entire data in and out at every iteration—and this is what we can also expect from <kbd>Cow</kbd>, so feel free to try it out yourself. </p>
<p>Both <kbd>Cell</kbd> objects and <kbd>RefCell</kbd> objects move the data onto the heap memory and use references (pointers) to get to these values, often requiring an extra jump. However, they offer a similar way of moving object references around with the comfort of C#, Java, or other such languages.</p>
<p><span>We hope you have successfully learned about shared mutable ownership. Now, let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Referencing with explicit lifetimes</h1>
                </header>
            
            <article>
                
<p>Lifetimes are common in many languages and typically decide whether a variable is available outside the scope. In Rust, the situation is a bit more complicated thanks to the borrowing and ownership model that extensively uses lifetimes and scopes to automatically manage memory. Instead of reserving memory and cloning stuff into it, we developers want to avoid the inefficiencies and potential slowdowns this causes with references. However, this leads down a tricky path because, as the original value goes out of scope, what happens to the reference? </p>
<p>Since the compiler cannot infer this information from code, you have to help it and annotate the code so it can go and check for proper usage. Let's see what this looks like.</p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">Lifetimes can be explored in a few steps:</p>
<ol>
<li><span>Create a new project using </span><kbd>cargo new lifetimes --lib</kbd><span> and open it in your favorite editor.</span></li>
<li>Let's start with a simple function that takes in a reference that might not outlive the function! Let's make sure that the function and the input parameter are on the same lifetime:</li>
</ol>
<pre style="padding-left: 60px">// declaring a lifetime is optional here, since the compiler automates this<br/><br/>///<br/>/// Compute the arithmetic mean<br/>/// <br/>pub fn mean&lt;'a&gt;(numbers: &amp;'a [f32]) -&gt; Option&lt;f32&gt; {<br/>    if numbers.len() &gt; 0 {<br/>        let sum: f32 = numbers.iter().sum();<br/>        Some(sum / numbers.len() as f32)<br/>    } else {<br/>        None<br/>    }<br/>} </pre>
<ol start="3">
<li>Where the lifetime declaration is required is in structs. Therefore, we define the base <kbd>struct</kbd> first. It comes with a lifetime annotation for the type it contains:</li>
</ol>
<pre style="padding-left: 60px">///<br/>/// Our almost generic statistics toolkit<br/>/// <br/>pub struct StatisticsToolkit&lt;'a&gt; {<br/>    base: &amp;'a [f64],<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>What follows is the implementation, which continues the lifetime specifications. First, we implement the constructor (<kbd>new()</kbd>):</li>
</ol>
<pre style="padding-left: 120px">impl&lt;'a&gt; StatisticsToolkit&lt;'a&gt; {<br/><br/>    pub fn new(base: &amp;'a [f64]) -&gt; <br/>     Option&lt;StatisticsToolkit&gt; {<br/>        if base.len() &lt; 3 {<br/>            None<br/>        } else {<br/>            Some(StatisticsToolkit { base: base })<br/>        }<br/>    }</pre>
<p style="padding-left: 60px">Then, we want to implement the variance calculation along with the standard deviation and the mean:</p>
<pre style="padding-left: 120px">    pub fn var(&amp;self) -&gt; f64 {<br/>        let mean = self.mean();<br/><br/>        let ssq: f64 = self.base.iter().map(|i| (i - <br/>        mean).powi(2)).sum();<br/>        return ssq / self.base.len() as f64;<br/>    }<br/><br/>    pub fn std(&amp;self) -&gt; f64 {<br/>        self.var().sqrt()<br/>    }<br/><br/>    pub fn mean(&amp;self) -&gt; f64 {<br/>        let sum: f64 = self.base.iter().sum();<br/><br/>        sum / self.base.len() as f64<br/>    }</pre>
<p style="padding-left: 60px">As a final operation, we add the median calculation:</p>
<pre style="padding-left: 120px">    pub fn median(&amp;self) -&gt; f64 {<br/>        let mut clone = self.base.to_vec();<br/><br/>        // .sort() is not implemented for floats<br/>        clone.sort_by(|a, b| a.partial_cmp(b).unwrap()); <br/><br/>        let m = clone.len() / 2;<br/>        if clone.len() % 2 == 0 {<br/>            clone[m]<br/>        } else {<br/>            (clone[m] + clone[m - 1]) / 2.0<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li>And that's it! Some tests are required so that we can be certain everything works as expected. Let's start with a few helper functions and a test for calculating the mean:</li>
</ol>
<pre style="padding-left: 120px">#[cfg(test)]<br/>mod tests {<br/><br/>    use super::*;<br/><br/>    ///<br/>    /// a normal distribution created with numpy, with mu = <br/>    /// 42 and <br/>    /// sigma = 3.14 <br/>    /// <br/>    fn numpy_normal_distribution() -&gt; Vec&lt;f64&gt; {<br/>        vec![<br/>            43.67221552, 46.40865622, 43.44603147, <br/>            43.16162571, <br/>            40.94815816, 44.585914 , 45.84833022, <br/>            37.77765835, <br/>            40.23715928, 48.08791899, 44.80964938, <br/>            42.13753315, <br/>            38.80713956, 39.16183586, 42.61511209, <br/>            42.25099062, <br/>            41.2240736 , 44.59644304, 41.27516889, <br/>            36.21238554<br/>        ]<br/>    }<br/><br/>    #[test]<br/>    fn mean_tests() {<br/>        // testing some aspects of the mean function<br/>        assert_eq!(mean(&amp;vec![1.0, 2.0, 3.0]), Some(2.0));<br/>        assert_eq!(mean(&amp;vec![]), None);<br/>        assert_eq!(mean(&amp;vec![0.0, 0.0, 0.0, 0.0, 0.0, 0.0, <br/>        0.0]), <br/>        Some(0.0));<br/>    }</pre>
<p style="padding-left: 60px">Then, we perform some testing on the new function:</p>
<pre style="padding-left: 120px">    #[test]<br/>    fn statisticstoolkit_new() {<br/>        // require &gt;= 3 elements in an array for a <br/>        // plausible normal distribution<br/>        assert!(StatisticsToolkit::new(&amp;vec![]).is_none());<br/>        assert!(StatisticsToolkit::new(&amp;vec![2.0, <br/>         2.0]).is_none());<br/><br/>        // a working example<br/>        assert!(StatisticsToolkit::new(&amp;vec![1.0, 2.0, <br/>         1.0]).is_some());<br/><br/>        // not a normal distribution, but we don't mind<br/>        assert!(StatisticsToolkit::new(&amp;vec![2.0, 1.0, <br/>         2.0]).is_some());<br/>    }</pre>
<p style="padding-left: 60px">Next, let's test the actual statistics. In a single function, we are starting with some special input data:</p>
<pre style="padding-left: 120px">    #[test]<br/>    fn statisticstoolkit_statistics() {<br/>         // simple best case test<br/>        let a_sample = vec![1.0, 2.0, 1.0];<br/>        let nd = StatisticsToolkit::<br/>         new(&amp;a_sample).unwrap();<br/>        assert_eq!(nd.var(), 0.2222222222222222);<br/>        assert_eq!(nd.std(), 0.4714045207910317);<br/>        assert_eq!(nd.mean(), 1.3333333333333333);<br/>        assert_eq!(nd.median(), 1.0);<br/><br/>        // no variance<br/>        let a_sample = vec![1.0, 1.0, 1.0];<br/>        let nd = StatisticsToolkit::<br/>         new(&amp;a_sample).unwrap();<br/>        assert_eq!(nd.var(), 0.0);<br/>        assert_eq!(nd.std(), 0.0);<br/>        assert_eq!(nd.mean(), 1.0);<br/>        assert_eq!(nd.median(), 1.0);</pre>
<p style="padding-left: 60px">In order to check more sophisticated input data (for example, skewed distributions or edge cases), let's expand the test further:</p>
<pre style="padding-left: 120px">        // double check with a real library<br/>        let a_sample = numpy_normal_distribution();<br/>        let nd = <br/>         StatisticsToolkit::new(&amp;a_sample).unwrap();<br/>        assert_eq!(nd.var(), 8.580276516670548);<br/>        assert_eq!(nd.std(), 2.9292109034124785);<br/>        assert_eq!(nd.mean(), 42.36319998250001);<br/>        assert_eq!(nd.median(), 42.61511209);<br/><br/><br/>        // skewed distribution<br/>        let a_sample = vec![1.0, 1.0, 5.0];<br/>        let nd = <br/>         StatisticsToolkit::new(&amp;a_sample).unwrap();<br/>        assert_eq!(nd.var(), 3.555555555555556);<br/>        assert_eq!(nd.std(), 1.8856180831641267);<br/>        assert_eq!(nd.mean(), 2.3333333333333335);<br/>        assert_eq!(nd.median(), 1.0);<br/><br/>        // median with even collection length<br/>        let a_sample = vec![1.0, 2.0, 3.0, 4.0] ;<br/>        let nd = <br/>         StatisticsToolkit::new(&amp;a_sample).unwrap();<br/>        assert_eq!(nd.var(), 1.25);<br/>        assert_eq!(nd.std(), 1.118033988749895);<br/>        assert_eq!(nd.mean(), 2.5);<br/>        assert_eq!(nd.median(), 3.0);<br/>    }<br/>}</pre>
<ol start="6">
<li>Use <kbd>cargo test</kbd> to run the tests and verify that they are successful:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling lifetimes v0.1.0 (Rust-Cookbook/Chapter02/lifetimes)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 1.16s<br/>     Running target/debug/deps/lifetimes-69291f4a8f0af715<br/><br/>running 3 tests<br/>test tests::mean_tests ... ok<br/>test tests::statisticstoolkit_new ... ok<br/>test tests::statisticstoolkit_statistics ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests lifetimes<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p><span>Working with lifetimes is complex, so let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we created a simple statistics toolbox that allows normal distribution samples to be analyzed quickly and accurately. However, this example was only chosen to illustrate the ways of how lifetimes are useful and comparatively simple. In <em>Step 2</em>, we are creating a function to calculate the mean of a given collection. Since lifetimes can be inferred from using the functions/variables, explicit specification of the lifetime is optional. Nevertheless, the function explicitly ties the input parameter's lifetime to the function's lifetime, requiring any reference that is passed in to outlive <kbd>mean()</kbd>.</p>
<p><em>Steps 3</em> and <em>4</em> show how to deal with lifetimes in structs and their implementations. Since type instances can easily outlive the references they store (and each could even require a different lifetime), the explicit specification of the lifetimes becomes necessary. The lifetimes have to be stated every step of the way; in the struct declaration, in the <kbd>impl</kbd> block, and in the functions they are used with. The lifetime's name binds them together. In a way, it creates a virtual scope bound to the type instance's life. </p>
<p>Lifetime annotations are useful but verbose, which makes working with references sometimes cumbersome. However, once the annotations are in place, the program can be much more efficient and the interfaces can be a lot more convenient, removing <kbd>clone()</kbd> method and other things. </p>
<p>The choice for the lifetime name (<kbd>'a</kbd>) is common, but arbitrary. Other than the predefined <kbd>'static</kbd>, every word works just as fine and a readable choice is definitely better.</p>
<p><span>Working with explicit lifetimes was not too hard, right? We recommend that you keep on experimenting until you are ready to move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enforcing behavior with trait bounds</h1>
                </header>
            
            <article>
                
<p>When building a complex architecture, prerequisite behavior is very common. In Rust, this means that we cannot build either generic or other types without requiring them to conform to some prior behavior, or, in other words, we need to be able to specify which traits are required. Trait bounds are one way of doing that – and you have seen multiple instances of this already, even if you have skipped many recipes so far. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Follow these steps to learn more about traits:</p>
<ol>
<li><span>Create a new project using </span><kbd>cargo new trait-bounds</kbd><span> and open it in your favorite editor.</span></li>
<li>Edit <kbd>src/main.rs</kbd> to add the following code, where we can easily print a variable's debug format since an implementation of that format is required on compilation:</li>
</ol>
<pre style="padding-left: 60px">///<br/>/// A simple print function for printing debug formatted variables<br/>/// <br/>fn log_debug&lt;T: Debug&gt;(t: T) {<br/>    println!("{:?}", t);<br/>}</pre>
<ol start="3">
<li>If we were to call this using a custom type such as <kbd>struct AnotherType(usize)</kbd>, the compiler would quickly complain:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling trait-bounds v0.1.0 (Rust-Cookbook/Chapter02/trait-bounds)<br/>error[E0277]: `AnotherType` doesn't implement `std::fmt::Debug`<br/>  --&gt; src/main.rs:35:5<br/>   |<br/>35 | log_debug(b);<br/>   | ^^^^^^^^^ `AnotherType` cannot be formatted using `{:?}`<br/>   |<br/>   = help: the trait `std::fmt::Debug` is not implemented for `AnotherType`<br/>   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`<br/>note: required by `log_debug`<br/>  --&gt; src/main.rs:11:1<br/>   |<br/>11 | fn log_debug&lt;T: Debug&gt;(t: T) {<br/>   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/><br/>error: aborting due to previous error<br/><br/>For more information about this error, try `rustc --explain E0277`.<br/>error: Could not compile `trait-bounds`.<br/><br/>To learn more, run the command again with --verbose.</pre>
<ol start="4">
<li>In order to fix this, we can either implement or derive the <kbd>Debug</kbd> trait, as it says in the error message. Deriving the implementation is very common for compositions of standard types. In traits, the trait bounds get a bit more interesting:</li>
</ol>
<pre style="padding-left: 60px">///<br/>/// An interface that can be used for quick and easy logging<br/>/// <br/>pub trait Loggable: Debug + Sized {<br/>    fn log(self) {<br/>        println!("{:?}", &amp;self)<br/>    }<br/>}</pre>
<ol start="5">
<li>We can then create and implement a suitable type:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Debug)]<br/>struct ArbitraryType {<br/>    v: Vec&lt;i32&gt;<br/>}<br/><br/>impl ArbitraryType {<br/>    pub fn new() -&gt; ArbitraryType {<br/>        ArbitraryType {<br/>            v: vec![1,2,3,4]<br/>        }<br/>    }<br/>}<br/>impl Loggable for ArbitraryType {}</pre>
<ol start="6">
<li>Next, let's tie the code together in the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    let a = ArbitraryType::new();<br/>    a.log();<br/>    let b = AnotherType(2);<br/>    log_debug(b);<br/>}</pre>
<ol start="7">
<li>Execute <kbd>cargo run</kbd> and establish whether the output matches your expectations:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling trait-bounds v0.1.0 (Rust-Cookbook/Chapter02/trait-<br/>   bounds)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.38s<br/>     Running `target/debug/trait-bounds`<br/>     ArbitraryType { v: [1, 2, 3, 4] }<br/>     AnotherType(2)</pre>
<p><span>After creating an example program, let's explore the background for trait bounds.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Trait bounds specify the requirements of the implementation to implementers. In this way, we can call functions on generic types without having a more in-depth knowledge of their structures. </p>
<p>In <em>Step 2</em>, we require any parameter type to implement the <kbd>std::fmt::Debug</kbd> trait in order to be able to use the debug formatter for printing. However, that does not generalize well, and we have to require that implementation for any <em>other</em> function as well. That's why, in <em>Step 4</em>, we require that any type that implements the <kbd>Loggable</kbd> <span>trait </span>also implements <kbd>Debug</kbd>. </p>
<p>As a result, we can expect to use all the required traits in the trait's functions, which makes expansion easier and provides the ability for all types to implement the trait to be compatible. In <em>Step 5</em> , we are implementing the <kbd>Loggable</kbd> trait for the type we created and using it in the remainder of the steps. </p>
<p><span>Decisions regarding the required traits are important for public APIs as well as for writing well-designed and maintainable code. Being mindful of what types are really required and how to provide them will lead to better interfaces and types. Notice also the</span> <kbd>+</kbd> <span>between two type bounds; it requires both (and more if more</span> <kbd>+</kbd> symbols <span>are added) traits to be present when implementing</span> <kbd>Loggable</kbd><span>. </span></p>
<p><span>We've successfully learned how to enforce behavior with trait bounds. Now, let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with generic data types</h1>
                </header>
            
            <article>
                
<p>Rust's function overloading is a bit more exotic than in other languages. Instead of redefining the same function with a different type signature, you can achieve the same result by specifying the actual types for a generic implementation. Generics are a great way to provide more general interfaces and are not too complex to implement thanks to helpful compiler messages.</p>
<p><span>In this recipe, we are going to implement a dynamic array (such as </span><kbd>Vec&lt;T&gt;</kbd><span>) in a generic way.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Learn how to use generics in just a few steps:</p>
<ol>
<li><span> Start off by creating a new library project with </span><kbd>cargo new generics --lib</kbd><span> and open the project folder in Visual Studio Code. </span></li>
<li>A dynamic array is a data structure many of you will use every day. In Rust, the implementation is called <kbd>Vec&lt;T&gt;</kbd><span>, while other languages know it as</span> <kbd>ArrayList</kbd> <span>or</span> <kbd>List</kbd><span>. First, let's establish the basic structure:</span></li>
</ol>
<pre style="padding-left: 60px">use std::boxed::Box;<br/>use std::cmp;<br/>use std::ops::Index;<br/><br/>const MIN_SIZE: usize = 10;<br/><br/>type Node&lt;T&gt; = Option&lt;T&gt;;<br/><br/>pub struct DynamicArray&lt;T&gt;<br/>where<br/>    T: Sized + Clone,<br/>{<br/>    buf: Box&lt;[Node&lt;T&gt;]&gt;,<br/>    cap: usize,<br/>    pub length: usize,<br/>}</pre>
<ol start="3">
<li>As the <kbd>struct</kbd> definition shows, the main element is a box of type <kbd>T</kbd>, a generic type. Let's see what the implementation looks like:</li>
</ol>
<pre style="padding-left: 60px">impl&lt;T&gt; DynamicArray&lt;T&gt;<br/>where<br/>    T: Sized + Clone,<br/>{<br/>    pub fn new_empty() -&gt; DynamicArray&lt;T&gt; {<br/>        DynamicArray {<br/>            buf: vec![None; MIN_SIZE].into_boxed_slice(),<br/>            length: 0,<br/>            cap: MIN_SIZE,<br/>        }<br/>    }<br/><br/>    fn grow(&amp;mut self, min_cap: usize) {<br/>        let old_cap = self.buf.len();<br/>        let mut new_cap = old_cap + (old_cap &gt;&gt; 1);<br/><br/>        new_cap = cmp::max(new_cap, min_cap);<br/>        new_cap = cmp::min(new_cap, usize::max_value());<br/>        let current = self.buf.clone();<br/>        self.cap = new_cap;<br/><br/>        self.buf = vec![None; new_cap].into_boxed_slice();<br/>        self.buf[..current.len()].clone_from_slice(&amp;current);<br/>    }<br/><br/>    pub fn append(&amp;mut self, value: T) {<br/>        if self.length == self.cap {<br/>            self.grow(self.length + 1);<br/>        }<br/>        self.buf[self.length] = Some(value);<br/>        self.length += 1;<br/>    }<br/><br/>    pub fn at(&amp;mut self, index: usize) -&gt; Node&lt;T&gt; {<br/>        if self.length &gt; index {<br/>            self.buf[index].clone()<br/>        } else {<br/>            None<br/>        }<br/>    }<br/>}</pre>
<ol start="4">
<li>So far, very straightforward. Instead of a type name, we'll simply use <kbd>T</kbd>. What happens if we wanted to implement a specific type for a generic definition? Let's implement the <kbd>Index</kbd> operation (a trait in Rust) for the <kbd>usize</kbd> <span>type. </span>Additionally, a <kbd>clone</kbd> operation will become very helpful in the future, so let's add that too:</li>
</ol>
<pre style="padding-left: 60px">impl&lt;T&gt; Index&lt;usize&gt; for DynamicArray&lt;T&gt;<br/>where<br/>    T: Sized + Clone,<br/>{<br/>    type Output = Node&lt;T&gt;;<br/><br/>    fn index(&amp;self, index: usize) -&gt; &amp;Self::Output {<br/>        if self.length &gt; index {<br/>            &amp;self.buf[index]<br/>        } else {<br/>            &amp;None<br/>        }<br/>    }<br/>}<br/><br/>impl&lt;T&gt; Clone for DynamicArray&lt;T&gt;<br/>where<br/>    T: Sized + Clone,<br/>{<br/>    fn clone(&amp;self) -&gt; Self {<br/>        DynamicArray {<br/>            buf: self.buf.clone(),<br/>            cap: self.cap,<br/>            length: self.length,<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li>In order to be certain that all of this works and we did not make any mistakes, let's start with a few tests for each implemented function:</li>
</ol>
<pre style="padding-left: 60px"><br/>#[cfg(test)]<br/>mod tests {<br/>    use super::*;<br/><br/>    #[test]<br/>    fn dynamic_array_clone() {<br/>        let mut list = DynamicArray::new_empty();<br/>        list.append(3.14);<br/>        let mut list2 = list.clone();<br/>        list2.append(42.0);<br/>        assert_eq!(list[0], Some(3.14));<br/>        assert_eq!(list[1], None);<br/>        <br/>        assert_eq!(list2[0], Some(3.14));<br/>        assert_eq!(list2[1], Some(42.0));<br/>    }<br/><br/>    #[test]<br/>    fn dynamic_array_index() {<br/>        let mut list = DynamicArray::new_empty();<br/>        list.append(3.14);<br/><br/>        assert_eq!(list[0], Some(3.14));<br/>        let mut list = DynamicArray::new_empty();<br/>        list.append("Hello");<br/>        assert_eq!(list[0], Some("Hello"));<br/>        assert_eq!(list[1], None);<br/>    }</pre>
<p style="padding-left: 60px">Now, let's add some more tests:</p>
<pre style="padding-left: 60px">    #[test]<br/>    fn dynamic_array_2d_array() {<br/>        let mut list = DynamicArray::new_empty();<br/>        let mut sublist = DynamicArray::new_empty();<br/>        sublist.append(3.14);<br/>        list.append(sublist);<br/><br/>        assert_eq!(list.at(0).unwrap().at(0), Some(3.14));<br/>        assert_eq!(list[0].as_ref().unwrap()[0], Some(3.14));<br/><br/>    }<br/><br/>    #[test]<br/>    fn dynamic_array_append() {<br/>        let mut list = DynamicArray::new_empty();<br/>        let max: usize = 1_000;<br/>        for i in 0..max {<br/>            list.append(i as u64);<br/>        }<br/>        assert_eq!(list.length, max);<br/>    }<br/><br/>    #[test]<br/>    fn dynamic_array_at() {<br/>        let mut list = DynamicArray::new_empty();<br/>        let max: usize = 1_000;<br/>        for i in 0..max {<br/>            list.append(i as u64);<br/>        }<br/>        assert_eq!(list.length, max);<br/>        for i in 0..max {<br/>            assert_eq!(list.at(i), Some(i as u64));<br/>        }<br/>        assert_eq!(list.at(max + 1), None);<br/>    }<br/>}</pre>
<ol start="6">
<li>Once the tests are implemented, we can run the tests successfully with <kbd>cargo test</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling generics v0.1.0 (Rust-Cookbook/Chapter02/generics)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.82s<br/>     Running target/debug/deps/generics-0c9bbd42843c67d5<br/><br/>running 5 tests<br/>test tests::dynamic_array_2d_array ... ok<br/>test tests::dynamic_array_index ... ok<br/>test tests::dynamic_array_append ... ok<br/>test tests::dynamic_array_clone ... ok<br/>test tests::dynamic_array_at ... ok<br/><br/>test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests generics<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p><span>Now, let's look at using generics from behind the scenes.</span></p>


            </article>

            
        </section>
    </div>
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Generics work very well in Rust and, other than the verbose notation, they are very handy. In fact, you will find them all over the place and, as you progress in Rust, the need for better, more generic interfaces will increase.</p>
<p>In <em>S<span>tep 2</span></em><span>, we are creating a modified dynamic array (</span><span>taken from the book</span> <em>Hand</em><em>s-On Data Structures and Algorithms with Rust:</em> <a href="https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-rust">https://www.packtpub.com/application-development/hands-data-structures-and-algorithms-<em>rust</em></a><span>) that uses a generic type. </span><span>Using a generic type in code works like any other type, writing</span> <kbd>T</kbd> <span>instead of</span> <kbd>i32</kbd><span>. However, as discussed in a previous recipe, the compiler expects certain behaviors from the</span> <kbd>T</kbd><span> type, such as implementing </span><kbd>Clone</kbd><span>, which is specified in the</span> <kbd>where</kbd> <span>clause of the struct and implementation. In more complex use cases, there could be multiple blocks for when</span> <kbd>T</kbd> <span>implements</span> <kbd>Clone</kbd> <span>and when it doesn't, but that would go beyond the scope of the recipe. <em>Step 3</em> shows the generic implementation of the dynamic array type and how the</span> <kbd>Clone</kbd> <span>and</span> <kbd>Sized</kbd> <span>traits come into play. </span></p>
<p>When implementing the <kbd>Index</kbd> trait in <em>Step 4</em>, something becomes more obvious. First, we specify the <kbd>usize</kbd> type for the trait implementation header. Therefore, this trait is only implemented if someone uses a <kbd>usize</kbd> variable (or constant/literal) for indexing, thereby ruling out any negative values. The second aspect is the associated type, which, in itself, has a generic type. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Another important aspect of generics is the term <kbd>Sized</kbd>. Variables in Rust are <kbd>Sized</kbd> when the size is known at compile time, so the compiler knows how much memory to allocate. Unsized types have an unknown size at compile time; that is, they are dynamically allocated and may grow at runtime. Examples include <kbd>str</kbd>, or slices of type <kbd>[T]</kbd>. Their actual size can change, which is why they are always behind a fixed-size reference, a pointer. If <kbd>Sized</kbd> is required, only the reference to an unsized type can be used (<kbd>&amp;str</kbd>, <kbd>&amp;[T]</kbd>), but there is also <kbd>?Sized</kbd> to make this behavior optional.</p>
<p><em>Steps 5</em> and <em>6</em> then create some tests and run them. The tests demonstrate that the main functions of the dynamic array continue to work, and we encourage you to try out any questions you have about the code in there as well.</p>
<p>If you want more details on the dynamic array and why/how it grows (it doubles in size, like Java's <kbd>ArrayList</kbd>), check out <em>Hands-On Data Structures and Algorithms with Rust</em>, where this dynamic array and other data structures are explained in more detail. </p>


            </article>

            
        </section>
    </div></body></html>