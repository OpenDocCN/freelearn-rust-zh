["```rs\n        requirements=[\n            \"pyyaml>=3.13\"\n        ]\n    ```", "```rs\n        entry_points={\n            'console_scripts': [\n                'fib-number = flitton_fib_rs.'\n                'fib_number_command:'\n                'fib_number_command',\n                'config-fib = flitton_fib_rs.'\n                'config_number_command:'\n                'config_number_command',\n            ],\n        },\n    ```", "```rs\n    import argparse\n    import yaml\n    import os\n    from pprint import pprint\n    from .flitton_fib_rs import run_config\n    ```", "```rs\n    def config_number_command() -> None:\n        parser = argparse.ArgumentParser(\n            description='Calculate Fibonacci numbers '\n                        'using a config file')\n        parser.add_argument('--path', action='store',\n                            type=str, required=True,\n                            help=\"path to config file\")\n        args = parser.parse_args()\n    ```", "```rs\n        with open(str(os.getcwd()) + \"/\" + args.path) as \\\n          f:\n            config_data: dict = yaml.safe_load(f)\n    ```", "```rs\n        print(\"Here is the config data: \")\n        pprint(config_data)\n        print(f\"Here is the result:\")\n        pprint(run_config(config_data))\n    ```", "```rs\n    ├── fib_calcs\n    │   ├── fib_number.rs\n    │   ├── fib_numbers.rs\n    │   └── mod.rs\n    ├── interface\n    │   ├── config.rs\n    │   └── mod.rs\n    ├── lib.rs\n    └── main.rs\n    ```", "```rs\n    use pyo3::prelude::{pyfunction, PyResult};\n    use pyo3::types::{PyDict, PyList};\n    use pyo3::exceptions::PyTypeError;\n    use crate::fib_calcs::fib_number::fibonacci_number;\n    use crate::fib_calcs::fib_numbers::fibonacci_numbers;\n    ```", "```rs\n    fn process_numbers(input_numbers: Vec<Vec<i32>>) \\\n        -> Vec<Vec<u64>> {\n        let mut buffer: Vec<Vec<u64>> = Vec::new();\n        for i in input_numbers {\n            buffer.push(fibonacci_numbers(i));\n        }\n        return buffer\n    }\n    ```", "```rs\n    #[pyfunction]\n    pub fn run_config<'a>(config: &'a PyDict) \\\n        -> PyResult<&'a PyDict> {\n    ```", "```rs\n        match config.get_item(\"number\") {\n            Some(data) => {\n                . . .\n            },\n            None => println!(\n            \"parameter number is not in the config\"\n            )\n        }\n    ```", "```rs\n                match data.downcast::<PyList>() {\n                    Ok(raw_data) => {\n                        . . .\n                    },\n                    Err(_) => Err(PyTypeError::new_err(\n                        \"parameter number is not a list \n                        of integers\")).unwrap()\n                }\n    ```", "```rs\n                        let processed_results: Vec<i32> = \n                  raw_data.extract::<Vec<i32>>().unwrap();\n                        let fib_numbers: Vec<u64> = \n                        processed_results.iter().map(\n                            |x| fibonacci_number(*x)\n                        ).collect();\n                        config.set_item(\n                        \"NUMBER RESULT\", fib_numbers);\n    ```", "```rs\n        match config.get_item(\"numbers\") {\n            Some(data) => {\n                match data.downcast::<PyList>() {\n                    Ok(raw_data) => {\n                        let processed_results_two: \\\n                          Vec<Vec<i32>> = \n                        raw_data.extract::<Vec<Vec<i32>>>(\n                        ).unwrap();\n                        config.set_item(\"NUMBERS RESULT\", \n                        process_numbers(processed \\\n                          _results_two));\n                    },\n                    Err(_) => Err(PyTypeError::new_err(\n                    \"parameter numbers is not a list of \\\n                       lists of integers\")).unwrap()\n                }\n            },\n            None => println!(\n            \"parameter numbers is not in the config\")\n        }\n        return Ok(config)\n    ```", "```rs\n    pub mod config;\n    ```", "```rs\n    mod interface;\n    use interface::config::__pyo3_get_function_run_config;\n    ```", "```rs\n    m.add_wrapped(wrap_pyfunction!(run_config));\n    ```", "```rs\n    number:\n      - 4\n      - 7\n      - 2\n    numbers:\n      -\n        - 12\n        - 15\n        - 20\n      -\n        - 15\n        - 19\n        - 18\n    ```", "```rs\n    config-fib --path example.yml\n    ```", "```rs\n    Here is the config data: \n    {'number': [4, 7, 2, 10, 15],\n     'numbers': [[5, 8, 12, 15, 20], [12, 15, 19, 18, 8]]}\n    Here is the result:\n    {'NUMBER RESULT': [3, 13, 1, 55, 610],\n     'NUMBERS RESULT': [[5, 21, 144, 610, 6765], \n                        [144, 610, 4181, 2584, 21]],\n     'number': [4, 7, 2, 10, 15],\n     'numbers': [[5, 8, 12, 15, 20], [12, 15, 19, 18, 8]]}\n    ```", "```rs\n    number:\n      one: 1\n    ```", "```rs\n    TypeError exception was raised. This is not trivial. This means that we can try to accept type errors in our Python code when using our Rust module if we need to. Considering this, if a user did not know how our module was built, they would have no problem thinking that our module was built in pure Python. There is one more test that we can consider. We only manually threw an error when we were downcasting to PyList, highlighting that we need to have a list of integers. However, we just unwrapped the extract function being performed on PyList. \n    ```", "```rs\n    number:\n      - \"test\"\n    ```", "```rs\n    pyo3_runtime.PanicException: called 'Result:: \\\n      unwrap()' on an \n    'Err' value: PyErr { type: <class 'TypeError'>, \n    value: TypeError(\n    \"'str' object cannot be interpreted as an integer\"), \n    traceback: None }\n    ```", "```rs\n    from typing import List, Optional\n    from .flitton_fib_rs import object_interface\n    ```", "```rs\n    class ObjectInterface:\n        def __init__(self, number: List[int], \\ \n           numbers: List[List[int]]) -> None:\n            self.number: List[int] = number\n            self.numbers: List[List[int]] = numbers\n            self.number_results: Optional[List[int]] = \\\n              None\n            self.numbers_results:Optional[List[List \\\n              [int]]] = None\n    ```", "```rs\n        def process(self) -> None:\n            object_interface(self)\n    ```", "```rs\n    use pyo3::prelude::{pyfunction, PyResult, Python};\n    use pyo3::types::{PyAny, PyDict};\n    use pyo3::exceptions::PyLookupError;\n    use super::config::run_config;\n    ```", "```rs\n    #[pyfunction]\n    pub fn object_interface<'a>(input_object: &'a PyAny) \\\n        -> PyResult<&'a PyAny> {\n        let gil = Python::acquire_gil();\n        let py = gil.python();\n        let config_dict: &PyDict = PyDict::new(py);\n    ```", "```rs\n        match input_object.getattr(\"number\") {\n            Ok(data) => {\n                config_dict.set_item(\"number\", data) \\\n                  .unwrap();\n            },\n            Err(_) => Err(PyLookupError::new_err(\n                \"attribute number is missing\")).unwrap()\n        }\n    ```", "```rs\n        match input_object.getattr(\"numbers\") {\n            Ok(data) => {\n                config_dict.set_item(\"numbers\", data) \\\n                  .unwrap();\n            }\n            Err(_) => Err(PyLookupError::new_err(\n                \"attribute numbers is missing\")).unwrap()\n        }\n    ```", "```rs\n    fn extract_data<'a>(input_object: &'a PyAny, \\\n        attribute: &'a str, config_dict: &'a PyDict) \\\n          -> &'a PyDict {\n        match input_object.getattr(attribute) {\n            Ok(data) => {\n                config_dict.set_item(attribute, \\\n                  data).unwrap();\n            },\n            Err(_) => Err(PyLookupError::new_err(\n                \"attribute number is missing\")).unwrap()\n        }\n        return config_dict\n    }\n    ```", "```rs\n        let mut config_dict: &PyDict = PyDict::new(py);\n        config_dict = extract_data(input_object, \\\n          \"number\", config_dict);\n        config_dict = extract_data(input_object, \n          \"numbers\", config_dict);\n    ```", "```rs\n        let output_dict: &PyDict = run_config( \\\n          config_dict).unwrap();\n        input_object.setattr(\n            \"number_results\", \n            output_dict.get_item(\n                \"NUMBER RESULT\").unwrap()).unwrap();\n        input_object.setattr(\n            \"numbers_results\", \n            output_dict.get_item(\n                \"NUMBERS RESULT\").unwrap()).unwrap();\n        return Ok(input_object)\n    ```", "```rs\n    pub mod object;\n    ```", "```rs\n    use interface::object::__pyo3_get_function_object_ \\\n      interface;\n    ```", "```rs\n        m.add_wrapped(wrap_pyfunction!(object_interface));\n    ```", "```rs\n    >>> from flitton_fib_rs.object_interface import \n    ObjectInterface\n    >>> test = ObjectInterface([5, 6, 7, 8], [])\n    >>> test.process()\n    >>> test.number_results\n    [5, 8, 13, 21]\n    ```", "```rs\n    use pyo3::prelude::{pyclass, pymethods, staticmethod};\n    use crate::fib_calcs::fib_number::fibonacci_number;\n    use crate::fib_calcs::fib_numbers::fibonacci_numbers;\n    ```", "```rs\n    #[pyclass]\n    pub struct FibProcessor {\n        #[pyo3(get, set)]\n        pub number: Vec<i32>,\n        #[pyo3(get, set)]\n        pub numbers: Vec<Vec<i32>>,\n        #[pyo3(get)]\n        pub number_results: Vec<u64>,\n        #[pyo3(get)]\n        pub numbers_results: Vec<Vec<u64>>\n    }\n    ```", "```rs\n#[pymethods]\n```", "```rs\nimpl FibProcessor {\n```", "```rs\n    #[staticmethod]\n```", "```rs\n    fn process_numbers(input_numbers: Vec<Vec<i32>>) \\\n```", "```rs\n      -> Vec<Vec<u64>> {\n```", "```rs\n        let mut buffer: Vec<Vec<u64>> = Vec::new();\n```", "```rs\n        for i in input_numbers {\n```", "```rs\n            buffer.push(fibonacci_numbers(i));\n```", "```rs\n        }\n```", "```rs\n        return buffer\n```", "```rs\n    }\n```", "```rs\n}\n```", "```rs\n        #[new]\n        fn new(number: Vec<i32>, numbers: Vec<Vec<i32>>) \\\n          -> Self {\n            let input_numbers: Vec<Vec<i32>> = \\\n              numbers.clone();\n            let input_number: Vec<i32> = number.clone();\n            let number_results: Vec<u64> = \n              input_number.iter(\n                                 ).map(\n                |x| fibonacci_number(*x)\n            ).collect();\n            let numbers_results: Vec<Vec<u64>> = Self::\n                     process_numbers(input_numbers);\n            return FibProcessor {number, numbers, \n                     number_results, numbers_results}\n        }\n    ```", "```rs\n    pub mod fib_processor;\n    ```", "```rs\n    mod class_module;\n    use class_module::fib_processor::FibProcessor;\n    ```", "```rs\n    m.add_class::<FibProcessor>()?;\n    ```", "```rs\n    >>> from flitton_fib_rs.flitton_fib_rs import \n    FibProcessor\n    >>> test = FibProcessor([11, 12, 13, 14], [[11, 12], \n                            [13, 14], [15, 16]])\n    >>> test.numbers_results\n    [[89, 144], [233, 377], [610, 987]]\n    ```", "```rs\n    >>> test.numbers_results = \"test\"\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: attribute 'numbers_results' of \n    'builtins.FibProcessor' objects is not writable\n    ```", "```rs\n    >>> test.number = \"test\"\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    TypeError: 'str' object cannot be interpreted as an \n    integer\n    ```", "```rs\n    >>> test.number = [1, 2, 3, 4, 5]\n    >>> test.number\n    [1, 2, 3, 4, 5]\n    ```", "```rs\n    from flitton_fib_rs.flitton_fib_rs import FibProcessor\n    import time\n    ```", "```rs\n    class PythonFibProcessor:\n         def __init__(self, number, numbers):\n               self.number = number\n               self.numbers = numbers\n               self.numbers_results = None\n               self.number_results = None\n               self._process()\n         def _process(self):\n               self.numbers_results = \\\n                 [self.calculate_numbers(i)\\ \n                   for i in self.numbers]\n               self.number_results = \\\n                 self.calculate_numbers(\n                   self.number)\n         def fibonacci_number(self, number):\n             if number < 0:\n                 return None\n             elif number <= 2:\n                 return 1\n             else:\n              return self.fibonacci_number(number - 1) + \\\n                        self.fibonacci_number(number - 2)\n         def calculate_numbers(self, numbers):\n              return [self.fibonacci_number(i) for i in \\\n                numbers]\n    ```", "```rs\n    t_one = time.time()\n    test = FibProcessor([11, 12, 13, 14], [[11, 12], \\\n        [13, 14], [15, 16]])\n    t_two = time.time()\n    print(t_two - t_one)\n    t_one = time.time()\n    test = PythonFibProcessor([11, 12, 13, 14], \\\n      [[11, 12], [13, 14], [15, 16]])\n    t_two = time.time()\n    print(t_two - t_one)\n    ```", "```rs\n    1.4781951904296875e-05\n    0.0007779598236083984\n    ```", "```rs\n    0.000017881393432617188\n    0.0007779598236083984\n    ```", "```rs\n    let results: Vec<i32> = some_vector.iter().map(\n                |x| 2*x\n            ).collect();\n    ```"]