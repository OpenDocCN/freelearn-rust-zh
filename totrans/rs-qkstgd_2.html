<html><head></head><body><div><h1 class="header-title">Basics of the Rust Language</h1>
                
            
            
                
<p class="mce-root">Okay, we're ready to actually begin writing some Rust code. In this chapter, we're going to look at how Rust programs are structured, and how an assortment of common programming elements are expressed in the language. We'll start with functions and modules, then move on to fundamental language features, such as branching, looping, and data structures. Almost everything we're covering in this chapter has an equivalent in most other programming languages; these are the fundamentals of programming.</p>
<p>Specifically, this chapter describes the following:</p>
<ul>
<li>Functions, which are somewhat like miniature programs that are part of the larger program</li>
<li>Modules, which are used to organize the program</li>
<li>Expressions, which are how we tell the program to actually do specific things</li>
<li>Branching, which is how we tell the program to make a decision</li>
<li>Looping, which is how we tell the program to perform extended actions</li>
<li>Structures, which is how we organize information for the program to process</li>
<li>Attaching functions to structures or other data types, to make them more useful</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Functions</h1>
                
            
            
                
<p>We saw a couple of functions, in passing, in the last chapter when we looked at the automatically generated boilerplate code created by <kbd>cargo new</kbd>. What were we actually seeing, though?</p>
<p>A <strong>function</strong> is a sequence of instructions for the computer to follow. It's sort of like a recipe. We don't have to tell a person how much flour, sugar, and milk to use to bake cookies, if we know that they already have a cookie recipe. We can just say: <em>Bake some cookies, please</em>. It's similar with a function. We don't have to tell the computer exactly how to save some information to a database; if there's a <kbd>save_to_database</kbd> function, we can use it to do the job.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In Rust, instructions that can tell the computer to take action can <em>only</em> be written inside of functions. It all starts with a function called <kbd>main</kbd>, which can cause other functions to run, which can in turn cause yet more functions to run, and so on. Using our recipe analogy again, it's like a pie recipe saying: <em>Use the recipe on page 57 to make dough for the crust</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Defining a function</h1>
                
            
            
                
<p>In Rust, a function starts off with the <kbd>fn</kbd> keyword. A keyword is a sequence of letters or symbols which has a fixed meaning in the language. Nothing we do in our program can change the meaning of a keyword, and the libraries we use can't change the meaning either. Keywords occasionally have different meaning in clearly different contexts, but they always mean the same thing when used in the same way. Keywords are the solid foundation that everything else is built on.</p>
<p>So, the <kbd>fn</kbd> keyword is used to tell the Rust compiler that we're about to tell it about a new function. After that, separated by a space, comes the function's name. There are rules for what the function name can look like:</p>
<ul>
<li>It must be made up of the following:
<ul>
<li> English letters (the letters <kbd>A</kbd> through <kbd>Z</kbd>, in their lowercase or CAPITAL forms)</li>
<li>Arabic numerals (the digits <kbd>0</kbd> through <kbd>9</kbd>)</li>
<li>Underscores(<kbd>_</kbd>)</li>
</ul>
</li>
<li>It can't start with a number (so <kbd>7samurai</kbd> is not a valid name)</li>
<li>If it starts with an underscore, it must have at least one further character (<kbd>_</kbd> by itself has a special meaning)</li>
</ul>
<p>Then comes an open parenthesis <kbd>(</kbd> and a close parenthesis <kbd>)</kbd>, with a list of parameters between them. We're going to gloss over the parameter list for now and come back to that later. There doesn't have to be anything between the parenthesis if the function does not need parameters, and that's how we'll do it for now.</p>
<p>After the close parenthesis of the parameter list, we can optionally include a <kbd>→</kbd> symbol followed by a return type, another thing which we'll go into in more detail later.</p>
<p>Next comes a <kbd>{</kbd> symbol, which tells Rust that we're about to begin a sequence of commands, followed by as many commands as we need in order to tell Rust how to do what we want the function to do, and then finally a <kbd>}</kbd> symbol to mark the end.</p>
<p>Going back to the boilerplate code, Let's take a look at the automatically generated <kbd>main</kbd> function again:</p>
<pre>fn main() {<br/>     println!("Hello, world!");<br/> }</pre>
<p>Here, we can see the <kbd>fn</kbd> keyword, function name, and empty parameter list. The optional return type has been omitted. Then, between the <kbd>{</kbd> and <kbd>}</kbd>, we see a single instruction, which tells the computer that we want it to print out Hello, world! whenever we tell it to run the <kbd>main</kbd> function.</p>
<p>There's not a lot more to say about functions until we have some understanding of what kinds of instructions we can give the computer, between those <kbd>{</kbd> and <kbd>}</kbd> symbols. The main idea is that we can bundle up many instructions into a function, and then use a single instruction elsewhere in the program to tell the computer <em>to do all that stuff</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Modules</h1>
                
            
            
                
<p>Modules give us a way to organize our functions (and other items that have names, such as data structures) into categories. This helps us keep things organized, and allows us to use the same name more than once, as long as we only use it once per module. It also lets us use shorter versions of a thing's name most of the time, but gives us a longer version we can use when those short names might be confusing or ambiguous.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Defining a module</h1>
                
            
            
                
<p>Defining a module is easy. In any <kbd>.rs</kbd> file which the compiler is going to be looking at, we can use the <kbd>mod</kbd> keyword to start a new module. There are two different ways to use that keyword, though, depending on whether we want to define the module as a section of the current file or as a separate file.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">A module as a section of a file</h1>
                
            
            
                
<p>To define a module as a section of a file, we use the <kbd>mod</kbd> keyword followed by a name and then a <kbd>{</kbd> symbol, then the contents of the module, and then a <kbd>}</kbd> symbol to finish it up.</p>
<p>So, if we define a new module containing a couple of functions, it would look something like this:</p>
<pre>pub mod module_a {<br/>    pub fn a_thing() {<br/>         println!("This is a thing");<br/>    }<br/>    <br/>    pub fn a_second_thing() {<br/>         a_thing();<br/>         println!("This is another thing");<br/>    }<br/>}</pre>
<p>We've created a module named <kbd>module_a</kbd> and put the <kbd>a_thing</kbd> and <kbd>a_second_thing</kbd> functions inside of it. We haven't seen it previously, but the line in <kbd>a_second_thing</kbd> that says <kbd>a_thing();</kbd> is an instruction to the computer to run the <kbd>a_thing</kbd> function. So, when <kbd>a_second_thing</kbd> runs, the first thing it does is run <kbd>a_thing</kbd>, and then it prints out its own message afterwards.</p>
<p>The <kbd>pub</kbd> keyword means that <kbd>module_a</kbd> is part of the public interface of the current module, rather than just being internal data. We'll talk more about that soon.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">A module as a separate file</h1>
                
            
            
                
<p>More often than not, we're going to want to give our modules their own files. It's just nicer to keep things separated and contained as much as possible, because it helps keep the code manageable. Fortunately, this is just as easy. In our <kbd>.rs</kbd> file, we can just write something like the following:</p>
<pre>pub mod module_b;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>That looks a lot like the previous example, except that it doesn't have the module contents right there between <kbd>{</kbd> and <kbd>}</kbd>. Instead, the Rust compiler goes looking for a file called either <kbd>module_b.rs</kbd> or <kbd>module_b/mod.rs</kbd>, and uses the whole file as the contents of the <kbd>module_b</kbd> module. So, if the file contains a couple of functions similar to the ones we saw previously:</p>
<pre>pub fn a_thing() {<br/>    println!("This is a module_b thing");<br/>}<br/><br/>pub fn a_second_thing() {<br/>    a_thing();<br/>    println!("This is another module_b thing");<br/>}</pre>
<p>Then <kbd>module_b</kbd> will contain two functions named <kbd>a_thing</kbd> and <kbd>a_second_thing</kbd>. It's not a problem that those functions have the same names as functions in the <kbd>module_a</kbd> module from before, because they're in a different module.</p>
<p>Why did the compiler look in two places for the source code of <kbd>module_b</kbd>? This allows us to be more flexible in how we lay out our directory structure for our program's source code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Accessing module contents from outside</h1>
                
            
            
                
<p>In the <em>A module as a section of a file</em> section, the <kbd>a_second_thing</kbd> function is part of the same module as <kbd>a_thing</kbd>, so it's automatically allowed to use the short version of the other function's name to refer to it. However, code outside of the module needs to use the full name to refer to items inside the module. There are two ways this can be done. It can either be done directly, which is a good choice if we don't expect to be referring to the item often, or we can tell Rust that we want to use the short name for an item in a different module, which is a good choice if we're going to be using that item often in our code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the item's full name directly</h1>
                
            
            
                
<p>An item's full name consists of the module name, a <kbd>::</kbd> symbol, and then the item's short name. If we have several layers of modules that we need to get through before we find the item we want, we list those modules' names in order, with a <kbd>::</kbd> between each name. For example, we might refer to <kbd>std::path::Path</kbd> to get the <kbd>Path</kbd> item from the <kbd>path</kbd> module of the <kbd>std</kbd> module.</p>
<p class="mce-root"/>
<p>We can use the full name anywhere and be completely unambiguous as to what item we're talking about.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the item's short name</h1>
                
            
            
                
<p>We can also use the <kbd>use</kbd> keyword to tell Rust that we want to refer to an item in a different module by its short name. This is done by just writing <kbd>use</kbd> followed by the full name of the item we want to use. For example, <kbd>use std::path::Path;</kbd> allows us to use just the short name for that item (<kbd>Path</kbd> in this example) in the following instructions, until we come to the <kbd>}</kbd> that closes the section of code where our <kbd>use</kbd> keyword was written (or we come to the end of the module file, which amounts to the same thing).</p>
<p>We can use the same syntax to tell Rust that we want to use the name of a module, rather than an item in a module. For example, <kbd>std::path</kbd> is a valid command. That would allow us to use <kbd>path::Path</kbd> as the name of the <kbd>Path</kbd> item in subsequent code. This is frequently convenient, since it still keeps the external items boxed up and separate, while providing reasonably short and informative names to work with.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Public and private module items</h1>
                
            
            
                
<p>In many of the preceding examples, we saw a <kbd>pub</kbd> keyword. That keyword makes the item it's attached to <em>public</em>, meaning that it is available to code that is not part of the same module. If we omit the <kbd>pub</kbd> keyword on an item, that item is <kbd>private</kbd>, meaning that it can only be accessed within the module where it is defined. Private is the default, so we need to explicitly mark those items that we want to have as part of the module's externally accessible interface as public by using the <kbd>pub</kbd> keyword.</p>
<p>Making an item private is not a security mechanism. If you're worried that your code will be linked with hostile code that might misuse your code or data, making the code or data private will not protect against such attacks. Rather, the distinction between public and private exists in order to help us make it plain which parts of the code are <em>intended</em> for use outside of the current module, and which are meant to be used only internally. This helps us maintain our software, because we are free to make whatever changes we want to to private items, whereas with public items, we have to be careful that our changes do not break external things we might not even be aware exist.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Expressions</h1>
                
            
            
                
<p>The instructions that tell the computer to do something in a Rust program are almost all expressions. An expression tells the computer how to compute a particular value, and produces that value as its result. In math, <em>2 + 2</em> is an expression with a resulting value of 4. Similarly, <em>(2 + 2) - 1</em> is an expression with a resulting value of 3, which is itself made up of an addition expression and a subtraction expression. In Rust, the same basic idea applies: expressions tell the computer how to find a value, and they can be combined together, because using an expression that produces a value has the same result as using that value directly, just as writing (2 + 2) - 1 has the same result as writing 4 - 1.</p>
<p>Not all expressions in Rust look like math, though. Rust is a programming language, not just a calculator. It's the idea of expressions, which combine values to produce new values, that matters.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Literal expressions</h1>
                
            
            
                
<p>The simplest of Rust's expressions are the ones where we just write out the representation of the value we want. For example, when Rust sees <kbd>2</kbd> it knows we are asking it for the number <kbd>2</kbd>. Similarly, when Rust sees <kbd>"Hello, world!"</kbd> it knows we're asking it to produce the sequence of letters that spells out <em>Hello, world!</em></p>
<p>Rust recognizes the following literal expressions:</p>
<ul>
<li>Numbers</li>
<li>Quoted text</li>
<li>Byte sequences</li>
<li>Single Unicode points</li>
<li>Single bytes</li>
<li>Boolean values</li>
</ul>
<p>Numbers can be written as integers or decimal numbers or in engineering notation, and there are a few variants for quoted text and byte sequences, too. Boolean values are written as either <kbd>true</kbd> or <kbd>false</kbd>. In this book, we're not going to need any of the variants of quoted text, and we won't need byte sequences at all, so we won't go into those in more detail. See <a href="https://doc.rust-lang.org/">https://doc.rust-lang.org/</a> if you're curious.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Operator expressions</h1>
                
            
            
                
<p>Again, like math, Rust has a number of symbolic <strong>operators</strong> that can be applied to values to transform them into some new value. For example, <kbd>+</kbd> is a Rust operator that adds two values together. So, <kbd>2 + 2</kbd> is a Rust expression adding the number 2 to itself, producing the number 4. Rust also uses <kbd>-</kbd> as the subtraction operator, <kbd>*</kbd> as the multiplication operator, <kbd>/</kbd> as the division operator, and <kbd>%</kbd> as the remainder operator.</p>
<p>Rust is not limited to mathematical operators, though. In Rust, <kbd>&amp;</kbd> means <em>and</em>, <kbd>|</kbd> means <em>or</em>, <kbd>^</kbd> means <em>exclusive or</em>, <kbd>!</kbd> means <em>not</em> (<kbd>!true</kbd> is <kbd>false</kbd>, for example), <kbd>&lt;&lt;</kbd> means <em>leftward bit shift</em>, and <kbd>&gt;&gt;</kbd> means <em>rightward bit shift</em>. Sometimes the meanings of those operations depends on the type of value that they're acting on. For example, <kbd>|</kbd> means <em>bitwise or</em> when applied to integers, but <em>logical or</em> when applied to Boolean values.</p>
<p>Then there are the comparison operators. The <kbd>==</kbd> operator means <em>check whether two values are equal</em>. An expression built around the <kbd>==</kbd> operator produces the Boolean value <kbd>true</kbd> if the two values being compared are equal, and <kbd>false</kbd> if they are not. So, for example, <kbd>5 == 4</kbd> is an expression producing <kbd>false</kbd> as its result. Similarly, <kbd>!=</kbd> means <em>not equal</em>, <kbd>&gt;</kbd> means <em>greater than</em>, <kbd>&lt;</kbd> means <em>less than</em>, <kbd>&gt;=</kbd> means <em>greater than or equal</em>, and <kbd>&lt;=</kbd> means <em>less than or equal</em>. All of them produce <kbd>true</kbd> when the relationship is correct, and <kbd>false</kbd> when it is not.</p>
<p>Finally, Rust recognizes <kbd>&amp;&amp;</kbd> and <kbd>||</kbd> operators. These can only be applied to Boolean (<kbd>true</kbd> or <kbd>false</kbd>) values, and produce the same results as <kbd>&amp;</kbd> and <kbd>|</kbd> do when applied to the same values. The difference is that <kbd>&amp;&amp;</kbd> and <kbd>||</kbd> are what is called <em>lazy</em> or <em>short-circuit</em> operators, which means that they will not bother evaluating their right-side operand if the left-side operand provides enough information to determine the operator's produced value. For example, for the expression <kbd>false &amp;&amp; some_expensive_calculation()</kbd>, Rust will never bother to run the <kbd>some_expensive_calculation</kbd> function, because no matter what the function produced as its result, the result of the <kbd>&amp;&amp;</kbd> operation is going to be <kbd>false</kbd>.</p>
<p>In most situations where we'd use <kbd>&amp;</kbd> or <kbd>|</kbd> on Boolean values, we should use <kbd>&amp;&amp;</kbd> or <kbd>||</kbd> instead, since it allows Rust to be a little more efficient, especially if we're mindful enough to put the more expensive operations on the right side of the operator.</p>
<p>These are not a full list of Rust's operators, and we'll see some of the more specialized ones as we move onward through the language. These are the operators we need for expressing the majority of calculations, computations, and decisions in our programs, though.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Array and tuple expressions</h1>
                
            
            
                
<p>An <strong>array</strong> is a sequential collection of data values. There are many ways to use and manipulate them, but here we're interested in the specialized expressions that create them and access their internal data values. To tell Rust that we want to create a new array, all we have to do is write a <kbd>[</kbd> symbol, and then a comma-separated list of expressions that produce the values we want to store in the array, and then a <kbd>]</kbd> symbol. There doesn't have to be anything between the beginning and ending symbols if we want an empty array. So, we can write <kbd>[]</kbd> as an expression producing an empty array, or <kbd>[1, 3, 5]</kbd> as an expression producing an array containing three numbers. All of the values stored in an array need to have the same data type—integers in this case—so trying to set the second element to a text string such as <kbd>"nope"</kbd> would produce a compiler error when we tried to compile the program.</p>
<p>That's really nice for cases where we need to create a short array, but imagine writing out an expression for an array containing a thousand values! We wouldn't want to write them out one by one. Fortunately, we can instead do something like <kbd>[0; 1000]</kbd>, which produces an array containing a thousand zero values. Some other part of our code can then fill in different values in those slots.</p>
<p>Once we have an array value, we often need access to the values stored inside it. That too is achieved using the <kbd>[</kbd> and <kbd>]</kbd> symbols. If we have an array named <kbd>an_array</kbd> (we'll see how to give values names in the <em>Variables, types, and mutability</em> section of this chapter), we can access the first value in the array as <kbd>an_array[0]</kbd>, the second value as <kbd>an_array[1]</kbd>, and so on. Notice that the first value is numbered with <kbd>0</kbd>, while the second is <kbd>1</kbd>. Many programming languages count this way, because it simplifies some of the math that they frequently need to do with respect to arrays and other sequences of values.</p>
<p>In addition to arrays, Rust allows us to make <strong>tuples</strong>. The expression to create a tuple is similar to that for arrays: <kbd>(1, "wow", true)</kbd> is a tuple containing the number value <kbd>1</kbd>, the text value <kbd>wow</kbd>, and the Boolean <kbd>true</kbd>. If we have a tuple named <kbd>a_tuple</kbd>, then <kbd>a_tuple.1</kbd> produces the second value in the tuple, in this case the word <kbd>wow</kbd>. There's no simplified way to create a tuple containing a thousand duplicates, though, because that's not what they're for. Unlike arrays, a single tuple can contain values of more than one value type, and they are intended to serve as lightweight data structures, rather than as a collection of many similar data values.</p>
<p>In some languages, the contents of a tuple cannot be changed. That's not how it works in Rust, though, where tuples follow the same rules for that sort of thing as any other data structure.</p>
<p class="mce-root"/>
<p>If we need to make a tuple with only one contained value (which is not common, because the whole point of a tuple is to associate multiple values together), we need to include a comma after the value. So, a single-element tuple containing the number 5 looks like this: <kbd>(5,)</kbd></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Block expressions</h1>
                
            
            
                
<p>Sometimes, the necessary steps to figure out an expression's result value just don't fit into a single expression of the sorts we've looked at before. Maybe they need to store a data value for a little while in order to execute efficiently, or are otherwise too complex to be reasonably written in the <em>1 + ((2 * 57) / 13)</em> style.</p>
<p>That's where block expressions come in. Block expressions look a lot like the body of a function because the body of a function <em>is</em> a block expression. They start with <kbd>{</kbd> and end with <kbd>}</kbd>. Between those two markers, we can write whatever instructions we need, including doing things like defining variables or other named items.</p>
<p>At the very end of the block should come the expression that produces the final result value of the block. So, for example, the block expression <kbd>{ 2 + 2; 19 % 3; println!("In a block"); true}</kbd> is a (kind of silly) block expression that produces the Boolean <kbd>true</kbd> as its result, but not until after it has calculated that 2 plus 2 equals 4, and calculated that the remainder of 19 over 3 is 1, and printed out <em>In a block</em> to the console.</p>
<p>By the way, the Rust compiler will warn us about that block expression, because it calculates two values and then just discards them. That's wasteful, so Rust points it out. If optimizations are enabled, the compiler will actually skip generating code to calculate the values at all, but that's an optimization, and the program and compiler are still supposed to act as if they did perform the calculations.</p>
<p>Notice the semicolons (<kbd>;</kbd>) in the block expression. Every top-level instruction in the block has a semicolon after it, <em>except the last one</em>. That's because the semicolon tells Rust that the expression before it should be treated as a <strong>statement</strong>, which basically means that it won't produce a value, or if it does, we don't care what that value is. In some cases, the semicolon can be left off of expressions prior to the last one in a block, but I don't recommend it, because explicitly discarding the results of expressions whose results we're not going to use allows the compiler more freedom to make inferences and optimizations, and can help avoid some fairly obscure compiler errors.</p>
<p class="mce-root"/>
<p>If we put a <kbd>;</kbd> after the final expression in a block, we're saying that the block doesn't have a meaningful resulting value at all. In that case, it ends up having <kbd>()</kbd> as its resulting value. That's an empty tuple, which is a pretty good way of saying: <em>Nothing to see here, folks</em>. <kbd>()</kbd> is used that way throughout the Rust language and libraries.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Branch expressions</h1>
                
            
            
                
<p>One of the things that makes programs truly useful is the ability for them to make decisions. We can do that in Rust by using an <kbd>if</kbd> expression. An <kbd>if</kbd> expression looks something like this:</p>
<pre>if 3 &gt; 4 {<br/>    println!("Uh-oh. Three is greater than four.");<br/>}<br/>else if 3 == 4 {<br/>    println!("There seems to be something wrong with math.");<br/>}<br/>else {<br/>    println!("Three is not greater than or equal to four.");<br/>};</pre>
<p>If you're familiar with other programming languages, you might be wondering where the parenthesis are around the condition expression. Rust's syntax doesn't call for parenthesis there. In fact, if we place the condition in parenthesis, the compiler will warn us that they're not necessary.</p>
<p>What we have here is an expression that shows off all the features of an <kbd>if</kbd>. It starts off with the keyword <kbd>if</kbd>, followed by a <em>condition expression</em> that produces either <kbd>true</kbd> or <kbd>false</kbd>, and then a block expression. If the condition expression produces <kbd>true</kbd>, the block expression is run, but if the condition expression produces <kbd>false</kbd>, the block expression is not run.</p>
<p>Using <kbd>3 &gt; 4</kbd> as our condition expression is not very useful. We might as well just write <kbd>false</kbd>, or leave that block expression out entirely since it will never run. However, in real code, we would use a condition expression whose result we would not know at the time we were writing the code. <em>Is it between the hours of 8 A.M. and 5 P.M.</em>, <em>Did the user select this value from the menu</em>, and <em>Does the value match what is stored in the database</em> are examples of more realistic conditions, though of course they would have to be expressed in Rust.</p>
<p class="mce-root"/>
<p>After that, we have an <kbd>else if</kbd> and another condition expression and block. That means that, if the first condition expression produced <kbd>false</kbd>, the computer should check whether the second one produces <kbd>true</kbd>, and if it does, run the associated block expression.</p>
<p>We can chain as many <kbd>else if</kbd> expressions as we want after an initial <kbd>if</kbd>, so there's no limit to the number of different options we can make available to the computer. However, only one of them will run after any given decision. The computer will start with the initial <kbd>if</kbd> and check the values of the conditional expressions one at a time until it finds one that produces <kbd>true</kbd>, then it will run the associated block expression, and then it will be done with the if expression and move on to the subsequent instructions.</p>
<p>After an <kbd>if</kbd> and any <kbd>else if</kbd> we might wish to include, we are allowed to put an <kbd>else</kbd> followed by a block expression. This is a branch without a condition, and what it means is <em>if none of the condition expressions produced</em> <kbd>true</kbd>, <em>do this</em>. In other words, it allows us to tell the computer what to do by default, if none of the special cases we provided apply.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Loop expressions</h1>
                
            
            
                
<p>Another of the basic abilities that make programs useful is looping. Rust has several different kinds of loops, but we're going to look at two of them here: <kbd>while</kbd> loops and <kbd>for</kbd> loops.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">while loops</h1>
                
            
            
                
<p>A <kbd>while</kbd> loop is a lot like an <kbd>if</kbd> expression. The difference is, instead of checking the condition expression once and then either running the block expression or not, and then being done, a <kbd>while</kbd> loop keeps repeating the process until the condition expression produces <kbd>false</kbd>. So, if the condition expression results in <kbd>false</kbd> right away, the block expression never runs. On the other hand, if the condition expression produces <kbd>true</kbd> on the first check, the block expression gets run, and then the condition expression is evaluated again. If it produces <kbd>true</kbd> again, the block runs again, and so on, until the condition expression finally produces <kbd>false</kbd>.</p>
<p>That means that it's very important for the block expression to change something that affects the condition expression's result. If the condition expression produces <kbd>true</kbd> and the block doesn't have any chance of changing that, the program will be stuck looping through that block over and over until the program is forcefully terminated. This is the easiest way to cause your program to freeze.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, here's a simple <kbd>while</kbd> loop:</p>
<pre>while i &lt; 3 {<br/>    i = i + 1;<br/>    println!("While loop {}", i);<br/>}</pre>
<p>We're using a variable named <kbd>i</kbd> here, which we'll talk about more in the <em>Variables and mutability</em> section of this chapter. For now, just think of <kbd>i</kbd> as a name that we can assign different values to at different times, sort of like how we can ask different people to sit in the same chair at different times.</p>
<p>So, we have the <kbd>while</kbd> keyword followed by a condition expression. This condition expression uses a variable, which we change the value of in the block expression, so we're not in danger of looping forever. If <kbd>i</kbd> starts with the value <kbd>0</kbd>, we should see the block expression run three times: once when <kbd>i</kbd> is <kbd>0</kbd>, once when <kbd>i</kbd> is <kbd>1</kbd>, and once when <kbd>i</kbd> is <kbd>2</kbd>. When <kbd>i</kbd> gets to <kbd>3</kbd>, the condition expression produces <kbd>false</kbd> as its result (3 is not less than 3), and the loop stops.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">for loops</h1>
                
            
            
                
<p>Sometimes, <kbd>while</kbd> loops are exactly what we need, but the two most common needs for looping are to loop a specific number of times or to use a loop to process each element contained in an array or similar data structure. In both of these cases, <kbd>for</kbd> loops work better.</p>
<p>A <kbd>for</kbd> loop runs its block expression once for each value produced by an <strong>iterator</strong>. An iterator is a special kind of data value that has the job of returning a sequence of values, one at a time. An iterator for an array, for example, produces a different member of the array each time we ask it for a value.</p>
<p>To loop a specific number of times, we can use a <kbd>for</kbd> loop along with a <strong>range expression</strong>, which is an expression that produces an iterator over a sequence of numbers. Let's look at a concrete example of that:</p>
<pre>for num in 3..7 {<br/>    println!("for loop {}", num);<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We started off with the <kbd>for</kbd> keyword and then <kbd>num</kbd>, which is the name which is going to be given to each value that the iterator produces, one at a time, as those values are processed by the <kbd>for</kbd> loop. Then comes another keyword, <kbd>in</kbd>. Finally, the expression that produces our iterator. In this case, we have a range expression, which represents the values <kbd>3</kbd>, <kbd>4</kbd>, <kbd>5</kbd>, and <kbd>6</kbd>. Notice that <kbd>7</kbd> is not included in the range. As with counting from zero, this makes some of the math easier for the computer to do, and in this case, it makes things easier for us most of the time as well. If we want to loop seven times, we could just write <kbd>0..7</kbd>.</p>
<p>There is a variant we could use that would include the final number in the output, should we need it: <kbd>3..=7</kbd>. Just remember that if you loop through <kbd>0..=7</kbd>, you're going to be running the block expression eight times.</p>
<p>The other time when <kbd>for</kbd> loops shine is when we have a collection of actual values that we want to process, as the following example:</p>
<pre>for word in ["Hello", "world", "of", "loops"].iter() {<br/>    println!("{}", word);<br/>}</pre>
<p>This loop prints out each of the words in the array, each on their own line. The <kbd>word</kbd> name is set to the first value produced by the iterator, <kbd>"Hello"</kbd>, and the block expression is run. Then <kbd>word</kbd> is set to the second value produced by the iterator, <kbd>"world"</kbd>, and the block expression is run again. This continues until the iterator runs out of values to produce, and then stops.</p>
<p>Here, our iterator is producing the values stored in an array. The <kbd>.iter()</kbd> part of that expression is saying, basically: <em>Arrays know how to make iterators for themselves, so ask the array to give us an iterator</em>. We'll see more about how to implement functions that are specific to a data type in a later chapter, but for now, we just need to know that that's what the <kbd>.</kbd> symbol means: the thing on the right of the dot is specific to the thing on the left. We are asking the computer to run, not just any <kbd>iter</kbd> function, but the <kbd>iter</kbd> function that is associated with our array.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Variables, types, and mutability</h1>
                
            
            
                
<p>A variable is a named box in which a data value can be stored. The variable itself isn't the data value, just like a carton of milk is not the same thing as milk (it's waxed cardboard and such <em>containing</em> milk).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>On the other hand, if somebody needs milk and you hand them a full milk carton, they're not going to complain, and the same goes for Rust. If a Rust expression needs an integer, and we provide a variable containing an integer, Rust will be perfectly happy with that.</p>
<p>Variables are most often created using the <kbd>let</kbd> keyword:</p>
<p><kbd>let x = 10;</kbd></p>
<p>This statement creates a variable called <kbd>x</kbd> containing the <kbd>10</kbd> value in it. Once that's done, we can refer to <kbd>x</kbd> as part of the expressions. For example, <kbd>x + 5</kbd> is now a valid expression, with a resulting value of <kbd>15</kbd>.</p>
<p>The names that <kbd>for</kbd> loops use are also variables, as are function parameters, although they are not created with the <kbd>let</kbd> keyword.</p>
<p>In addition to having a name, variables are characterized by the type of value they can store. Each variable can store one kind of value, and can never store any other type of information. Rust can often figure out what type of information a given variable can store, but we always have the option of being explicit about it. If we tell Rust that <kbd>let x: i32 = 99;</kbd>then Rust will make sure that the <kbd>x</kbd> variable can store a 32-bit signed integer and report an error if we try to store something else there. On the other hand, <kbd>let x: f64 = 999.0;</kbd>tells Rust that we want <kbd>x</kbd> to store a 64-bit floating-point number and that trying to store anything else there is an error.</p>
<p>We don't have to provide an initial value for a variable. For example, we could say <kbd>let x: u16;</kbd>to tell Rust that the <kbd>x</kbd> variable needs to be able to store 16-bit unsigned integers. That's fine. However, if it's even possible that some of our code will try to use the contents of the variable without first having stored some contents there to be used, the Rust compiler will consider that an error. It's usually easier to just provide a starting value when we create a variable.</p>
<p>Variables are called <strong>variables</strong> because the values they contain can be changed. Except in Rust, by default, they can't. Rust allows us to use multiple <kbd>let</kbd> statements to create new variables with the same names as old variables, but we can't just assign a new value to an existing variable, unless that variable is <strong>mutable</strong>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Creating a new variable with the same name as an existing variable is called <strong>shadowing</strong> the old variable. A shadowed variable still contains the value it did before, but cannot be accessed by name any more, because that name now belongs to a different variable. If there are any references to the old variable still in play, they will still be accessing the old variable, though, not the new one.</p>
<p>Being mutable just means that the variable will accept changes, up to and including a whole new value. We use the <kbd>mut</kbd> keyword to tell Rust that a variable should be mutable:</p>
<p><kbd>let mut x = 17;</kbd></p>
<p>The new <kbd>x</kbd> variable is mutable. That means we can modify its contents:</p>
<p><kbd>x = 0;</kbd></p>
<p>Instead of containing <kbd>17</kbd>, <kbd>x</kbd> now contains <kbd>0</kbd>.</p>
<p>The equal symbol (<kbd>=</kbd>) that we're using for variables is not a statement of mathematical equality. It doesn't mean: <em>These two things are defined as being the same</em>. Instead it means: <em>Right here, right now, the value produced by the expression on the right side of the</em> <kbd>=</kbd> <em>is to be stored in the variable on the left</em>. This would be nonsense in math, but it makes perfect sense in Rust:</p>
<pre>for i in 0..5 {<br/>    x = x + i;<br/>}</pre>
<p>Rust has quite a lot of built-in data types. We've seen <kbd>i32</kbd>, <kbd>f64</kbd>, and <kbd>u16</kbd>, which are 32-bit signed integer, 64-bit floating point, and 16-bit unsigned integer, respectively. There are also more types following the same pattern, such as <kbd>u64</kbd> for an unsigned 64-bit integer, as well as types such as <kbd>bool</kbd> for Boolean values; <kbd>isize</kbd> and <kbd>usize</kbd> for signed and unsigned integers that take up the same number of bits as a memory address on the target architecture; and <kbd>char</kbd> and <kbd>str</kbd> for single Unicode code points and sequences of them.</p>
<p>These are known as primitive types, because they're inherent to the language. However, Rust also allows us to create new types, and so the Rust standard library contains many more data types that are suited to various specific uses, and there are even more available in third-party libraries.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Type inference</h1>
                
            
            
                
<p>As we noticed earlier, we can specify the type of a variable, but we often don't have to. That's because Rust has a feature called type inference, which often lets it figure out what type a variable is by looking at what we do with it. For example, if we were using the Tokio networking library, we might use code such as this:</p>
<pre>let addr = "127.0.0.1:12345".parse()?;<br/>let tcp = TcpListener::bind(&amp;addr)?;</pre>
<p>We didn't specify what type the <kbd>addr</kbd> variable should have. Even more interesting, we didn't tell the text address what kind of information we needed it to parse into.</p>
<div><strong>Parsing</strong> means <em>transforming a representation into usable data</em>, approximately. Lots of things can be represented as a string of text, if you know how to parse that text into the information you really want.</div>
<p>The question marks in this example are part of Rust's error handling mechanism, and the ampersand is an operator that affects how the <kbd>addr</kbd> variable is shared with the function. We'll see more on both of those soon.</p>
<p>However, Rust can see that we're passing the <kbd>addr</kbd> variable (or rather, a reference to it, but more on that in the next chapter) as a parameter of the <kbd>TcpListener::bind</kbd> function, and it knows that that function needs a reference to a <kbd>SocketAddr</kbd>, so <kbd>addr</kbd> must be a <kbd>SocketAddr</kbd>. Then, since it has figured out that <kbd>addr</kbd> is a <kbd>SocketAddr</kbd>, it takes it a step further and determines that it should use the string parsing function that produces a <kbd>SocketAddr</kbd> as its resulting value.</p>
<p>Type inference can save an amazing amount of time in a language as strict as Rust. On the other hand, it can be surprising if you see an error message about a data type you've never heard of, because Rust decided that it was the one you needed. If that happens, try assigning the type you actually expect to your variable and see what the Rust compiler has to say afterward.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Data structures</h1>
                
            
            
                
<p>Creating a data structure is one of the ways to add a new data type to Rust. A data structure is a group of variables that have been attached to each other, resulting in a single new data type that means <em>all of these, together</em>.</p>
<p>A new structure is defined using the <kbd>struct</kbd> keyword:</p>
<pre>pub struct Constrained {<br/>    pub min: i32,<br/>    pub max: i32,<br/>    current: i32,<br/>}</pre>
<p>Notice the commas after each contained variable is defined. It can be tempting to use semicolons there, but that would cause a compiler error. The final comma is optional, but recommended, because it means that the lines can be rearranged without having to pay attention to where a comma might be missing, among other reasons.</p>
<p>Here, we've defined a structure called <kbd>Constrained</kbd>, which is made up of three different 32-bit unsigned integer variables. The structure itself is public, meaning that it can be used outside of the module where it's defined.</p>
<p>The <kbd>min</kbd> and <kbd>max</kbd> contained variables are also public, but that means something slightly different. It means that anywhere we have a <kbd>Constrained</kbd> value, we can access the <kbd>min</kbd> and <kbd>max</kbd> contained values directly. The <kbd>current</kbd> value, on the other hand, is private, which means that it can be directly accessed only within the module where the structure is defined. We can define functions in that module with the express purpose of accessing the data contained in private structure members, but the members themselves are not part of the structure's public interface, even if the structure itself is public.</p>
<p>To access <kbd>min</kbd> and <kbd>max</kbd>, we can use the same <kbd>.</kbd> symbol that we've seen previously in a few places. So, if <kbd>cons</kbd> is a mutable <kbd>Constrained</kbd> value, then we can do things like this:</p>
<pre>cons.min = 5;</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Mutability of data structures</h1>
                
            
            
                
<p>We cannot use the <kbd>mut</kbd> keyword to make the contained values within a structure mutable, and leaving the keyword off does not make them immutable. Instead, the entire structure is mutable or immutable on a case-by-case basis. See the following, for example:</p>
<pre>let change_no: Constrained;<br/>let mut change_yes: Constrained;</pre>
<p>The preceding code means that there are two variables, both with <kbd>Constrained</kbd> as their data type, but the value stored in <kbd>change_no</kbd> is immutable while the value stored in <kbd>change_yes</kbd> is mutable.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">More about functions</h1>
                
            
            
                
<p>Now, we're going to fill in the blanks left in the earlier discussion of functions by talking about parameters and return types.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Parameters</h1>
                
            
            
                
<p>Parameters allow us to provide information to a function at the time when we ask it to run.</p>
<p>Asking a function to run is called <em>calling</em> it.</p>
<p>When we define a function, we can tell it the variable names and types we want it to use for receiving parameters, as in the following example:</p>
<pre>pub fn set(&amp;mut self, value: i32) {<br/>    self.current = value;<br/>}</pre>
<p>We'll talk about <kbd>self</kbd> in the <em>Implementing behavior for types</em> section of this chapter. For now, ignore it and take a look at <kbd>value</kbd>. Here, we've provided a name and data type, just as we would if we were using <kbd>let</kbd> to create a new variable. What we have not done is provide a value for the <kbd>value</kbd> variable, because that happens when the function is called.</p>
<p>We've seen function calls all along, but for the sake of clarity, they look like this:</p>
<pre>some_function(2 + 2, false)</pre>
<p>In that example, <kbd>some_function</kbd> is the name of a function, and the values that are assigned to its parameters are the results of the expressions <kbd>2 + 2</kbd> and <kbd>false</kbd>. The parameter expressions are evaluated <em>before</em> the function is called, so the actual values of the parameters are the number <kbd>4</kbd> and the Boolean, <kbd>false</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Return types</h1>
                
            
            
                
<p>Calling a function is an expression, which means it produces a resulting value. We've been ignoring that until now. If a function is going to produce a resulting value, we have to tell the compiler what data type that result will have. We do that like this:</p>
<pre>pub fn get(&amp;self) -&gt; i32 {<br/>    if self.current &lt; self.min {<br/>        return self.min;<br/>    }<br/>    else if self.current &gt; self.max {<br/>        return self.max;<br/>    }<br/>    else {<br/>        return self.current;<br/>    };<br/>}</pre>
<p>That's a longish example, but for now we're focusing on the first line. After the function parameters, we see <kbd>-&gt;  i32</kbd>. That tells Rust that the <kbd>get</kbd> function has <kbd>i32</kbd> as the data type of its result. Once it knows that, the compiler will make sure that it's true. In this example, there's no path through the function that doesn't produce an <kbd>i32</kbd> value, so the compiler is happy with it.</p>
<p>We also used the <kbd>return</kbd> keyword in that example. A <kbd>return</kbd> statement stops the currently running function (meaning that any instructions that would have run after the <kbd>return</kbd> statement do not in fact get run) and provides the resulting value for the function call expression. In this example, if the current value is less than the minimum value, the minimum value is returned. If the current value is greater than the maximum value, the maximum value is returned. Otherwise, the current value is returned.</p>
<p>You may recall that in Rust, function bodies are block expressions, and <kbd>if</kbd> along with its riders is also an expression, which means they all produce a resulting value naturally, even when we don't use the <kbd>return</kbd> keyword. That means that we could have written the example function this way and gotten the same result:</p>
<pre>pub fn alternate_get(&amp;self) -&gt; i32 {<br/>    if self.current &lt; self.min {<br/>        self.min<br/>    }<br/>    else if self.current &gt; self.max {<br/>        self.max<br/>    }<br/>    else {<br/>        self.current<br/>    }<br/>}</pre>
<p>Do you see the difference? Before, we used <kbd>return</kbd> to specifically terminate the function and provide a resulting value. Here, the resulting value of the function's block expression is the resulting value of the <kbd>if</kbd> expression, which is the resulting value of the block expression for whichever branch it follows, which is either <kbd>self.min</kbd>, <kbd>self.max</kbd> or <kbd>self.current</kbd>. The end result is the same, but it's expressed differently.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Error handling</h1>
                
            
            
                
<p>Sometimes, we can anticipate the possibility that something could go wrong, or we're using a library function that knows it might not succeed. When that happens, we'll find ourselves using the special <kbd>Result</kbd> data type. The result is a <strong>generic type</strong>, which we'll talk about in a later chapter, but it's so integral to using functions that we're going to see how to use it here in a rote way.</p>
<p>A function that can fail will have a return type something like this: <kbd>Result&lt;i32, &amp;'static str&gt;</kbd>. This looks kind of nuts at first glance, I admit. Let's break it down. The type starts off with <kbd>Result</kbd> followed by a <kbd>&lt;</kbd>, then <kbd>i32</kbd>, then a <kbd>,</kbd>, then <kbd>&amp;'static str</kbd>, and finally a <kbd>&gt;</kbd>. What that means is that the function will produce an <kbd>i32</kbd> if it succeeds, and an <kbd>&amp;'static str</kbd> if it fails. <kbd>&amp;'static str</kbd> happens to be the type for a literal text expression, like <kbd>oops, it broke</kbd>, so what we're really saying here is that the function will return an integer or an error message.</p>
<p>It's common to have a data type specifically for representing errors, such as an <kbd>Error</kbd> structure, rather than just using a textual error message.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Result to signal success or failure</h1>
                
            
            
                
<p>Expanding on our example, how do we write a function that can either succeed or fail? See the following:</p>
<pre>fn can_fail(x: bool) -&gt; Result&lt;i32, &amp;'static str&gt; {<br/>    if x {<br/>        return Ok(5);<br/>    }<br/>    else {<br/>        return Err("x is false");<br/>    };<br/>}</pre>
<p>First, we set up the return type to use <kbd>Result</kbd>, then, in the body of the function, we use either <kbd>Ok()</kbd> or <kbd>Err()</kbd> to signal that we're returning a valid value or an error, respectively.</p>
<p>If a function might fail, but doesn't have any meaningful return value if it succeeds, we can use <kbd>()</kbd> as the successful return type. So, in that case the return type might look like this: <kbd>Result&lt;(), &amp;'static str&gt;</kbd>. The successful return value would be <kbd>Ok(())</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Calling functions that return Result</h1>
                
            
            
                
<p>When we call a function that returns <kbd>Result</kbd>, the return value is—as requested—a <kbd>Result</kbd>, rather than the data type we really need. There are several ways of working with that, depending on our specific needs.</p>
<p>The simplest way to deal with a <kbd>Result</kbd> is to use the <kbd>?</kbd> operator, which extracts the stored value from a successful <kbd>Result</kbd>, or returns a <kbd>Result</kbd> containing the error value if the <kbd>Result</kbd> it's looking at indicates an error. Because <kbd>?</kbd> might return from the current function in the same way that a <kbd>return</kbd> statement would, <kbd>?</kbd> can only be used in functions that themselves return <kbd>Result</kbd> and use the same data type to represent errors. Using <kbd>?</kbd> looks like this:</p>
<pre>let mut cons: Constrained = new_constrained(0, 10, 5)?; </pre>
<p>Here, we're calling the <kbd>new_constrained</kbd> function, which returns either a successful result or an error message. However, the variable we're assigning to has <kbd>Constrained</kbd> as its type, not <kbd>Result</kbd>. That works because of the <kbd>?</kbd> at the end, which pulls out the <kbd>Constrained</kbd> value if the function call succeeds, and returns if the function call fails.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The next easiest way to deal with a returned <kbd>Result</kbd> is to use the <kbd>expect</kbd> function. This function does something similar to the <kbd>?</kbd>, pulling out the success value if Result indicates success, but it handles failure differently. Instead of returning an error from the current function, <kbd>expect</kbd> terminates the whole program and prints out an error message. Functions that use <kbd>expect</kbd> don't have to return a <kbd>Result</kbd>, so it can be used in some situations where <kbd>?</kbd> is unavailable. Using <kbd>expect</kbd> looks like this:</p>
<pre>let mut cons: Constrained = new_constrained(0, 10, 5).expect("Something went very wrong");</pre>
<p>The parameter passed to <kbd>expect</kbd> is the error message it should display on failure. There are some other functions, similar to <kbd>expect</kbd>, that handle errors in various ways, such as calling an error handler function.</p>
<p>Finally, we can actually handle the errors ourselves, by checking whether the returned <kbd>Result</kbd> is an <kbd>Ok</kbd> or an <kbd>Err</kbd>. That is done by using the <kbd>match</kbd> or <kbd>if let</kbd> expressions, which we will learn about in <a href="700c26ca-e1de-4069-afaf-d9acb22dd6ab.xhtml" target="_blank">Chapter 4</a>, the <em>Making Decisions by Pattern Matching</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Implementing behavior for types</h1>
                
            
            
                
<p>In previous examples, we've seen what appeared to be calls to functions that were contained within data values, such as <kbd>"127.0.0.1:12345".parse()</kbd> or <kbd>["Hello", "world", "of", "loops"].iter()</kbd>. Those are functions that have been <strong>implemented</strong> on the type of those values. Implementing functions on a type looks like this:</p>
<pre>impl Constrained {<br/>    pub fn set(&amp;mut self, value: i32) {<br/>        self.current = value;<br/>    }<br/><br/>    pub fn get(&amp;self) -&gt; i32 {<br/>        if self.current &lt; self.min {<br/>            return self.min;<br/>        }<br/>        else if self.current &gt; self.max {<br/>            return self.max;<br/>        }<br/>        else {<br/>            return self.current;<br/>        };<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is an implementation block (which is <em>not</em> a block expression) for a data type, in this case the <kbd>Constrained</kbd> type that we created earlier. Implementation blocks are introduced with the <kbd>impl</kbd> keyword, then they have the name of the type that we want to place our functions <em>inside of</em>, and then the functions we want to add to the data type, between the <kbd>{</kbd> and <kbd>}</kbd> symbols.</p>
<p>While we can access functions that were implemented on a type as if they were variables contained in data values of that type, they're not actually stored within the memory holding the data value. There's no need for each data value to have copies of the functions, since the copies would all be identical anyway.</p>
<p>Functions implemented on a type can be public or private, depending on whether we want them to be used by external users of the data type, or only by other functions within the current module.</p>
<p>When a function is implemented on a type, the first parameter is special. It's automatically provided to the function, even though it is not passed as a function parameter when we call the function. This automatic parameter is traditionally called <kbd>self</kbd>. It is the job of <kbd>self</kbd> to give the function access to the data value that it is being called through, meaning that if we do something like <kbd>"127.0.0.1".parse()</kbd>, the parse function receives <kbd>"127.0.0.1"</kbd> as its <kbd>self</kbd> parameter. The <kbd>self</kbd> parameter can be written as <kbd>self</kbd>, <kbd>&amp;self</kbd>, or <kbd>&amp;mut self</kbd>, a choice that we'll discuss in the next chapter.</p>
<p>The syntax of an implementation block allows us to specify which data type we're implementing functions on. Could we implement functions on types we didn't create, such as <kbd>i32</kbd> or <kbd>SocketAddr</kbd>? The answer is yes, but only if we create a <em>trait</em>. We'll see more about traits in <a href="6c390ac8-f3c8-495d-a97a-29426925531a.xhtml" target="_blank"/><a href="6c390ac8-f3c8-495d-a97a-29426925531a.xhtml" target="_blank">Chapter 5</a>, <em>One data Type Representing Multiple Kinds of Data</em>. Without using traits, we're only able to implement functions on data types we created within the same project, although they do not have to be in the same module.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>As we put the things we've learned in this chapter into practice, our grasp on them will solidify. We've learned about the basic structure of Rust programs, as well as how to write functions, loops, and branches. In addition, we've learned about Rust's type system and how to attach behavior to a data type. These things give us a foundation to build on, while we learn about the things that make Rust truly different from other programming languages.</p>
<p>In the next chapter, we're going to look at how the fundamental Rust concepts of ownership and borrowing work.</p>


            

            
        
    </div>



  </body></html>