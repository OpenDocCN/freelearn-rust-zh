<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Structuring Data and Matching Patterns</h1></div></div></div><p>Until now we have only used simple data, but to do real programming, more composite and structured data values are needed. Among them are flexible arrays and tuples, enums, and structs that represent more object-like behavior, similar to that found in classical object-oriented languages. Options are another important type that are used to ensure that cases where no value is returned are accounted for. Then, we will look at pattern matching, which is another typical functional construct in Rust. However, we will start by looking more carefully at strings. We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Strings</li><li class="listitem">Arrays, vectors, and slices</li><li class="listitem">Tuples</li><li class="listitem">Structs</li><li class="listitem">Enums</li><li class="listitem">Getting input from the console</li><li class="listitem">Matching patterns</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Strings</h1></div></div></div><p>The way Rust works with<a id="id115" class="indexterm"/> strings differs a bit to how strings work in other languages. All strings are valid sequences of Unicode (UTF-8) bytes. They can contain null bytes, but they are not null terminated as in C. Rust distinguishes two types of strings:</p><div><ul class="itemizedlist"><li class="listitem">Literal strings, which<a id="id116" class="indexterm"/> we have used until now, are string slices whose<a id="id117" class="indexterm"/> type is <code class="literal">&amp;str</code>. The <code class="literal">&amp;</code> character points out that the string slice is a reference to a string. They are immutable and have a fixed size. For example, the following bindings declare string slices:<div><pre class="programlisting">// from Chapter 4/code/strings.rs
   let magician1 = "Merlin";
   let greeting = "Hello, 世界!";</pre></div><p>Otherwise, we care to explicitly annotate the string variable with its type:</p><div><pre class="programlisting">
<strong>   let magician2: &amp;'static str = "Gandalf";</strong>
</pre></div><p>The <code class="literal">&amp;'static</code> command <a id="id118" class="indexterm"/>denotes that the string is statically allocated. We<a id="id119" class="indexterm"/> saw this notation earlier in <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <em>Using Variables and Types</em>, when we declared global string constants. In that case, indicating the type was mandatory, but for a let binding, it is superfluous because the compiler infers the type:</p><div><pre class="programlisting">println!("Magician {} greets magician {} with {}", 
        magician1, magician2, greeting);</pre></div><p>Prints out: <code class="literal">Magician Merlin greets magician Gandalf with Hello, </code>
<code class="literal">世界</code>
<code class="literal">!</code>
</p><p>These strings live as long as the program; they have the lifetime of the program, which is the static lifetime. They are described in the <code class="literal">std::str</code> module.</p></li><li class="listitem">A <code class="literal">String</code> on the other hand can grow dynamically in size (it is in fact a buffer), and so it must be allocated on the heap. We can create an empty string with the following snippet:<div><pre class="programlisting">
<strong>      let mut str1 = String::new();</strong>
</pre></div><p>Each time the string grows, it has to be reallocated in the memory. So, for example, if you know that it will start out as 25 bytes , you can create the string by allocating this amount of memory as follows:</p><div><pre class="programlisting">
<strong>      let mut str2 = String::with_capacity(25);</strong>
</pre></div><p>This type is described in the <code class="literal">std::string</code> module. To convert a string slice into a String, use the <code class="literal">to_string</code> method:</p><div><pre class="programlisting">
<strong>      let mut str3 = magician1.to_string();</strong>
</pre></div><p>The <code class="literal">to_string()</code> method can be used to convert any object into a <code class="literal">String</code> (more precisely, any object that implements the <code class="literal">ToString</code> trait; we will talk about traits in the next chapter). This method allocates memory on the heap.</p><p>If <code class="literal">str3</code> is a String, then you can make a string slice from it with <code class="literal">&amp;str3</code> or <code class="literal">&amp;str3[..]</code>:</p><div><pre class="programlisting">
<strong>      let sl1 = &amp;str3;</strong>
</pre></div></li></ul></div><p>A string slice<a id="id120" class="indexterm"/> created this way can be considered as a view into the <code class="literal">String</code>. It is a reference to the interior of the String and making it has no cost involved.</p><p>I prefer this way instead of <code class="literal">to_string()</code> when comparing strings because using <code class="literal">&amp;[..]</code> doesn't consume resources while <code class="literal">to_string()</code> allocates heap memory:</p><div><pre class="programlisting">  if &amp;str3[] == magician1 {
    println!("We got the same magician alright!")
  }</pre></div><p>To build a String, we can use a number of methods, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">push</code> method: This appends a character to the String</li><li class="listitem">The <code class="literal">push_str</code> method: This appends another string to the String</li></ul></div><p>You can see them in action in the following code snippet:</p><div><pre class="programlisting">let c1 = '<code class="literal">q</code>';  // character c1
<strong>str1.push(c1);</strong>
println!("{}", str1); // <code class="literal">q</code>
<strong>str1.push_str(" Level 1 is finished - ");</strong>
println!("{}", str1); // <code class="literal">q</code> Level 1 is finished - 
str1.push_str("Rise up to Level 2");
println!("{}", str1); // <code class="literal">q</code> Level 1 is finished - Rise up to Level 2</pre></div><p>If you need to get the characters of a <code class="literal">String</code> one by one and in order, use the <code class="literal">chars()</code> method. This method returns an <code class="literal">Iterator</code>, so we can use the for in loop (see the <em>Looping</em> section of <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <em>Using Variables and Types</em>):</p><div><pre class="programlisting">
<strong>for c in magician1.chars() {</strong>
    print!("{} - ", c); 
} </pre></div><p>Which prints out: <code class="literal">M - e - r - l - i - n -</code>.</p><p>To loop over the parts of a <code class="literal">String</code> that are separated by whitespace, we can use the <code class="literal">split()</code> method, which also returns an <code class="literal">Iterator</code>:</p><div><pre class="programlisting">
<strong> for word in str1.split(" ") {</strong>
<strong>     print!("{} / ", word);</strong>
<strong> }</strong>
</pre></div><p>Which prints out: <code class="literal">q</code>
<code class="literal"> / Level / 1 / is / finished / - / Rise / up / to / Level / 2 /</code>.</p><p>To change the first part of a <code class="literal">String</code> that matches with another string, use the <code class="literal">replace</code> method:</p><div><pre class="programlisting">
<strong>let str5 = str1.replace("Level", "Floor");</strong>
</pre></div><p>This code allocates new memory for the modified <code class="literal">str5</code> string.</p><p>When you write a function that takes a string as an argument, always declare it as a string slice, which is a view into the string, as shown in the following code snippet:</p><div><pre class="programlisting">  fn how_long(s: &amp;str) -&gt; usize { s.len() }</pre></div><p>The reason for this is that passing a String <code class="literal">str1</code> as argument allocates memory, so we better pass it as a slice. The easiest and most elegant way to do this is as follows:</p><div><pre class="programlisting">println!("Length of str1: {}", how_long(&amp;str1));</pre></div><p>Or:</p><div><pre class="programlisting">println!("Length of str1: {}", how_long(&amp;str1[..]));</pre></div><p>Consult the <a id="id121" class="indexterm"/>documentation at <a class="ulink" href="http://doc.rust-lang.org/std/str/">http://doc.rust-lang.org/std/str/</a> and <a class="ulink" href="http://doc.rust-lang.org/std/string/">http://doc.rust-lang.org/std/string/</a> for more functionality. Here is a schema to see the difference between the two string types more clearly:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>String</p>
</th><th valign="bottom">
<p>String slice (&amp;str)</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>mutable – heap memory allocation</p>
<p>module: std::string</p>
</td><td valign="top">
<p>fixed size – view on String – reference(&amp;)</p>
<p>module: std::str</p>
</td></tr></tbody></table></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Arrays, vectors, and slices</h1></div></div></div><p>Suppose we have a <a id="id122" class="indexterm"/>bunch of alien creatures to populate a game level, then we would probably want to store their names in a handy list. Rust's array is just what we need:</p><div><pre class="programlisting">// from Chapter 4/code/arrays.rs
<strong>let aliens = ["Cherfer", "Fynock", "Shirack", "Zuxu"];</strong>
<strong>println!("{:?}", aliens);</strong>
</pre></div><p>To make an array, separate the different items by commas and enclose the whole thing within <code class="literal">[ ]</code> (rectangular brackets). All the items must be of the same type. Such an array must be of a fixed size (this must be known at compile time) and cannot be changed; this is stored in one contiguous piece of memory.</p><p>If the items have to be modifiable, declare your array with <code class="literal">let mut</code>; however, even then the number of items cannot change. The aliens array could be of the type that is annotated as <code class="literal">[&amp;str; 4]</code> where the first parameter is the type of the items and the second is their number:</p><div><pre class="programlisting">let aliens: [&amp;str; 4] = ["Cherfer", "Fynock", "Shirack", "Zuxu"];</pre></div><p>If we want to initialize an array with three <code class="literal">Zuxus</code>, that's easy too:</p><div><pre class="programlisting">let zuxus = ["Zuxu"; 3];</pre></div><p>How would you then make an empty array? This is shown as follows:</p><div><pre class="programlisting">let mut empty: [i32; 0] = [];
println!("{:?}", empty); // []</pre></div><p>We can also access <a id="id123" class="indexterm"/>individual items with their index, starting from 0:</p><div><pre class="programlisting">println!("The first item is: {}", aliens[0]); // Cherfer
println!("The third item is: {}", aliens[2]); // Shirack</pre></div><p>The number of items in the array is given by <code class="literal">aliens.len()</code>; so, how would you get the last item? Exactly! By using <code class="literal">aliens[aliens.len() - 1]</code>. Alternatively, this can be found by using <code class="literal">aliens.iter().last().unwrap();</code>.</p><p>Pointers to arrays use automatic dereferencing so that you do not need to use <code class="literal">*</code> explicitly, as demonstrated in this code snippet:</p><div><pre class="programlisting">
<strong>let pa = &amp;aliens;</strong>
println!("Third item via pointer: {}", pa[2]);</pre></div><p>Which prints: <code class="literal">Third item via pointer: Shirack</code>. What do you think will happen when we try to change an item as follows:</p><div><pre class="programlisting">aliens[2] = "Facehugger";</pre></div><p>Hopefully, you didn't think that Rust would allow this, did you? Unless you told it explicitly that aliens can change with let <code class="literal">mut aliens = […];</code> then it is alright!</p><p>The index is also checked at runtime to be within the array bounds of 0 and <code class="literal">aliens.len();</code> if it is not, the program will crash with a runtime error or panic:</p><div><pre class="programlisting">println!("This item does not exist: {}", aliens[10]); // runtime error:</pre></div><p>It gives the following output:</p><div><pre class="programlisting">thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 4 but the index is 10'</pre></div><p>If we want to go through the items successively one by one and print them out or do something useful with them, we can do it as follows:</p><div><pre class="programlisting">
<strong>for ix in 0..aliens.len() {</strong>
<strong>    println!("Alien no {} is {}", ix, aliens[ix]);</strong>
<strong>}</strong>
</pre></div><p>This works and it gives us the index for each item, which might be useful. However, when we use the index to fetch each consecutive item, Rust also has to check each time whether we are still within the bounds of the array in memory. That's why this is not very efficient, and in the <em>Iterators</em> section of <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <em>Generalizing Code with Higher-order Functions and Parametrization</em>, we<a id="id124" class="indexterm"/> will see a much more efficient way by iterating over the items as follows:</p><div><pre class="programlisting">
<strong>for a in aliens.iter() {</strong>
<strong>    println!("The next alien is {}", a); </strong>
<strong>}</strong>
</pre></div><p>The <code class="literal">for</code> loop can be written even shorter as follows:</p><div><pre class="programlisting">
<strong>for a in &amp;aliens  { … }</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Vectors</h2></div></div></div><p>Often, it is more practical to<a id="id125" class="indexterm"/> work with a kind of array that can grow (or shrink) in size because it is allocated on the heap. Rust provides this through the <code class="literal">Vec</code> vector type from the <code class="literal">std::vec</code> module. This is a generic type, which means that the items can have any <code class="literal">T</code> type, where <code class="literal">T</code> is specified in the code; for example, we can have vectors of the <code class="literal">Vec&lt;i32&gt;</code> type or the <code class="literal">Vec&lt;&amp;str&gt;</code> type. To indicate that this is of the generic type, it is written as <code class="literal">Vec&lt;T&gt;</code>. Again, all elements must be of the same <code class="literal">T</code> type. We can make a vector in two ways, with <code class="literal">new()</code> or with the <code class="literal">vec!</code> macro. These are shown here:</p><div><pre class="programlisting">let mut numbers: Vec&lt;i32&gt; = Vec::new();
let mut magic_numbers = vec![7i32, 42, 47, 45, 54];</pre></div><p>In the first case, the type is indicated explicitly with <code class="literal">Vec&lt;i32&gt;</code>; in the second case, this is done by giving the first item an <code class="literal">i32</code> suffix, but this is usually optional.</p><p>We can also make a new vector and allocate an initial memory size to it, which can be useful if you know in advance that you will need at least that many items. The following initializes a vector for signed integers with a memory allocated for 25 integers:</p><div><pre class="programlisting">let mut ids: Vec&lt;i32&gt; = Vec::with_capacity(25);</pre></div><p>We need to provide the type here, otherwise the compiler would not be able to calculate the amount of memory needed.</p><p>A vector can also be constructed from an iterator through the <code class="literal">collect()</code> method with a range, such as in this example:</p><div><pre class="programlisting">
<strong>let rgvec: Vec&lt;u32&gt; = (0..7).collect();</strong>
println!("Collected the range into: {:?}", rgvec);</pre></div><p>which prints out: <code class="literal">Collected the range into: [0, 1, 2, 3, 4, 5, 6]</code>.</p><p>Indexing, getting the length, and looping over a vector works the same as with arrays. For example, a <code class="literal">for</code> loop over a vector can be written simply as follows:</p><div><pre class="programlisting">let values = vec![1, 2, 3];
<strong>for n in values {</strong>
      println!("{}", n);
}</pre></div><p>Add a new item to the end of a vector with <code class="literal">push()</code>, remove the last item with <code class="literal">pop()</code>:</p><div><pre class="programlisting">numbers.push(magic_numbers[1]);
<strong>numbers.push(magic_numbers[4]);</strong>
println!("{:?}", numbers); // [42, 54]
<strong>let fifty_four = numbers.pop();// fifty_four now contains 54</strong>
println!("{:?}", numbers); // [42]</pre></div><p>If a function needs to return<a id="id126" class="indexterm"/> many values of the same type, you can make an array or vector with these values and return that object.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Slices</h2></div></div></div><p>What would you do if you want to do <a id="id127" class="indexterm"/>something with a part of an array or a vector? Perhaps, your first idea is to copy that part out to another array, but Rust has a safer and more efficient solution; take a slice of the array. No copy is needed, instead you get a view into the existing array, similar to how a string slice is a view into a string.</p><p>As an example, suppose I only need the numbers 42, 47, and 45 from our <code class="literal">magic_numbers</code> vector. Then, I can take the following slice:</p><div><pre class="programlisting">
<strong>let slc = &amp;magic_numbers[1..4]; // only the items 42, 47 and 45</strong>
</pre></div><p>The starting index 1 is the index of 42, the last index 4 points to 54, but this item is not included. The <code class="literal">&amp;</code> shows that we are referencing an existing memory allocation. Slices share the following with vectors:</p><div><ul class="itemizedlist"><li class="listitem">They are generic and have the <code class="literal">&amp;[T]</code> type for a <code class="literal">T</code> type</li><li class="listitem">Their size does not have to be known at compile time</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Strings and arrays</h2></div></div></div><p>Back in the first section of this chapter, we saw<a id="id128" class="indexterm"/> that the sequence of characters in a <code class="literal">String</code> is<a id="id129" class="indexterm"/> given by the <code class="literal">chars()</code> function. Doesn't this look like an array to you? A <code class="literal">String</code> is backed up by an array if we look at the memory allocation of its characters; it is stored as a vector of bytes <code class="literal">Vec&lt;u8&gt;</code>.</p><p>This means that we can also take a slice of the <code class="literal">&amp;str</code> type from a <code class="literal">String</code>:</p><div><pre class="programlisting">let location = "Middle-Earth";
let part = &amp;location[7..12];
println!("{}", part); // Earth</pre></div><p>We can collect the characters of a slice into a vector and sort them as follows:</p><div><pre class="programlisting">let magician = "Merlin";
let mut chars: Vec&lt;char&gt; = magician.chars().collect();
chars.sort();
for c in chars.iter() {
      print!("{} ", c);
}</pre></div><p>This prints out <code class="literal">M e i l n r</code> (capital letters come before small letters in the sort order). Here are some other examples of using the <code class="literal">collect()</code> method:</p><div><pre class="programlisting">let v: Vec&lt;&amp;str&gt; = "The wizard of Oz".split(' ').collect();
let v: Vec&lt;&amp;str&gt; = "abc1def2ghi".split(|c: char| c.is_numeric()).collect();</pre></div><p>Here, <code class="literal">split()</code> takes a<a id="id130" class="indexterm"/> closure to determine on which character to split. Both the <a id="id131" class="indexterm"/>slice types, <code class="literal">&amp;str</code> and <code class="literal">&amp;[T]</code>, can be seen as views into <code class="literal">Strings</code> and vectors respectively. The following scheme compares the types that we just encountered (<code class="literal">T</code> denotes a generic type):</p><div><table border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Fixed-size </p>
<p>(stack allocated)</p>
</th><th valign="bottom">
<p>Slices </p>
</th><th valign="bottom"> </th><th valign="bottom">
<p>Dynamic size (growable) </p>
<p>(heap allocated)</p>
</th></tr></thead><tbody><tr><td valign="top"> </td><td valign="top">
<p>
<code class="literal">&amp;str</code>
</p>
<p>
<code class="literal">type: &amp;[u8]</code>
</p>
</td><td valign="top">
<p>is a view into</p>
</td><td valign="top">
<p>
<code class="literal">String</code>
</p>
</td></tr><tr><td valign="top">
<p>array type: <code class="literal">[T;size]</code>
</p>
</td><td valign="top">
<p>slice type: <code class="literal">&amp;[T]</code>
</p>
</td><td valign="top">
<p>is a view into</p>
</td><td valign="top">
<p>Vector type: <code class="literal">Vec&lt;T&gt;</code>
</p>
</td></tr></tbody></table></div><p>Perform the following exercise by referring to <code class="literal">Chapter 4/exercises/chars_string.rs</code>:</p><div><ul class="itemizedlist"><li class="listitem">Try out whether you can get the first or the fifth character of a string by using <code class="literal">[0]</code> or <code class="literal">[4]</code></li><li class="listitem">Compare the <code class="literal">bytes()</code> method with <code class="literal">chars()</code> on the <code class="literal">let greeting = "Hello, </code><code class="literal">世界</code><code class="literal">!";</code> string</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Tuples</h1></div></div></div><p>If you want to combine a certain<a id="id132" class="indexterm"/> number of values of different types, then you can collect them in a tuple, which is enclosed between parentheses (<code class="literal">( )</code>) and separated by commas, as follows:</p><div><pre class="programlisting">// from Chapter 4/code/tuples.rs
<strong>let thor = ("Thor", true, 3500u32);</strong>
println!("{:?}", thor); // ("Thor", true, 3500)</pre></div><p>The type of <code class="literal">thor</code> is <code class="literal">(&amp;str, bool, u32)</code>, that is: the tuple of the item's types. To extract an item on an index, use a dot-syntax:</p><div><pre class="programlisting">
<strong>println!("{} - {} - {}", thor.0, thor.1, thor.2);</strong>
</pre></div><p>Another way to extract items to other variables is by <em>destructuring</em> the tuple:</p><div><pre class="programlisting">let (name, _, power) = thor;
<strong>println!("{} has {} points of power", name, power);</strong>
</pre></div><p>Which prints out: <code class="literal">Thor has 3500 points of power</code>.</p><p>Here the <code class="literal">let</code> statement matches the pattern on the left with the right-hand side. The <code class="literal">_</code> indicates that we are not interested in the second item of <code class="literal">thor</code>.</p><p>Tuples can only be assigned to one another or compared with each other if they are of the same<a id="id133" class="indexterm"/> type. A one-element tuple needs to be written: <code class="literal">let one = (1,);</code>.</p><p>A function that needs to return some values of different types can collect them in a tuple and return that tuple as follows:</p><div><pre class="programlisting">fn increase_power(name: &amp;str, power: u32) -&gt; (&amp;str, u32) {
  if power &gt; 1000 {
    return (name, power * 3);
  } else {
    return (name, power * 2);
  }
}</pre></div><p>If we call this with the following code snippet:</p><div><pre class="programlisting">let (god, strength) = increase_power(thor.0, thor.2);
println!("This god {} has now {} strength", god, strength);</pre></div><p>The output is: <code class="literal">This god Thor has now 10500 strength</code>.</p><p>Perform the following exercise by referring to the code at <code class="literal">Chapter 4/exercises/tuples_ex.rs)</code>:</p><div><ul class="itemizedlist"><li class="listitem">Try to compare the tuples (2, 'a') and (5, false) and explain the error message.</li><li class="listitem">Make an empty tuple. Haven't we encountered this before? So, the unit value is in fact an empty tuple!</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Structs</h1></div></div></div><p>Often, you might need to keep<a id="id134" class="indexterm"/> several values of possibly different types together in your program; for example, the scores of the players. Let us assume that the score contains numbers that indicate the health of the players and the level at which they are playing. The first thing that you can then do to clarify your code is to give these tuples a common name, such as struct Score or better still, you can indicate the types of the values: <code class="literal">struct Score(i32, u8)</code> and we can make a score as follows:</p><div><pre class="programlisting">   let score1 = Score(73, 2);</pre></div><p>These are called tuple structs because they resemble tuples very much. The values contained in them can be extracted as follows:</p><div><pre class="programlisting">  // from Chapter 4/code/structs.rs
  let Score(h, l) = score1; // destructure the tuple
  println!("Health {} - Level {}", h, l);</pre></div><p>Which prints out: <code class="literal">Health 73 - Level 2</code>.</p><p>A tuple struct with only one<a id="id135" class="indexterm"/> field (called a newtype) gives us the possibility to create a new type that is based on an old one so that both have the same memory representation. Here is an example:</p><div><pre class="programlisting">struct Kilograms(u32);
let weight = Kilograms(250);
let Kilograms(kgm) = weight; // extracting kgm
println!("weight is {} kilograms", kgm);</pre></div><p>This prints: <code class="literal">weight is 250 kilograms</code>.</p><p>However, we will still have to remember what these numbers mean and to which players they belong. We can make coding much simpler by defining a struct with named fields:</p><div><pre class="programlisting">   struct Player {
      nname: &amp;'static str, // nickname
      health: i32,
      level: u8
  }</pre></div><p>This could be defined inside <code class="literal">main()</code> or outside it, although the latter is preferred. Now, we can make player instances or objects as follows:</p><div><pre class="programlisting">
<strong>let mut pl1 = Player{ nname: "Dzenan", health: 73, level: 2 };</strong>
</pre></div><p>Note the curly braces (<code class="literal">{ }</code>) around the object and the <code class="literal">key: value</code> syntax. The <code class="literal">nname</code> field is a constant string, and Rust requires that we indicate its lifetime, how long this string will be needed in the program. We used the global scope, <code class="literal">&amp;'static</code>, from the <em>Global constants</em> section in <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <em>Using Variables and Types</em>.</p><p>We can access the fields of the instance with the dot-notation:</p><div><pre class="programlisting">
<strong>println!("Player {} is at level {}", pl1.nname, pl1.level); </strong>
</pre></div><p>The struct variable has to be declared as mutable if the field values can change; for example, when the player enters a new level:</p><div><pre class="programlisting">  pl1.level = 3;</pre></div><p>By convention, the name of a struct always starts with a capital letter and follows CamelCase. It also defines a type of its own, which is composed of the types of its items.</p><p>Like tuples, structs can also be destructured in a <code class="literal">let</code> binding, for example:</p><div><pre class="programlisting">
<strong>let Player{ health: ht, nname: nn, .. } = pl1; </strong>
println!("Player {} has health {}", nn, ht); </pre></div><p>Which prints out: <code class="literal">Player Dzenan has health 73</code>. This shows that you can rename fields, reorder them if you want, or leave fields out with.</p><p>Pointers carry out automatic dereferencing when accessing data structure elements, as follows:</p><div><pre class="programlisting">    let ps = &amp;Player{ nname: "John", health: 95, level: 1 };
    println!("{} == {}", ps.nname, (*ps).nname);</pre></div><p>Structs are quite similar to the records or structs in C or even classes in other languages. In <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <em>Generalizing Code with Higher-order Functions and Parametrization</em>, we will see how we can define methods on structs.</p><p>Perform the following<a id="id136" class="indexterm"/> exercise by referring to the code in <code class="literal">Chapter 4/exercises/monster.rs</code>:</p><div><ul class="itemizedlist"><li class="listitem">Define a <code class="literal">Monster</code> struct with the health and damage fields. Then, make a <code class="literal">Monster</code> and show its condition.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Enums</h1></div></div></div><p>If something can be only one of a <a id="id137" class="indexterm"/>limited number of named values, then define it as an enum. For example, if our game needs the compass directions, we could define it as follows:</p><div><pre class="programlisting">// from Chapter 4/code/enums.rs
<strong>enum Compass {</strong>
<strong>  North, South, East, West</strong>
<strong>}</strong>
</pre></div><p>And then use it as shown in <code class="literal">main()</code> or another function:</p><div><pre class="programlisting">  let direction = Compass::West;</pre></div><p>The enum's values can also be of other types or structs, as in this example:</p><div><pre class="programlisting">type species = &amp;'static str;

enum PlanetaryMonster {
  VenusMonster(species, i32),
  MarsMonster(species, i32)
}
let martian = PlanetaryMonster::MarsMonster("Chela", 42);</pre></div><p>Enums are sometimes called union types or algebraic data types in other languages. If we make a <code class="literal">use</code> function at the start of the code file:</p><div><pre class="programlisting">use PlanetaryMonster::MarsMonster;</pre></div><p>Then, the type can be shortened, as follows:</p><div><pre class="programlisting">let martian = MarsMonster("Chela", 42);</pre></div><p>Enums are really nice to <a id="id138" class="indexterm"/>bring clarity in your code, and they are used a lot in Rust. To apply them usefully in code, see the <em>Matching patterns</em> section of this chapter.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Result and Option</h2></div></div></div><p>Here, we look at two kinds<a id="id139" class="indexterm"/> of enums that are pervasive in a Rust code. A <em>Result</em> is a <a id="id140" class="indexterm"/>special kind<a id="id141" class="indexterm"/> of enum that is defined in the standard library. It is used whenever something is executed, that can either end:</p><div><ul class="itemizedlist"><li class="listitem">Successfully, then an <code class="literal">Ok</code> value (of a certain type <code class="literal">T</code>) is returned</li><li class="listitem">With an error, then an <code class="literal">Err</code> value (of type <code class="literal">E</code>) is returned</li></ul></div><p>Since this situation is so common, provision is made so that the value <code class="literal">T</code> and error <code class="literal">E</code> types can be as general or generic as possible. The Result enum is defined as follows:</p><div><pre class="programlisting">
<strong>enum Result&lt;T, E&gt; {</strong>
<strong>    Ok(T),</strong>
<strong>    Err(E)</strong>
<strong>}</strong>
</pre></div><p>An <em>Option</em> is another enum <a id="id142" class="indexterm"/>that is defined in the standard library. It is used whenever there is a value, but there can also be a possibility that there is no value. For example, suppose our program expects to read a value from the console. However, when it is run as a background program by accident, it will never get an input value. Rust wants to be on the safe side whenever it is possible, so in this case, it is better to read the value as an Option enum with two possibilities:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Some</code>, if there is a value</li><li class="listitem"><code class="literal">None</code>, if there is no value</li></ul></div><p>This value can be of any type <code class="literal">T</code>, so option again is defined as a generic type:</p><div><pre class="programlisting">
<strong>enum Option&lt;T&gt; {</strong>
<strong>   Some(T),</strong>
<strong>   None</strong>
<strong>}</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Getting input from the console</h1></div></div></div><p>Suppose we want to capture the<a id="id143" class="indexterm"/> nicknames of our players before starting the game; how <a id="id144" class="indexterm"/>would we do that? Input/output functionality is handled by the <code class="literal">io</code> module in the <code class="literal">std</code> crate. It has a <code class="literal">stdin()</code> function to read input from the console. This function returns an object of the <code class="literal">Stdin</code> type, which is a reference to the input stream. <code class="literal">Stdin</code> has a <code class="literal">read_line(buf)</code> method to read a full line of input that ends with a new line character (when the user hits <em>Enter</em>). This input is read into a String buffer, <code class="literal">buf</code>. A method is a name for a function that is defined for a certain type, and it is called using dot notation, such as <code class="literal">object.method</code> (see <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <em>Generalizing Code with Higher-order Functions and Parametrization</em>).</p><p>So, our code will look as follows:</p><div><pre class="programlisting">let mut buf = String::new();
io::stdin().read_line(&amp;mut buf); </pre></div><p>However, this is not good enough for Rust; it gives us the warning, <code class="literal">unused result which must be used</code>. Rust is foremost a safe language and we must be ready to cope with everything than can occur. Reading a line might work and supply the input value, but it can also fail; for example, if this code was running in the background on a machine so that no console was available to get input from.</p><p>How will you cope with this? Well, <code class="literal">read_line()</code> returns a Result value, which can either be a real value (an <code class="literal">Ok</code>) when everything works fine or an error value (an <code class="literal">Err</code>) when there is a problem. To cope with a possible error, we need an <code class="literal">ok()</code> function and an <code class="literal">expect()</code> function; <code class="literal">ok()</code> converts the Result into an Option value (which contains how many bytes were read) and <code class="literal">expect()</code> gives this value or shows its message when an error occurs. In Rust, a program panics when an error occurs that cannot be recovered from, and the string argument from <code class="literal">expect()</code> is displayed to tell us where it occurred.</p><p>This is written in Rust in a chained form (and is a bit unusual the first time you see it) as follows:</p><div><pre class="programlisting">io::stdin().read_line(&amp;mut buf).ok().expect("Error!");</pre></div><p>Rust allows us to write these successive calls on separate lines, which clarifies the code a lot for most people:</p><div><pre class="programlisting">   // from Chapter 4/code/input.rs
use std::io;

fn main() {
  println!("What's your name, noble warrior?");
  let mut buf = String::new();
  io::stdin().read_line(&amp;mut buf)
      .ok()
      .expect("Failed to read line");
  println!("{}, that's a mighty name indeed!", buf);
}</pre></div><p>When we run this code from the command line, we get the following conversation:</p><div><pre class="programlisting">
<strong>What's your name, noble warrior?</strong>
<strong>Riddick</strong>
<strong>Riddick</strong>
<strong>, that's a mighty name indeed!</strong>
</pre></div><p>Can you guess why <code class="literal">that's a mighty name indeed!</code> appears on a new line? This is because the input <code class="literal">buf</code> still contains a newline character, <code class="literal">\n!</code> Luckily, we have a <code class="literal">trim()</code> method to remove trailing and <a id="id145" class="indexterm"/>leading whitespace from a string. If we insert the line<a id="id146" class="indexterm"/> shown in the following snippet:</p><div><pre class="programlisting">
<strong>let name = buf.trim();</strong>
println!("{}, that's a mighty name indeed!", name);</pre></div><p>We now get a correct output: <code class="literal">Riddick, that's a mighty name indeed!</code>
</p><p>In case the input does not succeed, our program will crash with the following output:</p><div><pre class="programlisting">What's your name, noble warrior?
thread '&lt;main&gt;' panicked at 'Failed to read line </pre></div><p>How would we read in a positive integer number from the console?</p><div><pre class="programlisting">// from Chapter 4/code/pattern_match.rs
<strong>let mut buf = String::new();</strong>
<strong>io::stdin().read_line(&amp;mut buf)</strong>
<strong>    .ok()</strong>
<strong>    .expect("Failed to read number");</strong>
<strong>let input_num: Result&lt;u32, _&gt; = buf.trim().parse();</strong>
</pre></div><p>We read the number in from the console in a <code class="literal">buf</code> String buffer and <code class="literal">trim()</code> the value; <code class="literal">expect()</code> will show us the message if something goes wrong. However, what we have read in is still a <code class="literal">String</code>, so we must convert the <code class="literal">String</code> to a number.</p><p>The <code class="literal">parse()</code> method tries to convert the input to an unsigned 32-bit integer in this case. What it returns is in fact a Result value again; this can either be an integer (<code class="literal">Ok&lt;u32&gt;</code>) or an error (<code class="literal">Err</code>) when the conversion fails.</p><p>We will encounter more examples of Option and Result in the <em>Generics</em> section of <em>Chapter 5</em>, <em>Generalizing Code with Higher-order Functions and Parametrization</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Matching patterns</h1></div></div></div><p>But how will we test <a id="id147" class="indexterm"/>whether <code class="literal">input_num</code> from the previous section, which is of the Result type, contains a value or not? When the value is an <code class="literal">Ok(T)</code> function, the <code class="literal">unwrap()</code> function can extract <code class="literal">T</code> like this:</p><div><pre class="programlisting">
<strong>println!("Unwrap found {}", input_num.unwrap());</strong>
</pre></div><p>Which prints: <code class="literal">Unwrap found 42</code>. However, when the result is an <code class="literal">Err</code> value, this lets the program crash with a panic, which is <code class="literal">thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value'</code>. This is bad!</p><p>To solve this, no complex if – else constructs will be enough; we need Rust's magical match here, which has a lot more possibilities than the switch in other languages, and is used frequently when handling errors:</p><div><pre class="programlisting">
<strong>match input_num {</strong>
<strong>   Ok(num) =&gt; println!("{}", num),</strong>
<strong>   Err(ex) =&gt; println!("Please input an integer number! {}", ex)</strong>
<strong>};</strong>
</pre></div><p>The <code class="literal">match</code> function tests the value of an expression against all possible values. Only the code (which can be a block) after the <code class="literal">=&gt;</code> of the first matching branch is executed. All branches are separated by commas. In this case, the same number that is given as input is printed out. There is no fall through from one branch to the next, so a break statement is not necessary; this enables us to avoid a common bug in C++.</p><p>In order to continue working with the return value of <code class="literal">match</code>, we have to bind that value to a variable, which is possible because match itself is an expression:</p><div><pre class="programlisting">
<strong>let num = match input_num {</strong>
        Ok(num) =&gt; num,
        Err(_)  =&gt; 0
}; </pre></div><p>This <code class="literal">match</code> extracts the number from <code class="literal">input_num</code> so that we can compare it with other numbers or calculate with it. Both branches must return a value of the same type; this is why we returned <code class="literal">0</code> in the <code class="literal">Err</code> case (supposing we expect a number greater than 0).</p><p>An alternative way to get the Result or Option value is by using the <code class="literal">if let</code> construct as follows:</p><div><pre class="programlisting">
<strong>if let Ok(val) = input_num {</strong>
    println!("Matched {:?}!", val);
} else {
    println!("No match!");
}</pre></div><p>The <code class="literal">input_num</code> function is destructured and if it contains a value <code class="literal">val</code>, this is extracted. In certain cases, this can simplify the code, but you lose the exhaustive match check. The same principle can be applied inside a <code class="literal">while</code> loop as follows:</p><div><pre class="programlisting">
<strong>while let Ok(val) = input_num {</strong>
    println!("Matched {:?}!", val);
    if val == 42 { break }
}</pre></div><p>With <code class="literal">match</code>, all possible values must be covered, which is the case if we match with a Result, Option (<code class="literal">Some</code> or <code class="literal">None</code> is pretty exhaustive), or some other enum value.</p><p>However, look what happens when we test on a string slice for example:</p><div><pre class="programlisting">// from Chapter 4/code/pattern_match2.rs
let magician = "Gandalf";
match magician {
      "Gandalf" =&gt; println!("A good magician!"),
      "Sauron"  =&gt; println!("A magician turned bad!")
}</pre></div><p>This <code class="literal">match</code> on <code class="literal">magician</code> gives us<a id="id148" class="indexterm"/> an error: non-exhaustive patterns: <code class="literal">_</code> not covered. After all, there are other magicians besides "Gandalf" and "Sauron"! The compiler even gives us the solution: use an underscore (<code class="literal">_</code>) for all other possibilities; so, this is a complete match:</p><div><pre class="programlisting">match magician {
      "Gandalf" =&gt; println!("A good magician!"),
      "Sauron"  =&gt; println!("A magician turned bad!"),
      _         =&gt; println!("No magician turned up!")
}</pre></div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>To be always on the safe side, use match when testing on the possible values of a variable or expression!</p></div><p>The left-hand side of a branch can contain several values if they are separated by a <code class="literal">|</code> sign or an inclusive range of values written as start … end. The following code snippet shows this in action:</p><div><pre class="programlisting">let magical_number: i32 = 42;
match magical_number {
      // Match a single value
       1 =&gt; println!("Unity!"),
      // Match several values
       2 | 3 | 5 | 7 | 11 =&gt; println!("Ok, these are primes"),
      // Match an inclusive range
       40...42 =&gt; println!("It is contained in this range"),
      // Handle the rest of cases
        _ =&gt; println!("No magic at all!"),
}</pre></div><p>This prints out: <code class="literal">It is contained in this range</code>. The matched value can be captured in a variable (here <code class="literal">num</code>) using the <code class="literal">@</code> symbol as follows:</p><div><pre class="programlisting">  num @ 40...42 =&gt; println!("{} is contained in this range", num)</pre></div><p>Which prints: <code class="literal">42 is contained in this range</code>.</p><p>Matches are even more powerful than this; the expression that is being matched can be destructured on the left-hand side, and this can even be combined with the <code class="literal">if</code> conditions that are called <em>guards</em>:</p><div><pre class="programlisting"> let loki = ("Loki", true, 800u32); 
    match loki {
<strong>        (name, demi, _) if demi =&gt; {</strong>
                            print!("This is a demigod ");
                            println!("called {}", name);
                        },
<strong>        (name, _, _) if name == "Thor" =&gt; </strong>
                        println!("This is Thor!"),
<strong>        (_, _, pow) if pow &lt;= 1000 =&gt; </strong>
                        println!("This is a powerless god"),
        _ =&gt; println!("This is something else")
    }</pre></div><p>Which prints out: <code class="literal">This is a demigod called Loki</code>.</p><p>Note that since <code class="literal">demi</code> is a<a id="id149" class="indexterm"/> Boolean, we don't have to write <code class="literal">if demi == true</code>. If you want to do nothing in a branch, then write <code class="literal">=&gt; {}</code>. Destructuring works not only for tuples, like this example, but it can also be applied for structs.</p><p>Perform the following exercise:</p><p>What happens if you move the <code class="literal">_</code> branch from the last position upwards? See an example in <code class="literal">Chapter 4/exercises/pattern_match.rs</code>.</p><p>The use of the <code class="literal">..</code> and <code class="literal">...</code> notations can be confusing, so here is a summary of the situations in Rust 1.0:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th valign="bottom"> </th><th valign="bottom">
<p>What works</p>
</th><th valign="bottom">
<p>Does not work</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">for in</code>
</p>
</td><td valign="top">
<p>
<code class="literal">..</code> exclusive</p>
</td><td valign="top">
<p>
<code class="literal">...</code>
</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Match</code>
</p>
</td><td valign="top">
<p>
<code class="literal">...</code> inclusive</p>
</td><td valign="top">
<p>
<code class="literal">..</code>
</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we increased our capabilities for working with composite data in Rust, from strings, arrays and vectors, and slices of both, to tuples, structs, and enums. We also discovered that pattern matching, combined with destructuring and guards, is a very powerful tool for writing clear and elegant code.</p><p>In the following chapter, we will see that functions are much more powerful than we expected. Furthermore, we will discover that structs can have methods by implementing traits, almost like classes and interfaces in other languages.</p></div></body></html>