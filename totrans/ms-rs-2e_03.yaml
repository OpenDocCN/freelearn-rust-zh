- en: Tests, Documentation, and Benchmarks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、文档和基准
- en: In this chapter, we will continue with Cargo and learn how to write tests, how
    to document our code, and how to measure the performance of our code with benchmark
    tests. We'll then put those skills to use and build a simple crate that simulates
    logic gates, giving you an end- to-end experience of writing unit and integration
    tests, as well as documentation tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续学习Cargo，了解如何编写测试，如何编写代码文档，以及如何使用基准测试来衡量代码的性能。然后，我们将运用这些技能来构建一个简单的crate，模拟逻辑门，为您提供编写单元测试、集成测试以及文档测试的端到端体验。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Motivation on testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的动机
- en: Organizing tests and testing primitives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织测试和测试原语
- en: Unit tests and integration tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试
- en: Documentation tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档测试
- en: Benchmark tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试
- en: Continuous integration with Travis CI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Travis CI进行持续集成
- en: Motivation for testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的动机
- en: '*"Things that are impossible just take longer." **                         
                                                                                 
                                                                                 
              - **Ian Hickson*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “那些不可能的事情只是需要更长的时间。” **
- en: Software systems are like machines with small cogs and gears. If any of the
    individual gears malfunctions, the machine as a whole is most likely to behave
    in an unreliable manner. In software, the individual gears are functions, modules,
    or any libraries that you use. Functional testing of the individual components
    of a software system is an effective and practical way of maintaining high quality
    code. It doesn't prove that bugs don't exist, but it helps in building confidence
    when deploying the code to production and maintaining the sanity of the code base
    when the project is to be maintained for a long time. Furthermore, large-scale
    refactoring in software is hard to do without unit tests. The benefits of the
    smart and balanced use of unit testing in software are profound. During the implementation
    phase, a well-written unit test becomes an informal specification for components
    of the software. In the maintenance phase, the existing unit tests serve as a
    harness against regressions in the code base, encouraging an immediate fix. In
    compiled languages like Rust, this gets even better as the refactors involved
    (if any) for regressions from unit tests are more guided due to helpful error
    diagnostics from the compiler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统就像带有小齿轮和齿轮的机器。如果任何一个单独的齿轮出现故障，整个机器很可能以不可靠的方式运行。在软件中，这些单独的齿轮是函数、模块或您使用的任何库。对软件系统个别组件的功能测试是维护高质量代码的有效和实用方法。它不能证明不存在错误，但它有助于在将代码部署到生产环境中建立信心，并在项目需要长期维护时保持代码库的稳定性。此外，没有单元测试，软件的大规模重构是难以进行的。在软件中智能和平衡地使用单元测试的好处是深远的。在实现阶段，编写良好的单元测试成为软件组件的非正式规范。在维护阶段，现有的单元测试作为防止代码库回归的
    harness，鼓励立即修复。在像Rust这样的编译语言中，这甚至更好，因为由于编译器的有用错误诊断，涉及回归的单元测试（如果有）将更加有指导性。
- en: Another good side effect of unit tests is that they encourage the programmer
    to write modular code that is mostly dependent on the input parameters, that is,
    stateless functions. It moves the programmer away from writing code that depends
    on a global mutable state. Writing tests that depend on a global mutable state
    are hard to write. Moreover, the act of simply thinking about writing tests for
    a piece of code helps the programmer figure out silly mistakes in their implementation.
    They also act as very good documentation for any newcomer trying to understand
    how different parts of the code base interact with each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的另一个良好副作用是它们鼓励程序员编写模块化代码，这些代码主要依赖于输入参数，即无状态函数。这使程序员远离编写依赖于全局可变状态的代码。编写依赖于全局可变状态的测试是困难的。此外，仅仅思考为一段代码编写测试的行为就帮助程序员找出实现中的愚蠢错误。它们还作为非常好的文档，帮助任何试图理解代码库不同部分如何相互交互的新手。
- en: The takeaway is that tests are indispensable for any software project. Now,
    let's look at how we can write tests in Rust, starting by learning about organizing
    tests!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出的结论是，测试对于任何软件项目都是不可或缺的。现在，让我们来看看如何在Rust中编写测试，首先从学习组织测试开始！
- en: Organizing tests
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织测试
- en: 'At a minimum, there are two kinds of tests that we usually write when developing
    software: unit tests and integration tests. They both serve different purposes
    and interact differently with the code base under test. Unit tests are always
    meant to be lightweight, testing individual components so that the developer can
    run them often, thus providing a shorter feedback loop, while integration tests
    are heavy and are meant to simulate real-world scenarios, making assertions based
    on their environment and specification. Rust''s built-in testing framework provides
    us with sane defaults for writing and organizing these tests:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，我们通常编写两种基本的测试：单元测试和集成测试。它们服务于不同的目的，并且与被测试的代码库的交互方式也不同。单元测试总是旨在轻量级，测试单个组件，以便开发者可以经常运行它们，从而提供更短的反馈循环，而集成测试则是重量级的，旨在模拟现实世界场景，基于其环境和规范进行断言。Rust的内置测试框架为我们提供了编写和组织这些测试的合理默认值：
- en: '**Unit tests**: Unit tests are usually written within the same module that
    contains the code to be tested. When these tests increase in number, they are
    organized into one entity as a nested module. One usually creates a child module
    within the current module, names it `tests` (by convention) with an annotation
    of the  `#[cfg(test)]` attribute over it, and puts all the test-related functions
    inside of it. This attribute simply tells the compiler to include code within
    the tests module, but only when `cargo test` is run. More on attributes in a moment.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**: 单元测试通常在包含要测试的代码的同一模块中编写。当这些测试的数量增加时，它们会被组织成一个实体，作为一个嵌套模块。通常，在当前模块中创建一个子模块，按照惯例命名为`tests`，并在其上添加`#[cfg(test)]`属性，然后将所有与测试相关的函数放入其中。这个属性简单地告诉编译器在运行`cargo
    test`时包含测试模块中的代码。稍后我们将详细介绍属性。'
- en: '**Integration tests**: Integration tests are written separately in a `tests/`
    directory at the crate root. They are written as if the tests are the consumer
    of the crate being tested. Any `.rs` file within the `tests/` directory can add
    a `use` declaration to bring in any public API that needs to be tested.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**: 集成测试在crate根部的`tests/`目录中单独编写。它们被编写成好像测试是正在测试的crate的消费者。`tests/`目录中的任何`.rs`文件都可以添加一个`use`声明来引入需要测试的任何公共API。'
- en: To write any of the aforementioned tests, there are some testing primitives
    we need to be familiar with.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写上述任何一种测试，我们需要熟悉一些测试原语。
- en: Testing primitives
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试原语
- en: Rust's built-in testing framework is based on a bunch of primitives that are
    mainly composed of attributes and macros. Before we write any actual tests, it's
    important that we get familiar with how to use them effectively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的内置测试框架基于一些原语，主要由属性和宏组成。在我们编写任何实际的测试之前，了解如何有效地使用它们是非常重要的。
- en: Attributes
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'An attribute is an annotation on an item in Rust code. Items are top-level
    language constructs in a crate such as functions, modules, structs, enums, and
    constant declarations, and other things that are meant to be defined only at the
    crate root. Attributes are usually compiler built-ins, but can also be created
    by users through compiler plugins. They instruct the compiler to inject extra
    code or meaning for the item that appears below them, or for the module if they
    apply to a module. We''ll cover more on these in [Chapter 7](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml),
    *Advanced Concepts*. For the sake of keeping things in scope, we will talk about
    two forms of attributes here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是Rust代码中项目的一个注释。项目是crate中的顶级语言结构，如函数、模块、结构体、枚举和常量声明，以及其他仅在crate根定义的东西。属性通常是编译器内置的，但也可以通过编译器插件由用户创建。它们指示编译器为它们下面的项目或模块注入额外的代码或意义。我们将在[第7章](63263043-9b5e-4711-b2e2-e44240a0e843.xhtml)，*高级概念*中详细介绍这些内容。为了保持话题的连贯性，我们在这里将讨论两种属性形式：
- en: '`#[<name>]`: This applies per item and usually appears above them in their
    definition. For example, test functions in Rust are annotated with the `#[test]`
    attribute. It signifies that the function is to be treated as part of the test
    harness.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[<name>]`: 这适用于每个项目，通常出现在它们的定义上方。例如，Rust中的测试函数使用`#[test]`属性进行标注。这表示该函数被视为测试框架的一部分。'
- en: '`#![<name>]`: This applies to the whole crate. Notice that it has an extra
    `!` there. It usually goes at the very top of your crate root.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#![<name>]`: 这适用于整个crate。注意那里有一个额外的`!`。它通常位于crate根部的顶部。'
- en: If we are creating a library crate, the crate root is basically `lib.rs`, whereas
    when creating a binary crate, the crate root would be the `main.rs` file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在创建一个库crate，crate根通常是`lib.rs`，而当我们创建一个二进制crate时，crate根将是`main.rs`文件。
- en: There are also other forms of attributes such as `#[cfg(test)]` that are used
    when writing tests within a module. This attribute is added on top of test modules
    to hint to the compiler to conditionally compile the module, but only when code
    is compiled in test mode. Attributes are not just limited to being used in testing
    code; they are widely used in Rust. We'll get to see more of them in upcoming
    chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`#[cfg(test)]`这样的属性形式之外，还有其他形式的属性，这些属性在模块内编写测试时使用。这个属性被添加到测试模块的顶部，以提示编译器有条件地编译模块，但仅在测试模式下编译代码时才这样做。属性不仅限于在测试代码中使用；在Rust中它们被广泛使用。我们将在接下来的章节中看到更多关于它们的例子。
- en: Assertion macros
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言宏
- en: 'In testing, when given a test case, we try to assert the expected behavior
    of our software component on a given range of inputs. Languages usually provide
    functions called assertion functions to perform these assertions. Rust provides
    us with assertion functions, implemented as macros, that help us achieve the same
    thing. Let''s take a look at some of the commonly used ones:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，当给定一个测试用例时，我们试图断言我们的软件组件在给定输入范围内的预期行为。通常，语言提供称为断言函数的函数来执行这些断言。Rust为我们提供了断言函数，作为宏实现，帮助我们实现相同的功能。让我们看看一些常用的例子：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`assert!`: This is the simplest assertion macro that takes a Boolean value
    to assert against. If the value is `false`, the test panics, showing the line
    where the failure happened. This can additionally take in a format string, followed
    by a corresponding number of variables, for providing custom error messages:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert!`：这是最简单的断言宏，它接受一个布尔值进行断言。如果值为`false`，则测试会崩溃，显示失败发生的行。它还可以接受一个格式字符串，后跟相应数量的变量，用于提供自定义错误消息：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`assert_eq!`: This takes in two values and fails if they are not equal. This
    can also take in a format string for custom error messages.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_eq!`：它接受两个值，如果它们不相等则失败。它还可以接受一个格式字符串，用于自定义错误消息。'
- en: '`assert_ne!`: This is similar to `assert_eq!` since it takes two values, but
    only asserts when the values are not equal to each other.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert_ne!`：这与`assert_eq!`类似，因为它接受两个值，但只有在值不相等时才进行断言。'
- en: '`debug_assert!`: This is similar to `assert!`. Debug assertion macros can be
    also be used in code other than test code. This is mostly used in code to assert
    for any contract or invariant that should be held by the code during runtime.
    These assertions are only effective on debug builds and help catch assertion violations
    when run in debug mode. When the code is compiled in optimized mode, these macro
    invocations are completely ignored and optimized away to a no-op. There are similar
    variants to this such as `debug_assert_eq!` and `debug_assert_ne!`, which work
    just like the `assert!` class of macros.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_assert!`：这与`assert!`类似。调试断言宏也可以用于除测试代码之外的代码。这主要用于代码中，以断言在运行时应该保持的任何合同或不变量。这些断言仅在调试构建中有效，并在以调试模式运行时帮助捕获断言违规。当代码以优化模式编译时，这些宏调用将被完全忽略并优化为无操作。还有类似的变体，如`debug_assert_eq!`和`debug_assert_ne!`，它们的工作方式与`assert!`类宏相同。'
- en: To compare the values within these assertion macros, Rust relies on traits.
    For example, the `==` inside `assert!(a == b)` actually turns into a method call, `a.eq(&b)`,
    which returns a `bool` value. The `eq` method comes from the `PartialEq` trait.
    Most built-in types in Rust implement the `PartialEq` and `Eq` traits so that
    they can be compared. The details of these traits and the difference between `PartialEq`
    and `Eq` are discussed in [Chapter 4](93373ddb-63dc-4b4c-a42f-7a099818705c.xhtml), *Types,
    Generics, and Traits.*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较这些断言宏内的值，Rust依赖于特质。例如，`assert!(a == b)`中的`==`实际上变成了一个方法调用，`a.eq(&b)`，它返回一个`bool`值。`eq`方法来自`PartialEq`特质。Rust中的大多数内置类型都实现了`PartialEq`和`Eq`特质，以便它们可以被比较。这些特质的细节以及`PartialEq`和`Eq`之间的区别在[第4章](93373ddb-63dc-4b4c-a42f-7a099818705c.xhtml)，“类型、泛型和特质”中进行了讨论。
- en: For user-defined types, however, we need to implement these traits. Fortunately,
    Rust provides us with a convenient macro called **derive**, which takes one or
    more trait names to implement. It can be used by putting the `#[derive(Eq, PartialEq)]`
    annotation over any user-defined type. Notice the trait names within parentheses.
    Derive is a procedural macro that simply generates code for `impl` blocks for
    the type on which it appears and implements the trait's methods or any associated
    functions. We'll discuss these macros when we get to [Chapter 9](7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml),
    *Metaprogramming with Macros*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户定义的类型，我们需要实现这些特质。幸运的是，Rust 为我们提供了一个方便的宏，称为 **derive**，它接受一个或多个要实现的特质名称。它可以通过在用户定义类型上放置
    `#[derive(Eq, PartialEq)]` 注解来使用。注意括号内的特质名称。Derive 是一个过程宏，它简单地为出现在其上的类型生成 `impl`
    块的代码，并实现特质的方 法或任何关联函数。我们将在第 9 章 [宏编程](7143ebcd-54cc-4e31-a2ad-07ce90268584.xhtml)中讨论这些宏。
- en: With that aside, let's start writing some tests!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，让我们开始编写一些测试！
- en: Unit tests
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In general, a unit test is a function that instantiates a small portion of an
    application and verifies its behavior independently from other parts of the code
    base**.** In Rust, unit tests are usually written within a module. Ideally, they
    should only aim to cover the module's functionality and its interfaces.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，单元测试是一个实例化应用程序的小部分并独立于代码库的其他部分验证其行为的函数**。**在 Rust 中，单元测试通常在模块内编写。理想情况下，它们应该只旨在覆盖模块的功能和接口。
- en: First unit test
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个单元测试
- en: 'The following is our very first unit test:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们非常第一个单元测试：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A unit test is written as a function and is marked with a `#[test]` attribute.
    There's nothing complex in the preceding `basic_test` function. We have a basic
    `assert!` call passing in `true`. For better organization, you may also create
    a child module called **tests** (by convention) and put all related test code
    inside it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是以函数的形式编写的，并带有 `#[test]` 属性。前面的 `basic_test` 函数中没有什么复杂的内容。我们有一个基本的 `assert!`
    调用，传递 `true`。为了更好的组织，你也可以创建一个名为 **tests** 的子模块（按照惯例），并将所有相关的测试代码放在其中。
- en: Running tests
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'The way we run this test is by compiling our code in test mode. The compiler
    ignores the compilation of test annotated functions unless it''s told to build
    in test mode. This can be achieved by passing the `--test` flag to `rustc` when
    compiling the test code. Following that, tests can be run by simply executing
    the compiled binary. For the preceding test, we''ll compile it in test mode by
    running this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行这个测试的方式是通过以测试模式编译我们的代码。编译器会忽略测试注解函数的编译，除非被指示以测试模式构建。这可以通过在编译测试代码时传递 `--test`
    标志给 `rustc` 来实现。之后，可以通过简单地执行编译后的二进制文件来运行测试。对于前面的测试，我们将通过运行以下命令以测试模式编译它：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the `--test` flag, `rustc` puts a `main` function with some test harness
    code and invokes all your defined test functions as threads in parallel. All tests
    are run in parallel by default unless told to do so with the environment variable `RUST_TEST_THREADS=1`.
    This means that if we want to run the preceding test in single thread mode, we
    can execute with `RUST_TEST_THREADS=1 ./first_unit_test`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--test` 标志，`rustc` 会放置一个带有一些测试框架代码的 `main` 函数，并将所有定义的测试函数作为线程并行调用。默认情况下，所有测试都是并行运行的，除非通过环境变量
    `RUST_TEST_THREADS=1` 指示。这意味着如果我们想以单线程模式运行前面的测试，我们可以通过 `RUST_TEST_THREADS=1 ./first_unit_test`
    来执行。
- en: Now, Cargo already has support for running tests, and all of this is usually
    done internally by invoking `cargo test`. This command compiles and runs the test
    annotated functions for us. In the examples that follow, we will mostly use Cargo
    to run our tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Cargo 已经支持运行测试，所有这些通常都是通过调用 `cargo test` 命令来内部完成的。这个命令会为我们编译并运行带有测试注解的函数。在接下来的示例中，我们将主要使用
    Cargo 来运行我们的测试。
- en: Isolating test code
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离测试代码
- en: When our tests grow in complexity, there may be additional helper methods that
    we might create that only gets used within the context of our test code. In such
    situations, it is beneficial to isolate the test-related code from the actual
    code. We can do this by encapsulating all of our test-related code inside a module
    and putting a `#[cfg(test)]` annotation over it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的测试变得复杂时，可能会有一些额外的辅助方法，我们可能会创建，这些方法仅在测试代码的上下文中使用。在这种情况下，将测试相关代码与实际代码隔离是有益的。我们可以通过将所有测试相关代码封装在一个模块中，并在其上放置
    `#[cfg(test)]` 注解来实现这一点。
- en: The `cfg` in the `#[cfg(...)]` attribute is generally used for conditional compilation
    and not just limited to test code. It can include or exclude code for different
    architectures or configuration flags. Here, the configuration flag is `test`.
    You might remember that the tests in the previous chapter were already using this
    form. This has the advantage that your test code is only compiled and included
    in the compiled binary when you run `cargo test`, and otherwise ignored.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[cfg(...)]` 属性中的 `cfg` 通常用于条件编译，并不仅限于测试代码。它可以包括或排除不同架构或配置标志的代码。在这里，配置标志是
    `test`。你可能还记得，上一章中的测试已经使用了这种形式。这有一个优点，即你的测试代码只有在运行 `cargo test` 时才会被编译并包含在编译的二进制文件中，否则会被忽略。'
- en: 'Say you want to programmatically generate test data for your tests, but there''s
    no reason to have that code in the release build. Let''s create a project by running
    `cargo new unit_test --lib` to demonstrate this. In `lib.rs`, we have defined
    some tests and functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想为测试程序生成测试数据，但没有理由在发布构建中包含那段代码。让我们通过运行 `cargo new unit_test --lib` 来创建一个项目来演示这一点。在
    `lib.rs` 中，我们定义了一些测试和函数：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can run these tests by running `cargo test`. Let's go through the preceding
    code. We generate known input and output pairs in the `sum_inputs_outputs` function,
    which is used by the `test_sums` function. The `#[test]` attribute keeps the `test_sums`
    function out of our release compilation. However, `sum_inputs_outputs` is not
    marked with `#[test]`, and will get included in compilation if it's declared outside
    the `tests` module. By using `#[cfg(test)]` with a `mod tests {}` child module
    and encapsulating all the test code and its related functions inside this module,
    we get the benefit of keeping both the code and the resulting binary clean of
    the test code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `cargo test` 来运行这些测试。让我们回顾一下前面的代码。我们在 `sum_inputs_outputs` 函数中生成已知输入和输出对，该函数被
    `test_sums` 函数使用。`#[test]` 属性使 `test_sums` 函数不包含在我们的发布编译中。然而，`sum_inputs_outputs`
    没有标记为 `#[test]`，如果它在 `tests` 模块外部声明，它将被包含在编译中。通过使用 `#[cfg(test)]` 与 `mod tests
    {}` 子模块，并将所有测试代码及其相关函数封装在这个模块中，我们得到了保持代码和生成的二进制文件清洁的好处，不包含测试代码。
- en: We also had our `sum` function defined as private without the `pub` visibility
    modifier, which means that unit tests within modules also allow you to test private
    functions and methods. Quite convenient!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将 `sum` 函数定义为私有，没有使用 `pub` 可见性修饰符，这意味着模块内的单元测试也允许你测试私有函数和方法。非常方便！
- en: Failing tests
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失败测试
- en: 'There are also test cases where you will want your API methods to fail based
    on some input, and you want the test framework to assert this failure. Rust provides
    an attribute called `#[should_panic]` for this. Here''s a test that panics and
    uses this attribute:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些测试用例中，你可能希望你的 API 方法根据某些输入失败，并且希望测试框架断言这种失败。Rust 提供了一个名为 `#[should_panic]`
    的属性来实现这一点。以下是一个引发 panic 并使用此属性的测试用例：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `#[should_panic]` attribute can be paired with a `#[test]` attribute to
    signify that running the `this_panics` function should cause a non-recoverable
    failure, which is called a **panic** in Rust.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[should_panic]` 属性可以与 `#[test]` 属性一起使用，表示运行 `this_panics` 函数应该导致不可恢复的失败，这在
    Rust 中被称为 **panic**。'
- en: Ignoring tests
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略测试
- en: 'Another useful attribute for writing tests is `#[ignore]`. If your test code
    is exceedingly heavy, the `#[ignore]` annotation enables the test harness to ignore
    such test functions when running `cargo test`. You can then choose to individually
    run those tests by supplying an `--ignored` parameter to either your test runner
    or the `cargo test` command. Here''s the code containing a silly loop that, when
    run using `cargo test`, is ignored by default:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的另一个有用属性是 `#[ignore]`。如果你的测试代码非常复杂，使用 `#[ignore]` 注解可以让测试运行器在运行 `cargo test`
    时忽略这些测试函数。然后你可以选择单独运行这些测试，通过向测试运行器或 `cargo test` 命令提供 `--ignored` 参数来实现。以下是一个包含愚蠢循环的代码示例，当使用
    `cargo test` 运行时，默认会被忽略：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the `#[ignore]` attribute over the `test_silly_loop` test function. Here''s
    the output from the ignored test:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `test_silly_loop` 测试函数上的 `#[ignore]` 属性。以下是忽略测试的输出：
- en: '![](img/fe9815c7-ab4a-44d5-a9c2-34f6393962db.png)**Note**: A single test can
    also be run by supplying the test function name to Cargo, for example, `cargo
    test some_test_func`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/fe9815c7-ab4a-44d5-a9c2-34f6393962db.png)**注意**：也可以通过向 Cargo 提供测试函数名来运行单个测试，例如，`cargo
    test some_test_func`。'
- en: Integration tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: While unit tests can test the private interface of your crate and individual
    modules, integration tests are kind of like black box tests that aim to test the
    end-to-end use of the public interface of your crate from a consumer's perspective.
    In terms of writing code, there is not a lot of difference between writing integration
    tests and unit tests. The only difference lies in the directory structure and
    that the items need to be made public, which is already exposed by the developer
    as per the design of the crate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试可以测试你的crate的私有接口和单个模块，但集成测试更像是一种黑盒测试，旨在从消费者的角度测试crate公共接口的端到端使用。在编写代码方面，编写集成测试和单元测试之间没有太大的区别。唯一的区别在于目录结构，并且需要将项目公开，这已经由crate的设计者公开了。
- en: First integration test
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一次集成测试
- en: 'As we stated previously, Rust expects all integration tests to live in the
    `tests/` directory. Files within the `tests/` directory are compiled as if they
    are separate binary crates while using our library under test. For the following
    example, we''ll create a new crate by running  `cargo new integration_test --lib`,
    with the same function, `sum` ,as in the previous unit test, but now we have added
    a `tests/` directory, which has an integration test function defined as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，Rust期望所有集成测试都位于`tests/`目录中。`tests/`目录中的文件被编译为似乎它们是单独的二进制crate，同时使用我们正在测试的库。对于以下示例，我们将通过运行`cargo
    new integration_test --lib`创建一个新的crate，与之前的单元测试具有相同的函数`sum`，但现在我们添加了一个`tests/`目录，其中定义了一个如下所示的集成测试函数：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We first bring the function `sum` in scope. Second, we have a function, `sum_test` ,
    that calls `sum` and asserts on the return value. When we try to run `cargo test`,
    we are presented with the following error:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将函数`sum`引入作用域。其次，我们有一个名为`sum_test`的函数，它调用`sum`并断言返回值。当我们尝试运行`cargo test`时，我们遇到了以下错误：
- en: '![](img/c864b7f9-9d25-452a-8e09-a6faa593ff57.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![清理资源图片](img/c864b7f9-9d25-452a-8e09-a6faa593ff57.png)'
- en: 'This error seems reasonable. We want the users of our crate to use the `sum`
    function, but in our crate we have it defined as a private function by default.
    So, after adding the `pub` modifier before the `sum` function and running `cargo
    test`, our test is green again:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误看起来是合理的。我们希望我们的crate的用户使用`sum`函数，但在我们的crate中，我们默认将其定义为私有函数。因此，在`sum`函数前添加`pub`修饰符并运行`cargo
    test`后，我们的测试再次变为绿色：
- en: '![](img/c2ad6160-52bc-4d26-9cb7-fd8ca6ed0243.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![错误图片](img/c2ad6160-52bc-4d26-9cb7-fd8ca6ed0243.png)'
- en: 'Here''s a view of the directory tree of our `integration_test` example crate:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们`integration_test`示例crate的目录树视图：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As an example of an integration test, this was very trivial, but the gist of
    it is that when we write integration tests, we use the crate that's being tested,
    like any other user of a library would use it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为集成测试的一个例子，这非常简单，但它的要点是，当我们编写集成测试时，我们使用正在测试的crate，就像任何其他库的用户使用它一样。
- en: Sharing common code
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享通用代码
- en: 'As is often the case with integration tests, there is some setup and teardown-related
    code that we might need to put in place before we can actually run our tests.
    You usually want them to be shared by all of the files in the `tests/` directory.
    For sharing code, we can use modules by either creating them as a directory that
    shares common code, or use a module `foo.rs` and declare in our `integration`
    test files that we depend on it by putting a `mod` declaration. So, in our preceding `tests/`
    directory, we added a `common.rs` module that has two functions called `setup`
    and `teardown`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如集成测试通常所做的那样，我们需要在运行测试之前放置一些设置和清理相关的代码。通常，我们希望这些代码在`tests/`目录下的所有文件中共享。为了共享代码，我们可以通过创建一个共享通用代码的目录，或者使用一个名为`foo.rs`的模块，并在我们的集成测试文件中通过放置一个`mod`声明来声明我们依赖于它。因此，在我们的前一个`tests/`目录中，我们添加了一个名为`common.rs`的模块，其中包含两个名为`setup`和`teardown`的函数：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In both of our functions, we can have any kind of fixture-related code. Consider
    that you have an integration test that relies on the existence of a text file.
    In our function `setup`, we can create the text file, while in our functi0n `teardown`,
    we can clean up our resources by deleting the file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的两个函数中，我们可以包含任何类型的固定相关代码。考虑一下，如果你有一个依赖于文本文件存在的集成测试。在我们的`setup`函数中，我们可以创建文本文件，而在我们的`teardown`函数中，我们可以通过删除文件来清理资源。
- en: 'To use these functions in our integration test code in `tests/sum.rs`, we put
    in the `mod` declarations like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的`tests/sum.rs`集成测试代码中使用这些函数，我们按照如下方式添加`mod`声明：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have added another function,  `test_with_fixture` , that includes calls
    to `setup` and `teardown`. We can run this test with `cargo test test_with_fixture`.
    As you may have noticed from the output, we don''t get to see our `println!` calls
    anywhere from within the `setup` or `teardown` functions. This is because, by
    default, the test harness hides or captures print statements within test functions
    to make the test results tidier, and only shows the test harness''s outputs. If
    we want to view print statements within our tests, we can run the test with `cargo
    test test_with_fixture -- --nocapture`, which gives us the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了另一个函数，`test_with_fixture`，它包括对`setup`和`teardown`的调用。我们可以通过`cargo test test_with_fixture`运行这个测试。正如你可能从输出中注意到的，我们在`setup`或`teardown`函数内部看不到任何`println!`调用。这是因为默认情况下，测试框架会隐藏或捕获测试函数内的打印语句，以使测试结果更整洁，并且只显示测试框架的输出。如果我们想在测试中查看打印语句，我们可以通过`cargo
    test test_with_fixture -- --nocapture`运行测试，这将给出以下输出：
- en: '![](img/560e2a59-d90d-4504-b4f1-24f86660a15e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/560e2a59-d90d-4504-b4f1-24f86660a15e.png)'
- en: We can see our print statements now. We needed the `--` in `cargo test test_with_fixture
    -- --nocapture` because we actually want to pass the `--nocapture` flag to our
    test runner. `--` marks the end of arguments for `cargo` itself, and any argument
    following that is passed to the binary being invoked by cargo, which is our compiled
    binary with test harness.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到我们的打印语句了。我们需要在`cargo test test_with_fixture -- --nocapture`中使用`--`，因为我们实际上想将`--nocapture`标志传递给我们的测试运行器。`--`标记了`cargo`本身的参数结束，并且任何随后的参数都传递给由cargo调用的二进制文件，即我们的带有测试框架的编译二进制文件。
- en: That's about it for integration tests. At the end of this chapter, we'll create
    a project where we get to see both unit tests and integration tests work in tandem.
    Next, we'll learn about documenting Rust code, an overlooked but quite important
    part of software development.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试就到这里。在本章结束时，我们将创建一个项目，在那里我们可以看到单元测试和集成测试协同工作。接下来，我们将学习如何编写Rust代码的文档，这是软件开发中一个被忽视但相当重要的部分。
- en: Documentation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: Documentation is a very crucial aspect of any open source software aiming for
    wide adoption by the programmer community. While your code, which should be readable,
    tells you how it works, the documentation should tell you about the why and how
    of the design decisions and example usage of the public APIs of your software.
    Well documented code with a comprehensive `README.md` page boosts the discoverability
    of your project many times over.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是任何开源软件面向程序员社区广泛采用的一个非常关键的部分。虽然你的代码，应该是可读的，告诉你它是如何工作的，但文档应该告诉你设计决策的原因和如何以及公共API的示例用法。一个良好的文档，带有全面的`README.md`页面，可以大大提高你项目的可发现性。
- en: The Rust community takes documentation very seriously and has tools at various
    levels to make it easy to write documentation for code. It also makes it presentable
    and consumable for its users. For writing documentation, it supports the markdown
    dialect. Markdown is a very popular markup language and is the standard these
    days for writing docs. Rust has a dedicated tool called **rustdoc** that parses
    markdown doc comments, converts them to HTML, and generates beautiful and searchable
    documentation pages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Rust社区非常重视文档，并在各个级别提供了工具，使编写代码文档变得容易。它还使文档对用户来说易于展示和消费。对于编写文档，它支持Markdown方言。Markdown是一种非常流行的标记语言，并且现在是编写文档的标准。Rust有一个专门的工具叫做**rustdoc**，它可以解析Markdown文档注释，将它们转换为HTML，并生成美丽且可搜索的文档页面。
- en: Writing documentation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写文档
- en: 'To write documentation, we have special symbols for marking the start of documentation
    comments (doc comments hereafter). Docs are written in a similar fashion, the
    way we write comments, but they are treated differently compared to ordinary comments
    and are parsed by rustdoc. The doc comments are divided into two levels and use
    separate symbols to mark the start of the doc comment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写文档，我们有特殊的符号来标记文档注释的开始（以下称为doc注释）。文档的编写方式与编写注释类似，但与普通注释相比，它们被处理得不同，并且由rustdoc解析。doc注释分为两个级别，并使用不同的符号来标记doc注释的开始：
- en: '**Item level**: These comments are meant for items within the module such as
    structs, enum declarations, functions, trait constants, and so on. They should
    appear above the item. For single-line comments, they start with `///`, while
    multi-line comments begin with `/**` and end with `*/`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目级别**：这些注释是针对模块内的项目，如结构体、枚举声明、函数、特质常量等。它们应该出现在项目上方。对于单行注释，它们以`///`开头，而多行注释以`/**`开头，以`*/`结尾。'
- en: '**Module level**: These are comments that appear at the root level, i.e., `main.rs`, `lib.rs`,
    or any other module, and use `//!` to mark the start of a line comment – or `/*!`
    for multi-line comments – before ending them with `*/`. They are suitable for
    giving a general overview of your crate and example usage.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块级别**：这些是在根级别出现的注释，即`main.rs`、`lib.rs`或任何其他模块，并使用`//!`来标记行注释的开始——或者使用`/*!`来标记多行注释——在结束前使用`*/`。它们适合提供对crate的一般概述和示例用法。'
- en: Within the doc comment, you can write docs using the usual markdown syntax.
    It also supports writing valid Rust code within backticks ([PRE11]`), which becomes
    part of documentation tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档注释中，你可以使用常规的Markdown语法来编写文档。它还支持在反引号（[PRE11]`）内编写有效的Rust代码，这将成为文档测试的一部分。
- en: The preceding notation for writing comments is actually a syntatic sugar for
    the `#[doc="your doc comment"]` attribute. These are called **doc attributes**.
    When rustdoc parses the `///` or `/**` lines, it converts them into these doc
    attributes. Alternatively, you can also write docs using these doc attributes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之前用于编写注释的符号实际上是`#[doc="your doc comment"]`属性的语法糖。这些被称为**文档属性**。当rustdoc解析`///`或`/**`行时，它会将它们转换为这些文档属性。或者，你也可以使用这些文档属性来编写文档。
- en: Generating and viewing documentation
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成和查看文档
- en: To generate documentation, we can use the `cargo doc` command in our project
    directory. It generates docs in the `target/doc/` directory with a bunch of HTML
    files and predefined stylesheets. By default, it generates docs for a crate's
    dependencies too. We can tell Cargo to ignore generating docs for dependencies
    by running `cargo doc --no-deps`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成文档，我们可以在项目目录中使用`cargo doc`命令。它会在`target/doc/`目录下生成包含许多HTML文件和预定义样式的文档。默认情况下，它还会为crate的依赖项生成文档。我们可以通过运行`cargo
    doc --no-deps`来告诉Cargo忽略为依赖项生成文档。
- en: To view the documentation, one can spawn a HTTP server by navigating inside
    the `target/doc` directory. Python's simple HTTP server can come in handy here.
    However, there's a better way to do this! Passing the `--open` option to `cargo
    doc` will open the documentation page directly in your default browser.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文档，可以在`target/doc`目录内导航以启动一个HTTP服务器。Python的简单HTTP服务器在这里很有用。然而，还有更好的方法！将`--open`选项传递给`cargo
    doc`将直接在默认浏览器中打开文档页面。
- en: '`cargo doc` can be combined with `cargo watch` to get a seamless experience
    in writing documentation and getting live feedback on the generated page for any
    documentation changes you do on your project.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo doc`可以与`cargo watch`结合使用，以在编写文档并获得对项目上任何文档更改的实时反馈时获得无缝体验。'
- en: Hosting documentation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管文档
- en: 'After your documentation has been generated, you will need to host it somewhere
    for the public to view and use. There are three possibilities here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文档生成后，你需要将其托管在某个地方供公众查看和使用。这里有三种可能性：
- en: '**docs.rs**: Crates that are hosted on `crates.io` get their documentation
    page automatically generated and hosted on [https://docs.rs](https://docs.rs).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**docs.rs**：托管在`crates.io`上的crate会自动生成并托管在[https://docs.rs](https://docs.rs)上的文档页面。'
- en: '**GitHub pages**: You can host your documentation on the `gh-pages` branch
    if your crate is on GitHub.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub pages**：如果你的crate在GitHub上，你可以将其文档托管在`gh-pages`分支上。'
- en: '**External website:** You can manage your own web server for hosting documentation.
    Rust''s standard library documentation is a fine example of this: [https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/).'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部网站**：你可以管理自己的Web服务器来托管文档。Rust的标准库文档就是这样一个很好的例子：[https://doc.rust-lang.org/std/](https://doc.rust-lang.org/std/)。'
- en: As an added note, if your project's documentation spans more than two to three
    pages and requires a detailed introduction, then there's a better option to generate
    book-like documentation. This is done by using the `mdbook` project. For more
    information on that, check out their GitHub page at [https://github.com/rust-lang-nursery/mdBook](https://github.com/rust-lang-nursery/mdBook).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加说明，如果你的项目文档超过两到三页，并且需要详细的介绍，那么有一个更好的选项来生成类似书籍的文档。这是通过使用`mdbook`项目来实现的。有关更多信息，请查看他们的GitHub页面[https://github.com/rust-lang-nursery/mdBook](https://github.com/rust-lang-nursery/mdBook)。
- en: Doc attributes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档属性
- en: 'We mentioned that the doc comments that we write get converted into doc attributes
    form. Apart from those, there are other doc attributes for documentation that
    can tweak the generated documentation page, and these are applied either at the
    crate level or at the item level. They are written like `#[doc(key = value)]`.
    Some of the most useful doc attributes are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，我们编写的文档注释会被转换成文档属性形式。除了这些，还有其他文档属性可以调整生成的文档页面，这些属性可以在crate级别或项目级别应用。它们被写成`#[doc(key
    = value)]`的形式。以下是一些最有用的文档属性：
- en: '**Crate-level attributes**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**crate级属性**:'
- en: '`#![doc(html_logo_url = "image url")`: Allows you to add a logo to the top-left
    of your documentation page.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#![doc(html_logo_url = "image url")]`: 允许您在文档页面的左上角添加一个标志。'
- en: '`#![doc(html_root_url = "https://docs.rs/slotmap/0.2.1")]`: Allows you to set
    the URL for the documentation page.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#![doc(html_root_url = "https://docs.rs/slotmap/0.2.1")]`: 允许您设置文档页面的URL。'
- en: '`#![doc(html_playground_url = "https://play.rust-lang.org/")]`: Allows you
    to put a run button near the code example in your documentation so that you can
    run it directly in the online Rust playground.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#![doc(html_playground_url = "https://play.rust-lang.org/")]`: 允许您在文档中的代码示例附近放置一个运行按钮，以便您可以直接在在线Rust
    playground中运行它。'
- en: '**Item-level attributes**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目级属性**:'
- en: '`#[doc(hidden)]`: Say you have written the documentation for a public function, `foo`,
    as a note to yourself. However, you don''t want your consumers to view the documentation.
    You can use this attribute to tell rustdoc to ignore generating docs for `foo`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[doc(hidden)]`: 假设您已经为公开函数`foo`编写了文档，作为自己的笔记。然而，您不希望您的消费者查看这些文档。您可以使用此属性告诉rustdoc忽略为`foo`生成文档。'
- en: '`#[doc(include)]`: This can be used to include documentation from other files.
    This helps you separate your documentation from code if it''s really long.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#[doc(include)]`: 这可以用来包含来自其他文件的文档。如果文档真的很长，这有助于您将文档与代码分离。'
- en: For more attributes like these ones, head over to [https://doc.rust-lang.org/beta/rustdoc/the-doc-attribute.html](https://doc.rust-lang.org/beta/rustdoc/the-doc-attribute.html).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多此类属性，请访问[https://doc.rust-lang.org/beta/rustdoc/the-doc-attribute.html](https://doc.rust-lang.org/beta/rustdoc/the-doc-attribute.html)。
- en: Documentation tests
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档测试
- en: It's often a good practice to include code examples with any documentation for
    your crate's public APIs. There's a caveat in maintaining such examples, though.
    Your code might change and you might forget to update your examples. Documentation
    tests (doctests) are there to remind you to update your example code as well.
    Rust allows you to embed code in backticks within doc comments. Cargo can then
    run this example code that's been embedded within your documentation, and treats
    it as part of the unit test suite. This means that documentation examples run
    every time you run your unit tests, forcing you to update them. Quite amazing!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在为crate的公开API编写任何文档时包含代码示例通常是一个好习惯。尽管如此，维护这些示例也存在一个注意事项。您的代码可能会更改，您可能会忘记更新示例。文档测试（doctests）就是为了提醒您更新示例代码。Rust允许您在文档注释中嵌入反引号内的代码。然后Cargo可以运行嵌入在文档中的示例代码，并将其视为单元测试套件的一部分。这意味着文档示例会在您运行单元测试时运行，迫使您更新它们。这非常神奇！
- en: 'Documentation tests are also executed via Cargo. We have created a project
    called `doctest_demo` to illustrate documentation tests. In `lib.rs`, we have
    the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文档测试也是通过Cargo执行的。我们创建了一个名为`doctest_demo`的项目来展示文档测试。在`lib.rs`中，我们有以下代码：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: //! use doctest_demo::sum;
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: //! use doctest_demo::sum;
- en: //!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: //!
- en: //! let work_a = 4;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: //! let work_a = 4;
- en: //! let work_b = 34;
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: //! let work_b = 34;
- en: //! let total_work = sum(work_a, work_b);
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: //! let total_work = sum(work_a, work_b);
- en: //! [PRE13]
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: //! [PRE13]
- en: /// assert_eq!(doctest_demo::sum(1, 1), 2);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: /// assert_eq!(doctest_demo::sum(1, 1), 2);
- en: /// [PRE14]
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE14]
- en: As you can see, the difference between module-level and function-level doctests
    is not much. They are used in pretty much the same way. It is just that the module-level
    doctests show the overall usage of the crate, covering more than one API surface,
    while function-level doctests cover just the particular function over which they
    appear.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模块级和函数级文档测试之间的区别不大。它们的使用方式几乎相同。只是模块级文档测试显示了crate的整体使用情况，覆盖了多个API界面，而函数级文档测试仅覆盖它们出现的特定函数。
- en: 'Documentation tests run with all the other tests when you run `cargo test`.
    Here''s the output when we run `cargo test` in our `doctest_demo` crate:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`cargo test`时，文档测试会与其他所有测试一起运行。以下是我们运行`doctest_demo` crate中的`cargo test`时的输出：
- en: '![](img/0edfb5b3-92f4-4e90-8ca8-8d4038260bea.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0edfb5b3-92f4-4e90-8ca8-8d4038260bea.png)'
- en: Benchmarks
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: When business needs change and your program gets a requirement to perform more
    efficiently, the first step to take is to find out the areas that are slow in
    the program. How can you tell where the bottlenecks are? You can tell by measuring
    individual parts of your program on various expected ranges or on a magnitude
    of inputs. This is known as benchmarking your code. Benchmarking is usually done
    at the very last stage of development (but does not have to be) to provide insights
    on areas where there are performance pitfalls in code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当业务需求发生变化，并且你的程序需要更高效地执行时，首先要采取的步骤是找出程序中缓慢的区域。你如何判断瓶颈在哪里？你可以通过在各个预期的范围或输入量级上测量程序的单个部分来了解。这被称为基准测试你的代码。基准测试通常在开发的最后阶段进行（但不必如此），以提供关于代码中性能陷阱的见解。
- en: There are various ways to perform benchmark tests for a program. The trivial
    way is to use the Unix tool time to measure the execution time of your program
    after your changes. But that doesn't provide precise micro-level insights. Rust
    provides us with a built-in micro benchmarking framework. By micro benchmarking,
    we mean that it can be used to benchmark individual parts of the code in isolation
    and remains unbiased from external factors. However, it also means that we should
    not rely solely on micro benchmarks since the real world results can be skewed.
    Thus, a micro benchmark is often followed by profiling and macro benchmarking
    of the code. Nonetheless, micro benchmarking is often a starting point for improving
    the performance of your code as the individual parts contribute a lot to the overall
    running time of your program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个程序，有多种方式进行基准测试。最简单的方法是使用Unix工具time来测量你更改后的程序执行时间。但这并不提供精确的微级洞察。Rust为我们提供了一个内置的微基准测试框架。通过微基准测试，我们指的是它可以用来独立基准测试代码的各个部分，并且不受外部因素的影响。然而，这也意味着我们不应该仅仅依赖于微基准测试，因为现实世界的结果可能会被扭曲。因此，微基准测试通常随后会进行代码的剖析和宏基准测试。尽管如此，微基准测试通常是提高你代码性能的起点，因为各个部分对程序的总体运行时间贡献很大。
- en: In this section, we will discuss the tool that Rust provides as a built in for
    performing micro benchmarks. Rust lowers the bar for writing benchmarking code
    right from the initial stages of development, rather than doing it as a last resort.
    The way you run benchmarks is similar to how tests are run, but uses the `cargo
    bench` command instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Rust提供的用于执行微基准测试的内置工具。Rust从开发初期就降低了编写基准测试代码的门槛，而不是作为最后的手段。运行基准测试的方式与运行测试类似，但使用的是`cargo
    bench`命令。
- en: Built-in micro-benchmark harness
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置的微基准测试工具
- en: 'Rust''s built-in benchmarking framework measures the performance of code by
    running it through several iterations and reports the average time taken for the
    operation in question. This is facilitated by two things:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的内置基准测试框架通过运行多次迭代来衡量代码的性能，并报告操作的平均时间。这由以下两点促成：
- en: The `#[bench]` annotation on a function. This marks the function as a benchmark
    test.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数上的`#[bench]`注解。这表示该函数是一个基准测试。
- en: The internal compiler crate `libtest` with a `Bencher` type, which the benchmark
    function uses for running the same benchmark code in several iterations. This
    type resides under the `test` crate, which is internal to the compiler.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部编译器crate `libtest`，其中包含一个`Bencher`类型，基准测试函数使用它来运行多次相同的基准测试代码。此类型位于编译器内部的`test`
    crate下。
- en: 'Now, we''ll write and run a simple benchmark test. Let''s create a new Cargo
    project by running `cargo new --lib bench_example`. No changes to `Cargo.toml`
    are needed for this. The contents of `src/lib.rs` is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并运行一个简单的基准测试。让我们通过运行`cargo new --lib bench_example`来创建一个新的Cargo项目。对于这个项目，不需要对`Cargo.toml`进行任何更改。`src/lib.rs`的内容如下：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we had to specify the internal crate `test` with the `external crate`
    declaration, along with the `#[feature(test)]` attribute. The `extern` declaration
    is needed for crates internal to the compiler. In future versions of the compiler,
    this might not be needed and you will be able to `use` them like normal crates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须使用`external crate`声明和`#[feature(test)]`属性来指定内部crate `test`。`extern`声明对于编译器内部的crate是必需的。在编译器的未来版本中，这可能不再需要，你将能够像正常crate一样`use`它们。
- en: 'If we run our benchmarks by running `cargo bench`, we will see the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过运行`cargo bench`来运行基准测试，我们将看到以下内容：
- en: '![](img/1489bed5-f538-4cc3-9414-1529bbe4783a.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1489bed5-f538-4cc3-9414-1529bbe4783a.png)'
- en: 'Unfortunately, benchmark tests are an unstable feature, so we''ll have to use
    the nightly compiler for these. Fortunately, with `rustup`, moving between different
    release channels of the Rust compiler is easy. First, we''ll make sure that the
    nightly compiler is installed by running `rustup update nightly`. Then, within
    our `bench_example` directory, we will override the default toolchain for this
    directory by running `rustup override set nightly`. Now, running `cargo bench`
    will give the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，基准测试是一个不稳定的功能，所以我们将不得不使用夜间编译器来执行这些测试。幸运的是，使用 `rustup` 在 Rust 编译器的不同发布渠道之间切换很容易。首先，我们将通过运行
    `rustup update nightly` 来确保夜间编译器已安装。然后，在我们的 `bench_example` 目录中，我们将通过运行 `rustup
    override set nightly` 来覆盖此目录的默认工具链。现在，运行 `cargo bench` 将给出以下输出：
- en: '![](img/2c9be90a-ff60-4a95-bd8a-f27155da64eb.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c9be90a-ff60-4a95-bd8a-f27155da64eb.png)'
- en: Those are nanoseconds per iteration, with the figure inside the parentheses
    showing the variation between each run. Our slower implementation was quite slow
    and variable in running time (as shown by the large `+/-` variation).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是每次迭代的纳秒数，括号内的数字显示了每次运行之间的变化。我们的较慢实现运行速度相当慢且变化很大（如大的 `+/-` 变化所示）。
- en: Inside our functions marked with `#[bench]`, the parameter to `iter` is a closure
    with no parameters. If the closure had parameters, they would be inside `||`.
    This essentially means that `iter` is passed a function that the benchmark test
    can run repeatedly. We print a single dot in the function so that Rust won't optimize
    the empty loop away. If the `println!()` was not there, then the compiler would
    have optimized away the loop to a no-op, and we would get false results. There
    are ways to get around this, and this is done by using the `black_box` function
    from the `test` module. However, even using that does not guarantee that the optimizer
    won't optimize your code. Now, we also have other third-party solutions for running
    benchmarks on stable Rust.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们标记为 `#[bench]` 的函数内部，`iter` 的参数是一个无参数的闭包。如果闭包有参数，它们将位于 `||` 内。这本质上意味着 `iter`
    被传递了一个可以被基准测试重复运行的函数。我们在函数中打印一个点，这样 Rust 就不会优化掉空循环。如果没有 `println!()`，那么编译器就会将循环优化为一个无操作，我们会得到错误的结果。有方法可以绕过这个问题，这是通过使用
    `test` 模块中的 `black_box` 函数来实现的。然而，即使使用了那个函数，也不能保证优化器不会优化你的代码。现在，我们也有其他第三方解决方案来在稳定版
    Rust 上运行基准测试。
- en: Benchmarking on stable Rust
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在稳定版 Rust 上的基准测试
- en: The built-in benchmarking framework provided by Rust is unstable, but fortunately
    there are community developed benchmarking crates that work on stable Rust. One
    such popular crate that we'll explore here is `criterion-rs`. This crate is designed
    to be easy to use while at the same time providing detailed information on the
    benchmarked code. It also maintains the state of the last run, reporting performance
    regressions (if any) on every run. Criterion.rs generates more statistical reports
    than the built-in benchmark framework, and also generates helpful charts and graphs
    using *gnuplot* to make it understandable to the user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 提供的内置基准测试框架是不稳定的，但幸运的是，有一些社区开发的基准测试 crate 可以在稳定版 Rust 上工作。我们将在这里探索的一个流行的
    crate 是 `criterion-rs`。这个 crate 设计得易于使用，同时提供有关基准测试代码的详细信息。它还维护了上次运行的状
- en: 'To demonstrate using this crate, we''ll create a new crate called `cargo new
    criterion_demo --lib`. We will add the criterion crate to `Cargo.toml` as a dependency
    under the `dev-dependencies` section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用这个 crate，我们将创建一个新的 crate，名为 `cargo new criterion_demo --lib`。我们将 criterion
    crate 添加到 `Cargo.toml` 中的 `dev-dependencies` 部分作为依赖项：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have also added a new section known as `[[bench]]`, which indicates to cargo
    that we have a new benchmark test named `fibonacci` and that it does not use the
    built-in benchmark harness (`harness = false`), since we are using the criterion
    crate's test harness.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个新的部分，称为 `[[bench]]`，它指示 cargo 我们有一个名为 `fibonacci` 的新基准测试，并且它不使用内置的基准测试工具（`harness
    = false`），因为我们正在使用 criterion crate 的测试工具。
- en: 'Now, in `src/lib.rs`, we have a fast and a slow version of a function that
    computes the nth `fibonacci` number (with initial values of `n[0] = 0` and `n[1]
    = 1`):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `src/lib.rs` 中，我们有一个计算第 n 个 `fibonacci` 数（初始值为 `n[0] = 0` 和 `n[1] = 1`）的函数的快速和慢速版本：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`fast_fibonacci` is the bottom-up iterative solution to get the nth fibonacci
    number, whereas the `slow_fibonacci` version is the slow recursive version. Now,
    criterion-rs requires us to place our benchmarks inside a `benches/` directory,
    which we created at the crate root. Within the `benches/` directory, we have also
    created a file named `fibonacci.rs`, which matches our name under the `[[bench]]`
    in `Cargo.toml`. It has the following content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`fast_fibonacci` 是获取第 n 个斐波那契数的自底向上的迭代解决方案，而 `slow_fibonacci` 版本则是较慢的递归版本。现在，`criterion-rs`
    要求我们将基准测试放在一个 `benches/` 目录中，我们在 crate 根目录下创建了它。在 `benches/` 目录中，我们还创建了一个名为 `fibonacci.rs`
    的文件，它与 `Cargo.toml` 中的 `[[bench]]` 下的名称相匹配。其内容如下：'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's quite a lot going on here! In the preceding code, we first declare our
    required crates and import our the `fibonacci` functions that we need to benchmark
    (`fast_fibonacci` and `slow_fibonacci`). Also, there is a `#[macro_use]` attribute
    above `extern crate criterion`, which means to use any macros from a crate, we
    need to opt for it using this attribute as they are not exposed by default. It's
    similar to a `use` statement, which is used to expose module items.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中！在上面的代码中，我们首先声明了所需的 crate 并导入了我们需要基准测试的 `fibonacci` 函数（`fast_fibonacci`
    和 `slow_fibonacci`）。此外，在 `extern crate criterion` 上有一个 `#[macro_use]` 属性，这意味着要使用来自
    crate 的任何宏，我们需要使用此属性来选择它，因为它们默认没有暴露。这类似于一个 `use` 语句，它用于暴露模块项。
- en: 'Now, criterion has this notion of benchmark groups that can hold related benchmark
    code. Accordingly, we created a function named `fibonacci_benchmark`, which we
    then pass on to the `criterion_group!` macro. This assigns a name of `fib_bench`
    to this benchmark group. The `fibonacci_benchmark` function takes in a mutable
    reference to a `criterion` object, which holds the state of our benchmark runs.
    This exposes a method called `bench_function`, which we use to pass in our benchmark
    code to run in a closure with a given name (above `fibonacci 8`). Then, we need
    to create the main benchmark harness, which generates code with a `main` function
    to run all of it by using `criterion_main!`, before passing in our benchmark group,  `fib_bench`.
    Now, it''s time to run `cargo bench` with the first `slow_fibonacci` function
    inside the closure. We get the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，criterion 有一个概念叫做基准测试组，它可以包含相关的基准测试代码。相应地，我们创建了一个名为 `fibonacci_benchmark`
    的函数，然后将其传递给 `criterion_group!` 宏。这给这个基准测试组分配了一个名为 `fib_bench` 的名称。`fibonacci_benchmark`
    函数接收一个对 `criterion` 对象的可变引用，该对象持有我们的基准测试运行的状态。这暴露了一个名为 `bench_function` 的方法，我们使用它将我们的基准测试代码传递到一个具有给定名称的闭包中（上面是
    `fibonacci 8`）。然后，我们需要创建主要的基准测试 harness，它使用 `criterion_main!` 生成带有 `main` 函数的代码来运行所有这些，在传递我们的基准测试组
    `fib_bench` 之前。现在，是时候运行 `cargo bench` 并在闭包中包含第一个 `slow_fibonacci` 函数了。我们得到以下输出：
- en: '![](img/52a10831-cbb4-457a-816a-6fac29cac734.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/52a10831-cbb4-457a-816a-6fac29cac734.png)'
- en: 'We can see that the recursive version of our `fibonacci` function takes about
    106.95 ns to run on average. Now, within the same benchmark closure, if we replace
    our `slow_fibonacci` with our `fast_fibonacci` and run `cargo bench` again, we''ll
    get the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的 `fibonacci` 函数的递归版本平均运行时间约为 106.95 纳秒。现在，在同一个基准测试闭包中，如果我们用 `fast_fibonacci`
    替换 `slow_fibonacci` 并再次运行 `cargo bench`，我们将得到以下输出：
- en: '![](img/b0014a93-911b-4f03-ad70-5f1633c66d0a.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0014a93-911b-4f03-ad70-5f1633c66d0a.png)'
- en: 'Great! The `fast_fibonacci` version takes just 7.8460 ns to run on average.
    That''s obvious, but the great thing about this is the detailed benchmark report,
    which also shows a human-friendly message: Performace has improved. The reason
    criterion is able to show this regression report is that it maintains the previous
    state of benchmark runs and uses their history to report changes in performance.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`fast_fibonacci` 版本平均运行时间仅为 7.8460 纳秒。这是显而易见的，但真正令人兴奋的是详细的基准测试报告，它还显示了一个人性化的消息：性能已提升。criterion
    能够显示这个回归报告的原因是它维护了基准测试运行的先前状态，并使用它们的历史记录来报告性能的变化。
- en: Writing and testing a crate – logic gate simulator
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和测试一个 crate – 逻辑门模拟器
- en: Armed with all of this knowledge, let's start things off with our logic gate
    simulation crate. We'll create a new project by running `cargo new logic_gates
    --lib`. Starting with primitive gates implemented as functions such as `and`,
    `xor`, and so on, we will write unit tests for these gates. Following that, we'll
    write integration tests by implementing a half adder that uses our primitive gates.
    During this process, we'll also get to write documentation for our crate.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 带着所有这些知识，让我们开始我们的逻辑门模拟crate。通过运行`cargo new logic_gates --lib`来创建一个新的项目。从实现为函数的原始门开始，例如`and`、`xor`等，我们将为这些门编写单元测试。随后，我们将通过实现使用我们的原始门的半加器来编写集成测试。在这个过程中，我们还将为我们的crate编写文档。
- en: 'First off, we''ll start with some unit tests. Here''s the initial crate code
    in its entirety:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从一些单元测试开始。以下是初始的crate代码的完整内容：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have started with two logic gates, `and` and `xor`, which have been implemented
    as functions. We also have tests cases against those that fail when run because
    they haven''t been implemented yet. Note that to represent bit `0` and `1`, we
    are using a `u8` as Rust does not have a native type to represent bits. Now, let''s
    fill in their implementation, along with some documentation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个逻辑门`and`和`xor`开始，这些门已经作为函数实现。我们还有针对它们的测试用例，当运行时因为它们尚未实现而失败。注意，为了表示比特`0`和`1`，我们使用`u8`，因为Rust没有原生的类型来表示比特。现在，让我们填写它们的实现，以及一些文档：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding code, we just expressed the truth tables of the `and` and
    `xor` gates using match expressions. We can see how concise match expressions
    can be in expressing our logic. Now, we can run the tests by running `cargo test`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是使用match表达式表达了`and`和`xor`门的真值表。我们可以看到match表达式在表达我们的逻辑时是多么简洁。现在，我们可以通过运行`cargo
    test`来运行测试：
- en: '![](img/6930937c-7ed3-444d-9d53-f972ffae96f7.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6930937c-7ed3-444d-9d53-f972ffae96f7.png)'
- en: 'All green! We are now ready to write integration tests by implementing a half
    adder using these gates. A half adder fits in perfectly as an integration test
    example as it tests the individual components of our crate while they''re being
    used together. Under the `tests/` directory, we''ll create a file called `half_adder.rs`
    that includes the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 全部绿色！我们现在可以使用这些门实现半加器来编写集成测试。半加器完美地适合作为集成测试示例，因为它在组件被一起使用时测试了我们的crate的各个部分。在`tests/`目录下，我们将创建一个名为`half_adder.rs`的文件，其中包含以下代码：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we import our primitive gate functions `xor` and `and`.
    Following that, we have something like `pub type Sum = u8`, which is known as
    a **type alias**. They are helpful in situations where you either have a type
    that is cumbersome to write every time or when you have types with complex signatures.
    It gives another name to our original type and is purely for readability and disambiguation;
    it has no implications in the way Rust analyzes those types. We then use the  `Sum`
    and `Carry` in our `half_adder_input_output` function, which implements the truth
    table for the half adder. This is a convenient helper function to test our `half_adder`
    function that follows it. This function takes in two one-bit inputs and calculates
    the `Sum` and `Carry` from them before returning them as a tuple of `(Sum, Carry)`.
    Further ahead, we have our `one_bit_adder` integration test function, in which
    we iterate over our half adder input output pairs and assert against the output
    of the  `half_adder`. By running `cargo test`, we get the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了我们的原始门函数`xor`和`and`。随后，我们有类似`pub type Sum = u8`的东西，这被称为类型别名。它们在以下情况下很有帮助：当你有一个每次都难以书写的类型，或者当你有具有复杂签名的类型时。它为我们原始类型提供了一个新名称，纯粹是为了可读性和消除歧义；它对Rust分析这些类型的方式没有影响。然后我们在`half_adder_input_output`函数中使用`Sum`和`Carry`，该函数实现了半加器的真值表。这是一个方便的辅助函数，用于测试随后的`half_adder`函数。这个函数接受两个单比特输入，并从它们中计算出`Sum`和`Carry`，然后作为`(Sum,
    Carry)`元组返回。进一步，我们有我们的`one_bit_adder`集成测试函数，其中我们遍历半加器输入输出对，并对`half_adder`的输出进行断言。通过运行`cargo
    test`，我们得到以下输出：
- en: '![](img/0d2972a5-d5a3-4bda-8fbe-eb2d072ae584.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d2972a5-d5a3-4bda-8fbe-eb2d072ae584.png)'
- en: 'Great ! Let''s also generate documentation for our crate by running `cargo
    doc --open`. The `--open` flag opens the page for us to view in a browser. To
    customize our documentation, we''ll also add an icon to our crate docs page. To
    do this, we need to add the following attribute at the top of `lib.rs`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们也通过运行 `cargo doc --open` 为我们的 crate 生成文档。`--open` 标志会在浏览器中为我们打开页面。为了自定义我们的文档，我们还将向
    crate 文档页面添加一个图标。为此，我们需要在 `lib.rs` 的顶部添加以下属性：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After generation, the documentation page looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 生成后，文档页面看起来是这样的：
- en: '![](img/fb250dfc-08a7-4a13-b628-21c9b54654bd.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb250dfc-08a7-4a13-b628-21c9b54654bd.png)'
- en: This is great! We have come a long way in our testing journey. Next, let's look
    at the aspect  automating out test suites.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们在测试之旅上已经走了很长的路。接下来，让我们看看自动化测试套件的方面。
- en: Continuous integration with Travis CI
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Travis CI 进行持续集成
- en: It is often the case in large software systems that for every change to our
    code, we want both our unit and integration tests to run automatically. Moreover,
    in a collaborative project, the manual way is just not practical. Fortunately,
    Continuous Integration is a practice that aims to automate those aspects of software
    development. Travis CI is a public continuous integration service that allows
    you to run your project's tests automatically in the cloud, based on event hooks.
    One example of an event hook is when new commits are pushed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型软件系统中，对于代码的每一次更改，我们通常都希望自动运行我们的单元测试和集成测试。此外，在协作项目中，手动方式显然不切实际。幸运的是，持续集成是一种旨在自动化软件开发这些方面的实践。Travis
    CI 是一个公共持续集成服务，允许您根据事件钩子在云中自动运行您项目的测试。事件钩子的一个例子是在推送新提交时。
- en: 'Travis is generally used to automate running builds and tests and to report
    failed builds, but can also be used for creating releases and even deploying them
    in staging or production environments. We''ll focus on one aspect of Travis in
    this section, performing automated runs of our tests for our project. GitHub already
    has integration with Travis that can run tests for new commits in our project.
    To make this happen, we need the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Travis 通常用于自动化运行构建和测试以及报告失败的构建，但也可以用于创建发布版本，甚至部署到预发布或生产环境。在本节中，我们将关注 Travis
    的一个方面，即为我们项目执行自动测试。GitHub 已经集成了 Travis，可以为我们项目的每个新提交运行测试。为了实现这一点，我们需要以下内容：
- en: Our project on GitHub
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 GitHub 上的项目
- en: An account in Travis, which is made by logging in with GitHub
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 GitHub 登录创建的 Travis 账户
- en: Your project enabled for builds in Travis
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的项目已在 Travis 中启用构建
- en: A `.travis.yml` file at the root of your repository that tells Travis what to
    run on
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的仓库根目录下的 `.travis.yml` 文件，告诉 Travis 要运行什么
- en: 'The first step is to go to [https://travis-ci.org/](https://travis-ci.org/)
    and log in with your GitHub credentials. From there, we can add our GitHub repository
    in Travis. Travis has good native support for Rust projects and keeps its Rust
    compiler continuously up to date. It provides a basic version of the `.travis.yml`
    file for Rust projects, which is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是前往 [https://travis-ci.org/](https://travis-ci.org/) 并使用您的 GitHub 凭据登录。从那里，我们可以在
    Travis 中添加我们的 GitHub 仓库。Travis 对 Rust 项目有良好的原生支持，并持续更新其 Rust 编译器。它为 Rust 项目提供了一个基本的
    `.travis.yml` 文件，如下所示：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Rust project recommends testing against beta and nightly channels too, but
    you may choose to target just a single version by removing the corresponding lines.
    This recommended setup runs the tests on all three versions, but allows the fast-moving
    nightly compiler to fail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 项目还建议针对 beta 和 nightly 频道进行测试，但您可以选择通过删除相应的行来仅针对单个版本进行目标。此推荐设置在所有三个版本上运行测试，但允许快速移动的
    nightly 编译器失败。
- en: With this `.travis.yml` file in your repository, GitHub will inform Travis CI
    every time you push your code and run your tests automatically. We can also attach
    build status badges to our repository's `README.md` file, which shows a green
    badge when tests pass and a red badge in when tests fail.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的仓库中拥有这个 `.travis.yml` 文件，GitHub 将在您每次推送代码并运行测试时通知 Travis CI。我们还可以将构建状态徽章附加到仓库的
    `README.md` 文件中，当测试通过时显示绿色徽章，当测试失败时显示红色徽章。
- en: 'Let''s integrate Travis with our `logic_gates` crate. For this, we have to
    add a `.travis.yml` file at our crate root. The following is the contents of the `.travis.yml` file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Travis 与我们的 `logic_gates` crate 集成。为此，我们必须在 crate 根目录下添加一个 `.travis.yml`
    文件。以下是为 `.travis.yml` 文件的内容：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After pushing this to GitHub, we then need to enable Travis for our project
    on their page, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将此推送到 GitHub 后，我们接下来需要在他们的页面上启用 Travis 以用于我们的项目，如下所示：
- en: '![](img/6cf809eb-a568-430d-acdd-dd7942b2ada8.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cf809eb-a568-430d-acdd-dd7942b2ada8.png)'
- en: 'The preceding screenshot is from my TravisCI account. Now, we''ll make a commit
    to our `logic_gates` repository by adding a simple `README.md` file to trigger
    the Travis build runner. While we do this, let''s also add a build badge to our
    `README.md` file that will show the status of our repository to consumers. To
    do this, we''ll click the build passing badge on the right:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图来自我的TravisCI账户。现在，我们将通过向我们的`logic_gates`仓库添加一个简单的`README.md`文件来提交一个commit，以触发Travis构建运行器。在此过程中，我们还将向`README.md`文件添加一个构建徽章，以便向消费者展示我们仓库的状态。为此，我们将点击右侧的构建通过徽章：
- en: '![](img/df44efff-27ec-48b2-aabf-f62f4aa402be.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df44efff-27ec-48b2-aabf-f62f4aa402be.png)'
- en: 'This opens up a popup menu with the badge link:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个包含徽章链接的弹出菜单：
- en: '![](img/28fb3d03-5593-4f32-abfb-a7e09dd74dc1.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28fb3d03-5593-4f32-abfb-a7e09dd74dc1.png)'
- en: 'We will copy this link and add it to the top in our `README.md` file as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制此链接并将其添加到`README.md`文件的顶部，如下所示：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You need to replace `$USERNAME` and `$REPO_NAME` with your details.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`$USERNAME`和`$REPO_NAME`替换为您自己的详细信息。
- en: 'After this change and committing the `README.md` file, we will start to see
    the Travis build starting and succeeding:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改并提交`README.md`文件之后，我们将开始看到Travis构建开始并成功：
- en: '![](img/1daa5147-2ee3-4b1a-be63-0e5d20c713c5.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1daa5147-2ee3-4b1a-be63-0e5d20c713c5.png)'
- en: Awesome! If you are feeling more ambitious, you can also try hosting the `logic_gates`
    crate's documentation on your repository's `gh-pages` branch on GitHub. You can
    do this by using the `cargo-travis` project, which is available at [https://github.com/roblabla/cargo-travis\](https://github.com/roblabla/cargo-travis).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果您更有雄心，您还可以尝试在GitHub仓库的`gh-pages`分支上托管`logic_gates` crate的文档。您可以通过使用可在[https://github.com/roblabla/cargo-travis](https://github.com/roblabla/cargo-travis)找到的`cargo-travis`项目来实现这一点。
- en: For an even more versatile CI setup that covers major platforms, you can use
    the template provided by the trust project, which is available at [https://github.com/japaric/trust](https://github.com/japaric/trust).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更通用的CI设置，它涵盖了主要平台，您可以使用信任项目提供的模板，该模板可在[https://github.com/japaric/trust](https://github.com/japaric/trust)找到。
- en: 'Finally, to publish your crate on *crates.io*, you can follow the directions
    given in Cargo''s reference documentation: [https://doc.rust-lang.org/cargo/reference/publishing.html](https://doc.rust-lang.org/cargo/reference/publishing.html).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在*crates.io*上发布您的crate，您可以按照Cargo参考文档中给出的说明操作：[https://doc.rust-lang.org/cargo/reference/publishing.html](https://doc.rust-lang.org/cargo/reference/publishing.html)。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got acquainted with writing unit tests, integration tests,
    documentation tests, and benchmarks using both `rustc` and the `cargo` tool. We
    then implemented a logic gate simulator crate and got to experience the whole
    crate development workflow. Later, we learned how to integrate Travis CI for our
    GitHub project.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了使用`rustc`和`cargo`工具编写单元测试、集成测试、文档测试和基准测试。然后，我们实现了一个逻辑门模拟crate，并体验了整个crate开发工作流程。之后，我们学习了如何将Travis
    CI集成到我们的GitHub项目中。
- en: In the next chapter, we'll explore Rust's type system and how to use it to express
    proper semantics in our program at compile time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Rust的类型系统以及如何在编译时使用它来在我们的程序中表达正确的语义。
