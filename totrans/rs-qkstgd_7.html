<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic Types</h1>
                </header>
            
            <article>
                
<p class="mce-root">Sometimes, the details of a data type just don't matter. Our code would work just as well no matter what the data type is, as long as it's <em>something</em>.</p>
<p>We've seen examples of this sort of situation many times already, such as with <kbd>Result</kbd>, <kbd>Option</kbd>, <kbd>Rc</kbd>, and so on. All of them, and many more, can work with a wide range of different data types, because they have one or more <em>generic type parameter</em>s.</p>
<p>In this chapter, we're going to do the following:</p>
<ul>
<li>Learn what generic type parameters are</li>
<li>Learn how to apply <span>generic type parameters</span> to data types</li>
<li>Learn how to apply <span>generic type parameters</span> to functions</li>
<li>Learn how generic types and trait objects differ</li>
<li>Create a complete and useful binary tree data structure</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types with generic type parameters</h1>
                </header>
            
            <article>
                
<p>When a data type has generic type parameters, it's not, <span>strictly speaking,</span> actually a data type at all. It is a whole family of data types. Let's look at <kbd>Option</kbd> for a moment. <kbd>Option</kbd> is defined as follows:</p>
<pre class="rust"><span class="kw">pub</span> <span class="kw">enum</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt; {<br/>    None,<br/>    Some(T),<br/>}</span></pre>
<p>This means that it has one generic type parameter with the name <kbd>T</kbd>. If we try to use <kbd>Option</kbd> without specifying a type for that generic type parameter, Rust will report an error:</p>
<pre>let x: Option = None;</pre>
<p>It produces this error:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a77720ef-620f-4f6e-b393-75459d3f3a27.png" style="width:38.58em;height:6.25em;" width="662" height="107"/></p>
<p>What that's telling us, in essence, is that <kbd>Option</kbd> isn't a usable data type. However, <kbd>Option&lt;u32&gt;</kbd> is, as is <kbd>Option&lt;String&gt;</kbd>, <kbd>Option&lt;Result&lt;f64, String&gt;&gt;</kbd>, and so on. Moreover, <kbd>Option&lt;u32&gt;</kbd> and <kbd>Option&lt;String&gt;</kbd> are not the same type, and Rust won't pretend that they are. They're two different data types that have the same shape, as it were.</p>
<p>When we write <kbd>Option&lt;String&gt;</kbd>, we're telling Rust that it should make a data type by substituting <kbd>String</kbd> for the <kbd>T</kbd> in the definition of <kbd>Option</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Limiting what types can be used for type parameters</h1>
                </header>
            
            <article>
                
<p class="mce-root">Sometimes, we need our type to have generic type parameters, but we don't want them to be <em>totally</em> generic. For example, we might need the type that's substituted for the parameter to be able to be moved between threads, or to support transformation into <kbd>String</kbd>, or any number of other things. Fortunately, Rust provides a way for us to do that.</p>
<p>We limit the domain of a generic type parameter by requiring it to have one or more traits. This is called a trait bound. Let's look at a basic binary tree data structure as an example.</p>
<div class="packt_infobox">A binary tree is made up of nodes. Each node has a key, an associated value, and two sub-trees: one for nodes with keys that are less than the current node's key, and one for nodes with keys that are greater. Finding a node with a particular key in the tree is just a matter of comparing it to the root node's key, then if it isn't the same, picking either the lesser or greater tree, and doing the same thing there, and so on.</div>
<p class="mce-root"/>
<p>Here are a pair of structures that represent a binary tree, with generic type parameters for the key and value types, and a trait bound on the key type to make sure it actually supports the comparisons we need for a binary tree key:</p>
<pre>struct TreeNode&lt;K, V&gt; where K: PartialOrd + PartialEq {<br/>    key: K,<br/>    value: V,<br/>    lesser: Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;,<br/>    greater: Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;,<br/>}</pre>
<p>Here is the second structure, which gives us a way to store an empty tree:</p>
<pre>pub struct Tree&lt;K, V&gt; where K: PartialOrd + PartialEq {<br/>    root: Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;,<br/>}</pre>
<p>We need the second structure so that a tree containing no data can be represented. On both of these structures, we've placed the names of the generic type parameters between <kbd>&lt;</kbd> and <kbd>&gt;</kbd> after the structure name, but then we included a <kbd>where</kbd> clause that says that <kbd>K: PartialOrd + PartialEq</kbd>. That means that any data type that is substituted for <kbd>K</kbd> <em>must</em> implement both the <kbd>PartialOrd</kbd> trait and the <kbd>PartialEq</kbd> trait. If we try to use a data type that does not implement both traits, the compiler will reject it.</p>
<div class="packt_tip">We'll examine the specific meanings of <kbd>PartialOrd</kbd> and <kbd>PartialEq</kbd> in <a href="a10c4fb7-f282-4769-9b35-5ab56a619eea.xhtml" target="_blank">Chapter 8</a>, <em>Important Standard Traits</em>. Roughly, they mean that the concepts of <em>greater</em> and <em>lesser</em> apply to the key.</div>
<p>We've also specified that <kbd>lesser</kbd> and <kbd>greater</kbd> in <kbd>TreeNode</kbd> and <kbd>root</kbd> in <kbd>Tree</kbd> are variables with the <kbd>Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;</kbd> data type . That means that they are optional (they can contain a meaningful value, or <kbd>None</kbd>), and if they contain a meaningful value, it is stored on the heap, and that value stored on the heap is a <kbd>TreeNode</kbd> with <kbd>K</kbd> as the data type of its key, and <kbd>V</kbd> as the data type of its value.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing functionality for types with generic type parameters</h1>
                </header>
            
            <article>
                
<p class="mce-root">If we want to have functions that are part of a type with generic type parameters, we need to have an implementation block, the same as if the type didn't have those parameters, but we need to parameterize the implementation block, too.</p>
<p>Here is the beginning of our implementation block for the <kbd>TreeNode</kbd> type:</p>
<pre>impl&lt;K, V&gt; TreeNode&lt;K, V&gt; where K: PartialOrd + PartialEq {</pre>
<p>Now, <kbd>TreeNode&lt;K, V&gt;</kbd> is the data type we're implementing functionality for. It's the <kbd>impl&lt;K, V&gt;</kbd> part that tells the compiler that <kbd>K</kbd> and <kbd>V</kbd> are generic type parameters, and it's <kbd>K: PartialOrd + PartialEq</kbd> that tells it the trait bounds for those parameters. It does not just use the same generic type parameters and trait bounds that were specified for the data type, because implementation blocks are allowed to differ from the data type; for example, there's an implementation block for <kbd>Box&lt;Any&gt;</kbd> that provides the <kbd>downcast</kbd> function for a boxed <kbd>Any</kbd>, which is not a part of <kbd>Box</kbd> under other circumstances. If the implementation block's trait bounds match what is actually being using for type parameters, the functions in the block are available. If they do not, the functions are not available.</p>
<p>Inside the implementation block, we can use <kbd>K</kbd> and <kbd>V</kbd> as the names of data types:</p>
<pre>    fn set(&amp;mut self, key: K, value: V) {<br/>        if key == self.key {<br/>            self.value = value;<br/>        }<br/>        else if key &lt; self.key {<br/>            match self.lesser {<br/>                None =&gt; {<br/>                    self.lesser = Some(<br/>                        Box::new(TreeNode {key, value, lesser: None, <br/>                        greater: None })<br/>                    );<br/>                },<br/>                Some(ref mut lesser) =&gt; {<br/>                    lesser.set(key, value);<br/>                }<br/>            }<br/>        }<br/>        else {<br/>            match self.greater {<br/>                None =&gt; {<br/>                    self.greater = Some(<br/>                        Box::new(TreeNode {key, value, lesser: None, <br/>                        greater: None })<br/>                    );<br/>                }<br/>                Some(ref mut greater) =&gt; {<br/>                    greater.set(key, value);<br/>                }<br/>            }<br/>        }<br/>    }</pre>
<p>Here we have the code to associate a key with a value inside our binary tree. It starts off with a pretty standard function definition, except that we're using <kbd>K</kbd> and <kbd>V</kbd> to specify the data types of the <kbd>key</kbd> and <kbd>value</kbd> parameters. We mutably borrow <kbd>self</kbd> because setting a contained value is a mutation.</p>
<p>Inside the function, we first compare the current node's key to the key we're looking for, and if they're the same, we just assign the value to the current node.</p>
<p>Next, we check whether the key we're looking for is less than or greater than the current node's key, and use that to select which branch of the tree to travel down. Either way, we use a <kbd>match</kbd> expression to figure out whether there actually is a branch on that side, and if there's not, we create one containing the specified key and value. If there <em>is</em> a branch on that side, we call that node's <kbd>set</kbd> function, which does the same thing all over again except with a different <kbd>self</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using generic types as function return values</h1>
                </header>
            
            <article>
                
<p>Within an implementation block that has generic type parameters, we can use those parameter names as part of function return values, too.</p>
<p>Here is an example function that uses generic type parameter names in its <kbd>return</kbd> data type:</p>
<pre>    fn get_ref(&amp;self, key: K) -&gt; Result&lt;&amp;V, String&gt; {<br/>        if key == self.key {<br/>            return Ok(&amp;self.value);<br/>        }<br/>        else if key &lt; self.key {<br/>            match self.lesser {<br/>                None =&gt; {<br/>                    return Err("No such key".to_string());<br/>                }<br/>                Some(ref lesser) =&gt; {<br/>                    return lesser.get_ref(key);<br/>                }<br/>            }<br/>        }<br/>        else {<br/>            match self.greater {<br/>                None =&gt; {<br/>                    return Err("No such key".to_string());<br/>                }<br/>                Some(ref greater) =&gt; {<br/>                    return greater.get_ref(key);<br/>                }<br/>            }<br/>        }<br/>    }</pre>
<p>This function looks up a key in the binary tree, and returns an immutable borrow of the associated value, or an error message if the key is not present in the tree.</p>
<p>It's structured very similarly to the <kbd>set</kbd> function we saw before, but since we're not changing anything or asking for a mutable borrow, <kbd>self</kbd> can be a plain old immutable borrow as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compiler errors involving generic type parameters</h1>
                </header>
            
            <article>
                
<p class="mce-root">Our tree structure requires that the data type used for the key has to have the <kbd>PartialOrd</kbd> and <kbd>PartialEq</kbd> traits. The <kbd>&amp;str</kbd> type happens to have those traits, so we can use an <kbd>&amp;str</kbd> for the key:</p>
<pre>let mut tree: Tree&lt;&amp;'static str, f32&gt; = Tree::new();<br/><br/>tree.set("first key", 12.65);<br/>tree.set("second key", 99.999);<br/>tree.set("third key", -128.5);<br/>tree.set("fourth key", 67.21);<br/><br/>println!("tree.get_ref(\"third key\") is {}", match tree.get_ref("third key") {<br/>    Err(_) =&gt; {println!("Invalid!"); &amp;0.0},<br/>    Ok(x) =&gt; x,<br/>});</pre>
<p>Here, we've created a <kbd>Tree&lt;&amp;'static str, f32&gt;</kbd>, or a tree that maps static strings to 32-bit floating point numbers. If we compile and run a complete program containing that snippet, everything works beautifully.</p>
<p>This data type, on the other hand, does not have the <kbd>PartialOrd</kbd> trait:</p>
<pre>pub enum NotOrdered {<br/>    A,<br/>    B,<br/>    C,<br/>}</pre>
<p>If we substitute <kbd>NotOrdered</kbd> for <kbd>&amp;'static str</kbd> as the key type for the tree, we suddenly get seven different compiler errors, which probably fill up the entire screen. Most of them look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/768756f1-0bcc-4222-97bf-d6c3b062fe3a.png" width="1000" height="237"/></p>
<p>This is telling us that the function was defined inside an implementation block that requires <kbd>PartialOrd</kbd> and <kbd>PartialEq</kbd>. Since our <kbd>NotOrdered</kbd> data type doesn't have those traits, the function we're trying to call doesn't exist, and the compiler is telling us that.</p>
<p>Up at the top of the list of errors, and possibly scrolled right off the screen, is a different error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/93b1ad4d-62d5-43b6-a7f8-9e2ec03707b5.png" width="1242" height="237"/></p>
<p>This error message is somewhat more helpful than the other one, but it stems from the same cause. Our <kbd>Tree</kbd> data type requires a key type whose values can be compared to other values of the same type, and <kbd>NotOrdered</kbd> just doesn't provide that.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic types on functions outside of implementation blocks</h1>
                </header>
            
            <article>
                
<p>It's possible to use generic type parameters for functions even when they're not part of an implementation block. That looks like this:</p>
<pre>fn print_generic&lt;T&gt;(value: T) where T: Display {<br/>    println!("{}", value);<br/>}</pre>
<p>This function has a generic type parameter, <kbd>T</kbd>, which can be any data type that has the <kbd>Display</kbd> trait. That means that, if this function is defined, we can do things like this:</p>
<pre>print_generic(12.7);<br/>print_generic("Hello");<br/>print_generic(75);</pre>
<p>Each of those lines calls a different <kbd>print_generic</kbd> function, specialized for the data type of the parameter. The compiler generates code for each version of <kbd>print_generic</kbd> that we use, each one accepting a different data type for its parameter.</p>
<div class="packt_tip">Of course, <kbd>print_generic</kbd> doesn't do anything that the plain <kbd>println!</kbd> macro doesn't, but it serves to demonstrate the ways of generic type parameters for standalone functions.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Alternative ways to write trait bounds</h1>
                </header>
            
            <article>
                
<p>So far, we've been writing trait bounds as a <kbd>where</kbd> clause, but there are two alternative ways of writing them. The <kbd>where</kbd> clause is nice because it's somewhat out of the way, allowing us to write even complex trait bounds without interfering with reading the rest of the function or data type declaration.</p>
<p>The first alternative is to put the trait bounds alongside the generic type parameter names, like this:</p>
<pre>impl&lt;K: PartialOrd + PartialEq, V&gt; TreeNode&lt;K, V&gt; {</pre>
<p>For a standalone function, that technique looks like this:</p>
<pre>fn print_generic&lt;T: Display&gt;(value: T) {</pre>
<p class="mce-root">This can be good for data types or functions that only have simple trait bounds, but we can see that even with just two required traits, the <kbd>TreeNode</kbd> implementation block is getting a little hard to read. The trait bound kind of breaks up the flow and makes us go looking for the data type's name when we want to find it.</p>
<p>There's another way of specifying trait bounds that only works for functions:</p>
<pre>fn requires_trait(value: impl Display)  {</pre>
<p>What we're saying here is that the <kbd>value</kbd> parameter can be any data type that has the <kbd>Display</kbd> trait. As with any other function with generic type parameters, the compiler will generate a different version of the function for each data type that is actually used for <kbd>value</kbd>. However, using this syntax, we didn't give the generic type parameter a name, so we can't refer to it elsewhere in the function.</p>
<p class="mce-root">Within the body of the function, that's not usually much of a problem, because we can usually skip specifying data types inside the function body and just rely on the compiler to figure it out.</p>
<p>We can also use a similar syntax to specify the return type of our function, which is handy because if we don't have a name for one or more of the parameter types, it can be hard to write the return type:</p>
<pre>fn requires_trait(value: impl Display) -&gt; impl Display {</pre>
<p>This doesn't mean that the function could return any data type as long as it implements <kbd>Display</kbd> (the correct way to do that would be to return a trait object, such as <kbd>Box&lt;dyn Display&gt;</kbd>), but all we care about is that the return type <em>does</em> implement <kbd>Display</kbd>, and we want the compiler to figure out the details of the return type beyond that.</p>
<p>To make that clear, here is a function that tries to return two different data types, both of which implement <kbd>Display</kbd>:</p>
<pre>fn faulty_return(sel: bool) -&gt; impl Display {<br/>    if sel {<br/>        return 52;<br/>    } else {<br/>        return "Oh no";<br/>    }<br/>}</pre>
<p>Here is the error message that Rust gives when we try to compile it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c31e0023-4785-49fe-8e4f-ffbc2a9c14d2.png" style="width:40.92em;height:9.00em;" width="742" height="163"/></p>
<p>When it finds the <kbd>return 52</kbd>, Rust checks that <kbd>52</kbd> implements <kbd>Display</kbd> (it does) and decides that the actual return type of the function is some form of integer. Then, it finds the second <kbd>return</kbd> and decides that something is wrong, because even though <kbd>"Oh no"</kbd> also implements <kbd>Display</kbd>, it's definitely not an integer. Returning an <kbd>impl Display</kbd> or similar doesn't mean returning anything that implements <kbd>Display</kbd>; it means figuring out the specific type we're returning, as long as it implements <kbd>Display</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic types versus trait objects</h1>
                </header>
            
            <article>
                
<p>We can use trait objects in a very similar way to generic type parameters. From one point of view, these two functions do the same thing:</p>
<pre>fn print_generic&lt;T&gt;(value: T) where T: Display {<br/>    println!("{}", value);<br/>}</pre>
<p>This might seem like it does the same thing as the previous code:</p>
<pre>fn print_trait(value: &amp;dyn Display) {<br/>    println!("{}", value);<br/>}</pre>
<p>The first has a generic type parameter with a trait bound, the second accepts a trait object, which means both of them can work with many different data types, as long as the type in question has the <kbd>Display</kbd> trait.</p>
<p>Underneath, though, they're very different. The generic function is used to generate a version of the function that is specialized for each data type that is passed to it, while the compiler is running. That means that when we call the function while the program is running,the computer doesn't have to spend any time at all considering the differences between various data types. It just calls the function the compiler told it to use, which is the version specialized for the data type that's actually being used. This is faster, but all the various versions of generic functions make the program a little larger.</p>
<div class="packt_tip">This process of turning a generic type-based pattern for a function into multiple actual functions specialized for specific types is called <em>monomorphization</em>.</div>
<p>The function that accepts a trait object as its parameter, on the other hand, has only one version, but the computer has to deal with the differences between the various data types that have the <kbd>Display</kbd> trait while it's running. This is slower, but requires a little less memory.</p>
<p>As a rule of thumb, opt to use generic type parameters when you can. We do things at runtime when they can't be done at compile time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Higher-order functions and trait bounds that represent functions</h1>
                </header>
            
            <article>
                
<p>A higher-order function is a function that takes another function, or a closure, as a parameter. In Rust, there are three somewhat unusual traits that allow us to specify a function or closure as a parameter's trait bound: <kbd>Fn</kbd>, <kbd>FnOnce</kbd>, and <kbd>FnMut</kbd>.</p>
<p>The differences between these traits are defined by what kind of variable access they permit:</p>
<ul>
<li><kbd>FnOnce</kbd> is the most widely applicable of these traits, because it has the fewest requirements on what types can implement it. An <kbd>FnOnce</kbd> only guarantees that it is safe to call it once. A function that consumes <kbd>self</kbd> is an example of a natural <kbd>FnOnce</kbd>, because having consumed <kbd>self</kbd>, it no longer has a <kbd>self</kbd> to be called on in future. Functions and closures that are safe to be called more than once still implement <kbd>FnOnce</kbd>, because calling them exactly once isn't an error. That means that a variable that is constrained to be an <kbd>FnOnce</kbd> can accept any sort of function or closure.</li>
<li><kbd>FnMut</kbd><span><span> is the next most widely applicable trait. An <kbd>FnMut</kbd> guarantees that it is safe to call it more than once, but it doesn't promise not to change variable values elsewhere in the code via mutable borrows. A function that uses <kbd>&amp;mut self</kbd> is an example of a natural <kbd>FnMut</kbd>, because it might change one or more of the variables contained in its <kbd>self</kbd>. Functions and closures that can't or don't actually change any outside variables still implement <kbd>FnMut</kbd>, because using them in a place where mutating is allowed isn't an error.</span></span></li>
<li><kbd>Fn</kbd> is the least applicable, since it guarantees that it can be called multiple times and it will not change any outside variables. Anything that is <kbd>Fn</kbd> can safely be used where an <kbd>FnMut</kbd> or <kbd>FnOnce</kbd> was expected, but the reverse is not true.</li>
</ul>
<p>That means that when we're the receiver, we should prefer to accept <kbd>FnOnce</kbd> if possible, or <kbd>FnMut</kbd> as a second choice, and <kbd>Fn</kbd> as the last choice when we truly need all of those guarantees, so as to give the people who are sending the data value to us the maximum flexibility in what they choose to send.</p>
<p>Here is a very simple higher-order function, which uses a trait bound to specify what kind of function can be assigned to the <kbd>f</kbd> parameter:</p>
<pre>fn higher_order(f: impl FnOnce(u32) -&gt; u32) {<br/>    f(5);<br/>}</pre>
<p>So, that looks a little odd. <kbd>FnOnce(u32) -&gt; u32</kbd> is the complete name of the trait that we're requiring data types for <kbd>f</kbd> to implement. <span>The special syntax that allows us to specify the parameter and return types for </span><kbd>Fn</kbd><span>, </span><kbd>FnMut</kbd><span>, and </span><kbd>FnOnce</kbd><span> is unique to those traits; we can't do similar things anywhere else.</span></p>
<p>Just to be clear, that function definition could have also been written as follows:</p>
<pre>fn higher_order2&lt;F&gt;(f: F) where F: FnOnce(u32) -&gt; u32 {<br/>    f(5);<br/>}</pre>
<p>We could also have written the same thing as follows:</p>
<pre>fn higher_order3&lt;F: FnOnce(u32) -&gt; u32&gt;(f: F) {<br/>    f(5);<br/>}</pre>
<p>All of the preceding code means the same thing: the function's <kbd>f</kbd> parameter needs to implement the <kbd>FnOnce</kbd> trait, and accept a single <kbd>u32</kbd> parameter, and return a <kbd>u32</kbd>. </p>
<p class="mce-root"/>
<p>Here's a bit of code that calls our <kbd>higher_order</kbd> function and passes it a closure to be used as the value of <kbd>f</kbd>:</p>
<pre>let mut y = "y".to_string();<br/>higher_order(|x: u32| {<br/>    y.push('X');<br/>    println!("In the closure, y is now {}", y);<br/>    x<br/>});<br/>println!("After higher_order, y is {}", y);</pre>
<p>This closure has one parameter named <kbd>x</kbd>, defined between the <kbd>|</kbd> and <kbd>|</kbd> symbols, but it also accesses the <kbd>y</kbd> variable that was defined on the first line. In addition, it changes the value of that variable, meaning it requires mutable access. Thus, this closure implements <kbd>FnOnce</kbd> and <kbd>FnMut</kbd>, but not <kbd>Fn</kbd>.</p>
<p>If we change <kbd>higher_order</kbd> to require the <kbd>Fn</kbd> trait and try compiling this code, we get a compiler error, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7382d144-1317-405d-a1c7-606515ac039e.png" style="width:47.50em;height:16.92em;" width="896" height="319"/></p>
<p>This error is not particularly illuminating. What it means is that we told <kbd>higher_order</kbd> to require an <kbd>Fn</kbd>, and then we passed it a closure that therefore <em>must</em> be an <kbd>Fn</kbd>, but we tried to perform a mutating operation inside of the closure, where we don't have a mutable <kbd>borrow</kbd> because Rust is sure that the closure must have the <kbd>Fn</kbd> trait, so it reports an error about trying a mutating operation on a non-mutable variable.</p>
<p>All we need to do to fix this is change the trait bound on the <kbd>higher_order</kbd> function's <kbd>f</kbd> parameter back to <kbd>FnOnce</kbd> (or <kbd>FnMut</kbd>) so that the closure is allowed to perform the <kbd>push</kbd> operation on <kbd>y</kbd>.</p>
<p class="mce-root"/>
<p>Once we restore <kbd>f</kbd> to have the proper trait bound, what does this code actually do?:</p>
<ol>
<li>Creates a mutable variable <kbd>y</kbd> containing a <kbd>String</kbd></li>
<li>Constructs a closure that captures a mutable borrow of the <kbd>y</kbd> variable, and accepts an <kbd>x</kbd> parameter</li>
<li>Passes that closure to <kbd>higher_order</kbd> as the value of the <kbd>f</kbd> parameter</li>
<li><kbd>higher_order</kbd> then calls <kbd>f</kbd> (which is our closure), passing it <kbd>5</kbd> as the value of its <kbd>x</kbd> parameter</li>
<li>Within the closure, the following occurs:
<ol>
<li>The character <kbd>'X'</kbd> is appended to the string stored in <kbd>y</kbd></li>
<li>The new value of <kbd>y</kbd> is printed</li>
<li>The value of <kbd>x</kbd> is returned, and becomes the result of the <kbd>f(5)</kbd> expression</li>
</ol>
</li>
<li><kbd>higher_order</kbd> returns</li>
<li>The current value of the <kbd>y</kbd> variable is printed</li>
</ol>
<div class="packt_tip">Notice that the code inside the closure does not run until the closure is called, but it has access to the variables that were defined in the scope where it was created. </div>
<p class="mce-root">Both of the printouts of <kbd>y</kbd> print the string <kbd>yX</kbd>, because they are both referring to the same actual variable, whether directly or via a mutable borrow.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Complete implementation of a binary tree with generic type parameters</h1>
                </header>
            
            <article>
                
<p>We've finally progressed far enough in our journey through Rust that we can produce something truly useful. Our binary tree could still be improved in any number of ways, but it does what it was designed to do: it allows us to easily store and retrieve any number of key/value pairs.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_tip">We made no effort to ensure that the binary tree remains balanced, meaning that the left and right branches of each node are approximately the same height, because that wouldn't have added anything to our discussion of generic types. If we had, this data structure would also be guaranteed to be efficient. Balanced binary trees are close to being as good as you can get when it comes to arbitrary key/value data structures.</div>
<p>So, here we have a complete, useful data structure. First we have the actual structure that stores the tree node data:</p>
<p class="mce-root"/>
<div>
<pre>struct TreeNode&lt;K, V&gt; where K: PartialOrd + PartialEq {<br/>    key: K,<br/>    value: V,<br/>    lesser: Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;,<br/>    greater: Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;,<br/>}</pre></div>
<p>Next, we have the implementation block to define the functionality of the <kbd>TreeNode</kbd> type, starting with the <kbd>set</kbd> function, which associates a key with a value:</p>
<div>
<pre>impl&lt;K, V&gt; TreeNode&lt;K, V&gt; where K: PartialOrd + PartialEq {<br/>    fn set(&amp;mut self, key: K, value: V) {<br/>        if key == self.key {<br/>            self.value = value;<br/>        }<br/>        else if key &lt; self.key {<br/>            match self.lesser {<br/>                None =&gt; {<br/>                    self.lesser = Some(Box::new(TreeNode {key, value, <br/>                     lesser: None, greater: None }));<br/>                },<br/>                Some(ref mut lesser) =&gt; {<br/>                    lesser.set(key, value);<br/>                }<br/>            }<br/>        }<br/>        else {<br/>            match self.greater {<br/>                None =&gt; {<br/>                    self.greater = Some(Box::new(TreeNode {key, value, <br/>                    lesser: None, greater: None }));<br/>                }<br/>                Some(ref mut greater) =&gt; {<br/>                    greater.set(key, value);<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/></pre></div>
<p>The <kbd>get_ref</kbd> and <kbd>get_mut</kbd> functions are structured very similarly to the <kbd>set</kbd> function, because all three of them use the same mechanism to search the tree for a node with the correct key:</p>
<div>
<pre>    fn get_ref(&amp;self, key: K) -&gt; Result&lt;&amp;V, String&gt; {<br/>        if key == self.key {<br/>            return Ok(&amp;self.value);<br/>        }<br/>        else if key &lt; self.key {<br/>            match self.lesser {<br/>                None =&gt; {<br/>                    return Err("No such key".to_string());<br/>                }<br/>                Some(ref lesser) =&gt; {<br/>                    return lesser.get_ref(key);<br/>                }<br/>            }<br/>        }<br/>        else {<br/>            match self.greater {<br/>                None =&gt; {<br/>                    return Err("No such key".to_string());<br/>                }<br/>                Some(ref greater) =&gt; {<br/>                    return greater.get_ref(key);<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    fn get_mut(&amp;mut self, key: K) -&gt; Result&lt;&amp;mut V, String&gt; {<br/>        if key == self.key {<br/>            return Ok(&amp;mut self.value);<br/>        }<br/>        else if key &lt; self.key {<br/>            match self.lesser {<br/>                None =&gt; {<br/>                    return Err("No such key".to_string());<br/>                }<br/>                Some(ref mut lesser) =&gt; {<br/>                    return lesser.get_mut(key);<br/>                }<br/>            }<br/>        }<br/>        else {<br/>            match self.greater {<br/>                None =&gt; {<br/>                    return Err("No such key".to_string());<br/>                }<br/>                Some(ref mut greater) =&gt; {<br/>                    return greater.get_mut(key);<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre></div>
<p>Next comes the definition of our <kbd>Tree</kbd> data type, which provides the public interface to our data structure, and allows us to have an empty tree:</p>
<div>
<pre>pub struct Tree&lt;K, V&gt; where K: PartialOrd + PartialEq {<br/>    root: Option&lt;Box&lt;TreeNode&lt;K, V&gt;&gt;&gt;,<br/>}</pre></div>
<p>And now the implementation block for <kbd>Tree</kbd>, with the public functions that provide us with a way to interact with <kbd>TreeNodes</kbd>:</p>
<div>
<pre>impl&lt;K, V&gt; Tree&lt;K, V&gt; where K: PartialOrd + PartialEq {<br/>    pub fn new() -&gt; Tree&lt;K, V&gt; {<br/>        Tree { root: None }<br/>    }<br/><br/>    pub fn set(&amp;mut self, key: K, value: V) {<br/>        match self.root {<br/>            None =&gt; {<br/>                self.root = Some(Box::new(TreeNode { key, value, <br/>                lesser: None, greater: None }));<br/>            }<br/>            Some(ref mut root) =&gt; {<br/>                root.set(key, value);<br/>            }<br/>        }<br/>    }<br/><br/>    pub fn get_ref(&amp;self, key: K) -&gt; Result&lt;&amp;V, String&gt; {<br/>        match self.root {<br/>            None =&gt; {<br/>                return Err("No such key".to_string());<br/>            }<br/>            Some(ref root) =&gt; {<br/>                return root.get_ref(key);<br/>            }<br/>        }<br/>    }<br/><br/>    pub fn get_mut(&amp;mut self, key: K) -&gt; Result&lt;&amp;mut V, String&gt; {<br/>        match self.root {<br/>            None =&gt; {<br/>                return Err("No such key".to_string());<br/>            }<br/>            Some(ref mut root) =&gt; {<br/>                return root.get_mut(key);<br/>            }<br/>        }<br/>    }<br/>}<br/><br/></pre></div>
<p class="mce-root">Finally, we have a main function to actually use our tree, so we can see it in action:</p>
<pre>fn main() {<br/>    let mut tree: Tree&lt;&amp;'static str, f32&gt; = Tree::new();<br/><br/>    tree.set("first key", 12.65);<br/>    tree.set("second key", 99.999);<br/>    tree.set("third key", -128.5);<br/>    tree.set("fourth key", 67.21);<br/><br/>    println!("tree.get_ref(\"third key\") is {}", match <br/>     tree.get_ref("third key") {<br/>        Err(_) =&gt; {println!("Invalid!"); &amp;0.0},<br/>        Ok(x) =&gt; x,<br/>    });<br/>}<br/><br/></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have done the following:</p>
<ul>
<li>Looked at generic type parameters for data types and for functions</li>
<li>Learned how to limit generic type parameters so that we can be sure the concrete types chosen implement the proper traits</li>
<li>Seen various compiler errors relating to generic types, and what they mean</li>
<li>Learned how to use trait bounds and the <kbd>Fn</kbd>, <kbd>FnMut</kbd>, and <kbd>FnOnce</kbd> traits to create higher-order functions</li>
<li>Learned about the differences and similarities between using generic types and using trait objects</li>
<li>Taken our knowledge from this chapter and previous chapters and built a binary tree data structure</li>
</ul>
<p>In the next chapter, we're going to conclude our Rust journey by looking at many more traits, learning what they mean and how to implement them.</p>


            </article>

            
        </section>
    </div>



  </body></html>