["```rs\n@first\n@second\n> first\n> second\n@sum\nsum := first + second\n< sum\n< first * second\n```", "```rs\ny := m * x + q\na := a + b - c / d\n```", "```rs\na := 2.1 + 4 * 5\n```", "```rs\na := (2.1 + 4) * 5\n```", "```rs\n@first@second>first>second@sum sum:=first+second<sum<first*second\n```", "```rs\n<program> ::= \"\" | <program> <statement>\n<statement> ::= \"@\" <identifier> | \">\" <identifier> | \"<\" <expr> | <identifier> \":=\" <expr>\n<expr> ::= <term> | <expr> \"+\" <term> | <expr> \"-\" <term>\n<term> ::= <factor> | <term> \"*\" <factor> | <term> \"/\" <factor>\n<factor> ::= <identifier> | <literal> | \"(\" <expr> \")\"\n<identifier> := <letter> | <identifier> <letter>\n```", "```rs\nextern crate nom;\nuse nom::{branch::alt, character::complete::char, IResult};\n\nfn parse_abc(input: &str) -> IResult<&str, char> {\n    alt((char('a'), char('b'), char('c')))(input)\n}\n\nfn main() {\n    println!(\"a: {:?}\", parse_abc(\"a\"));\n    println!(\"x: {:?}\", parse_abc(\"x\"));\n    println!(\"bjk: {:?}\", parse_abc(\"bjk\"));\n}\n```", "```rs\na: Ok((\"\", 'a'))\nx: Err(Error((\"x\", Char)))\nbjk: Ok((\"jk\", 'b'))\n```", "```rs\nextern crate nom;\nuse nom::{character::complete::char, sequence::tuple, IResult};\n\nfn parse_abc_sequence(input: &str)\n    -> IResult<&str, (char, char, char)> {\n    tuple((char('a'), char('b'), char('c')))(input)\n}\n\nfn main() {\n    println!(\"abc: {:?}\", parse_abc_sequence(\"abc\"));\n    println!(\"bca: {:?}\", parse_abc_sequence(\"bca\"));\n    println!(\"abcjk: {:?}\", parse_abc_sequence(\"abcjk\"));\n}\n```", "```rs\nabc: Ok((\"\", ('a', 'b', 'c')))\nbca: Err(Error((\"bca\", Char)))\nabcjk: Ok((\"jk\", ('a', 'b', 'c')))\n```", "```rs\nextern crate nom;\nuse nom::{bytes::complete::tag, IResult};\n\nfn parse_abc_string(input: &str) -> IResult<&str, &str> {\n    tag(\"abc\")(input)\n}\n\nfn main() {\n    println!(\"abc: {:?}\", parse_abc_string(\"abc\"));\n    println!(\"bca: {:?}\", parse_abc_string(\"bca\"));\n    println!(\"abcjk: {:?}\", parse_abc_string(\"abcjk\"));\n}\n```", "```rs\nabc: Ok((\"\", \"abc\"))\nbca: Err(Error((\"bca\", Tag)))\nabcjk: Ok((\"jk\", \"abc\"))\n```", "```rs\nextern crate nom;\nuse nom::{branch::alt, character::complete::char, combinator::map, IResult};\n\nfn parse_abc_as_numbers(input: &str)\n    -> IResult<&str, u8> {\n    alt((\n        map(char('a'), |_| 5),\n        map(char('b'), |_| 16),\n        map(char('c'), |_| 8),\n    ))(input)\n}\n\nfn main() {\n    println!(\"a: {:?}\", parse_abc_as_numbers(\"a\"));\n    println!(\"x: {:?}\", parse_abc_as_numbers(\"x\"));\n    println!(\"bjk: {:?}\", parse_abc_as_numbers(\"bjk\"));\n}\n```", "```rs\na: Ok((\"\", 5))\nx: Err(Error((\"x\", Char)))\nbjk: Ok((\"jk\", 16))\n```", "```rs\nfn parse_abc_as_numbers(input: &str) -> IResult<&str, u8> {\n    fn transform_letter(ch: char) -> u8 {\n        match ch {\n            'a' => 5,\n            'b' => 16,\n            'c' => 8,\n            _ => 0,\n        }\n    }\n    alt((\n        map(char('a'), transform_letter),\n        map(char('b'), transform_letter),\n        map(char('c'), transform_letter),\n    ))(input)\n}\n```", "```rs\nextern crate nom;\nuse nom::{character::complete::char, sequence::tuple, IResult};\n\nfn parse_abc_to_ac(input: &str) -> IResult<&str, (char, char)> {\n    tuple((char('a'), char('b'), char('c')))(input)\n        .map(|(rest, result)| (rest, (result.0, result.2)))\n}\n\nfn main() {\n    println!(\"abc: {:?}\", parse_abc_to_ac(\"abc\"));\n}\n```", "```rs\nabc: Ok((\"\", ('a', 'c')))\n```", "```rs\n.map(|(rest, result): (&str, (char, char, char))|\n    -> (&str, (char, char)) {\n    (rest, (result.0, result.2))\n}\n```", "```rs\nextern crate nom;\nuse nom::{bytes::complete::take, character::complete::char, sequence::tuple, IResult};\n\nfn parse_variable_text(input: &str)\n    -> IResult<&str, (char, &str)> {\n    tuple((char('n'), take(2usize)))(input)\n}\n\nfn main() {\n    println!(\"nghj: {:?}\", parse_variable_text(\"nghj\"));\n    println!(\"xghj: {:?}\", parse_variable_text(\"xghj\"));\n    println!(\"ng: {:?}\", parse_variable_text(\"ng\"));\n}\n```", "```rs\nnghj: Ok((\"j\", ('n', \"gh\")))\nxghj: Err(Error((\"xghj\", Char)))\nng: Err(Error((\"g\", Eof)))\n```", "```rs\nextern crate nom;\nuse nom::{bytes::complete::take, multi::many1, IResult};\n\nfn repeated_text(input: &str) -> IResult<&str, Vec<&str>> {\n    many1(take(3usize))(input)\n}\n\nfn main() {\n    println!(\": {:?}\", repeated_text(\"\"));\n    println!(\"ab: {:?}\", repeated_text(\"abc\"));\n    println!(\"abcabcabc: {:?}\", repeated_text(\"abcabcabc\"));\n}\n```", "```rs\n: Err(Error((\"\", Eof)))\nabc: Ok((\"\", [\"abc\"]))\nabcabcabcx: Ok((\"x\", [\"abc\", \"abc\", \"abc\"]))\n```", "```rs\n@a\n@b\n>a\n>b\n<a+b\n```", "```rs\ncargo run data/sum.calc\n```", "```rs\nParsed program: [\n    Declaration(\n        \"a\",\n    ),\n    Declaration(\n        \"b\",\n    ),\n    InputOperation(\n        \"a\",\n    ),\n    InputOperation(\n        \"b\",\n    ),\n    OutputOperation(\n        (\n            (\n                Identifier(\n                    \"a\",\n                ),\n                [],\n            ),\n            [\n                (\n                    Add,\n                    (\n                        Identifier(\n                            \"b\",\n                        ),\n                        [],\n                    ),\n                ),\n            ],\n        ),\n    ),\n]\n```", "```rs\nprintln!(\"Parsed program: {:#?}\", parsed_program);\n```", "```rs\ntype ParsedProgram<'a> = Vec<ParsedStatement<'a>>;\n```", "```rs\nenum ParsedStatement<'a> {\n    Declaration(&'a str),\n    InputOperation(&'a str),\n    OutputOperation(ParsedExpr<'a>),\n    Assignment(&'a str, ParsedExpr<'a>),\n}\n```", "```rs\ntype ParsedExpr<'a> = (ParsedTerm<'a>, Vec<(ExprOperator, ParsedTerm<'a>)>);\n```", "```rs\ntype ParsedTerm<'a> = (ParsedFactor<'a>, Vec<(TermOperator, ParsedFactor<'a>)>);\n```", "```rs\nenum ParsedFactor<'a> {\n    Literal(f64),\n    Identifier(&'a str),\n    SubExpression(Box<ParsedExpr<'a>>),\n}\n```", "```rs\npub fn parse_program(input: &str) -> IResult<&str, ParsedProgram> {\n    many0(preceded(\n        skip_spaces,\n        alt((\n            parse_declaration,\n            parse_input_statement,\n            parse_output_statement,\n            parse_assignment,\n        )),\n    ))(input)\n}\n```", "```rs\nfn parse_declaration(input: &str) -> IResult<&str, ParsedStatement> {\n    tuple((char('@'), skip_spaces, parse_identifier))(input)\n        .map(|(input, output)| (input, ParsedStatement::Declaration(output.2)))\n}\n```", "```rs\nfn parse_input_statement(input: &str) -> IResult<&str, ParsedStatement> {\n    tuple((char('>'), skip_spaces, parse_identifier))(input)\n        .map(|(input, output)| (input, ParsedStatement::InputOperation(output.2)))\n}\n```", "```rs\nfn parse_output_statement(input: &str) -> IResult<&str, ParsedStatement> {\n    tuple((char('<'), skip_spaces, parse_expr))(input)\n        .map(|(input, output)| (input, ParsedStatement::OutputOperation(output.2)))\n}\n```", "```rs\nfn parse_assignment(input: &str) -> IResult<&str, ParsedStatement> {\n    tuple((\n        parse_identifier,\n        skip_spaces,\n        tag(\":=\"),\n        skip_spaces,\n        parse_expr,\n    ))(input)\n    .map(|(input, output)| (input, ParsedStatement::Assignment(output.0, output.4)))\n}\n```", "```rs\nfn parse_expr(input: &str) -> IResult<&str, ParsedExpr> {\n    tuple((\n        parse_term,\n        many0(tuple((\n            preceded(\n                skip_spaces,\n                alt((\n                    map(char('+'), |_| ExprOperator::Add),\n                    map(char('-'), |_| ExprOperator::Subtract),\n                )),\n            ),\n            parse_term,\n        ))),\n    ))(input)\n}\n```", "```rs\nfn parse_term(input: &str) -> IResult<&str, ParsedTerm> {\n    tuple((\n        parse_factor,\n        many0(tuple((\n            preceded(\n                skip_spaces,\n                alt((\n                    map(char('*'), |_| TermOperator::Multiply),\n                    map(char('/'), |_| TermOperator::Divide),\n                )),\n            ),\n            parse_factor,\n        ))),\n    ))(input)\n}\n```", "```rs\nfn parse_factor(input: &str) -> IResult<&str, ParsedFactor> {\n    preceded(\n        skip_spaces,\n        alt((\n            map(parse_identifier, ParsedFactor::Identifier),\n            map(double, ParsedFactor::Literal),\n            map(parse_subexpr, |expr|\n                ParsedFactor::SubExpression(Box::new(expr))\n            ),\n        )),\n    )(input)\n}\n```", "```rs\nfn parse_subexpr(input: &str) -> IResult<&str, ParsedExpr> {\n    delimited(\n        preceded(skip_spaces, char('(')),\n        parse_expr,\n        preceded(skip_spaces, char(')')),\n    )(input)\n```", "```rs\nfn parse_identifier(input: &str) -> IResult<&str, &str> {\n    alpha1(input)\n}\n```", "```rs\nfn skip_spaces(input: &str) -> IResult<&str, &str> {\n    let chars = \" \\t\\r\\n\";\n    take_while(move |ch| chars.contains(ch))(input)\n}\n```", "```rs\nSymbol table: SymbolTable {\n entries: [\n (\n \"a\",\n 0.0,\n ),\n (\n \"b\",\n 0.0,\n ),\n ],\n}\nAnalyzed program: [\n Declaration(\n 0,\n ),\n Declaration(\n 1,\n ),\n InputOperation(\n 0,\n ),\n InputOperation(\n 1,\n ),\n OutputOperation(\n (\n (\n Identifier(\n 0,\n ),\n [],\n ),\n [\n (\n Add,\n (\n Identifier(\n 1,\n ),\n [],\n ),\n ),\n ],\n ),\n ),\n]\n```", "```rs\n    let analyzed_program;\n    let mut variables = symbol_table::SymbolTable::new();\n    match analyzer::analyze_program(&mut variables, &parsed_program) {\n        Ok(analyzed_tree) => {\n            analyzed_program = analyzed_tree;\n        }\n        Err(err) => {\n            eprintln!(\"Invalid code in '{}': {}\", source_path, err);\n            return;\n        }\n    }\n\n    println!(\"Symbol table: {:#?}\", variables);\n    println!(\"Analyzed program: {:#?}\", analyzed_program);\n```", "```rs\nstruct SymbolTable {\n    entries: Vec<(String, f64)>,\n}\n```", "```rs\nfn new() -> SymbolTable\nfn insert_symbol(&mut self, identifier: &str) -> Result<usize, String>\nfn find_symbol(&self, identifier: &str) -> Result<usize, String>\n```", "```rs\ntype AnalyzedProgram = Vec<AnalyzedStatement>;\n```", "```rs\nenum AnalyzedStatement {\n    Declaration(usize),\n    InputOperation(usize),\n    OutputOperation(AnalyzedExpr),\n    Assignment(usize, AnalyzedExpr),\n}\n\n```", "```rs\ntype AnalyzedExpr = (AnalyzedTerm, Vec<(ExprOperator, AnalyzedTerm)>);\n```", "```rs\ntype AnalyzedTerm = (AnalyzedFactor, Vec<(TermOperator, AnalyzedFactor)>);\n```", "```rs\npub enum AnalyzedFactor {\nLiteral(f64),\nIdentifier(usize),\nSubExpression(Box<AnalyzedExpr>),\n}\n```", "```rs\nfn analyze_program(variables: &mut SymbolTable, parsed_program: &ParsedProgram)\n    -> Result<AnalyzedProgram, String> {\n    let mut analyzed_program = AnalyzedProgram::new();\n    for statement in parsed_program {\n        analyzed_program.push(analyze_statement(variables, statement)?);\n    }\n    Ok(analyzed_program)\n}\n```", "```rs\nfn analyze_statement(\n    variables: &mut SymbolTable,\n    parsed_statement: &ParsedStatement,\n) -> Result<AnalyzedStatement, String> {\n    match parsed_statement {\n        ParsedStatement::Assignment(identifier, expr) => {\n            let handle = variables.find_symbol(identifier)?;\n            let analyzed_expr = analyze_expr(variables, expr)?;\n            Ok(AnalyzedStatement::Assignment(handle, analyzed_expr))\n        }\n        ParsedStatement::Declaration(identifier) => {\n            let handle = variables.insert_symbol(identifier)?;\n            Ok(AnalyzedStatement::Declaration(handle))\n        }\n        ParsedStatement::InputOperation(identifier) => {\n            let handle = variables.find_symbol(identifier)?;\n            Ok(AnalyzedStatement::InputOperation(handle))\n        }\n        ParsedStatement::OutputOperation(expr) => {\n            let analyzed_expr = analyze_expr(variables, expr)?;\n            Ok(AnalyzedStatement::OutputOperation(analyzed_expr))\n        }\n    }\n}\n```", "```rs\nfn analyze_expr(\n    variables: &mut SymbolTable,\n    parsed_expr: &ParsedExpr,\n) -> Result<AnalyzedExpr, String> {\n    let first_term = analyze_term(variables, &parsed_expr.0)?;\n    let mut other_terms = Vec::<(ExprOperator, AnalyzedTerm)>::new();\n    for term in &parsed_expr.1 {\n        other_terms.push((term.0, analyze_term(variables, &term.1)?));\n    }\n    Ok((first_term, other_terms))\n}\n```", "```rs\nfn analyze_term(\n    variables: &mut SymbolTable,\n    parsed_term: &ParsedTerm,\n) -> Result<AnalyzedTerm, String> {\n    let first_factor = analyze_factor(variables, &parsed_term.0)?;\n    let mut other_factors = Vec::<(TermOperator, AnalyzedFactor)>::new();\n    for factor in &parsed_term.1 {\n        other_factors.push((factor.0, analyze_factor(variables, \n         &factor.1)?));\n    }\n    Ok((first_factor, other_factors))\n}\n```", "```rs\nfn analyze_factor(\n    variables: &mut SymbolTable,\n    parsed_factor: &ParsedFactor,\n) -> Result<AnalyzedFactor, String> {\n    match parsed_factor {\n        ParsedFactor::Literal(value) => \n         Ok(AnalyzedFactor::Literal(*value)),\n        ParsedFactor::Identifier(name) => {\n            Ok(AnalyzedFactor::Identifier(variables.find_symbol(name)?))\n        }\n        ParsedFactor::SubExpression(expr) => \n         Ok(AnalyzedFactor::SubExpression(\n            Box::<AnalyzedExpr>::new(analyze_expr(variables, expr)?),\n        )),\n    }\n}\n```", "```rs\n* Calc interactive interpreter *\n> \n```", "```rs\n@a >a @b b := a + 2 <b\n```", "```rs\n* Calc interactive interpreter *\n> @a >a @b b := a + 2 <b\n? 5\n7\n> \n```", "```rs\n> v\nVariables:\n a: 5\n b: 7\n> \n```", "```rs\nfn run_interpreter() {\n    eprintln!(\"* Calc interactive interpreter *\");\n    let mut variables = symbol_table::SymbolTable::new();\n    loop {\n        let command = input_command();\n        if command.len() == 0 {\n            break;\n        }\n *<<process interpreter commands>>*\n *<<parse, analyze, and execute the commands>>*\n    }\n}\n```", "```rs\nmatch command.trim() {\n    \"q\" => break,\n    \"c\" => {\n        variables = symbol_table::SymbolTable::new();\n        eprintln!(\"Cleared variables.\");\n    }\n    \"v\" => {\n        eprintln!(\"Variables:\");\n        for v in variables.iter() {\n            eprintln!(\" {}: {}\", v.0, v.1);\n        }\n    }\n```", "```rs\n    trimmed_command => match parser::parse_program(&trimmed_command) {\n        Ok((rest, parsed_program)) => {\n            if rest.len() > 0 {\n                eprintln!(\"Unparsed input: `{}`.\", rest)\n            } else {\n                match analyzer::analyze_program(&mut variables, \n                 &parsed_program) {\n                    Ok(analyzed_program) => {\n                        executor::execute_program(&mut variables, \n                          &analyzed_program)\n                    }\n                    Err(err) => eprintln!(\"Error: {}\", err),\n                }\n            }\n        }\n        Err(err) => eprintln!(\"Error: {:?}\", err),\n    },\n```", "```rs\npub fn get_value(&self, handle: usize) -> f64\npub fn set_value(&mut self, handle: usize, value: f64)\npub fn iter(&self) -> std::slice::Iter<(String, f64)>\n```", "```rs\npub fn execute_program(variables: &mut SymbolTable, program: &AnalyzedProgram) {\n    for statement in program {\n        execute_statement(variables, statement);\n    }\n}\n```", "```rs\nfn execute_statement(variables: &mut SymbolTable, statement: &AnalyzedStatement) {\n    match statement {\n        AnalyzedStatement::Assignment(handle, expr) => {\n            variables.set_value(*handle, evaluate_expr(variables, expr));\n        }\n        AnalyzedStatement::Declaration(handle) => {}\n        AnalyzedStatement::InputOperation(handle) => {\n            let mut text = String::new();\n            eprint!(\"? \");\n            std::io::stdin()\n                .read_line(&mut text)\n                .expect(\"Cannot read line.\");\n            let value = text.trim().parse::<f64>().unwrap_or(0.);\n            variables.set_value(*handle, value);\n        }\n        AnalyzedStatement::OutputOperation(expr) => {\n            println!(\"{}\", evaluate_expr(variables, expr));\n        }\n    }\n}\n```", "```rs\nfn evaluate_expr(variables: &SymbolTable, expr: &AnalyzedExpr) -> f64 {\n    let mut result = evaluate_term(variables, &expr.0);\n    for term in &expr.1 {\n        match term.0 {\n            ExprOperator::Add => result += evaluate_term(variables, \n             &term.1),\n            ExprOperator::Subtract => result -= evaluate_term(variables, \n             &term.1),\n        }\n    }\n    result\n}\n```", "```rs\nfn evaluate_term(variables: &SymbolTable, term: &AnalyzedTerm) -> f64 {\n    let mut result = evaluate_factor(variables, &term.0);\n    for factor in &term.1 {\n        match factor.0 {\n            TermOperator::Multiply => result *= evaluate_factor(\n            variables, &factor.1),\n            TermOperator::Divide => result /= evaluate_factor(\n            variables, &factor.1),\n        }\n    }\n    result\n}\n```", "```rs\nfn evaluate_factor(variables: &SymbolTable, factor: &AnalyzedFactor) -> f64 {\n    match factor {\n        AnalyzedFactor::Literal(value) => *value,\n        AnalyzedFactor::Identifier(handle) => variables.get_value(*handle),\n        AnalyzedFactor::SubExpression(expr) => evaluate_expr(variables, expr),\n    }\n}\n```", "```rs\nCompiled data/sum.calc to data/sum.rs\n```", "```rs\nuse std::io::Write;\n\n#[allow(dead_code)]\nfn input() -> f64 {\n    let mut text = String::new();\n    eprint!(\"? \");\n    std::io::stderr().flush().unwrap();\n    std::io::stdin()\n        .read_line(&mut text)\n        .expect(\"Cannot read line.\");\n    text.trim().parse::<f64>().unwrap_or(0.)\n}\n\nfn main() {\n    let mut _a = 0.0;\n    let mut _b = 0.0;\n    _a = input();\n    _b = input();\n    println!(\"{}\", _a + _b);\n}\n```", "```rs\npub fn get_name(&self, handle: usize) -> String\n```", "```rs\nlet target_path = source_path[0..source_path.len() - CALC_SUFFIX.len()].to_string() + \".rs\";\n```", "```rs\nmatch std::fs::write(\n    &target_path,\n    compiler::translate_to_rust_program(&variables, &analyzed_program),\n) {\n    Ok(_) => eprintln!(\"Compiled {} to {}.\", source_path, target_path),\n    Err(err) => eprintln!(\"Failed to write to file {}: ({})\", target_path, err),\n}\n```", "```rs\npub fn translate_to_rust_program(\n    variables: &SymbolTable,\n    analyzed_program: &AnalyzedProgram,\n) -> String {\n    let mut rust_program = String::new();\n    rust_program += \"use std::io::Write;\\n\";\n    ...\n```", "```rs\n    ...\n    for statement in analyzed_program {\n        rust_program += \" \";\n        rust_program += &translate_to_rust_statement(&variables, \n         statement);\n        rust_program += \";\\n\";\n    }\n    rust_program += \"}\\n\";\n    rust_program\n}\n```", "```rs\nmatch analyzed_statement {\n    AnalyzedStatement::Assignment(handle, expr) => format!(\n        \"_{} = {}\",\n        variables.get_name(*handle),\n        translate_to_rust_expr(&variables, expr)\n    ),\n    AnalyzedStatement::Declaration(handle) => {\n        format!(\"let mut _{} = 0.0\", variables.get_name(*handle))\n    }\n    AnalyzedStatement::InputOperation(handle) => {\n        format!(\"_{} = input()\", variables.get_name(*handle))\n    }\n    AnalyzedStatement::OutputOperation(expr) => format!(\n        \"println!(\\\"{}\\\", {})\",\n        \"{}\",\n        translate_to_rust_expr(&variables, expr)\n    ),\n}\n```", "```rs\nfn translate_to_rust_expr(variables: &SymbolTable, analyzed_expr: &AnalyzedExpr) -> String {\n    let mut result = translate_to_rust_term(variables, &analyzed_expr.0);\n    for term in &analyzed_expr.1 {\n        match term.0 {\n            ExprOperator::Add => {\n                result += \" + \";\n                result += &translate_to_rust_term(variables, &term.1);\n            }\n            ExprOperator::Subtract => {\n                result += \" - \";\n                result += &translate_to_rust_term(variables, &term.1);\n            }\n        }\n    }\n    result\n}\n```", "```rs\nmatch analyzed_factor {\n    AnalyzedFactor::Literal(value) => value.to_string() + \"f64\",\n    AnalyzedFactor::Identifier(handle) => \"_\".to_string()\n    + &variables.get_name(*handle),\n    AnalyzedFactor::SubExpression(expr) => {\n        \"(\".to_string() + &translate_to_rust_expr(variables, expr) + \")\"\n    }\n}\n```"]