["```rs\n// rusqlite_demo/src/main.rs\n\nuse std::io;\nuse std::io::BufRead;\n\nuse rusqlite::Error;\nuse rusqlite::{Connection, NO_PARAMS};\n\nconst CREATE_TABLE: &str = \"CREATE TABLE books \n                            (id INTEGER PRIMARY KEY,\n                            title TEXT NOT NULL,\n                            author TEXT NOT NULL,\n                            year INTEGER NOT NULL)\";\n\nconst DROP_TABLE: &str = \"DROP TABLE IF EXISTS books\";\n\n#[derive(Debug)]\nstruct Book {\n    id: u32,\n    title: String,\n    author: String,\n    year: u16\n}\n```", "```rs\n// rusqlite_demo/src/main.rs\n\nfn main() {\n    let conn = Connection::open(\"./books\").unwrap();\n    init_database(&conn);\n    insert(&conn);\n    query(&conn);\n}\n```", "```rs\nfn init_database(conn: &Connection) {\n    conn.execute(CREATE_TABLE, NO_PARAMS).unwrap();\n}\n```", "```rs\nfn insert(conn: &Connection) {\n    let stdin = io::stdin();\n    let lines = stdin.lock().lines();\n    for line in lines {\n        let elems = line.unwrap();\n        let elems: Vec<&str> = elems.split(\",\").collect();\n        if elems.len() == 4 {\n            let _ = conn.execute(\n                \"INSERT INTO books (id, title, author, year) VALUES (?1, ?2, ?3, ?4)\",\n                &[&elems[0], &elems[1], &elems[2], &elems[3]],\n            );\n        }\n    }\n}\n```", "```rs\nfn query(conn: &Connection) {\n    let mut stmt = conn\n        .prepare(\"SELECT id, title, author, year FROM books WHERE year >= ?1\")\n        .unwrap();\n    let movie_iter = stmt\n        .query_map(&[&2013], |row| Book {\n            id: row.get(0),\n            title: row.get(1),\n            author: row.get(2),\n            year: row.get(3),\n        })\n        .unwrap();\n\n    for movie in movie_iter.filter_map(extract_ok) {\n        println!(\"Found book {:?}\", movie);\n    }\n}\n```", "```rs\nfn extract_ok(p: Result<Book, Error>) -> Option<Book> {\n    if p.is_ok() {\n        Some(p.unwrap())\n    } else {\n        None\n    }\n}\n```", "```rs\n// rusqlite_demo/src/main.rs\n\nuse std::io;\nuse std::io::BufRead;\n\nuse rusqlite::Error;\nuse rusqlite::{Connection, NO_PARAMS};\n\nconst CREATE_TABLE: &str = \"CREATE TABLE IF NOT EXISTS books \n                            (id INTEGER PRIMARY KEY,\n                            title TEXT NOT NULL,\n                            author TEXT NOT NULL,\n                            year INTEGER NOT NULL)\";\n\n#[derive(Debug)]\nstruct Book {\n    id: u32,\n    title: String,\n    author: String,\n    year: u16,\n}\n\nfn extract_ok(p: Result<Book, Error>) -> Option<Book> {\n    if p.is_ok() {\n        Some(p.unwrap())\n    } else {\n        None\n    }\n}\n\nfn insert(conn: &Connection) {\n    let stdin = io::stdin();\n    let lines = stdin.lock().lines();\n    for line in lines {\n        let elems = line.unwrap();\n        let elems: Vec<&str> = elems.split(\",\").collect();\n        if elems.len() > 2 {\n            let _ = conn.execute(\n                \"INSERT INTO books (id, title, author, year) VALUES (?1, ?2, ?3, ?4)\",\n                &[&elems[0], &elems[1], &elems[2], &elems[3]],\n            );\n        }\n    }\n}\n\nfn init_database(conn: &Connection) {\n    conn.execute(CREATE_TABLE, NO_PARAMS).unwrap();\n}\n\nfn query(conn: &Connection) {\n    let mut stmt = conn\n        .prepare(\"SELECT id, title, author, year FROM books WHERE year >= ?1\")\n        .unwrap();\n    let movie_iter = stmt\n        .query_map(&[&2013], |row| Book {\n            id: row.get(0),\n            title: row.get(1),\n            author: row.get(2),\n            year: row.get(3),\n        })\n        .unwrap();\n\n    for movie in movie_iter.filter_map(extract_ok) {\n        println!(\"Found book {:?}\", movie);\n    }\n}\n\nfn main() {\n    let conn = Connection::open(\"./books\").unwrap();\n    init_database(&conn);\n    insert(&conn);\n    query(&conn);\n}\n```", "```rs\ncargo run < books.csv\n```", "```rs\n$ sudo -u postgres psql\n```", "```rs\npostgres=# SELECT version();\n```", "```rs\nPostgreSQL 9.5.14 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609, 64-bit\n```", "```rs\n# postgres_demo/Cargo.toml\n\n[dependencies]\npostgres = \"0.15.2\"\nserde = { version = \"1.0.82\"}\nserde_derive = \"1.0.82\"\nserde_json = \"1.0.33\"\n```", "```rs\n// postgres_demo/src/main.rs\n\nuse postgres::{Connection, TlsMode};\n\nconst DROP_TABLE: &str = \"DROP TABLE IF EXISTS books\";\nconst CONNECTION: &str = \"postgres://postgres:postgres@localhost:5432\";\nconst CREATE_TABLE: &str = \"CREATE TABLE IF NOT EXISTS books \n                            (id SERIAL PRIMARY KEY,\n                            title VARCHAR NOT NULL,\n                            author VARCHAR NOT NULL,\n                            year SERIAL)\";\n\n#[derive(Debug)]\nstruct Book {\n    id: i32,\n    title: String,\n    author: String,\n    year: i32\n}\n\nfn reset_db(conn: &Connection) {\n    let _ = conn.execute(DROP_TABLE, &[]).unwrap();\n    let _ = conn.execute(CREATE_TABLE, &[]).unwrap();\n}\n```", "```rs\n// postgres_demo/src/main.rs\n\nfn main() {\n    let conn = Connection::connect(CONNECTION, TlsMode::None).unwrap();\n    reset_db(&conn);\n\n    let book = Book {\n        id: 3,\n        title: \"A programmers introduction to mathematics\".to_string(),\n        author: \"Dr. Jeremy Kun\".to_string(),\n        year: 2018\n    };\n\n    conn.execute(\"INSERT INTO books (id, title, author, year) VALUES ($1, $2, $3, $4)\",\n                 &[&book.id, &book.title, &book.author, &book.year]).unwrap();\n\n    for row in &conn.query(\"SELECT id, title, author, year FROM books\", &[]).unwrap() {\n        let book = Book {\n            id: row.get(0),\n            title: row.get(1),\n            author: row.get(2),\n            year: row.get(3)\n        };\n        println!(\"{:?}\", book);\n    }\n}\n```", "```rs\npub trait ManageConnection: Send + Sync + 'static {\n    type Connection: Send + 'static;\n    type Error: Error + 'static;\n    fn connect(&self) -> Result<Self::Connection, Self::Error>;\n    fn is_valid(&self, conn: &mut Self::Connection) -> Result<(), Self::Error>;\n    fn has_broken(&self, conn: &mut Self::Connection) -> bool;\n}\n```", "```rs\n// r2d2_demo/src/main.rs\n\nuse std::thread;\nuse r2d2_postgres::{TlsMode, PostgresConnectionManager};\nuse std::time::Duration;\n\nconst DROP_TABLE: &str = \"DROP TABLE IF EXISTS books\";\n\nconst CREATE_TABLE: &str = \"CREATE TABLE IF NOT EXISTS books \n                            (id SERIAL PRIMARY KEY,\n                            title VARCHAR NOT NULL,\n                            author VARCHAR NOT NULL,\n                            year SERIAL)\";\n\n#[derive(Debug)]\nstruct Book {\n    id: i32,\n    title: String,\n    author: String,\n    year: i32\n}\n\nfn main() {\n    let manager = PostgresConnectionManager::new(\"postgres://postgres:postgres@localhost:5432\",\n                                                 TlsMode::None).unwrap();\n    let pool = r2d2::Pool::new(manager).unwrap();\n    let conn = pool.get().unwrap();\n\n    let _ = conn.execute(DROP_TABLE, &[]).unwrap();\n    let _ = conn.execute(CREATE_TABLE, &[]).unwrap();\n\n    thread::spawn(move || {\n        let book = Book {\n            id: 3,\n            title: \"A programmers introduction to mathematics\".to_string(),\n            author: \"Dr. Jeremy Kun\".to_string(),\n            year: 2018\n        };\n        conn.execute(\"INSERT INTO books (id, title, author, year) VALUES ($1, $2, $3, $4)\",\n                    &[&book.id, &book.title, &book.author, &book.year]).unwrap();                                         \n    });\n\n    thread::sleep(Duration::from_millis(100));\n    for _ in 0..8 {\n        let conn = pool.get().unwrap();\n        thread::spawn(move || {\n            for row in &conn.query(\"SELECT id, title, author, year FROM books\", &[]).unwrap() {\n                let book = Book {\n                    id: row.get(0),\n                    title: row.get(1),\n                    author: row.get(2),\n                    year: row.get(3)\n                };\n                println!(\"{:?}\", book);\n            }\n        });\n    }\n}\n\n```", "```rs\ncargo install diesel_cli --no-default-features --features postgres\n```", "```rs\nDATABASE_URL=postgres://postgres:postgres@localhost/linksnap\n```", "```rs\n# linksnap_v2/Cargo.toml\n\n[dependencies]\nactix = \"0.7\"\nactix-web = \"0.7\"\n\nfutures = \"0.1\"\nenv_logger = \"0.5\"\nbytes = \"0.4\"\nserde = \"1.0.80\"\nserde_json = \"1.0.33\"\nserde_derive = \"1.0.80\"\nurl = \"1.7.2\"\nlazy_static = \"1.2.0\"\nlog = \"0.4.6\"\nchrono = { version=\"0.4\" }\ndiesel = { version = \"1.3.3\", features = [\"extras\", \"postgres\", \"r2d2\"] }\ndotenv = \"0.13.0\"\n```", "```rs\nCreating migrations directory at: /home/creativcoder/book/Mastering-RUST-Second-Edition/Chapter14/linksnap_v2/migrations\n```", "```rs\n# linksnap_v2/diesel.toml\n\n# For documentation on how to configure this file,\n# see diesel.rs/guides/configuring-diesel-cli\n\n[print_schema]\nfile = \"src/schema.rs\"\n```", "```rs\ndiesel migration generate linksnap\n```", "```rs\nCreating migrations/2019-01-30-045330_linksnap/up.sql\nCreating migrations/2019-01-30-045330_linksnap/down.sql\n```", "```rs\n-- linksnap_v2/migrations/2019-01-30-045330_linksnap_db/up.sql\n\nCREATE TABLE linksnap (\n  id SERIAL PRIMARY KEY,\n  title VARCHAR NOT NULL,\n  url TEXT NOT NULL,\n  added TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP\n)\n```", "```rs\n-- linksnap_v2/migrations/2019-01-30-045330_linksnap_db/down.sqlDROP TABLE linksnap\n```", "```rs\n$ diesel migration run\n```", "```rs\n// linksnap_v2/src/schema.rs\n\ntable! {\n    linksnap (id) {\n        id -> Int4,\n        title -> Varchar,\n        url -> Text,\n        added -> Timestamp,\n    }\n}\n```", "```rs\n// linksnap_v2/src/models.rs\n\nuse chrono::prelude::*;\nuse diesel::prelude::Queryable;\nuse chrono::NaiveDateTime;\nuse diesel;\nuse diesel::pg::PgConnection;\nuse diesel::prelude::*;\nuse crate::state::AddLink;\nuse crate::schema::linksnap;\nuse crate::schema::linksnap::dsl::{linksnap as get_links};\nuse serde_derive::{Serialize, Deserialize};\n\npub type LinkId = i32;\n\n#[derive(Queryable, Debug)]\npub struct Link {\n    pub id: i32,\n    pub title: String,\n    pub url: String,\n    pub added: NaiveDateTime,\n}\n\nimpl Link {\n    pub fn add_link(new_link: AddLink, conn: &PgConnection) -> QueryResult<usize> {\n        diesel::insert_into(linksnap::table)\n            .values(&new_link)\n            .execute(conn)\n    }\n\n    pub fn get_links(conn: &PgConnection) -> QueryResult<Vec<Link>> {\n        get_links.order(linksnap::id.desc()).load::<Link>(conn)\n    }\n\n    pub fn rm_link(id: LinkId, conn: &PgConnection) -> QueryResult<usize> {\n        diesel::delete(get_links.find(id)).execute(conn)\n    }\n}\n```", "```rs\n// linksnap_v2/src/state.rs\n\nuse diesel::pg::PgConnection;\nuse actix::Addr;\nuse actix::SyncArbiter;\nuse std::env;\nuse diesel::r2d2::{ConnectionManager, Pool, PoolError, PooledConnection};\nuse actix::{Handler, Message};\nuse crate::models::Link;\nuse serde_derive::{Serialize, Deserialize};\nuse crate::schema::linksnap;\nuse std::ops::Deref;\n\nconst DB_THREADS: usize = 3;\n\nuse actix_web::{error, Error};\nuse actix::Actor;\nuse actix::SyncContext;\n\n// Using this we create the connection pool.\npub type PgPool = Pool<ConnectionManager<PgConnection>>;\ntype PgPooledConnection = PooledConnection<ConnectionManager<PgConnection>>;\npub struct Db(pub PgPool);\n\n// We define a get conn a convenient method to get\nimpl Db {\n    pub fn get_conn(&self) -> Result<PgPooledConnection, Error> {\n        self.0.get().map_err(|e| error::ErrorInternalServerError(e))\n    }\n}\n```", "```rs\n\n// We then implement the Actor trait on the actor.\nimpl Actor for Db {\n    type Context = SyncContext<Self>;\n}\n\npub fn init_pool(database_url: &str) -> Result<PgPool, PoolError> {\n    let manager = ConnectionManager::<PgConnection>::new(database_url);\n    Pool::builder().build(manager)\n}\n\n// This type is simply wraps a Addr what we \n#[derive(Clone)]\npub struct State {\n    pub inner: Addr<Db>\n}\n\nimpl State {\n    // The init method creates \n    pub fn init() -> State {\n        let database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n        let pool = init_pool(&database_url).expect(\"Failed to create pool\");\n        let addr = SyncArbiter::start(DB_THREADS, move || Db(pool.clone()));\n        let state = State {\n            inner: addr.clone()\n        };\n        state\n    }\n    pub fn get(&self) -> &Addr<Db> {\n        &self.inner\n    }\n}\n```", "```rs\ncurl --header \"Content-Type: application/json\" \\\n --request POST \\\n --data '{\"title\":\"rust webpage\",\"url\":\"https://rust-lang.org\"}' \\\n 127.0.0.1:8080/add\n```"]