<html><head></head><body><div><h1 class="header-title">Expressing Yourself with Macros</h1>
                
            
            
                
<p class="mce-root">In the previous century, many languages featured a preprocessor (most prominently, C/C++) that often did unassuming text replacement. While this is handy for expressing constants (<kbd>#define MYCONST 1</kbd>), it also leads to potentially unexpected outcomes once the replacement gets more complex (for example, <kbd>#define MYCONST 1 + 1</kbd> and when applied as <kbd>5 * MYCONST</kbd> yields <em>5 * 1 + 1 = 6</em> instead of the expected 10 (from <em>5 * (1 + 1))</em> ) .</p>
<p class="mce-root">However, a preprocessor allows program programming (metaprogramming) and therefore makes things easier for the developer. Instead of copying and pasting expressions and excessive boilerplate code, a quick macro definition leads to a smaller code base and reusable calls and—as a consequence—fewer errors. In order to make the best use of Rust's type system, macros cannot simply search and replace text; they have to work on a higher level: the abstract syntax tree. Not only does this require a different calling syntax (such as an exclamation mark at the end of a call; for example, <kbd>println!</kbd>) for the compiler to know what to do, the parameter <em>types</em> are different as well.</p>
<p class="mce-root">At this level, we are talking about expressions, statements, identifiers, types, and many more that can be passed into a macro. Ultimately, however, the macro preprocessor still inserts the macro's body into the calling scope before compilation, so the compiler catches type mismatches or borrowing violations. If you want to read more on macros, check out the blog post at <a href="https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/">https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/</a>, <em>The Little Book of Rust Macros</em> (<a href="https://danielkeep.github.io/tlborm/book/index.html">https://danielkeep.github.io/tlborm/book/index.html</a>), and the Rust book (<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">https://doc.rust-lang.org/book/ch19-06-macros.html</a>). Macros are best tried out to get a feel for them—we'll cover the following in this chapter:</p>
<ul>
<li>Building custom macros in Rust</li>
<li>Implementing matching with macros</li>
<li>Using predefined Rust macros</li>
<li>Code generation using macros</li>
<li>Macro overloading</li>
<li>Using <kbd>repeat</kbd> for parameter ranges</li>
<li>Don't Repeat Yourself (DRY)</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Building custom macros in Rust</h1>
                
            
            
                
<p>Previously, we have mostly used predefined macros—it's now time to look at creating custom macros. There are several types of macros in Rust—derive-based, function-like, and attributes, all of which have their own respective use cases. In this recipe, we'll experiment with the function-like variety to get started. </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>You are only a few steps from creating macros:</p>
<ol>
<li>Run <kbd>cargo new custom-macros</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code.</li>
<li>Open <kbd>src/main.rs</kbd> in the editor. Let's create a new macro called <kbd>one_plus_one</kbd> at the top of the file:</li>
</ol>
<pre style="padding-left: 60px">// A simple macro without arguments<br/>macro_rules! one_plus_one {<br/>    () =&gt; { 1 + 1 };<br/>}</pre>
<ol start="3">
<li>Let's call this simple macro inside the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("1 + 1 = {}", one_plus_one!());<br/>}</pre>
<ol start="4">
<li>This was a very simple macro, but macros can do so much more! How about one that lets us decide on the operation. Add a very simple macro to the top of the file:</li>
</ol>
<pre style="padding-left: 60px">// A simple pattern matching argument<br/>macro_rules! one_and_one {<br/> (plus) =&gt; { 1 + 1 };<br/> (minus) =&gt; { 1 - 1 };<br/> (mult) =&gt; { 1 * 1 };<br/>}</pre>
<ol start="5">
<li>Since the words in the <strong>matcher </strong>part of the macro are required, we have to call the macro exactly like that. Add the following inside the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">    println!("1 + 1 = {}", one_and_one!(plus));<br/>    println!("1 - 1 = {}", one_and_one!(minus));<br/>    println!("1 * 1 = {}", one_and_one!(mult));</pre>
<ol start="6">
<li>As the last part, we should think of keeping things in order; creating modules, structs, files, and so on. To group similar behavior is a common way to organize stuff, and if we want to use it outside of our module we need to make it publicly available. Just like the <kbd>pub</kbd> keyword, macros have to be exported explicitly—but with an attribute. Add this module to <kbd>src/main.rs</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">mod macros {<br/>    #[macro_export]<br/>    macro_rules! two_plus_two {<br/>        () =&gt; { 2 + 2 };<br/>    }<br/>}</pre>
<ol start="7">
<li>Thanks to the export, we can now also call this function in <kbd>main()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("1 + 1 = {}", one_plus_one!());<br/>    println!("1 + 1 = {}", one_and_one!(plus));<br/>    println!("1 - 1 = {}", one_and_one!(minus));<br/>    println!("1 * 1 = {}", one_and_one!(mult));<br/>    println!("2 + 2 = {}", two_plus_two!());<br/>}</pre>
<ol start="8">
<li>By issuing <kbd>cargo run</kbd> from Terminal inside the project's directory, we will then find out whether it worked:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/> Compiling custom-macros v0.1.0 (Rust-Cookbook/Chapter06/custom-<br/>  macros)<br/> Finished dev [unoptimized + debuginfo] target(s) in 0.66s<br/> Running `target/debug/custom-macros`<br/>1 + 1 = 2<br/>1 + 1 = 2<br/>1 - 1 = 0<br/>1 * 1 = 1<br/>2 + 2 = 4</pre>
<p>In order to understand the code better, let's decipher these steps.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As appropriate, we use a macro—<kbd>macro_rules!</kbd>—to create a custom macro as we did in <em>step 3</em>. A single macro matches a pattern and consists of three parts:</p>
<ul>
<li>A name (for example, <kbd>one_plus_one</kbd>)</li>
<li>A matcher (for example, <kbd>(plus) =&gt; ...</kbd>)</li>
<li>A transcriber (for example, <kbd>... =&gt; { 1 + 1 }</kbd>) </li>
</ul>
<p>Calling a macro is always done using its name followed by an exclamation mark (<em>step 4</em>), and for specific patterns, with the required characters/words (<em>step 6</em>). Note that <kbd>plus</kbd> and others are not variables, types, or otherwise defined—which gives you the power to create your own <strong>domain-specific language</strong> (<strong>DSL</strong>)! More on that in other recipes in this chapter.</p>
<p>By calling a macro, the compiler takes note of the position in the <strong>abstract syntax tree</strong> (<strong>AST</strong>) and, instead of pure text replacement, inserts the macro's transcriber sub-tree right there. Afterward, the compiler tries to finish the compilation, leading to regular type-safety checks, borrowing rules enforcement, and so on, but with awareness for macros. This makes it easier for you, as the developer, to find errors and trace them back into the macros they originate from.</p>
<p>In <em>step 6</em>, we create a module to export a macro from—something that will improve the code structure and maintainability, especially in larger code bases. However, the export step is required since macros are private by default. Try removing the <kbd>#[macro_export]</kbd> attribute to see what happens.</p>
<p><em>Step 8</em> shows how to call every macro variation in the project as a comparison. For more information, you can also check out the blog post at <a href="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html">https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</a>, which goes into more detail about providing macro crates on <kbd>crates.io</kbd> (<a href="https://crates.io">https://crates.io</a>).</p>
<p>Now that we know how to build custom macros in Rust, we can move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Implementing matching with macros</h1>
                
            
            
                
<p>When we created custom macros, we had already seen pattern matching at play: a command was only executed if particular words were present <em>before compilation</em>. In other words, the macro system compares raw text as patterns before they become expressions or types. Consequently, creating a DSL is really easy. Defining a web request handler? Use method names in the pattern: <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>HEAD</kbd>. There is an endless variety, however, so let's see how we can define some patterns in this recipe!</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>By following these next few steps, you will be able to use macros:</p>
<ol>
<li>Run <kbd>cargo new matching --lib</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code.</li>
<li>In <kbd>src/lib.rs</kbd>, we add a macro to work with specific types as inputs. Insert the following at the top of the file:</li>
</ol>
<pre style="padding-left: 60px">macro_rules! strange_patterns {<br/>    (The pattern must match precisely) =&gt; { "Text" };<br/>    (42) =&gt; { "Numeric" };<br/>    (;&lt;=,&lt;=;) =&gt; { "Alpha" };<br/>}</pre>
<ol start="3">
<li>Clearly, this should be tested to see whether it works. Replace the <kbd>it_works()</kbd> test with a different test function:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_strange_patterns() {<br/>        assert_eq!(strange_patterns!(The pattern must match <br/>        precisely), "Text");<br/>        assert_eq!(strange_patterns!(42), "Numeric");<br/>        assert_eq!(strange_patterns!(;&lt;=,&lt;=;), "Alpha");<br/>    }</pre>
<ol start="4">
<li>The patterns can also contain actual input parameters:</li>
</ol>
<pre style="padding-left: 60px">macro_rules! compare {<br/>    ($x:literal =&gt; $y:block) =&gt; { $x == $y };<br/>}</pre>
<ol start="5">
<li>A simple test to round it off is as follows:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_compare() {<br/>        assert!(compare!(1 =&gt; { 1 }));<br/>    }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="6">
<li>Handling HTTP requests has always been an architectural challenge, with added layers and special routes for every business case. As some web frameworks (<a href="https://github.com/seanmonstar/warp">https://github.com/seanmonstar/warp</a>) show, macros can provide useful support to enable composing handlers together. Add another macro and support functions to the file—the <kbd>register_handler()</kbd> function, which mocks registering a handler function for our hypothetical web framework:</li>
</ol>
<pre style="padding-left: 120px">#[derive(Debug)]<br/>pub struct Response(usize);<br/>pub fn register_handler(method: &amp;str, path: &amp;str, handler: &amp;Fn() -&gt; Response ) {}<br/><br/>macro_rules! web {<br/>    (GET $path:literal =&gt; $b:block) =&gt; { <br/>     register_handler("GET", $path, &amp;|| $b) };<br/>    (POST $path:literal =&gt; $b:block) =&gt; { <br/>     register_handler("POST", $path, &amp;|| $b) };<br/>}</pre>
<ol start="7">
<li>In order to make sure everything works, we should also add a test for the <kbd>web!</kbd> macro. When the function is empty, a macro that doesn't match the pattern it holds leads to a compile-time error:</li>
</ol>
<pre style="padding-left: 60px">    use super::*;<br/><br/>    #[test]<br/>    fn test_web() {<br/>        web!(GET "/" =&gt; { Response(200) });<br/>        web!(POST "/" =&gt; { Response(403) });<br/>    } </pre>
<ol start="8">
<li>As the final step, let's run <kbd>cargo test</kbd> (note: add <kbd>#![allow(unused_variables, unused_macros)]</kbd><em> </em>at the top of the file to remove warnings):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling matching v0.1.0 (Rust-Cookbook/Chapter06/matching)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.31s<br/>     Running target/debug/deps/matching-124bc24094676408<br/><br/>running 3 tests<br/>test tests::test_compare ... ok<br/>test tests::test_strange_patterns ... ok<br/>test tests::test_web ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests matching<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now let's look at what the code does.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In <em>step 2</em> of this recipe, we define a macro that explicitly provides the different patterns that the engine can match to. Specifically, the alphanumeric characters are limited to <kbd>,</kbd>, <kbd>;</kbd>, and <kbd>=&gt;</kbd>. While this allows Ruby-style map initialization, it also limits the elements that a DSL can have. However, macros are still great for creating a more expressive way to deal with situations. In <em>step 6</em> and <em>step 7</em>, we show a way to create a web request handler using a more expressive way than the usual chained function calls. <em>Step 4</em> and <em>step 5</em> show the usage of the arrow (<kbd>=&gt;</kbd>) inside macros and <em>step 8</em> ties it all together by running the tests. </p>
<p>In this recipe, we created matching arms for the macro invocation to use, where the arms use a literal matching (instead of matching on the types, which will come later in this chapter) to decide on a replacement. This shows that not only can we use parameters and literals in one arm but we can also automate tasks without the constraints of regularly allowed names.</p>
<p>We've successfully learned how to implement matching in macros. Now let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Using predefined macros</h1>
                
            
            
                
<p>As we saw in the previous recipes in this chapter, macros can save a lot of writing and provide convenience functions without having to rethink the entire application architecture. Consequently, the Rust standard library provides several macros for a range of features that might otherwise be surprisingly complex to implement. One example is cross-platform prints—how would that work? Is there an equivalent way to output console text for every platform? What about color support? What is the default encoding? There are a lot of questions, which is an indicator of how many things need to be configurable—yet in a typical program, we only call <kbd>print!("hello")</kbd> and it works. Let's see what else there is. </p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these few steps to implement this recipe:</p>
<ol>
<li>Run <kbd>cargo new std-macros</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code. Then, create a <kbd>a.txt</kbd> file inside the project's <kbd>src</kbd> directory with the following content:<br/></li>
</ol>
<pre style="padding-left: 60px">Hello World!</pre>
<ol start="2">
<li>First, the default implementation of <kbd>main()</kbd> (in <kbd>src/main.rs</kbd>) already provides us with a macro call to <kbd>println!</kbd>:</li>
</ol>
<pre style="padding-left: 60px">fn main() {<br/>    println!("Hello, world!");<br/>}</pre>
<ol start="3">
<li>We can extend the function by printing more. Insert the following after the <kbd>println!</kbd> macro call in the <kbd>main()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">    println!("a vec: {:?}", vec![1, 2, 3]);<br/>    println!("concat: {}", concat!(0, 'x', "5ff"));<br/>    println!("MyStruct stringified: {}", stringify!(MyStruct(10)));<br/>    println!("some random word stringified: {}", stringify!<br/>     (helloworld));<br/><br/></pre>
<ol start="4">
<li>The definition for <kbd>MyStruct</kbd> is also simple and involves a procedural macro that comes with the standard library. Insert this before the <kbd>main()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">#[derive(Debug)]<br/>struct MyStruct(usize);</pre>
<ol start="5">
<li>The Rust standard library also includes macros to interact with the outside world. Let's add a few more calls to the <kbd>main</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">    println!("Running on Windows? {}", cfg!(windows));<br/>    println!("From a file: {}", include_str!("a.txt"));<br/>    println!("$PATH: {:?}", option_env!("PATH")); </pre>
<ol start="6">
<li>As a final step, let's add two alternatives to the well-known <kbd>println!</kbd> and <kbd>assert!</kbd> macros to <kbd>main()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">    eprintln!("Oh no!");<br/>    debug_assert!(true);</pre>
<ol start="7">
<li>If you haven't already, we have to run the entire project using <kbd>cargo run</kbd> to see some output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo run</strong><br/>   Compiling std-macros v0.1.0 (Rust-Cookbook/Chapter06/std-macros)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.25s<br/>     Running `target/debug/std-macros`<br/>Hello, world!<br/>a vec: [1, 2, 3]<br/>concat: 0x5ff<br/>MyStruct stringified: MyStruct ( 10 )<br/>some random word stringified: helloworld<br/>Running on Windows? false<br/>From a file: Hello World!<br/>$PATH: Some("/home/cm/.cargo/bin:/home/cm/.cargo/bin:/home/cm/.cargo/bin:/usr/local/bin:/usr/bin:/bin:/home/cm/.cargo/bin:/home/cm/Apps:/home/cm/.local/bin:/home/cm/.cargo/bin:/home/cm/Apps:/home/cm/.local/bin")<br/>Oh no!</pre>
<p>We should now pull back the curtain to understand the code a bit better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Inside the <kbd>main</kbd> function, we now have a few macros that are more or less well known. Each of them is doing something we thought was useful. We'll skip <em>step 2</em> since it only shows the <kbd>println!</kbd> macro—something that we are using constantly. In <em>step 3</em>, however, some more exotic macros turn up:</p>
<ul>
<li><kbd>vec!</kbd> creates and initializes a vector and famously uses <kbd>[]</kbd> to do so. However, while this makes visual sense, the compiler will accept <kbd>vec!()</kbd> just as well as <kbd>vec!{}</kbd>. </li>
<li><kbd>concat!</kbd> joins literals from left to right like a static string. </li>
<li><kbd>stringify!</kbd> creates a string literal from the input tokens, regardless of whether they exist or not (see the word <kbd>helloworld</kbd>, which got translated to a string).</li>
</ul>
<p><em>Step 4</em> includes working with a procedural macro in Rust. While the word <em>derive</em> and the syntax bring to mind inheritance in classic OOP fashion, they are not actually deriving anything but are providing an actual implementation. For us, <kbd>#[derive(Debug)]</kbd> has certainly been the most useful, but there is also <kbd>PartialEq</kbd>, <kbd>Eq</kbd>, and <kbd>Clone</kbd>, which are closely behind. </p>
<p><em>Step 5</em> of the recipe returns to function-like macros:</p>
<ul>
<li><kbd>cfg!</kbd> is similar to the <kbd>#[cfg]</kbd> attribute, which makes it possible to determine conditions at compile time, which allows you—for example—to include platform-specific code. </li>
<li><kbd>include_str!</kbd> is a very interesting one. There are other includes, but this is very useful to provide translation to your applications since it reads the provided file's contents as a <kbd>'static str</kbd> (just like a literal). </li>
<li><kbd>option_env!</kbd> reads environment variables at <strong>compile time</strong> to provide an <kbd>Option</kbd> result of their values. Be aware that, in order to reflect the changes to the variable, the program has to be re-compiled! </li>
</ul>
<p><em>Step 6</em>'s macros are alternatives to other popular macros that we know:</p>
<ul>
<li><kbd>debug_assert!</kbd> is a variation of <kbd>assert!</kbd>, which is not included in <kbd>--release</kbd> builds.</li>
<li><kbd>eprintln!</kbd> outputs stuff on standard error instead of standard out. </li>
</ul>
<p>While this is a pretty stable selection, future releases of the Rust Standard Library will include more macros to make working with Rust more convenient. The most popular example—at the time of writing—for unfinished macros is <kbd>await!</kbd>, which might never be stabilized due to a different approach to <kbd>async</kbd>/<kbd>await</kbd>. Check out the full list in the document at <a href="https://doc.rust-lang.org/std/#macros">https://doc.rust-lang.org/std/#macros</a>.</p>
<p>Now we've learned more about using predefined macros, we can move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Code generation using macros</h1>
                
            
            
                
<p>Something derive-type macros already show us is that we can generate entire trait implementations using macros. Similarly, we can generate entire structs and functions using macros and avoid copy-and-paste programming, as well as tedious boilerplate code. Since macros are executed right before compilation, the generated code will be checked accordingly while avoiding the details of strictly typed languages. Let's see how!</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Code generation can be as easy as these few steps:</p>
<ol>
<li>Run <kbd>cargo new code-generation --lib</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code.</li>
<li>Open <kbd>src/lib.rs</kbd> and add the first simple macro:</li>
</ol>
<pre style="padding-left: 60px">// Repeat the statement that was passed in n times<br/>macro_rules! n_times {<br/>    // `()` indicates that the macro takes no argument.<br/>    ($n: expr, $f: block) =&gt; {<br/>        for _ in 0..$n {<br/>            $f()<br/>        }<br/>    }<br/>}</pre>
<ol start="3">
<li>Let's do another one, this time a bit more generative. Add this outside of the testing module (for example, underneath the previous macro):</li>
</ol>
<pre style="padding-left: 60px">// Declare a function in a macro!<br/>macro_rules! make_fn {<br/>    ($i: ident, $body: block) =&gt; {<br/>        fn $i () $body<br/>    } <br/>}</pre>
<ol start="4">
<li>Both of those macros are also very straightforward to use. Let's replace the <kbd>tests</kbd> module with relevant tests:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    #[test]<br/>    fn test_n_times() {<br/>        let mut i = 0;<br/>        n_times!(5, {<br/>            i += 1;<br/>        });<br/>        assert_eq!(i, 5);<br/>    }<br/><br/>    #[test]<br/>    #[should_panic]<br/>    fn test_failing_make_fn() {<br/>        make_fn!(fail, {assert!(false)});<br/>        fail();<br/>    }<br/><br/>    #[test]<br/>    fn test_make_fn() {<br/>        make_fn!(fail, {assert!(false)});<br/>        // nothing happens if we don't call the function<br/>    }<br/>}</pre>
<ol start="5">
<li>So far, the macros have not done a sophisticated code generation, however. In fact, the first one simply repeats a block several times—something that is already available through iterators (<a href="https://doc.rust-lang.org/std/iter/fn.repeat_with.html">https://doc.rust-lang.org/std/iter/fn.repeat_with.html</a>). The second macro creates a function, but that's available, too, via the closure syntax (<a href="https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html">https://doc.rust-lang.org/stable/rust-by-example/fn/closures.html</a>). Let's add something more interesting then, such as <kbd>enum</kbd> with a <kbd>Default</kbd> implementation:</li>
</ol>
<pre style="padding-left: 60px">macro_rules! default_enum {<br/>    ($name: ident, $($variant: ident =&gt; $val:expr),+) =&gt; {<br/>        #[derive(Eq, PartialEq, Clone, Debug)]<br/>        pub enum $name {<br/>            Invalid,<br/>            $($variant = $val),+<br/>        }<br/><br/>        impl Default for $name {<br/>            fn default() -&gt; Self { $name::Invalid }<br/>        }<br/>    };<br/>}</pre>
<ol start="6">
<li>Nothing can go untested, so here is a test to see whether it works as expected. Add this to the preceding tests:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_default_enum() {<br/>        default_enum!(Colors, Red =&gt; 0xFF0000, Blue =&gt; 0x0000FF);<br/>        let color: Colors = Default::default();<br/>        assert_eq!(color, Colors::Invalid);<br/>        assert_eq!(Colors::Red as i32, 0xFF0000);<br/>        assert_eq!(Colors::Blue as i32, 0x0000FF);     <br/>    }</pre>
<ol start="7">
<li>If we are writing tests, we also want to see them running:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/>Compiling custom-designators v0.1.0 (Rust-Cookbook/Chapter06/code-generation)<br/>warning: function is never used: `fail`<br/>  --&gt; src/lib.rs:20:9<br/>   |<br/>20 | fn $i () $body<br/>   | ^^^^^^^^^^^^^^<br/>...<br/>56 | make_fn!(fail, {assert!(false)});<br/>   | --------------------------------- in this macro invocation<br/>   |<br/>   = note: #[warn(dead_code)] on by default<br/><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.30s<br/>     Running target/debug/deps/custom_designators-ebc95554afc8c09a<br/><br/>running 4 tests<br/>test tests::test_default_enum ... ok<br/>test tests::test_make_fn ... ok<br/>test tests::test_failing_make_fn ... ok<br/>test tests::test_n_times ... ok<br/><br/>test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests custom-designators<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>In order to understand the code, let's talk about what's going on behind the scenes.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Thanks to the compiler executing macros before the actual compilation, we can generate code that will show up in the final program but that was actually created via a macro invocation. This lets us reduce boilerplate code, enforce defaults (such as implementing certain traits, adding metadata, and many others), or simply provide a nicer interface for users of our crate. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In <em>step 2</em>, we are creating a simple macro to repeat a block (these curly braces—<kbd>{ }</kbd>—and their content are called a <strong>block</strong>) several times—using a <kbd>for</kbd> loop. The tests created in <em>step 4</em> show how this operates and what it can do—it executes as if we were to write a <kbd>for</kbd> loop right in the test. </p>
<p><em>Step 3</em> creates a more interesting thing: a function. Together with the tests in <em>step 4</em>, we can see how the macro operates and note the following:</p>
<ul>
<li>The provided block is evaluated lazily (the test only fails when the function is called).</li>
<li>The compiler complains about an unused function if it is not called.</li>
<li>Creating a parameterized function in this way leads to a compiler error (it can't find the value).</li>
</ul>
<p><em>Step 5</em> creates a more complex macro that is able to create an entire <kbd>enum</kbd>. It lets the user define the variants (even using an arrow—<kbd>=&gt;</kbd>—notation), and adds a default value. Let's look at the pattern the macro expects: <kbd>($name: ident, $($variant: ident =&gt; $val:expr),+)</kbd>. The first parameter (<kbd>$name</kbd>) is an identifier, something that names something (that is, the rules of identifiers are enforced). The second parameter is a repeated parameter and it is required to be present at least once (indicated by <kbd>+</kbd>), but if you provide more instances, they have to be separated by <kbd>,</kbd>. The expected pattern for those repetitions is as follows: identifier, <kbd>=&gt;</kbd>, and expression (for example, <kbd>bla =&gt; 1 + 1</kbd>, <kbd>Five =&gt; 5</kbd>, or  <kbd>blog =&gt; 0x5ff</kbd>, and many others). </p>
<p>What follows inside the macro is a classic definition of <kbd>enum</kbd> with the repeated parameter inserted just as often as it occurs in the input. Then, we can add derive attributes on top of <kbd>enum</kbd> and implement the <kbd>std::default::Default</kbd> trait (<a href="https://doc.rust-lang.org/std/default/trait.Default.html">https://doc.rust-lang.org/std/default/trait.Default.html</a>) to provide something sensible for when a default value is required.</p>
<p>Let's learn some more about macros and parameters and move on to the next recipe.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">Macro overloading</h1>
                
            
            
                
<p>Method/function overloading is a technique to have duplicate method/function names but different parameters for each. Many statically typed languages, such as C# and Java, support this in order to provide many ways to call a method without having to come up with a new name each time (or use generics). Rust, however, does not support that for functions—with good reason (<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>). Where Rust does support overloading is with macro patterns: you can create a macro and have multiple arms that only differ in their input parameters. </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's implement some overloaded macros in a few simple steps:</p>
<ol>
<li>Run <kbd>cargo new macro-overloading --lib</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code.</li>
<li>In <kbd>src/lib.rs</kbd>, we add the following before the <kbd>mod tests</kbd> module declaration:</li>
</ol>
<pre style="padding-left: 60px">#![allow(unused_macros)]<br/><br/>macro_rules! print_debug {<br/>    (stdout, $($o:expr),*) =&gt; {<br/>        $(print!("{:?}", $o));*;<br/>        println!();<br/>    };<br/>    (error, $($o:expr),*) =&gt; {<br/>        $(eprint!("{:?}", $o));*;<br/>        eprintln!();<br/>    };<br/>    ($stream:expr, $($o:expr),*) =&gt; {<br/>        $(let _ = write!($stream, "{:?}", $o));*;<br/>        let _ = writeln!($stream);<br/>    }<br/>}</pre>
<ol start="3">
<li>Let's see how we apply this macro. Inside the <kbd>tests</kbd> module, let's see if the printer macro serializes strings to a stream by adding the following unit test (replace the existing <kbd>it_works</kbd> test):</li>
</ol>
<pre style="padding-left: 60px">    use std::io::Write;<br/> <br/>    #[test]<br/>    fn test_printer() {<br/>        print_debug!(error, "hello std err");<br/>        print_debug!(stdout, "hello std out");<br/>        let mut v = vec![];<br/>        print_debug!(&amp;mut v, "a");<br/>        assert_eq!(v, vec![34, 97, 34, 10]);<br/><br/>    }</pre>
<ol start="4">
<li>In order to facilitate testing in the future, we should add another macro inside the <kbd>tests</kbd> module. This time, the macro is mocking (<a href="https://martinfowler.com/articles/mocksArentStubs.html">https://martinfowler.com/articles/mocksArentStubs.html</a>) a function with a static return value. Write this after the previous test:</li>
</ol>
<pre style="padding-left: 60px">    macro_rules! mock {<br/>        ($type: ty, $name: ident, $ret_val: ty, $val: block) =&gt; {<br/>            pub trait $name {<br/>                fn $name(&amp;self) -&gt; $ret_val;<br/>            }<br/><br/>            impl $name for $type {<br/>                fn $name(&amp;self) -&gt; $ret_val $val<br/>            }<br/>        };<br/>        ($name: ident, $($variant: ident =&gt; $type:ty),+) =&gt; {<br/>            #[derive(PartialEq, Clone, Debug)]<br/>            struct $name {<br/>                $(pub $variant: $type),+<br/>            }<br/>        };<br/>    }</pre>
<ol start="5">
<li>Then, we should test the <kbd>mock!</kbd> macro as well. Add another test underneath:</li>
</ol>
<pre style="padding-left: 60px">    mock!(String, hello, &amp;'static str, { "Hi!" });<br/>    mock!(HelloWorld, greeting =&gt; String, when =&gt; u64);<br/><br/>    #[test]<br/>    fn test_mock() {<br/>        let mystr = "Hello".to_owned();<br/>        assert_eq!(mystr.hello(), "Hi!");<br/><br/>        let g = HelloWorld { greeting: "Hello World".to_owned(), <br/>        when: 1560887098 };<br/><br/>        assert_eq!(g.greeting, "Hello World");<br/>        assert_eq!(g.when, 1560887098);<br/>    }</pre>
<ol start="6">
<li>As a final step, we run <kbd>cargo test</kbd> to see if it works. However, this time, we pass <kbd>--nocapture</kbd> into the test harness to see what's been printed (for <em>step 3</em>):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test -- --nocapture</strong><br/>Compiling macro-overloading v0.1.0 (Rust-Cookbook/Chapter06<br/> /macro-overloading)<br/>warning: trait `hello` should have an upper camel case name<br/>  --&gt; src/lib.rs:53:19<br/>   |<br/>53 | mock!(String, hello, &amp;'static str, { "Hi!" });<br/>   | ^^^^^ help: convert the identifier to upper camel case: `Hello`<br/>   |<br/>   = note: #[warn(non_camel_case_types)] on by default<br/><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.56s<br/>     Running target/debug/deps/macro_overloading-bd8b38e609ddd77c<br/><br/>running 2 tests<br/>"hello std err"<br/>"hello std out"<br/>test tests::test_mock ... ok<br/>test tests::test_printer ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests macro-overloading<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Overloading is a very simple concept—so simple, in fact, that it's hard to find usable examples that can't be done using a sufficiently complex function. However, in this recipe, we think that we have come up with something useful.</p>
<p>In <em>step 2</em>, we created a wrapper around <kbd>println!</kbd> and similar functions that allow writing to standard streams such as standard output and standard error, or any other arbitrary stream type, with only a token to make the difference. There are a few interesting details to this implementation outside of this as well:</p>
<ul>
<li>Each call to <kbd>print!</kbd> is followed by <kbd>;</kbd>—except for the last one, which is why there is an extra <kbd>;</kbd> after the <kbd>*</kbd>.</li>
<li>The pattern allows for an arbitrary number of expressions to be passed in.</li>
</ul>
<p>This macro can be useful to avoid repeating <kbd>println!("{:?}", "hello")</kbd> just to quickly see the current value of a variable. Additionally, it facilitates output redirection to standard error. </p>
<p>In <em>step 3</em>, we create a test for this macro invocation. In a quick check, we print to <kbd>error</kbd>, <kbd>stdout</kbd>, and <kbd>vec!</kbd> (which is why we import <kbd>std::io::Write</kbd>). There, we can see the new line at the end and that it's written as a string (the numbers are bytes). In either call, it finds the required macro pattern and inserts its contents. </p>
<p><em>Step 4</em> creates a macro for mocking functions on structs or entire structs. This is very useful for isolating the tests to really only test the target implementation without running the risk of adding more errors by trying to implement a supporting function. In this case, the macro's arms are easy to distinguish. The first one creates a mock implementation of a function and matches the parameters it requires: the type it attaches to, the function's identifier, which return type, and a block that returns that type. The second arm creates a struct and therefore only requires an identifier to name the struct and properties together with their data types.</p>
<p>Mocking—or creating a mock object—is a testing technique that allows the creation of shallow constructs to simulate the desired behavior. This is very useful for things that cannot be implemented otherwise (external hardware, third-party web services, and many more) or complex internal systems (database connection and logic).</p>
<p>Next, we have to test these outcomes, which is done in <em>step 5</em>. There, we call the <kbd>mock!</kbd> macro and define its behavior along with a test to prove it works. We run the tests in <em>step 6</em> without the harness capturing the console outputs: it works! </p>
<p>We are certain that overloading macros were a breeze to learn. Now let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Using repeat for parameter ranges</h1>
                
            
            
                
<p class="mce-root">Rust's <kbd>println!</kbd> macro has a curious characteristic: there is no upper limit on the number of parameters that you can pass into it. Since regular Rust does not support arbitrary parameter ranges, it has to be a macro feature—but which? In this recipe, find out how to handle and implement parameter ranges for macros.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>You'll know how to use parameter ranges after these few steps:</p>
<ol>
<li>Run <kbd>cargo new parameter-ranges --lib</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code.</li>
<li>In <kbd>src/lib.rs</kbd>, add the following code to initialize a set in <kbd>vec!</kbd> style:</li>
</ol>
<pre style="padding-left: 60px">#![allow(unused_macros)]<br/><br/>macro_rules! set {<br/> ( $( $item:expr ),* ) =&gt; {<br/>        {<br/>            let mut s = HashSet::new();<br/>            $(<br/>                s.insert($item);<br/>            )*<br/>            s<br/>        }<br/>    };<br/>}</pre>
<ol start="3">
<li>Next, we'll add a simple macro to create a DTO—a data transmission object:</li>
</ol>
<pre style="padding-left: 60px">macro_rules! dto {<br/>    ($name: ident, $($variant: ident =&gt; $type:ty),+) =&gt; {<br/>        #[derive(PartialEq, Clone, Debug)]<br/>        pub struct $name {<br/>            $(pub $variant: $type),+<br/>        }<br/><br/>        impl $name {<br/>            pub fn new($($variant:$type),+) -&gt; Self {<br/>                $name {<br/>                    $($variant: $variant),+<br/>                }<br/>             }<br/>        }<br/>    };<br/>}</pre>
<ol start="4">
<li>This needs to be tested as well, so let's add a test to use the new macro to create a set:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod tests {<br/>    use std::collections::HashSet;<br/><br/>    #[test]<br/>    fn test_set() {<br/>        let actual = set!("a", "b", "c", "a");<br/>        let mut desired = HashSet::new();<br/>        desired.insert("a");<br/>        desired.insert("b");<br/>        desired.insert("c");<br/>        assert_eq!(actual, desired); <br/>    }<br/>}</pre>
<ol start="5">
<li>With the set initializer tested, let's also test creating a DTO. Add the following under the previous test:</li>
</ol>
<pre style="padding-left: 60px">    #[test]<br/>    fn test_dto() {<br/>        dto!(Sensordata, value =&gt; f32, timestamp =&gt; u64);<br/>        let s = Sensordata::new(1.23f32, 123456);<br/>        assert_eq!(s.value, 1.23f32); <br/>        assert_eq!(s.timestamp, 123456); <br/>    }</pre>
<p class="mce-root"/>
<ol start="6">
<li>As a final step, we also run <kbd>cargo test</kbd> to show that it works:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/> Compiling parameter-ranges v0.1.0 (Rust-Cookbook/Chapter06<br/>  /parameter-ranges)<br/>  Finished dev [unoptimized + debuginfo] target(s) in 1.30s<br/>  Running target/debug/deps/parameter_ranges-7dfb9718c7ca3bc4<br/><br/>running 2 tests<br/>test tests::test_dto ... ok<br/>test tests::test_set ... ok<br/><br/>test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests parameter-ranges<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Parameter ranges in Rust's macro system work a little bit like regular expressions. There are several parts to the syntax: <kbd>$()</kbd> indicates repetition, the character that follows its separator (<kbd>,</kbd>, <kbd>;</kbd>, and <kbd>=&gt;</kbd> are allowed), and lastly, the qualifier for how often the repetition is expected (<kbd>+</kbd> or <kbd>*</kbd>—just like regular expressions, one or more and zero or more respectively). </p>
<p><em>Step 2</em> shows the implementation of a set initializer macro akin to <kbd>vec!</kbd>. There, we expect a single expression to populate <kbd>std::collections::HashSet</kbd> and return the result in a sub-block from the transcriber. This is necessary to allow things such as variable assignments (which are not allowed directly within the transcriber block), but don't hinder the expansion of the parameters that were passed into the macro. In a similar fashion to the declaration, the expansion is done using a <kbd>$()</kbd> area, but instead of a separator, the repetition qualifier follows directly. Whatever is contained in there will be run as many times as there are parameters.</p>
<p>The second macro is defined in <em>step 3</em> and is much more complex. The name <kbd>dto!</kbd> (data transmission object) indicates a business object such as a data container that is only used to pass data around the program without being sent outside the program. Since these DTOs contain a significant amount of boilerplate code, they can be initialized similarly to a key-value store. By using the <kbd>=&gt;</kbd> sign in the parameter range specification, we can create identifier/type pairs that are used to create properties in <kbd>struct</kbd> and its constructor function. Note that the comma that separates the properties is located right before the <kbd>+</kbd> sign so it gets repeated as well. </p>
<p><em>Step 4</em> shows an invocation of the macro designed in <em>step 2</em> to populate a set and test to confirm it was populated properly. Similarly, <em>step 5</em> shows the creation and instantiation of a DTO instance (<kbd>struct</kbd> called <kbd>Sensordata</kbd>) along with a test to confirm that the properties were created as expected. The last step confirms this by running the tests. </p>
<p>We've successfully learned how to use repeat for parameter ranges. Now let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Don't Repeat Yourself </h1>
                
            
            
                
<p>In a previous recipe, we were using macros to generate almost arbitrary code, thereby reducing the amount of code to write. Let's dive deeper into this topic since this is a great way not only to reduce bugs but also to achieve consistent quality in code. One repetitive task that everyone should do is testing (especially if it's a public-facing API), and if we copy and paste those tests we expose ourselves to errors. Instead, let's see how we can generate boilerplate code with macros to stop repeating ourselves.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Automated testing with macros is only a few steps away:</p>
<ol>
<li>Run <kbd>cargo new dry-macros --lib</kbd> in Terminal (or PowerShell on Windows) and open the directory with Visual Studio Code.</li>
<li>In <kbd>src/lib.rs</kbd>, we want to create a helper macro and import the stuff we need:</li>
</ol>
<pre style="padding-left: 60px">use std::ops::{Add, Mul, Sub};<br/><br/>macro_rules! assert_equal_len {<br/>    // The `tt` (token tree) designator is used for<br/>    // operators and tokens.<br/>    ($a:ident, $b: ident, $func:ident) =&gt; (<br/>        assert_eq!($a.len(), $b.len(),<br/>                "{:?}: dimension mismatch: {:?} {:?}",<br/>                stringify!($func),<br/>                ($a.len(),),<br/>                ($b.len(),));<br/>    )<br/>}</pre>
<ol start="3">
<li>Next, we define a macro to auto-implement an operator. Let's add this underneath the <kbd>assert_equal_len</kbd> macro:</li>
</ol>
<pre style="padding-left: 60px">macro_rules! op {<br/>    ($func:ident, $bound:ident, $method:ident) =&gt; (<br/>        pub fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut <br/>        Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {<br/>            assert_equal_len!(xs, ys, $func);<br/><br/>            for (x, y) in xs.iter_mut().zip(ys.iter()) {<br/>                *x = $bound::$method(*x, *y);<br/>            }<br/>        }<br/>    )<br/>}</pre>
<ol start="4">
<li>Now, let's call the macro and actually generate the implementation:</li>
</ol>
<pre style="padding-left: 60px">op!(add_assign, Add, add);<br/>op!(mul_assign, Mul, mul);<br/>op!(sub_assign, Sub, sub);</pre>
<ol start="5">
<li>With these functions in place, we can now generate the test cases as well! Add the following instead of the <kbd>test</kbd> module:</li>
</ol>
<pre style="padding-left: 60px">#[cfg(test)]<br/>mod test {<br/><br/>    use std::iter;<br/>    macro_rules! test {<br/>        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {<br/>            #[test]<br/>            fn $func() {<br/>                for size in 0usize..10 {<br/>                    let mut x: Vec&lt;_&gt; = <br/>                    iter::repeat($x).take(size).collect();<br/>                    let y: Vec&lt;_&gt; = <br/>                    iter::repeat($y).take(size).collect();<br/>                    let z: Vec&lt;_&gt; = <br/>                    iter::repeat($z).take(size).collect();<br/><br/>                    super::$func(&amp;mut x, &amp;y);<br/><br/>                    assert_eq!(x, z);<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    // Test `add_assign`, `mul_assign` and `sub_assign`<br/>    test!(add_assign, 1u32, 2u32, 3u32);<br/>    test!(mul_assign, 2u32, 3u32, 6u32);<br/>    test!(sub_assign, 3u32, 2u32, 1u32);<br/>}</pre>
<ol start="6">
<li>As a final step, let's see the generated code in action by running <kbd>cargo test</kbd> to see the (positive) test results:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo test</strong><br/> Compiling dry-macros v0.1.0 (Rust-Cookbook/Chapter06/dry-macros)<br/>  Finished dev [unoptimized + debuginfo] target(s) in 0.64s<br/>  Running target/debug/deps/dry_macros-bed1682b386b41c3<br/><br/>running 3 tests<br/>test test::add_assign ... ok<br/>test test::mul_assign ... ok<br/>test test::sub_assign ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><br/>   Doc-tests dry-macros<br/><br/>running 0 tests<br/><br/>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</pre>
<p>In order to understand the code better, let's decipher the steps.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>While design patterns, <kbd>if-else</kbd> constructs, and API design, in general, facilitate reusing code, it becomes tricky when it's time to hardcode tokens (for example, certain names) to remain loosely coupled. Rust's macros can help with that. As an example, we generate functions and tests for those functions in an effort to avoid copying and pasting test code around files. </p>
<p>In <em>step 3</em>, we declare a macro that wraps around comparing the lengths of two sequences and provides a better error message. <em>Step 4</em> uses this macro right away and creates a function with the name provided, but only if the lengths of the multiple input <kbd>Vec</kbd> instances match. </p>
<p>In <em>step 5</em>, we call the macros and provide them with the required input: a name (for the function) and types for the generic binding. This creates the functions using a provided interface without the need to copy and paste code.</p>
<p><em>Step 6</em> creates the associated tests by declaring the <kbd>test</kbd> module, a macro to generate the tests, and the call to finally create the test code as well. This allows you to generate the tests on the fly, right before compiling them, which significantly reduces the amount of static, repeated code—which has always been an issue in testing. The last step shows that these tests are actually created and executed when running <kbd>cargo test</kbd>. </p>


            

            
        
    </div></body></html>