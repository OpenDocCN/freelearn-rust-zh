- en: Advanced Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating lazy static objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bit fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing custom derives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting types into each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boxing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing ownership with smart pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with interior mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have primarily looked at techniques that were all useful in their
    own right. Of course, we are continuing that trend, but the recipes shown in this
    chapter truly shine when combined with other code. You can imagine them as the
    *glue* holding a nice Rust program together, as they are primarily oriented toward
    new enabling ways in which different components of your crate can work together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating lazy static objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Big objects, especially constant ones, should be reused instead of rebuilt.
    The `lazy_static!` macro helps you with this by extending Rust's normal `static`
    functionality, which normally requires your objects to be constructable at compile-time,
    with the ability to create lazy objects that are initialized during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a Rust project to work on during this chapter with `cargo new chapter_five`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate into the newly created `chapter_five` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `src` folder, create a new folder called `bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to the crates.io web pages for `lazy_static` ([https://crates.io/crates/lazy_static](https://crates.io/crates/lazy_static))
    and regex ([https://crates.io/crates/regex](https://crates.io/crates/regex)) to
    check for the newest version and use that one instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the `src/bin` folder, create a file called `lazy_static.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin lazy_static`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By invoking the `lazy_static!` macro [10, 21 and 29], we define a lazily initialized
    object in the current scope. *Lazy* here means *created only the first time it
    is used*.
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to a `let` binding, its scope can also be the global scope [10]. A
    realistic example for this is creating a collection with a known content that
    is used by many functions, as the alternative would be to create it once and pass
    it around endlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your `lazy_static` consists of a `Vec` with content that is known at compile
    time, you can instead use a `const` array, as its construction is constant. In
    terms of code, this means you don''t need to use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember when, in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*; *Querying with Regexes*, we talked about how compiling
    Regexes is expensive and should be avoided? `lazy_static!` is ideal for this.
    In fact, the pattern of creating a local `static` regex in a function is so widespread
    that we included it in this example [29]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you can also create a global mutable state with `lazy_static` objects
    [21]. As mentioned in earlier chapters, the excessive state is the root of many
    evils in software development and should be treated with care. There are very
    few cases where having such an object is justifiable, as it is almost always better
    to pass the object around. There are exceptions, however. Sometimes a program
    revolves around the manipulation of one specific dataset in memory and all involved
    actors want to access it. In these cases, it can be very cumbersome to pass an
    object to literally every function in your code. One possible, but still very
    rare, an example where this might happen, is when dealing exclusively with a list
    of active connections [21]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that, as the borrow checker is disabled for objects with `'static` lifetimes
    (see the following *There's more...* section), we need to wrap our `static` in
    a parallel lock, such as `RwLock` or `Mutex`, to guarantee thread safety. You
    can read more about that in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism
    and Rayon*; *Access resources in parallel with RwLocks*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People coming from other languages might wonder what `lazy_static` offers that
    can't already be done by a normal `static` object. The difference between them
    is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, a `static` variable is a variable that lives for the entire duration
    of the program, which is why they get their own, special lifetime, `'static`.
    The catch is that the variable has to be built in a constant way, that is, a way
    that is known at compile time. In our example, we cannot replace `CURRENCIES`
    [11] with a normal `static` because `HashMap::new()` returns a newly constructed
    `HashMap` sitting somewhere in the memory during runtime. As this requires it
    to live in memory, it's impossible to build a `HashMap` during compile time, so
    its constructor is not `constant`.
  prefs: []
  type: TYPE_NORMAL
- en: Another catch with `static` variables is that, because they have a global lifetime,
    the borrow checker cannot make sure that their access is thread-safe. As a consequence,
    any access on a `static mut` variable will always be `unsafe`.
  prefs: []
  type: TYPE_NORMAL
- en: The convention for `static` variables is to write them in `ALL_CAPS`, just like
    `const` variables. This is because they are very closely linked. In fact, a `const`
    is nothing but an inlined `static` that can never be `mut`.
  prefs: []
  type: TYPE_NORMAL
- en: '`lazy_static` gets around these restrictions by wrapping your object in a newly
    created `struct` that can be implicitly dereferenced into your object. This means
    that you never actually access your object directly. `lazy_static` stresses this
    by demanding that you write `ref` during the declaration of the `static`, as this
    makes you mentally treat the variable as a reference rather than an actual object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While dereferencing, the wrapper `struct` works with a `static mut` pointer
    in your dynamically created object. All it does then is wrap the `unsafe` calls
    in a safe way.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from a modern C++ background, you can view a normal `static` Rust
    as a `static constexpr` C++ and a `lazy_static` Rust as a `static` C++ local.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Querying with Regexes* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Access resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bit fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs written in C don't have the possibility to use the Builder Pattern
    ([Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*;
    *Using the builder pattern*) to provide users with combinable options. Instead,
    they have to rely on bit fields. As C has historically become the *lingua franca*
    of system languages, you will have to interact with a lot of C code if you plan
    on wrapping existing programs in a Rust interface or vice versa. Because of this,
    you will sooner or later come in contact with bit fields. As Rust's `enum` is
    way more complex than a C `enum`, you have to instead rely on the `bitflags` crate
    to provide you with all of the necessary functionality to comfortably handle bit
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter assumes that you know what a bit field is. Explaining it here
    doesn''t make sense, as it would also incorporate an explanation of binary arithmetic
    and is not that relevant in your day-to-day Rust experience. For a good introduction
    to bit fields, check out this forum post and tutorial: [http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/](http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/)
    and [https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm),
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `Cargo.toml` file that was generated earlier for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `[dependencies]`, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to bitflags' crates.io page ([https://crates.io/crates/bitflags](https://crates.io/crates/bitflags))
    to check for the newest version and use that one instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `bit_fields.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin bit_fields`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bitflags!` macro lets you define all of your flags and their underlying
    type (in our case, this is `u32`)[4 to 15]. They are written in `ALL_CAPS` because
    they are constants. We can also define collections of flags this way, as we did
    with `ALL`[10]. We could have added additional combinations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The macro then creates a struct with the specified members for you and implements
    a bunch of traits for it in order to enable the familiar `|`, `&`, `-`, and `!`
    notations [37 to 40] and pretty printing. You can still access the raw `bits`
    used in the background directly over the member of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, when printing, flag combinations will be listed separately. For
    instance, look at the output in line [47]. After setting all possible flags in
    the field to active, it will pretty print itself as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A useful method to additionally define on a bit field is `clear()`[19]. This
    hides the underlying `bits` from the user and is nicely readable.
  prefs: []
  type: TYPE_NORMAL
- en: With the aforementioned binary operators, you can perform *set operations* on
    your bit field [37 to 40]. These are the same operations as the ones you can perform
    on a `HashSet` and are explained with a nice diagram in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working
    with Collections;* *Using a HashSet*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with single flags in the bit field is also very easy. `insert()` sets
    a flag in the field to active [45], `remove()` sets it to inactive [50], and `toggle`
    flips it from active to inactive and vice versa [48]. If you don't yet know whether
    you're going to `insert` or `remove` a flag, as is the case with unpredictable
    user input, you can use `set()` to explicitly set the activation of a flag to
    either `true` or `false` [55].
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether a certain flag is active by calling `contains()` [56].
    This also works for another bit field or a flag combination. This means that the
    following is also valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can use `intersects()` to check whether *any* flags in two-bit
    fields match.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you can deserialize raw bytes into your generated bit field
    struct by calling `from_bits()` on it [62]. This will check whether every bit
    actually corresponds to a flag and return `None` otherwise. You can skip the error
    checking and simply ignore invalid bits with `from_bits_truncate()` if you're
    absolutely 100% sure that the data has to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Using a HashSet* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing custom derives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have looked at `#[derive(Debug)]` and assumed it's some weird compiler
    magic. It is not. It is a so-called *procedural macro*, that is, a macro that
    doesn't simply expand at compile time but instead *runs* at compile time. This
    way, you can inject code into the actual compilation process. The most useful
    application for this is creating custom derives, with which you can generate new
    code based on the analysis of existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will operate with an *Abstract Syntax Tree*, or AST. It is a tree-like
    representation of a language's elements in relation to each other. In this recipe,
    we (that is, a cool crate called `syn`) will parse our entire program into a single
    deep `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new sub-crate for the custom derive with `cargo new chapter-five-derive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the newly generated `chapter-five-derive/Cargo.toml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this directly above the `[dependencies]` section of the file in order to
    mark the crate as a procedural macro crate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `[dependencies]`, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can go to the crates.io web pages for `syn` ([https://crates.io/crates/syn](https://crates.io/crates/syn))
    and `quote` ([https://crates.io/crates/quote](https://crates.io/crates/quote))
    to check for the newest version and use that one instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chapter-five-derive/src/lib.rs` file, delete the generated code and
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the original `Cargo.toml` file of this chapter, add the following to the
    `[dependencies]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 7\. In the `bin` folder, create a file called `custom_derive.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: '8\. Add the following code and run it with `cargo run --bin custom_derive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The instructions for this recipe are a bit more complex than the others, as
    we need to manage two separate crates. If your code doesn''t compile, compare
    your version with the one used in the book at [https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five.](https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five)
    We need to separate the code into two crates because providing a custom `derive`
    requires creating a procedural macro, as indicated by all of the instances of
    `proc_macro` in the code. A procedural macro is Rust code that runs alongside
    the compiler and interacts directly with it. Because of the special nature and
    unique restrictions of such code, it needs to be in a separate crate that is annotated
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This crate is typically named after the main crate with the `_derive` suffix
    added. In our example, the main crate is called `chapter_five`, so the crate providing
    the procedural macro is called `chapter_five_derive`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are going to create a derived version of good, old Hello
    World: a `struct` or `enum` deriving from `HelloWorld` will implement the `HelloWorld`
    trait, providing a `hello_world()` function with a friendly greeting containing
    its own name. Additionally, you can specify a `HelloWorldName` attribute to alter
    the message.'
  prefs: []
  type: TYPE_NORMAL
- en: The code in `custom.rs` should be self-explanatory. We begin by importing our
    derivation crate [2] where we need to include the `#[macro_use]` attribute in
    order to actually import the procedural macros. We then define our `HelloWorld`
    trait [5] and proceed to derive it on a bunch of structures [13, 16 and 19], just
    like we would with built-in derives such as `Debug` or `Clone`. `Australia` gets
    a custom message via the `HelloWorldName` attribute. Lastly, in the `main` function,
    we call the generated `hello_world()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at `chapter-five-derive/src/lib.rs` now. Procedural macro
    crates typically begin by importing the `proc_macro`, `quote`, and `syn` crates.
    Attentive readers will have noticed that we didn't add the `proc_macro` to our
    `[dependencies]` section in the crate's `Cargo.toml`. We didn't need to because
    this special support crate is provided by the standard Rust distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `quote` crate provides the `quote!` macro, which lets us translate Rust
    code into tokens that the compiler can use. The really useful feature of this
    macro is that it supports code interpolation of a variable by writing a `#` in
    front of it. This means that when we write the following, the value inside the `struct_name` variable is
    interpreted as Rust code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If `struct_name` has the `Switzerland` value, the following code will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `syn` crate is a Rust parser built upon the `nom` parser combinator framework ([https://github.com/Geal/nom](https://github.com/Geal/nom)),
    which you should check out as well if you're thinking about writing a parser.
    In fact, some of the crates used in [Chapter 4](c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml),
    *Serialization*, are written with `nom`, too. Back on track, `syn` parses the
    code annotated by your custom attributes or derives and lets you work with the
    generated abstract syntax tree.
  prefs: []
  type: TYPE_NORMAL
- en: The convention for a custom derive is to create a function with the name of
    the derive in `snake_case` (`pub fn hello_world`, in our case) that parses the
    annotated code and then calls a function that generates the new code. The second
    function typically has the name of the first one, prefixed with `impl`. In our
    code, this is `fn impl_hello_world`.
  prefs: []
  type: TYPE_NORMAL
- en: In a `proc_macro` crate, only functions tagged with `proc_macro_derive` are
    allowed to be published. The consequence of this is, by the way, that we are not
    able to move our `HelloWorld` trait into this crate; it wouldn't be allowed to
    be `pub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `proc_macro_derive` annotation requires you to specify which name will
    be used for the derive (`HelloWorld` for us) and which attributes it allows. If
    we didn''t want to accept the `HelloWorldName` attribute, we could simply omit
    the entire attributes section and annotate our function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `hello_world` hooks itself directly into the compiler, it both accepts
    and returns a `TokenStream`, which is the compiler-internal representation of
    Rust code. We start by turning the `TokenStream` back into a `String` in order
    to be parsed again by `syn`. This is not an expensive action, as the `TokenStream`
    we receive from the compiler is not the entire program, but only the part annotated
    by our custom derive. For example, the `String` behind the `TokenStream` of the
    first `struct` annotated by `HelloWorld` is simply the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We then parse the said string with `syn::parse_derive_input(&s)`, which basically
    tells `syn` that the code we want to parse is a `struct` or `enum` that is deriving
    something.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then generate the code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we convert it back into a `TokenStream` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `TokenStream` is then injected back into the code by the compiler. As you
    can see, a procedural macro cannot change existing code, but only analyze it and
    generate additional code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the process described in `hello_world`:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the `TokenStream` into a `String`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the `String` with `syn`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate an implementation of another method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the implementation back into a `TokenStream`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is very typical for a custom derive. You can reuse the code presented in
    nearly all basic procedural macros.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to `impl_hello_world` now. With the help of the `ast` passed,
    we can analyze the annotated structure. The `ident` member, which stands for *identifier*,
    tells us the name of the `struct` or `enum`. For instance, in the first struct
    that derives from `HelloWorld`, this is the `"Switzerland"` string.
  prefs: []
  type: TYPE_NORMAL
- en: We then decide which name to use in the greeting with the help of the `get_name_attribute` little
    helper function, which we will look at in a moment. It returns the value of the
    `HelloWorldName` attribute if it has been set. If not, we default to the `identifier`,
    converted to a string via `as_ref`[29]. How this is done is explained in the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create some `quote::Tokens` by writing the implementation and surrounding
    it with `quote!`. Notice again how we interpolate variables into the code by writing
    `#` in front of it. Additionally, while printing, we surround `#identifier` with
    `stringify!`, which turns an identifier into a string. We don''t need to do this
    with `#hello_world_identifier` because it already holds a string. To understand
    why this is needed, let''s look at the code that would be generated for the `Switzerland`
    struct if we *didn''t* include `stringify!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Try it out for yourself, and you will be greeted with an error message stating
    that something along the lines of ``"`Switzerland` cannot be formatted with the
    default formatter"``. This is because we are not printing the `"Switzerland"` string,
    but instead trying to print the concept of the `Switzerland` struct itself, which
    is clearly nonsense. To fix this, we just need to make sure that the interpolated
    variable is surrounded by quotes (`"`), which is exactly what `stringify!` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the final piece of the puzzle now: `get_name_attribute`. This
    function might look a little intimidating at first. Let''s go through it step
    by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''ll go through all available attributes and search for one named `"HelloWorldName"`.
    If we don''t find any, the function call already ends by returning `None`. Otherwise,
    we continue with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`syn::MetaItem` is simply how `syn` calls attributes. This line is necessary
    because there are many ways to write attributes in Rust. For example, a `syn::MetaItem::Word`
    can be written like `#[foo]`. An example for `syn::MetaItem::List` is `#[foo(Bar,
    Baz, Quux)]`. `#[derive(...)]` itself also a `syn::MetaItem::List`. We, however,
    are only interested in `syn::MetaItem::NameValue`, which is an attribute in the
    form of `#[foo = Bar]`. If the `HelloWorldName` attribute is not in this form,
    we `panic!` with a message explaining what the problem is. A `panic` in procedural
    macro results in a compiler error. You can verify this by replacing `#[HelloWorldName
    = "the Land Down Under"` in `custom.rs` with `#[HelloWorldName]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to normal programs, because of procedural macros `panic!` at compile
    time, it's okay for them to `panic!` often. When doing so, remember that errors
    originating from other crates are very nasty to debug, doubly so in any kind of
    macros, so it's incredibly important to write the error messages as explicitly
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last check we need to do is on the value of `HelloWorldName`. As we are
    going to print it, we want to accept only strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On success, we return the string. Otherwise, we again `panic!` with an error
    message detailing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ran into trouble while running this recipe, you can use David Tolney's
    `cargo-expand` ([https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand))
    to show you how the compiler expanded your `proc_macros`. It's a really useful
    tool to debug your macros, so be sure to check it out.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind the two-crate restriction is historical and only temporary.
    In the beginning, there was only one way to define macros, `macro_rules!`. People
    with exotic needs, who were ready to put in the effort, were (and still are) able
    to extend their programs by directly hooking into the Rust compiler itself. Crates
    written this way are called *compiler plugins*. Of course, this is incredibly
    unstable because every minor Rust release can break your plugin, but people kept
    on doing it because it gave them one big advantage, custom derives. The core team
    reacted to the increased demand for language extensibility by deciding to launch
    `macros2.0` at some point in the future, bringing an overhaul to the entire macro
    system and many additional features, such as namespacing macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'As they saw that most of the plugins were used only for custom derives, they
    also decided to bridge the time until `macros2.0` with `macros1.1`, which are
    also called *procedural macros*. Stabilizing the small subset of the compiler
    that is needed to create custom derives. The only problem was that crates now
    had parts that ran normally and parts that ran at compile time instead. Mixing
    them proved difficult to implement and a bit chaotic, so the two-crate system
    of moving all procedural macro code into a `-derive` crate was created. This is
    the system used in this recipe, as at the time of writing, `macros2.0` has not
    been stabilized yet. I encourage you to take a look at the current progress: [https://github.com/rust-lang/rust/issues/39412](https://github.com/rust-lang/rust/issues/39412).'
  prefs: []
  type: TYPE_NORMAL
- en: If by the time you read this book, `macros2.0` has been released, you should
    update your knowledge about how to write modern custom derives.
  prefs: []
  type: TYPE_NORMAL
- en: Converting types into each other
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having dedicated types is great, but true flexibility can only come when these
    types can easily be converted from and into each other. Luckily, Rust provides
    this functionality quite literally through the `From` and `Into` traits, along
    with some friends.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `conversion.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin conversion`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important trait for conversion is `From`. Implementing it means defining
    how to obtain a type *from* another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We present this on the example of `DoubleVec`[6]. Its concept is simple, when
    you construct it out of a `Vec`, it doubles all its elements. For this purpose,
    we implement `From<Vec<T>>` [11] with a `where` clause specifying `T: MulAssign<i32>`[13],
    which means that the trait will be implemented for all types that can be assigned
    to the result of a multiplication with an integer. Or, in terms of code, all types
    that allow the following, assuming the `t` variable is of the `T` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation should be self-explanatory, we simply multiply every
    element in the vector by two and wrap it in our `DoubleVec`[19]. Afterwards, we
    implement `From` as well for slices of the same type [25].
  prefs: []
  type: TYPE_NORMAL
- en: It is considered good practice to extend all of your trait definitions that
    work with vectors ( `Vec<T>` ) to also work with slices (`&[T]`). This way, you
    gain generality and performance, as you can operate on direct references to arrays
    (such as `&[1, 2, 3]`) and ranges of other vectors (`vec[1..3]`) without converting
    them first. This best practice carries over to functions as well, where you should
    always accept a slice of your type (as shown with `print_elements()`), if possible,
    for the same reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this implementation, however, we see something interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`slice.to_vec()` simply converts the slice into a vector. But what''s up with
    `.into()`? Well, it comes from the `Into` trait, which is the opposite of the
    `From` trait, it converts a type *into* another. But how does a `Vec` know how
    to turn into a `DoubleVec`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the standard library''s implementation of `Into` at [https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs](https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs),
    where we find the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! According to this, every `T` type that implements `From` for `U` automatically
    lets `U` implement `Into` for `T`. And sure enough because we implemented `From<Vec<T>
    for DoubleVec<T>`, we automatically also implemented `Into<DoubleVec<T>> for Vec<T>`.
    Let''s look at our code from before again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The slice gets turned into a `Vec`, which implements `Into` for `DoubleVec`,
    among many others. Because our function signature says that we return `Self`,
    Rust knows which `Into` implementation to use, as only one of them returns `DoubleVec`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful trait for type conversion is `AsRef`. Its only function, `as_ref`,
    is nearly identical to `into`, but instead of moving itself into another type,
    it takes a reference to itself and returns a reference to another type. In a way,
    it *translates* references. You can expect this operation to be cheap in most
    cases, as it typically just returns a reference to an internal object. In fact,
    you have already used this method in the last recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`identifier` internally holds a `String` of its name. The compiler knows that
    `hello_world_name` has to be a `&str`, as the return type of `get_name_attribute(ast)`
    is `Option<&str>` and we are trying to unwrap it with a default value. Based on
    this information, `as_ref()` tries to return a `&str`, which it can, as the only
    implementation of `AsRef` for `identifier` that returns a `&str` is the one that
    returns a reference to the aforementioned `String` that holds its name.'
  prefs: []
  type: TYPE_NORMAL
- en: We are only implementing `AsRef` for `Vec`, and not for a slice, because of
    a reference to a vector (`&Vec<T>`) with automatically deref-coerce into a slice 
    (`&[T]`), which means we automatically implement it. You can read more about the
    concept of deref coercion at [https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods](https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods).
  prefs: []
  type: TYPE_NORMAL
- en: '`AsRef` also has a brother called `AsMut`, which is identical but operates
    on mutable references. We intentionally didn''t implement it in this example,
    as we don''t want users messing with the internal state of `DoubleVec`. In general,
    you should be very conservative with this trait as well, as excessive access to
    the internals of anything can quickly become very chaotic.'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function contains some examples of converting types. A popular example
    is the conversion from `&str` to `String` in lines [46 to 48]. Interestingly,
    `&str` can also be converted into a vector of its underlying bytes [52 and 53].
    Let's look at how our `DoubleVec` can be converted in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line showcases how the `&Vec<i32>` returned by `double_vec.as_ref()`
    seamlessly behaves like an `&[i32]`, as `print_elements()` only accepts slices
    [67]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the recipe is about API design. There is a little implementation
    of `From` in the standard library that reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that every type can be converted into an `Option`. You can use this
    trick, as showcased in the implementation of `ergonomic_public_func` [100], to
    make functions with multiple parameters of the `Option` type easier to use and
    look at, as you can see by comparing the following two function calls [71 and
    72]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, because some extra typing is required to achieve this, it's okay if
    you only do this on functions that are part of your API, that is, available to
    users of your crate. If you want to read some more tips about clean API design
    in Rust, check out Rust core developer Pascal Hertleif's excellent blog entry:  [https://deterministic.space/elegant-apis-in-rust.html.](https://deterministic.space/elegant-apis-in-rust.html)
  prefs: []
  type: TYPE_NORMAL
- en: Boxing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first smart pointer we are going to look at is the `Box`. This very special
    type is the analogue to C++'s `unique_ptr`, a pointer to data stored on the heap
    that deletes said data automatically when it's out of scope. Because of the shift
    from stack to heap, `Box` can allow you some flexibility by intentionally losing
    type information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `boxing.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin boxing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing that we are going to explore are recursive types, that is,
    a type that contains itself. This cannot be done directly, as the compiler needs
    to know in advance how much space a type requires. Consider the following `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will ask itself, `How much space does it take to create a Foo?` and
    see that it needs just enough space to hold an `i32`. And how much does an `i32`
    need? Exactly 32 bits. Now, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'How much space does `Foo` need? Enough to hold an `i32` and a `Foo`. How much
    is an `i32`? 32 bits. And `Foo`? Enough to hold an `i32` and a `Foo`. And how
    much does that `Foo` take? Enough for a `Foo`, and so on, until the heat death
    of the universe. Clearly, we don''t want to spend that long on compiling. Let''s
    take a look at the solution to our problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: One last time, how big is `Foo`? Enough to hold an `i32` and a `Foo`. How big
    is an `i32`? 32 bits. How big is a `Box<Foo>`? Just as big as a box of any other
    type, namely 64 bit. Every `Box` will always have the same size, as they are all
    the same thing, a pointer to some type in the heap. This way, we resolved our
    problem, as the compiler now knows the exact size of the type at compile time
    and is happy. And because it is happy, we are happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code example, we illustrate one possible use case for a recursive type,
    a naive binary tree implementation [9]. In case you didn''t know, a binary tree
    consists of a clump of data, which is called a *node*, that can be connected to
    either zero or two other *child nodes*. A node that is connected to zero nodes
    is a *leaf*. In our example, we build such a tree that will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b80fc206-db6d-4c14-8575-7a18fc1ce149.png)'
  prefs: []
  type: TYPE_IMG
- en: We implement it as a `struct Node` that contains any data and optionally a pair
    of `BoxedNode`, which is just an alias for `Box<Node>`.
  prefs: []
  type: TYPE_NORMAL
- en: A real binary tree implementation that is optimized for speed will be a little
    bit more complex than our example. While the concept of recursion fits very nicely
    into a binary tree, it is rather inefficient to store every node separately somewhere
    in the heap. Real implementations will instead just appear to be recursive for
    the user but internally store the nodes in a `Vec<Node>`. This way, the nodes
    profit from speed gains by simply being allocated in a continuous memory block,
    as this will optimize caching. Rust's `BTreeMap` and `BTreeSet` follow this concept
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A binary tree is an excellent kind of data structure for data traversal. You
    can read about some of its biggest use cases at the following StackOverflow answer
    by Danny Pflughoeft: [https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588](https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing that a `Box` enables us to do is classic polymorphism how you
    will recognize it from other languages. For this, we prepare a trait called `Animal`
    [37] that has a method to produce a `sound()`. Its implementor, `Dog` [42], will
    produce `"Woof!"`[45] and the `Cat` [50] implementor will produce `"Meow!"` [53].
    Our goal is to store both a `Dog` and a `Cat` in a `Vec` of `Animal`. We can do
    this by creating a so-called *trait object*. It is created by a `Box` of a trait,
    like in our example in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This way, we intentionally erase type information from the actual type in the
    `Box`. The compiler no longer knows which type is in the `Box`, only that it implements
    `Animal`, which is all that it needs to know. As you can see by running the code,
    the Rust runtime will still execute the correct functions and give the `Dog` and
    the `Cat` different sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the same mechanism, we can return a trait object of `Iterator`[90]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can mix and match iterators inside `caps_words_iter()` without
    caring for the exact return type, so long as it implements `Iterator`, which they
    all do. Remember that we can't just return `Iterator` directly without any `Box`
    around it, as we cannot return a trait. A trait object, however, is completely
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'On we go to `read_file_as_number()`[96]. This method reads a file and returns
    the content parsed as an `i32`. This file will not be generated for you, so you
    will have to either download it from our GitHub repo or manually create a file
    called `number.txt` that contains a number, say `777`. From the signature, you
    can gather that this time we are boxing the `Error`. This lets us mix the error
    type returned. Indeed, this method does return two different kinds of errors:
    `std::io::Error` and `std::num::ParseIntError`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that we are going to look at is how to return closures with `create_multiplier()`[105].
    As all closures implement either `Fn`, `FnOnce`, and/or `FnMut`, we can return
    a trait object for them. This way, we can create, compose, and change functions
    at runtime, just like with functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that returning a `Box<Iterator>` or a `Box<Error>` comes
    at a small cost in terms of efficiency, as it requires moving an object onto the
    heap without it having any reason to go there. There are currently two ways around
    this.
  prefs: []
  type: TYPE_NORMAL
- en: For `Box<Error>`, you should instead create an own `Error` type, combining all
    the possible errors that can be returned from your function. This is detailed
    in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml), *Handling Errors*;
    *Providing user-defined Error types*.
  prefs: []
  type: TYPE_NORMAL
- en: For `Box<Iterator>`, you can analyze the compiler's output in order to find
    out the exact true type that you're returning. This works for small iterators,
    but any complex iterator will take a long time to crack. Because this situation
    is not really desirable, the Rust team has approved the introduction of *abstract
    types*, which will be introduced in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*; *Returning abstract types* because it has
    not yet hit stable Rust.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Providing user-defined error types* recipe in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Returning abstract types* recipe in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing ownership with smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some ownership relationships are not as straightforward as *type A owns B*.
    Sometimes, an entire group of types owns another type. To handle this, we need
    another smart pointer that behaves mostly like `Box` but only deletes the underlying
    resource if no one needs it anymore, it is `Rc`, which stands for Reference Counted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `shared.rs`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo run --bin shared`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart and soul of an `Rc` is its internal counter of how many objects own
    it at the moment. Every time the `Rc` is cloned, it increases by one, and every
    time one of its clones go out of scope, it decreases by one. The moment this counter
    reaches zero, the objects behind the `Rc` are destroyed. The `main` method contains
    some annotated examples of values the counter reaches during its lifetime to help
    you understand how the mechanism works.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of the simple rules presented is that a resource behind an `Rc` will
    only be deleted once it's no longer used, at the slim cost of a very small runtime
    performance loss because of the ongoing counting. This *delayed deletion* effect
    is ideal for resources that are shared between objects. Simply wrap them in an
    `Rc` and they will make sure that everything survives long enough. This is the
    equivalent of `shared_ptr` in C++.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In one edge case, reference counts can cause a *memory leak*, that is, accidentally
    preventing resources from ever being deleted. This happens when two objects exist
    that both contain an `Rc` pointing to each other. Because of this circular dependence,
    none of them will stop using the other and so the two objects will continue existing
    and pointing at each other long after your code has stopped using them. The solution
    here is to pick the weaker link in the hierarchy and replace its `Rc` for a `Weak`,
    which contains a *non-owning reference* instead. Because this situation is fairly
    rare, however, we are not going to look at it in detail. Instead, simply remember
    the possibility of a memory leak and come back to read this again when it arises.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rc` is inherently singlethreaded. If you need its functionality in a multithreaded
    environment (such as the one we are going to explore in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*; *Sharing resources in multithreaded closures*), you can
    use `Arc` instead. It stands for Atomically Reference Counted and behaves the
    same way as `Rc`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Sharing resources in multithreaded closures* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with interior mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Rust's borrow checker is one of its biggest selling points, alongside
    its clever error-handling concept and impressive tooling, it cannot read minds
    yet. Sometimes you might have to take things into your own hands and borrow objects
    manually. This is done with the concept of *interior mutability*, which states
    that certain types can wrap objects while being non-mutable and still operate
    on them mutably.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `bin` folder, create a file called `interior_mutability.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code and run it with `cargo test --bin interior_mutability`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The protagonist of this recipe is `RefCell`, a wrapper around any type that
    moves the borrow checker's rule enforcement from compile time to runtime. The
    basics are pretty easy, you borrow the underlying value immutably by calling `.borrow()`
    and borrow it mutably by calling `.borrow_mut()`. If you don't follow the golden
    rule of only having multiple readers or one single writer at the same time, the
    program goes into `panic!`. One application for this is making members of your
    structs mutable even though your struct itself is immutable. The best use case
    to show where this is useful is mocking, the art of faking infrastructure for
    testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of our example is as follows, we want to send a newsletter to every
    customer that is interested. For that, we have the `EmailSender` trait[1], which
    just specifies a method to send an `Email` and return a response[2]. It's good
    practice to try to define functionality through traits in order to mock them.
  prefs: []
  type: TYPE_NORMAL
- en: Our `publish_news` function [19] takes a message, an `EmailSender` and a slice
    of `Customer` (please don't imagine that literally), and sends the message to
    all customers who want to receive news. If it encounters an error, it returns
    `None`[32], otherwise, it returns the number of newsletters it sent [36].
  prefs: []
  type: TYPE_NORMAL
- en: You probably don't want to send an email to your customers every time you test
    your code, which is why we create `MockEmailSender`[49] inside the test configuration,
    which doesn't actually send anything but instead stores all mail in a `Vec` [64].
    In order to do this, it needs to modify its member despite being immutable. That's
    exactly what `RefCell` is for! Thanks to this, we can efficiently test `publish_news()`,
    as we can access all messages it would have sent and compare them with what we
    expect.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many types that use interior mutability. Among them are `Cell`, which,
    instead of handing out references, simply copies the value it stores. This is
    nice when storing primitive types such as `i32` or `bool`, as they all implement
    copy anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Others are `RwLock` and `Mutex`, which are important for parallelism, as we
    shall see in their recipes in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*; *Access resources in parallel with RwLocks*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Access resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
