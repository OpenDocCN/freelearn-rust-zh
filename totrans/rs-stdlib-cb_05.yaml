- en: Advanced Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据结构
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating lazy static objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建延迟静态对象
- en: Working with bit fields
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位字段操作
- en: Providing custom derives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供自定义derives
- en: Converting types into each other
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型之间的转换
- en: Boxing data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据装箱
- en: Sharing ownership with smart pointers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与智能指针共享所有权
- en: Working with interior mutability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理内部可变性
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have primarily looked at techniques that were all useful in their
    own right. Of course, we are continuing that trend, but the recipes shown in this
    chapter truly shine when combined with other code. You can imagine them as the
    *glue* holding a nice Rust program together, as they are primarily oriented toward
    new enabling ways in which different components of your crate can work together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注了所有都有其自身用途的技术。当然，我们正在继续这一趋势，但本章中展示的食谱在与其他代码结合使用时真正闪耀。您可以想象它们是*胶水*，将一个漂亮的Rust程序粘合在一起，因为它们主要面向新的使不同组件能够协同工作的方式。
- en: Creating lazy static objects
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建延迟静态对象
- en: Big objects, especially constant ones, should be reused instead of rebuilt.
    The `lazy_static!` macro helps you with this by extending Rust's normal `static`
    functionality, which normally requires your objects to be constructable at compile-time,
    with the ability to create lazy objects that are initialized during runtime.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大对象，尤其是常量对象，应该重用而不是重建。`lazy_static!`宏通过扩展Rust的正常`static`功能，帮助您实现这一点，正常情况下，您的对象需要在编译时构造，现在有了在运行时创建延迟对象的
    capability。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a Rust project to work on during this chapter with `cargo new chapter_five`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cargo new chapter_five`创建一个Rust项目，在本章中进行工作。
- en: Navigate into the newly created `chapter_five` folder. For the rest of this
    chapter, we will assume that your command line is currently in this directory.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`chapter_five`文件夹。在本章的剩余部分，我们将假设您的命令行当前位于此目录中。
- en: Inside the `src` folder, create a new folder called `bin`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个名为`bin`的新文件夹。
- en: Delete the generated `lib.rs` file, as we are not creating a library.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的`lib.rs`文件，因为我们没有创建库。
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为您生成的`Cargo.toml`文件。
- en: 'Under `[dependencies]`, add the following lines:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[dependencies]`下添加以下行：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you want, you can go to the crates.io web pages for `lazy_static` ([https://crates.io/crates/lazy_static](https://crates.io/crates/lazy_static))
    and regex ([https://crates.io/crates/regex](https://crates.io/crates/regex)) to
    check for the newest version and use that one instead.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以访问`lazy_static`([https://crates.io/crates/lazy_static](https://crates.io/crates/lazy_static))和正则表达式([https://crates.io/crates/regex](https://crates.io/crates/regex))的crates.io网页，检查最新版本并使用该版本。
- en: In the `src/bin` folder, create a file called `lazy_static.rs`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/bin`文件夹中，创建一个名为`lazy_static.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin lazy_static`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin lazy_static`运行它：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By invoking the `lazy_static!` macro [10, 21 and 29], we define a lazily initialized
    object in the current scope. *Lazy* here means *created only the first time it
    is used*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`lazy_static!`宏[10, 21和29]，我们在当前作用域中定义了一个延迟初始化的对象。这里的*延迟*意味着*仅在第一次使用时创建*。
- en: Contrary to a `let` binding, its scope can also be the global scope [10]. A
    realistic example for this is creating a collection with a known content that
    is used by many functions, as the alternative would be to create it once and pass
    it around endlessly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与`let`绑定不同，其作用域也可以是全局作用域[10]。一个现实生活中的例子是创建一个具有已知内容且被许多函数使用的集合，因为另一种选择是创建一次并无限传递。
- en: 'If your `lazy_static` consists of a `Vec` with content that is known at compile
    time, you can instead use a `const` array, as its construction is constant. In
    terms of code, this means you don''t need to use this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`lazy_static`包含一个在编译时已知内容的`Vec`，您可以使用一个`const`数组，因为其构造是常量的。从代码的角度来看，这意味着您不需要使用以下内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Instead, you can use the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用以下方法：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remember when, in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*; *Querying with Regexes*, we talked about how compiling
    Regexes is expensive and should be avoided? `lazy_static!` is ideal for this.
    In fact, the pattern of creating a local `static` regex in a function is so widespread
    that we included it in this example [29]:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*；*使用正则表达式查询*时，我们讨论了编译正则表达式是昂贵的，应该避免吗？`lazy_static!`
    是理想的选择。事实上，在函数中创建局部 `static` 正则表达式的模式非常普遍，以至于我们将其包含在这个例子 [29] 中：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, you can also create a global mutable state with `lazy_static` objects
    [21]. As mentioned in earlier chapters, the excessive state is the root of many
    evils in software development and should be treated with care. There are very
    few cases where having such an object is justifiable, as it is almost always better
    to pass the object around. There are exceptions, however. Sometimes a program
    revolves around the manipulation of one specific dataset in memory and all involved
    actors want to access it. In these cases, it can be very cumbersome to pass an
    object to literally every function in your code. One possible, but still very
    rare, an example where this might happen, is when dealing exclusively with a list
    of active connections [21]:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以使用 `lazy_static` 对象创建全局可变状态 [21]。如前几章所述，过多的状态是软件开发中许多问题的根源，应该谨慎处理。很少有情况可以证明拥有这样的对象是合理的，因为几乎总是更好的选择是将对象传递出去。然而，也有一些例外。有时一个程序围绕对内存中一个特定数据集的操作展开，所有涉及的参与者都希望访问它。在这些情况下，将对象传递到代码中的每个函数可能会非常繁琐。一个可能但仍然非常罕见的例子是当仅处理活动连接列表
    [21] 时：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that, as the borrow checker is disabled for objects with `'static` lifetimes
    (see the following *There's more...* section), we need to wrap our `static` in
    a parallel lock, such as `RwLock` or `Mutex`, to guarantee thread safety. You
    can read more about that in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml), *Parallelism
    and Rayon*; *Access resources in parallel with RwLocks*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于借用检查器对具有 `'static` 生命周期的对象是禁用的（参见以下 *还有更多...* 部分），我们需要将我们的 `static` 包裹在一个并行锁中，例如
    `RwLock` 或 `Mutex`，以保证线程安全。您可以在[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行与Rayon*；*使用RwLock并行访问资源*中了解更多。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: People coming from other languages might wonder what `lazy_static` offers that
    can't already be done by a normal `static` object. The difference between them
    is as follows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 来自其他语言的人可能会想知道 `lazy_static` 提供了什么，这是普通 `static` 对象无法做到的。它们之间的区别如下。
- en: In Rust, a `static` variable is a variable that lives for the entire duration
    of the program, which is why they get their own, special lifetime, `'static`.
    The catch is that the variable has to be built in a constant way, that is, a way
    that is known at compile time. In our example, we cannot replace `CURRENCIES`
    [11] with a normal `static` because `HashMap::new()` returns a newly constructed
    `HashMap` sitting somewhere in the memory during runtime. As this requires it
    to live in memory, it's impossible to build a `HashMap` during compile time, so
    its constructor is not `constant`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`static` 变量是一个在整个程序运行期间存在的变量，这就是为什么它们有自己的、特殊的生命周期 `'static'`。问题是变量必须以恒定的方式构建，即在编译时已知的方式。在我们的例子中，我们不能用正常的
    `static` 替换 `CURRENCIES` [11]，因为 `HashMap::new()` 返回一个在运行时内存中某处的新构造的 `HashMap`。由于这要求它存在于内存中，因此不可能在编译时构建
    `HashMap`，所以它的构造器不是 `constant`。
- en: Another catch with `static` variables is that, because they have a global lifetime,
    the borrow checker cannot make sure that their access is thread-safe. As a consequence,
    any access on a `static mut` variable will always be `unsafe`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 变量的另一个问题是，由于它们具有全局生命周期，借用检查器不能确保它们的访问是线程安全的。因此，对 `static mut` 变量的任何访问都将始终是
    `unsafe`。'
- en: The convention for `static` variables is to write them in `ALL_CAPS`, just like
    `const` variables. This is because they are very closely linked. In fact, a `const`
    is nothing but an inlined `static` that can never be `mut`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 变量的约定是使用全大写字母书写，就像 `const` 变量一样。这是因为它们非常紧密地相关联。事实上，`const` 仅仅是一个内联的
    `static`，它永远不会是 `mut`。'
- en: '`lazy_static` gets around these restrictions by wrapping your object in a newly
    created `struct` that can be implicitly dereferenced into your object. This means
    that you never actually access your object directly. `lazy_static` stresses this
    by demanding that you write `ref` during the declaration of the `static`, as this
    makes you mentally treat the variable as a reference rather than an actual object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy_static` 通过将你的对象包装在一个新创建的 `struct` 中来绕过这些限制，该 `struct` 可以隐式解引用到你的对象。这意味着你实际上从未直接访问过你的对象。`lazy_static`
    通过要求你在 `static` 声明期间写 `ref` 来强调这一点，因为这让你在心理上将变量视为引用而不是实际的对象：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While dereferencing, the wrapper `struct` works with a `static mut` pointer
    in your dynamically created object. All it does then is wrap the `unsafe` calls
    in a safe way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在解引用时，包装器 `struct` 使用你在动态创建的对象中的 `static mut` 指针。它所做的只是以安全的方式包装 `unsafe` 调用。
- en: If you come from a modern C++ background, you can view a normal `static` Rust
    as a `static constexpr` C++ and a `lazy_static` Rust as a `static` C++ local.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自现代C++背景，你可以将正常的Rust `static` 视为C++的 `static constexpr`，将 `lazy_static`
    Rust 视为C++的 `static` 局部。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Querying with Regexes* recipe in [Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml),
    *Learning the Basics*'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式进行查询* 在[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*中的配方'
- en: '*Access resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用RwLocks并行访问资源* 在[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行性和Rayon*中的配方'
- en: Working with bit fields
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位字段的工作方式
- en: Programs written in C don't have the possibility to use the Builder Pattern
    ([Chapter 1](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml), *Learning the Basics*;
    *Using the builder pattern*) to provide users with combinable options. Instead,
    they have to rely on bit fields. As C has historically become the *lingua franca*
    of system languages, you will have to interact with a lot of C code if you plan
    on wrapping existing programs in a Rust interface or vice versa. Because of this,
    you will sooner or later come in contact with bit fields. As Rust's `enum` is
    way more complex than a C `enum`, you have to instead rely on the `bitflags` crate
    to provide you with all of the necessary functionality to comfortably handle bit
    fields.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用C编写的程序没有使用Builder模式（[第1章](0620f24b-d897-497a-b000-d63a1426c3ff.xhtml)，*学习基础知识*；*使用builder模式*）来为用户提供可组合选项的可能性。相反，它们必须依赖于位字段。由于C在历史上已经成为系统语言的通用语言，如果你计划在Rust接口中包装现有程序或反之亦然，你将不得不与大量的C代码交互。因此，你迟早会接触到位字段。由于Rust的
    `enum` 比C的 `enum` 复杂得多，你必须依赖 `bitflags` crate 来提供你舒适地处理位字段所需的所有功能。
- en: Getting started
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'This chapter assumes that you know what a bit field is. Explaining it here
    doesn''t make sense, as it would also incorporate an explanation of binary arithmetic
    and is not that relevant in your day-to-day Rust experience. For a good introduction
    to bit fields, check out this forum post and tutorial: [http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/](http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/)
    and [https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm),
    respectively.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设你已经知道什么是位字段。在这里解释它没有意义，因为它还会涉及到二进制算术的解释，并且在你日常的Rust使用中并不那么相关。要了解位字段的好方法，请查看这篇论坛帖子以及教程：[http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/](http://forum.codecall.net/topic/56591-bit-fields-flags-tutorial-with-example/)
    和 [https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm](https://www.tutorialspoint.com/cprogramming/c_bit_fields.htm)。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open the `Cargo.toml` file that was generated earlier for you.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前为你生成的 `Cargo.toml` 文件。
- en: 'Under `[dependencies]`, add the following lines:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下，添加以下行：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you want, you can go to bitflags' crates.io page ([https://crates.io/crates/bitflags](https://crates.io/crates/bitflags))
    to check for the newest version and use that one instead.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以去bitflags的crates.io页面([https://crates.io/crates/bitflags](https://crates.io/crates/bitflags))查看最新版本，并使用那个版本。
- en: In the `bin` folder, create a file called `bit_fields.rs`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `bit_fields.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin bit_fields`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用 `cargo run --bin bit_fields` 运行它：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `bitflags!` macro lets you define all of your flags and their underlying
    type (in our case, this is `u32`)[4 to 15]. They are written in `ALL_CAPS` because
    they are constants. We can also define collections of flags this way, as we did
    with `ALL`[10]. We could have added additional combinations, for example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitflags!`宏允许您定义所有标志及其底层类型（在我们的情况下，这是`u32`)[4到15]。它们以`ALL_CAPS`的形式编写，因为它们是常量。我们也可以用这种方式定义标志集合，就像我们用`ALL`[10]做的那样。我们本可以添加更多的组合，例如：'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The macro then creates a struct with the specified members for you and implements
    a bunch of traits for it in order to enable the familiar `|`, `&`, `-`, and `!`
    notations [37 to 40] and pretty printing. You can still access the raw `bits`
    used in the background directly over the member of the same name.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏为您创建一个具有指定成员的结构，并为其实现了一组特质，以便启用熟悉的`|`、`&`、`-`和`!`表示法 [37到40]以及美化打印。您仍然可以直接通过同名成员访问在后台使用的原始`bits`。
- en: 'Note that, when printing, flag combinations will be listed separately. For
    instance, look at the output in line [47]. After setting all possible flags in
    the field to active, it will pretty print itself as the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在打印时，标志组合将被单独列出。例如，查看第[47]行的输出。在将字段中所有可能的标志设置为活动状态后，它将按以下方式进行美化打印：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A useful method to additionally define on a bit field is `clear()`[19]. This
    hides the underlying `bits` from the user and is nicely readable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在位字段上定义的一个有用的方法是`clear()`[19]。这隐藏了底层的`bits`，并且易于阅读。
- en: With the aforementioned binary operators, you can perform *set operations* on
    your bit field [37 to 40]. These are the same operations as the ones you can perform
    on a `HashSet` and are explained with a nice diagram in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml), *Working
    with Collections;* *Using a HashSet*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述二进制运算符，您可以在您的位字段上执行*集合操作* [37到40]。这些操作与您可以在`HashSet`上执行的操作相同，并在[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)中用一张漂亮的图表进行了说明，*处理集合；*
    *使用HashSet*。
- en: Working with single flags in the bit field is also very easy. `insert()` sets
    a flag in the field to active [45], `remove()` sets it to inactive [50], and `toggle`
    flips it from active to inactive and vice versa [48]. If you don't yet know whether
    you're going to `insert` or `remove` a flag, as is the case with unpredictable
    user input, you can use `set()` to explicitly set the activation of a flag to
    either `true` or `false` [55].
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在位字段中处理单个标志也非常简单。`insert()`将标志设置为活动状态 [45]，`remove()`将其设置为非活动状态 [50]，而`toggle`则将其从活动状态切换到非活动状态，反之亦然
    [48]。如果您还不知道您将要`insert`或`remove`一个标志，就像不可预测的用户输入那样，您可以使用`set()`显式地将标志的激活状态设置为`true`或`false`
    [55]。
- en: 'You can check whether a certain flag is active by calling `contains()` [56].
    This also works for another bit field or a flag combination. This means that the
    following is also valid:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`contains()` [56]来检查某个标志是否处于活动状态。这也适用于另一个位字段或标志组合。这意味着以下也是有效的：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Additionally, you can use `intersects()` to check whether *any* flags in two-bit
    fields match.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用`intersects()`来检查两个位字段中的任何标志是否匹配。
- en: Last but not least, you can deserialize raw bytes into your generated bit field
    struct by calling `from_bits()` on it [62]. This will check whether every bit
    actually corresponds to a flag and return `None` otherwise. You can skip the error
    checking and simply ignore invalid bits with `from_bits_truncate()` if you're
    absolutely 100% sure that the data has to be valid.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，您可以通过在它上面调用`from_bits()`来将原始字节反序列化到您生成的位字段结构中 [62]。这将检查每个位是否实际上对应于一个标志，如果不是，则返回`None`。如果您绝对100%确信数据必须是有效的，您可以使用`from_bits_truncate()`跳过错误检查并简单地忽略无效位。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using a HashSet* recipe in [Chapter 2](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml),
    *Working with Collections*'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](977b8621-cb73-43de-9a2b-4bc9f5583542.xhtml)中的*使用HashSet*配方，*处理集合*'
- en: Providing custom derives
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供自定义的`derive`
- en: You might have looked at `#[derive(Debug)]` and assumed it's some weird compiler
    magic. It is not. It is a so-called *procedural macro*, that is, a macro that
    doesn't simply expand at compile time but instead *runs* at compile time. This
    way, you can inject code into the actual compilation process. The most useful
    application for this is creating custom derives, with which you can generate new
    code based on the analysis of existing code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看过`#[derive(Debug)]`并假设它是某种奇怪的编译器魔法。并非如此。它是一个所谓的*过程宏*，即一个在编译时不仅扩展，而且*运行*的宏。这样，您可以在实际的编译过程中注入代码。最有用的应用是创建自定义的`derive`，通过它可以基于现有代码的分析生成新代码。
- en: Getting started
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: This recipe will operate with an *Abstract Syntax Tree*, or AST. It is a tree-like
    representation of a language's elements in relation to each other. In this recipe,
    we (that is, a cool crate called `syn`) will parse our entire program into a single
    deep `struct`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将使用一个 *抽象语法树*，或 AST。它是语言元素之间相互关系的树形表示。在这个配方中，我们（即一个名为 `syn` 的酷crate）将整个程序解析成一个单一的深层
    `struct`。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new sub-crate for the custom derive with `cargo new chapter-five-derive`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cargo new chapter-five-derive` 创建一个用于自定义 derive 的新子crate。
- en: Open the newly generated `chapter-five-derive/Cargo.toml`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的 `chapter-five-derive/Cargo.toml` 文件。
- en: 'Add this directly above the `[dependencies]` section of the file in order to
    mark the crate as a procedural macro crate:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容直接添加到文件的 `[dependencies]` 部分上方，以标记该crate为过程宏crate：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Under `[dependencies]`, add the following lines:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `[dependencies]` 下添加以下行：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you want, you can go to the crates.io web pages for `syn` ([https://crates.io/crates/syn](https://crates.io/crates/syn))
    and `quote` ([https://crates.io/crates/quote](https://crates.io/crates/quote))
    to check for the newest version and use that one instead.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你可以访问 `syn` ([https://crates.io/crates/syn](https://crates.io/crates/syn))
    和 `quote` ([https://crates.io/crates/quote](https://crates.io/crates/quote)) 的
    crates.io 网页，检查最新版本并使用那个版本。
- en: 'In the `chapter-five-derive/src/lib.rs` file, delete the generated code and
    add the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chapter-five-derive/src/lib.rs` 文件中，删除生成的代码，并添加以下内容：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the original `Cargo.toml` file of this chapter, add the following to the
    `[dependencies]`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的原始 `Cargo.toml` 文件中，在 `[dependencies]` 下添加以下内容：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 7\. In the `bin` folder, create a file called `custom_derive.rs`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 在 `bin` 文件夹中，创建一个名为 `custom_derive.rs` 的文件。
- en: '8\. Add the following code and run it with `cargo run --bin custom_derive`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 添加以下代码，并使用 `cargo run --bin custom_derive` 运行：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The instructions for this recipe are a bit more complex than the others, as
    we need to manage two separate crates. If your code doesn''t compile, compare
    your version with the one used in the book at [https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five.](https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five)
    We need to separate the code into two crates because providing a custom `derive`
    requires creating a procedural macro, as indicated by all of the instances of
    `proc_macro` in the code. A procedural macro is Rust code that runs alongside
    the compiler and interacts directly with it. Because of the special nature and
    unique restrictions of such code, it needs to be in a separate crate that is annotated
    with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的说明比其他配方复杂一些，因为我们需要管理两个独立的crate。如果你的代码无法编译，请将你的版本与书中使用的版本进行比较，网址为 [https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five.](https://github.com/SirRade/rust-standard-library-cookbook/tree/master/chapter_five)。我们需要将代码分成两个crate，因为提供自定义
    `derive` 需要创建一个过程宏，正如代码中所有的 `proc_macro` 实例所示。过程宏是运行在编译器旁边并与它直接交互的Rust代码。由于这种代码的特殊性质和独特的限制，它需要在一个单独的crate中，该crate带有以下注释：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This crate is typically named after the main crate with the `_derive` suffix
    added. In our example, the main crate is called `chapter_five`, so the crate providing
    the procedural macro is called `chapter_five_derive`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个crate通常以主crate的名称命名，并在后面添加 `_derive` 后缀。在我们的例子中，主crate名为 `chapter_five`，所以提供过程宏的crate称为
    `chapter_five_derive`。
- en: 'In our example, we are going to create a derived version of good, old Hello
    World: a `struct` or `enum` deriving from `HelloWorld` will implement the `HelloWorld`
    trait, providing a `hello_world()` function with a friendly greeting containing
    its own name. Additionally, you can specify a `HelloWorldName` attribute to alter
    the message.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将创建一个派生版本的经典的 Hello World：一个从 `HelloWorld` 派生的 `struct` 或 `enum` 将实现
    `HelloWorld` trait，提供一个包含其自身名称的友好问候的 `hello_world()` 函数。此外，你可以指定一个 `HelloWorldName`
    属性来改变消息。
- en: The code in `custom.rs` should be self-explanatory. We begin by importing our
    derivation crate [2] where we need to include the `#[macro_use]` attribute in
    order to actually import the procedural macros. We then define our `HelloWorld`
    trait [5] and proceed to derive it on a bunch of structures [13, 16 and 19], just
    like we would with built-in derives such as `Debug` or `Clone`. `Australia` gets
    a custom message via the `HelloWorldName` attribute. Lastly, in the `main` function,
    we call the generated `hello_world()` function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`custom.rs` 中的代码应该是自解释的。我们首先导入我们需要包含 `#[macro_use]` 属性以实际导入过程宏的派生 `crate`。然后我们定义我们的
    `HelloWorld` 特征 [5]，并在多个结构体 [13、16 和 19] 上派生它，就像我们使用内置的派生如 `Debug` 或 `Clone` 一样。`Australia`
    通过 `HelloWorldName` 属性获得自定义消息。最后，在 `main` 函数中，我们调用生成的 `hello_world()` 函数。'
- en: Let's take a look at `chapter-five-derive/src/lib.rs` now. Procedural macro
    crates typically begin by importing the `proc_macro`, `quote`, and `syn` crates.
    Attentive readers will have noticed that we didn't add the `proc_macro` to our
    `[dependencies]` section in the crate's `Cargo.toml`. We didn't need to because
    this special support crate is provided by the standard Rust distribution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `chapter-five-derive/src/lib.rs`。过程宏 `crate` 通常首先导入 `proc_macro`、`quote`
    和 `syn` `crate`。细心的读者会注意到我们没有在我们的 `crate` 的 `Cargo.toml` 中的 `[dependencies]` 部分添加
    `proc_macro`。我们不需要这样做，因为这个特殊支持 `crate` 是由标准 Rust 分发提供的。
- en: 'The `quote` crate provides the `quote!` macro, which lets us translate Rust
    code into tokens that the compiler can use. The really useful feature of this
    macro is that it supports code interpolation of a variable by writing a `#` in
    front of it. This means that when we write the following, the value inside the `struct_name` variable is
    interpreted as Rust code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote` `crate` 提供了 `quote!` 宏，它允许我们将 Rust 代码转换为编译器可以使用的令牌。这个宏真正有用的特性是它支持通过在变量前写一个
    `#` 来进行代码插值。这意味着当我们写下以下内容时，`struct_name` 变量内的值被解释为 Rust 代码：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If `struct_name` has the `Switzerland` value, the following code will be generated:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `struct_name` 有 `Switzerland` 的值，以下代码将被生成：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `syn` crate is a Rust parser built upon the `nom` parser combinator framework ([https://github.com/Geal/nom](https://github.com/Geal/nom)),
    which you should check out as well if you're thinking about writing a parser.
    In fact, some of the crates used in [Chapter 4](c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml),
    *Serialization*, are written with `nom`, too. Back on track, `syn` parses the
    code annotated by your custom attributes or derives and lets you work with the
    generated abstract syntax tree.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`syn` crate 是一个基于 `nom` 解析器组合框架（[https://github.com/Geal/nom](https://github.com/Geal/nom)）构建的
    Rust 解析器，如果你在考虑编写一个解析器，也应该查看一下。实际上，[第 4 章](c9c593dc-fc0e-4305-b819-4b112cb98684.xhtml)
    中使用的某些 `crate` 也用 `nom` 编写。回到正题，`syn` 解析由你的自定义属性或 `derives` 注释的代码，并允许你使用生成的抽象语法树进行工作。'
- en: The convention for a custom derive is to create a function with the name of
    the derive in `snake_case` (`pub fn hello_world`, in our case) that parses the
    annotated code and then calls a function that generates the new code. The second
    function typically has the name of the first one, prefixed with `impl`. In our
    code, this is `fn impl_hello_world`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义派生的惯例是创建一个以派生名称命名的函数（在我们的例子中是 `pub fn hello_world`），该函数解析注释的代码，然后调用一个生成新代码的函数。第二个函数通常具有第一个函数的名称，前面加上
    `impl`。在我们的代码中，这是 `fn impl_hello_world`。
- en: In a `proc_macro` crate, only functions tagged with `proc_macro_derive` are
    allowed to be published. The consequence of this is, by the way, that we are not
    able to move our `HelloWorld` trait into this crate; it wouldn't be allowed to
    be `pub`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 `proc_macro` `crate` 中，只有标记为 `proc_macro_derive` 的函数才允许发布。顺便说一句，这个后果是我们无法将我们的
    `HelloWorld` 特征移动到这个 `crate` 中；它不允许是 `pub`。
- en: 'The `proc_macro_derive` annotation requires you to specify which name will
    be used for the derive (`HelloWorld` for us) and which attributes it allows. If
    we didn''t want to accept the `HelloWorldName` attribute, we could simply omit
    the entire attributes section and annotate our function like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc_macro_derive` 注解要求你指定用于派生的名称（对我们来说是 `HelloWorld`）以及它允许的属性。如果我们不想接受 `HelloWorldName`
    属性，我们可以简单地省略整个属性部分，并像这样注释我们的函数：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because `hello_world` hooks itself directly into the compiler, it both accepts
    and returns a `TokenStream`, which is the compiler-internal representation of
    Rust code. We start by turning the `TokenStream` back into a `String` in order
    to be parsed again by `syn`. This is not an expensive action, as the `TokenStream`
    we receive from the compiler is not the entire program, but only the part annotated
    by our custom derive. For example, the `String` behind the `TokenStream` of the
    first `struct` annotated by `HelloWorld` is simply the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`hello_world`直接钩入编译器，它既接受也返回一个`TokenStream`，这是Rust代码的编译器内部表示。我们首先将`TokenStream`转换回`String`，以便再次由`syn`解析。这不是一个昂贵的操作，因为我们从编译器接收到的`TokenStream`不是整个程序，而只是我们自定义推导注解的部分。例如，第一个由`HelloWorld`注解的`struct`的`TokenStream`后面的`String`仅仅是以下内容：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We then parse the said string with `syn::parse_derive_input(&s)`, which basically
    tells `syn` that the code we want to parse is a `struct` or `enum` that is deriving
    something.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`syn::parse_derive_input(&s)`解析该字符串，这基本上告诉`syn`我们想要解析的代码是一个派生某些内容的`struct`或`enum`。
- en: 'We then generate the code with the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用以下方式生成代码：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we convert it back into a `TokenStream` with this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用以下方式将其转换回`TokenStream`：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `TokenStream` is then injected back into the code by the compiler. As you
    can see, a procedural macro cannot change existing code, but only analyze it and
    generate additional code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`TokenStream`被编译器注入回代码中。正如你所见，过程宏不能更改现有代码，而只能分析它并生成额外的代码。
- en: 'Here is the process described in `hello_world`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`hello_world`中描述的过程：
- en: Convert the `TokenStream` into a `String`
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TokenStream`转换为`String`
- en: Parse the `String` with `syn`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`syn`解析`String`
- en: Generate an implementation of another method
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成另一个方法的实现
- en: Parse the implementation back into a `TokenStream`
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现解析回`TokenStream`
- en: It is very typical for a custom derive. You can reuse the code presented in
    nearly all basic procedural macros.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义推导来说，这是一个非常典型的例子。你可以在几乎所有基本过程宏中重用所展示的代码。
- en: Let's move on to `impl_hello_world` now. With the help of the `ast` passed,
    we can analyze the annotated structure. The `ident` member, which stands for *identifier*,
    tells us the name of the `struct` or `enum`. For instance, in the first struct
    that derives from `HelloWorld`, this is the `"Switzerland"` string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到`impl_hello_world`。借助传递的`ast`，我们可以分析注解的结构。`ident`成员，代表*标识符*，告诉我们`struct`或`enum`的名称。例如，在从`HelloWorld`派生的第一个`struct`中，这就是`"Switzerland"`字符串。
- en: We then decide which name to use in the greeting with the help of the `get_name_attribute` little
    helper function, which we will look at in a moment. It returns the value of the
    `HelloWorldName` attribute if it has been set. If not, we default to the `identifier`,
    converted to a string via `as_ref`[29]. How this is done is explained in the next
    recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们借助`get_name_attribute`这个小助手函数来决定在问候语中使用哪个名称，我们稍后会看到它。如果设置了`HelloWorldName`属性，它将返回该属性的值。如果没有设置，我们默认使用通过`as_ref`[29]转换的`identifier`。如何做到这一点将在下一个菜谱中解释。
- en: 'Finally, we create some `quote::Tokens` by writing the implementation and surrounding
    it with `quote!`. Notice again how we interpolate variables into the code by writing
    `#` in front of it. Additionally, while printing, we surround `#identifier` with
    `stringify!`, which turns an identifier into a string. We don''t need to do this
    with `#hello_world_identifier` because it already holds a string. To understand
    why this is needed, let''s look at the code that would be generated for the `Switzerland`
    struct if we *didn''t* include `stringify!`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过编写实现并用`quote!`包围它来创建一些`quote::Tokens`。再次注意，我们如何通过在变量前写`#`来将变量内插到代码中。此外，在打印时，我们用`stringify!`包围`#identifier`，将标识符转换为字符串。对于`#hello_world_identifier`，我们不需要这样做，因为它已经包含了一个字符串。为了理解为什么需要这样做，让我们看看如果我们没有包含`stringify!`，将为`Switzerland`结构生成的代码：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Try it out for yourself, and you will be greeted with an error message stating
    that something along the lines of ``"`Switzerland` cannot be formatted with the
    default formatter"``. This is because we are not printing the `"Switzerland"` string,
    but instead trying to print the concept of the `Switzerland` struct itself, which
    is clearly nonsense. To fix this, we just need to make sure that the interpolated
    variable is surrounded by quotes (`"`), which is exactly what `stringify!` does.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己操作一下，你会看到一个错误信息，内容大致是“`Switzerland`无法使用默认格式化器格式化”。这是因为我们并没有打印`"Switzerland"`这个字符串，而是在尝试打印`Switzerland`结构体的概念本身，这显然是没有意义的。要解决这个问题，我们只需要确保插值变量被引号包围（`"`），这正是`stringify!`所做的事情。
- en: 'Let''s look at the final piece of the puzzle now: `get_name_attribute`. This
    function might look a little intimidating at first. Let''s go through it step
    by step:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看拼图的最后一部分：`get_name_attribute`。这个函数一开始可能会有些令人畏惧。让我们一步一步地来看：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here we''ll go through all available attributes and search for one named `"HelloWorldName"`.
    If we don''t find any, the function call already ends by returning `None`. Otherwise,
    we continue with the following line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将遍历所有可用的属性并搜索一个名为`"HelloWorldName"`的属性。如果我们找不到，函数调用已经结束，通过返回`None`来结束。否则，我们继续执行下一行：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`syn::MetaItem` is simply how `syn` calls attributes. This line is necessary
    because there are many ways to write attributes in Rust. For example, a `syn::MetaItem::Word`
    can be written like `#[foo]`. An example for `syn::MetaItem::List` is `#[foo(Bar,
    Baz, Quux)]`. `#[derive(...)]` itself also a `syn::MetaItem::List`. We, however,
    are only interested in `syn::MetaItem::NameValue`, which is an attribute in the
    form of `#[foo = Bar]`. If the `HelloWorldName` attribute is not in this form,
    we `panic!` with a message explaining what the problem is. A `panic` in procedural
    macro results in a compiler error. You can verify this by replacing `#[HelloWorldName
    = "the Land Down Under"` in `custom.rs` with `#[HelloWorldName]`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`syn::MetaItem`是`syn`如何调用属性的简单方式。这一行是必要的，因为Rust中编写属性的方式有很多。例如，`syn::MetaItem::Word`可以写成`#[foo]`。`syn::MetaItem::List`的一个例子是`#[foo(Bar,
    Baz, Quux)]`。`#[derive(...)]`本身也是一个`syn::MetaItem::List`。然而，我们只对`syn::MetaItem::NameValue`感兴趣，它是一种形式为`#[foo
    = Bar]`的属性。如果`HelloWorldName`属性不是这种形式，我们会`panic!`并显示一条解释问题的消息。过程宏中的`panic`会导致编译器错误。你可以通过将`custom.rs`中的`#[HelloWorldName
    = "the Land Down Under"]`替换为`#[HelloWorldName]`来验证这一点。'
- en: Contrary to normal programs, because of procedural macros `panic!` at compile
    time, it's okay for them to `panic!` often. When doing so, remember that errors
    originating from other crates are very nasty to debug, doubly so in any kind of
    macros, so it's incredibly important to write the error messages as explicitly
    as possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规程序不同，由于过程宏在编译时使用`panic!`，它们经常`panic!`是可以接受的。在这样做的时候，记住来自其他crate的错误非常难以调试，尤其是在任何类型的宏中，因此尽可能明确地编写错误信息非常重要。
- en: 'The last check we need to do is on the value of `HelloWorldName`. As we are
    going to print it, we want to accept only strings:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要检查的是`HelloWorldName`的值。由于我们打算打印它，我们只想接受字符串：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On success, we return the string. Otherwise, we again `panic!` with an error
    message detailing the problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，我们返回字符串。否则，我们再次`panic!`并显示一个详细说明问题的错误信息。
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you ran into trouble while running this recipe, you can use David Tolney's
    `cargo-expand` ([https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand))
    to show you how the compiler expanded your `proc_macros`. It's a really useful
    tool to debug your macros, so be sure to check it out.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个配方时遇到了麻烦，可以使用David Tolney的`cargo-expand`（[https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand)）来展示编译器是如何展开你的`proc_macros`的。这是一个非常有用的调试宏的工具，所以请务必查看。
- en: The reason behind the two-crate restriction is historical and only temporary.
    In the beginning, there was only one way to define macros, `macro_rules!`. People
    with exotic needs, who were ready to put in the effort, were (and still are) able
    to extend their programs by directly hooking into the Rust compiler itself. Crates
    written this way are called *compiler plugins*. Of course, this is incredibly
    unstable because every minor Rust release can break your plugin, but people kept
    on doing it because it gave them one big advantage, custom derives. The core team
    reacted to the increased demand for language extensibility by deciding to launch
    `macros2.0` at some point in the future, bringing an overhaul to the entire macro
    system and many additional features, such as namespacing macros.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 两种crate限制背后的原因是历史性的，只是暂时的。最初，只有一种定义宏的方法，即`macro_rules!`。那些有特殊需求并愿意付出努力的人（现在仍然如此）能够通过直接挂钩Rust编译器本身来扩展他们的程序。以这种方式编写的crate被称为*编译器插件*。当然，这是极其不稳定的，因为每个Rust的小版本发布都可能破坏你的插件，但人们仍然继续这样做，因为它给了他们一个很大的优势，即自定义派生。核心团队为了应对对语言扩展性的增加需求，决定在未来某个时候推出`macros2.0`，对整个宏系统进行彻底的改革，并添加了许多额外的功能，例如命名空间宏。
- en: 'As they saw that most of the plugins were used only for custom derives, they
    also decided to bridge the time until `macros2.0` with `macros1.1`, which are
    also called *procedural macros*. Stabilizing the small subset of the compiler
    that is needed to create custom derives. The only problem was that crates now
    had parts that ran normally and parts that ran at compile time instead. Mixing
    them proved difficult to implement and a bit chaotic, so the two-crate system
    of moving all procedural macro code into a `-derive` crate was created. This is
    the system used in this recipe, as at the time of writing, `macros2.0` has not
    been stabilized yet. I encourage you to take a look at the current progress: [https://github.com/rust-lang/rust/issues/39412](https://github.com/rust-lang/rust/issues/39412).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于他们看到大多数插件都只用于自定义派生，他们也决定通过`macros1.1`（也称为*过程宏*）来连接`macros2.0`发布前的这段时间。稳定了创建自定义派生所需的小部分编译器。唯一的问题是，crate现在有正常运行的部分和在编译时运行的部分。混合它们在实现上很困难，而且有点混乱，因此创建了将所有过程宏代码移动到`-derive`
    crate的两种crate系统。这是本食谱中使用的系统，因为在编写本食谱时，`macros2.0`尚未稳定。我鼓励你查看当前的进展：[https://github.com/rust-lang/rust/issues/39412](https://github.com/rust-lang/rust/issues/39412)。
- en: If by the time you read this book, `macros2.0` has been released, you should
    update your knowledge about how to write modern custom derives.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你阅读这本书的时候，`macros2.0`已经发布，你应该更新你对如何编写现代自定义派生的知识。
- en: Converting types into each other
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类型转换为彼此
- en: Having dedicated types is great, but true flexibility can only come when these
    types can easily be converted from and into each other. Luckily, Rust provides
    this functionality quite literally through the `From` and `Into` traits, along
    with some friends.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有专用类型是很好的，但真正的灵活性只能在这些类型可以轻松相互转换时出现。幸运的是，Rust通过`From`和`Into`特性以及一些相关特性，非常直接地提供了这种功能。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the `bin` folder, create a file called `conversion.rs`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`conversion.rs`的文件。
- en: 'Add the following code and run it with `cargo run --bin conversion`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo run --bin conversion`运行它：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The most important trait for conversion is `From`. Implementing it means defining
    how to obtain a type *from* another.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 转换类型之间最重要的特性是`From`。实现它意味着定义如何从另一个类型中获取类型。
- en: 'We present this on the example of `DoubleVec`[6]. Its concept is simple, when
    you construct it out of a `Vec`, it doubles all its elements. For this purpose,
    we implement `From<Vec<T>>` [11] with a `where` clause specifying `T: MulAssign<i32>`[13],
    which means that the trait will be implemented for all types that can be assigned
    to the result of a multiplication with an integer. Or, in terms of code, all types
    that allow the following, assuming the `t` variable is of the `T` type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '我们以`DoubleVec`[6]为例来介绍这个概念。它的概念很简单，当你从`Vec`构造它时，它会将其所有元素翻倍。为此，我们实现了`From<Vec<T>>`
    [11]，并使用一个`where`子句指定`T: MulAssign<i32>`[13]，这意味着该特性将为所有可以赋值给整数乘法结果的类型实现。或者，用代码来说，所有允许以下操作的类型：'
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The actual implementation should be self-explanatory, we simply multiply every
    element in the vector by two and wrap it in our `DoubleVec`[19]. Afterwards, we
    implement `From` as well for slices of the same type [25].
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实际实现应该是自解释的，我们只是将向量中的每个元素乘以二，并将其包裹在我们的`DoubleVec`[19]中。之后，我们也为相同类型的切片实现了`From`[25]。
- en: It is considered good practice to extend all of your trait definitions that
    work with vectors ( `Vec<T>` ) to also work with slices (`&[T]`). This way, you
    gain generality and performance, as you can operate on direct references to arrays
    (such as `&[1, 2, 3]`) and ranges of other vectors (`vec[1..3]`) without converting
    them first. This best practice carries over to functions as well, where you should
    always accept a slice of your type (as shown with `print_elements()`), if possible,
    for the same reasons.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到良好的实践，将所有与向量（`Vec<T>`）一起工作的特性定义扩展到也适用于切片（`&[T]`）是很有用的。这样，你就能获得通用性和性能，因为你可以直接操作数组的引用（如`&[1,
    2, 3]`）和其他向量的范围（如`vec[1..3]`），而不需要先进行转换。这个最佳实践也适用于函数，你应该始终尽可能接受你类型的切片（如`print_elements()`所示），出于同样的原因。
- en: 'In this implementation, however, we see something interesting:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个实现中，我们看到了一些有趣的东西：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`slice.to_vec()` simply converts the slice into a vector. But what''s up with
    `.into()`? Well, it comes from the `Into` trait, which is the opposite of the
    `From` trait, it converts a type *into* another. But how does a `Vec` know how
    to turn into a `DoubleVec`?'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice.to_vec()`简单地将切片转换成向量。但`.into()`是什么意思呢？嗯，它来自`Into`特性，它是`From`特性的对立面，它将一个类型*转换*成另一个类型。但`Vec`是如何知道如何转换成`DoubleVec`的呢？'
- en: 'Let''s take a look at the standard library''s implementation of `Into` at [https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs](https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs),
    where we find the following lines:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看标准库中`Into`的实现，可以在[https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs](https://github.com/rust-lang/rust/blob/master/src/libcore/convert.rs)找到，其中我们发现以下行：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Aha! According to this, every `T` type that implements `From` for `U` automatically
    lets `U` implement `Into` for `T`. And sure enough because we implemented `From<Vec<T>
    for DoubleVec<T>`, we automatically also implemented `Into<DoubleVec<T>> for Vec<T>`.
    Let''s look at our code from before again:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！根据这个，每个实现`From`接口的`T`类型都会自动让`U`实现`Into`接口的`T`。确实如此，因为我们实现了`From<Vec<T> for
    DoubleVec<T>>`，所以我们自动也实现了`Into<DoubleVec<T>> for Vec<T>`。让我们再次看看之前的代码：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The slice gets turned into a `Vec`, which implements `Into` for `DoubleVec`,
    among many others. Because our function signature says that we return `Self`,
    Rust knows which `Into` implementation to use, as only one of them returns `DoubleVec`
    as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个切片被转换成了一个`Vec`，它实现了`Into`接口，用于`DoubleVec`以及其他许多类型。因为我们的函数签名表明我们返回`Self`，Rust知道应该使用哪个`Into`实现，因为只有其中一个返回`DoubleVec`。
- en: 'Another useful trait for type conversion is `AsRef`. Its only function, `as_ref`,
    is nearly identical to `into`, but instead of moving itself into another type,
    it takes a reference to itself and returns a reference to another type. In a way,
    it *translates* references. You can expect this operation to be cheap in most
    cases, as it typically just returns a reference to an internal object. In fact,
    you have already used this method in the last recipe:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对类型转换有用的特性是`AsRef`。它的唯一函数`as_ref`几乎与`into`相同，但它不是将自身移动到另一个类型，而是取自身的引用并返回另一个类型的引用。从某种意义上说，它*转换*引用。你可以预期在大多数情况下这个操作都很便宜，因为它通常只是返回一个内部对象的引用。实际上，你已经在上一个菜谱中使用了这个方法：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`identifier` internally holds a `String` of its name. The compiler knows that
    `hello_world_name` has to be a `&str`, as the return type of `get_name_attribute(ast)`
    is `Option<&str>` and we are trying to unwrap it with a default value. Based on
    this information, `as_ref()` tries to return a `&str`, which it can, as the only
    implementation of `AsRef` for `identifier` that returns a `&str` is the one that
    returns a reference to the aforementioned `String` that holds its name.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`identifier`内部持有其名称的`String`。编译器知道`hello_world_name`必须是`&str`，因为`get_name_attribute(ast)`的返回类型是`Option<&str>`，我们正在尝试使用默认值解包它。基于这些信息，`as_ref()`试图返回一个`&str`，它可以做到，因为`identifier`唯一返回`&str`的`AsRef`实现是返回上述包含其名称的`String`的引用。'
- en: We are only implementing `AsRef` for `Vec`, and not for a slice, because of
    a reference to a vector (`&Vec<T>`) with automatically deref-coerce into a slice 
    (`&[T]`), which means we automatically implement it. You can read more about the
    concept of deref coercion at [https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods](https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为 `Vec` 实现 `AsRef`，而不是切片，因为有一个指向向量的引用 (`&Vec<T>`) 可以自动解引用强制转换为切片 (`&[T]`)，这意味着我们自动实现了它。你可以在
    [https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods](https://doc.rust-lang.org/book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods)
    中了解更多关于解引用强制转换的概念。
- en: '`AsRef` also has a brother called `AsMut`, which is identical but operates
    on mutable references. We intentionally didn''t implement it in this example,
    as we don''t want users messing with the internal state of `DoubleVec`. In general,
    you should be very conservative with this trait as well, as excessive access to
    the internals of anything can quickly become very chaotic.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsRef` 还有一个兄弟叫做 `AsMut`，它与前者相同，但操作的是可变引用。我们故意没有在这个示例中实现它，因为我们不希望用户去干扰 `DoubleVec`
    的内部状态。一般来说，你也应该非常谨慎地使用这个特性，因为过度访问任何事物的内部可能会迅速变得非常混乱。'
- en: The `main` function contains some examples of converting types. A popular example
    is the conversion from `&str` to `String` in lines [46 to 48]. Interestingly,
    `&str` can also be converted into a vector of its underlying bytes [52 and 53].
    Let's look at how our `DoubleVec` can be converted in the same way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数包含了一些类型转换的例子。一个流行的例子是第 46 到 48 行的从 `&str` 转换到 `String`。有趣的是，`&str`
    也可以转换为其底层字节的向量 [52 和 53]。让我们看看我们的 `DoubleVec` 如何以同样的方式转换。'
- en: 'The next line showcases how the `&Vec<i32>` returned by `double_vec.as_ref()`
    seamlessly behaves like an `&[i32]`, as `print_elements()` only accepts slices
    [67]:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行展示了 `double_vec.as_ref()` 返回的 `&Vec<i32>` 如何无缝地表现得像 `[i32]`，因为 `print_elements()`
    只接受切片 [67]：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last part of the recipe is about API design. There is a little implementation
    of `From` in the standard library that reads:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 配方的最后一部分是关于 API 设计。标准库中 `From` 的小实现如下：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This means that every type can be converted into an `Option`. You can use this
    trick, as showcased in the implementation of `ergonomic_public_func` [100], to
    make functions with multiple parameters of the `Option` type easier to use and
    look at, as you can see by comparing the following two function calls [71 and
    72]:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个类型都可以转换为 `Option`。你可以使用这个技巧，如 `ergonomic_public_func` [100] 的实现所示，使具有多个
    `Option` 类型参数的函数更容易使用和查看，正如你可以通过比较以下两个函数调用 [71 和 72] 所见：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, because some extra typing is required to achieve this, it's okay if
    you only do this on functions that are part of your API, that is, available to
    users of your crate. If you want to read some more tips about clean API design
    in Rust, check out Rust core developer Pascal Hertleif's excellent blog entry:  [https://deterministic.space/elegant-apis-in-rust.html.](https://deterministic.space/elegant-apis-in-rust.html)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于需要一些额外的类型来达到这个目的，如果你只在你 API 中的函数上这样做，也就是对 crate 的用户可用，那就没问题。如果你想了解更多关于
    Rust 中干净 API 设计的技巧，请查看 Rust 核心开发者 Pascal Hertleif 的优秀博客文章：[https://deterministic.space/elegant-apis-in-rust.html](https://deterministic.space/elegant-apis-in-rust.html)
- en: Boxing data
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装数据
- en: The first smart pointer we are going to look at is the `Box`. This very special
    type is the analogue to C++'s `unique_ptr`, a pointer to data stored on the heap
    that deletes said data automatically when it's out of scope. Because of the shift
    from stack to heap, `Box` can allow you some flexibility by intentionally losing
    type information.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个智能指针是 `Box`。这个非常特殊的数据类型是 C++ 中 `unique_ptr` 的类似物，它指向存储在堆上的数据，当它超出作用域时自动删除该数据。由于从栈到堆的转变，`Box`
    可以通过故意丢失类型信息来提供一些灵活性。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the `bin` folder, create a file called `boxing.rs`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `boxing.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin boxing`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并用 `cargo run --bin boxing` 运行它：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing that we are going to explore are recursive types, that is,
    a type that contains itself. This cannot be done directly, as the compiler needs
    to know in advance how much space a type requires. Consider the following `struct`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一件事是递归类型，即包含自身的类型。这不能直接完成，因为编译器需要提前知道一个类型需要多少空间。考虑以下 `struct`：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The compiler will ask itself, `How much space does it take to create a Foo?` and
    see that it needs just enough space to hold an `i32`. And how much does an `i32`
    need? Exactly 32 bits. Now, consider the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自问：“创建一个Foo需要多少空间？”并发现它只需要足够的空间来存放一个`i32`。而一个`i32`需要多少空间？正好是32位。现在，考虑以下情况：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'How much space does `Foo` need? Enough to hold an `i32` and a `Foo`. How much
    is an `i32`? 32 bits. And `Foo`? Enough to hold an `i32` and a `Foo`. And how
    much does that `Foo` take? Enough for a `Foo`, and so on, until the heat death
    of the universe. Clearly, we don''t want to spend that long on compiling. Let''s
    take a look at the solution to our problem:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Foo需要多少空间？足够存放一个`i32`和一个Foo。一个`i32`需要多少空间？32位。Foo需要多少空间？足够存放一个`i32`和一个Foo。而这个Foo需要多少空间？足够存放一个Foo，以此类推，直到宇宙的热寂。显然，我们不想在编译上花费那么长时间。让我们看看我们问题的解决方案：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: One last time, how big is `Foo`? Enough to hold an `i32` and a `Foo`. How big
    is an `i32`? 32 bits. How big is a `Box<Foo>`? Just as big as a box of any other
    type, namely 64 bit. Every `Box` will always have the same size, as they are all
    the same thing, a pointer to some type in the heap. This way, we resolved our
    problem, as the compiler now knows the exact size of the type at compile time
    and is happy. And because it is happy, we are happy.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再说一次，Foo有多大？足够存放一个`i32`和一个Foo。`i32`有多大？32位。`Box<Foo>`有多大？和其他类型的盒子一样大，即64位。每个`Box`都将始终具有相同的大小，因为它们都是同一件事，即指向堆中某个类型的指针。这样，我们就解决了问题，因为编译器现在在编译时知道类型的确切大小，并且很高兴。而且因为它很高兴，所以我们也很高兴。
- en: 'In our code example, we illustrate one possible use case for a recursive type,
    a naive binary tree implementation [9]. In case you didn''t know, a binary tree
    consists of a clump of data, which is called a *node*, that can be connected to
    either zero or two other *child nodes*. A node that is connected to zero nodes
    is a *leaf*. In our example, we build such a tree that will look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们展示了递归类型的一个可能的使用案例，一个简单的二叉树实现[9]。如果你不知道，二叉树由一个称为*节点*的数据簇组成，它可以连接到零个或两个其他*子节点*。连接到零个节点的节点是一个*叶节点*。在我们的例子中，我们构建了一个看起来像这样的树：
- en: '![](img/b80fc206-db6d-4c14-8575-7a18fc1ce149.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b80fc206-db6d-4c14-8575-7a18fc1ce149.png)'
- en: We implement it as a `struct Node` that contains any data and optionally a pair
    of `BoxedNode`, which is just an alias for `Box<Node>`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其实现为一个包含任何数据以及可选的一对`BoxedNode`的`struct Node`，其中`BoxedNode`只是`Box<Node>`的别名。
- en: A real binary tree implementation that is optimized for speed will be a little
    bit more complex than our example. While the concept of recursion fits very nicely
    into a binary tree, it is rather inefficient to store every node separately somewhere
    in the heap. Real implementations will instead just appear to be recursive for
    the user but internally store the nodes in a `Vec<Node>`. This way, the nodes
    profit from speed gains by simply being allocated in a continuous memory block,
    as this will optimize caching. Rust's `BTreeMap` and `BTreeSet` follow this concept
    as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个针对速度优化的真实二叉树实现将比我们的示例稍微复杂一些。虽然递归的概念非常适合二叉树，但将每个节点单独存储在堆中的某个地方是非常低效的。真正的实现将只对用户表现出递归，但内部将节点存储在`Vec<Node>`中。这样，节点通过在连续的内存块中分配来获得速度上的提升，这将优化缓存。Rust的`BTreeMap`和`BTreeSet`也遵循这个概念。
- en: 'A binary tree is an excellent kind of data structure for data traversal. You
    can read about some of its biggest use cases at the following StackOverflow answer
    by Danny Pflughoeft: [https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588](https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是一种非常适合数据遍历的数据结构。你可以在以下StackOverflow答案中了解一些它的最大用途，由Danny Pflughoeft提供：[https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588](https://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees#2200588)。
- en: 'The next thing that a `Box` enables us to do is classic polymorphism how you
    will recognize it from other languages. For this, we prepare a trait called `Animal`
    [37] that has a method to produce a `sound()`. Its implementor, `Dog` [42], will
    produce `"Woof!"`[45] and the `Cat` [50] implementor will produce `"Meow!"` [53].
    Our goal is to store both a `Dog` and a `Cat` in a `Vec` of `Animal`. We can do
    this by creating a so-called *trait object*. It is created by a `Box` of a trait,
    like in our example in the following line:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box` 允许我们做的下一件事是经典的泛型，就像你在其他语言中会认识的那样。为此，我们准备了一个名为 `Animal` [37] 的特征，它有一个用于产生
    `sound()` 方法的特征。它的实现者 `Dog` [42] 将产生 `"Woof!"`[45]，而 `Cat` [50] 的实现者将产生 `"Meow!"`
    [53]。我们的目标是存储一个 `Dog` 和一个 `Cat` 在一个 `Vec` 的 `Animal` 中。我们可以通过创建一个所谓的 *特征对象* 来做到这一点。它是由一个特征的
    `Box` 创建的，就像在下面的例子中一样：'
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This way, we intentionally erase type information from the actual type in the
    `Box`. The compiler no longer knows which type is in the `Box`, only that it implements
    `Animal`, which is all that it needs to know. As you can see by running the code,
    the Rust runtime will still execute the correct functions and give the `Dog` and
    the `Cat` different sounds.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们故意从 `Box` 中的实际类型中删除类型信息。编译器不再知道 `Box` 中是什么类型，只知道它实现了 `Animal`，这正是它需要知道的所有信息。正如你通过运行代码所看到的，Rust
    运行时仍然会执行正确的函数，并为 `Dog` 和 `Cat` 产生不同的声音。
- en: 'With the same mechanism, we can return a trait object of `Iterator`[90]:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的机制，我们可以返回一个 `Iterator`[90] 的特征对象：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, we can mix and match iterators inside `caps_words_iter()` without
    caring for the exact return type, so long as it implements `Iterator`, which they
    all do. Remember that we can't just return `Iterator` directly without any `Box`
    around it, as we cannot return a trait. A trait object, however, is completely
    fine.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以在 `caps_words_iter()` 内混合和匹配迭代器，而不必关心确切的返回类型，只要它实现了 `Iterator`，它们都做到了。记住，我们不能直接返回
    `Iterator`，没有任何 `Box` 包围它，因为我们不能返回一个特征。然而，特征对象是完全可行的。
- en: 'On we go to `read_file_as_number()`[96]. This method reads a file and returns
    the content parsed as an `i32`. This file will not be generated for you, so you
    will have to either download it from our GitHub repo or manually create a file
    called `number.txt` that contains a number, say `777`. From the signature, you
    can gather that this time we are boxing the `Error`. This lets us mix the error
    type returned. Indeed, this method does return two different kinds of errors:
    `std::io::Error` and `std::num::ParseIntError`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看 `read_file_as_number()`[96]。这个方法读取一个文件，并返回解析为 `i32` 的内容。这个文件不会为你生成，所以你必须从我们的
    GitHub 仓库下载它，或者手动创建一个名为 `number.txt` 的文件，其中包含一个数字，比如 `777`。从签名中，你可以看出这次我们正在装箱
    `Error`。这让我们可以混合返回的错误类型。确实，这个方法返回两种不同的错误：`std::io::Error` 和 `std::num::ParseIntError`。
- en: The last thing that we are going to look at is how to return closures with `create_multiplier()`[105].
    As all closures implement either `Fn`, `FnOnce`, and/or `FnMut`, we can return
    a trait object for them. This way, we can create, compose, and change functions
    at runtime, just like with functional languages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一件事是如何使用 `create_multiplier()`[105] 返回闭包。由于所有闭包都实现了 `Fn`、`FnOnce` 和/或
    `FnMut`，我们可以为它们返回一个特征对象。这样，我们就可以在运行时创建、组合和更改函数，就像在函数式语言中一样。
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have noticed that returning a `Box<Iterator>` or a `Box<Error>` comes
    at a small cost in terms of efficiency, as it requires moving an object onto the
    heap without it having any reason to go there. There are currently two ways around
    this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，返回 `Box<Iterator>` 或 `Box<Error>` 在效率上会有一些损失，因为它需要在没有任何理由的情况下将对象移动到堆上。目前有两种方法可以解决这个问题。
- en: For `Box<Error>`, you should instead create an own `Error` type, combining all
    the possible errors that can be returned from your function. This is detailed
    in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml), *Handling Errors*;
    *Providing user-defined Error types*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Box<Error>`，你应该创建一个自己的 `Error` 类型，结合你函数可以返回的所有可能的错误。这详细说明在 [第 6 章](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)，*处理错误*；*提供用户定义的错误类型*。
- en: For `Box<Iterator>`, you can analyze the compiler's output in order to find
    out the exact true type that you're returning. This works for small iterators,
    but any complex iterator will take a long time to crack. Because this situation
    is not really desirable, the Rust team has approved the introduction of *abstract
    types*, which will be introduced in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*; *Returning abstract types* because it has
    not yet hit stable Rust.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Box<Iterator>`，你可以分析编译器的输出，以找出你返回的确切真实类型。这对于小型迭代器有效，但任何复杂的迭代器都需要很长时间才能破解。由于这种情况并不理想，Rust
    团队已经批准引入**抽象类型**，这将在第 10 章[使用实验性夜间功能](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml)中介绍；**返回抽象类型**，因为它尚未进入稳定
    Rust。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Providing user-defined error types* recipe in [Chapter 6](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml),
    *Handling Errors*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 6 章[处理错误](d2c7b7cb-3060-40b8-adb4-408eee7940a1.xhtml)中的**提供用户定义的错误类型**配方。
- en: '*Returning abstract types* recipe in [Chapter 10](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml),
    *Using Experimental Nightly Features*'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 10 章[使用实验性夜间功能](f2c7ca21-145e-40af-8502-8b42b37fe290.xhtml)中的**返回抽象类型**配方。
- en: Sharing ownership with smart pointers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与智能指针共享所有权
- en: Some ownership relationships are not as straightforward as *type A owns B*.
    Sometimes, an entire group of types owns another type. To handle this, we need
    another smart pointer that behaves mostly like `Box` but only deletes the underlying
    resource if no one needs it anymore, it is `Rc`, which stands for Reference Counted.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些所有权关系并不像**类型 A 拥有 B**那样简单。有时，一组类型会拥有另一个类型。为了处理这种情况，我们需要另一个类似 `Box` 的智能指针，但只有在没有人需要它时才会删除底层资源，它是
    `Rc`，代表引用计数。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the `bin` folder, create a file called `shared.rs`
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bin` 文件夹中，创建一个名为 `shared.rs` 的文件。
- en: 'Add the following code and run it with `cargo run --bin shared`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用 `cargo run --bin shared` 运行它：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The heart and soul of an `Rc` is its internal counter of how many objects own
    it at the moment. Every time the `Rc` is cloned, it increases by one, and every
    time one of its clones go out of scope, it decreases by one. The moment this counter
    reaches zero, the objects behind the `Rc` are destroyed. The `main` method contains
    some annotated examples of values the counter reaches during its lifetime to help
    you understand how the mechanism works.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc` 的核心是其内部计数器，它记录当前有多少个对象拥有它。每次 `Rc` 被克隆时，计数器增加一，每次其克隆中的一个超出作用域时，计数器减少一。当这个计数器达到零时，`Rc`
    后的对象将被销毁。`main` 方法包含一些注释示例，说明计数器在其生命周期中达到的值，以帮助你理解该机制的工作原理。'
- en: The effect of the simple rules presented is that a resource behind an `Rc` will
    only be deleted once it's no longer used, at the slim cost of a very small runtime
    performance loss because of the ongoing counting. This *delayed deletion* effect
    is ideal for resources that are shared between objects. Simply wrap them in an
    `Rc` and they will make sure that everything survives long enough. This is the
    equivalent of `shared_ptr` in C++.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的简单规则的效果是，位于 `Rc` 后的资源只有在不再被使用时才会被删除，由于持续计数导致的运行时性能损失非常小，因此成本极低。这种**延迟删除**的效果非常适合在对象之间共享的资源。只需将它们包装在
    `Rc` 中，它们就会确保一切都能存活足够长的时间。这相当于 C++ 中的 `shared_ptr`。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In one edge case, reference counts can cause a *memory leak*, that is, accidentally
    preventing resources from ever being deleted. This happens when two objects exist
    that both contain an `Rc` pointing to each other. Because of this circular dependence,
    none of them will stop using the other and so the two objects will continue existing
    and pointing at each other long after your code has stopped using them. The solution
    here is to pick the weaker link in the hierarchy and replace its `Rc` for a `Weak`,
    which contains a *non-owning reference* instead. Because this situation is fairly
    rare, however, we are not going to look at it in detail. Instead, simply remember
    the possibility of a memory leak and come back to read this again when it arises.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个边缘情况下，引用计数可能导致**内存泄漏**，即意外地阻止资源被删除。这种情况发生在存在两个对象，它们都包含指向对方的 `Rc` 时。由于这种循环依赖，它们都不会停止使用对方，因此这两个对象将在你的代码停止使用它们很久之后继续存在并指向对方。这里的解决方案是选择层次结构中的较薄弱环节，并用
    `Weak` 替换其 `Rc`，`Weak` 包含一个**非拥有引用**。然而，由于这种情况相当罕见，我们不会详细讨论它。相反，只需记住内存泄漏的可能性，并在出现时再次阅读此内容。
- en: '`Rc` is inherently singlethreaded. If you need its functionality in a multithreaded
    environment (such as the one we are going to explore in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*; *Sharing resources in multithreaded closures*), you can
    use `Arc` instead. It stands for Atomically Reference Counted and behaves the
    same way as `Rc`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc`本质上是单线程的。如果你需要在多线程环境中（例如我们将在第7章[ca93ce61-1a86-4588-9da0-766bed49876f.xhtml]中探讨的，*并行性和Rayon*；*在多线程闭包中共享资源*）使用其功能，你可以使用`Arc`代替。它代表原子引用计数，并且与`Rc`的行为相同。'
- en: See also
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Sharing resources in multithreaded closures* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7章[ca93ce61-1a86-4588-9da0-766bed49876f.xhtml]中的*在多线程闭包中共享资源*食谱
- en: Working with interior mutability
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与内部可变性一起工作
- en: Although Rust's borrow checker is one of its biggest selling points, alongside
    its clever error-handling concept and impressive tooling, it cannot read minds
    yet. Sometimes you might have to take things into your own hands and borrow objects
    manually. This is done with the concept of *interior mutability*, which states
    that certain types can wrap objects while being non-mutable and still operate
    on them mutably.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Rust的借用检查器是其最大的卖点之一，与它巧妙地错误处理的概念和令人印象深刻的工具一起，但它还不能读心。有时你可能必须亲自处理并手动借用对象。这是通过*内部可变性*的概念来完成的，它表明某些类型可以在非可变的情况下包装对象，并仍然可以对其进行可变操作。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In the `bin` folder, create a file called `interior_mutability.rs`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin`文件夹中，创建一个名为`interior_mutability.rs`的文件。
- en: 'Add the following code and run it with `cargo test --bin interior_mutability`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，并使用`cargo test --bin interior_mutability`运行它：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The protagonist of this recipe is `RefCell`, a wrapper around any type that
    moves the borrow checker's rule enforcement from compile time to runtime. The
    basics are pretty easy, you borrow the underlying value immutably by calling `.borrow()`
    and borrow it mutably by calling `.borrow_mut()`. If you don't follow the golden
    rule of only having multiple readers or one single writer at the same time, the
    program goes into `panic!`. One application for this is making members of your
    structs mutable even though your struct itself is immutable. The best use case
    to show where this is useful is mocking, the art of faking infrastructure for
    testing purposes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的主角是`RefCell`，它是一个任何类型的包装器，将借用检查器的规则执行从编译时移动到运行时。基本操作很简单，通过调用`.borrow()`来不可变地借用底层值，通过调用`.borrow_mut()`来可变地借用。如果你不遵循只有多个读者或同时只有一个写者的黄金法则，程序将进入`panic!`状态。这种应用的一个例子是即使你的结构体本身是不可变的，也可以使你的结构体的成员可变。展示这种用法最有用的案例是模拟，这是为了测试目的而伪造基础设施的艺术。
- en: The idea of our example is as follows, we want to send a newsletter to every
    customer that is interested. For that, we have the `EmailSender` trait[1], which
    just specifies a method to send an `Email` and return a response[2]. It's good
    practice to try to define functionality through traits in order to mock them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例想法如下，我们希望向所有感兴趣的客户发送新闻通讯。为此，我们有一个`EmailSender`特性[1]，它只指定了一个发送`Email`并返回响应的方法[2]。尝试通过特性来定义功能是一种良好的实践，以便对其进行模拟。
- en: Our `publish_news` function [19] takes a message, an `EmailSender` and a slice
    of `Customer` (please don't imagine that literally), and sends the message to
    all customers who want to receive news. If it encounters an error, it returns
    `None`[32], otherwise, it returns the number of newsletters it sent [36].
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`publish_news`函数[19]接受一个消息、一个`EmailSender`和一个`Customer`切片（请不要字面地想象），并将消息发送给所有希望接收新闻的客户。如果它遇到错误，它返回`None`[32]，否则，它返回它发送的新闻通讯数量[36]。
- en: You probably don't want to send an email to your customers every time you test
    your code, which is why we create `MockEmailSender`[49] inside the test configuration,
    which doesn't actually send anything but instead stores all mail in a `Vec` [64].
    In order to do this, it needs to modify its member despite being immutable. That's
    exactly what `RefCell` is for! Thanks to this, we can efficiently test `publish_news()`,
    as we can access all messages it would have sent and compare them with what we
    expect.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想每次测试代码时都向客户发送电子邮件，这就是为什么我们在测试配置中创建`MockEmailSender`[49]，它实际上不会发送任何东西，而是将所有邮件存储在一个`Vec`
    [64]中。为了做到这一点，它需要修改其成员，尽管它是不可变的。这正是`RefCell`的作用！多亏了它，我们可以有效地测试`publish_news()`，因为我们可以访问它将发送的所有消息，并将它们与我们期望的内容进行比较。
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many types that use interior mutability. Among them are `Cell`, which,
    instead of handing out references, simply copies the value it stores. This is
    nice when storing primitive types such as `i32` or `bool`, as they all implement
    copy anyway.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型使用内部可变性。其中之一是`Cell`，它不是分发引用，而是简单地复制它存储的值。当存储原始类型，如`i32`或`bool`时，这很好，因为它们都实现了复制。
- en: Others are `RwLock` and `Mutex`, which are important for parallelism, as we
    shall see in their recipes in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*; *Access resources in parallel with RwLocks*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型包括`RwLock`和`Mutex`，它们对于并行性非常重要，正如我们将在第7章的配方中看到，即[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行性和Rayon*；*使用RwLock并行访问资源*。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Access resources in parallel with RwLocks* recipe in [Chapter 7](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml),
    *Parallelism and Rayon*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ca93ce61-1a86-4588-9da0-766bed49876f.xhtml)，*并行性和Rayon*中的*使用RwLock并行访问资源*配方'
