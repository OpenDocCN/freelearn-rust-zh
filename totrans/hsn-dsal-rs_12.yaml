- en: Algorithms of the Standard Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库的算法
- en: 'Rust''s standard library provides a few fundamental data types that cover the
    basic needs of many projects and, typically, there is no need to implement your
    own algorithms if the appropriate data structure is available. If, for some reason,
    the data type is not perfectly suited to the task, the standard library has you
    covered as well. In this quick round-up, you can look forward to learning about
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的标准库提供了一些基本的数据类型，这些类型覆盖了许多项目的基本需求，通常情况下，如果已经有了适当的数据结构，就无需实现自己的算法。如果由于某种原因，数据类型并不完全适合任务，标准库也为你提供了相应的解决方案。在这个快速总结中，你可以期待了解以下内容：
- en: The `slice` primitive type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice` 原始类型'
- en: The `Iterator` trait
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator` 特质'
- en: '`binary_search()`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binary_search()`'
- en: '`sort()`, stable, and unstable'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`、稳定和不稳定的排序'
- en: Slicing and iteration
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片和迭代
- en: Similar to how interfaces standardize access to functionality in the libraries
    of other languages, Rust's standard library utilizes a type and a trait to provide
    fundamental implementations. The trait, `Iterator<T>`, has been looked at and
    used over the course of this book several times. The slice type, however, was
    not explicitly used a lot, especially since the Rust compiler automatically uses
    slices when `Vec<T>` is borrowed for a function call. How can you leverage this
    type, though? We have seen the `Iterator<T>` implementation in action, but does
    it provide more than that?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他语言的库中接口标准化对功能访问的方式，Rust 的标准库通过类型和特质来提供基本实现。特质 `Iterator<T>` 在本书的多个地方被提及和使用。然而，切片类型并没有被大量显式使用，特别是当
    `Vec<T>` 被借用来进行函数调用时，Rust 编译器会自动使用切片。那么，如何利用这种类型呢？我们已经看到了 `Iterator<T>` 的实现，但它提供了更多吗？
- en: Iterator
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'To recap: an iterator is a pattern to traverse a collection, providing a pointer
    to each element in the process. This pattern is mentioned in the book *Design
    Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (the
    Gang of Four), in 1994 and can be found in basically every language one way or
    another.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾：迭代器是一种遍历集合的模式，在遍历过程中提供对每个元素的指针。这种模式在1994年由Erich Gamma、Richard Helm、Ralph
    Johnson 和 John Vlissides（四人帮）所著的《设计模式》一书中被提及，并且几乎在每种语言中以某种方式存在。
- en: 'In Rust, the term pointer to each element gets a new dimension: is it a borrowed
    or owned item? Can this be mutably borrowed as well?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，每个元素的指针术语获得了一个新的维度：它是借用的还是拥有的项？它是否也可以被可变借用？
- en: Using the standard library's `Iterator<T>` trait makes a lot of sense, since
    it provides a serious amount of useful functions, which are all based around a
    single implementation of `next()`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库的 `Iterator<T>` 特质非常有意义，因为它提供了一系列有用的函数，这些函数都基于单一的 `next()` 实现。
- en: '`next()` returns an `Option<Self::Item>`, which is the associated type that
    has to be declared when implementing the trait—and it can be anything you like!'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()` 返回一个 `Option<Self::Item>`，这是在实现特质时必须声明的关联类型——它可以是你想要的任何类型！'
- en: 'Therefore, using `&MyType`, `&mut MyType`, and `MyType` can all be implemented
    separately to achieve the desired functionality. `IntoIter<T>` is a trait that
    is specifically designed to facilitate this workflow and to integrate it neatly
    with the `for` loop syntax. The following code is from the Rust standard library''s
    source code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 `&MyType`、`&mut MyType` 和 `MyType` 可以分别实现以实现所需的功能。`IntoIter<T>` 是一个特质，它专门设计用来简化这种工作流程，并与
    `for` 循环语法完美集成。以下代码来自 Rust 标准库的源代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: /// let v = vec!["a".to_string(), "b".to_string()];
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let v = vec!["a".to_string(), "b".to_string()];
- en: /// for s in v.into_iter() {
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// for s in v.into_iter() {
- en: /// // s has type String, not &String
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// // s has type String, not &String
- en: /// println!("{}", s);
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// println!("{}", s);
- en: /// }
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// }
- en: /// [PRE1]
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// [PRE1]
- en: Rust's `Vec<T>` implements precisely this pattern, but with a nice twist. The
    preceding code consumes the original data structure, potentially transforming
    the original into something that's easier to iterate, in the same way as trees
    can be expanded into a sorted `Vec<T>` or a stack. To return to the original theme,
    the `Iterator<T>` provides functions (implemented in further structures) that
    add many possible ways to search and filter through a collection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的 `Vec<T>` 正确实现了这种模式，但有一个巧妙的转折。前面的代码消耗了原始数据结构，可能将其转换成更容易迭代的格式，就像树可以被展开成排序后的
    `Vec<T>` 或栈。回到原来的主题，`Iterator<T>` 提供了函数（在进一步的结构中实现），这些函数增加了许多在集合中进行搜索和过滤的可能方式。
- en: Any Rust user will be aware of the `iter()` function of `Vec<T>`, however, which
    is actually provided by the slice type that `Vec` is implicitly converted into?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Rust 用户都会意识到 `Vec<T>` 的 `iter()` 函数，然而，实际上这是由 `Vec` 隐式转换为切片类型提供的？
- en: Slices
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: Slices are views into sequences to provide a more unified interface for accessing,
    iterating, or otherwise interacting with these memory areas. Consequently, they
    are available through `Vec<T>`, especially since they implement the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)
    trait to implicitly treat `Vec<T>` as a `[T]`—a slice of `T`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是序列的视图，以提供更统一的接口来访问、迭代或以其他方式与这些内存区域交互。因此，它们可以通过 `Vec<T>` 获取，特别是由于它们实现了 `Deref`
    特性，可以隐式地将 `Vec<T>` 作为 `[T]`——`T` 的切片来处理。
- en: 'The `Vec<T>` implementation also hints at that for the `IntoIterator` implementation
    for immutable and mutable references:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec<T>` 的实现也暗示了不可变和可变引用的 `IntoIterator` 实现：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The slice itself is only a view, represented by a pointer to the memory part
    and its length. Since the compiler knows the nature of the data contained within,
    it can also figure out individual elements to provide type safety.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 切片本身只是一个视图，由指向内存部分的指针及其长度表示。由于编译器知道其中包含的数据的性质，它也可以确定单个元素以提供类型安全。
- en: A more detailed explanation of slices and the way they work would warrant its
    own book, so it is recommended at least reading the documentation (or the source
    code) of the `slice` module ([https://doc.rust-lang.org/std/slice/index.html](https://doc.rust-lang.org/std/slice/index.html))[.](https://doc.rust-lang.org/std/slice/index.html)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 切片及其工作方式的更详细解释可能需要一本书来专门介绍，因此建议至少阅读 `slice` 模块的文档（或源代码）([https://doc.rust-lang.org/std/slice/index.html](https://doc.rust-lang.org/std/slice/index.html))[.](https://doc.rust-lang.org/std/slice/index.html)
- en: Search
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索
- en: Finding things in a collection has been discussed throughout this book, and
    the Rust standard library provides a few ways by default. These functions are
    attached to the `Iterator<T>` trait or slice types and work regardless of the
    actual type, provided that a function to compare two elements is furnished.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中已经讨论了如何在集合中查找事物，Rust 标准库默认提供了一些方法。这些函数附加到 `Iterator<T>` 特性或切片类型上，并且无论实际类型如何，只要提供了比较两个元素的功能，它们就可以工作。
- en: This can either be the `Ord` trait or a custom comparator function, such as
    the `position()` function on the `Iterator<T>`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是 `Ord` 特性或自定义比较函数，例如 `Iterator<T>` 上的 `position()` 函数。
- en: Linear search
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性查找
- en: 'The classic linear search is provided via `position()` (or `rposition()`) on
    the `Iterator<T>` trait, and it even utilizes other iterator functions that are
    implemented on the trait itself:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的线性查找是通过 `Iterator<T>` 特性上的 `position()`（或 `rposition()`）提供的，它甚至利用了在特性本身上实现的其它迭代器函数：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`try_fold()` is a short-circuit variation on the `fold()` (or `reduce()`, following
    the map/reduce pattern) function that returns whenever `LoopState::Break` is returned.
    The call to `break_value()` transforms the result from the value returned in the
    `LoopState::Break` enumeration into `Option` and `None` if it ran through the
    entire collection.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_fold()` 是 `fold()`（或 `reduce()`，遵循 map/reduce 模式）函数的短路变体，它在返回 `LoopState::Break`
    时随时返回。对 `break_value()` 的调用将 `LoopState::Break` 枚举中返回的值转换为 `Option` 和 `None`，如果它运行了整个集合。'
- en: This is the brute-force approach to searching and can be useful if the collection
    is unsorted and short. For anything longer, sorting and using the binary search
    function might pay off.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是搜索的暴力方法，如果集合未排序且较短，可能很有用。对于任何更长的情况，排序和使用二分搜索函数可能更有利。
- en: Binary search
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分查找
- en: A generic fast search function is provided through slices as well, called `binary_search()`.
    As discussed in [Chapter 10](32002bad-c2bb-46e9-918d-12d7dabfe579.xhtml), *Finding
    Stuff*, a binary search returns the index of an element after closing in on its
    position by repeatedly choosing a half.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 切片还提供了一个通用的快速搜索函数，称为 `binary_search()`。如第 10 章[32002bad-c2bb-46e9-918d-12d7dabfe579.xhtml]“查找事物”中讨论的，二分搜索通过反复选择一半来逼近元素的位置，返回元素的索引。
- en: 'To achieve that, there are two prerequisites that the input slice has to satisfy:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，输入切片必须满足两个先决条件：
- en: It's sorted
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是有序的
- en: The element type implements the `Ord` trait
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素类型实现了 `Ord` 特性
- en: '`binary_search()` cannot check whether the collection that''s provided is sorted,
    which means that if an unordered collection returns the expected result, it can
    only be coincidental. Additionally, if there are multiple elements with the same
    value, any of those can be the result.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search()`无法检查提供的集合是否已排序，这意味着如果无序集合返回预期的结果，这只能是一种巧合。此外，如果有多个具有相同值的元素，任何这些都可以是结果。'
- en: Other than using the implicitly provided comparison function (by implementing
    `Ord`), `binary_search()` also has a more flexible sibling—`binary_search_by()`,
    which requires a comparison function to be supplied.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用隐式提供的比较函数（通过实现`Ord`），`binary_search()`还有一个更灵活的兄弟函数—`binary_search_by()`，它需要一个提供的比较函数。
- en: 'Under the hood, this function is comparable to the naive implementation we
    created in [Chapter 10](32002bad-c2bb-46e9-918d-12d7dabfe579.xhtml), *Finding
    Stuff*; on occasion, it was even faster by a nanosecond or two. The code is just
    as simple, however:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这个函数与我们在第10章中创建的朴素实现[Chapter 10](32002bad-c2bb-46e9-918d-12d7dabfe579.xhtml)，*Finding
    Stuff*相似；有时，它甚至快上几纳秒。然而，代码同样简单：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Other variants of the function include searching by key or by the comparator
    function of the `Ord` trait (as mentioned previously). One major caveat can be
    the requirement to provide a sorted collection to the binary search function,
    but luckily, Rust provides sorting in its standard library.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的其他变体包括通过键或通过`Ord`特质的比较函数进行搜索（如前所述）。一个主要的注意事项是需要向二分搜索函数提供一个已排序的集合，但幸运的是，Rust在其标准库中提供了排序功能。
- en: Sorting
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: 'Sorting is an important feature in user interfaces, but also provides the predictability
    that''s necessary for many algorithms. Whenever there is no way to use an appropriate
    data structure (such as a tree), a generic sorting algorithm can take care of
    creating that order. One important question arises regarding equal values: will
    they end up at the same exact spot every time? When using a stable sorting algorithm,
    the answer is *yes*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是用户界面中的一个重要功能，同时也为许多算法提供了必要的可预测性。每当没有适当的数据结构（如树）可以使用时，一个通用的排序算法可以负责创建这种顺序。关于相等值的一个重要问题随之而来：它们是否每次都会出现在同一个确切的位置？当使用稳定排序算法时，答案是*是的*。
- en: Stable sorting
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定排序
- en: The key to stable sorting is not reordering equal elements, so in `[1, 1, 2,
    3, 4, 5]`, `1`s never change their positions relative to each other. In Rust,
    this is actually used when `sort()` is called on `Vec<T>`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定排序的关键不是重新排列相等元素，所以在`[1, 1, 2, 3, 4, 5]`中，`1`s相对于彼此的位置永远不会改变。在Rust中，当在`Vec<T>`上调用`sort()`时，实际上就是这样使用的。
- en: 'The current (2018 edition) implementation of `Vec<T>` uses a merge sort variation
    based on Timsort. Here is the source code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当前（2018版）`Vec<T>`的实现使用基于Timsort的归并排序变体。以下是源代码：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code is quite verbose, but can be split into smaller parts. The first step
    is to sort smaller (20 elements or less) slices by deleting and reinserting the
    elements in order (in other words, insertion sort):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当冗长，但可以分成更小的部分。第一步是对较小的（20个元素或更少）切片进行排序，通过删除并按顺序重新插入元素来实现（换句话说，插入排序）：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the collection is longer, the algorithm resorts to traversing the items
    back to front, identifying natural runs. The constant `MIN_RUN` (`10` in the preceding
    code) defines a minimum length of such a run, so a shorter run (such as `5, 9,
    10, 11, 13, 19, 31, 55, 56` in `[5, 9, 10, 11, 13, 19, 31, 55, 56, 1, ...]`) is
    expanded by doing an insertion sort on the 1 to get to 10 elements. The metadata
    of the resulting block (for `[1, 5, 9, 10, 11, 13, 19, 31, 55, 56]`, it would
    start at `0`, with a length of 10) is then pushed onto a stack for subsequent
    merging (note: we recommend reading the comments from the code authors):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合更长，算法将回溯遍历项目，识别自然运行。常量`MIN_RUN`（前述代码中的`10`）定义了此类运行的最小长度，因此较短的运行（例如`[5, 9,
    10, 11, 13, 19, 31, 55, 56]`中的`5, 9, 10, 11, 13, 19, 31, 55, 56`）通过在1上执行插入排序以获得10个元素来扩展。然后，结果块（对于`[1,
    5, 9, 10, 11, 13, 19, 31, 55, 56]`，它将从`0`开始，长度为10）将被推送到栈上以供后续合并（注意：我们建议阅读代码作者的注释）：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To conclude the iteration, some pairs on the stack are already merged, collapsing
    them in an insertion sort:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束迭代，栈上的一些对已经合并，在插入排序中折叠它们：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This `collapse` loop ensures that there is only a single item left on the stack,
    which is the sorted sequence. Finding out which runs to collapse is the essential
    part of Timsort, since merging is simply done using insertion sort. The collapse
    function checks for two essential conditions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`collapse`循环确保栈上只留下一个项目，即已排序的序列。找出要折叠的运行是Timsort的关键部分，因为合并只是简单地使用插入排序来完成。折叠函数检查两个基本条件：
- en: The lengths of the runs are in descending order (the top of the stack holds
    the longest run)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行的长度按降序排列（栈顶持有最长的运行）
- en: The length of each generated run is greater than the sum of the next two runs
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个生成的运行的长度大于下一个两个运行的长度之和
- en: 'With this in mind, let''s look at the collapse function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看折叠函数：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It returns the index of the run that is to be merged with its successor (`r`
    and `r + 1`; refer to the `collapse` loop for more information). The collapse
    function checks the top four runs to satisfy the aforementioned conditions if
    the topmost run (at the highest index) does not start at the beginning. If it
    does, the end is almost reached and a merge is necessary, regardless of any conditions
    that are violated, thereby ensuring the final sequence to be merged last.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回要与其后续元素合并的运行索引（`r`和`r + 1`；有关更多信息，请参阅`collapse`循环）。如果最顶部的运行（在最高索引处）不是从开始处开始的，折叠函数会检查前四个运行以满足上述条件。如果是，则几乎到达了终点，需要进行合并，无论违反了哪些条件，从而确保最终要合并的序列是最后一个。
- en: Timsort's combination of insertion sort and merge sort make it a really fast
    and efficient sorting algorithm that is also stable and operates on "blocks" by
    building these naturally occurring runs. Unstable sorting, on the other hand,
    uses a familiar Quicksort.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Timsort结合插入排序和归并排序，使其成为一个真正快速且高效的排序算法，它也是稳定的，并且通过构建这些自然发生的运行来在“块”上操作。另一方面，不稳定的排序使用熟悉的快速排序。
- en: Unstable sorting
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不稳定的排序
- en: Unstable sorting does not retain the relative position of equal values, and
    can therefore achieve better speeds thanks to the lack of additionally allocated
    memory that stable sorting requires. The slice's `sort_unstable()` function uses
    a Quicksort variation that is called a pattern-defeating Quicksort by Orson Peters,
    combining heap sort and Quicksort to achieve an excellent performance in most
    cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的排序不会保留相等值的相对位置，因此由于不需要稳定排序所需额外分配的内存，可以因此实现更快的速度。切片的`sort_unstable()`函数使用了一种由Orson
    Peters称为模式破坏快速排序的快速排序变体，结合堆排序和快速排序，在大多数情况下实现出色的性能。
- en: 'The slice implementation simply refers to it as Quicksort:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 切片实现简单地将其称为快速排序：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking at the Quicksort implementation, it spans the entire module—about 700
    lines of code. Therefore, let's look at the highest level function to understand
    the basics; curious readers should dive into the source code ([https://doc.rust-lang.org/src/core/slice/sort.rs.html](https://doc.rust-lang.org/src/core/slice/sort.rs.html))
    to find out more.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 观察快速排序的实现，它跨越了整个模块——大约700行代码。因此，让我们看看最高级函数以了解基础知识；好奇的读者应该深入研究源代码([https://doc.rust-lang.org/src/core/slice/sort.rs.html](https://doc.rust-lang.org/src/core/slice/sort.rs.html))以了解更多信息。
- en: 'The Quicksort function performs a few preliminary checks to rule out invalid
    cases:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序函数执行一些初步检查以排除无效情况：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `recurse` function is at the heart of this implementation and is even a
    recursive function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`recurse`函数是这个实现的核心，甚至是一个递归函数：'
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thankfully, the standard library's source has many helpful comments. Therefore,
    it's highly recommended to read through all the comments in the preceding snippet.
    In short, the algorithms make a lot of guesses to avoid making a bad choice for
    the pivot. If you recall, when Quicksort chooses a bad pivot element, it will
    split into uneven partitions, thereby creating very bad runtime behavior. Therefore,
    choosing a good pivot is critical, which is why so many heuristics around that
    process are employed and, if all else fails, the algorithm runs heap sort to at
    least have *O(n log n)* runtime complexity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准库的源代码中有许多有用的注释。因此，强烈建议阅读前面片段中的所有注释。简而言之，算法做出了很多猜测以避免对枢轴做出糟糕的选择。如果你还记得，当快速排序选择一个糟糕的枢轴元素时，它将分裂成不均匀的分区，从而产生非常糟糕的运行时间行为。因此，选择一个好的枢轴是至关重要的，这就是为什么围绕这个过程有那么多启发式方法被采用，如果所有其他方法都失败了，算法将运行堆排序以确保至少有*O(n
    log n)*的运行时间复杂度。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Rust's standard library includes several implementations for basic things such
    as sorting or searching on its primitive slice type and the `Iterator<T>` trait.
    The slice type in particular has many highly important functions to offer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的标准库包括对基本事物如排序或搜索其原始切片类型和`Iterator<T>`特质的好几种实现。特别是切片类型提供了许多非常重要的函数。
- en: '`binary_search()` is a generic implementation of the binary search concepts
    provided on the slice type. `Vec<T>` can be quickly and easily (and implicitly)
    converted into a slice, making this a universally available function. However,
    it requires a sorting order to be present in the slice to work (and it won''t
    fail if it''s not) and, if custom types are used, an implementation of the `Ord`
    trait.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search()`是针对切片类型提供的二分搜索概念的泛型实现。`Vec<T>`可以快速且容易（隐式地）转换为切片，这使得这个函数在所有情况下都可用。然而，它要求切片中存在排序顺序才能工作（如果不存在则不会失败），并且如果使用自定义类型，则需要实现`Ord`特质。'
- en: In case the slice cannot be sorted beforehand, the `Iterator<T>` variable's
    implementation of `position()` (of `find()`) provides a basic linear search that
    returns the first position of the element.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果切片不能事先排序，`Iterator<T>`变量的`position()`（`find()`的）实现提供了一个基本的线性搜索，返回元素的第一个位置。
- en: 'Sorting is provided in a generic function, but comes in two flavors: stable
    and unstable. The regular `sort()` function uses a merge sort variation called
    Timsort to achieve an efficient and stable sorting performance.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 排序由一个泛型函数提供，但有两种风味：稳定和不稳定。常规的`sort()`函数使用一个称为Timsort的归并排序变体，以实现高效且稳定的排序性能。
- en: '`sort_unstable()` utilizes a pattern-defeating Quicksort to combine the efficiency
    of heap sort and Quicksort in a smart way, which typically leads to a better absolute
    runtime than `sort()`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_unstable()`利用一种模式破坏的快速排序来巧妙地结合堆排序和快速排序的效率，这通常会导致比`sort()`更好的绝对运行时间。'
- en: This was the final chapter of this book and, if you made it to here, you finally
    deserve some answers! You can find the answers to all of the questions that have
    been asked in the *Assessments* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，如果你已经读到这儿，你终于应该得到一些答案了！你可以在*评估*部分找到所有问题的答案。
- en: Questions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Where is Rust's implementation of generic algorithms on collections?
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust在集合上的泛型算法实现在哪里？
- en: When is a linear search better than a binary search?
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时线性搜索比二分搜索更好？
- en: '*Potential job interview question:* What are stable and unstable sorting algorithms?'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可能的面试问题：* 稳定和不稳定排序算法是什么？'
- en: What is a bad behavior exhibited by Quicksort that pattern-defeating Quicksort
    mitigates?
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序表现出的哪种不良行为被模式破坏的快速排序缓解了？
- en: Further reading
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的参考资料，你可以参考有关本章所涵盖内容的材料：
- en: '*D**esign Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计模式*，由Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides著'
- en: Iterator pattern on Wikipedia ([https://en.wikipedia.org/wiki/Iterator_pattern](https://en.wikipedia.org/wiki/Iterator_pattern))
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的迭代器模式([https://en.wikipedia.org/wiki/Iterator_pattern](https://en.wikipedia.org/wiki/Iterator_pattern))
- en: '*OpenJDK''s java.utils.Collection.sort() is broken: The good, the bad and the
    worst case*, by de Gow et al. ([http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf](http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf))'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenJDK的java.utils.Collection.sort()存在缺陷：好的、坏的和最坏的情况*，由de Gow等人撰写([http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf](http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf))'
- en: Pattern-defeating Quicksort ([http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf](http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf))
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式破坏的快速排序([http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf](http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf))
