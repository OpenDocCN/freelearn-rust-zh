- en: Algorithms of the Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust''s standard library provides a few fundamental data types that cover the
    basic needs of many projects and, typically, there is no need to implement your
    own algorithms if the appropriate data structure is available. If, for some reason,
    the data type is not perfectly suited to the task, the standard library has you
    covered as well. In this quick round-up, you can look forward to learning about
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `slice` primitive type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Iterator` trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary_search()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort()`, stable, and unstable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing and iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to how interfaces standardize access to functionality in the libraries
    of other languages, Rust's standard library utilizes a type and a trait to provide
    fundamental implementations. The trait, `Iterator<T>`, has been looked at and
    used over the course of this book several times. The slice type, however, was
    not explicitly used a lot, especially since the Rust compiler automatically uses
    slices when `Vec<T>` is borrowed for a function call. How can you leverage this
    type, though? We have seen the `Iterator<T>` implementation in action, but does
    it provide more than that?
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap: an iterator is a pattern to traverse a collection, providing a pointer
    to each element in the process. This pattern is mentioned in the book *Design
    Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (the
    Gang of Four), in 1994 and can be found in basically every language one way or
    another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, the term pointer to each element gets a new dimension: is it a borrowed
    or owned item? Can this be mutably borrowed as well?'
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard library's `Iterator<T>` trait makes a lot of sense, since
    it provides a serious amount of useful functions, which are all based around a
    single implementation of `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`next()` returns an `Option<Self::Item>`, which is the associated type that
    has to be declared when implementing the trait—and it can be anything you like!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, using `&MyType`, `&mut MyType`, and `MyType` can all be implemented
    separately to achieve the desired functionality. `IntoIter<T>` is a trait that
    is specifically designed to facilitate this workflow and to integrate it neatly
    with the `for` loop syntax. The following code is from the Rust standard library''s
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: /// let v = vec!["a".to_string(), "b".to_string()];
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// for s in v.into_iter() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// // s has type String, not &String
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// println!("{}", s);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// }
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: /// [PRE1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rust's `Vec<T>` implements precisely this pattern, but with a nice twist. The
    preceding code consumes the original data structure, potentially transforming
    the original into something that's easier to iterate, in the same way as trees
    can be expanded into a sorted `Vec<T>` or a stack. To return to the original theme,
    the `Iterator<T>` provides functions (implemented in further structures) that
    add many possible ways to search and filter through a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Any Rust user will be aware of the `iter()` function of `Vec<T>`, however, which
    is actually provided by the slice type that `Vec` is implicitly converted into?
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slices are views into sequences to provide a more unified interface for accessing,
    iterating, or otherwise interacting with these memory areas. Consequently, they
    are available through `Vec<T>`, especially since they implement the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)
    trait to implicitly treat `Vec<T>` as a `[T]`—a slice of `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Vec<T>` implementation also hints at that for the `IntoIterator` implementation
    for immutable and mutable references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The slice itself is only a view, represented by a pointer to the memory part
    and its length. Since the compiler knows the nature of the data contained within,
    it can also figure out individual elements to provide type safety.
  prefs: []
  type: TYPE_NORMAL
- en: A more detailed explanation of slices and the way they work would warrant its
    own book, so it is recommended at least reading the documentation (or the source
    code) of the `slice` module ([https://doc.rust-lang.org/std/slice/index.html](https://doc.rust-lang.org/std/slice/index.html))[.](https://doc.rust-lang.org/std/slice/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding things in a collection has been discussed throughout this book, and
    the Rust standard library provides a few ways by default. These functions are
    attached to the `Iterator<T>` trait or slice types and work regardless of the
    actual type, provided that a function to compare two elements is furnished.
  prefs: []
  type: TYPE_NORMAL
- en: This can either be the `Ord` trait or a custom comparator function, such as
    the `position()` function on the `Iterator<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Linear search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic linear search is provided via `position()` (or `rposition()`) on
    the `Iterator<T>` trait, and it even utilizes other iterator functions that are
    implemented on the trait itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`try_fold()` is a short-circuit variation on the `fold()` (or `reduce()`, following
    the map/reduce pattern) function that returns whenever `LoopState::Break` is returned.
    The call to `break_value()` transforms the result from the value returned in the
    `LoopState::Break` enumeration into `Option` and `None` if it ran through the
    entire collection.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the brute-force approach to searching and can be useful if the collection
    is unsorted and short. For anything longer, sorting and using the binary search
    function might pay off.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic fast search function is provided through slices as well, called `binary_search()`.
    As discussed in [Chapter 10](32002bad-c2bb-46e9-918d-12d7dabfe579.xhtml), *Finding
    Stuff*, a binary search returns the index of an element after closing in on its
    position by repeatedly choosing a half.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, there are two prerequisites that the input slice has to satisfy:'
  prefs: []
  type: TYPE_NORMAL
- en: It's sorted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The element type implements the `Ord` trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary_search()` cannot check whether the collection that''s provided is sorted,
    which means that if an unordered collection returns the expected result, it can
    only be coincidental. Additionally, if there are multiple elements with the same
    value, any of those can be the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than using the implicitly provided comparison function (by implementing
    `Ord`), `binary_search()` also has a more flexible sibling—`binary_search_by()`,
    which requires a comparison function to be supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, this function is comparable to the naive implementation we
    created in [Chapter 10](32002bad-c2bb-46e9-918d-12d7dabfe579.xhtml), *Finding
    Stuff*; on occasion, it was even faster by a nanosecond or two. The code is just
    as simple, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Other variants of the function include searching by key or by the comparator
    function of the `Ord` trait (as mentioned previously). One major caveat can be
    the requirement to provide a sorted collection to the binary search function,
    but luckily, Rust provides sorting in its standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sorting is an important feature in user interfaces, but also provides the predictability
    that''s necessary for many algorithms. Whenever there is no way to use an appropriate
    data structure (such as a tree), a generic sorting algorithm can take care of
    creating that order. One important question arises regarding equal values: will
    they end up at the same exact spot every time? When using a stable sorting algorithm,
    the answer is *yes*.'
  prefs: []
  type: TYPE_NORMAL
- en: Stable sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to stable sorting is not reordering equal elements, so in `[1, 1, 2,
    3, 4, 5]`, `1`s never change their positions relative to each other. In Rust,
    this is actually used when `sort()` is called on `Vec<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current (2018 edition) implementation of `Vec<T>` uses a merge sort variation
    based on Timsort. Here is the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is quite verbose, but can be split into smaller parts. The first step
    is to sort smaller (20 elements or less) slices by deleting and reinserting the
    elements in order (in other words, insertion sort):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the collection is longer, the algorithm resorts to traversing the items
    back to front, identifying natural runs. The constant `MIN_RUN` (`10` in the preceding
    code) defines a minimum length of such a run, so a shorter run (such as `5, 9,
    10, 11, 13, 19, 31, 55, 56` in `[5, 9, 10, 11, 13, 19, 31, 55, 56, 1, ...]`) is
    expanded by doing an insertion sort on the 1 to get to 10 elements. The metadata
    of the resulting block (for `[1, 5, 9, 10, 11, 13, 19, 31, 55, 56]`, it would
    start at `0`, with a length of 10) is then pushed onto a stack for subsequent
    merging (note: we recommend reading the comments from the code authors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To conclude the iteration, some pairs on the stack are already merged, collapsing
    them in an insertion sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This `collapse` loop ensures that there is only a single item left on the stack,
    which is the sorted sequence. Finding out which runs to collapse is the essential
    part of Timsort, since merging is simply done using insertion sort. The collapse
    function checks for two essential conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The lengths of the runs are in descending order (the top of the stack holds
    the longest run)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of each generated run is greater than the sum of the next two runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this in mind, let''s look at the collapse function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It returns the index of the run that is to be merged with its successor (`r`
    and `r + 1`; refer to the `collapse` loop for more information). The collapse
    function checks the top four runs to satisfy the aforementioned conditions if
    the topmost run (at the highest index) does not start at the beginning. If it
    does, the end is almost reached and a merge is necessary, regardless of any conditions
    that are violated, thereby ensuring the final sequence to be merged last.
  prefs: []
  type: TYPE_NORMAL
- en: Timsort's combination of insertion sort and merge sort make it a really fast
    and efficient sorting algorithm that is also stable and operates on "blocks" by
    building these naturally occurring runs. Unstable sorting, on the other hand,
    uses a familiar Quicksort.
  prefs: []
  type: TYPE_NORMAL
- en: Unstable sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unstable sorting does not retain the relative position of equal values, and
    can therefore achieve better speeds thanks to the lack of additionally allocated
    memory that stable sorting requires. The slice's `sort_unstable()` function uses
    a Quicksort variation that is called a pattern-defeating Quicksort by Orson Peters,
    combining heap sort and Quicksort to achieve an excellent performance in most
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The slice implementation simply refers to it as Quicksort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the Quicksort implementation, it spans the entire module—about 700
    lines of code. Therefore, let's look at the highest level function to understand
    the basics; curious readers should dive into the source code ([https://doc.rust-lang.org/src/core/slice/sort.rs.html](https://doc.rust-lang.org/src/core/slice/sort.rs.html))
    to find out more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Quicksort function performs a few preliminary checks to rule out invalid
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `recurse` function is at the heart of this implementation and is even a
    recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, the standard library's source has many helpful comments. Therefore,
    it's highly recommended to read through all the comments in the preceding snippet.
    In short, the algorithms make a lot of guesses to avoid making a bad choice for
    the pivot. If you recall, when Quicksort chooses a bad pivot element, it will
    split into uneven partitions, thereby creating very bad runtime behavior. Therefore,
    choosing a good pivot is critical, which is why so many heuristics around that
    process are employed and, if all else fails, the algorithm runs heap sort to at
    least have *O(n log n)* runtime complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust's standard library includes several implementations for basic things such
    as sorting or searching on its primitive slice type and the `Iterator<T>` trait.
    The slice type in particular has many highly important functions to offer.
  prefs: []
  type: TYPE_NORMAL
- en: '`binary_search()` is a generic implementation of the binary search concepts
    provided on the slice type. `Vec<T>` can be quickly and easily (and implicitly)
    converted into a slice, making this a universally available function. However,
    it requires a sorting order to be present in the slice to work (and it won''t
    fail if it''s not) and, if custom types are used, an implementation of the `Ord`
    trait.'
  prefs: []
  type: TYPE_NORMAL
- en: In case the slice cannot be sorted beforehand, the `Iterator<T>` variable's
    implementation of `position()` (of `find()`) provides a basic linear search that
    returns the first position of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting is provided in a generic function, but comes in two flavors: stable
    and unstable. The regular `sort()` function uses a merge sort variation called
    Timsort to achieve an efficient and stable sorting performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sort_unstable()` utilizes a pattern-defeating Quicksort to combine the efficiency
    of heap sort and Quicksort in a smart way, which typically leads to a better absolute
    runtime than `sort()`.'
  prefs: []
  type: TYPE_NORMAL
- en: This was the final chapter of this book and, if you made it to here, you finally
    deserve some answers! You can find the answers to all of the questions that have
    been asked in the *Assessments* section.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where is Rust's implementation of generic algorithms on collections?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is a linear search better than a binary search?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Potential job interview question:* What are stable and unstable sorting algorithms?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a bad behavior exhibited by Quicksort that pattern-defeating Quicksort
    mitigates?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is some additional reference material that you may refer to regarding
    what has been covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*D**esign Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator pattern on Wikipedia ([https://en.wikipedia.org/wiki/Iterator_pattern](https://en.wikipedia.org/wiki/Iterator_pattern))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OpenJDK''s java.utils.Collection.sort() is broken: The good, the bad and the
    worst case*, by de Gow et al. ([http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf](http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern-defeating Quicksort ([http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf](http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
