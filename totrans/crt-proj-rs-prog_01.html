<html><head></head><body>
        

                            
                    Rust 2018: Productivity
                
            
            
                
<p>The Rust Standard Library and tooling have improved a lot over the years. Since February 2018, the Rust ecosystem has become quite wide and multifaceted. Four domain working groups have been created, each covering one of the main application areas. These areas were already fairly mature, but this development allowed them to improve even further. In the coming years, we will see the introduction of other domain working groups as well.</p>
<p>It's not an easy task to develop a high-quality and cost-effective application, even after learning a language as a developer. To avoid reinventing the (presumably low-quality) wheel, you as a developer should use a high-quality framework or some high-quality libraries that cover the kind of application you are going to develop.</p>
<p>The purpose of this book is to guide you as a developer to choose the best open source Rust libraries available for developing software. This book covers several typical domains, each using different libraries. Because some non-standard libraries are useful in a number of different domains, it would be quite limiting to present them as confined to a single domain.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Understanding the different editions of Rust</li>
<li>Understanding the most important recent improvements made to Rust</li>
<li>Understanding domain working groups</li>
<li>Understanding the kind of projects that we will cover in this book</li>
<li>An introduction to some useful Rust libraries</li>
</ul>
<h1 id="uuid-e96f82a0-d0a9-4bdd-a762-6f1d631770d4">Technical requirements</h1>
<p>To follow this book, you will need to have access to a computer on which a recent Rust system is installed. Any release since version 1.31 is okay. Some optional libraries will be listed for some specific projects later on.</p>
<p>Any cited source code and additional examples can (and should) be downloaded from the repository: <a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers</a>.</p>
<h1 id="uuid-5705be04-fffd-43be-ba98-1496bfa1965a" class="mce-root">Understanding the different editions of Rust</h1>
<p class="mce-root">On December 6, 2018, a very important version of the Rust language, its compiler, and its standard library was released: stable version <strong>1.31</strong>. This version has been defined as the <strong>2018 edition</strong>, meaning it is a milestone that will be used as a reference for the years to come.</p>
<p class="mce-root">Before this, there was another version, 1.0, which was defined as the <strong>2015 edition</strong>. This edition was characterized by the word <em>stability</em>. Up until version 1.0, every version of the compiler applied breaking changes to the language or to the standard library, forcing the developers to apply sweeping changes to their code base. From version 1.0, efforts have been made to ensure that any future version of the compiler can correctly compile any code written for version 1.0 or successive versions. This is called <strong>backward compatibility</strong>.</p>
<p>However, many features were applied to the language and to the standard library before the release of the 2018 edition. Many new libraries used these new features, meaning that these libraries could not be used by older compilers. For this reason, there was a need to tag a specific version of Rust as aimed at being used with newer libraries. This was the main reason for the 2018 edition.</p>
<p>Some of the features added to the language are marked as for the 2015 edition, while others are marked as for the 2018 edition. The features for the 2015 edition are just small improvements, while the features for the 2018 edition are more in-depth changes. Developers must mark their crates as for the 2018 edition in order to use the features that are specific to the 2018 edition.</p>
<p class="mce-root">In addition, although the 2015 edition marked a stable milestone for the language and the standard library, the command-line tools were not actually stabilized; they were still quite immature. In the three and a half years from May 2015 to December 2018, the main official command-line tools have matured, and the language has also been improved to allow more efficient coding. The 2018 edition can be characterized by the word <em>productivity</em>.</p>
<p>The following table shows a timeline of the features stabilized in the language, the standard library, and the tooling:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>2015</strong></td>
<td><strong>May</strong>: 2015 edition</td>
<td><strong>August</strong>: Parallel compilation on multi-core CPUs</td>
<td/>
<td/>
<td/>
<td/>
<td/>
</tr>
<tr>
<td><strong>2016</strong></td>
<td><strong>April</strong>: Microsoft C compiler format supported</td>
<td><strong>May</strong>: Ability to capture panics</td>
<td><strong>September</strong>: Improved compiler error messages</td>
<td><strong>November</strong>: The <kbd>?</kbd> operator</td>
<td><strong>December</strong>: The <kbd>rustup</kbd> command</td>
<td/>
<td/>
</tr>
<tr>
<td><strong>2017</strong></td>
<td><strong>February</strong>: Custom derive attributes</td>
<td><strong>March</strong>: The cargo check command</td>
<td><strong>July</strong>: The <kbd>union</kbd> keyword</td>
<td><strong>August</strong>: Associated constants</td>
<td><strong>November</strong>: The <kbd>?</kbd> operator with Option</td>
<td/>
<td/>
</tr>
<tr>
<td><strong>2018</strong></td>
<td><strong>February</strong>:
<ul>
<li>The formation of four Domain Working Groups.</li>
<li>The <kbd>rustfmt</kbd> program</li>
</ul>
</td>
<td><strong>May</strong>:
<ul>
<li>The Rust Programming Language Second Edition.</li>
<li>The <kbd>impl</kbd> Trait language feature.</li>
<li><kbd>main</kbd> can return a Result.</li>
<li>Inclusive ranges with <kbd>..=</kbd></li>
<li>The <em>i128</em> and <em>u128</em> native types.</li>
<li>Improved patterns for <kbd>match</kbd></li>
</ul>
</td>
<td><strong>June</strong>:
<ul>
<li>The SIMD library feature</li>
<li>The <kbd>dyn</kbd> Trait language feature</li>
</ul>
</td>
<td><strong>August</strong>: Custom global allocator</td>
<td><strong>September</strong>:
<ul>
<li>The <kbd>cargo fix</kbd> command</li>
<li>The <kbd>cargo clippy</kbd> command</li>
</ul>
</td>
<td><strong>October</strong>:
<ul>
<li>Procedural macros</li>
<li>Changes to the module system and the <kbd>use</kbd> statement</li>
<li>Raw identifiers</li>
<li><kbd>no_std</kbd> applications</li>
</ul>
</td>
<td><strong>December</strong>:
<ul>
<li>The 2018 edition</li>
<li>Non-lexical lifetimes</li>
<li>The <kbd>const fn</kbd> language feature</li>
<li>The new <a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a> website</li>
<li><kbd>try</kbd>, <kbd>async</kbd>, and <kbd>await</kbd> are reserved words</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Many improvements have been applied since the 2015 edition. More information can be found in the official documentation (<a href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</a>). The most important improvements are listed as follows:</p>
<ul>
<li>A new official tutorial book, available free online (<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>), or printed on paper (<em>The Rust Programming Language</em> by Steve Klabnik and Carol Nichols).</li>
<li>A revamped official website.</li>
<li>The formation of four domain working groups, which are open committees to design the future of the ecosystem in four key areas:
<ul>
<li><strong>Networking</strong>: Designing the new asynchronous paradigm around a concept of delayed computation, named <em>future</em>, as it is already done in other languages, such as C++, C#, and JavaScript (with <em>promises</em>).</li>
<li><strong>Command-line applications</strong>: Designing some standard libraries to support any non-graphical, non-embedded applications.</li>
<li><strong>WebAssembly</strong>: Designing tools and libraries to build applications to be run inside web browsers.</li>
<li><strong>Embedded software</strong>: Designing tools and libraries to build applications to be run on bare-metal systems or on strictly constrained hardware.</li>
</ul>
</li>
<li>We witnessed some good improvements to the language:
<ul>
<li>Non-lexical lifetimes; any bindings that are no longer used are considered <em>dead</em>. For example, now this program is allowed:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px">fn main() {<br/>    let mut _a = 7;<br/>    let _ref_to_a = &amp;_a;<br/>    _a = 9;<br/>}</pre>
<p>In this code, the object bound to the variable <kbd>_a</kbd> is borrowed by the variable <kbd>_ref_to_a</kbd> in the second statement. Prior to the introduction of non-lexical lifetimes, such bindings would last till the end of the scope, and so the last statement would have been illegal because it tries to change that object through binding <kbd>_a</kbd> when it is still borrowed to variable <kbd>_ref_to_a</kbd>. Now, because variable <kbd>_ref_to_a</kbd> is no longer used, its lifetime ceases in the same line it is declared, and so, in the last statement, variable <kbd>_a</kbd> is again free to change its own object.</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>The <kbd>Impl Trait</kbd> feature, which allows functions to return unspecified types, such as <strong>closures</strong>.</li>
<li>The <kbd>i128</kbd> and <kbd>u128</kbd> native types.</li>
<li>Some other reserved keywords such as <kbd>try</kbd>, <kbd>async</kbd>, and <kbd>await</kbd>.</li>
<li>The <kbd>?</kbd> operator, usable even in the <kbd>main</kbd> function, because now it can return <kbd>Result</kbd>. The following program is an example of the <kbd>main</kbd> function returning a <kbd>Result</kbd>:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px">fn main() -&gt; Result&lt;(), String&gt; {<br/>    Err("Hi".to_string())<br/>}</pre>
<p style="padding-left: 150px">It can succeed, by returning the usual empty tuple or fail by returning the type you specify. In this case, it was <kbd>String</kbd>. The following program is an example using the <kbd>?</kbd> operator used in the <kbd>main</kbd> function:</p>
<pre style="padding-left: 150px">fn main() -&gt; Result&lt;(), usize&gt; {<br/>    let array = [12, 19, 27];<br/>    let found = array.binary_search(&amp;19)?;<br/>    println!("Found {}", found);<br/>    let found = array.binary_search(&amp;20)?;<br/>    println!("Found {}", found);<br/>    Ok(())<br/>}</pre>
<p style="padding-left: 150px">This program will print <kbd>Found 1</kbd> on the standard output stream, meaning that the number <kbd>19</kbd> has been found at position <kbd>1</kbd>, and it will print <kbd>Error: 2</kbd> on the standard error stream, meaning that the number <kbd>20</kbd> hasn't been found, but that it should be inserted at position <kbd>2</kbd>.</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>Procedural macros, which allow a kind of meta-programming, manipulating source code to generate Rust code at compile time. </li>
<li>More powerful and more ergonomic pattern matching in <kbd>match</kbd> expressions.</li>
</ul>
</li>
<li>And also some improvements to the standard tooling:
<ul>
<li>The <kbd>rustup</kbd> program, which allows users to easily choose the default compiler target or to update the toolchain.</li>
<li>The <kbd>rustfix</kbd> program, which converts a 2015 edition project to a 2018 edition project.</li>
<li>The Clippy program, which checks for non-idiomatic syntax, and suggests changes to code for better maintainability.</li>
<li>Faster compilation speed, in particular, if just a syntax check is required.</li>
<li>The <strong>Rust Language Server</strong> (<strong>RLS</strong>) program, which is currently still unstable, but which allows IDEs and programmable editors to spot syntax errors, and to suggest allowed operations.</li>
</ul>
</li>
</ul>
<p>Rust is still evolving as a language, like any other programming language. The following areas are still left to be improved:</p>
<ul>
<li>The IDE tools, including a language interpreter (REPL) and a graphical debugger</li>
<li>Libraries and tools to support bare-metal and real-time software development</li>
<li>Application-level frameworks and libraries for the main application areas</li>
</ul>
<p>This book will focus primarily on the third point on this list.</p>
<h1 id="uuid-e56c755b-7085-40c9-878a-990c187b6249">The projects</h1>
<p class="mce-root">When we write a real-world application, the Rust language and its standard library are not sufficient. Application frameworks are needed for particular kinds of applications, such as GUI apps, web apps, or games.</p>
<p class="mce-root">Of course, if you use a good-quality and comprehensive library, you can reduce the number of lines of code that you need to write. Using a library also offers the following two advantages:</p>
<ul>
<li class="mce-root">The overall design is improved, particularly if you are using a framework (since it imposes an architecture on your app) as it will be created by knowledgeable engineers and time-tested by a number of users. </li>
<li class="mce-root">The number of bugs will be reduced because it will have undergone more thorough testing than that which you are likely to be able to apply.</li>
</ul>
<p class="mce-root">There are actually many Rust libraries, also known as <strong>crates</strong>, but most are low-quality or quite narrow in their range of applications. This book will look at the best quality and most complete libraries for some typical application areas of the Rust language.</p>
<p class="mce-root">The application areas are as follows:</p>
<ul>
<li class="mce-root"><strong>Web apps</strong>: There are various popular technologies, including the following:
<ul>
<li>The REST web service (backend only)</li>
<li>An event-driven web client (frontend only)</li>
<li>A full web app (full-stack)</li>
<li>A web game (frontend only)</li>
</ul>
</li>
</ul>
<ul>
<li class="mce-root"><strong>Games</strong>: When I say <em>games</em>, I'm not referring to anything that is entertaining. I am referring to a graphical application where a continuous animation is shown, as opposed to event-driven graphical applications that do nothing until an event occurs, such as the user pressing a key, moving the mouse, or some data arriving from a connection. As well as games for the web browser, there are also games for desktop and laptop computers, for video game consoles, and for mobile devices. However, video game consoles and mobile devices are not yet that well supported by Rust, so we will only be looking at games for desktop and laptop computers in this book.</li>
<li class="mce-root"><strong>Language interpreters</strong>: There are two kinds of languages that can be interpreted. Both are covered in this book:
<ul>
<li><strong>Text</strong>: Like a programming language, a markup language, or a machine command language</li>
<li><strong>Binary</strong>: Like the machine language of a computer to be emulated, or the intermediate bytecode of a programming language.</li>
</ul>
</li>
<li class="mce-root"><strong>C-language-callable libraries</strong>: This is an important use case of Rust: to develop a library to be invoked by another application, typically written in a higher-level language. Rust cannot assume that other languages can invoke the Rust code, but it can assume that they can invoke the C-language code. We will look at how to build a library that can be invoked as if it were written in C. One particularly challenging case is to build a module for the Linux operating system, which notoriously has to be written in C.</li>
</ul>
<p>Most applications read and write data to and from a file, or a communication channel, or a database. In the next chapter, we will be looking at various different techniques that will be useful for all the other projects.</p>
<p>Other application areas have not been listed here as they are either not used much in Rust, they are still immature, or they are still in a state of flux. The libraries available for these immature areas will be completely different in a couple of years. These areas include software for micro-controllers, or other real-time or low-resource systems, and also software for mobile or wearable systems.</p>
<h1 id="uuid-ac599826-8397-4b25-8baa-9eed970dc63e">Working through the examples in this book</h1>
<p>To follow the examples in the book, you should download all the examples from the online repository: <a href="https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers">https://github.com/PacktPublishing/Creative-Projects-for-Rust-Programmers</a>. This repository contains a sub-folder for each chapter of the book and a sub-sub-folder for any project in a chapter.</p>
<p>For example, to run the <kbd>use_rand</kbd> project in this chapter, you should go to the <kbd>Chapter01/use_rand</kbd> folder and type <kbd>cargo run</kbd>. Notice that the most important files of any project are <kbd>cargo.toml</kbd> and <kbd>src/main.rs</kbd>, so you should always take a look at them first.</p>
<h1 id="uuid-19608cb6-0d94-4a65-b5a4-fdbf353e083c">Exploring some utility crates</h1>
<p>Before moving on to looking at how to use the most complex crates, let's take a look at some basic Rust crates. These are not a part of the standard library, but they are useful in many different kinds of projects. They should be known by all Rust developers since they are of general applicability.</p>
<h2 id="uuid-6f03fcb7-57e7-44df-8abb-40fcc500ca72">Pseudo-random number generators – the rand crate</h2>
<p>The ability to generate pseudo-random numbers is needed for several kinds of applications, especially for games. The <kbd>rand</kbd> crate is rather complex, but its basic usage is shown in the following example (named <kbd>use_rand</kbd>): </p>
<pre>// Declare basic functions for pseudo-random number generators.<br/>use rand::prelude::*;<br/><br/>fn main() {<br/>    // Create a pseudo-Random Number Generator for the current thread<br/>    let mut rng = thread_rng();<br/><br/>    // Print an integer number<br/>    // between 0 (included) and 20 (excluded).<br/>    println!("{}", rng.gen_range(0, 20));<br/><br/>    // Print a floating-point number<br/>    // between 0 (included) and 1 (excluded).<br/>    println!("{}", rng.gen::&lt;f64&gt;());<br/><br/>    // Generate a Boolean.<br/>    println!("{}", if rng.gen() { "Heads" } else { "Tails" });<br/>}</pre>
<p>First, you create a pseudo-random number generator object. Then, you call several methods on this object. Any generator must be <strong>mutable</strong> because any generation modifies the state of the generator.</p>
<p>The <kbd>gen_range</kbd> method generates an integer number in a right-open range. The <kbd>gen</kbd> generic method generates a number of the specified type. Sometimes, this type can be inferred, like in the last statement, where a Boolean is expected. If the generated type is a floating-point number, it is between 0 and 1, with 1 excluded.</p>
<h2 id="uuid-eb52aa33-f048-493f-8c63-8878d2911029">Logging – the log crate</h2>
<p>For any kind of software, in particular for servers, the ability to emit logging messages is essential. The logging architecture has two components:</p>
<ul>
<li><strong>API</strong>: Defined by the <kbd>log</kbd> crate</li>
<li><strong>Implementation</strong>: Defined by several possible crates</li>
</ul>
<p>Here, an example using the popular <kbd>env_logger</kbd> crate is shown. If you want to emit logging messages from a library, you should only add the API crate as a dependency, as it is the responsibility of the application to define the logging implementation crate.</p>
<p>In the following example (named <kbd>use_env_logger</kbd>), we are showing an application (not a library), and so we need both crates:</p>
<div><div><pre style="padding-left: 30px">#[macro_use]<br/>extern crate log;<br/><br/>fn main() {<br/>    env_logger::init();<br/>    error!("Error message");<br/>    warn!("Warning message");<br/>    info!("Information message");<br/>    debug!("Debugging message");<br/>}</pre></div>
</div>
<p>In a Unix-like console, after having run <kbd>cargo build</kbd>, execute the following command:</p>
<pre style="padding-left: 30px"><strong>RUST_LOG=debug ./target/debug/use_env_logger</strong></pre>
<p>It will print something like the following:</p>
<pre style="padding-left: 30px"><strong>[2020-01-11T15:43:44Z ERROR logging] Error message</strong><br/><strong>[2020-01-11T15:43:44Z WARN logging] Warning message</strong><br/><strong>[2020-01-11T15:43:44Z INFO logging] Information message</strong><br/><strong>[2020-01-11T15:43:44Z DEBUG logging] Debugging message</strong></pre>
<p>By typing <kbd>RUST_LOG=debug</kbd> at the beginning of the command, you defined the temporary environment variable <kbd>RUST_LOG</kbd>, with <kbd>debug</kbd> as its value. The <kbd>debug</kbd> level is the highest, and hence all logging statements are performed. Instead, if you execute the following command, only the first three lines will be printed, as the <kbd>info</kbd> level is not detailed enough to print debug messages:</p>
<pre style="padding-left: 30px"><strong>RUST_LOG=info ./target/debug/</strong><strong>use_env_logger</strong></pre>
<p>Similarly, if you execute the following command, only the first two lines will be printed, as the <kbd>warn</kbd> level is not detailed enough to print either the <kbd>debug</kbd> or the <kbd>info</kbd> messages:</p>
<pre style="padding-left: 30px"><strong>RUST_LOG=warn ./target/debug/</strong><strong>use_env_logger</strong></pre>
<p>If you execute one or the other of the following commands, only the first line will be printed, as the default logging level is <kbd>error</kbd>:</p>
<ul>
<li><kbd>RUST_LOG=error ./target/debug/use_env_logger</kbd></li>
<li><kbd>./target/debug/use_env_logger</kbd><strong><br/></strong></li>
</ul>
<h2 id="uuid-a65bd33c-0ceb-42d2-aa34-3b2475a14cd2">Initializing static variables at runtime – the lazy_static crate</h2>
<p class="mce-root">It's well known that Rust does not allow <em>mutable static variables in safe code</em>. Immutable static variables are allowed in safe code, but they must be initialized by constant expressions, possibly by invoking <kbd>const fn</kbd> functions. However, the compiler must be able to evaluate the initialization expression of any static variable.</p>
<p class="mce-root">Sometimes, however, there is a need to initialize a static variable at runtime, because the initial value depends on an input, such as a command-line argument or a configuration option. In addition, if the initialization of a variable takes a long time, instead of initializing it at the start of the program, it may be better to initialize it only the first time the variable is used. This technique is called <strong>lazy initialization</strong>.</p>
<p class="mce-root">There is a small crate, named <kbd>lazy_static</kbd>, that contains only one macro, which has the same name as the crate. This can be used to solve the issue mentioned previously. Its use is shown in the following project (named <kbd>use_lazy_static</kbd>):</p>
<div><pre style="padding-left: 30px">use lazy_static::lazy_static;<br/>use std::collections::HashMap;<br/><br/>lazy_static! {<br/>    static ref DICTIONARY: HashMap&lt;u32, &amp;'static str&gt; = {<br/>        let mut m = HashMap::new();<br/>        m.insert(11, "foo");<br/>        m.insert(12, "bar");<br/>        println!("Initialized");<br/>        m<br/>    };<br/>}<br/><br/>fn main() {<br/>    println!("Started");<br/>    println!("DICTIONARY contains {:?}", *DICTIONARY);<br/>    println!("DICTIONARY contains {:?}", *DICTIONARY);<br/>}</pre></div>
<p>This will print the following output:</p>
<pre style="padding-left: 30px"><strong>Started</strong><br/><strong>Initialized</strong><br/><strong>DICTIONARY contains {12: "bar", 11: "foo"}</strong><br/><strong>DICTIONARY contains {12: "bar", 11: "foo"}</strong></pre>
<p>As you can see, the <kbd>main</kbd> function starts first. Then, it tries to access the <kbd>DICTIONARY</kbd> static variable, and that access causes the initialization of variables. The initialized value, which is a reference, is then dereferenced and printed.</p>
<p>The last statement, which is identical to the previous one, does not perform the initialization again, as you can see by the fact that the <kbd>Initialized</kbd> text is not printed again.</p>
<h2 id="uuid-4750f1c0-4ffc-4dc1-bb7f-ccdd1020789e">Parsing the command line – the structopt crate</h2>
<p>The command-line arguments of any program are easily accessible through the <kbd>std::env::args()</kbd> iterator. However, the code that parses these arguments is actually rather cumbersome. To get more maintainable code, the <kbd>structopt</kbd> crate can be used, as shown in the following project (named <kbd>use_structopt</kbd>):</p>
<div><pre>use std::path::PathBuf;<br/>use structopt::StructOpt;<br/><br/>#[derive(StructOpt, Debug)]<br/>struct Opt {<br/>    /// Activate verbose mode<br/>    #[structopt(short = "v", long = "verbose")]<br/>    verbose: bool,<br/><br/>    /// File to generate<br/>    #[structopt(short = "r", long = "result", parse(from_os_str))]<br/>    result_file: PathBuf,<br/><br/>    /// Files to process<br/>    #[structopt(name = "FILE", parse(from_os_str))]<br/>    files: Vec&lt;PathBuf&gt;,<br/>}<br/><br/>fn main() {<br/>    println!("{:#?}", Opt::from_args());<br/>}</pre>
<p>If you execute the <kbd>cargo run input1.txt input2.txt -v --result res.xyz</kbd> command, you should get the following output:</p>
<pre>Opt {<br/>    verbose: true,<br/>    result_file: "res.txt",<br/>    files: [<br/>        "input1.tx",<br/>        "input2.txt"<br/>    ]<br/>}</pre>
<p>As you can see, the filenames <kbd>input1.txt</kbd> and <kbd>input2.txt</kbd> have been loaded into the <kbd>files</kbd> field of the structure. The <kbd>--result res.xyz</kbd> argument caused the <kbd>result_file</kbd> field to be filled, and the <kbd>-v</kbd> argument caused the <kbd>verbose</kbd> field to be set to <kbd>true</kbd>, instead of the default <kbd>false</kbd>.</p>
</div>
<h1 id="uuid-044ebd8b-6af5-4218-a2ad-3e1d768e1ed9">Summary</h1>
<div><p>In this chapter, we introduced the new Rust 2018 edition. We learned about the kind of projects that are going to be described in this book. We then took a quick look at four useful crates which you can apply in your Rust code.</p>
<p>In the next chapter, we will learn how to store or retrieve data to and from a file, a database, or another application.</p>
</div>
<h1 id="uuid-58dd1cde-adf4-4603-a113-c8267e62761f">Questions</h1>
<ol>
<li>Is there an official printed book to learn the Rust language?</li>
<li>How long was the longest primitive Rust integer in 2015, and how long was it at the end of 2018?</li>
<li>Which are the four domain working groups at the end of 2018?</li>
<li>What is the purpose of the Clippy utility?</li>
<li>What is the purpose of the <kbd>rustfix</kbd> utility?</li>
<li>Write a program that generates 10 pseudo-random <kbd>f32</kbd> numbers between 100 and 400.</li>
<li>Write a program that generates 10 pseudo-random <kbd>i32</kbd> numbers between 100 and 400 (without truncating or rounding the numbers generated by the previous exercise).</li>
<li>Write a program that creates a static vector containing all squared integers between 1 and 200.</li>
<li>Write a program that emits a warning message and an info message, and then run it so that only the warning message appears.</li>
<li>Try to parse a command-line argument that contains a value from 1 to 20, emitting an error message if the value is out of range. The short option should be <kbd>-l</kbd>, and the long option should be <kbd>--level</kbd>.</li>
</ol>


            

            
        
    </body></html>