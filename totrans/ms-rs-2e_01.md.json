["```rs\n1\\. import java.util.stream.Collectors\n2\\. \n3\\. fun main(args: Array<String>) {\n5\\.     // Create a stream of numbers\n6\\.     val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).stream()\n7\\.     val evens = numbers.filter { it -> it % 2 == 0 } \n8\\.     val evenSquares = evens.map { it -> it * it }  \n9\\.     val result = evenSquares.collect(Collectors.toList())\n10\\.    println(result)       // prints [4,16,36,64,100]\n11\\.    \n12\\.    println(evens)\n13\\.    println(evenSquares)\n14\\. }\n```", "```rs\n1\\. fn main() {\n2\\.     let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter();\n3\\.     let evens = numbers.filter(|x| *x % 2 == 0);\n4\\.     let even_squares = evens.clone().map(|x| x * x);\n5\\.     let result = even_squares.clone().collect::<Vec<_>>();\n6\\.     println!(\"{:?}\", result);      // prints [4,16,36,64,100]\n7\\.     println!(\"{:?}\\n{:?}\", evens, even_squares);\n8\\. }\n```", "```rs\n// C++\n\nmutex.lock();                         // Mutex locked, good to go \n // Do super critical stuff\nmutex.unlock();                       // We're done\n```", "```rs\n// Rust\n\nuse std::sync::Mutex;\n\nfn main() {\n    let value = Mutex::new(23);\n    *value.lock().unwrap() += 1;   // modify\n}                                  // unlocks here automatically\n```", "```rs\ncurl https://sh.rustup.rs -sSf | sh\n```", "```rs\n// greet.rs\n\n1\\. use std::env;\n2\\. \n3\\. fn main() {\n4\\.    let name = env::args().skip(1).next();\n5\\.    match name {\n6\\.       Some(n) => println!(\"Hi there ! {}\", n),\n7\\.       None => panic!(\"Didn't receive any name ?\")\n8\\.    }\n9\\. }\n```", "```rs\n// variables.rs\n\nfn main() {\n    let target = \"world\";\n    let mut greeting = \"Hello\";\n    println!(\"{}, {}\", greeting, target);\n    greeting = \"How are you doing\";\n    target = \"mate\";\n    println!(\"{}, {}\", greeting, target);\n}\n```", "```rs\n$ rustc variables.rs\n$ ./variables\nHello, world\nHow are you doing, mate\n```", "```rs\n// functions.rs\n\nfn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n\nfn main() {\n    let a: u64 = 17;\n    let b = 3;\n    let result = add(a, b);\n    println!(\"Result {}\", result);\n}\n```", "```rs\n// function_mut.rs\n\nfn increase_by(mut val: u32, how_much: u32) {\n    val += how_much;\n    println!(\"You made {} points\", val);\n}\n\nfn main() {\n    let score = 2048;\n    increase_by(score, 30);\n}\n```", "```rs\n$ rustc function_mut.rs \n$ ./function_mut \nYou made 2078 points\n```", "```rs\n// closures.rs\n\nfn main() {\n    let doubler = |x| x * 2;\n    let value = 5;\n    let twice = doubler(value);\n    println!(\"{} doubled is {}\", value, twice);\n\n    let big_closure = |b, c| {\n        let z = b + c;\n        z * twice\n    };\n\n    let some_number = big_closure(1, 2);\n    println!(\"Result from closure: {}\", some_number);\n}\n```", "```rs\n// strings.rs\n\nfn main() {\n    let question = \"How are you ?\";            // a &str type\n    let person: String = \"Bob\".to_string();\n    let namaste = String::from(\"नमस्ते\");        // unicodes yay!\n\n    println!(\"{}! {} {}\", namaste, question, person);\n}\n```", "```rs\n// if_else.rs\n\nfn main() {\n    let rust_is_awesome = true;\n    if rust_is_awesome {\n        println!(\"Indeed\");\n    } else {\n        println!(\"Well, you should try Rust !\");\n    }\n}\n```", "```rs\n// if_assign.rs\n\nfn main() {\n    let result = if 1 == 2 { \n        \"Wait, what ?\" \n    } else { \n        \"Rust makes sense\" \n    };\n\n    println!(\"You know what ? {}.\", result);\n}\n```", "```rs\n// if_else_no_value.rs\n\nfn main() { \n    let result = if 1 == 2 { \n        \"Nothing makes sense\"; \n    } else { \n        \"Sanity reigns\"; \n    };\n\n    println!(\"Result of computation: {:?}\", result); \n}\n```", "```rs\n// match_expression.rs\n\nfn req_status() -> u32 {\n    200\n}\n\nfn main() {\n    let status = req_status();\n    match status {\n        200 => println!(\"Success\"),\n        404 => println!(\"Not Found\"),\n        other => {\n            println!(\"Request failed with code: {}\", other);\n            // get response from cache\n        }\n    }\n}\n```", "```rs\n// loops.rs \n\nfn main() { \n    let mut x = 1024;\n    loop { \n        if x < 0 { \n            break; \n        } \n        println!(\"{} more runs to go\", x); \n        x -= 1; \n    } \n}\n```", "```rs\n// loop_labels.rs\n\nfn silly_sub(a: i32, b: i32) -> i32 {\n    let mut result = 0;\n    'increment: loop {\n        if result == a {\n            let mut dec = b;\n            'decrement: loop {\n                if dec == 0 {\n                    // breaks directly out of 'increment loop\n                    break 'increment;\n                } else {\n                    result -= 1;\n                    dec -= 1;\n                }\n            }\n        } else {\n            result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let a = 10;\n    let b = 4;\n    let result = silly_sub(a, b);\n    println!(\"{} minus {} is {}\", a, b, result);\n}\n```", "```rs\n// while.rs \n\nfn main() { \n    let mut x = 1000; \n    while x > 0 { \n        println!(\"{} more runs to go\", x); \n        x -= 1;     \n    }\n}\n```", "```rs\n// for_loops.rs\n\nfn main() {\n    // does not include 10\n    print!(\"Normal ranges: \");\n    for i in 0..10 {\n        print!(\"{},\", i);\n    }\n\n    println!();       // just a newline\n    print!(\"Inclusive ranges: \");\n    // counts till 10\n    for i in 0..=10 {\n        print!(\"{},\", i);\n    }\n}\n```", "```rs\n// unit_struct.rs\n\nstruct Dummy;\n\nfn main() {\n    let value = Dummy;\n}\n```", "```rs\n// tuple_struct.rs \n\nstruct Color(u8, u8, u8);\n\nfn main() {\n    let white = Color(255, 255, 255);\n\n    // You can pull them out by index\n    let red = white.0;\n    let green = white.1;\n    let blue = white.2;\n\n    println!(\"Red value: {}\", red);\n    println!(\"Green value: {}\", green);\n    println!(\"Blue value: {}\\n\", blue);\n\n    let orange = Color(255, 165, 0);\n\n    // You can also destructure the fields directly\n    let Color(r, g, b) = orange;\n    println!(\"R: {}, G: {}, B: {} (orange)\", r, g, b);\n\n    // Can also ignore fields while destructuring\n    let Color(r, _, b) = orange;\n}\n```", "```rs\n// structs.rs\n\nstruct Player {\n    name: String,\n    iq: u8,\n    friends: u8,\n    score: u16\n}\n\nfn bump_player_score(mut player: Player, score: u16) {\n    player.score += 120;\n    println!(\"Updated player stats:\");\n    println!(\"Name: {}\", player.name);\n    println!(\"IQ: {}\", player.iq);\n    println!(\"Friends: {}\", player.friends);\n    println!(\"Score: {}\", player.score);\n}\n\nfn main() {\n    let name = \"Alice\".to_string();\n    let player = Player { name,\n                          iq: 171,\n                          friends: 134,\n                          score: 1129 };\n\n   bump_player_score(player, 120);\n}\n```", "```rs\n// enums.rs\n\nenum Direction { \n    N, \n    E, \n    S, \n    W\n}\n\nenum PlayerAction {\n    Move {\n        direction: Direction,\n        speed: u8\n    },\n    Wait, \n    Attack(Direction)   \n}\n\nfn main() {\n    let simulated_player_action = PlayerAction::Move {\n        direction: Direction::N,\n        speed: 2,\n    };\n    match simulated_player_action {\n        PlayerAction::Wait => println!(\"Player wants to wait\"),\n        PlayerAction::Move { direction, speed } => {\n          println!(\"Player wants to move in direction {:?} with speed {}\",\n                direction, speed)\n        }\n        PlayerAction::Attack(direction) => {\n            println!(\"Player wants to attack direction {:?}\", direction)\n        }\n    };\n}\n```", "```rs\n// struct_methods.rs\n\nstruct Player {\n    name: String,\n    iq: u8,\n    friends: u8\n}\n\nimpl Player {\n    fn with_name(name: &str) -> Player {\n        Player {\n            name: name.to_string(),\n            iq: 100,\n            friends: 100\n        }\n    }\n\n    fn get_friends(&self) -> u8 {\n        self.friends\n    }\n\n    fn set_friends(&mut self, count: u8) {\n        self.friends = count;\n    }\n}\n\nfn main() {\n    let mut player = Player::with_name(\"Dave\");\n    player.set_friends(23);\n    println!(\"{}'s friends count: {}\", player.name, player.get_friends());\n    // another way to call instance methods.\n    let _ = Player::get_friends(&player);\n}\n```", "```rs\n      Player::with_name(\"Dave\");\n```", "```rs\n      let player = Player::with_name(\"Dave\");\n      player.get_friends();\n```", "```rs\n// enum_methods.rs\n\nenum PaymentMode {\n    Debit,\n    Credit,\n    Paypal\n}\n\n// Bunch of dummy payment handlers\n\nfn pay_by_credit(amt: u64) {\n    println!(\"Processing credit payment of {}\", amt);\n}\nfn pay_by_debit(amt: u64) {\n    println!(\"Processing debit payment of {}\", amt);\n}\nfn paypal_redirect(amt: u64) {\n    println!(\"Redirecting to paypal for amount: {}\", amt);\n}\n\nimpl PaymentMode {\n    fn pay(&self, amount: u64) {\n        match self {\n            PaymentMode::Debit => pay_by_debit(amount),\n            PaymentMode::Credit => pay_by_credit(amount),\n            PaymentMode::Paypal => paypal_redirect(amount)\n        }\n    }\n}\n\nfn get_saved_payment_mode() -> PaymentMode {\n    PaymentMode::Debit\n}\n\nfn main() {\n    let payment_mode = get_saved_payment_mode();\n    payment_mode.pay(512);\n}\n```", "```rs\n// arrays.rs\n\nfn main() { \n    let numbers: [u8; 10] = [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]; \n    let floats = [0.1f64, 0.2, 0.3]; \n\n    println!(\"Number: {}\", numbers[5]);\n    println!(\"Float: {}\", floats[2]);\n}\n```", "```rs\n// tuples.rs\n\nfn main() { \n    let num_and_str: (u8, &str) = (40, \"Have a good day!\");\n    println!(\"{:?}\", num_and_str);\n    let (num, string) = num_and_str;\n    println!(\"From tuple: Number: {}, String: {}\", num, string);\n}\n```", "```rs\n// vec.rs\n\nfn main() {\n    let mut numbers_vec: Vec<u8> = Vec::new(); \n    numbers_vec.push(1); \n    numbers_vec.push(2); \n\n    let mut vec_with_macro = vec![1]; \n    vec_with_macro.push(2);\n    let _ = vec_with_macro.pop();    // value ignored with `_`\n\n    let message = if numbers_vec == vec_with_macro {\n        \"They are equal\"\n    } else {\n        \"Nah! They look different to me\"\n    };\n\n    println!(\"{} {:?} {:?}\", message, numbers_vec, vec_with_macro); \n}\n```", "```rs\n// hashmaps.rs\n\nuse std::collections::HashMap; \n\nfn main() { \n    let mut fruits = HashMap::new(); \n    fruits.insert(\"apple\", 3);\n    fruits.insert(\"mango\", 6);\n    fruits.insert(\"orange\", 2);\n    fruits.insert(\"avocado\", 7);\n    for (k, v) in &fruits {\n        println!(\"I got {} {}\", v, k);\n    }\n\n    fruits.remove(\"orange\");\n    let old_avocado = fruits[\"avocado\"];\n    fruits.insert(\"avocado\", old_avocado + 5);\n    println!(\"\\nI now have {} avocados\", fruits[\"avocado\"]);\n}\n```", "```rs\n// slices.rs\n\nfn main() {\n    let mut numbers: [u8; 4] = [1, 2, 3, 4];\n    {\n        let all: &[u8] = &numbers[..];\n        println!(\"All of them: {:?}\", all);\n    }\n\n    {\n        let first_two: &mut [u8] = &mut numbers[0..2];\n        first_two[0] = 100;\n        first_two[1] = 99;\n    }\n\n    println!(\"Look ma! I can modify through slices: {:?}\", numbers);\n}\n```", "```rs\n// word_counter.rs\n\nuse std::env;\nuse std::fs::File;\nuse std::io::prelude::BufRead;\nuse std::io::BufReader;\n\n#[derive(Debug)]\nstruct WordCounter(HashMap<String, u64>);\n\nimpl WordCounter {\n    fn new() -> WordCounter {\n        WordCounter(HashMap::new());\n    }\n\n    fn increment(word: &str) {\n        let key = word.to_string();\n        let count = self.0.entry(key).or_insert(0);\n        *count += 1;\n    }\n\n    fn display(self) {\n        for (key, value) in self.0.iter() {\n            println!(\"{}: {}\", key, value);\n        }\n    }\n}\n\nfn main() {\n    let arguments: Vec<String> = env::args().collect();\n    let filename = arguments[1];\n    println!(\"Processing file: {}\", filename);\n\n    let file = File::open(filenam).expect(\"Could not open file\");\n    let reader = BufReader::new(file);\n\n    let mut word_counter = WordCounter::new();\n\n    for line in reader.lines() {\n        let line = line.expect(\"Could not read line\");\n        let words = line.split(\" \");\n        for word in words {\n            if word == \"\" {\n                continue\n            } else {\n                word_counter.increment(word);\n            }\n        }\n    }\n\n    word_counter.display();\n}\n\n```"]