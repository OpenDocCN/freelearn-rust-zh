["```rs\nasync fn hello() {\n    println!(\"Hello, world!\");\n}\nfn main() {\n    hello();\n}\n```", "```rs\nwarning: unused implementer of `Future` that must be used\n --> src/main.rs:9:5\n  |\n9 |     hello();\n  |     ^^^^^^^^\n  |\n  = note: `#[warn(unused_must_use)]` on by default\n  = note: futures do nothing unless you `.await` or poll them\n```", "```rs\n8 | fn main() {\n  |    ---- this is not `async`\n9 |     hello().await;\n  |            ^^^^^^ only allowed inside `async`\n                      functions and blocks\n```", "```rs\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\n```", "```rs\nuse tokio::main;\nuse std::error::Error;\n```", "```rs\n#[main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let outcome = hello().await;\n    Ok(outcome)\n}\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    hello().await;\n    println!(\"program has run\");\n}\n```", "```rs\nHello, world!\nprogram has run\n```", "```rs\nasync fn hello(input_int: i32) -> i32 {\n    println!(\"Hello, world! {}\", input_int);\n    return input_int\n}\n#[tokio::main]\nasync fn main() {\n    let one = hello(1);\n    let two = hello(2);\n    let three = hello(3);\n    let one = one.await;\n    let three = three.await;\n    let two = two.await;\n    println!(\"{} {} {}\", one, two, three);\n}\n```", "```rs\nHello, world! 1\nHello, world! 3\nHello, world! 2\n1 2 3\n```", "```rs\nuse std::time::Instant;\nuse std::{thread, time};\n```", "```rs\nasync fn hello(input_int: i32) -> i32 {\n    let five_seconds = time::Duration::from_secs(5);\n    tokio::time::sleep(five_seconds).await;\n    println!(\"Hello, world! {}\", input_int);\n    input_int\n}\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    let now = Instant::now();\n    let one = tokio::spawn({\n        hello(1)\n    });\n    let two = tokio::spawn({\n        hello(2)\n    });\n    let three = tokio::spawn({\n        hello(3)\n    });\n    one.await;\n    two.await;\n    three.await;\n    let elapsed = now.elapsed();\n    println!(\"Elapsed: {:.2?}\", elapsed);\n}\n```", "```rs\nHello, world! 2\nHello, world! 3\nHello, world! 1\nElapsed: 5.00s\n```", "```rs\n#[tokio::main(flavor = \"multi_thread\", worker_threads = 4)]\nasync fn main() {\n    ...\n}\n```", "```rs\n#[tokio::main(flavor = \"multi_thread\", worker_threads = 4)]\nasync fn main() {\n    let now = Instant::now();\n    let mut buffer = Vec::new();\n    for i in 0..20 {\n        let handle = tokio::spawn(async move {\n            hello(i).await\n        });\n        buffer.push(handle);\n    }\n    for i in buffer {\n        i.await;\n    }\n    let elapsed = now.elapsed();\n    println!(\"Elapsed: {:.2?}\", elapsed);\n}\n```", "```rs\nuse tokio::sync::mpsc;\n#[tokio::main]\nasync fn main() {\n    ...\n}\n```", "```rs\nlet (tx, mut rx) = mpsc::channel(1);\ntokio::spawn(async move {\n    for i in 0..10 {\n        if let Err(e) = tx.send(i).await {\n            println!(\"send error: {:?}\", e);\n            break;\n        }\n        println!(\"sent: {}\", i);\n    }\n});\n```", "```rs\nwhile let Some(i) = rx.recv().await {\n    println!(\"got: {}\", i);\n}\n```", "```rs\nsent: 0\ngot: 0\nsent: 1\ngot: 1\nsent: 2\ngot: 2\n...\n```", "```rs\npub fn channel<T>(buffer: usize) -> (Sender<T>, Receiver<T>) {\n    assert!(buffer > 0, \"mpsc bounded channel requires\n            buffer > 0\");\n    let semaphore = (semaphore::Semaphore::new(buffer),\n                     buffer);\n    let (tx, rx) = chan::channel(semaphore);\n    let tx = Sender::new(tx);\n    let rx = Receiver::new(rx);\n    (tx, rx)\n}\n```", "```rs\n#[derive(Debug, Clone)]\npub enum Order {\n    BUY,\n    SELL\n}\n#[derive(Debug, Clone)]\npub struct Message {\n    pub order: Order,\n    pub ticker: String,\n    pub amount: f32\n}\n```", "```rs\nlet (tx, mut rx) = mpsc::channel::<Message>(1);\nlet orders = [\n    Message { order: Order::BUY,\n              amount: 5.5, ticker: \"BYND\".to_owned()},\n    Message { order: Order::BUY,\n              amount: 5.5, ticker: \"NET\".to_owned()},\n    Message { order: Order::BUY,\n              amount: 5.5, ticker: \"PLTR\".to_owned()},\n];\n```", "```rs\ntokio::spawn(async move {\n    for order in orders {\n        if let Err(e) = tx.send(order.clone()).await {\n            println!(\"send error: {:?}\", e);\n            return;\n        }\n        println!(\"sent: {:?}\", order);\n    }\n});\nwhile let Some(i) = rx.recv().await {\n    println!(\"got: {:?}\", i);\n}\n```", "```rs\nsent: Message { order: \"BUY\", ticker: \"BYND\", amount: 5.5 }\nsent: Message { order: \"BUY\", ticker: \"NET\", amount: 5.5 }\ngot: Message { order: \"BUY\", ticker: \"BYND\", amount: 5.5 }\ngot: Message { order: \"BUY\", ticker: \"NET\", amount: 5.5 }\nsent: Message { order: \"BUY\", ticker: \"PLTR\", amount: 5.5 }\ngot: Message { order: \"BUY\", ticker: \"PLTR\", amount: 5.5 }\n```", "```rs\nsent: Message { order: \"BUY\", ticker: \"BYND\", amount: 5.5 }\nsent: Message { order: \"BUY\", ticker: \"NET\", amount: 5.5 }\nsent: Message { order: \"BUY\", ticker: \"PLTR\", amount: 5.5 }\ngot: Message { order: \"BUY\", ticker: \"BYND\", amount: 5.5 }\ngot: Message { order: \"BUY\", ticker: \"NET\", amount: 5.5 }\ngot: Message { order: \"BUY\", ticker: \"PLTR\", amount: 5.5 }\n```", "```rs\nuse tokio::sync::{mpsc, oneshot, mpsc::Sender};\n```", "```rs\n#[derive(Debug)]\npub struct Message {\n    pub order: Order,\n    pub ticker: String,\n    pub amount: f32,\n    pub respond_to: oneshot::Sender<u32>\n}\n```", "```rs\npub struct OrderBookActor {\n    pub receiver: mpsc::Receiver<Message>,\n    pub total_invested: f32,\n    pub investment_cap: f32\n}\n```", "```rs\nimpl OrderBookActor {\n    fn new(receiver: mpsc::Receiver<Message>,\n           investment_cap: f32) -> Self {\n        . . .\n    }\n    fn handle_message(&mut self, message: Message) {\n        . . .\n    }\n    async fn run(mut self) {\n        . . .\n    }\n}\n```", "```rs\nfn new(receiver: mpsc::Receiver<Message>, investment_cap:\n       f32) -> Self {\n    return OrderBookActor {\n        receiver,\n        total_invested: 0.0,\n        investment_cap\n    }\n}\n```", "```rs\nfn handle_message(&mut self, message: Message) {\n    if message.amount + self.total_invested >=\n        self.investment_cap {\n        println!(\"rejecting purchase, total invested: {}\",\n                  self.total_invested);\n        let _ = message.respond_to.send(0);\n    } else {\n        self.total_invested += message.amount;\n        println!(\"processing purchase, total invested: {}\",\n                  self.total_invested);\n        let _ = message.respond_to.send(1);\n    }\n}\n```", "```rs\nasync fn run(mut self) {\n    println!(\"actor is running\");\n    while let Some(msg) = self.receiver.recv().await {\n        self.handle_message(msg);\n    }\n}\n```", "```rs\nstruct BuyOrder {\n    pub ticker: String,\n    pub amount: f32,\n    pub order: Order,\n    pub sender: Sender<Message>\n}\n```", "```rs\nimpl BuyOrder {\n    fn new(amount: f32, ticker: String,\n           sender: Sender<Message>) -> Self {\n        . . .\n    }\n    async fn send(self) {\n        . . .\n    }\n}\n```", "```rs\nfn new(amount: f32, ticker: String,\n       sender: Sender<Message>) -> Self {\n    return BuyOrder { ticker, amount,\n                      order: Order::BUY, sender }\n}\n```", "```rs\nasync fn send(self) {\n    let (send, recv) = oneshot::channel();\n    let message = Message { order: self.order,\n                            amount: self.amount,\n                            ticker: self.ticker,\n                            respond_to: send};\n    let _ = self.sender.send(message).await;\n    match recv.await {\n        Err(e) => println!(\"{}\", e),\n        Ok(outcome) => println!(\"here is the outcome: {}\",\n                                 outcome)\n    }\n}\n```", "```rs\n#[tokio::main]\nasync fn main() {\n    let (tx, rx) = mpsc::channel::<Message>(1);\n    let tx_one = tx.clone();\n    tokio::spawn(async move {\n        . . .\n    });\n    tokio::spawn(async move {\n        . . .\n    });\n    let actor = OrderBookActor::new(rx, 20.0);\n    actor.run().await;\n}\n```", "```rs\ntokio::spawn(async move {\n    for _ in 0..5 {\n        let buy_actor = BuyOrder::new(5.5,\n                                      \"BYND\".to_owned(),\n                                      tx_one.clone());\n        buy_actor.send().await;\n    }\n    drop(tx_one);\n});\ntokio::spawn(async move {\n    for _ in 0..5 {\n        let buy_actor = BuyOrder::new(5.5,\n                                      \"PLTR\".to_owned(),\n                                      tx.clone());\n        buy_actor.send().await;\n    }\n    drop(tx);\n});\n```", "```rs\nprocessing purchase, total invested: 5.5\nhere is the outcome: 1\nprocessing purchase, total invested: 11\nprocessing purchase, total invested: 16.5\nhere is the outcome: 1\nhere is the outcome: 1\nrejecting purchase, total invested: 16.5\nhere is the outcome: 0\nrejecting purchase, total invested: 16.5\nhere is the outcome: 0\n. . .\n```"]