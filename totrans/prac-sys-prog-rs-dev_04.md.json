["```rs\ncargo new –-lib template-engine\n```", "```rs\n// Each line in input can be of one of following types\n#[derive(PartialEq, Debug)]\npub enum ContentType {\n    Literal(String),\n    TemplateVariable(ExpressionData),\n    Tag(TagType),\n    Unrecognized,\n}\n```", "```rs\n#[derive(PartialEq, Debug)]\npub enum TagType {\n    ForTag,\n    IfTag,\n}\n```", "```rs\n#[derive(PartialEq, Debug)]\npub struct ExpressionData {\n    pub head: Option<String>,\n    pub variable: String,\n    pub tail: Option<String>,\n}\n```", "```rs\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    }\n    ```", "```rs\n    #[test]\n    fn check_literal_test() {\n        let s = \"<h1>Hello world</h1>\";\n        assert_eq!(ContentType::Literal(s.to_string()),     \n            get_content_type(s));\n    }\n```", "```rs\n    #[test]\n    fn check_template_var_test() {\n        let content = ExpressionData {\n            head: Some(\"Hi \".to_string()),\n            variable: \"name\".to_string(),\n            tail: Some(\" ,welcome\".to_string()),\n        };\n        assert_eq!(\n            ContentType::TemplateVariable(content),\n            get_content_type(\"Hi {{name}} ,welcome\")\n        );\n    }\n```", "```rs\n    #[test]\n    fn check_for_tag_test() {\n        assert_eq!(\n            ContentType::Tag(TagType::ForTag),\n            get_content_type(\"{% for name in names %} \n                ,welcome\")\n        );\n    }\n```", "```rs\n    #[test]\n    fn check_if_tag_test() {\n        assert_eq!(\n            ContentType::Tag(TagType::IfTag),\n            get_content_type(\"{% if name == 'Bob' %}\")\n        );\n    }\n```", "```rs\npub fn get_content_type(input_line: &str) -> ContentType {\n    let is_tag_expression = check_matching_pair\n        (&input_line, \"{%\", \"%}\");\n    let is_for_tag = (check_symbol_string(&input_line, \n        \"for\")\n        && check_symbol_string(&input_line, \"in\"))\n        || check_symbol_string(&input_line, \"endfor\");\n    let is_if_tag =\n        check_symbol_string(&input_line, \"if\") || \n            check_symbol_string(&input_line, \"endif\");\n\n    let is_template_variable = check_matching_pair\n        (&input_line, \"{{\", \"}}\");\n    let return_val;\n\n    if is_tag_expression && is_for_tag {\n        return_val = ContentType::Tag(TagType::ForTag);\n    } else if is_tag_expression && is_if_tag {\n        return_val = ContentType::Tag(TagType::IfTag);\n    } else if is_template_variable {\n        let content = get_expression_data(&input_line);\n        return_val = ContentType::TemplateVariable\n            (content);\n    } else if !is_tag_expression && !is_template_variable {\n        return_val = ContentType::Literal\n            (input_line.to_string());\n    } else {\n        return_val = ContentType::Unrecognized;\n    }\n    return_val\n}\n```", "```rs\n        #[test]\n        fn check_symbol_string_test() {\n            assert_eq!(true, check_symbol_string(\n                \"{{Hello}}\", \"{{\"));\n        }\n    ```", "```rs\n    pub fn check_symbol_string(input: &str, symbol: &str)  \n        -> bool {\n        input.contains(symbol)\n    }\n    ```", "```rs\n        #[test]\n        fn '{{' and '}}', to this function, and check if both are contained within another string expression, \"{{Hello}}\".Here is the code for the function:\n\n    ```", "```rs\n\n    In this function, we are checking if the two matching tags are contained within the input string.\n    ```", "```rs\n        #[test]\n        fn check_get_expression_data_test() {\n            let expression_data = ExpressionData {\n                head: Some(\"Hi \".to_string()),\n                variable: \"name\".to_string(),\n                tail: Some(\" ,welcome\".to_string()),\n            };\n\n            assert_eq!(expression_data, \n                get_expression_data(\"Hi {{name}} \n                ,welcome\"));\n        }\n    ```", "```rs\n    pub fn get_expression_data(input_line: &str) -> \n        ExpressionData {\n        let (_h, i) = get_index_for_symbol(input_line, \n        '{');\n        let head = input_line[0..i].to_string();\n        let (_j, k) = get_index_for_symbol(input_line, \n            '}');\n        let variable = input_line[i + 1 + 1..k]\n            .to_string();\n        let tail = input_line[k + 1 + 1..].to_string();\n\n        ExpressionData {\n            head: Some(head),\n            variable: variable,\n            tail: Some(tail),\n        }\n    }\n    ```", "```rs\n        #[test]\n        fn char_indices() method on the slice available as part of the standard library, and converts the input string into an iterator that is capable of tracking indices. We then iterate over the input string and return the index of the symbol when found:\n\n    ```", "```rs\n\n    ```", "```rs\n        let mut context: HashMap<String, String> = \n            HashMap::new();\n        context.insert(\"name\".to_string(), \n            \"Bob\".to_string());\n        context.insert(\"city\".to_string(), \n            \"Boston\".to_string());\n    ```", "```rs\n        for line in io::stdin().lock().lines() {\n            match get_content_type(&line?.clone()) {\n                ContentType::TemplateVariable(content) => {\n                    let html = generate_html_template_var\n                        (content, context.clone());\n                    println!(\"{}\", html);\n                }\n                ContentType::Literal(text) => println!\n                    (\"{}\", text),\n                ContentType::Tag(TagType::ForTag) => \n                    println!(\"For Tag not implemented\"),\n                ContentType::Tag(TagType::IfTag) => \n                    println!(\"If Tag not implemented\"),\n                ContentType::Unrecognized => \n                    println!(\"Unrecognized input\"),\n            }\n        }\n    ```", "```rs\n    for line in io::stdin().lock().lines() {..}\n    ```", "```rs\nuse std::collections::HashMap;\nuse std::io;\nuse std::io::BufRead;\nuse template_engine::*;\n\nfn main() {\n    let mut context: HashMap<String, String> = \n        HashMap::new();\n    context.insert(\"name\".to_string(), \"Bob\".to_string());\n    context.insert(\"city\".to_string(),     \n        \"Boston\".to_string());\n\n    for line in io::stdin().lock().lines() {\n        match get_content_type(&line.unwrap().clone()) {\n            ContentType::TemplateVariable(content) => {\n                let html = generate_html_template_var\n                    (content, context.clone());\n                println!(\"{}\", html);\n            }\n            ContentType::Literal(text) => println!(\"{}\",    \n                text),\n            ContentType::Tag(TagType::ForTag) => \n                println!(\"For Tag not implemented\"),\n            ContentType::Tag(TagType::IfTag) => \n                println!(\"If Tag not implemented\"),\n            ContentType::Unrecognized => \n                println!(\"Unrecognized input\"),\n        }\n    }\n}\n```", "```rs\nuse std::collections::HashMap;\npub fn generate_html_template_var(\n    content: ExpressionData,\n    context: HashMap<String, String>,\n) -> String {\n    let mut html = String::new();\n\n    if let Some(h) = content.head {\n        html.push_str(&h);\n    }\n\n    if let Some(val) = context.get(&content.variable) {\n        html.push_str(&val);\n    }\n\n    if let Some(t) = content.tail {\n        html.push_str(&t);\n    }\n\n    html\n}\n```", "```rs\n    >cargo run\n    ```"]