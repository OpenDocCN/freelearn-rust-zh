- en: Hello Rust!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到Rust！
- en: First, thank you for picking up a copy of this book! Many of you will only have
    talked about the topic of algorithms and data structures back in university. In
    fact, regardless of whether this is your first endeavor in programming or not,
    we worked hard to make this book a great learning experience. Our primary focus
    will be the unique influence of Rust on algorithm and data structure design, so
    we would like to start with a recap of important fundamentals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，感谢您拿起这本书！你们中的许多人可能只在大学时讨论过算法和数据结构这个话题。实际上，无论这是您编程生涯的第一次尝试与否，我们都努力使这本书成为一次极好的学习体验。我们的主要关注点将是Rust对算法和数据结构设计的独特影响，因此我们想从回顾一些重要的基础知识开始。
- en: 'Starting off with the Rust 2018 edition changes, we will cover how borrowing
    and ownership, mutability, and concurrency influence how and where data can be
    held, and what algorithms can be executed. In this chapter, you can look forward
    to learning about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从Rust 2018版的变化开始，我们将探讨借用和所有权、可变性以及并发如何影响数据可以存储的位置以及可以执行哪些算法。在本章中，您可以期待学习以下内容：
- en: A quick refresh on Rust and what awaits in the 2018 edition (Rust 1.31)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速回顾Rust以及2018版（Rust 1.31）中期待的内容
- en: The latest and greatest about borrowing and ownership
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于借用和所有权的最新和最佳内容
- en: How we can leverage concurrency and mutability properly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何正确利用并发和可变性
- en: References (not pointers!) to where Rust lives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向Rust所在之处的引用（不是指针！）
- en: Rust in 2018
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2018年的Rust
- en: How old is Rust? It started off in 2006 as a side project of Graydon Hoare,
    an engineer at Mozilla, and was later (in 2009) adopted by the company. Fast forward
    to less than a decade later to May 15, 2015, and the Rust team announced a stable
    version 1.0!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有多久了？它始于2006年，是Mozilla工程师Graydon Hoare的一个副项目，后来（在2009年）被公司采纳。快进到不到十年后的2015年5月15日，Rust团队宣布了稳定版本1.0！
- en: During its journey, there have been many features that have been added and removed
    again (for example, a garbage collector, classes, and interfaces) to help it become
    the fast and safe language that it is today.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在其发展过程中，许多特性被添加和移除（例如，垃圾回收器、类和接口），以帮助它成为今天既快速又安全的语言。
- en: Before getting deeper into borrowing and ownership, mutability, concurrency,
    safety, and so on in Rust, we would like to recap some major concepts in Rust
    and why they change architectural patterns significantly.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Rust中的借用和所有权、可变性、并发、安全性等之前，我们想回顾一下Rust的一些主要概念以及它们如何显著改变架构模式。
- en: The 2018 edition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2018年版
- en: Rust in the 2015 edition is essentially the 1.0 version with a few non-breaking
    additions. Between 2015 and 2018, however, features and **Requests for Comments **(**RFCs**),
    Rust's way of changing core features with the community, accumulated, and worries
    about backward compatibility arose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的2015年版基本上是1.0版本，增加了一些非破坏性特性。然而，在2015年和2018年之间，特性和**请求评论（RFCs**）——Rust社区改变核心特性的方式——不断积累，对向后兼容性的担忧也随之产生。
- en: 'With the goal of keeping this compatibility, editions were introduced and,
    with the first additional edition, many major changes made it into the language:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持这种兼容性，引入了版本，并且随着第一个附加版本，许多重大变化被纳入了语言：
- en: Changes to the module path system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块路径系统的变化
- en: '`dyn Trait` and `impl Trait` syntax'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dyn Trait`和`impl Trait`语法'
- en: '`async`/`await` syntax'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`/`await`语法'
- en: Simplifications to the lifetime syntax
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期语法的简化
- en: With these additions, Rust will introduce asynchronous programming into its
    syntax (`async`/`await` keywords) and improve the language's usability. This book
    uses the Rust 2018, released on December 6, 2018 ([https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html))
    edition by default, so all the following snippets will already include these new
    language features!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些新增特性，Rust将异步编程引入其语法（`async`/`await`关键字），并提高了语言的可用性。本书默认使用2018年12月6日发布的Rust
    2018版（[https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)），因此所有以下代码片段都将包含这些新的语言特性！
- en: The Rust language
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust语言
- en: Many of the established programming languages today are multi-paradigm languages,
    but still remain focused on the principles of object orientation. This means that
    they have classes, methods, interfaces, inheritance, and so on, none of which
    can be found in Rust, giving it a steep learning curve for many established developers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: More experienced readers will miss many aspects of what makes Rust an excellent
    language, such as static versus dynamic method invocation, memory layouts, and
    so on. I recognize the importance of those things, yet for brevity and focus chose
    to leave it to you to explore these things further. Check the *Further reading*
    section for resources.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: As a multi-paradigm language, Rust has many functional concepts and paradigms
    that guide it, but they make traditional object-oriented patterns more difficult
    to apply. Other than organizing code without classes and interfaces, there are
    various methods to handle errors, change the code itself, or even work with raw
    pointers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we want to explore a few concepts that make Rust
    unique and have a major influence on the way we develop algorithms and data structures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Objects and behavior
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Organizing code in Rust is a bit different from regular object-oriented languages
    such as C#. There, an object is supposed to change its own state, interfaces are
    simple contract definitions, and specialization is often modeled using class inheritance:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With Rust, this pattern would require constant mutability of any `Door` instance
    (thereby requiring explicit locking for thread safety), and without inheritance
    `GlassDoor` would have to duplicate code, making it harder to maintain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it''s recommended to create traits to implement (shared) behavior.
    Traits have a lot in common with abstract classes in traditional languages (such
    as default implementations of methods/functions), yet any `struct` in Rust can
    (and should) implement several of those traits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This pattern is very common in the standard library, and often third-party libraries
    will even add behavior to existing types by implementing traits in their code
    (also known as extension traits).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Other than a typical class, where data fields and methods are in a single construct,
    Rust emphasizes the separation between those by declaring a `struct` for data
    and an `impl` part for the methods/functions. Traits name and encapsulate behaviors
    so they can easily be imported, shared, and reused.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Going wrong
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than classes, Rust comes without another well-known companion: `null`.
    In the absence of pointers and with a very different memory management model,
    there is no typical `null` pointer/reference.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the language works with `Option` and `Result` types that let developers
    model success or failure. In fact, there is no exception system either, so any
    failed execution of a function should be indicated in the return type. Only in
    rare cases when immediate termination is required does the language provide a
    macro for panicking: `panic!()`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '`Option<T>` and `Result<T, E>` both encapsulate one (`Option<T>`) or two (`Result<T,
    E>`) values that can be returned to communicate an error or whether something
    was found or not. For example, a `find()` function could return `Option<T>`, whereas
    something like `read_file()` would typically have a `Result<T, E>` return type
    to communicate the content or errors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Handling those return values is often done with `match` or `if let` clauses
    in order to handle the cases of success or failure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is due to `Option<T>` and `Result<T, E>` both being enumerations that have
    generic type parameters; they can assume any type in their variants. Matching
    on their variants provides access to their inner values and types to allow a branch
    of the code to be executed and handle the case accordingly. Not only does this
    eliminate the need for constructs such as try/catch with multiple—sometimes cast—exception
    arms, it makes failure part of the normal workflow that needs to be taken care
    of.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another aspect of Rust is the ability to do metaprogramming—basically programming
    programming—using macros! Macros are expanded in Rust code before compilation,
    which gives them more power than a regular function. The generated code can, for
    instance, create functions on the fly or implement traits for a structure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: These pieces of code make everyday life a lot easier by reducing the need to
    create and then initialize vectors, deriving the ability to clone a structure,
    or simply printing stuff to the command line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified example for the declarative `vec![]` macro provided in
    the *Rust Book* (second edition, Appendix D):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Declarative macros work on patterns and run code if that pattern matches; the
    previous example matches *0 - n* expressions (for example, a number, or a function
    that returns a number) and inserts `temp_vec.push(...)` *n* times, iterating over
    the provided expressions as a parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The second type, procedural macros, operate differently and are often used to
    provide a default trait implementation. In many code bases, the `#[derive(Clone,
    Debug)]` statement can be found on top of structures to implement the `Clone`
    and `Debug` traits automatically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this chapter, we are going to use a structure, `FileName`, to illustrate
    reference counting, but for printing it to the command line using the debug literal
    `"{:?}"`, we need to derive `Debug`, which recursively prints all members to the
    command line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Rust standard library provides several macros already, and by creating custom
    macros, you can minimize the boilerplate code you have to write.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust''s code is "safe" because the compiler checks and enforces certain behavior
    when it comes to memory access and management. However, sometimes these rules
    have to be forgone, making the code unsafe. `unsafe` is a keyword in Rust and
    declares a section of code that can do most of the things the C programming language
    would let you do. For example, it lets the user do the following (from the *Rust
    Book*, chapter 19.1):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的代码是“安全”的，因为编译器在内存访问和管理方面检查并强制执行某些行为。然而，有时这些规则必须被放弃，使得代码变得不安全。`unsafe`是Rust中的一个关键字，它声明了一段代码，可以执行C编程语言允许你做的许多事情。例如，它允许用户执行以下操作（来自*《Rust编程语言》*，第19.1章）：
- en: Dereference a raw pointer
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用原始指针
- en: Call an `unsafe` function or method
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个`不安全`的函数或方法
- en: Access or modify a mutable static variable
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问或修改可变静态变量
- en: Implement an `unsafe` trait
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`unsafe`特质
- en: 'These four abilities can be used for things such as very low-level device access,
    language interoperability (the compiler can''t know what native libraries do with
    their memory), and so on. In most cases, and certainly in this book, `unsafe`
    is not required. In fact, the Rustonomicon ([https://doc.rust-lang.org/nomicon/what-unsafe-does.html](https://doc.rust-lang.org/nomicon/what-unsafe-does.html))
    defines a list of issues the language is trying to prevent from happening by providing
    the safe part:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种能力可以用于诸如非常低级的设备访问、语言互操作性（编译器无法知道原生库如何使用它们的内存）等情况。在大多数情况下，当然在这本书中，`unsafe`是不必要的。事实上，Rustonomicon（[https://doc.rust-lang.org/nomicon/what-unsafe-does.html](https://doc.rust-lang.org/nomicon/what-unsafe-does.html)）定义了一个列表，列出了语言试图通过提供安全部分来防止发生的问题：
- en: Dereferencing null, dangling, or unaligned pointers.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解引用空、悬垂或未对齐的指针。
- en: Reading uninitialized memory.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取未初始化的内存。
- en: Breaking the pointer aliasing rules.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏指针别名规则。
- en: 'Producing invalid primitive values:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成无效的原始值：
- en: Dangling/null references
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬垂/空引用
- en: Null `fn` pointers
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空的`fn`指针
- en: A bool that isn't 0 or 1
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是0或1的布尔值
- en: An undefined `enum` discriminant
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义的`enum`判别符
- en: A char outside the ranges [`0x0`, `0xD7FF`] and [`0xE000`, `0x10FFFF`]
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符超出范围[`0x0`, `0xD7FF`]和[`0xE000`, `0x10FFFF`]
- en: A non-UTF8 string
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非UTF8字符串
- en: Unwinding into another language.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用其他语言。
- en: Causing a data race.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致数据竞争。
- en: The fact that these potential issues are prevented in safe Rust certainly makes
    the life of a developer easier, especially when designing algorithms or data structures.
    As a consequence, this book will always work with safe Rust.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些潜在问题在安全Rust中被防止，这无疑使开发者的生活变得更轻松，尤其是在设计算法或数据结构时。因此，这本书将始终使用安全Rust。
- en: Borrowing and ownership
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用和所有权
- en: 'Rust is famous for its memory management model, which replaces runtime garbage
    collection with compile-time checks for memory safety. The reason why Rust can
    work without a garbage collector and still free the programmer from error-prone
    memory management is simple (but not easy): borrowing and ownership.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Rust以其内存管理模型而闻名，该模型用编译时对内存安全的检查取代了运行时垃圾回收。Rust能够在没有垃圾回收器的情况下工作，并且仍然让程序员摆脱易出错的内存管理，原因简单（但不容易）：借用和所有权。
- en: While the particulars are quite complex, the high-level view is that the compiler
    inserts any "provide *x* amounts of memory" and "remove *x* amounts of memory"
    (somewhat like `malloc()` and `free()` for C programmers) statements for the developer.
    Yet how can it do that?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然具体细节相当复杂，但高层次的观点是，编译器为开发者插入任何“提供*x*数量的内存”和“移除*x*数量的内存”（对于C程序员来说类似于`malloc()`和`free()`）语句。然而，它是如何做到这一点的呢？
- en: 'The rules of ownership are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权规则如下：
- en: The owner of a value is a variable
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的所有者是变量
- en: At any time, only a single owner is allowed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时候，只允许一个所有者
- en: The value is lost once the owner goes out of scope
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，值就会丢失
- en: 'This is where Rust''s declarative syntax comes into play. By declaring a variable,
    the compiler knows—at compile time—that a certain amount of memory needs to be
    reserved. The lifetime is clearly defined too, from the beginning to end of a
    block or function, or as long as the `struct` instance lives. If the size of this
    variable is known at compile time, the compiler can provide exactly the necessary
    amount of memory to the function for the time required. To illustrate, let''s
    consider this snippet, where two variables are allocated and removed in a deterministic
    order:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Rust声明性语法发挥作用的地方。通过声明一个变量，编译器在编译时就知道需要预留一定量的内存。其生命周期也是明确定义的，从块的开始到结束，或只要`struct`实例存在。如果这个变量的大小在编译时已知，编译器就可以为函数提供所需的精确内存量。为了说明这一点，让我们考虑这个片段，其中两个变量以确定的顺序分配和释放：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Is this not what every other compiler does? The answer is yes—and no. At compile
    time, the "provide *x* amounts of memory" part is fairly simple; the tricky part
    is keeping track of how much is still in use when references can be passed around
    freely. If, during the course of a function, a particular local reference becomes
    invalid, a static code analysis will tell the compiler about the lifetime of the
    value behind the reference. However, what if a thread changes that value at an
    unknown time during the function's execution?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是每个其他编译器都做的事情吗？答案是是的——也不是。在编译时，“提供*x*量的内存”这部分相对简单；棘手的部分是跟踪在可以自由传递引用时还有多少内存在使用中。如果在函数执行过程中，某个局部引用变得无效，静态代码分析会告诉编译器引用背后的值的生命周期。然而，如果在函数执行过程中某个线程在未知的时间改变了这个值呢？
- en: 'At compile time, this is impossible to know, which is why many languages do
    these checks at runtime using a garbage collector. Rust forgoes this, with two
    primary strategies:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，这是不可能知道的，这就是为什么许多语言使用垃圾回收器在运行时进行这些检查。Rust放弃了这种方法，采用两种主要策略：
- en: Every variable is owned by exactly one scope at any time
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个变量在任何时候都恰好由一个作用域拥有
- en: Therefore, the developer is forced to pass ownership as required
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，开发者被迫按照要求传递所有权
- en: Especially when working with scopes, the nature of stack variables comes in
    handy. There are two areas of memory, stack and heap, and, similar to other languages,
    the developer uses types to decide whether to allocate heap (`Box`, `Rc`, and
    so on) or stack memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在处理作用域时，栈变量的特性非常有用。存在两个内存区域，栈和堆，类似于其他语言，开发者使用类型来决定是分配堆（`Box`、`Rc`等）还是栈内存。
- en: 'Stack memory is usually short-lived and smaller, and operates in a first-in,
    last-out manner. Consequently, a variable''s size has to be known before it is
    put on the stack:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 栈内存通常是短暂的且较小的，以先进先出的方式操作。因此，在将变量放入栈之前，必须知道其大小：
- en: '![](img/04d4f181-3289-4b0a-97ed-7942ad366875.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04d4f181-3289-4b0a-97ed-7942ad366875.png)'
- en: 'Heap memory is different; it''s a large portion of the memory, which makes
    it easy to allocate more whenever needed. There is no ordering, and memory is
    accessed by using an addresses. Since the pointer to an address on the heap has
    a known size at compile time, it fits nicely on the stack:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存不同；它是内存的一部分，这使得在需要时很容易分配更多内存。没有顺序，内存通过地址访问。由于堆上的地址指针在编译时已知大小，它非常适合放在栈上：
- en: '![](img/f30496bb-f144-45a9-befa-4e66a0f8b4cf.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f30496bb-f144-45a9-befa-4e66a0f8b4cf.png)'
- en: 'Stack variables are typically passed by value in other languages, which means
    that the entire value is copied and placed into the stack frame of the function.
    Rust does the same, but it also invalidates further use of that variable in the—now
    parent—scope. Ownership moves into the new scope and can only be transferred back
    as a return value. When trying to compile this snippet, the compiler will complain:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，栈变量通常按值传递，这意味着整个值被复制并放置在函数的栈帧中。Rust也这样做，但它还使该变量在——现在的父——作用域中的进一步使用无效。所有权移动到新的作用域，并且只能作为返回值转移回来。当尝试编译这个片段时，编译器会报错：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Borrowing is similar but, instead of copying the entire value, a reference to
    the original value is moved into the new scope. Just like in real life, the value
    continues to be owned by the original scope; scopes with a reference are just
    allowed to use it as it was provided. Of course, this comes with drawbacks for
    mutability, and some functions will require ownership for technical and semantic
    reasons, but it also has advantages such as a smaller memory footprint.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 借用类似，但不是复制整个值，而是将原始值的引用移动到新的作用域。就像在现实生活中一样，值继续由原始作用域拥有；具有引用的作用域只是允许像提供的那样使用它。当然，这也带来了可变性的缺点，并且一些函数可能需要所有权，这既有技术原因也有语义原因，但它也有优点，例如更小的内存占用。
- en: 'These are the rules of borrowing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是借用规则：
- en: Owners can have immutable or mutable references, but not both
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者可以拥有不可变或可变引用，但不能同时拥有两者
- en: There can be multiple immutable references, but only one mutable reference
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以有多个不可变引用，但只能有一个可变引用
- en: References cannot be invalid
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用不能是无效的
- en: 'By changing the previous snippet to borrow the variable to `do_something()`
    (assuming this is allowed, of course), the compiler will be happy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将前面的片段更改为将变量借用给`do_something()`（假设这是允许的，当然），编译器将很高兴：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Borrowed variables rely heavily on lifetimes. The most basic lifetime is the
    scope it was created in. However, if a reference should go into a struct field,
    how can the compiler know that the underlying value has not been invalidated?
    The answer is explicit lifetimes!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 借用的变量在很大程度上依赖于生命周期。最基本的生命周期是它在其中创建的作用域。然而，如果引用应该进入结构体字段，编译器如何知道底层值没有被无效化？答案是显式生命周期！
- en: Exceptional lifetimes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊生命周期
- en: Some lifetimes are different and Rust denominates them with a `'`. While this
    could be the predefined `'static`, it's equally possible to create your own, something
    that is often required when working with structures.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生命周期是不同的，Rust用`'`来表示它们。虽然这可能是预定义的`'static`，但在处理结构时，创建自己的生命周期也是同样可能的。
- en: 'This makes sense when thinking about the underlying memory structure: if an
    input parameter is passed into the function and returned at the end, its lifetime
    surpasses the function''s. While the function owns this part of the memory during
    its lifetime, it cannot borrow a variable for longer than it actually exists.
    So, this snippet cannot work:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑底层内存结构时，这是有意义的：如果输入参数被传递到函数中并在最后返回，它的生命周期超过了函数。虽然函数在其生命周期内拥有这部分内存，但它不能借用一个比它实际存在的时间更长的变量。因此，这个片段无法工作：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The reason is that the `passing_through` variable outlives `x`. There are several
    solutions to this problem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`passing_through`变量比`x`存在的时间更长。解决这个问题有几种方法：
- en: 'Change the type definition of `MyStruct` to require ownership. This way, the
    structure now owns the variable and it will live as long as the structure:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`MyStruct`的类型定义更改为要求所有权。这样，结构现在拥有变量，并且它的生命周期将与结构相同：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Clone `x` to pass ownership into `passing_through`:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`x`克隆到`passing_through`以传递所有权：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this case, `vec![]` is statically defined, so it could make sense to add
    it as a function parameter. This is not only more allocation-efficient, but also
    can enforce an appropriate lifetime:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，`vec![]`是静态定义的，因此将其作为函数参数可能是有意义的。这不仅更高效地分配内存，还可以强制执行适当的生命周期：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lifetimes cause a lot of strange errors for many Rust users, and in the 2018
    edition there is one less to worry about. With the introduction of non-lexical
    lifetimes, the borrow checker got a lot smarter and it is now able to check—up
    to a certain degree—semantically whether the variable was used. Recall from the
    rules of borrowing that, if a mutable reference is created, no immutable references
    can exist.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期给许多Rust用户带来了很多奇怪的错误，在2018版中有一个可以少担心的问题。随着非词法生命期的引入，借用检查器变得更聪明了，现在它能够在一定程度上检查变量是否被使用。回想一下借用规则，如果创建了一个可变引用，则不能存在不可变引用。
- en: 'This code did not compile before Rust 1.31:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust 1.31之前，这段代码无法编译：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now it will compile since the compiler does not just check the beginning and
    ending of a scope, but also if the reference was used at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将能够编译，因为编译器不仅检查作用域的开始和结束，还检查引用是否被使用过。
- en: Multiple owners
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个所有者
- en: 'As powerful as single ownership is, it does not work for every use case. Large
    objects or shared objects that other instances need to own are examples where
    immutable ownership makes life easier. Consider a function that requires an owned
    object to be passed in:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 单一所有权的功能虽然强大，但并不适用于所有用例。例如，大型对象或需要其他实例拥有的共享对象，在这些情况下不可变所有权会使生活变得更简单。考虑一个需要传入拥有对象的函数：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When trying to compile `no_ref_counter()`, the compiler creates a scope for
    each iteration of the loop and owns any value that is used within it. This works
    exactly once, since afterward, the variable has been moved and is inaccessible
    for subsequent iterations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试编译`no_ref_counter()`时，编译器为循环的每次迭代创建一个作用域，并拥有其中使用的任何值。这只会成功一次，因为之后变量已经被移动，并且对于后续迭代不可访问。
- en: 'Consequently, these values (in this case, `name` and `ext`) are gone and compilation
    will yield two errors, one for each "second" move of a string:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些值（在这种情况下，`name`和`ext`）消失了，编译将产生两个错误，每个错误对应于字符串的“第二次”移动：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One solution is to clone the object in every iteration, but that causes a lot
    of slow memory allocations. For this, the Rust standard library provides a solution:
    reference counting.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是在每次迭代中克隆对象，但这会导致大量的缓慢内存分配。为此，Rust标准库提供了一个解决方案：引用计数。
- en: A reference counter (`std::rc::Rc<T>`) encapsulates a variable of type `T` allocated
    on the heap and returns an **immutable** reference when created. This reference
    can be cloned with low overhead (it's only a reference count that is incremented)
    but never transformed into a mutable reference. Regardless, it acts just like
    owned data, passing through function calls and property lookups.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数器（`std::rc::Rc<T>`）封装了一个在堆上分配的类型为`T`的变量，并在创建时返回一个**不可变**引用。这个引用可以以低开销克隆（它只是增加引用计数），但永远不会转换为可变引用。无论如何，它就像拥有数据一样，通过函数调用和属性查找传递。
- en: 'While this requires a change to the variable types, a call to `clone()` is
    now far cheaper than cloning the data directly:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这需要改变变量类型，但现在调用`clone()`比直接克隆数据要便宜得多：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this snippet prints the debug version of the `FileName` object three
    times:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段会打印出`FileName`对象的调试版本三次：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This approach works great for single-threaded and immutable scenarios, but will
    refuse to compile multithreaded code. The solution to this will be discussed in
    the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于单线程和不可变场景非常有效，但会拒绝编译多线程代码。这个解决方案将在下一节讨论。
- en: Concurrency and mutability
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和可变性
- en: 'Rust''s approach to managing memory is a powerful concept. In fact, it is powerful
    enough to also facilitate concurrency and parallel execution. However, first things
    first: how do threads work in the Rust standard library?'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Rust管理内存的方法是一个强大的概念。事实上，它足够强大，可以促进并发和并行执行。然而，首先：Rust标准库中的线程是如何工作的？
- en: Concurrency and parallelism are two different modes of execution. While concurrency
    means that parts of a program run independently of each other, parallelism refers
    to these parts executing at the same time. For simplicity, we will refer to both
    concepts as concurrency.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行性是两种不同的执行模式。虽然并发意味着程序的某些部分可以独立运行，但并行性指的是这些部分同时执行。为了简单起见，我们将这两个概念统称为并发。
- en: 'Due to its low-level nature, Rust provides an API to the operating system''s
    threading capabilities (for example, POSIX on Linux/Unix systems). If no variables
    are passed into the scope, their usage is very straightforward:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其底层性质，Rust提供了操作系统线程功能的API（例如，Linux/Unix系统上的POSIX）。如果没有变量传递到作用域中，其使用非常简单：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, when passing data back and forth, more work has to be done to hold
    up Rust's safety guarantees, especially when mutability comes into play. Before
    getting into that, it is important to recap immutability.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在传递数据时，为了保持Rust的安全性保证，需要做更多的工作，尤其是在涉及可变性时。在深入探讨这一点之前，回顾不可变性是很重要的。
- en: Immutable variables
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变变量
- en: Rust—like many functional languages—embraces immutable variables. They are the
    default, and changing mutability requires explicit declaration with `mut`, which
    tells the compiler what the variable is going to be used for (reading or writing).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Rust——就像许多函数式语言一样——拥抱不可变变量。它们是默认的，改变可变性需要使用`mut`进行显式声明，这告诉编译器变量将要被用于什么（读取或写入）。
- en: Functional programming languages are known for facilitating the ability to work
    concurrently, thanks to immutability guarantees; reading data does not produce
    side effects! Requiring explicit mutability gives the compiler a chance to check
    where and if mutability is required, and therefore whether a data race may occur.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言因通过不可变性保证促进并发工作能力而闻名；读取数据不会产生副作用！要求显式可变性给编译器一个检查何时以及是否需要可变性的机会，因此是否可能发生数据竞争。
- en: This results in compile-time warnings and errors instead of crashes and strange
    race conditions at runtime, something that many production users appreciate. In
    short, it's easier to think through your code if mutability is a (rare) option
    instead of the norm.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致编译时警告和错误而不是运行时崩溃和奇怪的竞争条件，这是许多生产用户所欣赏的。简而言之，如果可变性是（罕见的）选项而不是规范，那么思考代码就更容易。
- en: Shadowing
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影（Shadowing）
- en: Instead of changing variable properties, it's often more readable to overwrite
    a variable with a different value (for example, a changed copy of the original).
    This technique is called **shadowing**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与改变变量属性不同，用不同的值（例如，原始值的更改副本）覆盖变量通常更易于阅读。这种技术被称为**阴影（shadowing）**。
- en: 'Typically, this is used to reuse a variable name, even though the actual value
    has changed, to work in the current situation. This snippet sanitizes `String`
    and, by using the same name throughout the function, it''s always clear that it''s
    the input parameter that is changed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这用于重用变量名，即使实际值已经改变，以便在当前情况下工作。此代码片段清理`String`，通过在整个函数中使用相同的名称，始终可以清楚地知道是输入参数被更改：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While this is akin to changing the value of a variable, shadowing does not replace
    mutability, especially when it's less costly to actually change properties of
    that variable; Rust has a specific design pattern for that!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与改变变量的值类似，但阴影（shadowing）并不会取代可变性，尤其是在实际改变该变量的属性成本较低时；Rust为此有一个特定的设计模式！
- en: Interior mutability
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部可变性
- en: Can a variable be immutable and mutable at the same time? Of course. Boxed variables
    (`Box`, `Rc`, and so on) are an immutable reference to the heap and they contain
    the actual value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量能否同时是不可变和可变的？当然可以。装箱变量（`Box`、`Rc`等）是对堆的不可变引用，它们包含实际值。
- en: For these kinds of containers, there is no reason why the inner variable cannot
    be changed—a task that can be done safely in Rust using `RefCell`. `RefCell` maintains
    single ownership of a value but allows mutable borrowing **checked at runtime.**
    Instead of compiler errors, violating the rules of borrowing will lead to a runtime
    `panic!`, crashing the program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的容器，没有理由说内部变量不能被更改——这是一个可以在Rust中使用`RefCell`安全完成的任务。`RefCell`维护值的单一所有权，但允许在运行时进行可变借用**检查**。而不是编译器错误，违反借用规则将导致运行时`panic!`，使程序崩溃。
- en: This entire concept is called **interior mutability** and is often used in combination
    with `Rc` in order to provide a value to multiple owners with mutability at will.
    Clearly, to provide a great user experience, it is strongly recommended to make
    sure the borrowing rules can't be violated in other ways.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 整个概念被称为**内部可变性（interior mutability）**，通常与`Rc`结合使用，以便为多个所有者提供可变性的值。显然，为了提供良好的用户体验，强烈建议确保借用规则不会被其他方式违反。
- en: Wrapping a `RefCell` in an `Rc` acts as the gatekeeper for having multiple owners,
    including a way to change the contents. This is actually similar to more traditional
    programming languages such as Java or C#, where typically references are moved
    between method calls, pointing to the object's instance on the heap memory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RefCell`包裹在`Rc`中充当拥有多个所有者的看门人，包括更改内容的方式。这实际上类似于更传统的编程语言，如Java或C#，在这些语言中，通常在方法调用之间移动引用，指向堆内存中的对象实例。
- en: 'This pattern is very important for implementing complex programs and data structures,
    since ownership of a specific variable is not always clear. For example, later
    in the book we will examine doubly linked lists, which famously have a pointer
    to the preceding and succeeding node. Which node *should* have ownership of which
    pointer? Interior mutability allows us to say both. Consider the node declaration
    we will use later:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于实现复杂程序和数据结构非常重要，因为特定变量的所有权并不总是明确的。例如，本书后面我们将研究双链表，它著名地有一个指向前一个和后继节点的指针。哪个节点**应该**拥有哪个指针的所有权？内部可变性允许我们说两者都有。考虑我们稍后将使用的节点声明：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this list declaration, we can see the pattern in this simpler version
    of the `append` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code adds a new node at the front (head) of the list, which contains all
    data in the form of nodes stored on the heap. In order to add a node at the head
    of the list, the references have to be set properly, so the previous and next
    pointers actually refer to the same nodes instead of copies. A more detailed exploration
    is going to be covered in [Chapter 3](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml),
    *Lists, Lists, and More Lists*. For now, the important part is setting the variables
    using `borrow_mut()`. This mutable reference only lives as long as the assignment
    takes, thereby ruling out creating a too-large scope and violating the borrowing
    rules.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: By using the `RefCell` function's `borrow_mut()`, it will check for and enforce
    borrowing rules and panic in the case of a violation. Later on, we will also talk
    about the `Mutex` type, which is essentially a multithreaded version of these
    cells.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Moving data
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introductory snippet showed code that spawns a thread but did not pass any
    data into the scope. Just like any other scope, it requires either ownership of
    a value or at least a borrowed reference in order to work with that data. In this
    case, passing ownership is what we want, something that is called **moving data**
    into the scope.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the snippet from the introduction to include a simple variable
    to print from within the thread, compilation is going to fail:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The reason for this is simple: the compiler cannot determine the lifetimes
    of each of the scopes (will `x` still be there when the thread needs it?), so
    it refuses to compile the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As the compiler messages indicate, adding the `move` keyword will solve the
    issue! This keyword lets a thread pass ownership to a different thread; it "moves"
    the memory area:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When running this snippet, the output is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, for passing multiple messages into a thread or implementing *an actor
    model*, the Rust standard library offers channels. Channels are single-consumer,
    multi-producer queues that let the caller send messages from multiple threads.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet will spawn 10 threads and have each send a number into the channel,
    where it will be collected into a vector after the senders have finished executing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As expected, the output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With these tools, a multithreaded application can move data between threads
    without the need for manual locking or the dangers of inadvertently creating side
    effects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than sending data into threads one way, many programs operate on a shared
    state where multiple execution streams have to access and change one or more shared
    variables. Typically, this warrants a **mutex** (short for **mutual exclusion**),
    so that any time something is accessed within this locked mutex, it is guaranteed
    to be a single thread.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: This is an old concept and implemented in the Rust standard library. How does
    that facilitate accessing a variable? Wrapping a variable into a `Mutex` type
    will provide for the locking mechanism, thereby making it accessible from multiple
    concurrent writers. However, they don't have ownership of that memory area yet.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide that ownership across threads—similar to what `Rc` does
    within a single thread—Rust provides the concept of an `Arc`, an atomic reference
    counter. Using this `Mutex` on top, it''s the thread-safe equivalent of an `Rc`
    wrapping a `RefCell`, a reference counter that wraps a mutable container. To provide
    an example, this works nicely:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When running this example, the output is this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While the preferred way of doing concurrent programming is still to use immutable
    variables as often as possible, safe Rust provides the tools for working with
    shared data without side effects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Send and Sync
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These marker traits are fundamental to Rust''s multithreading policies. They
    have distinct purposes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`Send`: A data type is safe to send (move) from one thread to the other'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sync`: The data type can be shared across threads without manual locks or
    mutex areas'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These marker traits are implemented in all basic types of the standard library
    and can be inherited for custom types (if all properties of a type are `Sync`,
    then the type itself is `Sync` too).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `Sync` or `Send` is unsafe because there is no way for the compiler
    to know if you are right and the code can be shared/sent between threads, which
    is why it's very unusual to do this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In case your program requires this depth of Rust programming, be sure to read
    up on this topic in the *Rust Book*, chapter 16 ([https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html](https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Deeper into Rust
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another one of Rust''s strong points is its thriving community. Many users
    actively participate in their local community (by going to or organizing meetups)
    or online via working groups, the IRC/Discord channel, or the official forum.
    The most important online resources are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The main website with pointers to various resources: [https://www.rust-lang.org](https://www.rust-lang.org)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust user forum: [https://users.rust-lang.org](https://users.rust-lang.org)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Twitter account: [https://twitter.com/rustlang](https://twitter.com/rustlang)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of IRC channels at [https://wiki.mozilla.org/Rust](https://wiki.mozilla.org/Rust)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust''s official blog: [https://blog.rust-lang.org](https://blog.rust-lang.org)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust Book: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than that, users have created additional content, such as podcasts, blogs,
    and various tools and libraries. The most impressive user contributions, however,
    can be found in the core language!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Rust's official GitHub repository at [https://github.com/rust-lang](https://github.com/rust-lang)
    holds the source code for many of the resources (for example, the website, blog,
    book, and documentation), and contributions are very welcome.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla has an impressive record of creating and fostering open source communities,
    and Rust is no different. As active members of these communities, we encourage
    everyone to take part and help make Rust the most enjoyable and useful language
    around!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Requests for Comments (RFCs)
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the open source nature of Rust, there are some governance rules in place
    to maintain stable and flexible interfaces, yet encourage change and discussion
    as the language evolves.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: For something as sensitive as a programming language and its standard library,
    a more rigid process than the regular pull request approval is required to have
    deeper discussions. Imagine the impact of changing a single keyword and how many
    projects would stop working immediately!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This is where RFCs come in. They provide a way for all stakeholders to contribute
    to the discussion with an equal chance to comment. A typical workflow for integrating
    change in open source projects uses the fork and pull method where the contributor
    creates a **pull request** (**PR**) to propose changes ([https://help.github.com/articles/about-pull-requests/](https://help.github.com/articles/about-pull-requests/)).
    Unlike in the RFC process, this gets hard to manage in larger code bases and only
    starts the discussion *after* a solution has been proposed, narrowing the focus
    considerably.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'A repository of active and past RFCs can be found here: [https://github.com/rust-lang/rfcs](https://github.com/rust-lang/rfcs).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust is a multi-paradigm language with exceptional concepts: the language emphasizes
    data and behavior separation with structures and traits, uses macros for metaprogramming,
    and leverages explicit ownership of memory to determine variable lifetimes. Knowing
    these lifetimes removes the need for runtime garbage collection and, at the same
    time, greatly facilitates concurrency by allowing mutable borrowing only in certain
    circumstances.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, threads and other asynchronous processes can change variables
    only when they have mutable ownership of them, something that is mostly enforced
    at compile time, but can also be done at runtime! Therefore, safe Rust is effectively
    free of data races.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Another strong point of the Rust ecosystem is its diverse and welcoming community.
    Sponsored by Mozilla, development is guided by RFCs, events are organized and
    centrally advertised, and learning resources are available online. Another way
    to be a part of the ecosystem is to contribute packages to `crates.io` ([https://crates.io/](https://crates.io/)),
    Rust's public package repository. Read the next chapter to find out more about
    `cargo`, Rust's universal tool to build and package.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are traits and how are they different from interfaces?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why doesn't Rust have a garbage collector?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Rust 没有垃圾回收器？
- en: Name three examples of how lifetimes are created in Rust (explicitly and implicitly)!
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举三个在 Rust 中创建生命周期（显式和隐式）的例子！
- en: Why is immutability for variables important?
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的不可变性为什么很重要？
- en: What does the Sync marker trait do?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步标记特性有什么作用？
- en: Where can you go to participate in the Rust community?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以去哪里参与 Rust 社区？
- en: Why are RFCs preferred over PRs?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 RFC 比 PR 更受欢迎？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Refer to the following books for more information:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下书籍提供了更多信息：
- en: '*Hands-On Concurrency with Rust* by Brian L. Troutwine (Packt)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Rust并发实战》* by Brian L. Troutwine (Packt)'
- en: '*Functional Programming in Rust* by Andrew Johnson (Packt)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Rust中的函数式编程》* by Andrew Johnson (Packt)'
