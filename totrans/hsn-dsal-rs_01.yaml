- en: Hello Rust!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, thank you for picking up a copy of this book! Many of you will only have
    talked about the topic of algorithms and data structures back in university. In
    fact, regardless of whether this is your first endeavor in programming or not,
    we worked hard to make this book a great learning experience. Our primary focus
    will be the unique influence of Rust on algorithm and data structure design, so
    we would like to start with a recap of important fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting off with the Rust 2018 edition changes, we will cover how borrowing
    and ownership, mutability, and concurrency influence how and where data can be
    held, and what algorithms can be executed. In this chapter, you can look forward
    to learning about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick refresh on Rust and what awaits in the 2018 edition (Rust 1.31)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest and greatest about borrowing and ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can leverage concurrency and mutability properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References (not pointers!) to where Rust lives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust in 2018
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How old is Rust? It started off in 2006 as a side project of Graydon Hoare,
    an engineer at Mozilla, and was later (in 2009) adopted by the company. Fast forward
    to less than a decade later to May 15, 2015, and the Rust team announced a stable
    version 1.0!
  prefs: []
  type: TYPE_NORMAL
- en: During its journey, there have been many features that have been added and removed
    again (for example, a garbage collector, classes, and interfaces) to help it become
    the fast and safe language that it is today.
  prefs: []
  type: TYPE_NORMAL
- en: Before getting deeper into borrowing and ownership, mutability, concurrency,
    safety, and so on in Rust, we would like to recap some major concepts in Rust
    and why they change architectural patterns significantly.
  prefs: []
  type: TYPE_NORMAL
- en: The 2018 edition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust in the 2015 edition is essentially the 1.0 version with a few non-breaking
    additions. Between 2015 and 2018, however, features and **Requests for Comments **(**RFCs**),
    Rust's way of changing core features with the community, accumulated, and worries
    about backward compatibility arose.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the goal of keeping this compatibility, editions were introduced and,
    with the first additional edition, many major changes made it into the language:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the module path system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dyn Trait` and `impl Trait` syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async`/`await` syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifications to the lifetime syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these additions, Rust will introduce asynchronous programming into its
    syntax (`async`/`await` keywords) and improve the language's usability. This book
    uses the Rust 2018, released on December 6, 2018 ([https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html))
    edition by default, so all the following snippets will already include these new
    language features!
  prefs: []
  type: TYPE_NORMAL
- en: The Rust language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the established programming languages today are multi-paradigm languages,
    but still remain focused on the principles of object orientation. This means that
    they have classes, methods, interfaces, inheritance, and so on, none of which
    can be found in Rust, giving it a steep learning curve for many established developers.
  prefs: []
  type: TYPE_NORMAL
- en: More experienced readers will miss many aspects of what makes Rust an excellent
    language, such as static versus dynamic method invocation, memory layouts, and
    so on. I recognize the importance of those things, yet for brevity and focus chose
    to leave it to you to explore these things further. Check the *Further reading*
    section for resources.
  prefs: []
  type: TYPE_NORMAL
- en: As a multi-paradigm language, Rust has many functional concepts and paradigms
    that guide it, but they make traditional object-oriented patterns more difficult
    to apply. Other than organizing code without classes and interfaces, there are
    various methods to handle errors, change the code itself, or even work with raw
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we want to explore a few concepts that make Rust
    unique and have a major influence on the way we develop algorithms and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Organizing code in Rust is a bit different from regular object-oriented languages
    such as C#. There, an object is supposed to change its own state, interfaces are
    simple contract definitions, and specialization is often modeled using class inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With Rust, this pattern would require constant mutability of any `Door` instance
    (thereby requiring explicit locking for thread safety), and without inheritance
    `GlassDoor` would have to duplicate code, making it harder to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it''s recommended to create traits to implement (shared) behavior.
    Traits have a lot in common with abstract classes in traditional languages (such
    as default implementations of methods/functions), yet any `struct` in Rust can
    (and should) implement several of those traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is very common in the standard library, and often third-party libraries
    will even add behavior to existing types by implementing traits in their code
    (also known as extension traits).
  prefs: []
  type: TYPE_NORMAL
- en: Other than a typical class, where data fields and methods are in a single construct,
    Rust emphasizes the separation between those by declaring a `struct` for data
    and an `impl` part for the methods/functions. Traits name and encapsulate behaviors
    so they can easily be imported, shared, and reused.
  prefs: []
  type: TYPE_NORMAL
- en: Going wrong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than classes, Rust comes without another well-known companion: `null`.
    In the absence of pointers and with a very different memory management model,
    there is no typical `null` pointer/reference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the language works with `Option` and `Result` types that let developers
    model success or failure. In fact, there is no exception system either, so any
    failed execution of a function should be indicated in the return type. Only in
    rare cases when immediate termination is required does the language provide a
    macro for panicking: `panic!()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Option<T>` and `Result<T, E>` both encapsulate one (`Option<T>`) or two (`Result<T,
    E>`) values that can be returned to communicate an error or whether something
    was found or not. For example, a `find()` function could return `Option<T>`, whereas
    something like `read_file()` would typically have a `Result<T, E>` return type
    to communicate the content or errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling those return values is often done with `match` or `if let` clauses
    in order to handle the cases of success or failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is due to `Option<T>` and `Result<T, E>` both being enumerations that have
    generic type parameters; they can assume any type in their variants. Matching
    on their variants provides access to their inner values and types to allow a branch
    of the code to be executed and handle the case accordingly. Not only does this
    eliminate the need for constructs such as try/catch with multiple—sometimes cast—exception
    arms, it makes failure part of the normal workflow that needs to be taken care
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another aspect of Rust is the ability to do metaprogramming—basically programming
    programming—using macros! Macros are expanded in Rust code before compilation,
    which gives them more power than a regular function. The generated code can, for
    instance, create functions on the fly or implement traits for a structure.
  prefs: []
  type: TYPE_NORMAL
- en: These pieces of code make everyday life a lot easier by reducing the need to
    create and then initialize vectors, deriving the ability to clone a structure,
    or simply printing stuff to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified example for the declarative `vec![]` macro provided in
    the *Rust Book* (second edition, Appendix D):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Declarative macros work on patterns and run code if that pattern matches; the
    previous example matches *0 - n* expressions (for example, a number, or a function
    that returns a number) and inserts `temp_vec.push(...)` *n* times, iterating over
    the provided expressions as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The second type, procedural macros, operate differently and are often used to
    provide a default trait implementation. In many code bases, the `#[derive(Clone,
    Debug)]` statement can be found on top of structures to implement the `Clone`
    and `Debug` traits automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this chapter, we are going to use a structure, `FileName`, to illustrate
    reference counting, but for printing it to the command line using the debug literal
    `"{:?}"`, we need to derive `Debug`, which recursively prints all members to the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Rust standard library provides several macros already, and by creating custom
    macros, you can minimize the boilerplate code you have to write.
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust''s code is "safe" because the compiler checks and enforces certain behavior
    when it comes to memory access and management. However, sometimes these rules
    have to be forgone, making the code unsafe. `unsafe` is a keyword in Rust and
    declares a section of code that can do most of the things the C programming language
    would let you do. For example, it lets the user do the following (from the *Rust
    Book*, chapter 19.1):'
  prefs: []
  type: TYPE_NORMAL
- en: Dereference a raw pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call an `unsafe` function or method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access or modify a mutable static variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an `unsafe` trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These four abilities can be used for things such as very low-level device access,
    language interoperability (the compiler can''t know what native libraries do with
    their memory), and so on. In most cases, and certainly in this book, `unsafe`
    is not required. In fact, the Rustonomicon ([https://doc.rust-lang.org/nomicon/what-unsafe-does.html](https://doc.rust-lang.org/nomicon/what-unsafe-does.html))
    defines a list of issues the language is trying to prevent from happening by providing
    the safe part:'
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing null, dangling, or unaligned pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading uninitialized memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking the pointer aliasing rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Producing invalid primitive values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dangling/null references
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Null `fn` pointers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A bool that isn't 0 or 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An undefined `enum` discriminant
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A char outside the ranges [`0x0`, `0xD7FF`] and [`0xE000`, `0x10FFFF`]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-UTF8 string
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwinding into another language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causing a data race.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that these potential issues are prevented in safe Rust certainly makes
    the life of a developer easier, especially when designing algorithms or data structures.
    As a consequence, this book will always work with safe Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust is famous for its memory management model, which replaces runtime garbage
    collection with compile-time checks for memory safety. The reason why Rust can
    work without a garbage collector and still free the programmer from error-prone
    memory management is simple (but not easy): borrowing and ownership.'
  prefs: []
  type: TYPE_NORMAL
- en: While the particulars are quite complex, the high-level view is that the compiler
    inserts any "provide *x* amounts of memory" and "remove *x* amounts of memory"
    (somewhat like `malloc()` and `free()` for C programmers) statements for the developer.
    Yet how can it do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules of ownership are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The owner of a value is a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any time, only a single owner is allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value is lost once the owner goes out of scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is where Rust''s declarative syntax comes into play. By declaring a variable,
    the compiler knows—at compile time—that a certain amount of memory needs to be
    reserved. The lifetime is clearly defined too, from the beginning to end of a
    block or function, or as long as the `struct` instance lives. If the size of this
    variable is known at compile time, the compiler can provide exactly the necessary
    amount of memory to the function for the time required. To illustrate, let''s
    consider this snippet, where two variables are allocated and removed in a deterministic
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Is this not what every other compiler does? The answer is yes—and no. At compile
    time, the "provide *x* amounts of memory" part is fairly simple; the tricky part
    is keeping track of how much is still in use when references can be passed around
    freely. If, during the course of a function, a particular local reference becomes
    invalid, a static code analysis will tell the compiler about the lifetime of the
    value behind the reference. However, what if a thread changes that value at an
    unknown time during the function's execution?
  prefs: []
  type: TYPE_NORMAL
- en: 'At compile time, this is impossible to know, which is why many languages do
    these checks at runtime using a garbage collector. Rust forgoes this, with two
    primary strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Every variable is owned by exactly one scope at any time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the developer is forced to pass ownership as required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially when working with scopes, the nature of stack variables comes in
    handy. There are two areas of memory, stack and heap, and, similar to other languages,
    the developer uses types to decide whether to allocate heap (`Box`, `Rc`, and
    so on) or stack memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stack memory is usually short-lived and smaller, and operates in a first-in,
    last-out manner. Consequently, a variable''s size has to be known before it is
    put on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04d4f181-3289-4b0a-97ed-7942ad366875.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Heap memory is different; it''s a large portion of the memory, which makes
    it easy to allocate more whenever needed. There is no ordering, and memory is
    accessed by using an addresses. Since the pointer to an address on the heap has
    a known size at compile time, it fits nicely on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f30496bb-f144-45a9-befa-4e66a0f8b4cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Stack variables are typically passed by value in other languages, which means
    that the entire value is copied and placed into the stack frame of the function.
    Rust does the same, but it also invalidates further use of that variable in the—now
    parent—scope. Ownership moves into the new scope and can only be transferred back
    as a return value. When trying to compile this snippet, the compiler will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Borrowing is similar but, instead of copying the entire value, a reference to
    the original value is moved into the new scope. Just like in real life, the value
    continues to be owned by the original scope; scopes with a reference are just
    allowed to use it as it was provided. Of course, this comes with drawbacks for
    mutability, and some functions will require ownership for technical and semantic
    reasons, but it also has advantages such as a smaller memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the rules of borrowing:'
  prefs: []
  type: TYPE_NORMAL
- en: Owners can have immutable or mutable references, but not both
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be multiple immutable references, but only one mutable reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References cannot be invalid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By changing the previous snippet to borrow the variable to `do_something()`
    (assuming this is allowed, of course), the compiler will be happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Borrowed variables rely heavily on lifetimes. The most basic lifetime is the
    scope it was created in. However, if a reference should go into a struct field,
    how can the compiler know that the underlying value has not been invalidated?
    The answer is explicit lifetimes!
  prefs: []
  type: TYPE_NORMAL
- en: Exceptional lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some lifetimes are different and Rust denominates them with a `'`. While this
    could be the predefined `'static`, it's equally possible to create your own, something
    that is often required when working with structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes sense when thinking about the underlying memory structure: if an
    input parameter is passed into the function and returned at the end, its lifetime
    surpasses the function''s. While the function owns this part of the memory during
    its lifetime, it cannot borrow a variable for longer than it actually exists.
    So, this snippet cannot work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that the `passing_through` variable outlives `x`. There are several
    solutions to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the type definition of `MyStruct` to require ownership. This way, the
    structure now owns the variable and it will live as long as the structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone `x` to pass ownership into `passing_through`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `vec![]` is statically defined, so it could make sense to add
    it as a function parameter. This is not only more allocation-efficient, but also
    can enforce an appropriate lifetime:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Lifetimes cause a lot of strange errors for many Rust users, and in the 2018
    edition there is one less to worry about. With the introduction of non-lexical
    lifetimes, the borrow checker got a lot smarter and it is now able to check—up
    to a certain degree—semantically whether the variable was used. Recall from the
    rules of borrowing that, if a mutable reference is created, no immutable references
    can exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code did not compile before Rust 1.31:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now it will compile since the compiler does not just check the beginning and
    ending of a scope, but also if the reference was used at all.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple owners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As powerful as single ownership is, it does not work for every use case. Large
    objects or shared objects that other instances need to own are examples where
    immutable ownership makes life easier. Consider a function that requires an owned
    object to be passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When trying to compile `no_ref_counter()`, the compiler creates a scope for
    each iteration of the loop and owns any value that is used within it. This works
    exactly once, since afterward, the variable has been moved and is inaccessible
    for subsequent iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, these values (in this case, `name` and `ext`) are gone and compilation
    will yield two errors, one for each "second" move of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One solution is to clone the object in every iteration, but that causes a lot
    of slow memory allocations. For this, the Rust standard library provides a solution:
    reference counting.'
  prefs: []
  type: TYPE_NORMAL
- en: A reference counter (`std::rc::Rc<T>`) encapsulates a variable of type `T` allocated
    on the heap and returns an **immutable** reference when created. This reference
    can be cloned with low overhead (it's only a reference count that is incremented)
    but never transformed into a mutable reference. Regardless, it acts just like
    owned data, passing through function calls and property lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this requires a change to the variable types, a call to `clone()` is
    now far cheaper than cloning the data directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this snippet prints the debug version of the `FileName` object three
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This approach works great for single-threaded and immutable scenarios, but will
    refuse to compile multithreaded code. The solution to this will be discussed in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust''s approach to managing memory is a powerful concept. In fact, it is powerful
    enough to also facilitate concurrency and parallel execution. However, first things
    first: how do threads work in the Rust standard library?'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and parallelism are two different modes of execution. While concurrency
    means that parts of a program run independently of each other, parallelism refers
    to these parts executing at the same time. For simplicity, we will refer to both
    concepts as concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to its low-level nature, Rust provides an API to the operating system''s
    threading capabilities (for example, POSIX on Linux/Unix systems). If no variables
    are passed into the scope, their usage is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, when passing data back and forth, more work has to be done to hold
    up Rust's safety guarantees, especially when mutability comes into play. Before
    getting into that, it is important to recap immutability.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust—like many functional languages—embraces immutable variables. They are the
    default, and changing mutability requires explicit declaration with `mut`, which
    tells the compiler what the variable is going to be used for (reading or writing).
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming languages are known for facilitating the ability to work
    concurrently, thanks to immutability guarantees; reading data does not produce
    side effects! Requiring explicit mutability gives the compiler a chance to check
    where and if mutability is required, and therefore whether a data race may occur.
  prefs: []
  type: TYPE_NORMAL
- en: This results in compile-time warnings and errors instead of crashes and strange
    race conditions at runtime, something that many production users appreciate. In
    short, it's easier to think through your code if mutability is a (rare) option
    instead of the norm.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of changing variable properties, it's often more readable to overwrite
    a variable with a different value (for example, a changed copy of the original).
    This technique is called **shadowing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, this is used to reuse a variable name, even though the actual value
    has changed, to work in the current situation. This snippet sanitizes `String`
    and, by using the same name throughout the function, it''s always clear that it''s
    the input parameter that is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While this is akin to changing the value of a variable, shadowing does not replace
    mutability, especially when it's less costly to actually change properties of
    that variable; Rust has a specific design pattern for that!
  prefs: []
  type: TYPE_NORMAL
- en: Interior mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can a variable be immutable and mutable at the same time? Of course. Boxed variables
    (`Box`, `Rc`, and so on) are an immutable reference to the heap and they contain
    the actual value.
  prefs: []
  type: TYPE_NORMAL
- en: For these kinds of containers, there is no reason why the inner variable cannot
    be changed—a task that can be done safely in Rust using `RefCell`. `RefCell` maintains
    single ownership of a value but allows mutable borrowing **checked at runtime.**
    Instead of compiler errors, violating the rules of borrowing will lead to a runtime
    `panic!`, crashing the program.
  prefs: []
  type: TYPE_NORMAL
- en: This entire concept is called **interior mutability** and is often used in combination
    with `Rc` in order to provide a value to multiple owners with mutability at will.
    Clearly, to provide a great user experience, it is strongly recommended to make
    sure the borrowing rules can't be violated in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a `RefCell` in an `Rc` acts as the gatekeeper for having multiple owners,
    including a way to change the contents. This is actually similar to more traditional
    programming languages such as Java or C#, where typically references are moved
    between method calls, pointing to the object's instance on the heap memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is very important for implementing complex programs and data structures,
    since ownership of a specific variable is not always clear. For example, later
    in the book we will examine doubly linked lists, which famously have a pointer
    to the preceding and succeeding node. Which node *should* have ownership of which
    pointer? Interior mutability allows us to say both. Consider the node declaration
    we will use later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this list declaration, we can see the pattern in this simpler version
    of the `append` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a new node at the front (head) of the list, which contains all
    data in the form of nodes stored on the heap. In order to add a node at the head
    of the list, the references have to be set properly, so the previous and next
    pointers actually refer to the same nodes instead of copies. A more detailed exploration
    is going to be covered in [Chapter 3](1a6971bb-ec24-47d5-b44c-cfb4da7d5b24.xhtml),
    *Lists, Lists, and More Lists*. For now, the important part is setting the variables
    using `borrow_mut()`. This mutable reference only lives as long as the assignment
    takes, thereby ruling out creating a too-large scope and violating the borrowing
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `RefCell` function's `borrow_mut()`, it will check for and enforce
    borrowing rules and panic in the case of a violation. Later on, we will also talk
    about the `Mutex` type, which is essentially a multithreaded version of these
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: Moving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introductory snippet showed code that spawns a thread but did not pass any
    data into the scope. Just like any other scope, it requires either ownership of
    a value or at least a borrowed reference in order to work with that data. In this
    case, passing ownership is what we want, something that is called **moving data**
    into the scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the snippet from the introduction to include a simple variable
    to print from within the thread, compilation is going to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is simple: the compiler cannot determine the lifetimes
    of each of the scopes (will `x` still be there when the thread needs it?), so
    it refuses to compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As the compiler messages indicate, adding the `move` keyword will solve the
    issue! This keyword lets a thread pass ownership to a different thread; it "moves"
    the memory area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this snippet, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, for passing multiple messages into a thread or implementing *an actor
    model*, the Rust standard library offers channels. Channels are single-consumer,
    multi-producer queues that let the caller send messages from multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet will spawn 10 threads and have each send a number into the channel,
    where it will be collected into a vector after the senders have finished executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With these tools, a multithreaded application can move data between threads
    without the need for manual locking or the dangers of inadvertently creating side
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than sending data into threads one way, many programs operate on a shared
    state where multiple execution streams have to access and change one or more shared
    variables. Typically, this warrants a **mutex** (short for **mutual exclusion**),
    so that any time something is accessed within this locked mutex, it is guaranteed
    to be a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: This is an old concept and implemented in the Rust standard library. How does
    that facilitate accessing a variable? Wrapping a variable into a `Mutex` type
    will provide for the locking mechanism, thereby making it accessible from multiple
    concurrent writers. However, they don't have ownership of that memory area yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide that ownership across threads—similar to what `Rc` does
    within a single thread—Rust provides the concept of an `Arc`, an atomic reference
    counter. Using this `Mutex` on top, it''s the thread-safe equivalent of an `Rc`
    wrapping a `RefCell`, a reference counter that wraps a mutable container. To provide
    an example, this works nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this example, the output is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While the preferred way of doing concurrent programming is still to use immutable
    variables as often as possible, safe Rust provides the tools for working with
    shared data without side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Send and Sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These marker traits are fundamental to Rust''s multithreading policies. They
    have distinct purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Send`: A data type is safe to send (move) from one thread to the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sync`: The data type can be shared across threads without manual locks or
    mutex areas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These marker traits are implemented in all basic types of the standard library
    and can be inherited for custom types (if all properties of a type are `Sync`,
    then the type itself is `Sync` too).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `Sync` or `Send` is unsafe because there is no way for the compiler
    to know if you are right and the code can be shared/sent between threads, which
    is why it's very unusual to do this.
  prefs: []
  type: TYPE_NORMAL
- en: In case your program requires this depth of Rust programming, be sure to read
    up on this topic in the *Rust Book*, chapter 16 ([https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html](https://doc.rust-lang.org/1.31.0/book/ch16-04-extensible-concurrency-sync-and-send.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Deeper into Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another one of Rust''s strong points is its thriving community. Many users
    actively participate in their local community (by going to or organizing meetups)
    or online via working groups, the IRC/Discord channel, or the official forum.
    The most important online resources are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main website with pointers to various resources: [https://www.rust-lang.org](https://www.rust-lang.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust user forum: [https://users.rust-lang.org](https://users.rust-lang.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Twitter account: [https://twitter.com/rustlang](https://twitter.com/rustlang)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of IRC channels at [https://wiki.mozilla.org/Rust](https://wiki.mozilla.org/Rust)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rust''s official blog: [https://blog.rust-lang.org](https://blog.rust-lang.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Rust Book: [https://doc.rust-lang.org/book/](https://doc.rust-lang.org/book/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than that, users have created additional content, such as podcasts, blogs,
    and various tools and libraries. The most impressive user contributions, however,
    can be found in the core language!
  prefs: []
  type: TYPE_NORMAL
- en: Rust's official GitHub repository at [https://github.com/rust-lang](https://github.com/rust-lang)
    holds the source code for many of the resources (for example, the website, blog,
    book, and documentation), and contributions are very welcome.
  prefs: []
  type: TYPE_NORMAL
- en: Mozilla has an impressive record of creating and fostering open source communities,
    and Rust is no different. As active members of these communities, we encourage
    everyone to take part and help make Rust the most enjoyable and useful language
    around!
  prefs: []
  type: TYPE_NORMAL
- en: Requests for Comments (RFCs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the open source nature of Rust, there are some governance rules in place
    to maintain stable and flexible interfaces, yet encourage change and discussion
    as the language evolves.
  prefs: []
  type: TYPE_NORMAL
- en: For something as sensitive as a programming language and its standard library,
    a more rigid process than the regular pull request approval is required to have
    deeper discussions. Imagine the impact of changing a single keyword and how many
    projects would stop working immediately!
  prefs: []
  type: TYPE_NORMAL
- en: This is where RFCs come in. They provide a way for all stakeholders to contribute
    to the discussion with an equal chance to comment. A typical workflow for integrating
    change in open source projects uses the fork and pull method where the contributor
    creates a **pull request** (**PR**) to propose changes ([https://help.github.com/articles/about-pull-requests/](https://help.github.com/articles/about-pull-requests/)).
    Unlike in the RFC process, this gets hard to manage in larger code bases and only
    starts the discussion *after* a solution has been proposed, narrowing the focus
    considerably.
  prefs: []
  type: TYPE_NORMAL
- en: 'A repository of active and past RFCs can be found here: [https://github.com/rust-lang/rfcs](https://github.com/rust-lang/rfcs).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust is a multi-paradigm language with exceptional concepts: the language emphasizes
    data and behavior separation with structures and traits, uses macros for metaprogramming,
    and leverages explicit ownership of memory to determine variable lifetimes. Knowing
    these lifetimes removes the need for runtime garbage collection and, at the same
    time, greatly facilitates concurrency by allowing mutable borrowing only in certain
    circumstances.'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, threads and other asynchronous processes can change variables
    only when they have mutable ownership of them, something that is mostly enforced
    at compile time, but can also be done at runtime! Therefore, safe Rust is effectively
    free of data races.
  prefs: []
  type: TYPE_NORMAL
- en: Another strong point of the Rust ecosystem is its diverse and welcoming community.
    Sponsored by Mozilla, development is guided by RFCs, events are organized and
    centrally advertised, and learning resources are available online. Another way
    to be a part of the ecosystem is to contribute packages to `crates.io` ([https://crates.io/](https://crates.io/)),
    Rust's public package repository. Read the next chapter to find out more about
    `cargo`, Rust's universal tool to build and package.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are traits and how are they different from interfaces?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why doesn't Rust have a garbage collector?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name three examples of how lifetimes are created in Rust (explicitly and implicitly)!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is immutability for variables important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the Sync marker trait do?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where can you go to participate in the Rust community?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are RFCs preferred over PRs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following books for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hands-On Concurrency with Rust* by Brian L. Troutwine (Packt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Programming in Rust* by Andrew Johnson (Packt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
