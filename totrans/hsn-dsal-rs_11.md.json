["```rs\npub struct LCG {\n    xn: f32,\n    m: f32,\n    c: f32,\n    a: f32,\n}\n\nimpl LCG {\n    fn seeded(seed: u32) -> LCG {\n        LCG {\n            xn: seed as f32,\n            m: 2e31,\n            a: 171f32,\n            c: 8f32,\n        }\n    }\n\n    fn new(seed: f32, m: f32, a: f32, c: f32) -> LCG {\n        LCG {\n            xn: seed,\n            m: m,\n            a: a,\n            c: c,\n        }\n    }\n\n    fn next_f32(&mut self) -> f32 {\n        self.xn = (self.a * self.xn + self.c) % self.m;\n        self.xn / self.m\n    }\n}\n```", "```rs\nimpl LCG {\n    fn seeded(seed: u32) -> LCG {\n        LCG {\n            xn: seed as f32,\n            m: 181f32,\n            a: 167f32,\n            c: 0f32,\n        }\n    }\n...\n}\n```", "```rs\nconst S1_MOD: f32 = 30269f32;\nconst S2_MOD: f32 = 30307f32;\nconst S3_MOD: f32 = 30323f32;\n\npub struct WichmannHillRng {\n    s1: f32,\n    s2: f32,\n    s3: f32,\n}\n\nimpl WichmannHillRng {\n    fn new(s1: f32, s2: f32, s3: f32) -> WichmannHillRng {\n        WichmannHillRng {\n            s1: s1,\n            s2: s2,\n            s3: s3,\n        }\n    }\n\n    pub fn seeded(seed: u32) -> WichmannHillRng {\n        let t = seed;\n        let s1 = (t % 29999) as f32;\n        let s2 = (t % 29347) as f32;\n        let s3 = (t % 29097) as f32;\n        WichmannHillRng::new(s1, s2, s3)\n    }\n\n    pub fn next_f32(&mut self) -> f32 {\n        self.s1 = (171f32 * self.s1) % S1_MOD;\n        self.s2 = (172f32 * self.s2) % S2_MOD;\n        self.s3 = (170f32 * self.s3) % S3_MOD;\n        (self.s1 / S1_MOD + self.s2 / S2_MOD + self.s3 / S3_MOD) % 1f32\n    }\n}\n```", "```rs\npub trait Backtracking {\n    fn fill(&self, items: Vec<&Item>) -> u64;\n    fn fill_r(&self, remaining: &[&Item], current_weight: usize) -> i64;\n}\n```", "```rs\n\n#[derive(Debug, PartialEq)]\npub struct Item {\n    pub weight: u32,\n    pub value: u32,\n}\n\npub struct Knapsack {\n    capacity: usize,\n}\n\nimpl Knapsack {\n    pub fn new(capacity: usize) -> Knapsack {\n        Knapsack { capacity: capacity }\n    }\n}\n\nimpl Backtracking for Knapsack {\n\n    fn fill(&self, items: Vec<&Item>) -> u64 {\n        let value = self.fill_r(&items, 0);\n        if value < 0 {\n            0\n        } else {\n            value as u64\n        }\n    }\n\n    fn fill_r(&self, remaining: &[&Item], current_weight: usize)\n     -> i64 {\n        let w = current_weight;\n\n        if w > self.capacity {\n            return i64::min_value();\n        }\n\n        if remaining.len() > 0 && w < self.capacity {\n            let include = remaining[0].value as i64\n                + self.fill_r(&remaining[1..], current_weight \n                + remaining[0].weight as usize);\n            let exclude = self.fill_r(&remaining[1..], current_weight);\n            if include >= exclude {\n                include\n            } else {\n                exclude\n            }\n        } else {\n            0\n        }\n    }\n\n}\n```", "```rs\npub struct ChessBoard {\n    board: Vec<Vec<bool>>,\n    n: usize,\n}\n\nimpl ChessBoard {\n    pub fn new(n: usize) -> ChessBoard {\n        ChessBoard {\n            n: n,\n            board: vec![vec![false; n]; n],\n        }\n    }\n\n    pub fn place_queens(&mut self) -> bool {\n        self.place_queens_r(0)\n    }\n\n    pub fn place_queens_r(&mut self, column: usize) -> bool {\n        if column < self.n {\n            for r in 0..self.n {\n                if self.is_valid(r, column) {\n                    self.board[r][column] = true;\n                    if self.place_queens_r(column + 1) {\n                        return true;\n                    }\n\n                    self.board[r][column] = false;\n                }\n            }\n            false\n        }\n        else {\n            true\n        }\n    }\n\n    fn is_valid(&self, row: usize, col: usize) -> bool {\n        for i in 0..self.n {\n            if self.board[i][col] {\n                return false;\n            }\n            if self.board[row][i] {\n                return false;\n            }\n        }\n        let mut i = 0;\n        let (mut left_lower, mut left_upper, mut right_lower, \n             mut right_upper) =\n            (true, true, true, true);\n\n        while left_lower || left_upper || right_lower || right_upper {\n            if left_upper && self.board[row - i][col - i] {\n                return false;\n            }\n            if left_lower && self.board[row + i][col - i] {\n                return false;\n            }\n            if right_lower && self.board[row + i][col + i] {\n                return false;\n            }\n            if right_upper && self.board[row - i][col + i] {\n                return false;\n            }\n            i += 1;\n            left_upper = row as i64 - i as i64 >= 0 \n                         && col as i64 - i as i64 >= 0;\n            left_lower = row + i < self.n && col as i64 - i \n                         as i64 >= 0;\n\n            right_lower = row + i < self.n && col + i < self.n;\n            right_upper = row as i64 - i as i64 >= 0 \n                          && col + i < self.n;\n        }\n        true\n    }\n// ...\n}\n```", "```rs\npub trait DynamicProgramming {\n    fn fill(&self, items: Vec<&Item>) -> u64;\n}\n```", "```rs\n\nimpl DynamicProgramming for Knapsack {\n\n    fn fill(&self, items: Vec<&Item>) -> u64 {\n        let mut cache = vec![vec![0u64; self.capacity + 1]; \n                        items.len() + 1];\n        for i in 1..items.len() + 1 {\n            for w in 1..self.capacity + 1 {\n                if items[i -1].weight as usize <= w {\n                    let prev_weight = \n                        w - (items[i - 1].weight as usize);\n                    cache[i][w] = max(\n                        items[i - 1].value as u64 \n                        + cache[i - 1][prev_weight],\n                        cache[i - 1][w],\n                    );\n                } else {\n                    cache[i][w] = cache[i - 1][w]\n                }\n            }\n        }\n        cache[items.len()][self.capacity]\n    }\n}\n\n```", "```rs\nimpl Phenotype<TourFitness> for TspTour {\n    ///\n    /// The Euclidean distance of an entire tour.\n    ///\n    fn fitness(&self) -> TourFitness {\n        let tour_cities: Vec<&City> = self.tour.iter().map(|t| \n                                      &self.cities[*t]).collect();\n        let mut fitness = 0f32;\n        for i in 1..tour_cities.len() {\n            fitness += distance(tour_cities[i], tour_cities[i - 1]);\n        }\n        -(fitness.round() as i32)\n    }\n\n    ///\n    /// Implements the crossover for a TSP tour using PMX\n    ///\n    fn crossover(&self, other: &TspTour) -> TspTour {\n        // ...\n\n        TspTour {\n            tour: offspring,\n            cities: self.cities.clone(),\n            rng_cell: self.rng_cell.clone(),\n        }\n    }\n\n    ///\n    /// Mutates the solution by swapping neighbors at a chance\n    ///\n    fn mutate(&self) -> TspTour {\n        let mut rng = self.rng_cell.borrow_mut();\n        if rng.gen::<f32>() < MUTPROB {\n            let mut mutated: Tour = self.tour.clone();\n            for i in 0..mutated.len() {\n                if rng.gen::<f32>() < INDPB {\n                    let mut swap_idx = rng.gen_range(0, \n                                       mutated.len() - 2);\n                    if swap_idx >= i {\n                        swap_idx += 1;\n                    }\n                    let tmp = mutated[i];\n                    mutated[i] = mutated[swap_idx];\n                    mutated[swap_idx] = tmp;\n                }\n            }\n            TspTour {\n                tour: mutated,\n                cities: self.cities.clone(),\n                rng_cell: self.rng_cell.clone(),\n            }\n        } else {\n            self.clone()\n        }\n    }\n}\n```"]