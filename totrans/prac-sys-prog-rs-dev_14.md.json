["```rs\nrustup --version\nrustc --version\ncargo --version\n```", "```rs\nuse std::net::{Ipv4Addr, Ipv6Addr};\n\nfn main() {\n    // Create a new IPv4 address with four 8-bit integers\n    let ip_v4_addr1 = Ipv4Addr::new(106, 201, 34, 209);\n    // Use the built-in constant to create a new loopback \n    // (localhost) address\n    let ip_v4_addr2 = Ipv4Addr::LOCALHOST;\n    println!(\n        \"Is ip_v4_addr1 a loopback address? {}\",\n        ip_v4_addr1.is_loopback()\n    );\n    println!(\n        \"Is ip_v4_addr2 a loopback address? {}\",\n        ip_v4_addr2.is_loopback()\n    );\n    //Create a new IPv6 address with eight 16-bit  \n    // integers, represented in hex\n    let ip_v6_addr = Ipv6Addr::new(2001, 0000, 3238, \n        0xDFE1, 0063, 0000, 0000, 0xFEFB);\n    println!(\"IPV6 segments {:?}\", ip_v6_addr.segments());\n}\n```", "```rs\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n\nfn main() {\n    // Create an ipv4 address\n    let ip_v4_addr = IpAddr::V4(Ipv4Addr::new(106, 201, 34, \n        209));\n    // check if an address is ipv4 or ipv6 address\n    println!(\"Is ip_v4_addr an ipv4 address? {}\", \n        ip_v4_addr.is_ipv4());\n    println!(\"Is ip_v4_addr an ipv6 address? {}\", \n        ip_v4_addr.is_ipv6());\n\n    // Create an ipv6 address\n    let ip_v6_addr = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, \n        0, 0, 0, 1));\n    println!(\"Is ip_v6_addr an ipv6 address? {}\", \n        ip_v6_addr.is_ipv6());\n}\n```", "```rs\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\nfn main() {\n    // Create an ipv4 socket \n    let socket = SocketAddr::new(IpAddr::V4(\n        Ipv4Addr::new(127,0,0,1)),8000);\n    println!(\"Socket address is {}, port is {}\",\n        socket.ip(), socket.port());\n    println!(\"Is this IPv6 socket?{}\",socket.is_ipv6());\n}\n```", "```rs\ncargo new tcpudp && cd tcpudp\n```", "```rs\nuse std::str;\nuse std::thread;\n\nfn main() {\n    let socket = UdpSocket::bind(\"127.0.0.1:3000\").expect(\n        \"Unable to bind to port\");\n    let mut buffer = [0; 1024];\n    loop {\n        let socket_new = socket.try_clone().expect(\n            \"Unable to clone socket\");\n        match socket_new.recv_from(&mut buffer) {\n            Ok((num_bytes, src_addr)) => {\n                thread::spawn(move || {\n                    let send_buffer = &mut \n                        buffer[..num_bytes];\n                    println!(\n                        \"Received from client:{}\",\n                        str::from_utf8(\n                            send_buffer).unwrap()\n                    );\n                    let response_string =\n                        format!(\"Received this: {}\", \n                            String::from_utf8_lossy(\n                            send_buffer));\n                    socket_new\n                        .send_to(&response_string\n                            .as_bytes(), &src_addr)\n                        .expect(\"error in sending datagram \n                            to remote socket\");\n                });\n            }\n            Err(err) => {\n                println!(\"Error in receiving datagrams over \n                    UDP: {}\", err);\n            }\n        }\n    }\n}\n```", "```rs\nuse std::net::UdpSocket;\nfn main() {\n    // Create a local UDP socket\n    let socket = UdpSocket::bind(\"0.0.0.0:0\").expect(\n        \"Unable to bind to socket\");\n    // Connect the socket to a remote socket\n    socket\n        .connect(\"127.0.0.1:3000\")\n        .expect(\"Could not connect to UDP server\");\n    println!(\"socket peer addr is {:?}\", \n        socket.peer_addr());\n    // Send a datagram to the remote socket\n    socket\n        .send(\"Hello: sent using send() call\".as_bytes())\n        .expect(\"Unable to send bytes\");\n}\n```", "```rs\ncargo run --bin  udp-server\n```", "```rs\ncargo run --bin  udp-client\n```", "```rs\nuse std::io::{Read, Write};\nuse std::net::TcpListener;\nfn main() {\n    let connection_listener = TcpListener::bind(\n        \"127.0.0.1:3000\").unwrap();\n    println!(\"Running on port 3000\");\n    for stream in connection_listener.incoming() {\n        let mut stream = stream.unwrap();\n        println!(\"Connection established\");\n        let mut buffer = [0; 100];\n        stream.read(&mut buffer).unwrap();\n        println!(\"Received from client: {}\", \n            String::from_utf8_lossy(&buffer));\n        stream.write(&mut buffer).unwrap();\n    }\n}\n```", "```rs\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nuse std::str;\nfn main() {\n    let mut stream = TcpStream::connect(\n        \"localhost:3000\").unwrap();\n    let msg_to_send = \"Hello from TCP client\";\n    stream.write(msg_to_send.as_bytes()).unwrap();\n    let mut buffer = [0; 200];\n    stream.read(&mut buffer).unwrap();\n    println!(\n        \"Got echo back from server:{:?}\",\n        str::from_utf8(&buffer)\n            .unwrap()\n            .trim_end_matches(char::from(0))\n    );\n}\n```", "```rs\ncargo run --bin  tcp-server\n```", "```rs\ncargo run --bin  tcp-client\n```", "```rs\ncargo new tcpproxy && cd tcpproxy\n```", "```rs\nuse std::io::{Read, Write};\nuse std::net::TcpListener;\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\nuse std::str;\nuse std::str::FromStr;\nuse std::string::ParseError;\n```", "```rs\n#[derive(Debug)]\nstruct RequestLine {\n    method: Option<String>,\n    path: Option<String>,\n    protocol: Option<String>,\n}\n\nimpl RequestLine {\n    fn method(&self) -> String {\n        if let Some(method) = &self.method {\n            method.to_string()\n        } else {\n            String::from(\"\")\n        }\n    }\n    fn path(&self) -> String {\n        if let Some(path) = &self.path {\n            path.to_string()\n        } else {\n            String::from(\"\")\n        }\n    }\n    fn get_order_number(&self) -> String {\n        let path = self.path();\n        let path_tokens: Vec<String> = path.split(\"/\").map(\n            |s| s.parse().unwrap()).collect();\n        path_tokens[path_tokens.len() - 1].clone()\n    }\n}\n```", "```rs\n<HTTP-method> <path> <protocol>\n```", "```rs\nimpl FromStr for RequestLine {\n    type Err = ParseError;\n    fn from_str(msg: &str) -> Result<Self, Self::Err> {\n        let mut msg_tokens = msg.split_ascii_whitespace();\n        let method = match msg_tokens.next() {\n            Some(token) => Some(String::from(token)),\n            None => None,\n        };\n        let path = match msg_tokens.next() {\n            Some(token) => Some(String::from(token)),\n            None => None,\n        };\n        let protocol = match msg_tokens.next() {\n            Some(token) => Some(String::from(token)),\n            None => None,\n        };\n\n        Ok(Self {\n            method: method,\n            path: path,\n            protocol: protocol,\n        })\n    }\n}\n```", "```rs\n    // Start the origin server\n    let port = 3000;\n    let socket_addr = SocketAddr::new(IpAddr::V4(\n        Ipv4Addr::new(127, 0, 0, 1)), port);\n    let connection_listener = TcpListener::bind(\n        socket_addr).unwrap();\n\n    println!(\"Running on port: {}\", port);\n```", "```rs\n    for stream in connection_listener.incoming() {\n    //processing of incoming HTTP requests\n}\n```", "```rs\n        // Read the first line of incoming HTTP request \n        // and convert it into RequestLine struct\n        let mut stream = stream.unwrap();\n        let mut buffer = [0; 200];\n        stream.read(&mut buffer).unwrap();\n        let req_line = \"\";\n        let string_request_line =\n            if let Some(line) = str::from_utf8(\n                &buffer).unwrap().lines().next() {\n                line\n            } else {\n                println!(\"Invalid request line received\");\n                req_line\n            }; \n        let req_line = RequestLine::from_str(\n            string_request_line).unwrap();\n```", "```rs\n        // Construct the HTTP response string \n        let html_response_string;\n        let order_status;\n        println!(\"len is {}\", req_line.get_order_number()\n            .len());\n\n        if req_line.method() != \"GET\"\n            || !req_line.path().starts_with(\n               \"/order/status\")\n            || req_line.get_order_number().len() == 0\n        {\n            if req_line.get_order_number().len() == 0 {\n                order_status = format!(\"Please provide \n                    valid order number\");\n            } else {\n                order_status = format!(\"Sorry,this page is \n                    not found\");\n            }\n\n            html_response_string = format!(\n                \"HTTP/1.1 404 Not Found\\nContent-Type: \n                    text/html\\nContent-Length:{}\\n\\n{}\",\n                order_status.len(),\n                order_status\n            );\n}\n```", "```rs\n         else {\n            order_status = format!(\n                \"Order status for order number {} is: \n                    Shipped\\n\",\n                req_line.get_order_number()\n            );\n            html_response_string = format!(\n                \"HTTP/1.1 200 OK\\nContent-Type: \n                    text/html\\nContent-Length:{}\\n\\n{}\",\n                order_status.len(),\n                order_status\n            );\n        }\n```", "```rs\nstream.write(html_response_string.as_bytes()).unwrap();\n```", "```rs\ncargo run --bin origin\n```", "```rs\nlocalhost:3000/order/status/2\n```", "```rs\nlocalhost:3000/invalid/path\n```", "```rs\nlocalhost:3000/order/status/\n```", "```rs\nuse std::env;\nuse std::io::{Read, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::process::exit;\nuse std::thread;\n```", "```rs\n    // Accept command-line parameters for proxy_stream and \n    // origin_stream\n    let args: Vec<_> = env::args().collect();\n    if args.len() < 3 {\n        eprintln!(\"Please provide proxy-from and proxy-to \n            addresses\");\n        exit(2);\n    }\n    let proxy_server = &args[1];\n    let origin_server = &args[2];\n    // Start a socket server on proxy_stream\n    let proxy_listener;\n    if let Ok(proxy) = TcpListener::bind(proxy_server) {\n        proxy_listener = proxy;\n        let addr = proxy_listener.local_addr()\n            .unwrap().ip();\n        let port = proxy_listener.local_addr().unwrap()\n            .port();\n        if let Err(_err) = TcpStream::connect(\n            origin_server) {\n            println!(\"Please re-start the origin server\");\n            exit(1);\n        }\n        println!(\"Running on Addr:{}, Port:{}\\n\", addr, \n            port);\n    } else {\n        eprintln!(\"Unable to bind to specified proxy \n            port\");\n        exit(1);\n    }\n```", "```rs\n    // Listen for incoming connections from proxy_server \n    // and read byte stream\n    let mut thread_handles = Vec::new();\n    for proxy_stream in proxy_listener.incoming() {\n        let mut proxy_stream = proxy_stream.expect(\"Error \n            in incoming TCP connection\");\n        // Establish a new TCP connection to origin_stream\n        let mut origin_stream =\n            TcpStream::connect(origin_server).expect(\n                \"Please re-start the origin server\");\n        let handle =\n            thread::spawn(move || handle_connection(&mut  \n                proxy_stream, &mut origin_stream));\n        thread_handles.push(handle);\n    }\n    for handle in thread_handles {\n        handle.join().expect(\"Unable to join child \n            thread\");\n    }\n```", "```rs\nfn handle_connection(proxy_stream: &mut TcpStream, \n    origin_stream: &mut TcpStream) {\n    let mut in_buffer: Vec<u8> = vec![0; 200];\n    let mut out_buffer: Vec<u8> = vec![0; 200];\n    // Read incoming request to proxy_stream\n    if let Err(err) = proxy_stream.read(&mut in_buffer) {\n        println!(\"Error in reading from incoming proxy \n            stream: {}\", err);\n    } else {\n        println!(\n            \"1: Incoming client request: {}\",\n            String::from_utf8_lossy(&in_buffer)\n        );\n    }\n    // Write the byte stream to origin_stream\n    let _ = origin_stream.write(&mut in_buffer).unwrap();\n    println!(\"2: Forwarding request to origin server\\n\");\n    // Read response from the backend server\n    let _ = origin_stream.read(&mut out_buffer).unwrap();\n    println!(\n        \"3: Received response from origin server: {}\",\n        String::from_utf8_lossy(&out_buffer)\n    );\n    // Write response back to the proxy client\n    let _ = proxy_stream.write(&mut out_buffer).unwrap();\n    println!(\"4: Forwarding response back to client\");\n}\n```", "```rs\ncargo run --bin origin\n```", "```rs\ncargo run --bin proxy localhost:3001 localhost:3000\n```", "```rs\nlocalhost:3001/order/status/2\n```", "```rs\nlocalhost:3001/invalid/path\n```", "```rs\nlocalhost:3001/order/status/\n```"]