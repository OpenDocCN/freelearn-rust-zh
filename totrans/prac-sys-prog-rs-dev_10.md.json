["```rs\nrustc –version\ncargo --version\n```", "```rs\nuse std::process::Command;\nfn main() {\n    Command::new(\"ls\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n}\n```", "```rs\nuse std::process::Command;\nfn main() {\n    Command::new(\"ls\")\n        .arg(\"-l\")\n        .arg(\"-h\")\n        .spawn()\n        .expect(\"ls command failed to start\");\n}\n```", "```rs\nCommand::new(\"ls\")\n        .args(&[\"-l\", \"-h\"]).spawn().unwrap();\n```", "```rs\n    Command::new(\"ls\")\n        .current_dir(\"..\")\n        .args(&[\"-l\", \"-h\"])\n        .spawn()\n        .expect(\"ls command failed to start\");\n```", "```rs\n cargo run \n```", "```rs\n    let output = Command::new(\"cat\").arg(\"a.txt\").output().\n        unwrap();\n    if !output.status.success() {\n        println!(\"Command executed with failing error code\");\n    }\n    println!(\"printing: {}\", String::from_utf8(output.stdout).\n        unwrap());\n```", "```rs\necho \"Hello World\" > a.txt\n```", "```rs\nuse std::process;\nfn main() {\n    println!(\"Going to abort process\");\n    process::abort();\n    // This statement will not get executed\n    println!(\"Process aborted\");\n}\n```", "```rs\nuse std::process;\nfn main() {\n    println!(\"Going to exit process with error code 64\"); \n    process::exit(64);\n    // execution never gets here\n    println!(\"Process exited\");\n}\n```", "```rs\nuse std::process::Command;\nfn main() {\n    let status = Command::new(\"cat\")\n        .arg(\"non-existent-file.txt\")\n        .status()\n        .expect(\"failed to execute cat\");\n\n    if status.success() {\n        println!(\"Successful operation\");\n    } else {\n        println!(\"Unsuccessful operation\");\n    }\n}\n```", "```rs\nuse std::io::prelude::*;\nuse std::process::{Command, Stdio};\n\nfn main() {\n    // Spawn the `ps` command\n    let process = match Command::new(\"ps\").\n    stdout(Stdio::piped()).spawn() {\n        Err(err) => panic!(\"couldn't spawn ps: {}\", err),\n        Ok(process) => process,\n    };\n    let mut ps_output = String::new();\n    match process.stdout.unwrap().read_to_string(&mut     \n    ps_output) {\n        Err(err) => panic!(\"couldn't read ps stdout: {}\", \n            err),\n        Ok(_) => print!(\"ps output from child process \n            is:\\n{}\", ps_output),\n    }\n}\n```", "```rs\n    let process = match Command::new(\"rev\")\n        .stdin(Stdio::piped())               <1>\n        .stdout(Stdio::piped())              <2>\n        .spawn()\n    {\n        Err(err) => panic!(\"couldn't spawn rev: {}\", err),\n        Ok(process) => process,\n    };\n    match process.stdin.unwrap().write_all\n        (\"palindrome\".as_bytes()) {\n        Err(why) => panic!(\"couldn't write to stdin: {}\", \n            why),\n        Ok(_) => println!(\"sent text to rev command\"),\n    }                                      <3>\n    let mut child_output = String::new();\n    match process.stdout.unwrap().read_to_string(&mut \n        child_output) {\n        Err(err) => panic!(\"couldn't read stdout: {}\", err),\n        Ok(_) => print!(\"Output from child process is:\\n{}\", \n            child_output),\n    }                                             <4>\n```", "```rs\nuse std::process::Command;\nfn main() {\n    Command::new(\"env\")\n        .env(\"MY_PATH\", \"/tmp\")\n        .spawn()\n        .expect(\"Command failed to execute\");\n}\n```", "```rs\ncargo run | grep MY_PATH\n```", "```rs\n    Command::new(\"env\")\n        .env_clear()\n        .spawn()\n        .expect(\"Command failed to execute\");\n```", "```rs\nuse std::process::{Command, Stdio};\nfn main() {\n    let _child_process = match Command::new(\"invalid-command\")\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .spawn()\n    {\n        Err(err) => panic!(\"Unable to spawn child process: \n            {}\", err),\n        Ok(new_process_handle) => {\n            println!(\"Successfully spawned child process\");\n            new_process_handle\n        }\n    };\n} \n```", "```rs\nuse std::panic;\nuse std::process::{Stdio,Command};\nfn main() {\npanic::set_hook(Box::new(|_| {\n            println!(\" This is an example of custom panic \n                hook, which is invoked on thread panic, but \n                before the panic run-time is invoked\")\n        }));       \n    let _child_process = match Command::new(\"invalid-command\")\n        .stdin(Stdio::piped())\n        .stdout(Stdio::piped())\n        .spawn()\n    {\n        Err(err) => panic!(\"Normal panic message {}\", err),\n        Ok(new_process_handle) => new_process_handle,\n    };\n}\n```", "```rs\n[dependencies]\nsignal-hook = \"0.1.16\"\n```", "```rs\nuse signal_hook::iterator::Signals;\nuse std::io::Error;\nfn main() -> Result<(), Error> {\n    let signals = Signals::new(&[signal_hook::SIGTERM, \n        signal_hook::SIGINT])?;\n    'signal_loop: loop {\n        // Pick up signals that arrived since last time\n        for signal in signals.pending() {\n            match signal {\n                signal_hook::SIGINT => {\n                    println!(\"Received signal SIGINT\");\n                }\n                signal_hook::SIGTERM => {\n                    println!(\"Received signal SIGTERM\");\n                    break 'signal_loop;\n                }\n                _ => unreachable!(),\n            }\n        }\n    }\n    println!(\"Terminating program\");\n    Ok(())\n}\n```", "```rs\n    cargo new myshell && cd myshell\n    ```", "```rs\n    [[bin]]\n    name = \"iter1\"\n    path = \"src/iter1.rs\"\n    [[bin]]\n    name = \"iter2\"\n    path = \"src/iter2.rs\"\n    [[bin]]\n    name = \"iter3\"\n    path = \"src/iter3.rs\"\n    ```", "```rs\nuse std::io::Write;\nuse std::io::{stdin, stdout};\nuse std::process::Command;\nfn main() {\n    loop {\n        print!(\"$ \");                               <1>\n        stdout().flush().unwrap();                  <2>\n        let mut user_input = String::new();         <3>\n        stdin()\n            .read_line(&mut user_input)             <4>\n            .expect(\"Unable to read user input\");\t\n        let command_to_execute = user_input.trim(); <5>\n        let mut child = Command::new(command_to_execute) <6>\n            .spawn()\n            .expect(\"Unable to execute command\");\n        child.wait().unwrap();                       <7>\n    }\n}\n```", "```rs\ncargo run –-bin iter1 \n```", "```rs\n// Module imports not shown here\nfn main() {\n    loop {\n        print!(\"$ \");\n        stdout().flush().unwrap();\n        let mut user_input = String::new();\n        stdin()\n            .read_line(&mut user_input)\n            .expect(\"Unable to read user input\");\n        let command_to_execute = user_input.trim();\n        let command_args: Vec<&str> =      \n            command_to_execute.split_whitespace().\n            collect(); <1>\n\n        let mut child = Command::new(command_args[0])            \n                                                       <2>\n            .args(&command_args[1..])   <3>\n            .spawn()\n            .expect(\"Unable to execute command\");\n        child.wait().unwrap();\n    }\n}\n```", "```rs\n    cargo run -–bin iter2 \n    ```", "```rs\n    ls –lah\n    ps -ef\n    cat a.txt \n    ```", "```rs\nshow files\n```", "```rs\nuse std::io::Write;\nuse std::io::{stdin, stdout};\nuse std::io::{Error, ErrorKind};\nuse std::process::Command;\n```", "```rs\n    if command_args.len() > 0 {..}\n    ```", "```rs\n                let child = match command_args[0] {\n                    \"show\" if command_args.len() > 1 => match \n                        command_args[1] {\n                        \"files\" => Command::new(\"ls\").\n                            args(&command_args[2..]).spawn(),\n\n                        \"process\" => Command::new(\"ps\").args\n                            (&command_args[2..]).spawn(),\n\n                        _ => Err(Error::new(\n                            ErrorKind::InvalidInput,\n                            \"please enter valid command\",\n                        )),\n                    },\n                    \"show\" if command_args.len() == 1 => \n                        Err(Error::new(\n                        ErrorKind::InvalidInput,\n                        \"please enter valid command\",\n                    )),\n                    \"quit\" => std::process::exit(0),\n                    _ => Command::new(command_args[0])\n                        .args(&command_args[1..])\n                        .spawn(),\n                };\n    ```", "```rs\n                match child {\n                    Ok(mut child) => {\n                        if child.wait().unwrap().success() {\n                        } else {\n                            println!(\"\\n{}\", \"Child process \n                                failed\")\n                        }\n                    }\n                    Err(e) => match e.kind() {\n                        ErrorKind::InvalidInput => eprintln!(                        \n                            \"Sorry, show command only \n                            supports following options: files \n                            , process \"\n                        ),\n                        _ => eprintln!(\"Please enter a \n                            valid command\"),\n                    },\n                }\n    ```", "```rs\n    show files\n    show process \n    du\n    ```", "```rs\nshow memory\nshow\ninvalid-command\n```"]