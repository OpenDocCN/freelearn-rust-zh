- en: Memory Management in Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust中的内存管理
- en: Until now, we have always talked about how the Rust compiler handles the memory
    by itself, and how that makes it memory-safe and gives us some extra superpowers
    without the fear of creating memory vulnerabilities. Nevertheless, there is no
    limit to what you can accomplish by using unsafe scopes, and even by using safe
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在谈论Rust编译器如何自己处理内存，以及这如何使它内存安全，并给我们一些额外的超级能力，而无需担心创建内存漏洞。尽管如此，使用不可安全作用域，甚至使用安全代码，你所能完成的事情是没有限制的。
- en: We will check all the configuration and metaprogramming options that Rust gives
    us regarding memory management and see how we can improve our code by using both
    safe and unsafe code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查Rust提供的所有有关内存管理的配置和元编程选项，并看看我们如何通过使用安全和不可安全代码来改进我们的代码。
- en: 'In this chapter, we will be looking into the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Learning the rules of the borrow checker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习借用检查器的规则
- en: Binding lifetimes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定生命周期
- en: Memory representation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存表示
- en: Data representation for FFI with C/C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与C/C++的FFI数据表示
- en: Shared pointers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享指针
- en: Reference counted pointers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数指针
- en: Mastering the borrow checker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握借用检查器
- en: 'To ensure memory and thread safety, Rust''s borrow checker has three simple
    rules. They are enforced all through the code except in unsafe scopes. Here they
    are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保内存和线程安全，Rust的借用检查器有三个简单的规则。除了在不可安全的作用域之外，这些规则贯穿整个代码。以下是它们：
- en: Each binding will have an owner
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个绑定都将有一个所有者
- en: There can only be one owner for a binding
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绑定只能有一个所有者
- en: When the owner goes out of the scope, the binding gets dropped
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有者超出作用域时，绑定将被丢弃
- en: These three rules seem simple enough, but they have a great implication on how
    we code. The compiler can know beforehand when an owner goes out of scope, so
    it will always know when to drop/destruct a binding/variable. This means that
    you can write your code without having to think about where you create variables,
    where you call destructors, or whether you have already called a destructor or
    you are calling it twice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这三条规则看起来很简单，但它们对我们编码方式的影响很大。编译器可以在所有者超出作用域之前就知道，所以它总是会知道何时释放/销毁绑定/变量。这意味着你可以编写代码，而无需考虑在哪里创建变量，在哪里调用析构函数，或者你是否已经调用过析构函数或者你正在重复调用它。
- en: Of course, this comes with an additional learning curve that can sometimes be
    difficult to catch up. The second rule is what most people find difficult to manage.
    Since there can only be one owner at a time, sharing information sometimes becomes
    somewhat difficult.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这伴随着一个额外的学习曲线，有时可能很难跟上。第二条规则是大多数人发现难以管理。由于一次只能有一个所有者，共享信息有时变得有些困难。
- en: 'Let''s see an example of this behavior with a known type, the `Vec` type:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个已知类型，`Vec`类型的例子，来看看这种行为：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will print the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '![](img/9e603958-352b-4675-b3e4-635253803fb6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e603958-352b-4675-b3e4-635253803fb6.png)'
- en: At the end of the current scope (the `main()` function, for example), the vector
    will be dropped by calling its destructor. In this case, it will simply deallocate
    the memory cleanly and then destroy itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前作用域的末尾（例如`main()`函数），将通过调用其析构函数来丢弃向量。在这种情况下，它将简单地干净地释放内存然后销毁自己。
- en: Allocations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配
- en: For a variable to be growable (so that it can occupy different amounts of space
    in the memory at different times), it needs to be allocated on the heap, and not
    on the stack. The stack works faster, since on the loading of the program, it
    gets assigned to it. But the heap is slower, since for each allocation you need
    to perform a system call to the kernel, which means you will need a context switch
    (to kernel mode) and back (to user mode). This makes things too slow.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使变量可增长（以便它可以在不同时间占据内存中的不同空间），它需要在堆上分配，而不是在栈上。栈工作得更快，因为程序加载时，它会自动分配给它。但堆较慢，因为每次分配都需要对内核执行系统调用，这意味着你需要进行上下文切换（到内核模式）然后再切换回来（到用户模式）。这会使事情变得太慢。
- en: 'Vectors (and other standard library structures) have an interesting way of
    allocating that memory so that they perform as efficiently as possible. Let''s
    check the algorithm it uses to allocate new memory with this code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 向量（以及其他标准库结构）有一种有趣的内存分配方式，以便它们尽可能高效地执行。让我们检查它使用此代码分配新内存的算法：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output should be something along these lines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '![](img/ad0089ad-34f2-4d39-80f3-82a12241a276.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad0089ad-34f2-4d39-80f3-82a12241a276.png)'
- en: This means that, at the beginning, the vector will have allocated only the space
    required by our first two elements. But as soon as we push a new one, it will
    allocate space for two new elements, so that with the fourth push it won't need
    to allocate more memory. When we finally insert a fifth element, it allocates
    space for another four, so that it does not need to allocate until it gets to
    the ninth.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，一开始，向量只会分配我们前两个元素所需的空间。但一旦我们添加一个新的元素，它将为两个新元素分配空间，所以当进行第四次push时，它就不需要再分配更多内存。当我们最终插入第五个元素时，它为另一个四个元素分配空间，这样它就不需要再分配，直到它达到第九个。
- en: If you follow the progression, the next time it will allocate space for 8 more
    elements, making the capacity grow to 16\. This is dependent on the first allocation,
    and if we had started the vector with 3 elements, the numbers would be 3, 6, 12,
    24,... We can, in any case, force the vector to pre-allocate a given number of
    elements with two functions, `reserve()` and `reserve_exact()`. The former will
    reserve space for at least the given number of elements, while the latter will
    reserve space exactly for the given number of elements. This is really useful
    when you know the size of the input, so that it doesn't need to allocate once
    and again. It will just allocate once.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这个进程，下一次它将为8个更多元素分配空间，使容量增长到16。这取决于第一次分配，如果我们从3个元素开始向量，数字将是3、6、12、24...无论如何，我们可以使用两个函数`reserve()`和`reserve_exact()`强制向量预先分配一定数量的元素。前者将为至少给定数量的元素保留空间，而后者将为正好给定数量的元素保留空间。当你知道输入的大小，这样它就不需要一次又一次地分配，这非常有用。它只会分配一次。
- en: Mutability, borrowing, and owning
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性、借用和拥有
- en: 'There are also rules about mutability in Rust, that prevent data races between
    threads. Let''s see them:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Rust中还有一些关于可变性的规则，可以防止线程之间的数据竞争。让我们看看它们：
- en: All bindings are immutable by default
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有绑定默认都是不可变的
- en: There can be unlimited immutable borrows of a binding at the same time
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一时间可以有无限制的不可变借用
- en: There can only be one mutable borrow of a binding at most at a given point in
    time
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何给定时间点，一个绑定最多只能有一个可变借用
- en: If there is a mutable borrow, no immutable borrows can coexist at a given point
    in time
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在可变借用，则在该时间点不能存在不可变借用
- en: They are fairly simple to understand. You can read the contents of a binding
    from as many places as you would like, but if you want to modify a binding, you
    must somehow ensure that no readers or other writers exist. This, of course, prevents
    data races, but makes your coding a bit more troublesome.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它们相对容易理解。你可以从你想要的地方读取绑定内容，但如果你想修改一个绑定，你必须确保没有其他读者或写者存在。这当然可以防止数据竞争，但会使你的编码变得有些麻烦。
- en: 'Let''s see this with a couple of examples. Let''s first define these two functions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个例子来看看这个。首先定义这两个函数：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `change_third()` function requires a mutable `u32` slice that will use
    to add `1` to the third element if the slice has at least three elements. The
    second will print that element. You can then use this `main()` function to test
    it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`change_third()`函数需要一个可变的`u32`切片，如果切片至少有三个元素，它将用于将`1`添加到第三个元素。第二个将打印该元素。然后你可以使用这个`main()`函数来测试它：'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, since the two functions borrow the vector (one of them mutably
    and the other one immutably), you can continue using the vector in the `main()`
    function. This means that the ownership of the vector is in the `main()` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于两个函数都借用了向量（一个可变借用，另一个不可变借用），您可以在`main()`函数中继续使用向量。这意味着向量的所有权在`main()`函数中。
- en: 'If we had a function that took ownership of the vector, we wouldn''t be able
    to use it later. Consider changing the `change_third()` function for this one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个拥有向量所有权的函数，我们就无法在以后使用它。考虑将`change_third()`函数更改为这个：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, the function receives the argument and takes ownership of the
    vector (there is no slicing or referencing on the function declaration). Of course,
    we will need to change the call to the function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数接收参数并拥有向量的所有权（在函数声明中没有切片或引用）。当然，我们需要更改对函数的调用：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The issue is that the program will no longer compile. After we give the ownership
    of the vector to the `change_third()` function, there will no longer be a `my_vector`
    variable in the `main()` function. The error that the Rust compiler shows is really
    clarifying, and it will even point out where the issue is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于程序将无法编译。在我们将向量的所有权交给`change_third()`函数之后，`main()`函数中将不再有`my_vector`变量。Rust编译器显示的错误信息非常明确，它甚至会指出问题所在：
- en: '![](img/95d20d42-bcaf-4713-bf81-18b287cbd42c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95d20d42-bcaf-4713-bf81-18b287cbd42c.png)'
- en: In conclusion, if you need to continue using the variable after using it to
    call a function, pass it by reference, let the function borrow your variable but
    not own it. If you don't, and you prefer the new function to have absolute control
    over the variable (even to drop it), pass it by value. This doesn't apply to `Copy`
    types, as we saw in [Chapter 1](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml), *Common
    Performance Pitfalls*, since, in that case, the whole object gets copied to the
    new function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果你在使用变量调用函数之后还需要继续使用该变量，应该通过引用传递，让函数借用你的变量但不拥有它。如果不这样做，而你又希望新函数对变量有绝对的控制权（甚至可以丢弃它），那么就通过值传递。这一点不适用于`Copy`类型，正如我们在[第一章](ad672e4d-0f5e-4c59-b823-249da183abc8.xhtml)中看到的，*常见性能陷阱*，因为在这种情况下，整个对象都会被复制到新函数中。
- en: References can be a little difficult to manage though. We sometimes require
    a structure to have a referenced value, but since the structure won't have ownership
    of the variable to drop it, it will have to make sure that the owner of the variable
    doesn't do it while it is still in use. For this, we have lifetimes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 引用可能有点难以管理。我们有时需要结构体具有引用值，但由于结构体不会拥有变量以丢弃它，它必须确保变量所有者不会在使用期间丢弃它。为此，我们有生命周期。
- en: Lifetimes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'Every variable, structure attribute, and constant has a lifetime in Rust. Most
    of them can be elided, since we usually know that a constant has a static lifetime
    (it will always be there for us), or that most of the variables have the lifetime
    of its scope. Nevertheless, there is sometimes a place where we need to specify
    that lifetime. Let''s check the following structures:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，每个变量、结构体属性和常量都有一个生命周期。其中大多数都可以省略，因为我们通常知道常量具有静态生命周期（它将始终存在），或者大多数变量具有其作用域的生命周期。尽管如此，有时我们还需要指定生命周期。让我们检查以下结构体：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the parent has a reference to the child, but we added two letters
    preceded by a single quote. These are lifetime specifications, and what means
    is that the reference to the child has to live at least while the parent exists.
    Let''s see this behavior with a simple `main()` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，父结构体有一个指向孩子的引用，但我们添加了两个以单引号为前缀的字母。这些都是生命周期指定，这意味着指向孩子的引用至少要和父结构体存在的时间一样长。让我们用一个简单的`main()`函数来看看这种行为：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will print that the child is `10` years old. The child gets dropped at
    the end of the `main` function, so the reference is valid while the parent exists.
    But let's create a small inner scope to see if we can trick the compiler. Inner
    scopes are explicit scopes that you can create by using curly braces. All variables
    defined in there will be dropped at the end of the inner scope, and if an expression
    is added at the end without a semicolon, it will be the value of the scope, and
    can be assigned to any variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出孩子是`10`岁。孩子会在`main`函数的末尾被丢弃，所以引用在`parent`存在时是有效的。但让我们创建一个小的内部作用域来看看我们是否能欺骗编译器。内部作用域是显式的作用域，你可以通过使用花括号来创建。所有在内部定义的变量将在内部作用域的末尾被丢弃，如果在末尾添加了一个没有分号的表达式，那么这个表达式的值将是作用域的值，并且可以赋给任何变量。
- en: 'Let''s try to add a `child` to a `parent` that will be dropped at an inner
    scope:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试向一个将在内部作用域中被丢弃的`parent`添加一个`child`：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we try to compile this, the compiler will tell us that `child` does not live
    long enough. The compiler has understood that we told it in the structure that
    `child` had to live at least as long as the `Parent` structure, and since, in
    this case, it knows that the variable defined inside the inner scope will be dropped
    there, it will complain at compile time and not let you add it to the `parent`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译这段代码，编译器会告诉我们`child`的生命周期不够长。编译器已经理解了我们在结构体中告诉它的，即`child`的生命周期至少要和`Parent`结构体一样长，并且由于在这种情况下，它知道内部作用域中定义的变量将在那里被丢弃，因此它会在编译时提出警告，并阻止你将其添加到`parent`中。
- en: 'This can be extended to functions. Let''s consider a very simple function that
    returns a reference to the oldest child of the two provided:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以扩展到函数。让我们考虑一个非常简单的函数，该函数返回两个提供的子项中最年长的子项的引用：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will not compile, since it needs a lifetime parameter. This means that
    the compiler does not know whether the return child will live as long as `child1`
    or as long as `child2`. We don''t know either, so we will specify that all lifetimes
    must be at least as long as the current function, and then the rest is the problem
    of our caller:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译，因为它需要一个生命周期参数。这意味着编译器不知道返回的子项是否会像`child1`一样长时间存活，或者像`child2`一样长时间存活。我们也不知道，所以我们将指定所有生命周期必须至少与当前函数一样长，然后其余的就是我们调用者的问题：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This just declares a new lifetime (declared before the first parenthesis before
    the arguments) that we call `f`, that will be the lifetime of the function. We
    then specify that all references must live at least as long as the function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是声明了一个新的生命周期（在参数前的第一个括号之前声明），我们称之为`f`，它将是函数的生命周期。然后我们指定所有引用必须至少与函数一样长。
- en: Memory representation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存表示
- en: 'Apart from managing the references, ownerships, allocations, and copies, we
    can also manage the memory layout of those structures we saw earlier, and we can
    do it by using both safe and unsafe code. Let''s first understand how Rust manages
    the memory. Think of the following structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理引用、所有权、分配和复制之外，我们还可以管理我们之前看到的那些结构的内存布局，我们可以通过使用安全和不可安全代码来实现这一点。让我们首先了解Rust如何管理内存。考虑以下结构：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alignment
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐
- en: When accessing the attributes from memory, they need to be aligned so that their
    position in memory is a multiple of their size, 16 bits in this case. That way,
    when we try to get each attribute, we will only need to add 16 bits to the base
    address of the structure, multiplied by the attribute. This makes information
    retrieval much more efficient, and it's done by the compiler automatically. The
    main issue with it is that for each attribute to be 16-bit aligned, the compiler
    would need to pad 8 bits for each of the first and third attributes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当从内存中访问属性时，它们需要对齐，以便它们在内存中的位置是它们大小的倍数，在这种情况下是16位。这样，当我们尝试获取每个属性时，我们只需要将16位加到结构的基址上，乘以属性。这使得信息检索更加高效，并且这是由编译器自动完成的。主要问题是，为了使每个属性对齐为16位，编译器需要为前三个属性中的每一个填充8位。
- en: 'This means that the structure gets converted to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结构将被转换为以下形式：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But, in this concrete case, both `attr1` and `attr3` have 8 bits, so they do
    not need to be 16-bit aligned; they could be 8-bit aligned and work properly.
    This means that we could move the first attribute to the end and, that way, it
    would be something like having two 16-bit aligned attributes, and the second one
    would contain two 8-bit aligned attributes:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这个具体案例中，`attr1`和`attr3`都有8位，所以它们不需要16位对齐；它们可以是8位对齐并且正常工作。这意味着我们可以将第一个属性移到末尾，这样它就会像有两个16位对齐的属性一样，第二个属性将包含两个8位对齐的属性：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This does not require extra padding and thus the structure will occupy 32 bits
    (instead of 48 as before). This is a typical optimization that has to be done
    manually in C/C++, messing up our order of attributes, but in Rust we can do better.
    The compiler knows about this, and it will reorder the fields the best it can
    to have a better memory footprint, so you can put the attributes in the order
    you'd like.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要额外的填充，因此结构将占用32位（而不是之前的48位）。这是一个典型的优化，在C/C++中必须手动完成，这会打乱我们的属性顺序，但在Rust中我们可以做得更好。编译器知道这一点，并且会尽可能重新排序字段以获得更好的内存占用，因此你可以按照你想要的顺序放置属性。
- en: But, if the compiler already does this automatically, what is this doing in
    a performance optimization book? Well, there is a situation where you want to
    avoid this behavior.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果编译器已经自动完成这个操作，那么在性能优化书中这样做有什么意义呢？嗯，有一种情况你希望避免这种行为。
- en: Let's face it, not all of the software is written in Rust yet, and in the case
    of high-performance libraries, it's common that we have to use C dependencies.
    Luckily, Rust can seamlessly integrate with any C-compatible interface at no cost.
    But you will have a problem if you move structures between the Rust and C codes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实，并不是所有的软件都是用Rust编写的，在高性能库的情况下，我们通常不得不使用C依赖项。幸运的是，Rust可以无缝地与任何C兼容的接口集成，而且不收取任何费用。但是，如果你在Rust和C代码之间移动结构，你将遇到问题。
- en: 'As we discussed, Rust will reorder the fields, which means that the structure
    in C and in Rust might not have attributes positioned the same way. We can tell
    Rust not to change the order of the fields, though, by using the `repr` attribute
    with the `C` value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，Rust会重新排序字段，这意味着C和Rust中的结构可能不会以相同的方式定位属性。不过，我们可以通过使用带有`C`值的`repr`属性来告诉Rust不要改变字段的顺序：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will make the structure compatible with C. We can also tell Rust not to
    add padding to attributes, and therefore make the structure minimal size even
    if its alignment could be better. Note that this will break the code for platforms
    that require aligned structures. If you still want to use it, you can simply use
    the `packed` form of representation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使结构与C兼容。我们还可以告诉Rust不要对属性添加填充，因此即使对齐可能更好，结构也将是最小尺寸。请注意，这将破坏需要对齐结构的平台上的代码。如果您仍然想使用它，您只需简单地使用表示的`packed`形式：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Complex enumerations
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂枚举
- en: If you know about C/C++ enumerations, you know that each element represents
    a value, and that you can use them to avoid remembering the proper integers from
    the set of possible values. They are not strongly typed, though, so you can mix
    different enumerations. And they can only store one integer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您了解C/C++枚举，您知道每个元素代表一个值，并且您可以使用它们来避免记住可能值集中的正确整数。不过，它们不是强类型的，因此您可以混合不同的枚举。并且它们只能存储一个整数。
- en: 'Once again, Rust can do better, and we can create complex enumerations where
    we cannot only have strong typing (we won''t mix enumerations) but we will even
    be able to have more than integers in enumerations. As you can see in the following `Color`
    enumeration, we can have inner data, and even attributes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Rust可以做得更好，我们可以创建复杂的枚举，其中我们不仅可以有强类型（我们不会混合枚举），我们甚至可以在枚举中拥有比整数更多的内容。正如您在下面的`Color`枚举中可以看到的，我们可以有内部数据，甚至属性：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, in this case, the enumeration can have one of four values,
    but in the case of the last one, it will have three numbers associated. This gives
    you almost infinite possibilities, where you can safely represent any data structure.
    Check out, for instance, this implementation of *any JSON value* by the `Serde`
    crate, one of the most-used crates in the ecosystem:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，枚举可以具有四种值之一，但在最后一种情况下，它将关联三个数字。这为您提供了几乎无限的可能性，您可以安全地表示任何数据结构。例如，查看`Serde`
    crate对这个*任何JSON值*的实现，它是生态系统中最常用的crate之一：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A value in a JSON structure can either be null, a Boolean (and with the information
    whether it's `true` or `false`), a number (that will be another enumeration to
    know whether it's positive, negative, or float point), a string, with the text
    information, an array of values, or a whole JSON object with its keys as strings
    and values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JSON结构中的值可以是null，布尔值（并且包含它是`true`还是`false`的信息），数字（这将是一个枚举，以了解它是正数、负数还是浮点数），字符串，包含文本信息，值的数组，或者一个整个JSON对象，其键为字符串，值为。
- en: There are two caveats with this approach, though. For comparison between the
    different variants of an enumeration, they must be tagged. This means that they
    will need to occupy some extra space just to differentiate between them at runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有两个缺点。对于枚举的不同变体的比较，它们必须被标记。这意味着它们将需要占用一些额外的空间，仅为了在运行时区分它们。
- en: The second problem is that the size of the enumeration type (without taking
    into account the tag) will be the size of the biggest option. So if you have 10
    options that can be stored in 1 byte, but another one needs 10 bytes, the enumeration
    will have 10 bytes (plus the tag) independently of the variant being stored. This
    works this way because it works as a `union` (in C/C++ language), where all variants
    share the same representation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是，枚举类型的大小（不考虑标记）将是最大选项的大小。所以如果你有10个可以存储在1字节的选项，但另一个需要10字节，枚举将有10字节（加上标记）独立于存储的变体。这是因为它作为一个`union`（在C/C++语言中）工作，其中所有变体共享相同的表示。
- en: 'To mitigate this, an option is for big objects to be references. We can do
    this in two ways. The first way is by borrowing the color, in which case the compiler
    will force us to not return the enumeration from any function where the color
    was created (remember, the reference would be destroyed at the end of the scope):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这一点，一个选择是将大对象作为引用。我们可以有两种方式来做这件事。第一种方式是通过借用颜色，在这种情况下，编译器将强制我们不在创建颜色的任何函数中返回枚举（记住，引用将在作用域结束时被销毁）：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And if we want to avoid that, we can simply store that element in the heap
    by boxing it (yes, this will slow performance). It depends whether you require
    a lower RAM consumption or an improved speed. To store an element in the heap,
    you will need to use the `Box` type, as you can see here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想避免这种情况，我们可以简单地通过装箱（是的，这将降低性能）将那个元素存储在堆上。这取决于你是否需要较低的RAM消耗或更快的速度。要存储堆上的元素，你需要使用`Box`类型，就像你在这里可以看到的那样：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合体
- en: 'There is also another type of union that is not tagged. If the types in the
    union are not `Copy`, you will need to use the `untagged_unions` feature and compile
    the code with the nightly compiler. This can be avoided by deriving the `Copy`
    trait in the structures used inside the union, but you shouldn''t do this for
    big structures, as we discussed earlier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种未标记的联合体类型。如果联合体中的类型不是`Copy`，你需要使用`untagged_unions`特性，并使用夜间编译器编译代码。这可以通过在联合体内使用的结构中派生`Copy`特性来避免，但我们不应该对大型结构这样做，就像我们之前讨论的那样：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this particular example, the `Plant` can be a `Geranium` or a `Carnation`.
    Or more precisely, it will be both at the same time. The `Plant` will have the
    size of the biggest structure in it, and it won't have any extra padding for a
    tag describing which of the two variants it is.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，`Plant`可以是`Geranium`或`Carnation`。或者更准确地说，它将同时是两者。`Plant`将具有其中最大的结构的大小，并且它不会为描述它是哪个变体的标签添加任何额外的填充。
- en: 'This means that when writing one of the fields of the union, you will change
    the rest of the fields too. When creating the union, you will need to specify
    only one field, and since the compiler won''t know which variant it is at compile
    time, you will need to read the values using an unsafe block, as you can see in
    the next piece of code, since reading an unset value ends up being undefined behavior:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你在联合体中写入一个字段时，你也会改变其他字段。在创建联合体时，你只需要指定一个字段，由于编译器在编译时不知道它是哪个变体，因此你需要使用一个不安全块来读取值，就像你可以在下一段代码中看到的那样，因为读取未设置值最终会导致未定义行为：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we first create a `Plant` that is a `Carnation`, and then we
    convert it to a `Geranium`. That change does not need an unsafe block, since the
    `Plant` will always have 32 bits, the size of the `Geranium`, so it can be assigned
    with perfect memory safety.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个`Plant`，它是一个`Carnation`，然后我们将其转换为`Geranium`。这种变化不需要不安全块，因为`Plant`将始终具有32位，即`Geranium`的大小，因此它可以安全地分配。
- en: When we retrieve the height, though, we need to specify that we want to read
    the `Plant` as a `Geranium`, and then get the height. In this case, it works perfectly,
    since we changed the `Plant` to be a `Geranium`. If we tried to get the plant
    as a `Carnation` in this example, it would trigger undefined behavior. This means
    that the number of flowers can be a random number depending on the layout of the
    union. Still, this is not a security vulnerability, since the `u8` we will get
    for the number of flowers will be one of the bytes of the `Geranium` height, it
    will just feel random (in my case, it says 44 flowers).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索高度时，尽管如此，我们需要指定我们想要将`Plant`作为`Geranium`来读取，然后获取高度。在这种情况下，它工作得非常好，因为我们已经将`Plant`更改为`Geranium`。如果我们在这个例子中尝试将植物作为`Carnation`获取，它将触发未定义行为。这意味着花朵的数量可能是一个随机数，取决于联合体的布局。尽管如此，这并不是一个安全漏洞，因为我们获取的花朵数量的`u8`将是`Geranium`高度的字节之一，它只是感觉随机（在我的情况下，它显示有44朵花）。
- en: But in any case, this is particularly great for interfacing with C (FFI). If
    we use the `#[repr(C)]` attribute in the union, it will be structured exactly
    the same way as in C, so we will be able to send the union to a C library without
    needing to think about how to emulate a C union.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但在任何情况下，这对于与C（FFI）接口特别有用。如果我们使用`#[repr(C)]`属性在联合体中，它将结构与C中的结构完全相同，因此我们可以将联合体发送到C库，而无需考虑如何模拟C联合体。
- en: Shared pointers
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享指针
- en: One of Rust's most criticized problems is that it's difficult to develop an
    application with shared pointers. As we have seen before, it's true that due to
    Rust's memory safety guarantees, it might be difficult to develop those kinds
    of algorithms, but as we will see now, the standard library gives us some types
    we can use to safely allow that behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最被批评的问题之一是难以开发具有共享指针的应用程序。正如我们之前看到的，由于Rust的内存安全保证，开发这类算法可能确实比较困难，但正如我们现在将看到的，标准库为我们提供了一些我们可以用来安全地允许这种行为的类型。
- en: The cell module
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元模块
- en: The standard library has one interesting module, the `std::cell` module, that
    allows us to use objects with interior mutability. This means that we can have
    an immutable object and still mutate it by getting a mutable borrow to the underlying
    data. This, of course, would not comply with the mutability rules we saw before,
    but the cells make sure this works by checking the borrows at runtime or by doing
    copies of the underlying data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有一个有趣的模块，即 `std::cell` 模块，它允许我们使用具有内部可变性的对象。这意味着我们可以有一个不可变对象，并且仍然可以通过获取对底层数据的可变借用来修改它。当然，这不会符合我们之前看到的可变性规则，但
    `Cell` 通过在运行时检查借用或对底层数据进行复制来确保这一点。
- en: Cells
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cells
- en: 'Let''s start with the basic `Cell` structure. A `Cell` will contain a mutable
    value, but it can be mutated without having a mutable `Cell`. It has mainly three
    interesting methods: `set()`, `swap()`, and `replace()`. The first allows us to
    set the contained value, replacing it with a new value. The previous structure
    will be dropped (the destructor will run). That last bit is the only difference
    with the `replace()` method. In the `replace()` method, instead of dropping the
    previous value, it will be returned. The `swap()` method, on the other hand, will
    take another `Cell` and swap the values between the two. All this without the
    `Cell` needing to be mutable. Let''s see it with an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的 `Cell` 结构开始。一个 `Cell` 将包含一个可变值，但它可以在没有可变 `Cell` 的情况下被修改。它主要有三个有趣的方法：`set()`、`swap()`
    和 `replace()`。第一个允许我们设置包含的值，用新值替换它。之前的结构将被丢弃（析构函数将运行）。这一点与 `replace()` 方法不同。在
    `replace()` 方法中，而不是丢弃之前的值，它将返回该值。另一方面，`swap()` 方法将取另一个 `Cell` 并在两个之间交换值。所有这些都不需要
    `Cell` 是可变的。让我们用一个例子来看看：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see in the example, to use a `Cell`, the contained type must be
    `Copy`. If the contained type is not `Copy`, you will need to use a `RefCell`,
    which we will see next. Continuing with this `Cell` example, as you can see through
    the code, the output will be the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如同示例中所示，要使用 `Cell`，包含的类型必须是 `Copy`。如果包含的类型不是 `Copy`，你需要使用 `RefCell`，我们将在下一节中看到。继续这个
    `Cell` 示例，正如代码所示，输出将是以下内容：
- en: '![](img/a6ec229b-d16d-47f1-8d9a-9ae73cdc5b26.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6ec229b-d16d-47f1-8d9a-9ae73cdc5b26.png)'
- en: So we first create two houses, we select one of them as the current one, and
    we keep mutating the current and the new ones. As you might have seen, I also
    used the `take()` method, only available for types implementing the `Default`
    trait. This method will return the current value, replacing it with the default
    value. As you can see, you don't really mutate the value inside, but you replace
    it with another value. You can either retrieve the old value or lose it. Also,
    when using the `get()` method, you get a copy of the current value, and not a
    reference to it. That's why you can only use elements implementing `Copy` with
    a `Cell`. This also means that a `Cell` does not need to dynamically check borrows
    at runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先创建两个房子，我们选择其中一个作为当前的房子，并保持对当前的和新的房子进行修改。正如你可能看到的，我也使用了 `take()` 方法，它仅适用于实现了
    `Default` 特质的类型。此方法将返回当前值，并用默认值替换它。正如你所见，你实际上并没有修改内部的值，而是用另一个值替换它。你可以检索旧值或者失去它。另外，当使用
    `get()` 方法时，你得到当前值的副本，而不是它的引用。这就是为什么你只能使用与 `Cell` 一起实现的 `Copy` 元素。这也意味着 `Cell`
    不需要在运行时动态检查借用。
- en: RefCell
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RefCell
- en: '`RefCell` is similar to `Cell`, except that it accepts non-`Copy` data. This
    also means that when modifying the underlying object, it cannot simply copy it
    when returning it, it will need to return references. The same way, when you want
    to mutate the object inside, it will return a mutable reference. This only works
    because it will dynamically check at runtime whether a borrow exists before returning
    a mutable borrow, or the other way around, and if it does, the thread will panic.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`RefCell` 与 `Cell` 类似，但它接受非 `Copy` 数据。这也意味着在修改底层对象时，在返回它时不能简单地复制它，它需要返回引用。同样，当你想要修改内部的对象时，它将返回一个可变引用。这仅因为它在返回可变借用之前会动态检查运行时是否存在借用，或者反过来，如果存在，线程将崩溃。'
- en: 'Instead of using the `get()` method as in `Cell`, `RefCell` has two methods
    to get the underlying data: `borrow()` and `borrow_mut()`. The first will get
    a read-only borrow, and you can have as many immutable borrows in a scope. The
    second one will return a read-write borrow, and you will only be able to have
    one in scope to follow the mutability rules. If you try to do a `borrow_mut()`
    after a `borrow()` in the same scope, or a `borrow()` after a `borrow_mut()`,
    the thread will panic.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Cell` 中的 `get()` 方法不同，`RefCell` 有两个方法来获取底层数据：`borrow()` 和 `borrow_mut()`。第一个将获取只读借用，你可以在作用域内拥有任意多个不可变借用。第二个将返回读写借用，你将只能在作用域内有一个，以遵循可变性规则。如果在同一作用域中先执行了
    `borrow()`，然后尝试执行 `borrow_mut()`，或者先执行了 `borrow_mut()`，然后尝试执行 `borrow()`，线程将发生恐慌。
- en: 'There are two non-panicking alternatives to these borrows: `try_borrow()` and
    `try_borrow_mut()`. These two will try to borrow the data (the first read-only
    and the second read/write), and if there are incompatible borrows present, they
    will return a `Result::Err`, so that you can handle the error without panicking.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些借用，有两种非恐慌的替代方案：`try_borrow()` 和 `try_borrow_mut()`。这两个函数将尝试借用数据（第一个为只读，第二个为读写），如果存在不兼容的借用，它们将返回一个
    `Result::Err`，这样你就可以在不恐慌的情况下处理错误。
- en: Both `Cell` and `RefCell` have a `get_mut()` method, that will get a mutable
    reference to the element inside, but it requires the `Cell` / `RefCell` to be
    mutable, so it doesn't make much sense if you need the `Cell` / `RefCell` to be
    immutable. Nevertheless, if in a part of the code you can actually have a mutable
    `Cell` / `RefCell`, you should use this method to change the contents, since it
    will check all rules statically at compile time, without runtime overhead.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell` 和 `RefCell` 都有一个 `get_mut()` 方法，它将获取内部元素的可变引用，但它要求 `Cell` / `RefCell`
    是可变的，所以如果你需要 `Cell` / `RefCell` 是不可变的，这就没有太多意义。尽管如此，如果在代码的一部分中你实际上可以有一个可变的 `Cell`
    / `RefCell`，你应该使用这个方法来更改内容，因为它将在编译时静态地检查所有规则，而不产生运行时开销。'
- en: Interestingly enough, `RefCell` does not return a plain reference to the underlying
    data when we call `borrow()` or `borrow_mut()`. You would expect them to return
    `&T` and `&mut T` (where `T` is the wrapped element). Instead, they will return
    a `Ref` and a `RefMut`, respectively. This is to safely wrap the reference inside,
    so that the lifetimes get correctly calculated by the compiler without requiring
    references to live for the whole lifetime of the `RefCell`. They implement `Deref`
    into references, though, so thanks to Rust's `Deref` coercion, you can use them
    as references.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，当我们调用 `borrow()` 或 `borrow_mut()` 时，`RefCell` 并不返回对底层数据的普通引用。你可能会期望它们返回
    `&T` 和 `&mut T`（其中 `T` 是包装的元素）。相反，它们将分别返回一个 `Ref` 和一个 `RefMut`。这是为了安全地包装引用内部，以便编译器能够正确地计算生命周期，而不需要引用在整个
    `RefCell` 生命周期内都存在。尽管如此，它们实现了 `Deref` 到引用，因此得益于 Rust 的 `Deref` 强制转换，你可以将它们用作引用。
- en: The rc module
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`rc` 模块'
- en: 'The `std::rc` module contains reference-counted pointers that can be used in
    single-threaded applications. They have very little overhead, thanks to counters
    not being atomic counters, but this means that using them in multithreaded applications
    could cause data races. Thus, Rust will stop you from sending them between threads
    at compile time. There are two structures in this module: `Rc` and `Weak`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::rc` 模块包含可以在单线程应用程序中使用的引用计数指针。由于计数器不是原子计数器，因此它们的开销非常小，但这意味着在多线程应用程序中使用它们可能会导致数据竞争。因此，Rust
    将在编译时阻止你在线程之间发送它们。在这个模块中有两个结构：`Rc` 和 `Weak`。'
- en: An `Rc` is an owning pointer to the heap. This means that it's the same as a
    `Box`, except that it allows for reference-counted pointers. When the `Rc` goes
    out of scope, it will decrease by `1` the number of references, and if that count
    is `0`, it will drop the contained object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc` 是对堆的拥有指针。这意味着它与 `Box` 相同，只不过它允许使用引用计数指针。当 `Rc` 超出作用域时，它将引用计数减 `1`，如果这个计数是
    `0`，它将丢弃包含的对象。'
- en: Since an `Rc` is a shared reference, it cannot be mutated, but a common pattern
    is to use a `Cell` or a `RefCell` inside the `Rc` to allow for interior mutability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Rc` 是一个共享引用，它不能被修改，但一个常见的模式是在 `Rc` 内部使用 `Cell` 或 `RefCell` 来允许内部可变性。
- en: '`Rc` can be downgraded to a `Weak` pointer, that will have a borrowed reference
    to the heap. When an `Rc` drops the value inside, it will not check whether there
    are `Weak` pointers to it. This means that a `Weak` pointer will not always have
    a valid reference, and therefore, for safety reasons, the only way to check the
    value of the `Weak` pointer is to upgrade it to an `Rc`, which could fail. The
    `upgrade()` method will return `None` if the reference has been dropped.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rc`可以被降级为`Weak`指针，这将有一个指向堆的借用引用。当`Rc`释放其内部的值时，它不会检查是否有指向它的`Weak`指针。这意味着`Weak`指针不一定总是有一个有效的引用，因此出于安全考虑，检查`Weak`指针值的唯一方法是将它升级为`Rc`，这可能会失败。如果引用已经被释放，`upgrade()`方法将返回`None`。'
- en: 'Let''s check all this by creating an example binary tree structure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个示例二叉树结构来检查所有这些：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, the tree will have a root node, and each of the nodes can have
    up to two children. We call them left and right, because they are usually represented
    as trees with one child on each side. Each node has a pointer to one of the children,
    and it owns the children nodes. This means that when a node loses all references,
    it will be dropped, and with it, its children.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，树将有一个根节点，每个节点可以有最多两个子节点。我们称它们为左节点和右节点，因为它们通常被表示为每边有一个子节点的树。每个节点都有一个指向其子节点之一的指针，并且它拥有子节点。这意味着当一个节点失去所有引用时，它将被释放，连同它的子节点一起。
- en: Each child has a pointer to its parent. The main issue with this is that, if
    the child has an `Rc` pointer to its parent, it will never drop. This is a circular
    dependency, and to avoid it, the pointer to the parent will be a `Weak` pointer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个孩子都有一个指向其父节点的指针。这个问题的主要在于，如果孩子节点有一个指向其父节点的`Rc`指针，那么它将永远不会释放。这是一个循环依赖，为了避免这种情况，父节点的指针将是一个`Weak`指针。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how the borrow checker works. You now understand
    the rules that your code must follow to compile, and how little tricks can make
    your code much faster without having to worry about making the compiler happy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了借用检查器的工作原理。你现在理解了你的代码必须遵循的规则以进行编译，以及一些小技巧可以使你的代码运行得更快，而无需担心让编译器满意。
- en: You also learned about the memory representation of structures and enumerations
    in Rust and how to make your Rust code compatible with the C/C++.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了在Rust中结构体和枚举的内存表示，以及如何使你的Rust代码与C/C++兼容。
- en: Finally, you understood how Rust manages shared pointers for complex structures
    where the Rust borrow checker can make your coding experience much more difficult.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了Rust如何管理复杂结构的共享指针，其中Rust的借用检查器可以使你的编码体验变得更加困难。
- en: In [Chapter 4](0a00a575-c592-4022-8721-79c2f2d63f76.xhtml), *Lints and Clippy*,
    we will learn about linting and a surprisingly good linting tool called **Clippy**.
    With these lints, you will be able to find many of the issues we saw at compile
    time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](0a00a575-c592-4022-8721-79c2f2d63f76.xhtml)，*代码检查和Clippy*中，我们将学习关于代码检查以及一个出人意料的优秀的代码检查工具**Clippy**。使用这些代码检查，你将能够找到我们在编译时看到的大多数问题。
