- en: '*Chapter 10*: Uploading and Processing Posts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：上传和处理帖子'
- en: In this chapter, we are going to learn how to upload user posts. We will start
    with the basics of multipart uploads and continue with `TempFile` to store the
    uploaded files. After uploading the files, we will implement image processing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何上传用户帖子。我们将从多部分上传的基本知识开始，然后继续使用`TempFile`来存储上传的文件。上传文件后，我们将实现图像处理。
- en: The next thing we are going to learn about is improving processing using concurrent
    programming techniques, asynchronous programming, and multithreading.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何通过并发编程技术、异步编程和多线程来改进处理。
- en: 'In this chapter, we are going to cover these main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Uploading a text post
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传文本帖子
- en: Uploading a photo post
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传照片帖子
- en: Processing files asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理文件
- en: Uploading a video post and process using worker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作进程上传视频帖子并处理
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we have the usual requirements: a Rust compiler, a text editor,
    a web browser, and a PostgreSQL database server. Aside from those requirements,
    we are going to process uploaded video files. Download the **FFmpeg** command
    line from [https://www.ffmpeg.org/download.html](https://www.ffmpeg.org/download.html).
    FFmpeg is a multimedia framework to process media files. Make sure you can run
    FFmpeg on the terminal of your operating system.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们有通常的要求：Rust编译器、文本编辑器、网络浏览器和PostgreSQL数据库服务器。除了这些要求之外，我们还将处理上传的视频文件。从[https://www.ffmpeg.org/download.html](https://www.ffmpeg.org/download.html)下载**FFmpeg**命令行。FFmpeg是一个用于处理媒体文件的媒体框架。确保您可以在操作系统的终端上运行FFmpeg。
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此章节的源代码[https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10)中找到。
- en: Uploading a text post
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传文本帖子
- en: The first thing we want to upload is a text post because it's the simplest type.
    When we submit the form in HTML, we can specify the `form` tag `enctype` attribute
    as `text/plain`, `application/x-www-form-urlencoded`, or `multipart/form-data`.
    We already learned how to process `application/x-www-form-urlencoded` in the Rocket
    application when we learned how to create a user. We create a struct and derive
    `FromForm` for that struct. Later, in the route handling function, we set a route
    attribute, such as `get` or `post`, and assign the struct in the `data` annotation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要上传的是文本帖子，因为它是最简单的类型。当我们提交HTML表单时，我们可以指定`form`标签的`enctype`属性为`text/plain`、`application/x-www-form-urlencoded`或`multipart/form-data`。我们已经学习了如何在创建用户时处理`application/x-www-form-urlencoded`的Rocket应用程序。我们为该结构体创建一个结构体并为其推导`FromForm`。稍后，在路由处理函数中，我们设置一个路由属性，如`get`或`post`，并将结构体分配到`data`注释中。
- en: 'The request body for `Content-Type="application/x-www-form-urlencoded"` is
    simple: the form keys and values are encoded in key-value tuples separated by
    `&`, with an equals sign (`=`) between the key and the value. If the characters
    sent are not alphanumeric, they''re percent-encoded (`%`). An example of a form
    request body is shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Content-Type="application/x-www-form-urlencoded"`的请求体是简单的：表单键和值通过`&`分隔成键值对，键和值之间用等号(`=`)连接。如果发送的字符不是字母数字，则进行百分号编码(`%`)。以下是一个表单请求体的示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For uploading a file, `Content-Type` is `multipart/form-data`, and the body
    is different. Suppose we have the following HTTP header:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上传文件，`Content-Type`是`multipart/form-data`，其正文不同。假设我们有以下HTTP头：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The HTTP body can be as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP正文可以是以下内容：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Rocket, we can process `multipart/form-data` by using the `multer` crate.
    Let''s try to implement uploading using that crate by following these instructions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rocket中，我们可以通过使用`multer` crate来处理`multipart/form-data`。让我们按照以下说明尝试使用该crate实现上传：
- en: 'Modify our application by adding these crates into the `Cargo.toml` dependencies:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将这些crate添加到`Cargo.toml`依赖项中修改我们的应用程序：
- en: '[PRE12]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add these configurations in `Rocket.toml` to handle the file upload limit and
    add a temporary directory to store the uploaded files:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Rocket.toml`中添加以下配置以处理文件上传限制并添加一个临时目录来存储上传的文件：
- en: '[PRE13]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Modify `src/views/posts/index.html.tera` to add a form where the user can upload
    a file. Add the following lines after the pagination block:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`src/views/posts/index.html.tera`以添加一个用户可以上传文件的表单。在分页块之后添加以下行：
- en: '[PRE14]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the `create()` method for `Post` in the `src/models/post.rs` file. We want
    a method to save the `Post` data into the database. Add the following lines inside
    the `impl Post {}` block:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/post.rs`文件中为`Post`添加`create()`方法。我们希望有一个方法将`Post`数据保存到数据库中。在`impl
    Post {}`块内添加以下行：
- en: '[PRE15]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can remove `FromForm` as we will not use the placeholder anymore. Remove
    these lines from `src/models/post.rs`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以移除`FromForm`，因为我们不再使用占位符了。从`src/models/post.rs`中移除以下行：
- en: '[PRE16]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need the value from the request''s `Content-Type` to get a multipart boundary,
    but Rocket doesn''t have a request guard that can do that. Let''s create a type
    that can handle a raw HTTP `Content-Type` header. In `src/lib.rs`, add the following
    line:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从请求的`Content-Type`中获取多部分边界，但Rocket没有可以执行此操作的请求保护器。让我们创建一个可以处理原始HTTP `Content-Type`头部的类型。在`src/lib.rs`中添加以下行：
- en: '[PRE17]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `src` folder, create another folder, named `guards`, and then create
    a `src/guards/mod.rs` file. Inside the file, add the struct to handle the raw
    HTTP request body:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建另一个名为`guards`的文件夹，然后创建一个`src/guards/mod.rs`文件。在文件中，添加一个处理原始HTTP请求体的结构体：
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement `FromRequest` for `RawContent` to create a request guard:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`FromRequest`为`RawContent`以创建请求保护器：
- en: '[PRE19]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Rocket will consider the `"/users/delete/<uuid>"` route as conflicting with
    the `"/users/<user_uuid>/posts"` route. To avoid that problem, we can add `rank`
    to the route macro. In `src/routes/user.rs`, edit the route macro above the `delete_user_entry_point()`
    function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rocket会将`"/users/delete/<uuid>"`路由视为与`"/users/<user_uuid>/posts"`路由冲突。为了避免这个问题，我们可以在路由宏中添加`rank`。在`src/routes/user.rs`中，编辑`delete_user_entry_point()`函数上面的路由宏：
- en: '[PRE20]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In `src/routes/post.rs`, add the required `use` declaration to implement the
    handling of the HTTP multipart request:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/routes/post.rs`中添加所需的`use`声明以实现HTTP多部分请求的处理：
- en: '[PRE21]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a constant to limit the size of the uploaded file:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个常量以限制上传文件的大小：
- en: '[PRE22]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s modify the `get_posts()` function as well to add a `flash` message if
    the upload fails or is successful:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`get_posts()`函数，以便在上传失败或成功时添加一个`flash`消息：
- en: '[PRE23]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now it''s time to implement the `create_post()` function. The first thing we
    need to do is modify the `post` route macro and function signature:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现`create_post()`函数了。我们首先需要做的是修改`post`路由宏和函数签名：
- en: '[PRE24]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `create_post()` function, add a closure that returns an error. We
    add a closure to avoid repetition. Add the following lines:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create_post()`函数内部，添加一个返回错误的闭包。我们添加闭包以避免重复。添加以下行：
- en: '[PRE25]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Under the `create_err` definition, continue by getting the boundary from the
    `content_type` request guard:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create_err`定义下，继续从`content_type`请求保护器中获取边界：
- en: '[PRE26]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For `TextPost`, we just store the content of the text file in the post''s `content`
    field. Let''s open the request body, process it as a multipart, and define a new
    variable to store the content of the body. Append the following lines:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`TextPost`，我们只需将文本文件的内容存储在帖子的`content`字段中。让我们打开请求体，将其作为多部分处理，并定义一个新变量来存储正文内容。添加以下行：
- en: '[PRE27]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next thing we need to do is to iterate the multipart fields. We can iterate
    multipart fields as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是迭代多部分字段。我们可以这样迭代多部分字段：
- en: '[PRE28]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we only have one field in the form, we can just get the content of the first
    field and put the value in the `text_post` variable. Append the following lines:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们表单中只有一个字段，我们只需获取第一个字段的内容并将其值放入`text_post`变量中。添加以下行：
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, after we get the request body content and assign it to `text_post`,
    it''s time to store it in the database and return to the `posts` list page. Append
    the following lines:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们获取请求体内容并将其分配给`text_post`之后，是时候将其存储到数据库中并返回到`posts`列表页面。添加以下行：
- en: '[PRE30]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, try restarting the application and uploading the text file. You should
    see the content of the text file on the `posts` list page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试重新启动应用程序并上传文本文件。你应该能在`posts`列表页面上看到文本文件的内容：
- en: '![Figure 10.1 – Uploaded text posts'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 上传的文本帖子'
- en: '](img/Figure_10.1_B16825.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.1_B16825.jpg](img/Figure_10.1_B16825.jpg)'
- en: Figure 10.1 – Uploaded text posts
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 上传的文本帖子
- en: Now that we have implemented uploading and processing text files, it is time
    to move on to uploading and processing photo files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了上传和处理文本文件，是时候继续上传和处理图片文件了。
- en: Uploading a photo post
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图片帖子
- en: Before Rocket *0.5*, uploading multipart files had to be implemented manually,
    as in the previous section. Starting from Rocket *0.5*, there's a `rocket::fs::TempFile`
    type that can be used directly to handle uploaded files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rocket *0.5*之前，上传多部分文件必须手动实现，如前节所述。从Rocket *0.5*开始，有一个`rocket::fs::TempFile`类型可以直接用来处理上传文件。
- en: To handle processing image files, we can use an `image` crate. The crate can
    handle opening and saving various image file formats. The `image` crate also provides
    ways to manipulate the image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理图像文件，我们可以使用`image` crate。该crate可以处理打开和保存各种图像文件格式。`image` crate还提供了操作图像的方法。
- en: Websites process uploaded media files such as images for various reasons, including
    reducing disk usage. Some websites reduce the image quality and encode the uploaded
    images into file format with a default smaller size. In this example, we are going
    to convert all uploaded images into JPEG files with 75% quality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 网站出于各种原因处理上传的媒体文件，如图像，包括减少磁盘使用。一些网站会降低图像质量，并将上传的图像编码成默认更小的文件格式。在这个例子中，我们将所有上传的图像转换为75%质量的JPEG文件。
- en: 'Let''s implement uploading image files using the `image` crate and the `TempFile`
    struct by following these steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤使用`image` crate和`TempFile`结构体实现上传图像文件：
- en: 'Remove `multer` and `tokio-util` from `Cargo.toml`. Then, add the `image` crate
    to `Cargo.toml`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Cargo.toml`中移除`multer`和`tokio-util`，然后添加`image` crate到`Cargo.toml`：
- en: '[PRE31]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remove `pub mod guards;` from `src/lib.rs` and then remove the `src/guards`
    folder.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`src/lib.rs`中移除`pub mod guards;`，然后移除`src/guards`文件夹。
- en: 'Add a struct to handle uploaded files in `src/models/post.rs`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/models/post.rs`中添加一个结构体来处理上传文件：
- en: '[PRE32]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Modify `src/views/posts/index.html.tera` to include images as accepted files:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`src/views/posts/index.html.tera`以包括作为接受文件的图像：
- en: '[PRE33]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remove unused `use` declarations, `TEXT_LIMIT` constant, and part of the `create_post()`
    function from the boundary variable declaration to the multipart iteration block:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从边界变量声明到多部分迭代块中移除未使用的`use`声明、`TEXT_LIMIT`常量和`create_post()`函数的一部分：
- en: '[PRE34]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the required `use` declarations:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的`use`声明：
- en: '[PRE35]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can use the `NewPost` struct that we created earlier as a regular `FromForm`
    deriving struct. Modify the `create_post()` function signature:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们之前创建的`NewPost`结构体作为常规的`FromForm`派生结构体。修改`create_post()`函数签名：
- en: '[PRE36]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Under the `create_err` closure declaration, generate a random `uuid` name for
    the new name of the uploaded file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`create_err`闭包声明下，为上传文件的新名称生成一个随机的`uuid`名称：
- en: '[PRE37]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Check `Content-Type` of the uploaded file, and if the Temp File cannot determine
    it, return an error:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查上传文件的`Content-Type`，如果Temp文件无法确定它，则返回一个错误：
- en: '[PRE38]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Find the extension of the uploaded file and create a new filename:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到上传文件的扩展名并创建一个新的文件名：
- en: '[PRE39]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Persist the uploaded file in the temporary location:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在临时位置持久化上传的文件：
- en: '[PRE40]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define `content` and `post_type` to be saved later:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`content`和`post_type`以供以后保存：
- en: '[PRE41]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Check the media type of the file. We can separate media types into bitmaps
    and `svg` files. For now, we are going to process text and images only. We will
    process videos in the next section. Append the following lines:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件的媒体类型。我们可以将媒体类型分为位图和`svg`文件。目前，我们将只处理文本和图像。视频将在下一节中处理。添加以下行：
- en: '[PRE42]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We want to process the text first. Create a vector of byte (`u8`), open and
    read the file into the vector, and push the vector into the content String we
    defined previously. Add these lines inside the `mt.is_text()` block:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先处理文本。创建一个字节向量（`u8`），打开并读取文件到向量中，然后将向量推入我们之前定义的内容字符串中。在`mt.is_text()`块内添加这些行：
- en: '[PRE43]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we want to process the `svg` file. For this one, we cannot convert it
    into a JPEG file; we just want to copy the file into a `static` folder and create
    an image path of `/assets/random_uuid_filename.svg`. Append the following lines
    inside the `mt.is_svg()` block:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要处理`svg`文件。对于这个文件，我们不能将其转换为JPEG文件；我们只想将文件复制到`static`文件夹中，并创建一个图像路径`/assets/random_uuid_filename.svg`。在`mt.is_svg()`块内添加以下行：
- en: '[PRE44]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For bitmap files, we want to convert them into JPEG files. First, we want to
    define the destination filename. Append the following lines inside the `mt.is_bmp()
    || mt.is_jpeg() || mt.is_png() || mt.is_gif()` block:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于位图文件，我们希望将它们转换为JPEG文件。首先，我们想要定义目标文件名。在`mt.is_bmp() || mt.is_jpeg() || mt.is_png()
    || mt.is_gif()`块内添加以下行：
- en: '[PRE45]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Continuing the bitmap processing, open the file into a buffer and decode the
    buffer into a binary format that the `image` crate understands:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续处理位图，将文件打开到缓冲区中，并将缓冲区解码为`image` crate理解的二进制格式：
- en: '[PRE46]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a path for the destination file where we want the JPEG result to be,
    and create a file at that path. Append the following lines:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标文件想要生成的JPEG结果的位置创建一个路径，并在该路径下创建一个文件。追加以下行：
- en: '[PRE47]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We then create a JPEG decoder, specify the JPEG quality and the image attributes,
    and write the binary format into the destination file. Append the following lines:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后创建一个JPEG解码器，指定JPEG质量和图像属性，并将二进制格式写入目标文件。追加以下行：
- en: '[PRE48]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we can save the post as in the previous section. Change the `Post::create()`
    method as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以像上一节那样保存帖子。将`Post::create()`方法更改为以下内容：
- en: '[PRE49]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have now finished creating the routine to upload and process text and image
    files using `TempFile` and the `image` crate. Unfortunately, this process uses
    a more traditional programming paradigm that can be improved. Let's learn how
    to process the files asynchronously in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了使用`TempFile`和`image`crate上传和处理文本和图像文件的例程的创建。不幸的是，这个过程使用了一种更传统的编程范式，可以改进。让我们在下一节学习如何异步处理文件。
- en: Processing files asynchronously
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理文件
- en: At the beginning of computer development, the available resources were usually
    limited in some way. For example, an older generation CPU can only execute one
    thing at a time. This makes computing difficult because computer resources must
    wait for the execution of tasks sequentially. For example, while the CPU is calculating
    a number, the user cannot input anything using the keyboard.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机发展的早期，可用的资源通常在某种程度上有限。例如，老一代CPU一次只能执行一个任务。这使得计算变得困难，因为计算机资源必须按顺序等待任务的执行。例如，当CPU正在计算一个数字时，用户无法使用键盘输入任何内容。
- en: Then, people invented operating systems with a **scheduler**, which assigns
    resources to run tasks. The invention of the scheduler led to the idea of a **thread**.
    A thread, or operating system thread, is the smallest sequence of program instructions
    that can be executed independently by the scheduler.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，人们发明了具有**调度器**的操作系统，它将资源分配给运行任务。调度器的发明导致了**线程**的概念。线程，或操作系统线程，是可以由调度器独立执行的程序指令的最小序列。
- en: Some modern programming languages can generate applications that spawn multiple
    threads at the same time, and so are called **multithreaded** applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一些现代编程语言可以生成同时生成多个线程的应用程序，因此被称为**多线程**应用程序。
- en: Creating multithreaded applications can be a drawback, as creating a thread
    allocates various resources, such as a memory stack. In certain applications,
    such as desktop applications, it's suitable to create multiple threads. But, creating
    multiple threads can be a problem in other applications, such as web applications,
    where requests and responses come and go quickly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多线程应用程序可能是一个缺点，因为创建一个线程会分配各种资源，例如内存栈。在某些应用程序中，例如桌面应用程序，创建多个线程是合适的。但是，在创建多个线程可能成为问题的其他应用程序中，例如快速请求和响应的Web应用程序，可能会出现问题。
- en: There are techniques to overcome this problem in multiple ways. Some languages
    opt to have **green threads**, or **virtual threads**, where the language runtime
    manages a single operating system thread and makes the program behave as if it's
    multithreaded. Some other languages, such as Javascript and Rust, opt to have
    **async/await**, a syntactic feature that allows execution parts to be suspended
    and resumed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种技术可以以多种方式克服这个问题。一些语言选择使用**绿色线程**，或**虚拟线程**，其中语言运行时管理单个操作系统线程，并使程序表现得像多线程一样。其他一些语言，如JavaScript和Rust，选择使用**async/await**，这是一种语法特性，允许执行部分被挂起和恢复。
- en: In the previous section, we used the Rust standard library to open and write
    files for image processing. The library itself is called blocking because, it
    waits until all the files have been loaded or written. That is not efficient because
    I/O operations are slower than CPU operations, and the thread can be used to do
    other operations. We can improve the program by using asynchronous programming.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了Rust标准库来打开和写入文件进行图像处理。该库本身被称为阻塞，因为它等待所有文件都已加载或写入。这并不高效，因为I/O操作比CPU操作慢，而线程可以用来执行其他操作。我们可以通过使用异步编程来改进程序。
- en: 'In Rust, we can declare an `async` function as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，我们可以如下声明一个`async`函数：
- en: '[PRE50]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Any `async` function returns the `std::future::Future` trait. By default, running
    the function does not do anything. We can use `async_task1` and an executor, such
    as the `futures` crate, to run the `async` function. The following code will behave
    like regular programming:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`async`函数都返回`std::future::Future`特质。默认情况下，运行函数不会做任何事情。我们可以使用`async_task1`和一个执行器，例如`futures`包，来运行`async`函数。以下代码将表现得像常规编程：
- en: '[PRE52]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can use `.await` after the function usage to not block the thread, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数使用后使用`.await`来不阻塞线程，如下所示：
- en: '[PRE58]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Or, we can wait for both functions to finish, as in the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以等待两个函数都完成，如下所示：
- en: '[PRE65]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `futures` crate is very basic; we can use other runtimes that provide an
    executor and a scheduler and many other functionalities. There are a couple of
    competing runtimes in the Rust ecosystem, such as `tokio`, `smol`, and `async-std`.
    We can use those different runtimes together but it's not very efficient, so it's
    advised to stick with a single runtime. Rocket itself uses `tokio` as the runtime
    for `async`/`await`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`futures`包非常基础；我们可以使用提供执行器、调度器和其他许多功能的其他运行时。在Rust生态系统中，有几个竞争的运行时，例如`tokio`、`smol`和`async-std`。我们可以一起使用这些不同的运行时，但这并不高效，因此建议坚持使用单个运行时。Rocket本身使用`tokio`作为`async`/`await`的运行时。'
- en: 'We have used `async` functions in code before, so let''s now use `async` functions
    in more depth. Let''s convert the previous image processing to use the `async`
    programming technique by following these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在代码中使用过`async`函数，现在让我们更深入地使用`async`函数。让我们按照以下步骤将之前的图像处理转换为使用`async`编程技术：
- en: 'Add the crate dependency in `Cargo.toml`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cargo.toml`中添加crate依赖项：
- en: '[PRE73]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we look at the code that handles uploading, we can see that file-related
    operations use a standard library, so they are blocking. We want to replace those
    libraries with Tokio-equivalent `async` libraries. Remove the `use` declaration
    from `src/routes/post.rs`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看处理上传的代码，我们可以看到文件相关的操作使用的是标准库，因此是阻塞的。我们希望用Tokio等效的`async`库替换这些库。从`src/routes/post.rs`中移除`use`声明：
- en: '[PRE74]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, add these `use` declarations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下`use`声明：
- en: '[PRE75]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Replace the content of the `mt.is_text()` block from the standard library into
    a Tokio-equivalent library. Find the following lines:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标准库中的`mt.is_text()`块的内容替换为Tokio等效库。找到以下行：
- en: '[PRE76]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Replace those lines with the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行替换为以下内容：
- en: '[PRE77]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Next, replace reading the file in the `mt.is_bmp() || mt.is_jpeg() || mt.is_png()
    || mt.is_gif()` block. Replace synchronous reading of the file and use a Tokio-equivalent
    file reading functionality. We want to wrap the result in `std::io::Cursor` because
    `ImageReader` methods require the `std::io::Read + std::io:Seek` trait, and `Cursor`
    is a type that implemented those traits.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，替换`mt.is_bmp() || mt.is_jpeg() || mt.is_png() || mt.is_gif()`块中的文件读取。将文件的同步读取替换为Tokio等效的文件读取功能。我们希望将结果包裹在`std::io::Cursor`中，因为`ImageReader`方法需要`std::io::Read
    + std::io:Seek`特质，而`Cursor`是一个实现了这些特质的类型。
- en: 'Find the following lines:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以下行：
- en: '[PRE78]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Replace those lines with the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行替换为以下内容：
- en: '[PRE79]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Wrap the image decoding code in `tokio::task::spawn_blocking`. This function
    allows synchronous code to run inside the Tokio executor. Find the following lines:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像解码代码包裹在`tokio::task::spawn_blocking`中。这个函数允许同步代码在Tokio执行器中运行。找到以下行：
- en: '[PRE80]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Replace them with the following lines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们替换为以下行：
- en: '[PRE81]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, we want to wrap the JPEG encoding in `spawn_blocking` as well. We also
    want to change file writing into a Tokio `async` function. Find the following
    lines:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望将JPEG编码也包裹在`spawn_blocking`中。我们还想将文件写入改为Tokio的`async`函数。找到以下行：
- en: '[PRE82]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Replace them with the following lines:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们替换为以下行：
- en: '[PRE83]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, we can run the application and try the uploading functionality again. There
    should be no differences, except it now uses the `async` function. If there are
    a lot of requests, an asynchronous application should fare better because the
    application can use the thread to do other tasks while the application deals with
    long I/O, such as reading from and writing to a database, dealing with network
    connections, and handling files, for example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行应用程序并再次尝试上传功能。应该没有差异，除了现在它使用了`async`函数。如果有大量请求，异步应用程序应该表现得更好，因为应用程序可以在处理长I/O（例如从数据库读取和写入、处理网络连接和处理文件等）的同时使用线程来执行其他任务。
- en: There is one more example where the application uses `tokio::sync::channel`
    to create another asynchronous channel, and `rayon` (a crate for data parallelism).
    You can find this example in the source code for this chapter in the `Chapter10/04UploadingPhotoRayon`
    folder.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个例子，其中应用程序使用 `tokio::sync::channel` 创建另一个异步通道，以及 `rayon`（一个用于数据并行的crate）。您可以在
    `Chapter10/04UploadingPhotoRayon` 文件夹中找到本章源代码中的此示例。
- en: In the next section, let's create the handle for uploading videos and processing
    videos using a worker.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建用于上传视频和处理视频的worker的句柄。
- en: Uploading a video post and process using a worker
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用worker上传视频帖子并处理
- en: In this section, we are going to process an uploaded video. Processing an uploaded
    video is not a trivial task as it can take a lot of time, so even with the `async`
    programming technique, the generated response will take a lot of time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将处理一个上传的视频。处理上传的视频不是一个简单任务，因为它可能需要很长时间，所以即使使用 `async` 编程技术，生成的响应也会花费很长时间。
- en: 'Another technique in programming to solve a long processing time is using message
    passing. We are going to create another thread to process the video. When a user
    uploads a video, we will do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中解决长时间处理问题的另一种技术是使用消息传递。我们将创建另一个线程来处理视频。当用户上传视频时，我们将执行以下操作：
- en: Generate a path to the temporary file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成临时文件的路径。
- en: Mark the path as unprocessed.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径标记为未处理。
- en: Store the path to the file in the database.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件的路径存储在数据库中。
- en: Send a message from the main Rocket thread into the thread for processing the
    video.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主Rocket线程向处理视频的线程发送消息。
- en: Return the response for uploading the video.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回上传视频的响应。
- en: If the thread to process the video receives a message, it will find the data
    from the database, process the file, and mark the post as finished.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理视频的线程收到消息，它将从数据库中找到数据，处理文件，并将帖子标记为完成。
- en: If the user requests the `posts` list or posts while it's still being processed,
    the user will see the loading image. If the user requests the `posts` list or
    posts after the processing is finished, the user will see the correct video in
    the web browser.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在处理过程中请求 `posts` 列表或帖子，用户将看到加载图像。如果用户在处理完成后请求 `posts` 列表或帖子，用户将在网络浏览器中看到正确的视频。
- en: Rust libraries for video processing are not very mature yet. There are a couple
    of libraries that can be used to wrap the `ffmpeg` library, but using the `ffmpeg`
    library is complicated, even if it's used in its own language, the C language.
    One solution is to use the `ffmpeg-cli` crate, a wrapper for the `ffmpeg` binary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的视频处理库还不够成熟。有几个库可以用来封装 `ffmpeg` 库，但使用 `ffmpeg` 库很复杂，即使是在其自己的语言中，也就是C语言。一个解决方案是使用
    `ffmpeg-cli` crate，它是 `ffmpeg` 二进制的封装。
- en: 'Follow these instructions to process uploaded video files:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明处理上传的视频文件：
- en: 'We want to add the `ffmpeg-cli` crate and the `flume` crate as dependencies.
    The `flume` crate works by generating a channel, a producer, and a consumer. There
    are similar libraries, such as `std::sync::mpsc` or `crossbeam-channel`, which
    can be used with varying performance and quality. Add the dependencies to `Cargo.toml`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望添加 `ffmpeg-cli` crate 和 `flume` crate 作为依赖项。`flume` crate 通过生成通道、生产者和消费者来工作。还有类似的库，如
    `std::sync::mpsc` 或 `crossbeam-channel`，可以根据不同的性能和质量使用。将依赖项添加到 `Cargo.toml`：
- en: '[PRE84]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Change the form to allow uploading video files. Edit `src/views/posts/index.html.tera`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改表单以允许上传视频文件。编辑 `src/views/posts/index.html.tera`：
- en: '[PRE85]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Find a placeholder image to show the video is still being processed. There's
    a `loading.gif` example file in the source code for this section in `Chapter10/05ProcessingVideo/static/loading.gif`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个占位图来显示视频仍在处理中。在 `Chapter10/05ProcessingVideo/static/loading.gif` 文件夹中可以找到本节源代码中的
    `loading.gif` 示例文件。
- en: 'Modify the `raw_html()` method for `VideoPost` in `src/models/video_post.rs`
    to show the `loading.gif` image if the video is still not processed yet:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `src/models/video_post.rs` 中 `VideoPost` 的 `raw_html()` 方法，以显示如果视频尚未处理，则显示
    `loading.gif` 图像：
- en: '[PRE86]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We want a method for `Post` to update the content and mark it as permanent.
    Inside the `impl Post{}` block in `src/models/post.rs`, add the following method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望有一个方法来更新 `Post` 的内容并将其标记为永久。在 `src/models/post.rs` 的 `impl Post{}` 块中添加以下方法：
- en: '[PRE87]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We want to create a message that we want to send to the channel. In `src/models/mod.rs`,
    add a new module:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望创建一个要发送到通道的消息。在 `src/models/mod.rs` 中添加一个新的模块：
- en: '[PRE88]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, create a new file, `src/models/worker.rs`. Create a new `Message` struct
    in the file as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新文件，`src/models/worker.rs`。在文件中创建一个新的 `Message` 结构体如下：
- en: '[PRE89]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a worker that will be executed when a channel receives a message. Add
    a new module in `src/lib.rs` called `worker`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个当通道接收到消息时将被执行的工作线程。在 `src/lib.rs` 中添加一个名为 `worker` 的新模块：
- en: '[PRE90]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a folder named `workers`. Then, create a new file, `src/workers/mod.rs`,
    and add a new video module:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `workers` 的文件夹。然后，创建一个新文件，`src/workers/mod.rs`，并添加一个新的视频模块：
- en: '[PRE91]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a new file, `src/workers/video.rs`, and add the required `use` declarations:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`src/workers/video.rs`，并添加所需的 `use` 声明：
- en: '[PRE92]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Add the function signature to process the video as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下函数签名来处理视频：
- en: '[PRE93]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Inside the `process_video()` function, append these lines to prepare the destination
    file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `process_video()` 函数内部，添加以下行来准备目标文件：
- en: '[PRE94]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We want to re-encode all the files into MP4 files and use the `x265` codec
    for the video file destination. Append these lines to build the parameters for
    the `ffmpeg` binary:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将所有文件重新编码成 MP4 文件，并使用 `x265` 编解码器作为视频文件的目标。将这些行添加到构建 `ffmpeg` 二进制文件的参数：
- en: '[PRE95]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The next and final step for the worker is to execute the builder. We can make
    it `async` too. Append the following lines:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于工作线程来说，接下来的最后一步是执行构建器。我们也可以将其设置为 `async`。添加以下行：
- en: '[PRE96]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The next thing we want to do is to create a thread to receive and process the
    message. We can add a new thread after we initialize Rocket in `src/main.rs`.
    We want to do several things:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来想要做的是创建一个线程来接收和处理消息。我们可以在初始化 `src/main.rs` 中的 Rocket 之后添加一个新的线程。我们想要做几件事情：
- en: Initialize a `worker` thread.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个 `worker` 线程。
- en: Initialize a producer (message sender) and a consumer (message receiver).
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个生产者（消息发送者）和一个消费者（消息接收者）。
- en: Initialize a database pool.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个数据库连接池。
- en: In the `worker` thread, the consumer will obtain a connection from the database
    pool and process the message.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `worker` 线程中，消费者将从数据库连接池中获取一个连接并处理消息。
- en: 'Let''s start by adding `use` declarations in `src/main.rs`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 `src/main.rs` 中添加 `use` 声明开始：
- en: '[PRE97]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Add the structs to get the database configuration from `Rocket.toml` in `src/main.rs`
    after the `use` declaration:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main.rs` 中的 `use` 声明之后添加结构体以从 `Rocket.toml` 获取数据库配置：
- en: '[PRE98]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In the `rocket()` function after `setup_logger()`, initialize the `flume` producer
    and consumer as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `rocket()` 函数中的 `setup_logger()` 之后，初始化 `flume` 生产者和消费者如下：
- en: '[PRE99]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let Rocket manage the `tx` variable. We also want to assign the generated Rocket
    object into a variable, because we want to get the database configuration. Find
    these lines:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 Rocket 管理 `tx` 变量。我们还想将生成的 Rocket 对象赋值给一个变量，因为我们想获取数据库配置。找到以下行：
- en: '[PRE100]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Replace them with the following lines:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们替换为以下行：
- en: '[PRE101]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'After we get `our_rocket`, we want to get the database configuration and initialize
    a new database connection pool for the worker. Append the following lines:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们获取 `our_rocket` 之后，我们想要获取数据库配置并为工作线程初始化一个新的数据库连接池。添加以下行：
- en: '[PRE102]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Make a thread that will receive and process the message. Also, don''t forget
    that to return `our_rocket` as a `rocket()` signature, we require the `Rocket<Build>`
    return value. Append the following lines:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个线程来接收和处理消息。同时，别忘了为了返回 `our_rocket` 作为 `rocket()` 签名，我们需要 `Rocket<Build>`
    返回值。添加以下行：
- en: '[PRE103]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, it''s time to use the managed `tx` variable to send a message in the `create_post()`
    route handling function after we create the video. In `src/routes/post.rs`, add
    the required `use` declarations:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在创建视频后，在 `create_post()` 路由处理函数中使用管理的 `tx` 变量发送消息。在 `src/routes/post.rs`
    中添加所需的 `use` 声明：
- en: '[PRE104]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the `create_post()` function, retrieve the `Sender<Message>` instance managed
    by Rocket. Add the `Sender<Message>` instance to the function parameters:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `create_post()` 函数中，检索由 Rocket 管理的 `Sender<Message>` 实例。将 `Sender<Message>`
    实例添加到函数参数中：
- en: '[PRE105]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Before the `if mt.is_text()` block, append the following variables:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if mt.is_text()` 块之前，添加以下变量：
- en: '[PRE106]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'After the `if mt.is_svg() {}` block, add a new block to initialize a temporary
    video value and assign the value to the `wm` variable we have initialized:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `if mt.is_svg() {}` 块之后，添加一个新的块来初始化一个临时视频值并将其赋值给我们已经初始化的 `wm` 变量：
- en: '[PRE107]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Find the post creation and return value in the following lines:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下行中找到帖子创建和返回值：
- en: '[PRE108]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Modify this into the following lines:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将其修改为以下行：
- en: '[PRE109]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now try restarting the application and uploading the video file; notice the
    loading page. If the video has been processed, the video should be displayed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试重新启动应用程序并上传视频文件；注意加载页面。如果视频已经被处理，视频应该会显示：
- en: '![Figure 10.2 – Uploaded video post'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 上传的视频帖子'
- en: '](img/Figure_10.2_B16825.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B16825.jpg)'
- en: Figure 10.2 – Uploaded video post
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 上传的视频帖子
- en: Message passing is a very useful technique to process long-running jobs. Try
    using this technique if your application requires heavy processing but you need
    to return responses quickly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递是一种非常实用的技术，用于处理长时间运行的任务。如果你的应用程序需要大量处理但需要快速返回响应，请尝试使用这项技术。
- en: Some applications use a more advanced application called a **message broker**,
    which can retry sending messages, schedule sending messages, send messages to
    multiple applications, and much more. Some well-known message broker applications
    are RabbitMQ, ZeroMQ, and Redis. There are many cloud services providing message
    broker services as well, such as Google Cloud Pub/Sub.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序使用更高级的应用程序，称为**消息代理**，它可以重试发送消息、安排发送消息、将消息发送到多个应用程序等。一些知名的消息代理应用程序包括 RabbitMQ、ZeroMQ
    和 Redis。许多云服务也提供消息代理服务，例如 Google Cloud Pub/Sub。
- en: 'Before we complete this chapter, there''s one more thing we can do: delete
    the user post. Try writing the `delete_post()` function. You can find the sample
    code in the `Chapter10/06DeletingPost` folder on GitHub.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，我们还可以做一件事：删除用户帖子。尝试编写 `delete_post()` 函数。你可以在 GitHub 的 `Chapter10/06DeletingPost`
    文件夹中找到示例代码。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned several things.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多东西。
- en: The first thing we learned is how to process multipart forms in Rocket. After
    that, we learned how to use `TempFile` to upload files. Along with uploading photos
    and videos, we learned how to process the image files and video files.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习的是如何在 Rocket 中处理多部分表单。之后，我们学习了如何使用 `TempFile` 上传文件。在上传照片和视频的同时，我们还学习了如何处理图像文件和视频文件。
- en: We learned more about concurrent programming with `async`/`await` and multithreading.
    We also covered how to create a thread and pass a message to a different thread.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `async`/`await` 和多线程学习了更多关于并发编程的知识。我们还介绍了如何创建线程并将消息传递给不同的线程。
- en: In the next chapter, we will focus on how to do authentication, authorization,
    and serving the API from the Rocket application.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注如何在 Rocket 应用程序中实现身份验证、授权以及提供 API 服务。
