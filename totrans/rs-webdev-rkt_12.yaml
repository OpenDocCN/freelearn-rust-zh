- en: '*Chapter 10*: Uploading and Processing Posts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to upload user posts. We will start
    with the basics of multipart uploads and continue with `TempFile` to store the
    uploaded files. After uploading the files, we will implement image processing.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we are going to learn about is improving processing using concurrent
    programming techniques, asynchronous programming, and multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a text post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading a photo post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing files asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading a video post and process using worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we have the usual requirements: a Rust compiler, a text editor,
    a web browser, and a PostgreSQL database server. Aside from those requirements,
    we are going to process uploaded video files. Download the **FFmpeg** command
    line from [https://www.ffmpeg.org/download.html](https://www.ffmpeg.org/download.html).
    FFmpeg is a multimedia framework to process media files. Make sure you can run
    FFmpeg on the terminal of your operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a text post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we want to upload is a text post because it's the simplest type.
    When we submit the form in HTML, we can specify the `form` tag `enctype` attribute
    as `text/plain`, `application/x-www-form-urlencoded`, or `multipart/form-data`.
    We already learned how to process `application/x-www-form-urlencoded` in the Rocket
    application when we learned how to create a user. We create a struct and derive
    `FromForm` for that struct. Later, in the route handling function, we set a route
    attribute, such as `get` or `post`, and assign the struct in the `data` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request body for `Content-Type="application/x-www-form-urlencoded"` is
    simple: the form keys and values are encoded in key-value tuples separated by
    `&`, with an equals sign (`=`) between the key and the value. If the characters
    sent are not alphanumeric, they''re percent-encoded (`%`). An example of a form
    request body is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For uploading a file, `Content-Type` is `multipart/form-data`, and the body
    is different. Suppose we have the following HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP body can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rocket, we can process `multipart/form-data` by using the `multer` crate.
    Let''s try to implement uploading using that crate by following these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify our application by adding these crates into the `Cargo.toml` dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add these configurations in `Rocket.toml` to handle the file upload limit and
    add a temporary directory to store the uploaded files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `src/views/posts/index.html.tera` to add a form where the user can upload
    a file. Add the following lines after the pagination block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `create()` method for `Post` in the `src/models/post.rs` file. We want
    a method to save the `Post` data into the database. Add the following lines inside
    the `impl Post {}` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can remove `FromForm` as we will not use the placeholder anymore. Remove
    these lines from `src/models/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need the value from the request''s `Content-Type` to get a multipart boundary,
    but Rocket doesn''t have a request guard that can do that. Let''s create a type
    that can handle a raw HTTP `Content-Type` header. In `src/lib.rs`, add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `src` folder, create another folder, named `guards`, and then create
    a `src/guards/mod.rs` file. Inside the file, add the struct to handle the raw
    HTTP request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `FromRequest` for `RawContent` to create a request guard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rocket will consider the `"/users/delete/<uuid>"` route as conflicting with
    the `"/users/<user_uuid>/posts"` route. To avoid that problem, we can add `rank`
    to the route macro. In `src/routes/user.rs`, edit the route macro above the `delete_user_entry_point()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/routes/post.rs`, add the required `use` declaration to implement the
    handling of the HTTP multipart request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a constant to limit the size of the uploaded file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s modify the `get_posts()` function as well to add a `flash` message if
    the upload fails or is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to implement the `create_post()` function. The first thing we
    need to do is modify the `post` route macro and function signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `create_post()` function, add a closure that returns an error. We
    add a closure to avoid repetition. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under the `create_err` definition, continue by getting the boundary from the
    `content_type` request guard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `TextPost`, we just store the content of the text file in the post''s `content`
    field. Let''s open the request body, process it as a multipart, and define a new
    variable to store the content of the body. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing we need to do is to iterate the multipart fields. We can iterate
    multipart fields as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we only have one field in the form, we can just get the content of the first
    field and put the value in the `text_post` variable. Append the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after we get the request body content and assign it to `text_post`,
    it''s time to store it in the database and return to the `posts` list page. Append
    the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try restarting the application and uploading the text file. You should
    see the content of the text file on the `posts` list page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Uploaded text posts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Uploaded text posts
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have implemented uploading and processing text files, it is time
    to move on to uploading and processing photo files.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a photo post
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Rocket *0.5*, uploading multipart files had to be implemented manually,
    as in the previous section. Starting from Rocket *0.5*, there's a `rocket::fs::TempFile`
    type that can be used directly to handle uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: To handle processing image files, we can use an `image` crate. The crate can
    handle opening and saving various image file formats. The `image` crate also provides
    ways to manipulate the image.
  prefs: []
  type: TYPE_NORMAL
- en: Websites process uploaded media files such as images for various reasons, including
    reducing disk usage. Some websites reduce the image quality and encode the uploaded
    images into file format with a default smaller size. In this example, we are going
    to convert all uploaded images into JPEG files with 75% quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement uploading image files using the `image` crate and the `TempFile`
    struct by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove `multer` and `tokio-util` from `Cargo.toml`. Then, add the `image` crate
    to `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove `pub mod guards;` from `src/lib.rs` and then remove the `src/guards`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a struct to handle uploaded files in `src/models/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `src/views/posts/index.html.tera` to include images as accepted files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove unused `use` declarations, `TEXT_LIMIT` constant, and part of the `create_post()`
    function from the boundary variable declaration to the multipart iteration block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the required `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the `NewPost` struct that we created earlier as a regular `FromForm`
    deriving struct. Modify the `create_post()` function signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under the `create_err` closure declaration, generate a random `uuid` name for
    the new name of the uploaded file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check `Content-Type` of the uploaded file, and if the Temp File cannot determine
    it, return an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the extension of the uploaded file and create a new filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Persist the uploaded file in the temporary location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `content` and `post_type` to be saved later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the media type of the file. We can separate media types into bitmaps
    and `svg` files. For now, we are going to process text and images only. We will
    process videos in the next section. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to process the text first. Create a vector of byte (`u8`), open and
    read the file into the vector, and push the vector into the content String we
    defined previously. Add these lines inside the `mt.is_text()` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to process the `svg` file. For this one, we cannot convert it
    into a JPEG file; we just want to copy the file into a `static` folder and create
    an image path of `/assets/random_uuid_filename.svg`. Append the following lines
    inside the `mt.is_svg()` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For bitmap files, we want to convert them into JPEG files. First, we want to
    define the destination filename. Append the following lines inside the `mt.is_bmp()
    || mt.is_jpeg() || mt.is_png() || mt.is_gif()` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continuing the bitmap processing, open the file into a buffer and decode the
    buffer into a binary format that the `image` crate understands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a path for the destination file where we want the JPEG result to be,
    and create a file at that path. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create a JPEG decoder, specify the JPEG quality and the image attributes,
    and write the binary format into the destination file. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can save the post as in the previous section. Change the `Post::create()`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now finished creating the routine to upload and process text and image
    files using `TempFile` and the `image` crate. Unfortunately, this process uses
    a more traditional programming paradigm that can be improved. Let's learn how
    to process the files asynchronously in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing files asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of computer development, the available resources were usually
    limited in some way. For example, an older generation CPU can only execute one
    thing at a time. This makes computing difficult because computer resources must
    wait for the execution of tasks sequentially. For example, while the CPU is calculating
    a number, the user cannot input anything using the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Then, people invented operating systems with a **scheduler**, which assigns
    resources to run tasks. The invention of the scheduler led to the idea of a **thread**.
    A thread, or operating system thread, is the smallest sequence of program instructions
    that can be executed independently by the scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Some modern programming languages can generate applications that spawn multiple
    threads at the same time, and so are called **multithreaded** applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multithreaded applications can be a drawback, as creating a thread
    allocates various resources, such as a memory stack. In certain applications,
    such as desktop applications, it's suitable to create multiple threads. But, creating
    multiple threads can be a problem in other applications, such as web applications,
    where requests and responses come and go quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There are techniques to overcome this problem in multiple ways. Some languages
    opt to have **green threads**, or **virtual threads**, where the language runtime
    manages a single operating system thread and makes the program behave as if it's
    multithreaded. Some other languages, such as Javascript and Rust, opt to have
    **async/await**, a syntactic feature that allows execution parts to be suspended
    and resumed.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we used the Rust standard library to open and write
    files for image processing. The library itself is called blocking because, it
    waits until all the files have been loaded or written. That is not efficient because
    I/O operations are slower than CPU operations, and the thread can be used to do
    other operations. We can improve the program by using asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust, we can declare an `async` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Any `async` function returns the `std::future::Future` trait. By default, running
    the function does not do anything. We can use `async_task1` and an executor, such
    as the `futures` crate, to run the `async` function. The following code will behave
    like regular programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `.await` after the function usage to not block the thread, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can wait for both functions to finish, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `futures` crate is very basic; we can use other runtimes that provide an
    executor and a scheduler and many other functionalities. There are a couple of
    competing runtimes in the Rust ecosystem, such as `tokio`, `smol`, and `async-std`.
    We can use those different runtimes together but it's not very efficient, so it's
    advised to stick with a single runtime. Rocket itself uses `tokio` as the runtime
    for `async`/`await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used `async` functions in code before, so let''s now use `async` functions
    in more depth. Let''s convert the previous image processing to use the `async`
    programming technique by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the crate dependency in `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we look at the code that handles uploading, we can see that file-related
    operations use a standard library, so they are blocking. We want to replace those
    libraries with Tokio-equivalent `async` libraries. Remove the `use` declaration
    from `src/routes/post.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add these `use` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the content of the `mt.is_text()` block from the standard library into
    a Tokio-equivalent library. Find the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace those lines with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Next, replace reading the file in the `mt.is_bmp() || mt.is_jpeg() || mt.is_png()
    || mt.is_gif()` block. Replace synchronous reading of the file and use a Tokio-equivalent
    file reading functionality. We want to wrap the result in `std::io::Cursor` because
    `ImageReader` methods require the `std::io::Read + std::io:Seek` trait, and `Cursor`
    is a type that implemented those traits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace those lines with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap the image decoding code in `tokio::task::spawn_blocking`. This function
    allows synchronous code to run inside the Tokio executor. Find the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace them with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to wrap the JPEG encoding in `spawn_blocking` as well. We also
    want to change file writing into a Tokio `async` function. Find the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace them with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can run the application and try the uploading functionality again. There
    should be no differences, except it now uses the `async` function. If there are
    a lot of requests, an asynchronous application should fare better because the
    application can use the thread to do other tasks while the application deals with
    long I/O, such as reading from and writing to a database, dealing with network
    connections, and handling files, for example.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more example where the application uses `tokio::sync::channel`
    to create another asynchronous channel, and `rayon` (a crate for data parallelism).
    You can find this example in the source code for this chapter in the `Chapter10/04UploadingPhotoRayon`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's create the handle for uploading videos and processing
    videos using a worker.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a video post and process using a worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to process an uploaded video. Processing an uploaded
    video is not a trivial task as it can take a lot of time, so even with the `async`
    programming technique, the generated response will take a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another technique in programming to solve a long processing time is using message
    passing. We are going to create another thread to process the video. When a user
    uploads a video, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a path to the temporary file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the path as unprocessed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the path to the file in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a message from the main Rocket thread into the thread for processing the
    video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the response for uploading the video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the thread to process the video receives a message, it will find the data
    from the database, process the file, and mark the post as finished.
  prefs: []
  type: TYPE_NORMAL
- en: If the user requests the `posts` list or posts while it's still being processed,
    the user will see the loading image. If the user requests the `posts` list or
    posts after the processing is finished, the user will see the correct video in
    the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Rust libraries for video processing are not very mature yet. There are a couple
    of libraries that can be used to wrap the `ffmpeg` library, but using the `ffmpeg`
    library is complicated, even if it's used in its own language, the C language.
    One solution is to use the `ffmpeg-cli` crate, a wrapper for the `ffmpeg` binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these instructions to process uploaded video files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to add the `ffmpeg-cli` crate and the `flume` crate as dependencies.
    The `flume` crate works by generating a channel, a producer, and a consumer. There
    are similar libraries, such as `std::sync::mpsc` or `crossbeam-channel`, which
    can be used with varying performance and quality. Add the dependencies to `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the form to allow uploading video files. Edit `src/views/posts/index.html.tera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Find a placeholder image to show the video is still being processed. There's
    a `loading.gif` example file in the source code for this section in `Chapter10/05ProcessingVideo/static/loading.gif`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `raw_html()` method for `VideoPost` in `src/models/video_post.rs`
    to show the `loading.gif` image if the video is still not processed yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want a method for `Post` to update the content and mark it as permanent.
    Inside the `impl Post{}` block in `src/models/post.rs`, add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to create a message that we want to send to the channel. In `src/models/mod.rs`,
    add a new module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new file, `src/models/worker.rs`. Create a new `Message` struct
    in the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a worker that will be executed when a channel receives a message. Add
    a new module in `src/lib.rs` called `worker`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder named `workers`. Then, create a new file, `src/workers/mod.rs`,
    and add a new video module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new file, `src/workers/video.rs`, and add the required `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the function signature to process the video as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `process_video()` function, append these lines to prepare the destination
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to re-encode all the files into MP4 files and use the `x265` codec
    for the video file destination. Append these lines to build the parameters for
    the `ffmpeg` binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next and final step for the worker is to execute the builder. We can make
    it `async` too. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next thing we want to do is to create a thread to receive and process the
    message. We can add a new thread after we initialize Rocket in `src/main.rs`.
    We want to do several things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a `worker` thread.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize a producer (message sender) and a consumer (message receiver).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize a database pool.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `worker` thread, the consumer will obtain a connection from the database
    pool and process the message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by adding `use` declarations in `src/main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the structs to get the database configuration from `Rocket.toml` in `src/main.rs`
    after the `use` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `rocket()` function after `setup_logger()`, initialize the `flume` producer
    and consumer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let Rocket manage the `tx` variable. We also want to assign the generated Rocket
    object into a variable, because we want to get the database configuration. Find
    these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace them with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'After we get `our_rocket`, we want to get the database configuration and initialize
    a new database connection pool for the worker. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make a thread that will receive and process the message. Also, don''t forget
    that to return `our_rocket` as a `rocket()` signature, we require the `Rocket<Build>`
    return value. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it''s time to use the managed `tx` variable to send a message in the `create_post()`
    route handling function after we create the video. In `src/routes/post.rs`, add
    the required `use` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `create_post()` function, retrieve the `Sender<Message>` instance managed
    by Rocket. Add the `Sender<Message>` instance to the function parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before the `if mt.is_text()` block, append the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `if mt.is_svg() {}` block, add a new block to initialize a temporary
    video value and assign the value to the `wm` variable we have initialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the post creation and return value in the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify this into the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try restarting the application and uploading the video file; notice the
    loading page. If the video has been processed, the video should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Uploaded video post'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Uploaded video post
  prefs: []
  type: TYPE_NORMAL
- en: Message passing is a very useful technique to process long-running jobs. Try
    using this technique if your application requires heavy processing but you need
    to return responses quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Some applications use a more advanced application called a **message broker**,
    which can retry sending messages, schedule sending messages, send messages to
    multiple applications, and much more. Some well-known message broker applications
    are RabbitMQ, ZeroMQ, and Redis. There are many cloud services providing message
    broker services as well, such as Google Cloud Pub/Sub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we complete this chapter, there''s one more thing we can do: delete
    the user post. Try writing the `delete_post()` function. You can find the sample
    code in the `Chapter10/06DeletingPost` folder on GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned several things.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we learned is how to process multipart forms in Rocket. After
    that, we learned how to use `TempFile` to upload files. Along with uploading photos
    and videos, we learned how to process the image files and video files.
  prefs: []
  type: TYPE_NORMAL
- en: We learned more about concurrent programming with `async`/`await` and multithreading.
    We also covered how to create a thread and pass a message to a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on how to do authentication, authorization,
    and serving the API from the Rocket application.
  prefs: []
  type: TYPE_NORMAL
