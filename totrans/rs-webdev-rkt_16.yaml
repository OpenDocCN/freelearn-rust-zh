- en: '*Chapter 13*: Launching a Rocket Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After development and testing, an important part of development is preparing
    the application to serve its intended users. In this chapter, we are going to
    learn some techniques to generate a production-ready binary. After we generate
    the binary, we are going to learn about configuring the application behind a general-purpose
    web server. And finally, we will learn how to generate Docker images for a Rocket
    application.
  prefs: []
  type: TYPE_NORMAL
- en: After learning the information in this chapter, you will be able to optimize
    binaries using Rust compiler flags and Cargo configurations. You will also learn
    techniques to prepare your applications to serve their intended users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover these main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing production binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Apache HTTP Server with a Rocket application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating Docker images for a Rocket application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to serve HTTP requests using the Apache HTTP
    Server ([https://httpd.apache.org/](https://httpd.apache.org/)). If you have a
    Unix-based operating system, you can usually find the Apache HTTP Server in your
    operating system package manager. If you have a Windows operating system, there
    are recommended downloads at the following link: [https://httpd.apache.org/docs/2.4/platform/windows.html](https://httpd.apache.org/docs/2.4/platform/windows.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to generate a TLS (Transport Layer Security) certificate using
    OpenSSL. If you have a Unix-based operating system, you can usually find the OpenSSL
    binary using the distribution''s package manager. If you have a Windows operating
    system, you can find the recommended binary at the following link: [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For generating Docker images, you can use Docker Desktop from the following
    link: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code of this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter13)
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing production binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we create the application, we want to prepare the application to accept
    a real connection. In software development, there's a production environment,
    also called a release environment or deployment environment. The production environment
    contains the configuration of the system and software to make it available to
    the intended customer. In [*Chapter 2*](B16825_02_ePub.xhtml#_idTextAnchor032),
    *Building Our First Rocket Web Application*, we learned that we can tell the Rust
    compiler to build release binary when compiling the Rust application. We can use
    `cargo build` or `cargo run` with the extra `--release` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To refresh, Cargo will read the configuration in `Cargo.toml` in the `[profile.release]`
    section. There are some compilation optimizations we can do to improve the resulting
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the number of `codegen-units` of compilation. Rust compilation
    can take significant time, and to solve this, the compiler may try to split it
    into parts and compile them in parallel. But, compiling binaries or libraries
    in parallel might omit some optimization. By default, the number of `codegen-units`
    is `3`. We can sacrifice the compilation speed and make `codegen-units` into `1`
    to optimize the resulting binary further. For example, in `Cargo.toml`, we can
    have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`codegen` backend, LLVM, can perform various LTOs to produce output with optimized
    code. To enable LTO, we can set `lto = yes` or `lto = "fat"`. The following is
    an example of `lto` in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the optimization level. We can set optimization levels from `0`, `1`, `2`,
    and `3`, with the default value being `0` (no optimization) up to `3` (all optimization)
    as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Besides optimization level `0` to `3`, we can also also set `"s"` and `"z"`,
    with `"s"` for binary size optimization and `"z"` for binary size optimization
    and turn of loop vectorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable `panic` unwinding. We can set `panic` to not show the stack trace.
    The result is a more optimized binary. Set the following in `Cargo.toml` to disable
    stack unwinding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second optimization is compiling the correct architecture. CPU producers
    will always create a new CPU with better optimization or instruction sets that
    can improve the performance of an application. For example, the SSE (Streaming
    SIMD Extensions) instruction set was introduced by Intel with the release of Intel
    Pentium III.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the Rust compiler will produce binary with a reasonable amount of
    CPU support. But, this means newer instruction sets or optimizations are not used
    when compiling a library or a binary. We can tell the Rust compiler to produce
    a binary that supports newer optimizations or instruction sets of the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the list of the target architecture supported by the Rust compiler,
    we can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we know the target machine is AMD Ryzen, which supports *znver3*
    architecture, we can compile the Rust program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reason we use the `RUSTFLAGS` environment variable is that `target-cpu`
    is not a recognized option in `Cargo.toml`. Cargo will also use any other `rustc`
    option set in the `RUSTFLAGS` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to compile a Rust application for a production environment,
    let's learn about deploying a Rocket application behind a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Apache HTTP Server with a Rocket application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that Rocket has TLS support in its configuration, so we can set the
    TCP port to `443`, the default HTTPS connection port. In some cases, it might
    be acceptable to run web applications directly, for example, when we want to serve
    content for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons why we don''t want to run the Rocket application directly
    is because of this warning in the Rocket guide:'
  prefs: []
  type: TYPE_NORMAL
- en: Rocket's built-in TLS implements only TLS 1.2 and 1.3\. It may not be suitable
    for production use.
  prefs: []
  type: TYPE_NORMAL
- en: The TLS library used by the Rocket framework might not be suitable for production
    use for various reasons, such as security reasons or it is not yet audited.
  prefs: []
  type: TYPE_NORMAL
- en: There are other reasons why we do not want to serve content directly from Rocket
    aside from the TLS library problem. One example is when we want to serve multiple
    applications from a single computer. We might want to serve PHP applications from
    the same machine too.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the techniques people use when serving a Rust application is putting
    it behind a general-purpose web server that can do a reverse proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 ‒ General purpose web server performing a reverse proxy on a
    Rocket application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 ‒ General purpose web server performing a reverse proxy on a Rocket
    application
  prefs: []
  type: TYPE_NORMAL
- en: One of the most used reverse proxy applications is the Apache HTTP Server. The
    Apache HTTP Server also has other features besides the reverse proxy, including
    serving static files and compressing files to serve requests faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try serving our application using the Apache HTTP Server and configuring
    the server to act as a reverse proxy by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Apache HTTP Server for your operating system or from [https://httpd.apache.org/](https://httpd.apache.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try starting the application using the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Apache HTTP Server''s default port is `8080`. Check that Apache is running
    by using the cURL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Apache HTTP Server's functionalities can be extended by modules, and several
    modules are installed alongside it. We want to enable several modules to enable
    HTTP requests to our application using a reverse proxy. Find `httpd.conf`, the
    configuration file for your operating system. In some Linux distributions, the
    configuration might be in `/etc/httpd/httpd.conf`. In other distributions or operating
    systems, the file location might be in `/usr/local/etc/httpd/httpd.conf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `httpd.conf` file and remove the comment to enable the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same `httpd.conf` file, find these lines and uncomment these lines as
    well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a server name. In a real server, we can acquire a domain by buying
    the rights to it from a domain registrar and pointing the `ourapplication.example.net`.
    Edit `/etc/hosts` and some test domains as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install `openssl` for your operating system. After that, generate a certificate
    for `ourapplication.example.net` using the `openssl` command line, as in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command line will generate two files, `ourapplication.example.com.crt` and
    `ourapplication.example.com.key`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a PEM file, a file format that contains certificate as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `httpd-vhosts.conf`. The file might be in `/usr/local/etc/httpd/extra/`,
    depending on your operating system configuration. Add a new virtual host. We want
    the virtual host to point to our Rocket application at `http://127.0.0.1:8000`.
    Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the configuration is correct by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart and open [https://ourapplication.example.com](https://ourapplication.example.com)
    in your web browser. The web browser might complain because the root certificate
    is unknown. We can add our generated certificate so it''s accepted in our browser.
    For example, in Firefox, we can go to **Preferences** | **Privacy & Security**
    | **View Certificates**. After that, choose **Servers Tab** and click **Add Exception**.
    Then, ensure that **Permanently store this exception** is checked. Finally, click
    on **Confirm Security Exception** to store the security exception. If everything
    goes well, we can use the example domain in the browser, as in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.2 ‒ Using a domain and TLS certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 ‒ Using a domain and TLS certificate
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have deployed the Rocket application behind a reverse proxy, we
    can use the same principle with a real server. Set up the Apache HTTP Server or
    NGINX as a reverse proxy and run the Rocket application behind the reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: To run the Rocket application automatically when the operating system starts,
    we can set up some kind of service for the operating system. If we are running
    a Linux distribution with systemd as a service manager, for example, we can create
    a `systemd` service file and run the application automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn a different way to deploy an application.
    We are going to use Docker to package and create a Docker container for our Rocket
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Docker images for a Rocket application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerization has been a popular choice to ship production applications for
    a while. One of the most popular applications for containerization is Docker.
    In this section, we are going to learn how to set up Docker to run our Rocket
    application. To use the `docker` command line, please install Docker Desktop from
    [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create and run a Docker image of the Rocket application:'
  prefs: []
  type: TYPE_NORMAL
- en: In the root folder of the application, create a Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are some base images we can use to build and run the application. We are
    going to use Rust's official Docker image from [https://hub.docker.com/_/rust](https://hub.docker.com/_/rust).
    For the Linux distribution, we are going to use *Alpine base* because it's one
    of the smallest base images for Docker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Dockerfile, add the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the working directory. Append this line to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use Cargo to install the dependencies, but there is another way to quickly
    compile the application. We can vendorize the dependencies and use the vendor
    dependencies to build the application. Run this command on the root folder of
    the application source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to override the source of the dependencies from the internet to the
    vendor folder. Create a `.cargo` folder in the root application folder, and create
    `config.toml` inside the `.cargo` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append these lines to the `.cargo/config.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to add the required files to build the application as a Docker image.
    We don''t need `Rocket.toml`, templates, or static files to build the application.
    Append these lines to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the instructions to build the image. We want to use another stage and install
    the dependencies to build the image. Add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try building the application by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After testing, add a new part to run the application in the Dockerfile. We
    want to open port `8000`. We also want to add a default time zone and configure
    the user to run the application. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want the image to have the latest libraries. Append the following lines
    to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the working directory. Append the following line to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set `Rocket.toml` to run from `0.0.0.0`. We want to tell the application to
    use the host''s running database. In Docker, we can reference the host machine
    using a special domain, host.docker.internal. Edit `Rocket.toml` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the resulting binary, `Rocket.toml`, assets, and templates to the final
    image. Append the following lines to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the folder to store the log file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add changing permission to `$USER` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the entry point to the application to the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the image and create a tag for it using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After building the Docker image, it''s time to run it. Use the following command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After everything is done, we should see the Docker container is running and
    showing the `our_application` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 ‒ Docker Desktop showing the running container and our_application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 ‒ Docker Desktop showing the running container and our_application
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Rocket application using Docker is just like deploying other applications.
    We need to copy the source, build, and run the resulting image. There are some
    actions that we can perform to ensure proper deployment, such as vendoring the
    libraries and opening the correct ports to ensure requests can be made to the
    running container and applications running inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about production-ready compilation options.
    We can use them to ensure the resulting binary is as optimized as possible. We
    also learned about setting up a general-purpose HTTP server to work in conjunction
    with a Rocket application. And finally, we learned to create and run Docker images
    for the Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: After learning these techniques, we expanded them to set up the Rocket application
    to serve its intended users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about using Rust to create a frontend
    WebAssembly application in conjunction with a Rocket application.
  prefs: []
  type: TYPE_NORMAL
