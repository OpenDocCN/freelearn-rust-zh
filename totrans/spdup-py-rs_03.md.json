["```rs\n    git clone https://github.com/maxwellflitton/flitton-\n      fib-py.git\n    ```", "```rs\n    venv directory in the root directory. We have to use the venv directory, as this is automatically included in the .gitignore file. However, there is nothing stopping us from calling it what we want, as long as we include it in the .gitignore file. However, venv is the convention, and using this will avoid confusion with other developers. Our environment is now fully set up. \n    ```", "```rs\n    source venv/bin/activate\n    ```", "```rs\n    from setuptools import find_packages, setup\n    ```", "```rs\n    setup(\n        name=\"flitton_fib_py\",\n        version=\"0.0.1\",\n        author=\"Maxwell Flitton\",\n        author_email=\"maxwell@gmail.com\",\n        description=\"Calculates a Fibonacci number\",\n        long_description=\"A basic library that \\\n          calculates Fibonacci numbers\",\n        long_description_content_type=\"text/markdown\",\n        url=\"https://github.com/maxwellflitton/flitton- \\\n          fib-py\",\n        install_requires=[],\n        packages=find_packages(exclude=(\"tests\",)),\n        classifiers=[\n            \"Development Status :: 4 - Beta\",\n            \"Programming Language :: Python :: 3\",\n            \"Operating System :: OS Independent\",\n        ],\n        python_requires='>=3',\n        tests_require=['pytest'],\n    )\n    ```", "```rs\n    git add -A\n    git commit -m \"adding setup to module\"\n    git push origin main\n    ```", "```rs\nwith open(\"README.md\", \"r\") as fh:\n```", "```rs\n    long_description = fh.read()\n```", "```rs\nsetup(\n```", "```rs\n    name=\"flitton_fib_py\",\n```", "```rs\n    version=\"0.0.1\",\n```", "```rs\n    author=\"Maxwell Flitton\",\n```", "```rs\n    author_email=\"maxwell@gmail.com\",\n```", "```rs\n    description=\"Calculates a Fibonacci number\",\n```", "```rs\n    long_description=long_description,\n```", "```rs\n    ...\n```", "```rs\n├── LICENSE\n```", "```rs\n├── README.md\n```", "```rs\n├── flitton_fib_py\n```", "```rs\n│   └── __init__.py\n```", "```rs\n├── setup.py\n```", "```rs\n└── venv\n```", "```rs\n    def say_hello() -> None:\n        print(\"the Flitton Fibonacci module is saying hello\")\n    ```", "```rs\n    pip install and check to see whether it works.\n    ```", "```rs\n    pip install git+https://github.com/maxwellflitton/\n      flitton-fib-py@main\n    ```", "```rs\n    python\n    ```", "```rs\n    >>> from flitton_fib_py import say_hello\n    >>> say_hello()\n    ```", "```rs\n    the Flitton Fibonacci module is saying hello\n    ```", "```rs\n├── LICENSE\n```", "```rs\n├── README.md\n```", "```rs\n├── flitton_fib_py\n```", "```rs\n│   ├── __init__.py\n```", "```rs\n│   └── fib_calcs\n```", "```rs\n│       ├── __init__.py\n```", "```rs\n│       ├── fib_number.py\n```", "```rs\n│       └── fib_numbers.py\n```", "```rs\n├── setup.py\n```", "```rs\n    from typing import Optional\n    def recurring_fibonacci_number(number: int) -> \\\n    Optional[int]:\n        if number < 0:\n            return None\n        elif number <= 1:\n            return number\n        else:\n        return recurring_fibonacci_number(number - 1) + \\\n               recurring_fibonacci_number(number - 2)\n    ```", "```rs\n    from typing import List\n    from .fib_number import recurring_fibonacci_number\n    def calculate_numbers(numbers: List[int]) -> List[int]:\n        return [recurring_fibonacci_number(number=i) \\\n          for i in numbers]\n    ```", "```rs\n    >>> from flitton_fib_py.fib_calcs.fib_number \n        import recurring_fibonacci_number\n    >>> recurring_fibonacci_number(5)\n    5\n    >>> recurring_fibonacci_number(8)\n    21\n    ```", "```rs\n    >>> from flitton_fib_py.fib_calcs.fib_numbers \n    import calculate_numbers\n    >>> calculate_numbers([1, 2, 3, 4, 5, 6, 7])\n    [1, 1, 2, 3, 5, 8, 13]\n    ```", "```rs\n├── LICENSE\n```", "```rs\n├── README.md\n```", "```rs\n├── flitton_fib_py\n```", "```rs\n│   ├── __init__.py\n```", "```rs\n│   ├── cmd\n```", "```rs\n│   │   ├── __init__.py\n```", "```rs\n│   │   └── fib_numb.py\n```", "```rs\n│   └── fib_calcs\n```", "```rs\n     . . .\n```", "```rs\n    import argparse\n    from flitton_fib_py.fib_calcs.fib_number \\\n        import recurring_fibonacci_number\n    def fib_numb() -> None:\n        parser = argparse.ArgumentParser(\n            description='Calculate Fibonacci numbers')\n        parser.add_argument('--number', action='store', \n                            type=int, required=True,\n                            help=\"Fibonacci number to be \\\n                              calculated\")\n        args = parser.parse_args()\n        print(f\"Your Fibonacci number is: \" \\\n          f\"{recurring_fibonacci_number \\\n            (number=args.number)}\")\n    ```", "```rs\n    entry_points={\n        'console_scripts': [\n            'fib-number = \\\n               flitton_fib_py.cmd.fib_numb:fib_numb',\n        ],\n    },\n    ```", "```rs\n    argparse module that we are using ensures that we provide the arguments needed. If we need help, we can get this by typing in the following command:\n\n    ```", "```rs\n\n    This gives us the help printout, as shown here:\n\n    ```", "```rs\n\n    We can see that we have the type and the help description of what it does.\n    ```", "```rs\n    fib-number --number 20\n    ```", "```rs\n    Your Fibonacci number is: 6765\n    ```", "```rs\n├── LICENSE\n```", "```rs\n├── README.md\n```", "```rs\n├── flitton_fib_py\n```", "```rs\n     . . .\n```", "```rs\n├── scripts\n```", "```rs\n│   └── run_tests.sh\n```", "```rs\n├── setup.py\n```", "```rs\n├── tests\n```", "```rs\n│   ├── __init__.py\n```", "```rs\n│   └── flitton_fib_py\n```", "```rs\n│       ├── __init__.py\n```", "```rs\n│       └── fib_calcs\n```", "```rs\n│           ├── __init__.py\n```", "```rs\n│           ├── test_fib_number.py\n```", "```rs\n│           └── test_fib_numbers.py\n```", "```rs\n    from unittest import main, TestCase\n    from flitton_fib_py.fib_calcs.fib_number \\\n        import recurring_fibonacci_number\n    ```", "```rs\n    class RecurringFibNumberTest(TestCase):\n        def test_zero(self):\n            self.assertEqual(0, \n                recurring_fibonacci_number(number=0)\n            )\n        def test_negative(self):\n            self.assertEqual(\n                None, recurring_fibonacci_number \\\n                  (number=-1)\n            )\n        def test_one(self):\n            self.assertEqual(1, \\\n              recurring_fibonacci_number(number=1))\n        def test_two(self):\n            self.assertEqual(1, \\ \n              recurring_fibonacci_number(number=2))\n        def test_twenty(self):\n            self.assertEqual( \\\n            6765, recurring_fibonacci_number(number=20)\n            )\n    ```", "```rs\n    if __name__ == \"__main__\":\n        main()\n    ```", "```rs\n    None to a 1 in the second test, we would get the following printout:\n\n    ```", "```rs\n\n    ```", "```rs\n    from unittest import main, TestCase\n    from unittest.mock import patch\n    from flitton_fib_py.fib_calcs.fib_numbers \\\n        import calculate_numbers\n    ```", "```rs\nclass Test(TestCase):\n```", "```rs\n    @patch(\"flitton_fib_py.fib_calcs.fib_numbers.\" \n```", "```rs\n           \"recurring_fibonacci_number\")\n```", "```rs\n    def test_calculate_numbers(self, mock_fib_calc):\n```", "```rs\n        expected_outcome = [mock_fib_calc.return_value, \n```", "```rs\n                          mock_fib_calc.return_value]\n```", "```rs\n        self.assertEqual(expected_outcome, \n```", "```rs\n                         calculate_numbers(numbers=[3, 4]))\n```", "```rs\n        self.assertEqual(2, \n```", "```rs\n          len(mock_fib_calc.call_args_list))\n```", "```rs\n        self.assertEqual({'number': 3}, \n```", "```rs\n          mock_fib_calc.call_args_list[0][1])\n```", "```rs\n        self.assertEqual({'number': 4}, \n```", "```rs\n          mock_fib_calc.call_args_list[1][1])\n```", "```rs\n    def test_functional(self):\n```", "```rs\n        self.assertEqual([2, 3, 5], \n```", "```rs\n            calculate_numbers(numbers=[3, 4, 5]))\n```", "```rs\nif __name__ == \"__main__\":\n```", "```rs\n    main()\n```", "```rs\n#!/usr/bin/env bash\n```", "```rs\nSCRIPTPATH=\"$( cd \"$(dirname \"$0\")\" ; pwd -P )\"\n```", "```rs\ncd $SCRIPTPATH\n```", "```rs\ncd ..\n```", "```rs\nsource venv/bin/activate\n```", "```rs\nexport PYTHONPATH=\"./flitton_fib_py\"\n```", "```rs\npython -m unittest discover\n```", "```rs\n.......\n```", "```rs\n------------------------------------------\n```", "```rs\nRan 7 tests in 0.003s\n```", "```rs\nOK\n```", "```rs\n    pip module in a tar.gz file, which gives us the following file outline:\n\n    ```", "```rs\n\n    ```", "```rs\n    pip install twine\n    ```", "```rs\n    twine upload dist/*\n    ```", "```rs\npip freeze > requirements.txt\n```", "```rs\npip install -r requirements.txt\n```", "```rs\ninstall_requires=[ \n```", "```rs\n    \"PyYAML>=4.1.2\",\n```", "```rs\n    \"dill>=0.2.8\"\n```", "```rs\n],\n```", "```rs\nextras_require={\n```", "```rs\n  'server': [\"Flask>=1.0.0\"]\n```", "```rs\n},\n```", "```rs\npip install flitton-fib-py[server]\n```", "```rs\n    pip install mypy\n    ```", "```rs\n    mypy is doing is checking the consistency across all of our Python code! Like a Rust compiler, it has found an inconsistency. However, because this is Python, we can still run our Python code. While Python is memory-safe, the strong type-checking that Rust enforces is going to reduce the risk of incorrect variables being passed into the function in runtime. Now, we know that there is an inconsistency. The inconsistency is that our recurring_fibonacci_number function returns either None or int. However, our calculate_numbers function relies on the recurring_fibonacci_number function for the return value, but it returns a list of integers as opposed to returning a list of integers or None values.\n    ```", "```rs\n    def recurring_fibonacci_number(number: int) -> int:\n        if number < 0:\n            raise ValueError(\n            \"Fibonacci has to be equal or above zero\"\n            )\n        elif number <= 1:\n            return number\n        else:\n         return recurring_fibonacci_number(number - 1) + \\\n                recurring_fibonacci_number(number - 2)\n    ```", "```rs\n    Success: no issues found in 6 source files\n    ```", "```rs\n    Run tests. \n    ```", "```rs\n    uses step, then we would not be able to access files such as the requirements. \n    ```", "```rs\n    run is just a one-line terminal command. At one point, there is a | (pipe) value next to a run tag of the Install dependencies step. This pipe value simply allows us to write multiple lines of commands in one step. We must ensure that our requirements.txt file is updated with the mypy module. Once this is done, we can push this code to our GitHub repository and this GitHub action will run when we do pull requests. If you are familiar with GitHub and making pull requests, then you can move on to the next step. However, if you are not, then we can perform one now.\n    ```", "```rs\n    test. We can then make a change in our code. \n    ```", "```rs\n    # trigger build (14-6-2021)\n    ```", "```rs\n    def test_negative(self):\n        with self.assertRaises(ValueError) as \\\n    raised_error:\n            recurring_fibonacci_number(number=-1)\n        self.assertEqual(\n            \"Fibonacci has to be equal or above zero\",\n            str(raised_error.exception)\n        ) \n    ```", "```rs\n    os and pathlib to manage writing the latest version to a file. We are also going to use the requests module to call PyPI to get the latest version that is currently available to the public. \n    ```", "```rs\n    def get_latest_version_number() -> str:\n        req = requests.get(\n        \"https://pypi.org/pypi/flitton-fib-py/json\")\n        return req.json()[\"info\"][\"version\"]\n    ```", "```rs\n    def unpack_version_number(version_string: str) \\\n        -> Tuple[int, int, int]:\n        version_buffer: List[str] = \\\n          version_string.split(\".\")\n        return int(version_buffer[0]),\\\n          int(version_buffer[1]),int(version_buffer[2])\n    ```", "```rs\n    def increase_version_number(version_buffer: \\\n    Union[Tuple[int, int, int], List[int]]) -> List[int]:\n        first: int = version_buffer[0]\n        second: int = version_buffer[1]\n        third: int = version_buffer[2]\n        third += 1\n        if third >= 10:\n            third = 0\n            second += 1\n            if second >= 10:\n                second = 0\n                first += 1\n        return [first, second, third]\n    ```", "```rs\n    def pack_version_number(\n        version_buffer: Union[Tuple[int, int, int], \n          List[int]]) -> str:\n        return f\"{version_buffer[0]}.{version_buffer[1]} \\ \n          .{version_buffer[2]}\"\n    ```", "```rs\n    def write_version_to_file(version_number: str) -> \\\n    None:\n        version_file_path: str = str( \\\n        pathlib.Path(__file__).parent.absolute()) + \\\n        \"/flitton_fib_py/version.py\"\n        if os.path.exists(version_file_path):\n            os.remove(version_file_path)\n        with open(version_file_path, \"w\") as f:\n            f.write(f\"VERSION='{version_number}'\")\n    ```", "```rs\n    if __name__ == \"__main__\":\n        write_version_to_file(\n            version_number=pack_version_number(\n                version_buffer=increase_version_number(\n                    version_buffer=unpack_version_number(\n                version_string=get_latest_version_number()\n                    )\n                )\n            )\n        )\n    ```", "```rs\n    import pathlib\n    with open(str(pathlib.Path(__file__).parent.absolute()) +\n              \"/flitton_fib_py/version.py\", \"r\") as fh:\n        version = fh.read().split(\"=\")[1].replace(\"'\", \"\")\n    ```", "```rs\n    setup(\n        name=\"flitton_fib_py\",\n        version=version,\n        ...\n    ```", "```rs\n    name: Publish Python  distributions  to PyPI\n    on:\n      pull_request:\n        types: [closed]\n        branches:\n          - main\n    ```", "```rs\n    jobs:\n      run-shell-command:\n        runs-on: ubuntu-latest\n        steps:\n          - uses: actions/checkout@v2\n          - name: Install dependencies\n            run: |\n              python -m pip install --upgrade pip\n              pip install -r requirements.txt\n          - name: update version\n            run: python get_latest_version.py\n    ```", "```rs\n          - name: install deployment dependancies\n            if: github.event.pull_request.merged == true\n            run: |\n              pip install twine\n              pip install pexpect\n    ```", "```rs\n          - name: package module\n            if: github.event.pull_request.merged == true\n            run: python setup.py sdist\n    ```", "```rs\n          - name: deploy to pypi\n            if: github.event.pull_request.merged == true\n            env:\n              TWINE_USERNAME: ${{ secrets.TWINE_USERNAME \n                }}\n              TWINE_PASSWORD: ${{ secrets.TWINE_PASSWORD \n                }}\n            run: |\n              twine upload dist/*\n    ```"]