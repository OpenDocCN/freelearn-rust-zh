["```rs\n#[cfg(target_arch = \"x86\")]\nconst ARCH: &str = \"x86\";\n\n#[cfg(target_arch = \"x86_64\")]\nconst ARCH: &str = \"x64\";\n\n#[cfg(target_arch = \"mips\")]\nconst ARCH: &str = \"mips\";\n\n#[cfg(target_arch = \"powerpc\")]\nconst ARCH: &str = \"powerpc\";\n\n#[cfg(target_arch = \"powerpc64\")]\nconst ARCH: &str = \"powerpc64\";\n\n#[cfg(target_arch = \"arm\")]\nconst ARCH: &str = \"ARM\";\n\n#[cfg(target_arch = \"aarch64\")]\nconst ARCH: &str = \"ARM64\";\n\nfn main() {\n    println!(\"Hello, world!\");\n    println!(\"Compiled for {}\", ARCH);\n}\n```", "```rs\n$ cargo run\n   Compiling cross-compile v0.1.0 (Rust-Cookbook/Chapter09/cross-\n   compile)\n   Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n   Running `target/debug/cross-compile`\n   Hello, world!\n   Compiled for x64\n```", "```rs\n$ cargo install cross \n   Updating crates.io index\n   Installing cross v0.1.14\n   Compiling libc v0.2.60\n   Compiling cc v1.0.38\n   Compiling cfg-if v0.1.9\n   Compiling rustc-demangle v0.1.15\n   Compiling semver-parser v0.7.0\n   Compiling rustc-serialize v0.3.24\n   Compiling cross v0.1.14\n   Compiling lazy_static v0.2.11\n   Compiling semver v0.9.0\n   Compiling semver v0.6.0\n   Compiling rustc_version v0.2.3\n   Compiling backtrace-sys v0.1.31\n   Compiling toml v0.2.1\n   Compiling backtrace v0.3.33\n   Compiling error-chain v0.7.2\n    Finished release [optimized] target(s) in 15.64s\n   Replacing ~/.cargo/bin/cross\n    Replaced package `cross v0.1.14` with `cross v0.1.14` \n    (executable `cross`)\n$ cross --version\ncross 0.1.14\ncargo 1.36.0 (c4fcfb725 2019-05-15)\n```", "```rs\n$ sudo systemctl start docker\n$ cross build --target armv7-unknown-linux-gnueabihf -v\n+ \"rustup\" \"target\" \"list\"\n+ \"cargo\" \"fetch\" \"--manifest-path\" \"/home/cm/workspace/Mine/Rust-Cookbook/Chapter09/cross-compile/Cargo.toml\"\n+ \"rustc\" \"--print\" \"sysroot\"\n+ \"docker\" \"run\" \"--userns\" \"host\" \"--rm\" \"--user\" \"1000:1000\" \"-e\" \"CARGO_HOME=/cargo\" \"-e\" \"CARGO_TARGET_DIR=/target\" \"-e\" \"USER=cm\" \"-e\" \"XARGO_HOME=/xargo\" \"-v\" \"/home/cm/.xargo:/xargo\" \"-v\" \"/home/cm/.cargo:/cargo\" \"-v\" \"/home/cm/workspace/Mine/Rust-Cookbook/Chapter09/cross-compile:/project:ro\" \"-v\" \"/home/cm/.rustup/toolchains/stable-x86_64-unknown-linux-gnu:/rust:ro\" \"-v\" \"/home/cm/workspace/Mine/Rust-Cookbook/Chapter09/cross-compile/target:/target\" \"-w\" \"/project\" \"-it\" \"japaric/armv7-unknown-linux-gnueabihf:v0.1.14\" \"sh\" \"-c\" \"PATH=$PATH:/rust/bin \\\"cargo\\\" \\\"build\\\" \\\"--target\\\" \\\"armv7-unknown-linux-gnueabihf\\\" \\\"-v\\\"\"\n   Compiling cross-compile v0.1.0 (/project)\n     Running `rustc --edition=2018 --crate-name cross_compile src/main.rs --color always --crate-type bin --emit=dep-info,link -C debuginfo=2 -C metadata=a41129d8970184cc -C extra-filename=-a41129d8970184cc --out-dir /target/armv7-unknown-linux-gnueabihf/debug/deps --target armv7-unknown-linux-gnueabihf -C linker=arm-linux-gnueabihf-gcc -C incremental=/target/armv7-unknown-linux-gnueabihf/debug/incremental -L dependency=/target/armv7-unknown-linux-gnueabihf/debug/deps -L dependency=/target/debug/deps`\n    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n```", "```rs\n$ scp target/armv7-unknown-linux-gnueabihf/debug/cross-compile alarm@10.0.0.171:~\ncross-compile 100% 2410KB 10.5MB/s 00:00\n$ ssh alarm@10.0.0.171\nWelcome to Arch Linux ARM\n\n     Website: http://archlinuxarm.org\n       Forum: http://archlinuxarm.org/forum\n         IRC: #archlinux-arm on irc.Freenode.net\nLast login: Sun Jul 28 09:07:57 2019 from 10.0.0.46\n$ ./cross-compile \nHello, world!\nCompiled for ARM\n```", "```rs\nmod sensor;\n\nuse sensor::{Bmx42Device, RawI2CDeviceMock, Thermometer};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let mut device = Bmx42Device::new(RawI2CDeviceMock::\n     new(\"/dev/i2c-1\".into(), 0x5f)).unwrap();\n    let pause = Duration::from_secs(1);\n    loop {\n        println!(\"Current temperature {} °C\", \n         device.temp_celsius().unwrap());\n        sleep(pause);\n    }\n}\n```", "```rs\nuse std::io;\nuse rand::prelude::*;\n\npub trait Thermometer {\n    fn temp_celsius(&mut self) -> Result<f32>;\n}\n\ntype Result<T> = std::result::Result<T, io::Error>;\n```", "```rs\n#[allow(dead_code)]\npub struct RawI2CDeviceMock {\n    path: String,\n    device_id: u8,\n}\n\nimpl RawI2CDeviceMock {\n    pub fn new(path: String, device_id: u8) -> RawI2CDeviceMock {\n        RawI2CDeviceMock {\n            path: path,\n            device_id: device_id,\n        }\n    }\n\n    pub fn read(&self, register: u8) -> Result<u8> {\n        let register = register as usize;\n        if register == Register::Calib0 as usize {\n            Ok(1_u8)\n        } else { // register is the data register\n            Ok(random::<u8>())\n        }\n    }\n}\n```", "```rs\nenum Register {\n    Calib0 = 0x00,\n    Data = 0x01,\n}\n\npub struct Bmx42Device {\n    raw: RawI2CDeviceMock,\n    calibration: u8,\n}\n\nimpl Bmx42Device {\n    pub fn new(device: RawI2CDeviceMock) -> Result<Bmx42Device> {\n        let calib = device.read(Register::Calib0 as u8)?;\n        Ok(Bmx42Device {\n            raw: device,\n            calibration: calib\n        })\n    }\n}\n```", "```rs\nimpl Thermometer for Bmx42Device {\n    fn temp_celsius(&mut self) -> Result<f32> {\n        let raw_temp = self.raw.read(Register::Data as u8)?;\n        Ok(((raw_temp as i8) << (self.calibration as i8)) as f32 / \n        10.0)\n    }\n}\n```", "```rs\n[dependencies]\nrand = \"0.5\"\n```", "```rs\n$  cargo run\n   Compiling libc v0.2.60\n   Compiling rand_core v0.4.0\n   Compiling rand_core v0.3.1\n   Compiling rand v0.5.6\n   Compiling i2cdevice-drivers v0.1.0 (Rust-\n   Cookbook/Chapter09/i2cdevice-drivers)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.95s\n     Running `target/debug/i2cdevice-drivers`\nCurrent temperature -9.4 °C\nCurrent temperature 0.8 °C\nCurrent temperature -1.2 °C\nCurrent temperature 4 °C\nCurrent temperature -3 °C\nCurrent temperature 0.4 °C\nCurrent temperature 5.4 °C\nCurrent temperature 11.6 °C\nCurrent temperature -5.8 °C\nCurrent temperature 0.6 °C\n^C⏎\n```", "```rs\nuse std::io;\nuse rand::prelude::*;\n\ntype Result<T> = std::result::Result<T, io::Error>;\n\npub trait Thermometer {\n    fn temp_celsius(&mut self) -> Result<f32>;\n}\n\nenum Register {\n    Calib0 = 0x00,\n    Data = 0x01,\n}\n```", "```rs\n#[allow(dead_code)]\npub struct RawI2CDeviceMock {\n    path: String,\n    device_id: u8,\n}\n\nimpl RawI2CDeviceMock {\n    pub fn new(path: String, device_id: u8) -> RawI2CDeviceMock {\n        RawI2CDeviceMock {\n            path: path,\n            device_id: device_id,\n        }\n    }\n\n    pub fn read(&self, register: u8) -> Result<u8> {\n        let register = register as usize;\n        if register == Register::Calib0 as usize {\n            Ok(1_u8)\n        } else { // register is the data register\n            Ok(random::<u8>())\n        }\n    }\n}\n```", "```rs\npub struct Bmx42Device {\n    raw: RawI2CDeviceMock,\n    calibration: u8,\n}\n\nimpl Bmx42Device {\n    pub fn new(device: RawI2CDeviceMock) -> Result<Bmx42Device> {\n        let calib = device.read(Register::Calib0 as u8)?;\n        Ok(Bmx42Device {\n            raw: device,\n            calibration: calib\n        })\n    }\n}\n```", "```rs\nimpl Thermometer for Bmx42Device {\n    fn temp_celsius(&mut self) -> Result<f32> {\n        let raw_temp = self.raw.read(Register::Data as u8)?;\n        // converts the result into something usable; from the \n        // specification\n        Ok(((raw_temp as i8) << (self.calibration as i8)) as f32 / \n         10.0)\n    }\n}\n```", "```rs\nmod sensor;\nuse tokio::prelude::*;\nuse tokio::timer::Interval;\n\nuse sensor::{Bmx42Device, RawI2CDeviceMock, Thermometer};\nuse std::time::{Duration, UNIX_EPOCH, SystemTime, Instant};\nuse std::thread;\n\nuse std::sync::mpsc::channel;\n\nfn current_timestamp_ms() -> u64 {\n    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()\n}\n\n#[derive(Debug)]\nstruct Reading {\n    timestamp: u64,\n    value: f32\n}\n```", "```rs\n\nfn main() {\n    let mut device = Bmx42Device::new(RawI2CDeviceMock\n     ::new(\"/dev/i2c-1\".into(), 0x5f)).unwrap();\n\n    let (sx, rx) = channel();\n\n    thread::spawn(move || {\n        while let Ok(reading) = rx.recv() {\n\n            // or batch and save/send to somewhere\n            println!(\"{:?}\", reading);\n        }\n    });\n    let task = Interval::new(Instant::now(), Duration\n     ::from_secs(1))\n        .take(5)\n        .for_each(move |_instant| {\n            let sx = sx.clone();\n            let temp = device.temp_celsius().unwrap();\n            let _ = sx.send(Reading {\n                timestamp: current_timestamp_ms(),\n                value: temp\n            });\n            Ok(())\n        })\n        .map_err(|e| panic!(\"interval errored; err={:?}\", e));\n\n    tokio::run(task);\n}\n```", "```rs\n[dependencies]\ntokio = \"0.1\"\ntokio-timer = \"0.2\"\nrand = \"0.5\"\n```", "```rs\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.04s\n     Running `target/debug/reading-hardware`\nReading { timestamp: 1564762734, value: -2.6 }\nReading { timestamp: 1564762735, value: 6.6 }\nReading { timestamp: 1564762736, value: -3.8 }\nReading { timestamp: 1564762737, value: 11.2 }\nReading { timestamp: 1564762738, value: 2.4 }\n```"]