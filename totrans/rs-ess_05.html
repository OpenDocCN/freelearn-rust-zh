<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Generalizing Code with Higher-order Functions and Parametrization</h1></div></div></div><p>Now that we have the data structures and control constructs in place, we can start to discover the functional and object-oriented features of Rust, which make it a really expressive language. We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Higher-order functions and closures</li><li class="listitem">Iterators</li><li class="listitem">Consumers and adapters</li><li class="listitem">Generic data structures and functions</li><li class="listitem">Error handling</li><li class="listitem">Methods on structs</li><li class="listitem">Traits</li><li class="listitem">Using trait constraints</li><li class="listitem">Built-in traits and operator overloading</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Higher-order functions and closures</h1></div></div></div><p>By now, we know how to <a id="id150" class="indexterm"/>use functions, as shown in the following example where<a id="id151" class="indexterm"/> the <code class="literal">triples</code> function changes our <code class="literal">strength</code>, but only if the return value of <code class="literal">triples</code> is assigned to <code class="literal">strength</code>:</p><div><pre class="programlisting">// see code in Chapter 5/code/higher_functions.rs
let mut strength = 26;
println!("My tripled strength equals {}",triples(strength)); // 78
println!("My strength is still {}", strength); // 26
strength = triples(strength);
println!("My strength is now {}", strength); // 78</pre></div><p>With <code class="literal">triples</code> defined as <code class="literal">fn triples(s: i32) -&gt; i32 { 3 * s }</code>, <code class="literal">s</code> represents strength.</p><p>Suppose our player<a id="id152" class="indexterm"/> smashes an amazing power stone so that his strength is tripled and the resulting strength is tripled again, so we could write <code class="literal">triples(triples(s))</code>. We can also write a function to do this, but it would be even more general to have a function, let's call it again, that could apply a certain function <code class="literal">f</code>, of the <code class="literal">F</code> type upon its result, enabling us to create all kinds of new game tricks, as follows:</p><div><pre class="programlisting">fn again (f: F, s: i32) -&gt; i32  { f(f(s)) }</pre></div><p>However, this is not enough information for Rust; the compiler will ask us to explain what the <code class="literal">F</code> type is. We can make this clear by adding <code class="literal">&lt;F: Fn(i32) -&gt; i32&gt;</code> before the parameter list:</p><div><pre class="programlisting">
<strong>fn again&lt;F: Fn(i32) -&gt; i32&gt;(f: F , s: i32) -&gt; i32 {</strong>
<strong>      f(f(s))</strong>
<strong>}</strong>
</pre></div><p>The expression between <code class="literal">&lt; &gt;</code> (angle brackets) tells us that <code class="literal">F</code> is a function, <code class="literal">Fn</code> ,that takes <code class="literal">i32</code> as a parameter and returns an <code class="literal">i32</code> function.</p><p>Now look at the definition of triples. that's exactly what this function does (triples has the signature of type <code class="literal">F</code>), so we can call again with triples as the first parameter:</p><div><pre class="programlisting">
<strong>strength = again(triples, strength);</strong>
println!("I got so lucky to turn my strength into {}", strength); // 702 (= 3 * 3 * 78)</pre></div><p>The <code class="literal">again</code> function is a <em>higher-order function</em>, which means that it is a function that takes another function (or more than one function) as a parameter.</p><p>Often, simple functions such as <code class="literal">triples</code> are not even defined as a named function:</p><div><pre class="programlisting">  strength = 78;
<strong>  let triples = |n| { 3 * n };</strong>
  strength = again(triples, strength);
  println!("My strength is now {}", strength); // 702</pre></div><p>Here, we have an <em>anonymous function</em> or <em>closure</em>, <code class="literal">|n| { 3 * n }</code>, that takes an <code class="literal">n</code> parameter and returns its tripled value. The <code class="literal">||</code> (vertical bars) mark the start of a closure, and they contain the parameters that are passed to it (when there are no parameters, it is written as <code class="literal">||</code>). There is no need to indicate the type of the parameters or the return value as a closure can infer their types from the context in which it is called.</p><p>The <code class="literal">triples</code> function is only a binding to a name so that we can refer to the closure in another code. We can even leave that name out and put the closure inline, as follows:</p><div><pre class="programlisting">  strength = 78;
<strong>  strength = again(|n| { 3 * n }, strength);</strong>
  println!("My strength is now {}", strength); // 702</pre></div><p>The closure is called with the <code class="literal">n</code> parameter that takes the value of <code class="literal">s</code>, which is a copy of <code class="literal">strength</code>. The braces can also be left out to simplify the closure as follows:</p><div><pre class="programlisting">strength = again(|n| 3 * n , strength);</pre></div><p>So, why is it called a <a id="id153" class="indexterm"/>closure? This becomes more apparent in the following example:</p><div><pre class="programlisting">   let x: i32 = 42;
   let print_add = |s| { 
      println!("x is {}", x); 
      x + s
    }; 
   let res = print_add(strength);
   // here the closure is called and "x is 42" is printed
   assert_eq!(res, 744); // 42 + 702</pre></div><p>The <code class="literal">print_add()closure</code> has one argument and returns a 32-bit integer. The <code class="literal">print_add</code> closure knows the value of <code class="literal">x</code> and all other variables that are available in its surrounding scope—it <em>closes</em> them in. A closure with no arguments has the empty parameter list, <code class="literal">||</code>.</p><p>There is also a special kind of closure called a moving closure, which is indicated by the <code class="literal">move</code> keyword. A normal closure only needs a reference to the variables that it encloses, but a moving closure takes ownership of all the enclosing variables.</p><p>The preceding example would be written with a moving closure as follows:</p><div><pre class="programlisting">    let m: i32 = 42;
<strong>    let print_add_move = move |s| { </strong>
      println!("m is {}", m); 
      m + s
    };
    let res = print_add_move(strength); // strength == 702
    assert_eq!(res, 744); // 42 + 702</pre></div><p>Moving closures are mostly used when a program works with different concurrent threads (You can see this in <a class="link" title="Chapter 8. Concurrency and Parallelism" href="part0065.xhtml#aid-1TVKI2">Chapter 8</a>, <em>Concurrency and Parallelism</em>).</p><p>As you will see in the following sections, higher-order functions and closures are used throughout Rust because they can make code much more concise and readable, and they are useful to generalize a computation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Iterators</h1></div></div></div><p>An <code class="literal">Iterator</code> is an object that returns<a id="id154" class="indexterm"/> the items of a collection in sequence, from the first item to the last one. To return the following item, it uses a <code class="literal">next()</code> method. Here, we have an opportunity to use <code class="literal">Option</code>: because an iterator can have no more values at a certain <code class="literal">next()</code> call, <code class="literal">next()</code> returns <code class="literal">Option</code>: a <code class="literal">Some(value)</code> when there is a value, and <code class="literal">None</code> when there are no more values.</p><p>The simplest object that has this behavior is a range of numbers, <code class="literal">0...n</code>. Every time we used a <code class="literal">for</code> loop, such as for <code class="literal">i</code> in <code class="literal">0...n</code>, the underlying iterator mechanism was put to work. Let's see an example:</p><div><pre class="programlisting">// see code in Chapter 5/code/iterators.rs
    let mut rng = 0..7;
<strong>    println!("&gt; {:?}", rng.next()); // prints Some(0)</strong>
    println!("&gt; {:?}", rng.next()); // prints Some(1)
    for n in rng {
      print!("{} - ", n);
    } // prints 2 - 3 - 4 - 5 - 6 -</pre></div><p>Here, we see <code class="literal">next()</code> at work, which produces 0, 1, and so on; the <code class="literal">for</code> loop continues until the end.</p><p>Perform the following exercise:</p><p>In the previous example, we saw that <code class="literal">next()</code> returns a <code class="literal">Some</code> object, a variant of the <code class="literal">Option</code> type (see the <em>Result and Option</em> section of <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <em>Structuring Data and Matching Patterns</em>). Write an endless loop over <code class="literal">rng</code> with <code class="literal">next()</code> and see what happens. How would you break the endless loop? Use a match on the <code class="literal">Option</code> value. (for an example, see <code class="literal">Chapter 5/exercises/range_next.rs</code>). In fact, the <code class="literal">for</code> loop that we saw right before this exercise is syntactic sugar for this <code class="literal">loop – match</code> construct.</p><p>Iterators are also the preferred way to loop over arrays or slices. Let's revisit the aliens array, <code class="literal">let aliens = ["Cherfer", "Fynock", "Shirack", "Zuxu"];"</code>, from <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <em> Structuring Data and Matching Patterns</em>. Instead of using the index to show all the items one by one, let's do it the iterator way with the <code class="literal">iter()</code> function:</p><div><pre class="programlisting">
<strong>for alien in aliens.iter() {</strong>
<strong>  print!("{} / ", alien)</strong>
<strong>  // process alien</strong>
<strong>}</strong>
</pre></div><p>Which prints out: <code class="literal">Cherfer / Fynock / Shirack / Zuxu /</code>. The alien variable is of the <code class="literal">&amp;str</code> type, which is a reference to each of the items in turn. (Technically, it is of the <code class="literal">&amp;&amp;str</code> type here because the items themselves are of the <code class="literal">&amp;str</code> type, but this is not relevant to the point being made here.) This is much more performant and safe because Rust doesn't have to do index-bounds checking, we're always certain to move within the memory of the array.</p><p>An even shorter way is to write:</p><div><pre class="programlisting">for alien in &amp;aliens {
  print!("{} / ", alien)
}</pre></div><p>An alien array is also of the <code class="literal">&amp;str</code> type, but<a id="id155" class="indexterm"/> the <code class="literal">print!</code> macro automatically dereferences this. If you want them to print out in the reverse order, do <code class="literal">aliens.iter().rev()</code>. The other iterators that we encountered in the previous chapter were the <code class="literal">chars()</code> and <code class="literal">split()</code> methods on <code class="literal">Strings</code>.</p><p>Iterators are lazy by nature; they do not generate values unless asked, and we ask them by calling the <code class="literal">next()</code> method or applying <code class="literal">for</code> in the loop. This makes sense as we don't want to allocate one million integers in the following binding:</p><div><pre class="programlisting">let rng = 0..1000_000; // _ makes the number 1000000 more readable</pre></div><p>We want to allocate memory only when we need it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Consumers and adapters</h1></div></div></div><p>Now, we will see some<a id="id156" class="indexterm"/> examples that show why iterators are so useful. Iterators are lazy and have to be activated by invoking a <em>consumer</em> to start using the values. Let's start with a range of the numbers from 0 to 999. To make this into a vector, we apply the <code class="literal">collect()</code> consumer:</p><div><pre class="programlisting">// see code in Chapter 5/code/adapters_consumers.rs
let rng = 0..1000;
<strong>let rngvec = rng.collect::&lt;Vec&lt;i32&gt;&gt;();</strong>
println!("{:?}", rngvec);</pre></div><p>Which prints out the range (we shortened the output with ...): [0, 1, 2, 3, 4, ... , 999]</p><p>The <code class="literal">collect()</code> loops through the<a id="id157" class="indexterm"/> entire iterator and collects all of the elements into a container, here in the <code class="literal">Vec&lt;i32&gt;</code> type. That container does not have to be an iterator. Notice that we indicate the item type of the vector with <code class="literal">Vec&lt;i32&gt;</code>, but we could have also written it as <code class="literal">Vec&lt;_&gt;</code>. The <code class="literal">collect::&lt;Vec&lt;i32&gt;&gt;()</code> notation is new; it indicates that collect is a parametrized method that can work with generic types, as you will see in the next section. That line could also have been written as: </p><div><pre class="programlisting">let rngvec: Vec&lt;i32&gt; = rng.collect();</pre></div><p>The <code class="literal">find()</code> consumer gets the first value of the iterator that makes its condition (here, <code class="literal">&gt;= 42</code>) true and returns it as an <code class="literal">Option</code> function, for example:</p><div><pre class="programlisting">  let forty_two = rng.find(|n| *n &gt;= 42);
<strong>  println!("{:?}", forty_two);  // prints out Some(42)</strong>
</pre></div><p>The value of <code class="literal">find</code> is an <code class="literal">Option</code> function because the condition could be false for all items and then it would return a <code class="literal">None</code> value. The condition is wrapped in a <code class="literal">|n| *n &gt;= 42</code> closure, which is applied on every item of the iterator through an <code class="literal">n</code> reference; this is why we have to dereference <code class="literal">*n</code> to get the value.</p><p>Suppose we only want even numbers in our range, producing a new range by testing a closure condition on each item. This can be done with the <code class="literal">filter()</code> function, which is an adapter because it produces a new iterator from the old one. Its result can be collected just like any iterator:</p><div><pre class="programlisting">  let rng_even = rng.filter(|n| is_even(*n))
<strong>                   .collect::&lt;Vec&lt;i32&gt;&gt;();</strong>
  println!("{:?}", rng_even);</pre></div><p>Here, <code class="literal">is_even</code> is the following function:</p><div><pre class="programlisting">fn is_even(n: i32) -&gt; bool {
  n % 2 == 0
}</pre></div><p>This prints out: <code class="literal">[0, 2, 4, ..., 996, 998]</code> showing that odd integers are filtered out.</p><p>Notice how we can <a id="id158" class="indexterm"/>chain our consumers/adapters by just applying <code class="literal">collect()</code> on the <a id="id159" class="indexterm"/>result of <code class="literal">filter()</code> with <code class="literal">.collect()</code>.</p><p>Now, what would we do if we wanted to cube <code class="literal">(n * n * n)</code> with every item in the resulting iterator? We can produce a new range by applying a closure to each item in it with the <code class="literal">map()</code> function:</p><div><pre class="programlisting">  let rng_even_pow3 = rng.filter(|n| is_even(*n))
<strong>                         .map(|n| n * n * n)</strong>
                         .collect::&lt;Vec&lt;i32&gt;&gt;();
  println!("{:?}", rng_even_pow3);</pre></div><p>Which now prints out: <code class="literal">[0, 8, 64, ..., 988047936, 994011992]</code>.</p><p>If you only want the first five results, insert a <code class="literal">take(5)</code> adapter before the <code class="literal">collect</code> function. The resulting vector will then contain <code class="literal">[0, 8, 64, 216, 512]</code>.</p><p>So, if you see the warning, <code class="literal">unused result which must be used: iterator adaptors are lazy and do nothing unless consumed message while compiling</code>, you know what to do—call a consumer!</p><p>To see all the consumers and adapters, consult the documentation of the <code class="literal">std::iter</code> module.</p><p>Perform the following exercise:</p><p>Another very powerful consumer is the <code class="literal">fold()</code> function. The following example calculates the sum of the first hundred integers. It starts with a base value 0, which is also the initial value of the sum accumulator, and then iterates and adds every <code class="literal">n</code> item to sum:</p><div><pre class="programlisting">let sum = (0..101).fold(0, |sum, n| sum + n);
println!("{}", sum); // prints out 5050</pre></div><p>Now, calculate the product of all the cubes of the integers in the range from 1 to 6. The result should be 1,728,000, but look out for the base value! As the second exercise, subtract all the items from the <code class="literal">[1, 9, 2, 3, 14, 12]</code> array, starting from 0 (that is, 0, 1, 9, 2, and so on). This should result in <code class="literal">41</code>. (As a hint, remember that an iterator item is a reference; for some example code, refer to <code class="literal">Chapter 5/exercises/fold.rs</code>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Generic data structures and functions</h1></div></div></div><p>Genericity is the capacity to<a id="id160" class="indexterm"/> write code once, without or partly specified types, so<a id="id161" class="indexterm"/> that the code can be used for many different types. Rust has this capacity in abundance and applies it for both data structures and functions.</p><p>A composite data structure<a id="id162" class="indexterm"/> is generic if the type of its items can be of a general <code class="literal">&lt;T&gt;</code> type. <code class="literal">T</code> can be an <code class="literal">i32</code>, an <code class="literal">f64</code>, a <code class="literal">String</code>, or a <code class="literal">struct</code> type such as <code class="literal">Person</code> that we coded ourselves. So, we can have not only <code class="literal">Vec&lt;f64&gt;</code> but also <code class="literal">Vec&lt;Person&gt;</code>. If you make <code class="literal">T</code> a concrete type, then you must substitute <code class="literal">T</code> with that type everywhere <code class="literal">T</code> appears in the definition of the data structure.</p><p>Our data structure can be parametrized with a generic <code class="literal">&lt;T&gt;</code> type, so it has multiple concrete definitions—it is polymorphic. Rust makes extensive use of this concept, which we already encountered in <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <em>Structuring Data and Matching Patterns</em> when we talked about arrays, vectors, slices, and the <code class="literal">Result</code> and <code class="literal">Option</code> types.</p><p>Suppose you want to define a struct with two fields, first and second, but you want to keep the type of these fields generic. We can define this as follows:</p><div><pre class="programlisting">// see code in Chapter 5/code/generics.rs
<strong>struct Pair&lt;T&gt; {</strong>
<strong>    first: T,</strong>
<strong>    second: T,</strong>
<strong>}</strong>
</pre></div><p>We can now define a pair of magic numbers, or a pair of magicians, or whatever we want, as follows:</p><div><pre class="programlisting">
<strong>let magic_pair: Pair&lt;u32&gt; = Pair { first: 7, second: 42 };</strong>
let pair_of_magicians: Pair&lt;&amp;str&gt; = Pair { first: "Gandalf", second: "Sauron" };</pre></div><p>What if we wanted to write functions that work with generic data structures? They would also have to be generic, right? As a simple example, how would we write a function that returns the second item of a pair? We can do it as follows:</p><div><pre class="programlisting">
<strong>fn second&lt;T&gt;(pair: Pair&lt;T&gt;) {</strong>
<strong>  pair.second;</strong>
}</pre></div><p>We could call it as <code class="literal">let a = second(magic_pair);</code> producing <code class="literal">42</code>.</p><p>Note the <code class="literal">&lt;T&gt;</code> character right after the function name; this is how generic functions are declared.</p><p>Let's now investigate why <code class="literal">Option</code> and <code class="literal">Result</code> are so powerful. Here is the definition of the <code class="literal">Option</code> type again:</p><div><pre class="programlisting">enum Option&lt;T&gt; {
    Some(T),
    None
}</pre></div><p>From this, we can define<a id="id163" class="indexterm"/> multiple concrete types as follows:</p><div><pre class="programlisting">let x: Option&lt;i8&gt; = Some(5);
let pi: Option&lt;f64&gt; = Some(3.14159265359);
let none: Option&lt;f64&gt; = None;
let none2 = None::&lt;f64&gt;;
let name: Option&lt;&amp;str&gt; = Some("Joyce");</pre></div><p>When the type<a id="id164" class="indexterm"/> does not correspond with the value, a mismatched types error occurs, similar to that in <code class="literal">let magic: Option&lt;f32&gt; = Some(42)</code>.</p><p>We can define a <code class="literal">Person</code> struct as follows:</p><div><pre class="programlisting">struct Person {
  name: &amp;'static str,
  id:   i32
}</pre></div><p>We can also define a few <code class="literal">Person</code> objects as follows:</p><div><pre class="programlisting">let p1 = Person{ name: "James Bond", id: 7 };
let p2 = Person{ name: "Vin Diesel", id: 12 };
let p3 = Person{ name: "Robin Hood", id: 42 };</pre></div><p>Then, using these, we can make <code class="literal">Option</code> or a vector for <code class="literal">Person</code>:</p><div><pre class="programlisting">let op1: Option&lt;Person&gt; = Some(p1);
let pvec: Vec&lt;Person&gt; = vec![p2, p3];</pre></div><p>You should use the <code class="literal">Option</code> type in a situation where you expect to get a value, but there is a possibility that no value will be given. A typical scenario would be user input.</p><p>Somewhat related is the <code class="literal">Result</code> type that we first encountered in the <em>Result and Option</em> section of <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <em>Structuring Data and Matching Patterns</em>. This is used when a computation should return a result, but it can also return an error if something goes wrong. Result is defined with two generic types—<code class="literal">T</code> and <code class="literal">E</code>—as follows:</p><div><pre class="programlisting">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}</pre></div><p>It again shows Rust's<a id="id165" class="indexterm"/> commitment to be on the safe side; if it's <code class="literal">Ok</code>, it will give back a value of the <code class="literal">T</code> type, if there is a problem, then it will give back the error that will be a value of the <code class="literal">E</code> type (which is usually an error message string). So, we could read <a id="id166" class="indexterm"/>them also as <code class="literal">Ok(what)</code> and <code class="literal">Err(why)</code>, where <code class="literal">what</code> has the <code class="literal">T</code> type and <code class="literal">why</code> has the <code class="literal">E</code> type.</p><p>So, why are Option and Result killer features of Rust? Remember from <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <em>Structuring Data and Matching Patterns</em> in the section <em>Result and Option</em> how we used <code class="literal">Option</code> when getting a number input? Here, it is given again:</p><div><pre class="programlisting">let input_num: Result&lt;u32, _&gt; = buf.trim().parse();</pre></div><p>In other languages such as Java or C#, parsing the input to a number could result in an exception (when the input contains non-numeric characters or when it has nothing or null), and you would have to use a resource heavy <code class="literal">try/catch</code> to construct to deal with it.</p><p>In Rust, the result of <code class="literal">parse()</code> is a Result, and we just test the <code class="literal">Result</code> return value with a <code class="literal">match</code>, which is a much simpler mechanism:</p><div><pre class="programlisting">
<strong>match input_num {</strong>
<strong>   Ok(num) =&gt; println!("{}", num),</strong>
<strong>   Err(ex) =&gt; println!("Please input an integer number! {}", ex)</strong>
};</pre></div><p>Here is another example of how we can use <code class="literal">Result</code> to return an error condition. We calculate the square root of a floating point number with the <code class="literal">std::num::Float::sqrt()</code> function:</p><div><pre class="programlisting">fn sqroot(r: f32) -&gt; Result&lt;f32, String&gt; {
  if r &lt; 0.0 { 
    return Err("Number cannot be negative!".to_string()); 
  }
  Ok(Float::sqrt(r))
}</pre></div><p>We guard against taking the square root of a negative number (which would give NaN short for Not a Number) by returning an <code class="literal">Err</code> value.</p><div><pre class="programlisting">let m = sqroot(42.0);</pre></div><p>This prints out: <code class="literal">The square root of 42 is 6.480741</code>.</p><p>In the calling code, we use our trusted pattern match mechanism to distinguish between the two cases:</p><div><pre class="programlisting">match m {
   Ok(sq) =&gt; println!("The square root of 42 is {}", sq),
   Err(str) =&gt; println!("{}", str)
}</pre></div><p>With <code class="literal">let m = sqroot(-5.0);</code>, the <a id="id167" class="indexterm"/>error message is printed as <code class="literal">Number cannot be negative!</code>.</p><div><h3 class="title"><a id="note03"/>Note</h3><p>The use of match for both <code class="literal">Option</code> and <code class="literal">Result</code> values ensures that no null values or errors can propagate through your code, which leaves no room for null pointer runtime errors or other<a id="id168" class="indexterm"/> exceptions to crash your program.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Error handling</h1></div></div></div><p>A Rust program must be maximally prepared to<a id="id169" class="indexterm"/> handle unforeseen errors, but unexpected things can always happen, such as the division of an integer by zero:</p><div><pre class="programlisting">// see code in Chapter 5/code/errors.rs
let x = 3;
let y = 0;
x / y; </pre></div><p>When this happens, the program stops with the following message: <code class="literal">thread '&lt;main&gt;' panicked at 'attempted to divide by zero'</code>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Panics</h2></div></div></div><p>A situation could<a id="id170" class="indexterm"/> occur that is so bad (like when dividing by zero) that it is no longer <a id="id171" class="indexterm"/>useful to continue running the program, that is, we cannot recover from the error. In this case, we can invoke the <code class="literal">panic!("message")</code> macro, which will release all the resources owned by the thread, report the message, and then make the program exit. We could improve the previous code as follows:</p><div><pre class="programlisting">
<strong>if (y == 0) { panic!("Division by 0 occurred, exiting"); }</strong>
println!("{}", div(x, y));</pre></div><p>Here, <code class="literal">div</code> is the following function:</p><div><pre class="programlisting">fn div(x: i32, y: i32) -&gt; f32 {
  (x / y) as f32
}</pre></div><p>A number of other macros such as the <code class="literal">assert!</code> family can also be used to signal such unwanted conditions:</p><div><pre class="programlisting">assert!(x == 5); //thread &lt;main&gt; panicked at assertion failed: x == 5
assert!( x == 5, "x is not equal to 5!");
// thread &lt;main&gt; panicked at "x is not equal to 5!"
assert_eq!(x, 5); // thread '&lt;main&gt;' panicked at 'assertion failed: (left: `3`, right: `5`)',</pre></div><p>When the condition is<a id="id172" class="indexterm"/> not true, they result in a panic situation and exit. The error <a id="id173" class="indexterm"/>message that is given as the second parameter of <code class="literal">assert!</code> will be printed out if it is present, otherwise the general message, <code class="literal">assertion failed</code>, will be given. The <code class="literal">assert!</code> function is mostly useful to test for pre- and post-conditions.</p><p>Portions of code that would not be normally executed can contain the <code class="literal">unreachable!</code> macro, which will panic when it is executed:</p><div><pre class="programlisting">
<strong>unreachable!(); </strong>
<strong>// thread '&lt;main&gt;' panicked at 'internal error: entered unreachable code'</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec24"/>Failures</h2></div></div></div><p>In most cases, we would like to <a id="id174" class="indexterm"/>attempt to recover from the error and let the program continue. Fortunately, we have already seen the basic handling techniques to do just <a id="id175" class="indexterm"/>this in the <em>Result and Option</em> section of <a class="link" title="Chapter 4. Structuring Data and Matching Patterns" href="part0038.xhtml#aid-147LC2">Chapter 4</a>, <em>Structuring Data and Matching Patterns</em> and the <em>Generic data structures and functions</em> section of this chapter.</p><p>The <code class="literal">Option&lt;T&gt;</code> enum can be used when we expect a value; at this point, a <code class="literal">Some(T)</code> enum is given and a <code class="literal">None</code> value is returned when there was no value or in case of failure. In this way, Rust forces <em>nothingness</em> to appear in a clear and syntactically identifiable form, leaving no room for null pointer runtime errors.</p><p>The <code class="literal">Result&lt;T, E&gt;</code> enum can be used to return an <code class="literal">Ok(T)</code> value in the normal (success) case and an <code class="literal">Err(E)</code> value in the failure case, containing information about the error. In the examples in the previous section, we used Result to safely read a value from the keyboard and make a safe function to calculate the square root of a number.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Methods on structs</h1></div></div></div><p>Now, we'll see how Rust <a id="id176" class="indexterm"/>caters for more object-oriented developers who are used to the <code class="literal">object.method()</code> type of notation instead of <code class="literal">function(object)</code>. In Rust, we can define <em>methods</em> on a struct, which pretty much compares to the traditional <code class="literal">class</code> concept.</p><p>Suppose we are building a game in which the action takes place on a planet in a distant solar system that is inhabited by hostile aliens. For this game, let's define an <code class="literal">Alien</code> struct as follows:</p><div><pre class="programlisting">// see code in Chapter 5/code/methods.rs
struct Alien {
  health: u32,
  damage: u32
}</pre></div><p>Here, <code class="literal">health</code> is the alien's condition, and <code class="literal">damage</code> is the amount your health is decreased when it attacks. We can make an alien as follows:</p><div><pre class="programlisting">let mut bork = Alien{ health: 100, damage: 5 }; </pre></div><p>The <code class="literal">health</code> parameter cannot be more than <code class="literal">100</code>, but we cannot impose this constraint when we make a struct instance. The solution is to define a <code class="literal">new</code> method for aliens where we can test the value:</p><div><pre class="programlisting">
<strong>impl Alien {</strong>
<strong>  fn new(mut h: u32, d: u32) -&gt; Alien {</strong>
<strong>    // constraints:</strong>
<strong>    if h &gt; 100 { h = 100; }</strong>
<strong>    Alien { health: h, damage: d }</strong>
<strong>  }</strong>
<strong>}</strong>
</pre></div><p>We can then construct a new <code class="literal">Alien</code> array as follows:</p><div><pre class="programlisting">
<strong>let mut berserk = Alien::new(150, 15);</strong>
</pre></div><p>We define the <code class="literal">new</code> method (and all other methods) inside an <code class="literal">impl Alien</code> block, which is separate from the <code class="literal">Alien</code> struct definition. It returns an <code class="literal">Alien</code> object after all constraints have been applied. We <a id="id177" class="indexterm"/>call it on the <code class="literal">Alien</code> struct itself as <code class="literal">Alien::new()</code>. Since it is a <em>static method</em>, we don't call it on an <code class="literal">Alien</code> instance. Such a new method closely resembles a constructor from object-oriented languages. The fact that it is called <code class="literal">new</code> is merely by convention since we could have called it <code class="literal">create()</code> or <code class="literal">give_birth()</code>. Another static method could be a warning that is given by all aliens:</p><div><pre class="programlisting">  fn warn() -&gt; &amp;'static str {
    "Leave this planet immediately or perish!"
  }</pre></div><p>This can be called as follows:</p><div><pre class="programlisting">
<strong>println!("{}", Alien::warn());</strong>
</pre></div><p>When a specific alien attacks, we can define a method for that alien as follows:</p><div><pre class="programlisting">
<strong>fn attack(&amp;self) {</strong>
  println!("I attack! Your health lowers with {} damage points.", self.damage);
}</pre></div><p>And call it on the alien <code class="literal">berserk</code> as follows: <code class="literal">berserk.attack();</code>. A reference to <code class="literal">berserk</code> (the <code class="literal">Alien</code> object on which the method is invoked) is passed as <code class="literal">&amp;self</code> to the method. In fact, <code class="literal">self</code> is similar to the <code class="literal">self</code> in Python or this in Java or C#. An instance method always has <code class="literal">&amp;self</code> as parameter, in contrast to a static method.</p><p>Here, the object is passed immutably, but what if attacking you also lowers the alien's own health? Let's add a second attack method:</p><div><pre class="programlisting">fn attack(&amp;self) {
  self.health -= 10;
}</pre></div><p>However, Rust rejects this with two compiler errors. First, it says, <code class="literal">cannot assign to immutable field self.health</code>. We can remedy this by passing a mutable reference to <code class="literal">self</code> like this: <code class="literal">fn attack(&amp;mut self)</code>. But now Rust complains, <code class="literal">duplicate definition of value 'attack'</code>. This means that Rust does not allow two methods with the same name; there is no method overloading in Rust. This is because of the way type inference works.</p><p>By changing the name to <code class="literal">attack_and_suffer</code>, we get this:</p><div><pre class="programlisting">fn attack_and_suffer(&amp;mut self, damage_from_other: u32) {
  self.health -= damage_from_other;
}</pre></div><p>After calling <code class="literal">berserk.attack_and_suffer(31);</code>, berserk's health is now 69 (where <code class="literal">31</code> is the number of <a id="id178" class="indexterm"/>damage points inflicted upon berserk by another attacking alien).</p><p>No method overloading means that we can only define one new function (which is optional anyway). We could invent different names for our constructors, which is good from the point of view of code documentation. Otherwise, you could go for what is called the <code class="literal">Builder</code> pattern <a id="id179" class="indexterm"/>on which you can find more information at <a class="ulink" href="http://doc.rust-lang.org/book/method-syntax.html#builder-pattern">http://doc.rust-lang.org/book/method-syntax.html#builder-pattern</a>.</p><div><h3 class="title"><a id="note04"/>Note</h3><p>Note that, in Rust, methods can also be defined on tuples and enums.</p></div><p>Perform the following exercise:</p><p>Complex numbers such as 2 + 5i (i is the square root of -1) have a real part (here 2) and an imaginary part (5); both are floating point numbers. Define a <code class="literal">Complex</code> struct and some methods for it:</p><div><ul class="itemizedlist"><li class="listitem">A <code class="literal">new</code> method to construct a complex number.</li><li class="listitem">A <code class="literal">to_string</code> method that prints a complex number such as 2 + 5i or 2 – 5i (As a hint, use the <code class="literal">format!</code> macro that works in the same way as <code class="literal">println!</code> but returns a <code class="literal">String</code>.)</li><li class="listitem">An <code class="literal">add</code> method to add two complex numbers; this is a new complex number where the real part is the sum of the real parts of the operands and the same is applicable for the imaginary part as well.</li><li class="listitem">A <code class="literal">times_ten</code> method <a id="id180" class="indexterm"/>that changes the object itself by multiplying both parts by 10 (As a hint, think carefully about the method's argument.)</li><li class="listitem">As a bonus, make an <code class="literal">abs</code> method that calculates the absolute value<a id="id181" class="indexterm"/> of a complex number. (go to <a class="ulink" href="http://en.wikipedia.org/wiki/Absolute_value">http://en.wikipedia.org/wiki/Absolute_value</a>.)</li></ul></div><p>Now, test your methods! (for an example code, refer to <code class="literal">Chapter 5/exercises/complex.rs</code>.) Rust defines a <code class="literal">Complex</code> type in crate <code class="literal">num</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Traits</h1></div></div></div><p>What if our game is really <a id="id182" class="indexterm"/>diversely populated? That is, besides aliens, we also have zombies and predators and, needless to say, they all want to attack. Can we abstract their common behavior into something they all share? Of course, in Rust, we say that they have a trait in common, which is analogous to an interface or a super class in other languages. Let's call this trait <code class="literal">Monster</code> and because they all want to attack, the first version could be as follows:</p><div><pre class="programlisting">// see code in Chapter 5/code/traits.rs
<strong>trait Monster {</strong>
<strong>    fn attack(&amp;self);</strong>
<strong>}</strong>
</pre></div><p>A trait only contains a description of methods, that is, their type declarations or signatures, but it has no real implementation. This is logical because zombies, predators, and aliens could each have their own method of attack. So, there is no body of code between <code class="literal">{}</code> after the function signature, but don't forget the <code class="literal">;</code> to close it off.</p><p>When we want to implement the <code class="literal">Monster</code> trait for the <code class="literal">Alien</code> struct, we write the following code:</p><div><pre class="programlisting">
<strong>impl Monster for Alien {</strong>

<strong>}</strong>
</pre></div><p>When we compile this, Rust throws the <code class="literal">not all trait items implemented, missing: 'attack'</code> error. This is nice because Rust reminds us which methods from a trait we have forgotten to implement. The following code would make it pass:</p><div><pre class="programlisting">impl Monster for Alien {
  fn attack(&amp;self) {
    println!("I attack! Your health lowers with {} damage points.", self.damage);
  }
}</pre></div><p>So, the trait implementation for a type must provide the real code, which will be executed when that method is called on an <code class="literal">Alien</code> object. If a Zombie attack is twice as bad, its <code class="literal">Monster</code> implementation could be as follows:</p><div><pre class="programlisting">impl Monster for Zombies {
  fn attack(&amp;self) {
    println!("I bite you! Your health lowers with {} damage points.", 2 * self.damage);
  }
}</pre></div><p>We could add other methods to our trait, such as a <code class="literal">new</code> method, a <code class="literal">noise</code> method, and an <code class="literal">attack_with_sound</code> method:</p><div><pre class="programlisting">trait Monster {
    fn new(hlt: u32, dam: u32) -&gt; Self;
    fn attack(&amp;self);
    fn noise(&amp;self) -&gt; &amp;'static str;
<strong>    fn attacks_with_sound(&amp;self) {</strong>
<strong>      println!("The Monster attacks by making an awkward sound {}", self.noise());</strong>
<strong>    }</strong>
}</pre></div><p>Note that in the <code class="literal">new</code> method, the <a id="id183" class="indexterm"/>resulting object is of the <code class="literal">Self</code> type, which becomes the <code class="literal">Alien</code> or <code class="literal">Zombie</code> implementer type in a real implementation of the trait.</p><p>The functions that appear in a trait are called methods. Methods differ from functions because they have <code class="literal">&amp;self</code> as a parameter; this means that they have the object on which they are invoked as a parameter, for example, <code class="literal">fn noise(&amp;self) -&gt; &amp;'static str</code>. When we call it with <code class="literal">zmb1.noise()</code>, the <code class="literal">zmb1</code> object becomes self.</p><p>A trait can provide default code for a method (similar to the <code class="literal">attack_with_sound</code> method here). The implementer type can choose to take this default code or override it with its own version. Code in a trait method can also call upon other methods in the trait with <code class="literal">self.method()</code>, similar to <code class="literal">attack_with_sound</code> where <code class="literal">self.noise()</code> is called.</p><p>The full implementation of the <code class="literal">Monster</code> trait for the <code class="literal">Zombie</code> type could then be as follows:</p><div><pre class="programlisting">impl Monster for Zombie {
  fn new(mut h: u32, d: u32) -&gt; Zombie {
    // constraints:
    if h &gt; 100 { h = 100; }
    Zombie { health: h, damage: d }
  }
  fn attack(&amp;self) {
    println!("The Zombie bites! Your health lowers with {} damage points.", 2 * self.damage);
  }
  fn noise(&amp;self) -&gt; &amp;'static str {
    "Aaargh!"
  }
}</pre></div><p>Here is a short fragment of our<a id="id184" class="indexterm"/> game scenario:</p><div><pre class="programlisting">let zmb1 = Zombie { health: 75, damage: 15 };
println!("Oh no, I hear: {}", zmb1.noise());
zmb1.attack();</pre></div><p>It prints out: <code class="literal">Oh no, I hear: Aaargh!</code>
</p><p>
<code class="literal">The Zombie bites! Your health lowers with 30 damage points.</code>
</p><p>Traits are not limited to structs; they can be implemented on any type. A type can also implement many different traits. All the different implemented methods are compiled to a version that is specific for their type, so after compilation, there exists, for example, a new method for <code class="literal">Alien</code>, <code class="literal">Zombie</code>, and <code class="literal">Predator</code>.</p><p>Implementing all of the methods in a trait can be tedious work. For example, we probably want to be able to show our creatures in this way:</p><div><pre class="programlisting">println!("{:?}", zmb1);</pre></div><p>Unfortunately, this gives us <code class="literal">the trait 'core::fmt::Debug' is not implemented for the type 'Zombie' compiler</code> error. So, from the message, we can infer that this <code class="literal">{:?}</code> uses a <code class="literal">Debug</code> trait. If we look this up in the docs, we will find that we must implement an <code class="literal">fmt</code> method (specifying a way to format the object). However, the compiler once again helps us here; if we prefix our <code class="literal">Zombie</code> struct definition with the attribute <code class="literal">#[derive(Debug)]</code>, then a default code version is generated automatically:</p><div><pre class="programlisting">
<strong>#[derive(Debug)]</strong>
struct Zombie { health: u32, damage: u32 }</pre></div><p>The <code class="literal">println!("{:?}", zmb1);</code> snippet now shows this: <code class="literal">Zombie { health: 75, damage: 15 }</code>.</p><p>This also works for a<a id="id185" class="indexterm"/> whole list of other traits. (see the <em>Built-in traits and Operator Overloading</em> section in this chapter and <a class="ulink" href="http://rustbyexample.com/trait/derive.html">http://rustbyexample.com/trait/derive.html</a>.)</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Using trait constraints</h1></div></div></div><p>Back in the <em>Generic data structures and functions</em> section, we made a <code class="literal">sqroot</code> function to calculate the square root<a id="id186" class="indexterm"/> of a 32-bit floating point number:</p><div><pre class="programlisting">fn sqroot(r: f32) -&gt; Result&lt;f32, String&gt; {
  if r &lt; 0.0 {
    return Err("Number cannot be negative!".to_string()); 
  }
  Ok(f32::sqrt(r))
}</pre></div><p>What if we want to calculate the square root of an <code class="literal">f64</code> number? It would be very unpractical to make a different version for each type. The first attempt would be to just replace <code class="literal">f32</code> with a generic type <code class="literal">&lt;T&gt;</code>:</p><div><pre class="programlisting">// see code in Chapter 5/code/trait_constraints.rs
extern crate num;
use num::traits::Float;
fn sqroot&lt;T&gt;(r: T) -&gt; Result&lt;T, String&gt; {
  if r &lt; 0.0 { 
    return Err("Number cannot be negative!".to_string()); 
  }
  Ok(num::traits::Float::sqrt(r))
}</pre></div><p>However, Rust would not agree because it doesn't know anything about <code class="literal">T</code>, and it will give multiple errors (<code class="literal">num</code> is an external library which is imported with <code class="literal">extern crate num</code>, see <a class="link" title="Chapter 7. Organizing Code and Macros" href="part0062.xhtml#aid-1R42S2">Chapter 7</a>, <em>Organizing Code and Macros</em>):</p><div><pre class="programlisting">
<strong>binary operation `&lt;` cannot be applied to type `T`</strong>
<strong>the trait `core::marker::Copy` is not implemented for the type `T`</strong>
<strong>the trait `core::num::NumCast` is not implemented for the type `T`</strong>
<strong>…</strong>
</pre></div><p>All the traits that are missing are implemented by the <code class="literal">Float</code> trait. We can assert that <code class="literal">T</code> must implement this trait as <code class="literal">fn sqroot&lt;T: num::traits::Float&gt;</code>. This is called putting a trait constraint or a trait bound on the <code class="literal">T</code> type, and this ensures that the function can use all the methods of the specified trait.</p><p>To be as general as possible, we also use the special indicator for <code class="literal">0</code>, which exists in the <code class="literal">num::traits::Float</code> trait and is named <code class="literal">num::zero();</code> so, our function now becomes as follows:</p><div><pre class="programlisting">fn sqroot&lt;T: num::traits::Float&gt;(r: T) -&gt; Result&lt;T, String&gt; {
  if r &lt; num::zero() { 
    return Err("Number cannot be negative!".to_string()); 
  }
  Ok(num::traits::Float::sqrt(r))
}</pre></div><p>This works for both the following calls:</p><div><pre class="programlisting">println!("The square root of {} is {:?}", 42.0f32, sqroot(42.0f32) );
println!("The square root of {} is {:?}", 42.0f64, sqroot(42.0f64) );</pre></div><p>This gives the output as:</p><div><pre class="programlisting">
<strong>The square root of 42 is Ok(6.480741)</strong>
<strong>The square root of 42 is Ok(6.480741)</strong>
</pre></div><p>However, we will get an error <a id="id187" class="indexterm"/>if we try to call <code class="literal">sqroot</code> on an integer as follows:</p><div><pre class="programlisting">println!("The square root of {} is {:?}", 42, sqroot(42) );</pre></div><p>We get an error, <code class="literal">the trait `std::num::Float` is not implemented for the type `_` [E0277]</code>, because an integer is not a <code class="literal">Float</code> type.</p><p>Our <code class="literal">sqroot</code> function is generic and works for any <code class="literal">Float</code> type. The compiler creates a different executable <code class="literal">sqroot</code> method for any type that it is supposed to work with—in this case, <code class="literal">f32</code> and <code class="literal">f64</code>. Rust applies this mechanism when a function call is polymorphic, that is, when a function can accept arguments of different type. This is called <code class="literal">static</code> dispatch and no runtime overhead is involved. This should be contrasted with how Java interfaces work where the dispatching is done dynamically at runtime by the Java Virtual Machine. However, Rust also has a form of<a id="id188" class="indexterm"/> dynamic dispatch; for more details on this, go to <a class="ulink" href="http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html">http://doc.rust-lang.org/1.0.0-beta/book/static-and-dynamic-dispatch.html</a>.</p><p>Another way to write the same trait constraint is with a <code class="literal">where</code> clause as follows:</p><div><pre class="programlisting">
<strong>fn sqroot&lt;T&gt;(r: T) -&gt; Result&lt;T, String&gt; where T: num::traits::Float { … }</strong>
</pre></div><p>Why does this other form exist? Well, there can be more than one generic <code class="literal">T</code> and <code class="literal">U</code> types. In addition, each type can be constrained to multiple traits (which is indicated by a <code class="literal">+</code> between the traits) such as <code class="literal">Trait1</code>, <code class="literal">Trait2</code>, and so on, like in this fictitious example:</p><div><pre class="programlisting">fn multc&lt;T: Trait1, U: Trait1 + Trait2&gt;(x: T, y: U) {}</pre></div><p>With the <code class="literal">where</code> syntax, this can be made much more readable as follows:</p><div><pre class="programlisting">fn multc&lt;T, U&gt;(x: T, y: U) where T: Trait1, U: Trait1 + Trait2 {}</pre></div><p>Perform the following exercise:</p><p>Define a <code class="literal">Draw</code> trait with a <code class="literal">draw</code> method. Define the <code class="literal">S1</code> struct type with an integer field and the <code class="literal">S2</code> struct type with a float field.</p><p>Implement the <code class="literal">Draw</code> trait for <code class="literal">S1</code> and <code class="literal">S2</code> (draw prints the values and is surrounded by ***).</p><p>Make a generic <code class="literal">draw_object</code> function that takes any object that implements <code class="literal">Draw</code>.</p><p>Test these! (see the example code in <code class="literal">Chapter 5/exercises/draw_trait.rs</code>)</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Built-in traits and operator overloading</h1></div></div></div><p>The Rust standard library is packed<a id="id189" class="indexterm"/> with traits, which are used all over the place. For<a id="id190" class="indexterm"/> example, there are traits for:</p><div><ul class="itemizedlist"><li class="listitem">Comparing objects (the <code class="literal">Eq</code> and <code class="literal">PartialEq</code> traits).</li><li class="listitem">Ordering objects (the <code class="literal">Ord</code> and <code class="literal">PartialOrd</code> traits).</li><li class="listitem">Creating an empty object (the <code class="literal">Default</code> trait).</li><li class="listitem">Formatting a value using <code class="literal">{:?}</code> (the <code class="literal">Debug</code> trait, which defines a <code class="literal">fmt</code> method).</li><li class="listitem">Copying an object (the <code class="literal">Clone</code> trait).</li><li class="listitem">Adding objects (the <code class="literal">Add</code> trait, which defines an <code class="literal">add</code> method)<div><h3 class="title"><a id="note05"/>Note</h3><p>The <code class="literal">+</code> operator is just a nice way to use; <code class="literal">add: n + m</code> is the same as <code class="literal">n.add(m)</code>. So, if we implement the <code class="literal">Add</code> trait, we can use the <code class="literal">+</code> operator; this is called operator overloading. A lot of other traits can also be used to overload operators, such as <code class="literal">Sub(-)</code>, <code class="literal">Mul(*)</code>, <code class="literal">Deref (*v)</code>, <code class="literal">Index([])</code>, and so on.</p></div></li><li class="listitem">Freeing the resources of an object when it goes out of scope (the <code class="literal">Drop</code> trait in other words, the object has a destructor)</li></ul></div><p>In the <em>Iterators</em> section, we described how an iterator works and used it on ranges and arrays. In fact, iterator is also defined as a trait in Rust in <code class="literal">std::iter::Iterator</code>. From the docs for<a id="id191" class="indexterm"/> iterator (refer to <a class="ulink" href="http://doc.rust-lang.org/core/iter/trait.Iterator.html">http://doc.rust-lang.org/core/iter/trait.Iterator.html</a>), we see that we only need to define the <code class="literal">next()</code> method, which advances the iterator to return the next value as an option. When <code class="literal">next()</code> is implemented for the type of your object, we can then use a <code class="literal">for in</code> loop to iterate over the object.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, we learned all kinds of techniques to make our code more flexible by using higher-order functions, closures, iterators, and generic types and functions. We then reviewed the basic error-handling mechanisms that make good use of generic types.</p><p>We also discovered the object-oriented nature of Rust, by defining methods on structs and implementing traits. Finally, we saw that traits are the structuring concept of Rust.</p><p>In the next chapter, we will expose the crown jewels of the Rust language, which form the foundation of its memory safety behavior.</p></div></body></html>