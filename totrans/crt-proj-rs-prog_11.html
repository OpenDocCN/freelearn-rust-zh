<html><head></head><body>
        

                            
                    The Future of Rust
                
            
            
                
<p class="mce-root">The buzzword of the 2015 edition of Rust was <em>stability </em>because version 1.0 promised to be compatible with the versions that followed.</p>
<p class="mce-root">The buzzword of the 2018 edition of Rust was <em>productivity</em> because version 1.31 offered a mature ecosystem of tools that allowed command-line developers for desktop operating systems (Linux, Windows, macOS) to be more productive.</p>
<p class="mce-root">There is an intent to have a new Rust edition in the coming years, but for this edition, neither its release date, nor its features, nor its buzzword is defined yet.</p>
<p class="mce-root">However, after the release of the 2018 edition, several needs of Rust developers are being targeted by Rust ecosystem developers around the world. It is probable that the new buzzword will come out of one of these development lines.</p>
<p>The most interesting lines of development are as follows:</p>
<ul>
<li class="mce-root"><strong>Integrated Development Environments</strong> (<strong>IDEs</strong>) and interactive programming</li>
<li class="mce-root">Crate maturity</li>
<li class="mce-root">Asynchronous programming</li>
<li class="mce-root">Optimization</li>
<li class="mce-root">Embedded systems</li>
</ul>
<p>By the end of this chapter, we will see the most probable developments of the Rust ecosystem: the language, the tooling, and the available libraries. You will learn what to expect in the next few years.</p>
<p>Two of the most exciting new features of the Rust language are the <em>asynchronous programming</em> paradigm and the <em>const generics</em> language feature. At the end of 2019, the former was already added to the language, while the latter was still under development. This will be explained in this chapter using code examples, and so you will get a working knowledge about them.</p>
<h1 id="uuid-afb273ea-d1ec-4be5-be1e-aa31d3943837" class="mce-root">IDEs and interactive programming</h1>
<p class="mce-root">A lot of developers prefer to work inside a graphical application that contains or orchestrates all the development tools, instead of using terminal command lines. Such graphical applications are usually named <strong>Development Environments</strong>—or <strong>DEs</strong> for short.</p>
<p>At present, the most popular IDEs are probably the following ones:</p>
<ul>
<li><strong>Eclipse</strong>: This is used mainly for development in the Java language.</li>
<li><strong>Visual Studio</strong>: This is used mainly for development in the C# and Visual Basic languages.</li>
<li><strong>Visual Studio Code</strong>: This is used mainly for development in the JavaScript language.</li>
</ul>
<p>In the 20th century, it was typical to create an IDE from scratch for a single programming language. That was a major task, though. Therefore, in the last decades, it has become more typical to create customizable IDEs, and then to add extensions (or plugins) to support specific programming languages. For most programming languages, there is at least one mature extension for a popular IDE. However, in 2018, Rust had very limited IDE support, meaning that there were some extensions to use Rust in a pair of IDEs but they offered few features, bad performance, and were also rather buggy.</p>
<p class="mce-root">In addition, many programmers prefer an interactive development style. When creating a new feature of a software system, they do not like to write a lot of software and then compile and test all of it. Instead, they prefer to write a single line or a bunch of few lines and test such snippets of code right away. After testing that snippet of code successfully, they integrate it into the rest of the system. This is typical of developers using interpreted languages such as JavaScript or Python.</p>
<p class="mce-root">The tools that are able to run snippets of code are <strong>language interpreters</strong> or <strong>fast in-memory compilers</strong>. Such interpreters read a command from the user, evaluate it, print the result, and go back to the first step. Therefore, they are usually named <strong>read-eval-print loop</strong>, or <strong>REPL</strong> for short. For all interpreted programming languages, and for some compiled languages, there are mature REPLs. In 2018, the Rust ecosystem was missing a mature REPL.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root">Here, the IDE issue and the REPL issue are presented together because they share the following common problem. The main feature of modern IDEs is to analyze source code as it is edited, with the following goals:</p>
<ul>
<li>To highlight the code containing invalid syntax, and to display a compilation error message in a popup window that appears near the invalid code</li>
<li>To suggest the completion of identifiers, to be chosen among the already declared identifiers</li>
<li>To show the synopsis documentation of an identifier selected in the editor</li>
<li>To jump in the editor from the definition of an identifier to its uses, or vice versa</li>
<li>In a debugging session, to evaluate an expression inside the current context, or to change the memory contents owned by a variable</li>
</ul>
<p>Such operations require very fast parsing of Rust code, and this is also what is required by a Rust REPL. An attempt to address such issues is a project named the <strong>Rust Language Server</strong> (<a href="https://github.com/rust-lang/rls">https://github.com/rust-lang/rls</a>) that is developed by the Rust language team. Another attempt is the project named <strong>Rust Analyzer</strong> (<a href="https://github.com/rust-analyzer/rust-analyzer">https://github.com/rust-analyzer/rust-analyzer</a>) that is developed by the Ferrous Systems company, supported by several partners. Hopefully, before the next Rust edition, there will be a fast and powerful Rust language analyzer to support smart programmers' editors, source-level debuggers, and REPL tools, just as many other programming languages have.</p>
<h1 id="uuid-46cbc8a0-b800-4f26-99bc-23de8ed3584a">Crate maturity</h1>
<p>A crate becomes mature when it reaches <em>version 1.0</em>. That milestone means that the following versions 1.x will be compatible with it. Instead, for versions 0.x, there is no such guarantee, and any version can have an <strong>application programming interface</strong> (<strong>API</strong>) that's quite different from the previous one.</p>
<p class="mce-root">Having a mature version is important for several reasons, listed as follows:</p>
<ul>
<li class="mce-root">When you upgrade your dependency to a newer version of a crate (to use new features of that library), you are guaranteed that your existing code won't get broken—that is, it will continue to behave in a previous way, or in a better way. Without such a guarantee, you typically need to review all your code using that crate and fix all the incompatibilities.</li>
<li class="mce-root">Your investment in know-how is preserved. You need to neither retrain yourself nor your coworkers and not even update your documentation.</li>
<li class="mce-root">Typically, software quality is improved. If a version of an API remains unchanged for a long time, and many people use it in different corner cases, untested bugs and real-world performance issues can emerge and be fixed. Instead, a quickly changing version is usually bug-ridden and inefficient in many application cases.</li>
</ul>
<p class="mce-root">Of course, there is an advantage to iterating through several improvement steps of the API, and APIs created in a few weeks are usually badly designed. Although there are still many crates that have been in a 0.x version for several years, the time is coming to stabilize them.</p>
<p>This is a reinterpretation of the buzzword <em>stability</em>. In 2015, it meant <em>the</em> <em>stability of the language and of the standard library</em>. Now, the rest of the mature ecosystem must stabilize to be accepted in real-world projects.</p>
<h1 id="uuid-f28b101c-88b9-45fe-9337-ceaa68f17ff6">Asynchronous programming</h1>
<p>A major innovation was introduced in stable Rust in November 2019—with release 1.39—it is the <kbd>async-await</kbd> syntax, to support asynchronous programming.</p>
<p class="mce-root">Asynchronous programming is a programming paradigm that is very useful in many application areas, mainly in multiuser servers, so that many programming languages—such as JavaScript, C#, Go, and Erlang—support it in the language. Other languages, such as C++ and Java, support asynchronous programming through the standard library.</p>
<p class="mce-root">Around 2016, it was very hard to do asynchronous programming in Rust because neither the language nor the available crates supported it in an easy and stable way. Then, some crates supporting asynchronous programming were developed, such as <kbd>futures</kbd>, <kbd>mio</kbd>, and <kbd>tokio</kbd>, though they were not much easier to use, and remained at a version before 1, meaning instability of their API.</p>
<p class="mce-root">After having seen the difficulty of creating convenient support for asynchronous programming using only libraries, it appeared clear that a language extension was needed.</p>
<p class="mce-root">The new syntax, similar to that of C#, includes the new <kbd>async</kbd> and <kbd>await</kbd> language keywords. The stabilization of this syntax means that the previous asynchronous crates should now be considered obsolete until they migrate to use the new syntax.</p>
<p class="mce-root">The new syntax—announced on the <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">https://blog.rust-lang.org/2019/11/07/Async-await-stable.html</a> web page—is described on the <a href="https://rust-lang.github.io/async-book/">https://rust-lang.github.io/async-book/</a> web page.</p>
<p class="mce-root"/>
<p class="mce-root">For those who never felt the need for asynchronous programming, here is a quick example of it. Create a new Cargo project, with the following dependencies:</p>
<pre>async-std = "1.5"<br/>futures = "0.3"</pre>
<p>Prepare in the root folder of that project a file named <kbd>file.txt</kbd> that contains only five <kbd>Hello</kbd> characters. Using a Unix-like command-line, you can do this using the following command:</p>
<pre>echo -n "Hello" &gt;file.txt</pre>
<p>Put the following content into the <kbd>src/main.rs</kbd> file:</p>
<pre>use async_std::fs::File;<br/>use async_std::prelude::*;<br/>use futures::executor::block_on;<br/>use futures::try_join;<br/><br/>fn main() {<br/>    block_on(parallel_read_file()).unwrap();<br/>}<br/><br/>async fn parallel_read_file() -&gt; std::io::Result&lt;()&gt; {<br/>    print_file(1).await?;<br/>    println!();<br/>    print_file(2).await?;<br/>    println!();<br/>    print_file(3).await?;<br/>    println!();<br/>    try_join!(print_file(1), print_file(2), print_file(3))?;<br/>    println!();<br/>    Ok(())<br/>}<br/><br/>async fn print_file(instance: u32) -&gt; std::io::Result&lt;()&gt; {<br/>    let mut file = File::open("file.txt").await?;<br/>    let mut byte = [0u8];<br/>    while file.read(&amp;mut byte).await? &gt; 0 {<br/>        print!("{}:{} ", instance, byte[0] as char);<br/>    }<br/>    Ok(())<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>If you run this project, the output is not quite deterministic. The possible output is the following one:</p>
<pre>1:H 1:e 1:l 1:l 1:o <br/>2:H 2:e 2:l 2:l 2:o <br/>3:H 3:e 3:l 3:l 3:o <br/>1:H 2:H 3:H 1:e 2:e 3:e 1:l 1:l 3:l 1:o 2:l 3:l 2:l 3:o 2:o </pre>
<p>The first three lines are deterministic. Instead, the last line can be shuffled a bit.</p>
<p>In a first reading, pretend it is synchronous code, ignoring the words <kbd>async</kbd>, <kbd>await</kbd>, <kbd>block_on</kbd>, and <kbd>join!</kbd>. With this simplification, the flow is easy to follow.</p>
<p>The <kbd>main</kbd> function calls the <kbd>parallel_read_file</kbd> function. The first six lines of the <kbd>parallel_read_file</kbd> function call the <kbd>print_file</kbd> function three times, with the arguments <kbd>1</kbd>, <kbd>2</kbd>, and <kbd>3</kbd>, in different lines, each followed by a call to <kbd>println!</kbd>. The seventh line of the <kbd>parallel_read_file</kbd> function again calls the <kbd>print_file</kbd> function three times, with the same three arguments.</p>
<p>The <kbd>print_file</kbd> function uses the <kbd>File::open</kbd> function call to open a file, and then uses the <kbd>file.read</kbd> function call to read a byte at a time from that file. Any byte read is printed, preceded by the argument of the function (<kbd>instance</kbd>).</p>
<p>So, we obtain the information that the first call to <kbd>print_file</kbd> prints <kbd>1:H 1:e 1:l 1:l 1:o</kbd>. They are the five characters read from the file, preceded by the number <kbd>1</kbd>, received as an argument.</p>
<p>The fourth line prints the same contents of the first three lines, mixing the characters. First, the three <kbd>H</kbd> characters are printed, then the three <kbd>e</kbd> characters, then the three <kbd>l</kbd> characters, and then something weird happens: an <kbd>o</kbd> is printed before all the <kbd>l</kbd> characters have been printed.</p>
<p>What is happening is that the first three lines are printed by three sequential invocations of the <kbd>print_file</kbd> function, while the last line is printed by three parallel invocations of the same function. In any parallel invocation, all the letters printed by one invocation are in the correct order, but the other invocations may interleave their output.</p>
<p>If you think that this is similar to multithreading, you are not far from the truth. There is an important difference, though. Using threads, the operating system may interrupt the threads and pass control to another thread at any time, with the effect that the output may be broken at undesirable points.</p>
<p class="mce-root"/>
<p>To avoid such interruptions, critical regions or other synchronization mechanisms must be used. Instead, with asynchronous programming, functions are never interrupted except when a specific asynchronous operation is performed. Typically, such operations are an invocation of external services, such as accessing the filesystem, which could cause a wait. Instead of waiting, another asynchronous operation is activated.</p>
<p>Now, let's see the code from the beginning, implementing asynchronous operations. It uses the <kbd>async_std</kbd> crate. It is an asynchronous version of the standard library. The standard library is still available, but its functions are synchronous. The code can be seen in the following snippet:</p>
<pre>use async_std::fs::File;<br/>use async_std::prelude::*;</pre>
<p>To have an asynchronous behavior, the functions of this crate must be used. In particular, we will use the functions of the <kbd>File</kbd> data type. In addition, some features of the not-yet-stabilized <kbd>futures</kbd> crate are used. The code can be seen in the following snippet:</p>
<pre>use futures::executor::block_on;<br/>use futures::try_join;</pre>
<p>Then, there is the <kbd>main</kbd> function, whose body contains only the following line:</p>
<pre>    block_on(parallel_read_file()).unwrap();</pre>
<p>Here, the <kbd>parallel_read_file</kbd> function is called first.</p>
<p>This is an asynchronous function. When you call an asynchronous function using the normal function-call syntax, as in the <kbd>parallel_read_file()</kbd> expression, the body of that function is not actually executed, as a normal and synchronous function would be. Instead, such a call just returns an object, called a <strong>future</strong>. A future is similar to a closure, as it encapsulates a function and the arguments used to invoke such a function. The function encapsulated in the returned future is the body of the function we were calling.</p>
<p>To actually run the function encapsulated in the future, a particular kind of function is needed, called an <strong>executor</strong>. The <kbd>block_on</kbd> function is an executor. When an executor is invoked, passing a future to it, the body of the function encapsulated in that future is run, and the value returned by such a function is then returned by the executor itself.</p>
<p>So, when the <kbd>block_on</kbd> function is called, the body of <kbd>parallel_read_file</kbd> is run, and when it terminates, <kbd>block_on</kbd> also terminates, returning the same value returned by <kbd>parallel_read_file</kbd>. As this last function has a <kbd>Result</kbd> value type, it should be unwrapped.</p>
<p>Then, a function is defined whose signature is as follows:</p>
<pre>async fn parallel_read_file() -&gt; std::io::Result&lt;()&gt;</pre>
<p>The <kbd>async</kbd> keyword marks that function as asynchronous. It is also fallible, and so a <kbd>Result</kbd> value is returned.</p>
<p>Asynchronous functions can be invoked only by other asynchronous functions or by executors, such as <kbd>block_on</kbd> and <kbd>try_join</kbd>. The <kbd>main</kbd> function is not asynchronous, and so there, we needed an executor.</p>
<p>The first line of the body of the function is added in the following code snippet. It is an invocation of the <kbd>print_file</kbd> function, passing the value <kbd>1</kbd> to it. As the <kbd>print_file</kbd> function is asynchronous too, to invoke it from inside an asynchronous function, the <kbd>.await</kbd> clause must be used. Such a function is fallible, and so a <kbd>?</kbd> operator is added, like this:</p>
<pre>    print_file(1).await?;</pre>
<p>When an asynchronous function is invoked using <kbd>.await</kbd>, the execution of the body of that function starts right away, but as soon as it yields control because it executes a blocking function, such as an operating system call, another ready asynchronous function may proceed. However, the flow of control does not proceed beyond the <kbd>.await</kbd> clause until the body of the called function is complete.</p>
<p>The second line of the body of the function is an invocation of a synchronous function, and so <kbd>.await</kbd> is neither needed nor allowed, as can be seen in the following code snippet: </p>
<pre>    println!();</pre>
<p>We can be sure that it is run after the previous statement because that statement ended with a <kbd>.await</kbd> clause.</p>
<p>This pattern is repeated three times, and then the seventh line consists of a set of three invocations in parallel with the same asynchronous function, as illustrated in the following code snippet:</p>
<pre>    try_join!(print_file(1), print_file(2), print_file(3))?;</pre>
<p>Even the <kbd>try_join!</kbd> macro is an executor. It runs all the three futures generated by the three calls to <kbd>print_file</kbd>. Only one thread is used by asynchronous programming, and so, in fact, one of the three futures is run first. If it never has to wait, it ends before the other futures have the opportunity to start.</p>
<p>Instead, as this function will have to wait, at any wait the context is switched to another running future, starting from the statement that had put it on wait. So, the executions of the three futures are interleaved.</p>
<p>Now, let's see the definition of such an invoked function. Its signature is shown in the following code snippet:</p>
<pre>async fn print_file(instance: u32) -&gt; std::io::Result&lt;()&gt; {</pre>
<p>It is an asynchronous function, receiving an integer argument and returning an empty <kbd>Result</kbd> value.</p>
<p>The first line of its body opens a file using the <kbd>File</kbd> data type of the asynchronous standard library, as illustrated in the following code snippet:</p>
<pre>    let mut file = File::open("file.txt").await?;</pre>
<p>As such, the <kbd>open</kbd> function is asynchronous too, and it must be followed by <kbd>.await</kbd>, as illustrated in the following code snippet:</p>
<pre>    let mut byte = [0u8];<br/>    while file.read(&amp;mut byte).await? &gt; 0 {<br/>        print!("{}:{} ", instance, byte[0] as char);<br/>    }</pre>
<p>The asynchronous <kbd>read</kbd> function is used to read bytes to fill the <kbd>byte</kbd> buffer. This buffer has length <kbd>1</kbd>, and so just one byte at a time is read. The <kbd>read</kbd> function is fallible, and if it is successful, it returns the numbers of bytes read. This means that it returns <kbd>1</kbd> if a byte is read and <kbd>0</kbd> if the file is ended. If the call reads a byte, the loop continues.</p>
<p>The body of the loop is a synchronous output statement. It prints the identifier of the current instance of the file stream, and the byte just read.</p>
<p>So, the sequence of steps is as follows.</p>
<p>First, the <kbd>print_file(1)</kbd> future is started. When it executes the <kbd>File::open</kbd> call that is blocking, this future is put on hold, and a ready-to-run future is looked for. There are two ready futures: <kbd>print_file(2)</kbd> and <kbd>print_file(3)</kbd>. The first one is chosen, and it is started. Also, it reaches the <kbd>File::open</kbd> call, and so it is put on hold, and the third future is started. When it reaches the <kbd>File::open</kbd> call, it is put on hold and a ready future is looked for. If there is no ready-to-run future, the thread itself waits for the first ready future.</p>
<p>The first future to complete the <kbd>File::open</kbd> call is the first one, which resumes its execution just after that call and starts to read a byte from the file. Even this one is a blocking operation, and so this future is put on hold, and control is moved to the second future, which starts to read one byte.</p>
<p>There is always a queue of ready futures. When a future has to wait for an operation, it yields control to the executor, which passes control to the first future in the queue of ready futures. When the blocking operation is complete, the waiting future is appended to the queue of ready futures and can be yielded control if no other future is running.</p>
<p>When all the bytes of a file have been read, the <kbd>print_file</kbd> function ends. When all the three calls to <kbd>print_file</kbd> are ended, the <kbd>try_join!</kbd> executor ends, and the <kbd>parallel_read_file</kbd> function can proceed. When it reaches its end, the <kbd>block_on</kbd> executor ends and, with it, the whole program.</p>
<p>As blocking operations take a variable amount of time, the sequence of steps is non-deterministic. Indeed, the last line of output of the example program seen before can be slightly different in different runs, swapping some portions of it.</p>
<p>As we have seen, asynchronous programming is similar to multithreaded programming but it is more efficient, saving both context-switch time and memory usage. It is appropriate primarily for <strong>input/output</strong> (<strong>I/O</strong>)-bound tasks as only one thread is used, and the flow of control is interrupted only when an I/O operation is performed. Instead, multithreading can allocate a different thread on any core, and so it is more appropriate for <strong>central processing unit</strong> (<strong>CPU</strong>)-bound operations.</p>
<p>After the addition of the <kbd>async/await</kbd> syntax extension, what is still needed is the development and stabilization of crates using and supporting such syntax.</p>
<h1 id="uuid-3871a1aa-be9b-4af8-a1b4-9a2d778a94b1">Optimization</h1>
<p>Usually, system programmers are quite interested in efficiency. In this regard, Rust shines as one of the most efficient languages, though there are still some issues with performance, as follows:</p>
<ul>
<li>A full build—in particular, an optimized release build—is quite slow, even more so if link-time optimization is enabled. For large projects, this can be quite a nuisance. At present, the Rust compiler is just a frontend that generates <strong>Low-Level Virtual Machine</strong> (<strong>LLVM</strong>) <strong>intermediate representation</strong> (<strong>IR</strong>) code and passes such code to the LLVM machine code generator. However, the Rust compiler generates a disproportionate amount of LLVM IR code, and so the LLVM backend must take a long time to optimize it. An improved Rust compiler would pass to LLVM a much more compact sequence of instructions. A refactoring of the compiler is in progress, and this could lead to a faster compiler.</li>
<li>Since version 1.37, the Rust compiler supports <strong>profile-guided optimization</strong> (<strong>PGO</strong>), which can enhance performance for the typical processor workflows. However, such a feature is rather cumbersome to use. A graphical frontend or an IDE integration would make it easier to use.</li>
<li>A development underway is an addition to the language of the <strong>const generics</strong> feature, described in the next section.</li>
<li>In LLVM IR, any function argument of a pointer type can be tagged with the <kbd>noalias</kbd> attribute, meaning that the memory reference by this pointer will not be changed inside this function, except through this pointer. Using this information, LLVM can generate faster machine code. This attribute is similar to the <kbd>restrict</kbd> keyword in the C language. Yet in Rust, for <em>every</em> mutable reference (<kbd>&amp;mut</kbd>), the <kbd>noalias</kbd> property is guaranteed by language ownership rules. Therefore, faster programs could be obtained that always generate LLVM IR code with the <kbd>noalias</kbd> attribute for every mutable reference. This has been done in versions 1.0 through 1.7 and in versions 1.28 and 1.29, although, because of bugs in the LLVM backend compiler, the resulting code was bugged. Therefore, until a correct LLVM implementation is released, the <kbd>noalias</kbd> optimization hint will not be used.</li>
</ul>
<h2 id="uuid-5cee35c7-412c-43e6-859c-0292cc299308">The const generics feature</h2>
<p>At present, generic data types are parameterized only by types or lifetimes. It is useful to be able to also parameterize a generic data type by a constant expression. In a way, this feature is already available, but only for one kind of generic type: the arrays. You can have the <kbd>[u32; 7]</kbd> type that is an array parameterized by the <kbd>u32</kbd> type and by the <kbd>7</kbd> constant, though you cannot define your own generic type parameterized by a constant.</p>
<p>This feature, already available in C++ language, is in development in the nightly build. It would allow variables to be replaced with constants in generic code, and this would surely improve performance. Here is an example program that uses as dependencies the <kbd>num</kbd> crate:</p>
<pre>#![feature(const_generics)]<br/>#![allow(incomplete_features)]<br/><br/>use num::Float;<br/><br/>struct Array2&lt;T: Float, const WIDTH: usize, const HEIGHT: usize&gt; {<br/>    data: [[T; WIDTH]; HEIGHT],<br/>}<br/><br/>impl&lt;T: Float, const WIDTH: usize, const HEIGHT: usize&gt;<br/>Array2&lt;T, WIDTH, HEIGHT&gt; {<br/>    fn new() -&gt; Self {<br/>        Self { data: [[T::zero(); WIDTH]; HEIGHT] }<br/>    }<br/>    fn width(&amp;self) -&gt; usize { WIDTH }<br/>    fn height(&amp;self) -&gt; usize { HEIGHT }<br/>}<br/><br/>fn main() {<br/>    let matrix = Array2::&lt;f64, 4, 3&gt;::new();<br/>    print!("{} {}", matrix.width(), matrix.height());<br/>}</pre>
<p>This program, to be compiled only using a nightly version of the compiler, creates a data type implementing a bidimensional array of floating-point numbers. Notice that the parameterization is as follows: <kbd>T: Float, const WIDTH: usize, const HEIGHT: usize</kbd>. The first parameter is the type of array items. The second and third parameters are the sizes of the array.</p>
<p>Having constant values instead of variables allows important code optimizations.</p>
<h1 id="uuid-4dfc4665-f6fc-4ed1-87f0-64ab77f5fc4b">Embedded systems</h1>
<p>Rust has been developed since when Mozilla started to sponsor it in 2009, with a specific goal: to create a web browser. Even after 2018, the core team of developers works for Mozilla Foundation, whose main business is to build client-side web applications. Such software is multiplatform, but oriented exclusively toward the following requirements:</p>
<ul>
<li><strong>Random-access memory (RAM)</strong>: At least 1 GB</li>
<li><strong>Supported CPUs</strong>: Initially only x86 and x86_64; later, also ARM and ARM64.</li>
<li><strong>Supported operating systems</strong>: Linux, Windows, macOS</li>
</ul>
<p>These requirements excluded most microcontrollers as the Mozilla Foundation was not interested in such platforms, though the features of Rust appear to be a good match with the requirements of many embedded systems with more constrained requirements. Therefore, thanks to a worldwide group of volunteers, in 2018, the Embedded Working Group was created to develop the ecosystem needed to use Rust on embedded systems—that is, on bare-metal or on stripped-down operating systems, and with severe resource limitations. </p>
<p>Progress in this application area has been rather slow and directed mainly at a few architectures, but the future is promising, at least for 32-bit or 64-bit architectures, because any architecture supported by the LLVM backend is easily targetable by the Rust compiler.</p>
<p>Some specific improvements to the language, which ease the use of Rust for embedded systems, are listed as follows:</p>
<ul>
<li>The standard-library <kbd>Pin</kbd> generic class avoids moving objects in memory. This is needed when some external device is accessing a memory location.</li>
<li>The <kbd>cfg</kbd> and <kbd>cfg_attr</kbd> attributes, which allow conditional compilation, have been extended. This feature is needed because trying to compile code for a wrong platform can create unacceptable code bloat, or even cause compilation errors.</li>
<li>The <kbd>allocator</kbd> API has been made more customizable.</li>
<li>The applicability of <kbd>const fn</kbd> has been extended. This construct allows a code base that is maintainable as normal algorithmic code, but as efficient as a wired constant.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<h1 id="uuid-407de552-0c23-4fea-853b-ae23ab8fc0a4">Summary</h1>
<p>In this chapter, we have seen the most probable development lines of the Rust ecosystem in the next few years—support for IDEs and for interactive programming; the maturity of the most popular crates; widespread support of the new asynchronous programming paradigm and its keywords (<kbd>async</kbd> and <kbd>await</kbd>); further optimization of both the compiler and the generated machine code; and widespread support of embedded systems programming.</p>
<p>We have learned how to write asynchronous code and a possible way to define and use const generics (still unstable at the time of writing). </p>
<p>We have seen that there are quite a lot of application areas where Rust could really shine. Of course, if you are going to use it only for fun, the sky is the limit, but for real-world applications, the ecosystem of libraries and tools can really decide the viability of a programming system. Now, at last, the critical mass of high-quality libraries and tools is about to be reached.</p>


            

            
        
    </body></html>