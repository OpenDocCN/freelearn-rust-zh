- en: Starting with SDL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从SDL开始
- en: Before starting to write the Tetris, a few things remain to be talked about,
    such as crates, which we'll be using a lot (and you'll be using a lot as well
    once you're *rusting* on your own!). Let's start with crates!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写俄罗斯方块之前，还有一些事情需要讨论，比如库，我们将大量使用（一旦您开始在自己的项目上使用Rust，您也会大量使用！）。让我们从库开始吧！
- en: Understanding Rust crates
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Rust库
- en: In Rust, packages (both binaries and libraries) are named crates. You can find
    a lot of them on `crates.io`. Today, we'll use the SDL2 crate in order to make
    our tetris, but before even thinking about this, we need to install the `SDL2`
    library that is used by the `SDL2` crate!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，包（包括二进制和库）被称为crate。您可以在`crates.io`上找到很多。今天，我们将使用SDL2 crate来制作我们的俄罗斯方块，但在考虑这一点之前，我们需要安装`SDL2`库，这是由`SDL2`
    crate使用的！
- en: Installing SDL2
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SDL2
- en: Before going any further, we need to install the SDL library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要安装SDL库。
- en: Installing SDL2 on Linux
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装SDL2
- en: 'Depending on your package management tool, run the following to install SDL2
    on Linux:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的包管理工具，运行以下命令在Linux上安装SDL2：
- en: '`apt package mananger`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt包管理器`：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`dnf package manager`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`dnf包管理器`：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'yum package manager:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`yum包管理器`：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once done, your SDL2 installation is ready!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您的SDL2安装就绪了！
- en: Installing SDL2 on Mac
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装SDL2
- en: 'To install SDL2 on Mac, Simply run the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mac上安装SDL2，只需运行以下命令：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You're good to go!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开始了！
- en: Installing SDL2 on Windows
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装SDL2
- en: All these installation instructions come directly from the Rust SDL2 crate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些安装说明都直接来自Rust SDL2 crate。
- en: Windows with Build Script
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有构建脚本的Windows
- en: A few steps will be required in order to make all of it work. Follow the guide!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些工作，需要执行几个步骤。请遵循指南！
- en: Download the `mingw` and `msvc` development libraries from [http://www.libsdl.org/](http://www.libsdl.org/)
    (`SDL2-devel-2.0.x-mingw.tar.gz` and `SDL2-devel-2.0.x-VC.zip`).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.libsdl.org/](http://www.libsdl.org/)下载`mingw`和`msvc`开发库（`SDL2-devel-2.0.x-mingw.tar.gz`和`SDL2-devel-2.0.x-VC.zip`）。
- en: Unpack to folders of your choice. (You can delete it afterward.)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩到您选择的文件夹。 （之后您可以删除它。）
- en: 'Create the following folder structure in the same folder as your `Cargo.toml`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`Cargo.toml`文件相同的文件夹中创建以下文件夹结构：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Copy the `lib` and `dll` files from the source archive to the directories we
    created in step 3 as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源存档中的`lib`和`dll`文件复制到步骤3中创建的目录中，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a Build Script. If you don''t already have one, put this in your `Cargo.toml`
    file under `[package]`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构建脚本。如果您还没有，请将以下内容放入您的`Cargo.toml`文件中的`[package]`部分：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a file in the same directory as `Cargo.toml` called `build.rs` and write
    this into it:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`Cargo.toml`文件相同的目录下创建一个名为`build.rs`的文件，并将以下内容写入其中：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On build, the Build Script will copy the needed DLLs into the same directory
    as your `Cargo.toml` file. You probably don''t want to commit these to any Git
    repositories though, so add the following line to your `.gitignore` file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建过程中，构建脚本会将所需的DLL文件复制到与您的`Cargo.toml`文件相同的目录中。但是，您可能不希望将这些文件提交到任何Git仓库中，因此请将以下行添加到您的`.gitignore`文件中：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you're shipping your game, make sure that you copy the corresponding `SDL2.dll`
    to the same directory that your compiled `exe` is in; otherwise, the game won't
    launch.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您发布游戏时，请确保将相应的`SDL2.dll`复制到与您的编译`exe`文件相同的目录中；否则，游戏将无法启动。
- en: And now your project should build and run on any Windows computer!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的项目应该可以在任何Windows计算机上构建和运行了！
- en: Windows (MinGW)
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows（MinGW）
- en: A few steps will be required in order to make all of it work. Follow the guide!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些工作，需要执行几个步骤。请遵循指南！
- en: Download `mingw` development libraries from [http://www.libsdl.org/](http://www.libsdl.org/)
    (`SDL2-devel-2.0.x-mingw.tar.gz`).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.libsdl.org/](http://www.libsdl.org/)下载`mingw`开发库（`SDL2-devel-2.0.x-mingw.tar.gz`）。
- en: Unpack to a folder of your choice. (You can delete it afterward.)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩到您选择的文件夹。 （之后您可以删除它。）
- en: 'Copy all `lib` files from the following path:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下路径复制所有`lib`文件：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, copy it to this path:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将其复制到以下路径：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternately, you can copy to your library folder of choice and ensure that
    you have a system environment variable as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将它复制到您选择的库文件夹中，并确保您有一个如下所示的系统环境变量：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For Rustup users, this folder will be at the following location:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Rustup用户，此文件夹位于以下位置：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the current toolchain is probably `stable-x86_64-pc-windows-gnu`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当前的工具链可能是`stable-x86_64-pc-windows-gnu`。
- en: 'Copy `SDL2.dll` from the following:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下位置复制`SDL2.dll`：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The copied `SDL2.dll` is pasted into your cargo project, right next to your
    `Cargo.toml`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的`SDL2.dll`被粘贴到您的Cargo项目中，紧挨着您的`Cargo.toml`文件。
- en: When you're shipping your game, make sure that you copy `SDL2.dll` to the same
    directory that your compiled `exe` is in; otherwise, the game won't launch.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你发布你的游戏时，确保将 `SDL2.dll` 复制到与你的编译 `exe` 文件相同的目录中；否则，游戏将无法启动。
- en: Windows (MSVC)
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows (MSVC)
- en: A few steps will be required in order to make all of it work. Follow the guide!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些工作，你需要进行几个步骤。请遵循指南！
- en: Download MSVC development libraries from [http://www.libsdl.org/](http://www.libsdl.org/)
    `SDL2-devel-2.0.x-VC.zip`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [http://www.libsdl.org/](http://www.libsdl.org/) 下载 MSVC 开发库 `SDL2-devel-2.0.x-VC.zip`。
- en: Unpack `SDL2-devel-2.0.x-VC.zip` to a folder of your choice. (You can delete
    it afterward.)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SDL2-devel-2.0.x-VC.zip` 解压到你的选择文件夹中。（之后你可以删除它。）
- en: 'Copy all `lib` files from the following path:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下路径复制所有 `lib` 文件：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `lib` files will be pasted here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib` 文件将被粘贴在这里：'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, they''ll be pasted to your library folder of choice. Ensure
    that you have a system environment variable with the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们将被粘贴到你的选择库文件夹中。确保你有一个包含以下内容的系统环境变量：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the current toolchain is probably `stable-x86_64-pc-windows-msvc`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当前的工具链可能是 `stable-x86_64-pc-windows-msvc`。
- en: 'Copy `SDL2.dll` from the following code snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下代码片段复制 `SDL2.dll`：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The copied `SDL2.dll` is pasted into your cargo project, right next to your
    `Cargo.toml`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的 `SDL2.dll` 被粘贴到你的 cargo 项目中，紧挨着你的 `Cargo.toml` 文件。
- en: When you're shipping your game, make sure that you copy `SDL2.dll` to the same
    directory that your compiled `exe` is in; otherwise, the game won't launch.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你发布你的游戏时，确保将 `SDL2.dll` 复制到与你的编译 `exe` 文件相同的目录中；否则，游戏将无法启动。
- en: Setting up your Rust project
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的 Rust 项目
- en: 'The Rust package manager, `cargo`, allows us to create a new project very easily
    with just one command, `cargo new`. Let''s run it as follow:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 的包管理器 `cargo` 允许我们通过一个命令 `cargo new` 非常容易地创建一个新的项目。让我们按照以下步骤运行它：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should have a new folder `tetris` containing the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一个名为 `tetris` 的新文件夹，其中包含以下内容：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that if you ran `cargo new` without the `--bin` flag, then you will have
    a `lib.rs` file instead of `main.rs`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在运行 `cargo new` 命令时没有使用 `--bin` 标志，那么你将会有一个 `lib.rs` 文件而不是 `main.rs`。
- en: 'Now write this into your `Cargo.toml` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下内容写入你的 `Cargo.toml` 文件：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we declare that our project's name is `tetris`, its version is `0.0.1`
    (it isn't really important at the moment), and that it has a dependency on the
    `sdl2` crate.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明我们的项目名称是 `tetris`，版本是 `0.0.1`（目前这并不重要），并且它依赖于 `sdl2` crate。
- en: 'For the versioning, `Cargo` follows **SemVer** (**Semantic Versioning**). It
    works as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本控制，`Cargo` 遵循 **SemVer**（语义版本控制）。它的工作方式如下：
- en: '`[major].[minor].[path]`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`[major].[minor].[path]`'
- en: 'So here''s exactly what every part means:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里就是每个部分的确切含义：
- en: Update the `[major]` number version when you make incompatible API changes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你进行不兼容的 API 变更时，更新 `[major]` 版本号。
- en: Update the `[minor]` number version when adding functionalities that don't break
    backward compatibility
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你添加不破坏向后兼容性的新功能时，更新 `[minor]` 版本号。
- en: Update the `[patch]` number version when you make bug fixes that don't break
    backward compatibility
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你进行不破坏向后兼容性的错误修复时，更新 `[patch]` 版本号。
- en: It's not vital to know this, but it's always nice to be aware of it in case
    you intend to write crates in the future.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然知道这一点不是必须的，但如果你打算将来编写 crate，了解这一点总是很好的。
- en: Cargo and crates.io
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo 和 crates.io
- en: A very important thing to note with Rust's ecosystem is that `Cargo` is really
    important if not central. It makes things much easier and all Rust projects are
    using it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 的生态系统中有一些非常重要的事情需要注意，那就是 `Cargo` 非常重要，如果不是核心的话。它使事情变得容易得多，并且所有 Rust 项目都在使用它。
- en: 'Cargo isn''t only a build tool, it''s also Rust''s default package manager.
    If you need to download a dependency, `Cargo` will do it. You can find all available
    published crates on [https://crates.io/](https://crates.io/). Consider the following
    screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`cargo` 不仅是一个构建工具，也是 Rust 的默认包管理器。如果你需要下载依赖项，`Cargo` 会为你做这件事。你可以在 [https://crates.io/](https://crates.io/)
    找到所有可用的已发布 crate。考虑以下截图：'
- en: '![](img/00006.jpeg)*Figure 2.1*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00006.jpeg)*图 2.1*'
- en: 'In the case of the `sdl2` crate, we can see on its page ([https://crates.io/crates/sdl2](https://crates.io/crates/sdl2))
    some interesting and useful information:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `sdl2` crate，我们可以在其页面 ([https://crates.io/crates/sdl2](https://crates.io/crates/sdl2))
    上看到一些有趣和有用的信息：
- en: '![](img/00007.jpeg)*Figure 2.2*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00007.jpeg)*图 2.2*'
- en: On the right-hand side, you can see the version history. It can be useful to
    check whether you have the last version or not and whether the crate is still
    maintained.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，你可以看到版本历史。检查你是否拥有最新版本以及crate是否仍在维护中可能很有用。
- en: In the middle, you have the crate's dependencies. It's always interesting to
    know what you'll need to install in addition to your crate if something is missing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间，你有crate的依赖项。如果缺少某些东西，了解你需要安装什么总是很有趣。
- en: 'And finally on the left-hand side, you have a few links that might be very
    useful (not always those ones, it depends on what has been put into the `Cargo.toml`
    file):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在左侧，有几个可能非常有用的链接（不总是那些链接，这取决于 `Cargo.toml` 文件中放入了什么）：
- en: '**Documentation**: This is where the documentation is hosted (even though I
    generally recommend [docs.rs](https://docs.rs/), I''ll talk about it in a moment)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：这是文档的托管位置（尽管我通常推荐 [docs.rs](https://docs.rs/)，我稍后会谈到）'
- en: '**Repository**: This is where this crate''s repository is hosted'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：这是这个crate的仓库托管位置'
- en: '**Dependent crates**: This is the list of the crates depending on this one'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖的crate**：这是依赖于这个crate的crate列表'
- en: '**Homepage**: If the crate has a website, you can go to its link'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：如果crate有一个网站，你可以访问它的链接'
- en: Time to go back to `docs.rs` for a bit.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回到 `docs.rs` 上看看了。
- en: The docs.rs documentation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: docs.rs 文档
- en: Every published crate on `crates.io` gets its documentation generated and hosted
    on [https://docs.rs/](https://docs.rs/). If the crate's documentation hasn't been
    published by anyone anywhere online, you'll find it there as long as it has been
    published. With `crates.io` and `rust-lang.org`, it's one of the most known places
    of the Rust ecosystem, so bookmark it and doesn't lose it!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `crates.io` 上发布的每个crate都会生成其文档并托管在 [https://docs.rs/](https://docs.rs/)。如果crate的文档没有在任何地方在线发布，只要它已经发布，你就能在那里找到它。与
    `crates.io` 和 `rust-lang.org` 一样，它是Rust生态系统中最知名的地方之一，所以请将其添加到书签，不要丢失它！
- en: 'Here''s a screenshot of what [docs.rs](https://docs.rs/) looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 [docs.rs](https://docs.rs/) 的截图：
- en: '![](img/00008.jpeg)*Figure 2.3*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3](img/00008.jpeg)*图2.3*'
- en: Back to our Cargo.toml file
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到我们的 `Cargo.toml` 文件
- en: To go back to our `Cargo.toml` file, it's also possible to use crates directly
    from their repositories; you just have to specify this when adding the dependency
    in your `Cargo.toml` file. Generally, the published version is less advanced than
    the one on the corresponding repository but will be more stable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要回到我们的 `Cargo.toml` 文件，你也可以直接从它们的仓库中添加crates；你只需在添加依赖时在 `Cargo.toml` 文件中指定这一点。通常，发布的版本不如对应仓库中的版本先进，但会更稳定。
- en: 'So for example, if we want to use the repository version for the `sdl2` crate,
    we need to write in our `Cargo.toml` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想使用 `sdl2` crate的仓库版本，我们需要在 `Cargo.toml` 文件中写下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Easy right? `Cargo` can also start tests or benchmarks, install binaries, handle
    special builds through a build file (by default in `build.rs`), or handle features
    (we'll come back to this point later in this part).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单吧？`Cargo` 还可以启动测试或基准测试，安装二进制文件，通过构建文件（默认在 `build.rs`）处理特殊构建，或处理功能（我们稍后会回到这一点）。
- en: To put it simply, it's a complete tool, and explaining most of its features
    would take a lot of time and space, so we'll just stick to the basics for the
    moment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，它是一个完整的工具，解释其大部分功能需要花费很多时间和空间，所以我们现在就只关注基础部分。
- en: You can find a very good documentation/tutorial on Cargo at [http://doc.crates.io/index.html](http://doc.crates.io/index.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://doc.crates.io/index.html](http://doc.crates.io/index.html) 找到关于Cargo非常好的文档/教程。
- en: Rust's modules
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust的模块
- en: Before going any further, we need to talk about how file hierarchy works in
    Rust through its modules.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要谈谈Rust中通过其模块如何处理文件层次结构。
- en: 'The first thing to know is that files and folders are handled as modules in
    Rust. Consider the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，在Rust中，文件和文件夹被当作模块处理。考虑以下情况：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to declare that a module is in the `another_file.rs` file, you''ll
    need to add to your `main.rs` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想声明一个模块位于 `another_file.rs` 文件中，你需要在你的 `main.rs` 文件中添加：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You will now have access to everything contained in `another_file.rs` (as long
    as it's public).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够访问 `another_file.rs` 中包含的所有内容（只要它是公开的）。
- en: 'Another thing to know: you can only declare modules whose files are on the
    same level as your current module/file. Here''s a short example to sum this up:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要知道的事情：你只能声明与你的当前模块/文件处于同一级别的模块。以下是一个简短的例子来总结这一点：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you try to declare a module referring to `another_file.rs` directly into
    `main.rs`, as shown preceding, it''ll fail because there are no `another_file.rs`
    in `src/`. In this case, you''ll need to do three things:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试直接在`main.rs`中声明一个引用`another_file.rs`的模块，就像前面展示的那样，它将会失败，因为`src/`中没有`another_file.rs`。在这种情况下，你需要做三件事：
- en: Add a `mod.rs` file into the `subfolder` folder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`subfolder`文件夹中添加一个`mod.rs`文件。
- en: Declare `another_file` into `mod.rs`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mod.rs`中声明`another_file`。
- en: Declare `subfolder` into `main.rs`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.rs`中声明`subfolder`。
- en: You certainly wonder, why `mod.rs`? It's the norm in Rust—when you import a
    module, which is a folder, the compiler will look for a file named `mod.rs` into
    it. The `mod.rs` files are mainly used for re-exporting modules' content outside.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定想知道，为什么是`mod.rs`？这是Rust的标准——当你导入一个模块，即一个文件夹时，编译器会查找其中的`mod.rs`文件。`mod.rs`文件主要用于将模块的内容重新导出。
- en: 'Let''s now write down the code to do this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们写下实现这个功能的代码：
- en: 'Inside `mod.rs`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mod.rs`内部：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside `main.rs`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.rs`内部：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you can use everything that is in `another_file` (as long as it''s public!).
    Consider the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`another_file`中的所有内容（只要它是公共的！）！考虑以下示例：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will certainly have noticed that we declared `another_file` publicly in
    `mod.rs`. It's simply because `main.rs` won't be able to access its content otherwise,
    as it's not at the same module level. However, a child module can access a parent's
    private items.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经注意到我们在`mod.rs`中公开声明了`another_file`。这仅仅是因为`main.rs`否则无法访问其内容，因为它不在同一模块级别。然而，子模块可以访问父模块的私有项。
- en: 'To conclude this small part, let''s talk about the third type of modules: the
    module blocks (yes, as simple as that).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这个小部分，让我们谈谈第三种类型的模块：模块块（是的，就这么简单）。
- en: 'Just like you import a file or a folder, you can create a module block by using
    the same keyword:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像导入文件或文件夹一样，你可以通过使用相同的关键字来创建模块块：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And you now created a new module named `a_module` containing a public structure.
    The rules described previously are applied the same way to this last kind of module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个名为`a_module`的新模块，其中包含一个公共结构。之前描述的规则以相同的方式应用于这种类型的最后一个模块。
- en: You now know how to use modules to import files and folders. Let's start writing
    down our game!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何使用模块来导入文件和文件夹。让我们开始写下我们的游戏！
- en: Tetris
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沙罗曼蛇
- en: Okay, we're now ready to start writing down our tetris!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在准备好开始写下我们的沙罗曼蛇游戏了！
- en: 'First, let''s fulfill our `main.rs` file in order to check whether everything
    is working as expected:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们完善我们的`main.rs`文件，以检查一切是否按预期工作：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You''ll note the following line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到以下行：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It allows you to avoid using all your computer CPU time needlessly and only
    rendering 60 times every second at most.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你避免无谓地使用所有计算机CPU时间，并且最多每秒渲染60次。
- en: 'Now run the following in your terminal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的终端中运行以下命令：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you have a window filled with red (just as shown in the following screenshot),
    then everything's fine!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个充满红色的窗口（就像以下截图所示），那么一切正常！
- en: '![](img/00009.jpeg)*Figure 2.4*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00009.jpeg)*图2.4*'
- en: Creating a window
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口
- en: The previous example created a window and drew into it. Now let's see how it
    did that!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例创建了一个窗口并在其中绘制。现在让我们看看它是如何做到的！
- en: 'Before going any further, we need to import the SDL2 crate, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要导入SDL2包，如下所示：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this, we now have access to everything it contains.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在可以访问它包含的所有内容。
- en: 'Now that we''ve imported `sdl2`, we need to initialize an SDL context:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了`sdl2`，我们需要初始化一个SDL上下文：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once done, we need to get the video subsystem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们需要获取视频子系统：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now create the window:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建窗口了：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A few notes on these methods:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些方法的一些注意事项：
- en: The parameters for the `window` method are title, width, height
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window`方法的参数是标题、宽度和高度'
- en: '`.position_centered()` gets the window in the middle of the screen'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.position_centered()`将窗口放置在屏幕中间'
- en: '`.opengl()` makes the SDL use `opengl` to render'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.opengl()`使SDL使用`opengl`进行渲染'
- en: '`.build()` creates the window by applying all previously received parameters'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.build()`通过应用所有之前接收到的参数来创建窗口'
- en: '`.expect` panics with the given message if an error occurred'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，`.expect`会使用给定的消息引发恐慌
- en: If you try to run this sample of code, it'll display a window and close it super
    quickly. We now need to add an event loop in order to keep it running (and then
    to manage user inputs).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行这段代码示例，它将显示一个窗口并迅速关闭。我们现在需要添加一个事件循环来保持其运行（然后管理用户输入）。
- en: 'At the top of the file, you need to add this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，你需要添加以下内容：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s actually write our event manager. First, we need to get the event
    handler as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实际编写我们的事件管理器。首先，我们需要获取事件处理器，如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we create an infinite loop to loop over events:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个无限循环来遍历事件：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To go back on these two lines:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要回到这两行：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`loop` is a keyword that allows creating an infinite loop in Rust. An interesting
    feature though is that you can add a label to your loops (so, `while` and `for`
    as well). In this case, we added the label `running` to the main loop. The point
    is to be able to break directly an upper loop without having to set a variable.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`是一个关键字，允许在Rust中创建无限循环。虽然这是一个有趣的功能，但你也可以给你的循环添加标签（所以`while`和`for`也可以）。在这种情况下，我们给主循环添加了标签`running`。目的是能够直接跳出上层循环，而无需设置变量。'
- en: Now, if we receive a `quit` event (pressing the cross of the window) or if you
    press the *Esc* key, the program quits.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们收到一个`quit`事件（点击窗口的叉号）或者如果你按下*Esc*键，程序将退出。
- en: Now you can run this code and you'll have a window.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行这段代码，你将有一个窗口。
- en: Drawing
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制
- en: 'We now have a working window; it''d be nice to draw into it. First, we need
    to get the window''s canvas before starting the main loop:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以工作的窗口；将其绘制进去会很好。首先，在开始主循环之前，我们需要获取窗口的画布：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A few explanations for the preceding code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面代码的一些解释：
- en: '`into_canvas` transforms the window into a canvas so that we can manipulate
    it more easily'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`into_canvas`将窗口转换成画布，这样我们就可以更容易地操作它'
- en: '`target_texture` activates texture rendering support'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_texture`激活纹理渲染支持'
- en: '`present_vsync` enables the v-sync (also known as vertical-synchronization) limit'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`present_vsync`启用v同步（也称为垂直同步）限制'
- en: '`build` creates the canvas by applying all previously set parameters'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`通过应用所有之前设置的参数创建画布'
- en: 'Then we''ll create a texture that we''ll paste onto the window''s canvas. First,
    let''s get the texture creator, but before that, add this include at the top of
    the file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个纹理，并将其粘贴到窗口的画布上。首先，让我们获取纹理创建器，但在那之前，在文件顶部添加以下包含：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can get the texture creator:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以获取纹理创建器：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'OK! Now we need to create a rectangle. To make things easier to read, we''ll
    create a constant that will be the texture''s size (better to put it at the head
    of the file, just after the imports, for readability reasons):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在我们需要创建一个矩形。为了使代码更易于阅读，我们将创建一个常量，它将是纹理的大小（最好将其放在文件头部，紧随导入之后，以提高可读性）：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s create a texture with a `32x32` size:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个大小为`32x32`的纹理：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Good! Now let''s color it. First, add this import at the top of the file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在让我们给它上色。首先，在文件顶部添加以下导入：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We use the canvas to draw our square texture:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用画布来绘制我们的方形纹理：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'An explanation of the preceding code is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面代码的解释如下：
- en: '`set_draw_color` sets the color to be used when drawing occurs. In our case,
    it''s green.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_draw_color`设置绘制时使用的颜色。在我们的例子中，它是绿色。'
- en: '`clear` washes/clears the texture so it''ll be filled with green.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear`清洗/清除纹理，使其被绿色填充。'
- en: Now, we just have to draw this square texture onto our window. In order to make
    it work, we need it to be drawn into the main loop but right after the event loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将这个方形纹理绘制到我们的窗口上。为了使其工作，我们需要在主循环中绘制，但要在事件循环之后。
- en: 'One thing to note before we continue: when drawing with the `SDL2`, the (0,
    0) coordinates are at the top-left of a window, not at the bottom-left. The same
    goes for all shapes.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一点需要注意：在使用`SDL2`绘制时，(0, 0)坐标位于窗口的左上角，而不是左下角。对于所有形状都一样。
- en: 'Add this import at the top of your file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下导入：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s draw. In order to be able to update the rendering of your window,
    you need to draw inside the main loop (and after the event loop). So firstly,
    let''s fill our window with red:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来绘制。为了能够更新窗口的渲染，你需要在主循环中（并且在事件循环之后）进行绘制。所以首先，让我们用红色填充我们的窗口：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we copy our texture into the window in the top-left corner with a 32x32
    size:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的纹理以32x32的大小复制到窗口的左上角：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we update the window''s display:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新窗口的显示：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So if we take a look at the full code, we now have the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们看一下完整的代码，我们现在有以下内容：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you run this code, you should have a red window with a small green rectangle
    at the top-left (just as shown in the following screenshot):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你应该有一个红色的窗口，在左上角有一个小绿色的矩形（正如以下截图所示）：
- en: '![](img/00010.jpeg)*Figure 2.5*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5](img/00010.jpeg)*图2.5*'
- en: Now, what about switching the color of our small rectangle every second? Alright,
    first thing, we need to create another rectangle. To make things easier, we'll
    write a small function that will create texture.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于每秒切换我们小矩形的颜色，首先，我们需要创建另一个矩形。为了使事情更简单，我们将编写一个小的函数来创建纹理。
- en: 'As usual, add the following import at the top of your file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，在文件顶部添加以下导入：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For convenience, we''ll create a small enum to indicate the color as well:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们将创建一个小枚举来指示颜色：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To make our lives easier, we''ll handle errors outside of the next function,
    so no need to handle them directly here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的生活更简单，我们将在下一个函数外部处理错误，因此在这里无需直接处理它们：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You''ll note that the function returns an `Option` type, wrapping a texture.
    `Option` is an enum containing two variants: `Some` and `None`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到该函数返回一个包裹纹理的 `Option` 类型。`Option` 是一个包含两个变体的枚举：`Some` 和 `None`。
- en: Playing with Options
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转选项
- en: To explain briefly how it works, when the `Option` type is `Some`, it simply
    means it contains a value whereas `None` doesn't. It has already been explained
    in [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7), *Basics
    of Rust*, but here's a little recap just in case you need one. We can compare
    this mechanism with pointers in C-like languages; when the pointer is null, there
    is no data to access. The same goes for `None`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 简要解释一下它是如何工作的，当 `Option` 类型是 `Some` 时，它仅仅意味着它包含一个值，而 `None` 则不包含。这已经在 [第1章](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7)
    的 *Rust基础知识* 中解释过了，但这里有一个简短的回顾以防万一你需要它。我们可以将这种机制与C语言类似的指针进行比较；当指针为空时，没有数据可以访问。对于
    `None` 也是如此。
- en: 'Here''s a short example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简短的例子：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'So here, if the divider is `0`, we can''t divide or we''ll get an error. Instead
    of setting an error or returning a complicated type, we just return an `Option`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，如果分隔符是 `0`，我们无法进行分割，否则会出错。与其设置错误或返回一个复杂的数据类型，我们只需返回一个 `Option`：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, `x` is equal to `Some(3)` and `y` is equal to `None`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x` 等于 `Some(3)`，而 `y` 等于 `None`。
- en: The biggest advantage of this type compared to `null` is that if we have `Some`,
    you're sure that the data is valid. And in addition, when it's `None`, you can't
    accidentally read its content, it's simply impossible in Rust (and if you try
    to `unwrap` it, your program will panic immediately, but at least, you'll know
    what failed and why—no magical segmentation fault).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `null` 相比，这种类型最大的优点是，如果我们有 `Some`，你就可以确信数据是有效的。此外，当它是 `None` 时，你无法意外地读取其内容，在Rust中这是不可能的（如果你尝试
    `unwrap` 它，你的程序将立即崩溃，但至少，你会知道是什么失败了以及为什么——没有神奇的段错误）。
- en: You can take a look at its documentation at [https://doc.rust-lang.org/std/option/enum.Option.html](https://doc.rust-lang.org/std/option/enum.Option.html).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看其文档[https://doc.rust-lang.org/std/option/enum.Option.html](https://doc.rust-lang.org/std/option/enum.Option.html)。
- en: 'Let''s explain what happens here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里发生了什么：
- en: We create a texture or return `None` if the creation fails.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果创建失败，我们创建纹理或返回 `None`。
- en: We set the color and then fulfill the texture with it.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置颜色，然后用它填充纹理。
- en: We return the texture.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回纹理。
- en: If we return `None`, it simply means an error occurred. Also, for now, this
    function only handles two colors, but it's pretty easy to add more if you want.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们返回 `None`，这仅仅意味着发生了错误。目前，这个函数只处理两种颜色，但如果你想添加更多，那也很容易。
- en: 'It might look a bit complicated at the moment, but it''ll make our life easier
    afterward. Now, let''s call this function by creating a blue square of size 32x32:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它可能看起来有点复杂，但之后它会让我们更容易生活。现在，让我们通过创建一个32x32像素的蓝色正方形来调用这个函数：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Easy, right?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？
- en: 'Now we can just put pieces together. I''ll let you try to handle the color
    switch. A small tip: take a look at the `SystemTime` struct. You can refer to
    its documentation at [https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html](https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将各个部分组合起来。我会让你尝试处理颜色切换。一个小提示：看看 `SystemTime` 结构体。你可以参考其文档[https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html](https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html)。
- en: Solution
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'I guess you did it without any issues, but in any case, here''s the code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你没有遇到任何问题，但无论如何，这里是有问题的代码：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can now see the small rectangle at the top-left switching color every second.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到左上角的小矩形每秒切换颜色。
- en: Loading images
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载图像
- en: Uptill now, we've only created simple textures, but what about loading images
    instead?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只创建了简单的纹理，但如果我们加载图像会怎样呢？
- en: Before trying to go through this, check whether you have installed the `SDL2_image`
    library (it's not included by default with the SDL2 library!). If not, you can
    install it by following the upcoming sections.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试进行此操作之前，检查你是否已经安装了`SDL2_image`库（它默认不包括在SDL2库中！）如果没有，你可以通过接下来的部分进行安装。
- en: Installing SDL2_image on Mac
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装SDL2_image
- en: 'Just run the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行以下命令：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And you're good to go!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你就可以开始了！
- en: Installing SDL2_image on Linux
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装SDL2_image
- en: 'Depending on your package management tool, run the following to install `SDL2_image`
    on Linux:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的包管理工具，在Linux上运行以下命令来安装`SDL2_image`：
- en: 'For `apt package manager` use the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`apt包管理器`，使用以下命令：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For `dnf package manager` use the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dnf包管理器`，使用以下命令：
- en: '[PRE61]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For `yum package manager` use the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`yum包管理器`，使用以下命令：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And you're good to go!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你就可以开始了！
- en: Installing SDL2_image on Windows
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装SDL2_image
- en: For the Windows platform, the simplest way is to go to [https://www.libsdl.org/projects/SDL_image/](https://www.libsdl.org/projects/SDL_image/)
    and download it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows平台，最简单的方法是访问[https://www.libsdl.org/projects/SDL_image/](https://www.libsdl.org/projects/SDL_image/)并下载它。
- en: Playing with features
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转功能
- en: 'By default, you can''t use the `image` module with `sdl2`, we need to activate
    it. To do so, we need to update our `Cargo.toml` file by adding a new section
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你不能使用`image`模块与`sdl2`一起，我们需要激活它。为此，我们需要更新我们的`Cargo.toml`文件，添加一个新的部分，如下所示：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`default` means that by default, the following features (`"sdl2/image"`) will
    be enabled. Now, let''s explain what `"sdl2/image"` means; `sdl2` refers to the
    crate where we want to enable a feature and `image` is the feature we want to
    enable.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`表示默认情况下，以下功能（`"sdl2/image"`）将被启用。现在，让我们解释一下`"sdl2/image"`的含义；`sdl2`指的是我们想要启用功能的crate，而`image`是我们想要启用的功能。'
- en: 'Of course, if you want to enable a feature on the current project, you don''t
    need the `sdl2/` part. Consider the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想在一个当前项目中启用一个功能，你不需要`sdl2/`部分。考虑以下示例：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As I am sure you understood, it''s absolutely possible to chain features activation
    and even to activate multiple features at once! If you want to enable features
    depending on a version number, for example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如我肯定你已经理解的那样，链式激活功能甚至一次激活多个功能是完全可能的！如果你想根据版本号启用功能，例如：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So if you enable the `v3` feature, all the others will be activated as well!
    It can be incredibly useful when you need to handle multiple versions at once.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你启用`v3`功能，所有其他功能也将被激活！当你需要同时处理多个版本时，这可能非常有用。
- en: Now let's go back to our images.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们的图像。
- en: Playing with images
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转图像
- en: 'Just like textures, we need to initialize the image context. Now that we''ve
    activated the `image` feature, we can call the linked functions and import them.
    Let''s add some new imports:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 就像纹理一样，我们需要初始化图像上下文。现在我们已经激活了`image`功能，我们可以调用链接的函数并导入它们。让我们添加一些新的导入：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then we create the image context:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建图像上下文：
- en: '[PRE67]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that the context has been initialized, let''s actually load the image:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上下文已经初始化，让我们实际加载图像：
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A few explanations for the preceding code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面代码的一些解释：
- en: '`load_texture` takes a file path as an argument. Be very careful with paths,
    even more when they''re relative!'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_texture`函数接受一个文件路径作为参数。对路径要非常小心，尤其是当它们是相对路径时！'
- en: 'After that, it''s just like we did with other textures. Let''s put our image
    into our Window''s background:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它就像我们处理其他纹理一样。让我们把我们的图像放入窗口的背景中：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To sum everything up, here''s what your project''s folder should look like
    now:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，现在你的项目文件夹应该看起来像这样：
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And that's it!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！
- en: 'Here''s the full code in case you missed a step:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的代码，以防你错过了某个步骤：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In my case, it gives the following output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，它给出了以下输出：
- en: '![](img/00011.jpeg)*Figure 2.6*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6](img/00011.jpeg)*图2.6*'
- en: Now that we know how to make Windows and play with events and textures, let's
    see how to save and load high scores from files!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何制作Windows和玩转事件以及纹理，让我们看看如何从文件中保存和加载高分！
- en: Handling files
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: 'Let''s start with the basics. First, let''s open and write into a file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始。首先，让我们打开并写入一个文件：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now let''s explain this code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释这段代码：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Nothing fancy, we just import the `File` type:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么花哨的，我们只是导入`File`类型：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This set of imports is more interesting: we import the `io` module (`self`)
    and the `Write` trait. For the second, if we didn''t import it, we wouldn''t be
    able to use the `write_all` method (because you need to import a trait to use
    its methods):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这组导入更有趣：我们导入`io`模块（`self`）和`Write`特质。对于第二个，如果我们没有导入它，我们就无法使用`write_all`方法（因为你需要导入一个特质来使用它的方法）：
- en: '[PRE75]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We declared a function named `write_into_file` that takes a filename and the
    content you want to write into the file as arguments. (Note that the file will
    be overwritten by this content!) It returns an `io::Result` type. It is an alias
    over the normal `Result` type (its documentation is at [https://doc.rust-lang.org/stable/std/result/enum.Result.html](https://doc.rust-lang.org/stable/std/result/enum.Result.html))
    declared as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`write_into_file`的函数，它接受一个文件名和要写入文件的内容作为参数。（注意，文件将被此内容覆盖！）它返回一个`io::Result`类型。它是对正常`Result`类型的别名（其文档在[https://doc.rust-lang.org/stable/std/result/enum.Result.html](https://doc.rust-lang.org/stable/std/result/enum.Result.html)）声明如下：
- en: '[PRE76]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The only difference is that in case of error, the error type is already defined.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于，在出错的情况下，错误类型已经定义。
- en: I recommend that you to take a look at its documentation in case you want to
    go further, at [https://doc.rust-lang.org/stable/std/io/type.Result.html](https://doc.rust-lang.org/stable/std/io/type.Result.html).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你查看其文档，以防你想进一步了解，在[https://doc.rust-lang.org/stable/std/io/type.Result.html](https://doc.rust-lang.org/stable/std/io/type.Result.html)。
- en: So if our function worked without errors, it'll return `Ok(())`; it's the `Ok`
    variant containing an empty tuple which is considered the Rust equivalent of the
    `void` type. In case of error, it'll contain an `io::Error`, and it'll be up to
    you to handle it (or not). We'll come back to error handling a bit later.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们的函数在没有错误的情况下工作，它将返回`Ok(())`；这是包含空元组的`Ok`变体，被认为是Rust中`void`类型的等价物。在出错的情况下，它将包含一个`io::Error`，处理它（或不处理）将取决于你。我们稍后会回到错误处理。
- en: 'Now let''s look at the next line:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看下一行：
- en: '[PRE77]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we call the static method `create` of the `File` type. If the file exists,
    it'll be truncated and if it doesn't, it'll be created. More information about
    this method can be found at [https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create](https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们调用`File`类型的静态方法`create`。如果文件存在，它将被截断；如果不存在，它将被创建。关于这个方法的更多信息可以在[https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create](https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create)找到。
- en: 'Now let''s look at this strange `?` symbol. It''s a syntactic sugar over the
    `try!` macro. The `try!` macro is very simple to understand and its code can be
    resumed as this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看这个奇怪的`?`符号。它是`try!`宏的语法糖。`try!`宏非常容易理解，其代码可以总结如下：
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'So that''s pretty easy, but annoying to rewrite over and over, so the Rust
    teams decided to first introduce the `try!` macro and then after a long consensus,
    decided to add the `?` syntactic sugar over it (it also works with the `Option`
    type). However, both code pieces are still working, so you can perfectly do as
    well:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这很简单，但反复重写很烦人，所以Rust团队决定首先引入`try!`宏，然后在经过长时间的共识后，决定在它上面添加`?`语法糖（它也适用于`Option`类型）。然而，这两个代码片段仍然有效，所以你可以做得很好：
- en: '[PRE79]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It''s exactly the same. Alternatively, you can write the full version too:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它完全一样。或者，你也可以写完整的版本：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: It's up to you, but now you know what options you have!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你，但现在你知道你有哪些选项了！
- en: 'Now let''s check the last line:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查最后一行：
- en: '[PRE81]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Nothing fancy here; we write all our data into the file. We just need to convert
    (it's not really a conversion in this case, more like getting internal data) our
    `&str` into a slice of `u8` (so a `&[u8]`).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的地方；我们将所有数据写入文件。我们只需要将我们的`&str`转换为`u8`切片（所以是`&[u8]`）（在这种情况下，这并不是真正的转换，更像是获取内部数据）。
- en: 'Now that we have a function to write a file, it''d be nice to be able to read
    from a file as well:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了写文件的函数，能够从文件中读取也很好：
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now let''s go over what this function does quickly:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速了解一下这个函数的功能：
- en: '[PRE83]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This time, it only takes a filename as an argument and returns a `String` if
    the reading was successful:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，它只接受一个文件名作为参数，如果读取成功，则返回一个`String`：
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Just like before, we open the file. Then we create a mutable `String` where
    the file content will be stored and finally we read all the file content at once
    with the `read_to_string` method (the `String` is reallocated as many times as
    needed). This method will fail if the string isn't proper UTF-8.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们打开文件。然后我们创建一个可变的`String`，其中将存储文件内容，最后我们使用`read_to_string`方法一次性读取所有文件内容（`String`根据需要重新分配）。如果字符串不是正确的UTF-8，这个方法将失败。
- en: 'And to finish, if everything went fine, we return our content:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一切顺利，我们返回我们的内容：
- en: '[PRE85]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: So now, let's see how we can use this in our future tetris.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在让我们看看我们如何在未来的俄罗斯方块中使用它。
- en: Saving/loading high scores
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存/加载高分
- en: 'To keep things simple, we''ll have a very simple file format:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将有一个非常简单的文件格式：
- en: On the first line, we store the best scores
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行，我们存储最佳分数
- en: On the second line, we store the highest number of lines
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二行，我们存储最高行数
- en: 'Let''s start by writing the `save` function:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从编写`save`函数开始：
- en: '[PRE86]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'It was a small lie: there are actually two functions. The first one is just
    here to make the code smaller and easier to read even though we need to explain
    what it does, because we''re about to talk about a big feature from Rust—**iterators**!'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这其实是一个小谎言：实际上有两个函数。第一个函数只是在这里使代码更小、更容易阅读，尽管我们需要解释它所做的工作，因为我们即将讨论Rust的一个大特性——**迭代器**！
- en: Iterators
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: The Rust documentation describes an iterator as *Composable external iteration.*
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Rust文档将迭代器描述为*可组合的外部迭代器*。
- en: 'They''re used a lot in idiomatic Rust code on collection types (`slice`, `Vec`,
    `HashMap`, and so on) so it''s very important to learn to master them. This code
    will allow us to have a nice introduction. Let''s look at the code now:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在Rust代码中用于集合类型（`slice`、`Vec`、`HashMap`等）非常普遍，因此学习掌握它们非常重要。这段代码将为我们提供一个很好的入门。现在让我们看看代码：
- en: '[PRE87]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This is quite difficult to read and understand for the moment, so let''s rewrite
    it as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这个代码很难读和理解，所以让我们按照以下方式重写它：
- en: '[PRE88]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Better (or at least more readable!). Now let''s go step by step, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 更好（或者至少更易读！）现在让我们一步一步地来做，如下所示：
- en: '[PRE89]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here, we create an iterator from our slice. A really important and fundamental
    thing to note about iterators in Rust; they're lazy. Creating an iterator doesn't
    cost anything more than the size of the type (generally a structure containing
    a pointer and an index). Until the `next()` method is called, nothing happens.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从切片创建一个迭代器。关于Rust中的迭代器有一个非常重要和基本的事情需要注意；它们是惰性的。创建迭代器并不需要比类型大小更多的开销（通常是一个包含指针和索引的结构）。直到调用`next()`方法之前，什么都不会发生。
- en: 'So now we have an iterator, awesome! Let''s check the next step:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个迭代器，太棒了！让我们检查下一步：
- en: '[PRE90]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We call the iterator''s `map` method. What it does is simple: it converts the
    current type into another one. So here, we convert a `u32` into a `String`.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用迭代器的`map`方法。它所做的是简单的：将当前类型转换为另一种类型。所以在这里，我们将`u32`转换为`String`。
- en: 'Really important to note: at this point, the iterator still hasn''t done anything.
    Keep in mind that nothing is done until the `next()` method is called!'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意：在这个阶段，迭代器还没有做任何事情。请记住，直到调用`next()`方法之前，什么都不会发生！
- en: '[PRE91]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: And now we call the `collect()` method. It'll call the `next()` method of our
    iterator as long as it didn't get all elements and store them into a `Vec`. This
    is where the `map()` method will be called on every element of our iterator.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们调用`collect()`方法。只要迭代器没有获取到所有元素并将它们存储到`Vec`中，它就会调用迭代器的`next()`方法。这就是`map()`方法将在迭代器的每个元素上被调用的地方。
- en: 'And finally the last step:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步：
- en: '[PRE92]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This method (as its name indicates) joins all the elements of the `Vec` into
    a `String` separated by the given `&str` (so, `" "` in our case).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法（正如其名称所示）将`Vec`的所有元素连接成一个由给定`&str`（在我们的例子中是`" "`）分隔的`String`。
- en: Finally, if we give `&[1, 14, 5]` to the `slice_to_string` function, it'll return
    a `String` containing `"1 14 5"`. Pretty convenient, right?
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们给`slice_to_string`函数传递`&[1, 14, 5]`，它将返回一个包含`"1 14 5"`的`String`。非常方便，对吧？
- en: If you want to go a bit deeper with the iterators, you can take a look at the
    blog post at [https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust](https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust)
    or directly take a look at the iterator official documentation at [https://doc.rust-lang.org/stable/std/iter/index.html](https://doc.rust-lang.org/stable/std/iter/index.html).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对迭代器有更深入的了解，可以查看博客文章 [https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust](https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust)，或者直接查看迭代器官方文档
    [https://doc.rust-lang.org/stable/std/iter/index.html](https://doc.rust-lang.org/stable/std/iter/index.html)。
- en: 'It''s time to go back to our saving function:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到我们的保存函数了：
- en: '[PRE93]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Once we have converted our slices to `String`, we write them into the `scores.txt`
    file. The `is_ok()` method call just informs the caller of the `save_highscores_and_lines()`
    function if everything has been saved as expected or not.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将我们的切片转换为 `String`，我们就将它们写入 `scores.txt` 文件。`is_ok()` 方法调用只是通知 `save_highscores_and_lines()`
    函数是否已按预期保存一切。
- en: Now that we can save scores, it'd be nice to be able to get them back when the
    tetris game is starting!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够保存分数，当俄罗斯方块游戏开始时能够获取它们会很好！
- en: Reading formatted data from files
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取格式化数据
- en: 'As you will certainly have guessed at this point, we''ll use iterators once
    again. This is what the loading function will look like:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如你此刻肯定已经猜到的，我们还会再次使用迭代器。这就是加载函数的样子：
- en: '[PRE94]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Once again, not easy to understand, at first sight. So let's explain all this!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一开始并不容易理解。所以让我们来解释一下所有这些！
- en: '[PRE95]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Our `line_to_slice()` function does the opposite of `slice_to_string()`; it
    transforms a `&str` into a slice of `u32` (or `&[u32]`). Let''s see the iterator
    now:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `line_to_slice()` 函数是 `slice_to_string()` 的反操作；它将 `&str` 转换为 `u32` 的切片（或
    `&[u32]`）。现在让我们看看迭代器：
- en: '[PRE96]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Just like last time, let''s split the calls:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上次一样，让我们分解一下调用：
- en: '[PRE97]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A bit better! Now let''s explain:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微好一点！现在让我们来解释一下：
- en: '[PRE98]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We create an iterator that will contain all strings between spaces. So `a b` will
    contain `a` and `b`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个迭代器，它将包含所有空格之间的字符串。所以 `a b` 将包含 `a` 和 `b`：
- en: '[PRE99]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This method is particularly interesting since it''s the merge of two others:
    `filter()` and `map()`. We already know `map()` but what about `filter()`? If
    the condition isn''t verified (so if the returned value of the closure is `false`),
    the iterator won''t pass the value to the next method call. `filter_map()` works
    the same at this point: if the closure returns `None`, the value won''t be passed
    to the next method call.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法特别有趣，因为它融合了两种其他方法：`filter()` 和 `map()`。我们已经知道了 `map()`，那么 `filter()` 呢？如果条件没有得到验证（也就是说，如果闭包返回的值是
    `false`），迭代器不会将值传递给下一个方法调用。在这个点上，`filter_map()` 的工作方式相同：如果闭包返回 `None`，则值不会传递给下一个方法调用。
- en: 'Now let''s focus on this part:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于这部分：
- en: '[PRE100]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here, we try to convert `&str` into `u32`. The `parse()` method returns a `Result`
    but the `filter_map()` expects an `Option` so we need to convert it. That's what
    the `ok()` method is for! If your `Result` is an `Ok(value)`, then it'll convert
    it into a `Some(value)`. However, if it's an `Err(err)`, it'll convert it into
    a `None` (but you'll lose the error value).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试将 `&str` 转换为 `u32`。`parse()` 方法返回一个 `Result`，但 `filter_map()` 期望一个 `Option`，因此我们需要进行转换。这就是
    `ok()` 方法的作用！如果你的 `Result` 是 `Ok(value)`，那么它将转换为 `Some(value)`。然而，如果它是 `Err(err)`，它将转换为
    `None`（但你会丢失错误值）。
- en: To sum this up, this whole line tries to convert a `&str` into a number and
    ignores it if the conversion fails so it's not added to our final `Vec`. Amazing
    how much we can do with such small code!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这一行尝试将 `&str` 转换为数字，如果转换失败则忽略它，所以它不会被添加到我们的最终 `Vec` 中。代码如此之小，我们却能做这么多的事情真是令人惊讶！
- en: 'And finally:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后：
- en: '[PRE101]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We `collect` all the successful conversions into a `Vec` and return it.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有成功的转换收集到一个 `Vec` 中并返回它。
- en: 'That''s it for this function, now let''s look at the other one:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就到这里，现在让我们看看另一个：
- en: '[PRE102]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here, if everything went fine (if the file exists and has two lines), we return
    an `Option` containing in the first position the highest scores and in the second
    position the highest number of lines:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果一切顺利（如果文件存在并且有两行），我们将返回一个 `Option`，其中第一个位置包含最高分数，第二个位置包含最高行数：
- en: '[PRE103]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'So if the file exists and we can get its content, we parse the data:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果文件存在并且我们可以获取其内容，我们将解析数据：
- en: '[PRE104]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Another iterator! As usual, let''s rewrite it a bit:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个迭代器！像往常一样，让我们稍微重写一下：
- en: '[PRE105]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'I think you''re starting to get how they work, but just in case you don''t
    know, here''s how:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经开始了解它们是如何工作的了，但以防你不知道，这里是如何做的：
- en: '[PRE106]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We make an iterator containing at most two entries (because of the `2` as the
    first argument) splitting lines:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个最多包含两个条目的迭代器（因为第一个参数是`2`），分割行：
- en: '[PRE107]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We transform each line into a `Vec<u32>` by using the function described in
    the preceding code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用前面代码中描述的函数将每一行转换成`Vec<u32>`：
- en: '[PRE108]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: And finally, we collect those `Vec`s into a `Vec<Vec<u32>>`, which should only
    contain two entries.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些`Vec`收集到一个`Vec<Vec<u32>>`中，它应该只包含两个条目。
- en: 'Let''s look at the next line now:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看下一行：
- en: '[PRE109]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'As said before, if we don''t have two entries inside our `Vec`, it means something
    is wrong with the file:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果我们`Vec`中没有两个条目，这意味着文件有问题：
- en: '[PRE110]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In case our `Vec` has two entries, we can get the corresponding values. Since
    the `pop` method removes the last entry of the `Vec`, we get them in reverse (even
    though we return high scores first then the highest number of lines):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`Vec`有两个条目，我们可以获取相应的值。由于`pop`方法移除了`Vec`的最后一个条目，所以我们以相反的顺序获取它们（即使我们首先返回高分然后是最高行数）：
- en: '[PRE111]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Then everything else is just the error handling. As we said previously, if any
    error occurs, we return `None`. In this case, it's not really important to handle
    the error since it's just high scores. If we have errors with the `sdl` libraries,
    nothing will work as expected, so we need to handle them to avoid a panic.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然后其余的只是错误处理。正如我们之前所说的，如果发生任何错误，我们返回`None`。在这种情况下，处理错误并不是很重要，因为这只是高分。如果我们有`sdl`库的错误，什么都不会按预期工作，所以我们需要处理它们以避免恐慌。
- en: It's now time to really start the game!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是真正开始游戏的时候了！
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we saw a lot of important things like how to use `Cargo` (through
    the `Cargo.toml` file), how to import new crates into a project, thanks to `Cargo`,
    and the basics for Rust modules handling. We even covered how to use iterators
    and read and write files, `SDL2` basics like how to create a window and fill it
    with colors, and loading/creating new textures and images (thanks to the `SDL2-image`
    library!).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了很多重要的事情，比如如何使用`Cargo`（通过`Cargo.toml`文件），如何通过`Cargo`将新的crate导入到项目中，以及Rust模块处理的基础。我们甚至涵盖了如何使用迭代器、读取和写入文件，`SDL2`的基础，比如如何创建窗口并用颜色填充它，以及加载/创建新的纹理和图像（多亏了`SDL2-image`库！）。
- en: In [Chapter 3](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Events
    and Basic Game Mechanisms*, we'll start the implementation of the tetris game,
    so be sure to master everything explained in this chapter before starting the
    next one!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7)，“事件和基本游戏机制”中，我们将开始实现俄罗斯方块游戏，所以请确保在开始下一章之前掌握本章中解释的所有内容！
