- en: Starting with SDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting to write the Tetris, a few things remain to be talked about,
    such as crates, which we'll be using a lot (and you'll be using a lot as well
    once you're *rusting* on your own!). Let's start with crates!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Rust crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rust, packages (both binaries and libraries) are named crates. You can find
    a lot of them on `crates.io`. Today, we'll use the SDL2 crate in order to make
    our tetris, but before even thinking about this, we need to install the `SDL2`
    library that is used by the `SDL2` crate!
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going any further, we need to install the SDL library.
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2 on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on your package management tool, run the following to install SDL2
    on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apt package mananger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`dnf package manager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'yum package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once done, your SDL2 installation is ready!
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2 on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install SDL2 on Mac, Simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You're good to go!
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2 on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All these installation instructions come directly from the Rust SDL2 crate.
  prefs: []
  type: TYPE_NORMAL
- en: Windows with Build Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few steps will be required in order to make all of it work. Follow the guide!
  prefs: []
  type: TYPE_NORMAL
- en: Download the `mingw` and `msvc` development libraries from [http://www.libsdl.org/](http://www.libsdl.org/)
    (`SDL2-devel-2.0.x-mingw.tar.gz` and `SDL2-devel-2.0.x-VC.zip`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack to folders of your choice. (You can delete it afterward.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following folder structure in the same folder as your `Cargo.toml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `lib` and `dll` files from the source archive to the directories we
    created in step 3 as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Build Script. If you don''t already have one, put this in your `Cargo.toml`
    file under `[package]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file in the same directory as `Cargo.toml` called `build.rs` and write
    this into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On build, the Build Script will copy the needed DLLs into the same directory
    as your `Cargo.toml` file. You probably don''t want to commit these to any Git
    repositories though, so add the following line to your `.gitignore` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When you're shipping your game, make sure that you copy the corresponding `SDL2.dll`
    to the same directory that your compiled `exe` is in; otherwise, the game won't
    launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And now your project should build and run on any Windows computer!
  prefs: []
  type: TYPE_NORMAL
- en: Windows (MinGW)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few steps will be required in order to make all of it work. Follow the guide!
  prefs: []
  type: TYPE_NORMAL
- en: Download `mingw` development libraries from [http://www.libsdl.org/](http://www.libsdl.org/)
    (`SDL2-devel-2.0.x-mingw.tar.gz`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack to a folder of your choice. (You can delete it afterward.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy all `lib` files from the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, copy it to this path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, you can copy to your library folder of choice and ensure that
    you have a system environment variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For Rustup users, this folder will be at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the current toolchain is probably `stable-x86_64-pc-windows-gnu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `SDL2.dll` from the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The copied `SDL2.dll` is pasted into your cargo project, right next to your
    `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: When you're shipping your game, make sure that you copy `SDL2.dll` to the same
    directory that your compiled `exe` is in; otherwise, the game won't launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Windows (MSVC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few steps will be required in order to make all of it work. Follow the guide!
  prefs: []
  type: TYPE_NORMAL
- en: Download MSVC development libraries from [http://www.libsdl.org/](http://www.libsdl.org/)
    `SDL2-devel-2.0.x-VC.zip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unpack `SDL2-devel-2.0.x-VC.zip` to a folder of your choice. (You can delete
    it afterward.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy all `lib` files from the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lib` files will be pasted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they''ll be pasted to your library folder of choice. Ensure
    that you have a system environment variable with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the current toolchain is probably `stable-x86_64-pc-windows-msvc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `SDL2.dll` from the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The copied `SDL2.dll` is pasted into your cargo project, right next to your
    `Cargo.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: When you're shipping your game, make sure that you copy `SDL2.dll` to the same
    directory that your compiled `exe` is in; otherwise, the game won't launch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up your Rust project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rust package manager, `cargo`, allows us to create a new project very easily
    with just one command, `cargo new`. Let''s run it as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have a new folder `tetris` containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you ran `cargo new` without the `--bin` flag, then you will have
    a `lib.rs` file instead of `main.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now write this into your `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare that our project's name is `tetris`, its version is `0.0.1`
    (it isn't really important at the moment), and that it has a dependency on the
    `sdl2` crate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the versioning, `Cargo` follows **SemVer** (**Semantic Versioning**). It
    works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[major].[minor].[path]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s exactly what every part means:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `[major]` number version when you make incompatible API changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `[minor]` number version when adding functionalities that don't break
    backward compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `[patch]` number version when you make bug fixes that don't break
    backward compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not vital to know this, but it's always nice to be aware of it in case
    you intend to write crates in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo and crates.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very important thing to note with Rust's ecosystem is that `Cargo` is really
    important if not central. It makes things much easier and all Rust projects are
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo isn''t only a build tool, it''s also Rust''s default package manager.
    If you need to download a dependency, `Cargo` will do it. You can find all available
    published crates on [https://crates.io/](https://crates.io/). Consider the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)*Figure 2.1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the `sdl2` crate, we can see on its page ([https://crates.io/crates/sdl2](https://crates.io/crates/sdl2))
    some interesting and useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)*Figure 2.2*'
  prefs: []
  type: TYPE_NORMAL
- en: On the right-hand side, you can see the version history. It can be useful to
    check whether you have the last version or not and whether the crate is still
    maintained.
  prefs: []
  type: TYPE_NORMAL
- en: In the middle, you have the crate's dependencies. It's always interesting to
    know what you'll need to install in addition to your crate if something is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally on the left-hand side, you have a few links that might be very
    useful (not always those ones, it depends on what has been put into the `Cargo.toml`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation**: This is where the documentation is hosted (even though I
    generally recommend [docs.rs](https://docs.rs/), I''ll talk about it in a moment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: This is where this crate''s repository is hosted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependent crates**: This is the list of the crates depending on this one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Homepage**: If the crate has a website, you can go to its link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time to go back to `docs.rs` for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The docs.rs documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every published crate on `crates.io` gets its documentation generated and hosted
    on [https://docs.rs/](https://docs.rs/). If the crate's documentation hasn't been
    published by anyone anywhere online, you'll find it there as long as it has been
    published. With `crates.io` and `rust-lang.org`, it's one of the most known places
    of the Rust ecosystem, so bookmark it and doesn't lose it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of what [docs.rs](https://docs.rs/) looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)*Figure 2.3*'
  prefs: []
  type: TYPE_NORMAL
- en: Back to our Cargo.toml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To go back to our `Cargo.toml` file, it's also possible to use crates directly
    from their repositories; you just have to specify this when adding the dependency
    in your `Cargo.toml` file. Generally, the published version is less advanced than
    the one on the corresponding repository but will be more stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, if we want to use the repository version for the `sdl2` crate,
    we need to write in our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Easy right? `Cargo` can also start tests or benchmarks, install binaries, handle
    special builds through a build file (by default in `build.rs`), or handle features
    (we'll come back to this point later in this part).
  prefs: []
  type: TYPE_NORMAL
- en: To put it simply, it's a complete tool, and explaining most of its features
    would take a lot of time and space, so we'll just stick to the basics for the
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a very good documentation/tutorial on Cargo at [http://doc.crates.io/index.html](http://doc.crates.io/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Rust's modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going any further, we need to talk about how file hierarchy works in
    Rust through its modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to know is that files and folders are handled as modules in
    Rust. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to declare that a module is in the `another_file.rs` file, you''ll
    need to add to your `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You will now have access to everything contained in `another_file.rs` (as long
    as it's public).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to know: you can only declare modules whose files are on the
    same level as your current module/file. Here''s a short example to sum this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to declare a module referring to `another_file.rs` directly into
    `main.rs`, as shown preceding, it''ll fail because there are no `another_file.rs`
    in `src/`. In this case, you''ll need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `mod.rs` file into the `subfolder` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare `another_file` into `mod.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare `subfolder` into `main.rs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You certainly wonder, why `mod.rs`? It's the norm in Rust—when you import a
    module, which is a folder, the compiler will look for a file named `mod.rs` into
    it. The `mod.rs` files are mainly used for re-exporting modules' content outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write down the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `mod.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use everything that is in `another_file` (as long as it''s public!).
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You will certainly have noticed that we declared `another_file` publicly in
    `mod.rs`. It's simply because `main.rs` won't be able to access its content otherwise,
    as it's not at the same module level. However, a child module can access a parent's
    private items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this small part, let''s talk about the third type of modules: the
    module blocks (yes, as simple as that).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like you import a file or a folder, you can create a module block by using
    the same keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And you now created a new module named `a_module` containing a public structure.
    The rules described previously are applied the same way to this last kind of module.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to use modules to import files and folders. Let's start writing
    down our game!
  prefs: []
  type: TYPE_NORMAL
- en: Tetris
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, we're now ready to start writing down our tetris!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s fulfill our `main.rs` file in order to check whether everything
    is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It allows you to avoid using all your computer CPU time needlessly and only
    rendering 60 times every second at most.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you have a window filled with red (just as shown in the following screenshot),
    then everything's fine!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00009.jpeg)*Figure 2.4*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example created a window and drew into it. Now let's see how it
    did that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further, we need to import the SDL2 crate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this, we now have access to everything it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve imported `sdl2`, we need to initialize an SDL context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, we need to get the video subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A few notes on these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters for the `window` method are title, width, height
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.position_centered()` gets the window in the middle of the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.opengl()` makes the SDL use `opengl` to render'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.build()` creates the window by applying all previously received parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.expect` panics with the given message if an error occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try to run this sample of code, it'll display a window and close it super
    quickly. We now need to add an event loop in order to keep it running (and then
    to manage user inputs).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, you need to add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s actually write our event manager. First, we need to get the event
    handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an infinite loop to loop over events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To go back on these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`loop` is a keyword that allows creating an infinite loop in Rust. An interesting
    feature though is that you can add a label to your loops (so, `while` and `for`
    as well). In this case, we added the label `running` to the main loop. The point
    is to be able to break directly an upper loop without having to set a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we receive a `quit` event (pressing the cross of the window) or if you
    press the *Esc* key, the program quits.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can run this code and you'll have a window.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have a working window; it''d be nice to draw into it. First, we need
    to get the window''s canvas before starting the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A few explanations for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`into_canvas` transforms the window into a canvas so that we can manipulate
    it more easily'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_texture` activates texture rendering support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`present_vsync` enables the v-sync (also known as vertical-synchronization) limit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build` creates the canvas by applying all previously set parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we''ll create a texture that we''ll paste onto the window''s canvas. First,
    let''s get the texture creator, but before that, add this include at the top of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can get the texture creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'OK! Now we need to create a rectangle. To make things easier to read, we''ll
    create a constant that will be the texture''s size (better to put it at the head
    of the file, just after the imports, for readability reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a texture with a `32x32` size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! Now let''s color it. First, add this import at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the canvas to draw our square texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'An explanation of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_draw_color` sets the color to be used when drawing occurs. In our case,
    it''s green.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear` washes/clears the texture so it''ll be filled with green.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we just have to draw this square texture onto our window. In order to make
    it work, we need it to be drawn into the main loop but right after the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note before we continue: when drawing with the `SDL2`, the (0,
    0) coordinates are at the top-left of a window, not at the bottom-left. The same
    goes for all shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this import at the top of your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s draw. In order to be able to update the rendering of your window,
    you need to draw inside the main loop (and after the event loop). So firstly,
    let''s fill our window with red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we copy our texture into the window in the top-left corner with a 32x32
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the window''s display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So if we take a look at the full code, we now have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, you should have a red window with a small green rectangle
    at the top-left (just as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00010.jpeg)*Figure 2.5*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about switching the color of our small rectangle every second? Alright,
    first thing, we need to create another rectangle. To make things easier, we'll
    write a small function that will create texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, add the following import at the top of your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we''ll create a small enum to indicate the color as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our lives easier, we''ll handle errors outside of the next function,
    so no need to handle them directly here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll note that the function returns an `Option` type, wrapping a texture.
    `Option` is an enum containing two variants: `Some` and `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explain briefly how it works, when the `Option` type is `Some`, it simply
    means it contains a value whereas `None` doesn't. It has already been explained
    in [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7), *Basics
    of Rust*, but here's a little recap just in case you need one. We can compare
    this mechanism with pointers in C-like languages; when the pointer is null, there
    is no data to access. The same goes for `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'So here, if the divider is `0`, we can''t divide or we''ll get an error. Instead
    of setting an error or returning a complicated type, we just return an `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` is equal to `Some(3)` and `y` is equal to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of this type compared to `null` is that if we have `Some`,
    you're sure that the data is valid. And in addition, when it's `None`, you can't
    accidentally read its content, it's simply impossible in Rust (and if you try
    to `unwrap` it, your program will panic immediately, but at least, you'll know
    what failed and why—no magical segmentation fault).
  prefs: []
  type: TYPE_NORMAL
- en: You can take a look at its documentation at [https://doc.rust-lang.org/std/option/enum.Option.html](https://doc.rust-lang.org/std/option/enum.Option.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain what happens here:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a texture or return `None` if the creation fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the color and then fulfill the texture with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we return `None`, it simply means an error occurred. Also, for now, this
    function only handles two colors, but it's pretty easy to add more if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might look a bit complicated at the moment, but it''ll make our life easier
    afterward. Now, let''s call this function by creating a blue square of size 32x32:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can just put pieces together. I''ll let you try to handle the color
    switch. A small tip: take a look at the `SystemTime` struct. You can refer to
    its documentation at [https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html](https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I guess you did it without any issues, but in any case, here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can now see the small rectangle at the top-left switching color every second.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uptill now, we've only created simple textures, but what about loading images
    instead?
  prefs: []
  type: TYPE_NORMAL
- en: Before trying to go through this, check whether you have installed the `SDL2_image`
    library (it's not included by default with the SDL2 library!). If not, you can
    install it by following the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2_image on Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: And you're good to go!
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2_image on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on your package management tool, run the following to install `SDL2_image`
    on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `apt package manager` use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For `dnf package manager` use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For `yum package manager` use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: And you're good to go!
  prefs: []
  type: TYPE_NORMAL
- en: Installing SDL2_image on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the Windows platform, the simplest way is to go to [https://www.libsdl.org/projects/SDL_image/](https://www.libsdl.org/projects/SDL_image/)
    and download it.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, you can''t use the `image` module with `sdl2`, we need to activate
    it. To do so, we need to update our `Cargo.toml` file by adding a new section
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`default` means that by default, the following features (`"sdl2/image"`) will
    be enabled. Now, let''s explain what `"sdl2/image"` means; `sdl2` refers to the
    crate where we want to enable a feature and `image` is the feature we want to
    enable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if you want to enable a feature on the current project, you don''t
    need the `sdl2/` part. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As I am sure you understood, it''s absolutely possible to chain features activation
    and even to activate multiple features at once! If you want to enable features
    depending on a version number, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: So if you enable the `v3` feature, all the others will be activated as well!
    It can be incredibly useful when you need to handle multiple versions at once.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go back to our images.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like textures, we need to initialize the image context. Now that we''ve
    activated the `image` feature, we can call the linked functions and import them.
    Let''s add some new imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create the image context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the context has been initialized, let''s actually load the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A few explanations for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load_texture` takes a file path as an argument. Be very careful with paths,
    even more when they''re relative!'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, it''s just like we did with other textures. Let''s put our image
    into our Window''s background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To sum everything up, here''s what your project''s folder should look like
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: And that's it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the full code in case you missed a step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, it gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00011.jpeg)*Figure 2.6*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to make Windows and play with events and textures, let's
    see how to save and load high scores from files!
  prefs: []
  type: TYPE_NORMAL
- en: Handling files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the basics. First, let''s open and write into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s explain this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing fancy, we just import the `File` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This set of imports is more interesting: we import the `io` module (`self`)
    and the `Write` trait. For the second, if we didn''t import it, we wouldn''t be
    able to use the `write_all` method (because you need to import a trait to use
    its methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared a function named `write_into_file` that takes a filename and the
    content you want to write into the file as arguments. (Note that the file will
    be overwritten by this content!) It returns an `io::Result` type. It is an alias
    over the normal `Result` type (its documentation is at [https://doc.rust-lang.org/stable/std/result/enum.Result.html](https://doc.rust-lang.org/stable/std/result/enum.Result.html))
    declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that in case of error, the error type is already defined.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you to take a look at its documentation in case you want to
    go further, at [https://doc.rust-lang.org/stable/std/io/type.Result.html](https://doc.rust-lang.org/stable/std/io/type.Result.html).
  prefs: []
  type: TYPE_NORMAL
- en: So if our function worked without errors, it'll return `Ok(())`; it's the `Ok`
    variant containing an empty tuple which is considered the Rust equivalent of the
    `void` type. In case of error, it'll contain an `io::Error`, and it'll be up to
    you to handle it (or not). We'll come back to error handling a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the static method `create` of the `File` type. If the file exists,
    it'll be truncated and if it doesn't, it'll be created. More information about
    this method can be found at [https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create](https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.create).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at this strange `?` symbol. It''s a syntactic sugar over the
    `try!` macro. The `try!` macro is very simple to understand and its code can be
    resumed as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'So that''s pretty easy, but annoying to rewrite over and over, so the Rust
    teams decided to first introduce the `try!` macro and then after a long consensus,
    decided to add the `?` syntactic sugar over it (it also works with the `Option`
    type). However, both code pieces are still working, so you can perfectly do as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s exactly the same. Alternatively, you can write the full version too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: It's up to you, but now you know what options you have!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy here; we write all our data into the file. We just need to convert
    (it's not really a conversion in this case, more like getting internal data) our
    `&str` into a slice of `u8` (so a `&[u8]`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a function to write a file, it''d be nice to be able to read
    from a file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go over what this function does quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, it only takes a filename as an argument and returns a `String` if
    the reading was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Just like before, we open the file. Then we create a mutable `String` where
    the file content will be stored and finally we read all the file content at once
    with the `read_to_string` method (the `String` is reallocated as many times as
    needed). This method will fail if the string isn't proper UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to finish, if everything went fine, we return our content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: So now, let's see how we can use this in our future tetris.
  prefs: []
  type: TYPE_NORMAL
- en: Saving/loading high scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep things simple, we''ll have a very simple file format:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, we store the best scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the second line, we store the highest number of lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by writing the `save` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'It was a small lie: there are actually two functions. The first one is just
    here to make the code smaller and easier to read even though we need to explain
    what it does, because we''re about to talk about a big feature from Rust—**iterators**!'
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Rust documentation describes an iterator as *Composable external iteration.*
  prefs: []
  type: TYPE_NORMAL
- en: 'They''re used a lot in idiomatic Rust code on collection types (`slice`, `Vec`,
    `HashMap`, and so on) so it''s very important to learn to master them. This code
    will allow us to have a nice introduction. Let''s look at the code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite difficult to read and understand for the moment, so let''s rewrite
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Better (or at least more readable!). Now let''s go step by step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create an iterator from our slice. A really important and fundamental
    thing to note about iterators in Rust; they're lazy. Creating an iterator doesn't
    cost anything more than the size of the type (generally a structure containing
    a pointer and an index). Until the `next()` method is called, nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we have an iterator, awesome! Let''s check the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the iterator''s `map` method. What it does is simple: it converts the
    current type into another one. So here, we convert a `u32` into a `String`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Really important to note: at this point, the iterator still hasn''t done anything.
    Keep in mind that nothing is done until the `next()` method is called!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: And now we call the `collect()` method. It'll call the `next()` method of our
    iterator as long as it didn't get all elements and store them into a `Vec`. This
    is where the `map()` method will be called on every element of our iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally the last step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This method (as its name indicates) joins all the elements of the `Vec` into
    a `String` separated by the given `&str` (so, `" "` in our case).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we give `&[1, 14, 5]` to the `slice_to_string` function, it'll return
    a `String` containing `"1 14 5"`. Pretty convenient, right?
  prefs: []
  type: TYPE_NORMAL
- en: If you want to go a bit deeper with the iterators, you can take a look at the
    blog post at [https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust](https://blog.guillaume-gomez.fr/articles/2017-03-09+Little+tour+of+multiple+iterators+implementation+in+Rust)
    or directly take a look at the iterator official documentation at [https://doc.rust-lang.org/stable/std/iter/index.html](https://doc.rust-lang.org/stable/std/iter/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to go back to our saving function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Once we have converted our slices to `String`, we write them into the `scores.txt`
    file. The `is_ok()` method call just informs the caller of the `save_highscores_and_lines()`
    function if everything has been saved as expected or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can save scores, it'd be nice to be able to get them back when the
    tetris game is starting!
  prefs: []
  type: TYPE_NORMAL
- en: Reading formatted data from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you will certainly have guessed at this point, we''ll use iterators once
    again. This is what the loading function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Once again, not easy to understand, at first sight. So let's explain all this!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `line_to_slice()` function does the opposite of `slice_to_string()`; it
    transforms a `&str` into a slice of `u32` (or `&[u32]`). Let''s see the iterator
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like last time, let''s split the calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'A bit better! Now let''s explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an iterator that will contain all strings between spaces. So `a b` will
    contain `a` and `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is particularly interesting since it''s the merge of two others:
    `filter()` and `map()`. We already know `map()` but what about `filter()`? If
    the condition isn''t verified (so if the returned value of the closure is `false`),
    the iterator won''t pass the value to the next method call. `filter_map()` works
    the same at this point: if the closure returns `None`, the value won''t be passed
    to the next method call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s focus on this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Here, we try to convert `&str` into `u32`. The `parse()` method returns a `Result`
    but the `filter_map()` expects an `Option` so we need to convert it. That's what
    the `ok()` method is for! If your `Result` is an `Ok(value)`, then it'll convert
    it into a `Some(value)`. However, if it's an `Err(err)`, it'll convert it into
    a `None` (but you'll lose the error value).
  prefs: []
  type: TYPE_NORMAL
- en: To sum this up, this whole line tries to convert a `&str` into a number and
    ignores it if the conversion fails so it's not added to our final `Vec`. Amazing
    how much we can do with such small code!
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We `collect` all the successful conversions into a `Vec` and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for this function, now let''s look at the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, if everything went fine (if the file exists and has two lines), we return
    an `Option` containing in the first position the highest scores and in the second
    position the highest number of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'So if the file exists and we can get its content, we parse the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Another iterator! As usual, let''s rewrite it a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'I think you''re starting to get how they work, but just in case you don''t
    know, here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We make an iterator containing at most two entries (because of the `2` as the
    first argument) splitting lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We transform each line into a `Vec<u32>` by using the function described in
    the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we collect those `Vec`s into a `Vec<Vec<u32>>`, which should only
    contain two entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the next line now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'As said before, if we don''t have two entries inside our `Vec`, it means something
    is wrong with the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'In case our `Vec` has two entries, we can get the corresponding values. Since
    the `pop` method removes the last entry of the `Vec`, we get them in reverse (even
    though we return high scores first then the highest number of lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Then everything else is just the error handling. As we said previously, if any
    error occurs, we return `None`. In this case, it's not really important to handle
    the error since it's just high scores. If we have errors with the `sdl` libraries,
    nothing will work as expected, so we need to handle them to avoid a panic.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to really start the game!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw a lot of important things like how to use `Cargo` (through
    the `Cargo.toml` file), how to import new crates into a project, thanks to `Cargo`,
    and the basics for Rust modules handling. We even covered how to use iterators
    and read and write files, `SDL2` basics like how to create a window and fill it
    with colors, and loading/creating new textures and images (thanks to the `SDL2-image`
    library!).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0093.html#2OM4A0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Events
    and Basic Game Mechanisms*, we'll start the implementation of the tetris game,
    so be sure to master everything explained in this chapter before starting the
    next one!
  prefs: []
  type: TYPE_NORMAL
