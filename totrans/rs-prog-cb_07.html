<html><head></head><body><div><h1 class="header-title">Integrating Rust with Other Languages</h1>
                
            
            
                
<p>In today's application landscape, integration is key. Whether you are slowly modernizing a legacy service or starting from scratch with using a new language, programs rarely run in isolation nowadays. Rust is still an exotic technology for many companies and—unfortunately—is usually not considered in the typical SDK. This is why Rust made a point of <em>playing nicely with others</em>, which is why the community can (and will) supply a large number of drivers, service integrations, and so on, by wrapping other (native) libraries. </p>
<p>As developers, we rarely have the luxury of starting completely from scratch (greenfield projects), so in this chapter, we will cover the various ways the Rust language integrates with other languages and technologies. We'll focus on the most popular and useful integrations at the time of writing, but these fundamentals should provide a basis for greater interoperability as well since many languages provide an interface for native binaries (such as .NET (<a href="https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019">https://docs.microsoft.com/en-us/cpp/dotnet/calling-native-functions-from-managed-code?view=vs-2019</a>) or Java's JNI (<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502">https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html#wp9502</a>)). With that knowledge, adding Rust to enhance your web application should be just as easy as creating a sensor driver wrapper for the manufacturer's code. </p>
<p>We believe that good integration is important for the success of a language. In this chapter, we will cover the following recipes:</p>
<ul>
<li>Including legacy C code</li>
<li>Calling into Rust from Node.js using FFI</li>
<li>Running Rust in the browser</li>
<li>Using Rust and Python</li>
<li>Generating bindings for legacy applications</li>
</ul>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">Including legacy C code</h1>
                
            
            
                
<p>C is still among the most popular programming languages (<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>) thanks to its versatility, speed, and simplicity. Due to this, many applications—legacy or not—are developed using C, with all of its upsides and downsides. Rust shares a domain with C—systems programming, which is why more and more companies replace their C code with Rust thanks to its safety and appeal as a modern programming language. However, changes are not always made in one big bang (<a href="https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/">https://www.linkedin.com/pulse/big-bang-vs-iterative-dilemma-martijn-endenburg/</a>); it's usually a much more gradual (iterative) approach that includes swapping out components and replacing parts of an application. </p>
<p>Here, we use the C code as an analogy because it's popular and well known. However, these techniques apply to any (natively) compiled technology, such as Go, C++, or even Fortran. So let's get to it!</p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we are not only building Rust but also C. For this, we need a C compiler toolchain—<kbd>gcc</kbd> (<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>) and <kbd>make</kbd>: <a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a>, which is a rule-based scripting engine for executing the build.</p>
<p>Check whether the tools are installed by opening a Terminal window (note that the versions should be similar—at least the major release—to avoid any unexpected differences):</p>
<pre><strong>$ cc --version</strong><br/>cc (GCC) 9.1.1 20190503 (Red Hat 9.1.1-1)<br/>Copyright (C) 2019 Free Software Foundation, Inc.<br/>This is free software; see the source for copying conditions. There is NO<br/>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br/><strong>$ make --version</strong><br/>GNU Make 4.2.1<br/>Built for x86_64-redhat-linux-gnu<br/>Copyright (C) 1988-2016 Free Software Foundation, Inc.<br/>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br/>This is free software: you are free to change and redistribute it.<br/>There is NO WARRANTY, to the extent permitted by law.</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>If these commands are not available on your machine, check how to install them on your operating system. In any <strong>Linux/Unix</strong> environment (including the WSL—the <strong>Windows Subsystem for Linux</strong>: <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a>), they can require the installation of <kbd>gcc</kbd> and <kbd>make</kbd> via the default package repositories. On some distributions (for example, Ubuntu), bundles such as <kbd>build_essentials</kbd> (<a href="https://packages.ubuntu.com/xenial/build-essential">https://packages.ubuntu.com/xenial/build-essential</a>) provide these tools as well.</p>
<p>On macOS, check out Homebrew, which provides a similar experience and provides <kbd>gcc</kbd> as well as <kbd>make</kbd>: <a href="https://brew.sh/">https://brew.sh/</a>.</p>
<p>Windows users have a choice between the WSL (and then following the Linux instructions) or using Cygwin (<a href="https://www.cygwin.com">https://www.cygwin.com</a>) to find <kbd>gcc-core</kbd> and <kbd>make</kbd> there. We recommended adding these tools (by default, <kbd>C:\cygwin64\bin</kbd>) to the <kbd>PATH</kbd> variable on Windows (<a href="https://www.java.com/en/download/help/path.xml">https://www.java.com/en/download/help/path.xml</a>), so a regular (PowerShell) Terminal can access Cygwin's executables.</p>
<p>Once ready, use the same shell to create a <kbd>legacy-c-code</kbd> directory and, inside, run <kbd>cargo new rust-digest --lib</kbd> and create a directory named <kbd>C</kbd> alongside it: </p>
<pre><strong>$ ls legacy-c-code</strong><br/>C/ rust-digest/</pre>
<p>Inside the <kbd>C</kbd> directory, create an <kbd>src</kbd> folder to mirror the Rust project. Open the entire <kbd>legacy-c-code</kbd> in Visual Studio Code or your Rust development environment.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to be able to include legacy code in your project:</p>
<ol>
<li>Let's implement the Rust library first. Open <kbd>rust-digest/Cargo.toml</kbd> to adjust the configuration to output a dynamic library (<kbd>*.so</kbd> or <kbd>*.dll</kbd>):</li>
</ol>
<pre style="padding-left: 60px">[lib]<br/>name = "digest"<br/>crate-type = ["cdylib"]</pre>
<ol start="2">
<li>Another thing to add is the dependencies. Here, we are using types from <kbd>libc</kbd> and a cryptography library called <kbd>ring</kbd>, so let's add those dependencies:</li>
</ol>
<pre style="padding-left: 60px">[dependencies]<br/>libc = "0.2"<br/>ring = "0.14"</pre>
<ol start="3">
<li>Next, we can take care of the code itself. Let's open <kbd>rust-digest/src/lib.rs</kbd> and replace the default code with the following snippet. This snippet creates an interface from the outside world that accepts a string (a mutable character pointer) and returns a string digest of the input:</li>
</ol>
<pre style="padding-left: 60px">use std::ffi::{CStr, CString};<br/>use std::os::raw::{c_char, c_void};<br/><br/>use ring::digest;<br/><br/>extern "C" {<br/>    fn pre_digest() -&gt; c_void;<br/>}<br/><br/>#[no_mangle]<br/>pub extern "C" fn digest(data: *mut c_char) -&gt; *mut c_char {<br/>    unsafe {<br/>        pre_digest();<br/><br/>        let data = CStr::from_ptr(data);<br/>        let signature = digest::digest(&amp;digest::SHA256, <br/>        data.to_bytes());<br/><br/>        let hex_digest = signature<br/>            .as_ref()<br/>            .iter()<br/>            .map(|b| format!("{:X}", b))<br/>            .collect::&lt;String&gt;();<br/><br/>        CString::new(hex_digest).unwrap().into_raw()<br/>    }<br/>}</pre>
<ol start="4">
<li>This should be a full Rust library now. Let's run <kbd>cargo build</kbd> inside <kbd>rust-digest</kbd> to check the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd rust-digest; cargo build</strong><br/>   Compiling libc v0.2.58<br/>   Compiling cc v1.0.37<br/>   Compiling lazy_static v1.3.0<br/>   Compiling untrusted v0.6.2<br/>   Compiling spin v0.5.0<br/>   Compiling ring v0.14.6<br/>   Compiling rust-digest v0.1.0 (Rust-Cookbook/Chapter07/legacy-c-<br/>    code/rust-digest)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 7.53s</pre>
<p class="mce-root"/>
<ol start="5">
<li>There should be a <kbd>libdigest.so</kbd> library (or <kbd>digest.dll</kbd> on Windows):</li>
</ol>
<pre style="padding-left: 60px"><strong>$  ls -al rust-digest/target/debug/</strong><br/>total 3756<br/>drwxr-xr-x. 8 cm cm 4096 Jun 23 20:17 ./<br/>drwxr-xr-x. 4 cm cm 4096 Jun 23 20:17 ../<br/>drwxr-xr-x. 6 cm cm 4096 Jun 23 20:17 build/<br/>-rw-r--r--. 1 cm cm 0 Jun 23 20:17 .cargo-lock<br/>drwxr-xr-x. 2 cm cm 4096 Jun 23 20:17 deps/<br/>drwxr-xr-x. 2 cm cm 4096 Jun 23 20:17 examples/<br/>drwxr-xr-x. 13 cm cm 4096 Jun 23 20:17 .fingerprint/<br/>drwxr-xr-x. 3 cm cm 4096 Jun 23 20:17 incremental/<br/>-rw-r--r--. 1 cm cm 186 Jun 23 20:17 libdigest.d<br/><strong>-rwxr-xr-x. 2 cm cm 3807256 Jun 23 20:17 libdigest.so*</strong><br/>drwxr-xr-x. 2 cm cm 4096 Jun 23 20:17 native/</pre>
<ol start="6">
<li>However, let's do a release build as well. Run <kbd>cargo build --release</kbd> in <kbd>rust-digest</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo build --release</strong><br/>   Compiling rust-digest v0.1.0 (Rust-Cookbook/Chapter07/legacy-c-<br/>   code/rust-digest)<br/>   Finished release [optimized] target(s) in 0.42s</pre>
<ol start="7">
<li>To implement the <kbd>C</kbd> part of the project, create and open <kbd>C/src/main.c</kbd> to add the following code:</li>
</ol>
<pre style="padding-left: 60px">#include &lt;stdio.h&gt;<br/><br/>// A function with that name is expected to be linked to the project<br/>extern char* digest(char *str);<br/><br/>// This function is exported under the name pre_digest<br/>extern void pre_digest() {<br/>    printf("pre_digest called\n");<br/>}<br/><br/>int main() {<br/>    char *result = digest("Hello World");<br/>    printf("SHA digest of \"Hello World\": %s", result);<br/>    return 0;<br/>}</pre>
<ol start="8">
<li><kbd>make</kbd> is the traditional (and simplest) tool to build <kbd>C</kbd> code. <kbd>make</kbd> runs a file called <kbd>Makefile</kbd> to adhere to the rules that it defines. Create and open <kbd>C/Makefile</kbd> and add the following:</li>
</ol>
<pre style="padding-left: 60px"># Include the Rust library<br/>LIBS := -ldigest -L../rust-digest/target/release<br/><br/>ifeq ($(shell uname),Darwin)<br/>    LDFLAGS := -Wl,-dead_strip $(LIBS)<br/>else<br/>    LDFLAGS := -Wl,--gc-sections $(LIBS)<br/>endif<br/><br/>all: target/main<br/><br/>target:<br/>  @mkdir -p $@<br/><br/>target/main: target/main.o <br/>  @echo "Linking ... "<br/>  $(CC) -o $@ $^ $(LDFLAGS)<br/><br/>target/main.o: src/main.c | target<br/>  @echo "Compiling ..."<br/>  $(CC) -o $@ -c $&lt;<br/><br/>clean:<br/>  @echo "Removing target/"<br/>  @rm -rf target</pre>
<ol start="9">
<li>If everything is in place, we should be able to switch to the <kbd>C</kbd> directory and run <kbd>make all</kbd> there:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ make all</strong><br/>Compiling ...<br/>cc -o target/main.o -c src/main.c<br/>Linking ... <br/>cc -o target/main target/main.o -Wl,--gc-sections -ldigest -L../rust-digest/target/release</pre>
<p style="padding-left: 60px">Afterward, there is a <kbd>C/target</kbd> directory, which contains two files: <kbd>main.o</kbd> and <kbd>main</kbd> (<kbd>main.exe</kbd> on Windows).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="10">
<li>To be able to run the executable (the <kbd>.o</kbd> file is just the object file; not for running), we also need to tell it where our dynamic library is located. For that, the <kbd>LD_LIBRARY_PATH</kbd> environment variable is typically used. Open <kbd>bash</kbd> and run the following command inside the <kbd>legacy-c-code</kbd> directory to—temporarily—overwrite the variable with the appropriate path:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd rust-digest/target/release</strong><br/><strong>$ LD_LIBRARY_PATH=$(pwd)</strong><br/><strong>$ echo $LD_LIBRARY_PATH</strong> <br/>/tmp/Rust-Cookbook/Chapter07/legacy-c-code/rust-digest/target/release</pre>
<ol start="11">
<li>Now it's time to finally run the C program and check whether everything worked out. Switch to the <kbd>C/target</kbd> directory and run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ./main</strong><br/>pre_digest called<br/>SHA digest of "Hello World": A591A6D4BF420404A11733CFB7B190D62C65BFBCDA32B57B277D9AD9F146E </pre>
<p>With that done, let's take a look behind the scenes to understand how it was done.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Replacing legacy C code with Rust is a step-by-step process that is often done in order to improve developer productivity, safety, and potential innovation. This has been done in countless applications (for example, in Microsoft's public cloud offering, Azure: <a href="https://azure.microsoft.com/en-gb/">https://azure.microsoft.com/en-gb/</a>) and requires two technologies to work together flawlessly. </p>
<p>Thanks to Rust's LLVM-based compiler, the compilation outputs native code (for example, ELF on Linux: <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a>), which makes it accessible—in particular—for C/C++. In this recipe, we are taking a look at how to link those two outputs together into a single program using a dynamic library built in Rust.</p>
<p>The prerequisites for creating a dynamic library (<kbd>*.so</kbd>/<kbd>*.dll</kbd>) in Rust are surprisingly simple: <em>step 1</em> shows the required changes to <kbd>Cargo.toml</kbd> for <kbd>rustc</kbd> to output the required format. There are other formats, so if you are looking for something specific, check out the nomicon (<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries">https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries</a>) and docs at <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries">https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries</a>. </p>
<p class="mce-root"/>
<p><em>Step 3</em> shows the code to create an SHA256 (<a href="https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/">https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/</a>) digest of an incoming string, but only after it calls a simple callback function, <kbd>pre_digest()</kbd>, to showcase the bi-directional bindings. There are a few things of note here: </p>
<ul>
<li>Importing a function from a linked library is done using an <kbd>extern "C" {}</kbd> declaration (the <kbd>"C"</kbd> isn't actually necessary). After declaring a construct like that, it can be used just like any other function. </li>
<li>In order to export a function compatible with the ELF format, the <kbd>#[no_mangle]</kbd> attribute is required since the compiler runs a name-mangling scheme that changes the function name. Since compilers don't have a common scheme, <kbd>no_mangle</kbd> makes sure it stays just as it is. To learn more about name mangling, check out this link: <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code</a>.</li>
<li>The use of <kbd>unsafe</kbd> inside the <kbd>digest</kbd> function is required for a few reasons. First, calling an external function is always unsafe (<kbd>pre_digest()</kbd>). Second, the conversion from a <kbd>char</kbd> pointer to <kbd>CStr</kbd> is unsafe, requiring the scope as well.  </li>
</ul>
<div><strong>Note:</strong> <kbd>ring</kbd> (<a href="https://github.com/briansmith/ring">https://github.com/briansmith/ring</a>) is a pure Rust implementation of several cryptography algorithms, so there are no OpenSSL (<a href="https://www.openssl.org/">https://www.openssl.org/</a>) or LibreSSL (<a href="https://www.libressl.org">https://www.libressl.org</a>) requirements. Since both of those libraries are built on the respective native libraries, they always present a headache to even experienced Rust developers. Being pure Rust, <kbd>ring</kbd> avoids any of their linking/compilation issues, however.</div>
<p>From <em>steps </em><em>4</em> to<em> 6</em>, we are building the Rust library just as we used to, but instead of a <kbd>.rlib</kbd> file, a <kbd>.so</kbd> or <kbd>.dll</kbd> file is the result of this process.</p>
<p><em>Step 7</em> shows the <kbd>C</kbd> code required to import and call a dynamically linked function. <kbd>C</kbd> keeps this admirably simple with an <kbd>extern</kbd> declaration for the interface, which enables you to call the function just like that. The callback is also implemented and exported using the <kbd>extern</kbd> declaration and it simply prints out that it was called.</p>
<p>Rust's build system really shines when we get to <em>step 8</em>, where the rules for <kbd>Makefile</kbd> are created. Making rules is simple, but it leaves a lot of room for complexity, as many C developers know. In our recipe, however, we want to keep it easy to understand. Each rule consists of a target (for example, <kbd>all</kbd>) and its dependencies (for example, <kbd>target/main</kbd>), as well as a body of bash commands to run (for example, <kbd>@mkdir -p $@</kbd>). </p>
<p>These dependencies can be files (such as <kbd>target/main.o</kbd> or <kbd>target/main</kbd>) or other rules. If they are files, check when they were modified last and, if there was a change, that they run the rule and its dependencies. The resulting dependency tree gets resolved automatically. As fascinating as this highly useful, 30-year-old tool may be, there are books written that are devoted to how it works. It is certainly a deep dive into history, and Linux conventions. Check out a short tutorial here: <a href="http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/">http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/</a><a href="http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/"> or go straight to the make manual (</a><a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a><a href="http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/">).</a></p>
<p><em>Step 9</em> compiles the <kbd>C</kbd> code into an executable and links it to <kbd>libdigest.so</kbd>, which <kbd>rustc</kbd> created. We are also pointing the linker to the right path in the <kbd>LDFLAGS</kbd> variable in <kbd>Makefile</kbd>. </p>
<p>Only in <em>step 10</em> will it become apparent how a static library is different from a dynamic library. The latter has to be available at runtime because it isn't baked into the executable and relies on other mechanisms to be found. One such mechanism is the <kbd>LD_LIBRARY_PATH</kbd> environment variable, which points to directories with <kbd>libXXXX.so</kbd> files for the program to find its dependencies (by name). For this recipe, we are <strong>replacing</strong> the original value with wherever your <kbd>rust-digest/target/release</kbd> directory is located (<kbd>$(pwd)</kbd> outputs the current directory); however, this is only for the current Terminal session, so whenever you close and reopen the window, the setting will be gone. If the path is improperly set or the directory/file is missing, executing <kbd>main</kbd> will give you something along the lines of the following:</p>
<pre><strong>$ ./main</strong><br/>./main: error while loading shared libraries: libdigest.so: cannot open shared object file: No such file or directory</pre>
<p><em>Step 11</em> shows the correct output since the <kbd>pre_digest</kbd> function was called and we were able to create the correct SHA256 digest for <kbd>"Hello World"</kbd> (without the <kbd>"</kbd>).</p>
<p>Now that we know a little more about integrating Rust into a C-type application, we can move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Calling into Rust from Node.js using FFI</h1>
                
            
            
                
<p>JavaScript is a language that excels in its flat learning curve and flexibility, which leads to impressive adoption rates in various areas outside of the original browser animation. Node.js (<a href="https://nodejs.org/en/">https://nodejs.org/en/</a>) is a runtime based on Google's V8 JavaScript engine, which allows JavaScript code to run directly on the operating system (without the browser), including access to various low-level APIs in order to enable IoT-type applications and web services, or even to create and display virtual/augmented reality environments (<a href="https://github.com/microsoft/HoloJS">https://github.com/microsoft/HoloJS</a>). All of this is possible because the Node runtime provides access to native libraries on the host operating system. Let's see how we create a Rust library to call from JavaScript into this.  </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Since we are working with Node.js, please install <kbd>npm</kbd> and the Node.js runtime, as explained on their official website: <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>. Once ready, you should be able to run these commands from a Terminal (PowerShell or bash):</p>
<pre><strong>$ node --version</strong><br/>v11.15.0<br/><strong>$ npm --version</strong><br/>6.7.0</pre>
<p>The actual versions may be higher at the time of reading. The node dependency we are using also requires C/C++ tools, as well as having Python 2 installed. Follow the instructions for your OS on GitHub: <a href="https://github.com/nodejs/node-gyp#installation">https://github.com/nodejs/node-gyp#installation</a>. Then, let's set up a folder structure similar to the previous recipe:</p>
<ol>
<li>Create a <kbd>node-js-rust</kbd> folder.</li>
<li>Create a sub-folder called <kbd>node</kbd>, change into it, and run <kbd>npm init</kbd> to generate <kbd>package.json</kbd>—basically, Node's <kbd>Cargo.toml</kbd>.</li>
<li>Inside the <kbd>node</kbd> folder, add a directory called <kbd>src</kbd>. </li>
<li>At the same level as the <kbd>node</kbd> folder, create a new Rust project called <kbd>cargo new rust-digest --lib</kbd> (or reuse the one from the previous recipe).</li>
</ol>
<p>At the end, you should have a directory setup like this:</p>
<pre><strong>$ tree node-js-rust/</strong><br/>node-js-rust/<br/>├── node<br/>│   ├── package.json<br/>│   └── src<br/>│       └── index.js<br/>└── rust-digest<br/>    ├── Cargo.toml<br/>    └── src<br/>        └── lib.rs<br/>4 directories, 4 files</pre>
<p>Open the entire directory in Visual Studio Code to work on the code.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it ...</h1>
                
            
            
                
<p>Let's repeat a few steps from the SHA256 library from the previous recipe:</p>
<ol>
<li>First, let's take care of the Rust part. Open <kbd>rust-digest/Cargo.toml</kbd> to add <kbd>ring</kbd>, a dependency for the hashing part, as well as the <kbd>crate-type</kbd> configuration for cross-compilation:</li>
</ol>
<pre style="padding-left: 60px">[lib]<br/>name = "digest"<br/>crate-type = ["cdylib"]<br/><br/>[dependencies]<br/>libc = "0.2"<br/>ring = "0.14"</pre>
<ol start="2">
<li>Next, let's look at the Rust code. Just as in other recipes in this chapter, we are creating a fast way to generate an SHA digest via Rust to be used from Node.js:</li>
</ol>
<pre style="padding-left: 60px">use std::ffi::{CStr, CString};<br/>use std::os::raw::c_char;<br/><br/>use ring::digest;<br/><br/>#[no_mangle]<br/>pub extern "C" fn digest(data: *mut c_char) -&gt; *mut c_char {<br/>    unsafe {<br/><br/>        let data = CStr::from_ptr(data);<br/>        let signature = digest::digest(&amp;digest::SHA256, <br/>        data.to_bytes());<br/><br/>        let hex_digest = signature<br/>            .as_ref()<br/>            .iter()<br/>            .map(|b| format!("{:X}", b))<br/>            .collect::&lt;String&gt;();<br/><br/>        CString::new(hex_digest).unwrap().into_raw()<br/>    }<br/>}<br/><br/>// No tests :(</pre>
<ol start="3">
<li><kbd>cargo build</kbd> now creates a native library. You can find the library in <kbd>target/debug</kbd> inside the Rust project directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cargo build</strong><br/>   Compiling libc v0.2.58<br/>   Compiling cc v1.0.37<br/>   Compiling untrusted v0.6.2<br/>   Compiling spin v0.5.0<br/>   Compiling lazy_static v1.3.0<br/>   Compiling ring v0.14.6<br/>   Compiling rust-digest v0.1.0 (Rust-Cookbook/Chapter07/node-js-<br/>    rust/rust-digest)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 5.88s<br/><strong>$ ls rust-digest/target/debug/</strong><br/>build/ deps/ examples/ incremental/ libdigest.d <strong>libdigest.so*</strong> native/<br/><br/></pre>
<ol start="4">
<li>If the JavaScript part calls into the Rust binary, there are a few declarations to be made in order to make the function known. We finish off the code by printing out the result of a call to the Rust library. Add this to <kbd>node/src/index.js</kbd>:</li>
</ol>
<pre style="padding-left: 60px">const ffi = require('ffi');<br/>const ref = require('ref');<br/><br/>const libPath = '../rust-digest/target/debug/libdigest';<br/><br/><br/>const libDigest = ffi.Library(libPath, {<br/>  'digest': [ "string", ["string"]],<br/>});<br/><br/>const { digest } = libDigest;<br/>console.log('Hello World SHA256', digest("Hello World"));</pre>
<ol start="5">
<li>The <kbd>require</kbd> statement already hints toward a dependency, so let's integrate this as well. Open <kbd>node/package.json</kbd> to add the following:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  [...]<br/>  "dependencies": {<br/>    "ffi": "^2.3.0"<br/>  }<br/>}</pre>
<ol start="6">
<li>With everything in place, we can now issue an <kbd>npm install</kbd> command from within the <kbd>node</kbd> directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ npm install</strong><br/><br/>&gt; ref@1.3.5 install Rust-Cookbook/Chapter07/node-js-rust/node/node_modules/ref<br/>&gt; node-gyp rebuild<br/><br/>make: Entering directory 'Rust-Cookbook/Chapter07/node-js-rust/node/node_modules/ref/build'<br/>  CXX(target) Release/obj.target/binding/src/binding.o<br/>In file included from ../src/binding.cc:7:<br/>../../nan/nan.h: In function ‘void Nan::AsyncQueueWorker(Nan::AsyncWorker*)’:<br/>../../nan/nan.h:2298:62: warning: cast between incompatible function types from ‘void (*)(uv_work_t*)’ {aka ‘void (*)(uv_work_s*)’} to ‘uv_after_work_cb’ {aka ‘void (*)(uv_work_s*, int)’} [-Wcast-function-type]<br/> 2298 | , reinterpret_cast&lt;uv_after_work_cb&gt;(AsyncExecuteComplete)<br/>[...]<br/>  COPY Release/ffi_bindings.node<br/>make: Leaving directory 'Rust-Cookbook/Chapter07/node-js-rust/node/node_modules/ffi/build'<br/>npm WARN node@1.0.0 No description<br/>npm WARN node@1.0.0 No repository field.<br/><br/>added 7 packages from 12 contributors and audited 18 packages in 4.596s<br/>found 0 vulnerabilities<br/><br/></pre>
<ol start="7">
<li>After the dependencies have been installed, the <kbd>node</kbd> application is ready to run. Issue <kbd>node src/index.js</kbd> to execute the JavaScript file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ node src/index.js</strong><br/>Hello World SHA256 A591A6D4BF420404A11733CFB7B190D62C65BFBCDA32B57B277D9AD9F146E</pre>
<p>Having done the work, let's take a look at why and how it all comes together.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Node.js, as a native runtime environment for JavaScript, provides easy-to-access native libraries that can be built with Rust. In order to do that, the <kbd>node-ffi</kbd> (<a href="https://github.com/node-ffi/node-ffi">https://github.com/node-ffi/node-ffi</a>) package is required to dynamically find and load the desired libraries. First, however, we start with the Rust code and project: <em>steps</em> <em>1</em> to <em>3</em> show how to build a native dynamic library, which we discussed earlier in this chapter, in the <em>Including legacy C code</em> recipe, in the <em>How it works...</em> section.  </p>
<p>In <em>step 4</em>, we create the JavaScript code. Thanks to the dynamic nature of JavaScript, defining the function signature can be done using strings and objects and the actual invocation looks just like a regular function that can be imported from a module. The FFI library also takes away the data type conversion, and the call across technology boundaries is seamless. Another important note is that, with <kbd>node-ffi</kbd> (<a href="https://github.com/node-ffi/node-ffi">https://github.com/node-ffi/node-ffi</a>), the actual module path is required, which makes handling the different artifacts a lot easier (compared to using environment variables in C/C++ interop).</p>
<p>In <em>step 5</em> and <em>step 6</em>, we take care of adding and installing the required dependencies for Node.js using the famous <kbd>npm</kbd> package manager (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>), with <kbd>node-ffi</kbd> (<a href="https://github.com/node-ffi/node-ffi">https://github.com/node-ffi/node-ffi</a>) requiring some compiler tools to work properly. </p>
<p>The last step shows how the program executes and creates the same hash as other recipes in this chapter. </p>
<p>We've learned how to call into Rust from Node.js using FFI, so now let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Running Rust in the browser</h1>
                
            
            
                
<p>Running Rust in the browser may seem like a similar task to using Rust binaries with Node.js. However, the modern browser environment is exceedingly more difficult. Sandboxing limits access to local resources (which is a good thing!) and browsers provide a small number of scripting languages to run within the website. While the most successful language is JavaScript, it comes with many drawbacks in the area of animation, caused by the scripting nature of the technology. On top of that, there is garbage collection, a type system with many flaws, and the lack of a coherent programming paradigm—all of which manifests itself in unpredictable and poor performance for real-time applications such as games. </p>
<p>However, these issues are being resolved. A technology called WebAssembly has been introduced to be able to distribute binaries (as an assembler language for the web) that can be run in a specialized execution environment—just like JavaScript. In fact, JavaScript is able to seamlessly interact with these binaries, akin to native libraries in a Node.js application, which speeds things up considerably. Thanks to Rust's LLVM base, it can compile to WebAssembly, and, with its memory management, it's a great choice for running these real-time applications. While this technology is still in its infancy, let's see how this works!</p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this project, we are setting up a directory called <kbd>browser-rust</kbd>, containing a <kbd>web</kbd> directory and a <kbd>cargo</kbd> library project called <kbd>rust-digest</kbd> (<kbd>cargo new rust-digest --lib</kbd>). For the compilation, we need an additional compilation target, <kbd>wasm23-unknown-unknown</kbd>, which can be installed via <kbd>rustup</kbd>. Issue the following command in a Terminal to install the target:</p>
<pre><strong>$ rustup target add wasm32-unknown-unknown</strong><br/>info: downloading component 'rust-std' for 'wasm32-unknown-unknown'<br/> 10.9 MiB / 10.9 MiB (100 %) 5.3 MiB/s in 2s ETA: 0s<br/>info: installing component 'rust-std' for 'wasm32-unknown-unknown'</pre>
<p>Use <kbd>cargo</kbd> to install a tool called <kbd>wasm-bindgen-cli</kbd> (<kbd>cargo install wasm-bindgen-cli</kbd>), and check whether it works by invoking <kbd>wasm-bindgen</kbd> in your current console window. </p>
<p>Inside the <kbd>web</kbd> directory, we create a file named <kbd>index.html</kbd>, which will host and show our Rust output. In order to be able to render the index file, a web server is also required. Here are a few options:</p>
<ul>
<li>Python (3.x)'s standard library comes with an <kbd>http.server</kbd> module, which can be called like this: <kbd>python3 -m http.server 8080</kbd>.</li>
<li>Fans of JavaScript and Node.js can use <kbd>http-server</kbd> (<a href="https://www.npmjs.com/package/http-server">https://www.npmjs.com/package/http-server</a>), installable via <kbd>npm</kbd> (<a href="https://www.npmjs.com/package/http-server">https://www.npmjs.com/package/http-server</a>).</li>
<li>Recent versions of Ruby come with a web server as well: <kbd>ruby -run -ehttpd . -p8080</kbd>.</li>
<li>On Windows, you can use IIS Express (<a href="https://www.npmjs.com/package/http-server">https://www.npmjs.com/package/http-server</a>), also via the command line: <kbd>C:\&gt; "C:\Program Files (x86)\IIS Express\iisexpress.exe" /path:C:\Rust-Cookbook\Chapter07\browser-rust\web /port:8080</kbd>.</li>
</ul>
<p>Any web server that serves static files will do, and it should be able to provide the files appropriately. You should end up with a directory structure like this:</p>
<pre><strong>$ tree browser-rust/</strong><br/>browser-rust/<br/>├── rust-digest<br/>│   ├── Cargo.lock<br/>│   ├── Cargo.toml<br/>│   ├── src<br/>│       └── lib.rs<br/>└── web<br/>    └── index.html<br/><br/>3 directories, 4 files</pre>
<p>Your project should now be set up and ready to go. Let's see how we can get Rust to run in the browser.</p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Here's how to write low-latency web applications in just a few steps:</p>
<ol>
<li>Let's start by implementing the Rust part. We'll again create a hashing library, so we start by creating the API basics. Open <kbd>rust-digest/src/lib.rs</kbd> and insert the following above the tests:</li>
</ol>
<pre style="padding-left: 60px">use sha2::{Sha256, Digest};<br/>use wasm_bindgen::prelude::*;<br/><br/>fn hex_digest(data: &amp;str) -&gt; String {<br/>    let mut hasher = Sha256::new();<br/>    hasher.input(data.as_bytes());<br/>    let signature = hasher.result();<br/>    signature<br/>        .as_ref()<br/>        .iter()<br/>        .map(|b| format!("{:X}", b))<br/>        .collect::&lt;String&gt;()<br/>}</pre>
<ol start="2">
<li>Let's bind the <kbd>hex_digest()</kbd> function to a public API that we can call from outside the module. This enables us to invoke the code using WASM types and even autogenerate most of these bindings. Add some of those just below the preceding code:</li>
</ol>
<pre style="padding-left: 60px">#[wasm_bindgen]<br/>pub extern "C" fn digest(data: String) -&gt; String {<br/>    hex_digest(&amp;data)<br/>}<br/><br/>#[wasm_bindgen]<br/>pub extern "C" fn digest_attach(data: String, elem_id: String) -&gt; Result&lt;(), JsValue&gt; {<br/>    web_sys::window().map_or(Err("No window found".into()), |win| {<br/>        if let Some(doc) = win.document() {<br/>            doc.get_element_by_id(&amp;elem_id).map_or(Err(format!("No <br/>            element with id {} found", elem_id).into()), |val|{<br/>                let signature = hex_digest(&amp;data);<br/>                val.set_inner_html(&amp;signature);<br/>                Ok(())<br/>            })<br/>        }<br/>        else {<br/>            Err("No document found".into())<br/>        }<br/>    })<br/>}<br/>// No tests :( </pre>
<ol start="3">
<li class="mce-root">It's sometimes handy to have a callback once the module is instantiated, so let's add one of those as well:</li>
</ol>
<pre style="color: black;padding-left: 60px"><br/>#[wasm_bindgen(start)]<br/>pub fn start() -&gt; Result&lt;(), JsValue&gt; {<br/>    // This function is getting called when initializing the WASM <br/>    // module<br/>    Ok(())<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li class="mce-root">We have used two imports that require additional dependencies: <kbd>wasm-bindgen</kbd> and <kbd>sha2</kbd> (as a web-compatible version of <kbd>ring::digest</kbd>). Additionally, we are pretending to be a native library for external linking, so the library type and name should be adjusted. Modify <kbd>rust-digest/Cargo.toml</kbd> to include these changes:</li>
</ol>
<pre style="color: black;padding-left: 60px">[lib]<br/>name = "digest"<br/>crate-type = ["cdylib"]<br/><br/>[dependencies]<br/>sha2 = "0.8"<br/>wasm-bindgen = "0.2.48"<br/><br/>[dependencies.web-sys]<br/>version = "0.3.25"<br/>features = [<br/>  'Document',<br/>  'Element',<br/>  'HtmlElement',<br/>  'Node',<br/>  'Window',<br/>]</pre>
<ol start="5">
<li class="mce-root">Now, let's compile the library and check the output. Run <kbd>cargo build --target wasm32-unknown-unknown</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo build --target wasm32-unknown-unknown</strong><br/>   Compiling proc-macro2 v0.4.30<br/>   [...]<br/>   Compiling js-sys v0.3.24<br/>   Compiling rust-digest v0.1.0 (Rust-Cookbook/Chapter07/browser-<br/>    rust/rust-digest)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 54.49s<br/><strong>$ ls target/wasm32-unknown-unknown/debug/</strong><br/>build/ deps/ digest.d digest.wasm* examples/ incremental/ native/</pre>
<ol start="6">
<li class="mce-root">The resulting <kbd>digest.wasm</kbd> file is what we want to include in our web application using JavaScript. While this can be done directly (<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API">https://developer.mozilla.org/en-US/docs/WebAssembly/Using_the_JavaScript_API</a>), the data type conversion can be quite cumbersome. This is why there is a CLI tool to help out. Run <kbd>wasm-bindgen target/wasm32-unknown-unknown/debug/digest.wasm --out-dir ../web/ --web</kbd> from within <kbd>browser-rust/rust-digest</kbd> to generate the necessary JavaScript bindings for web browsers:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ wasm-bindgen target/wasm32-unknown-unknown/debug/digest.wasm --out-dir ../web/ --web</strong><br/><strong>$ ls ../web/</strong><br/>digest_bg.d.ts digest_bg.wasm digest.d.ts digest.js index.html</pre>
<ol start="7">
<li class="mce-root">These bindings need to be included in our <kbd>web/index.html</kbd> file (which is empty at the moment):</li>
</ol>
<pre style="color: black;padding-left: 60px">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;meta content="text/html;charset=utf-8" http-equiv="Content-<br/>         Type"/&gt;<br/>        &lt;script type="module"&gt;<br/>            import init, { digest, digest_attach } from <br/>             './digest.js';        <br/>            async function run() {<br/>                await init();<br/>                const result = digest("Hello World");<br/>                console.log(`Hello World SHA256 = ${result}`);<br/>                digest_attach("Hello World", "sha_out")<br/>            }<br/>            run();<br/>        &lt;/script&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;Hello World in SHA256 &lt;span id="sha_out"&gt;&lt;/span&gt;&lt;/h1&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<ol start="8">
<li class="mce-root">Save and exit the <kbd>index.html</kbd> file and start the web server you prepared earlier inside the web directory: </li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>py -m http.server 8080</strong><br/>Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...</pre>
<ol start="9">
<li class="CDPAlignLeft CDPAlign">Access <kbd>http://localhost:8080</kbd> in your browser (be sure to allow the server through the firewall) and check whether your output matches the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ad8dc81b-b4e0-4a4d-b33b-8341643e2498.png"/></p>
<p class="mce-root">Having done the work, let's take a look at why and how it all comes together.</p>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Modern browsers provide a JavaScript engine alongside a web assembly virtual machine (<a href="https://webassembly.org/">https://webassembly.org/</a>). With this capability, web applications can run binary code that is safely executed inside its own runtime environment with easy access from the outside. The main benefits include the following:</p>
<ul>
<li>A smaller-sized application, thanks to binary compilation</li>
<li>Faster end-to-end execution times (no compilation step)</li>
<li>No garbage collection—the WASM virtual machine is a stack machine</li>
</ul>
<p>On top of that, WASM can be converted into a text-based format for visual inspection and manual optimization. Rust is one of the few languages to even compile to these formats (text and binary), and it's largely thanks to LLVM and Rust's approach to memory management. </p>
<p class="mce-root"/>
<p>In <em>steps 1</em>, <em>2</em>, and <em>3</em>, we create the Rust module to do the work. Notice the <kbd>#[wasm_bindgen]</kbd> attributes over the <kbd>extern</kbd> functions, which allow the macro preprocessor to fetch the input and output types of the function and generate bindings from this interface definition. There is also a special (<a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html">https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html</a>) <kbd>#[wasm_bindgen(start)]</kbd> macro on top of one of the functions, which designates the initializer function to run whenever the module is instantiated. Both this function and <kbd>digest_attach()</kbd> feature a <kbd>Result</kbd> return type, which allows the <kbd>?</kbd> operator and rusty error handling in general. </p>
<p class="mce-root"><kbd>digest_attach()</kbd> is special (compared to <kbd>digest()</kbd>) since it directly accesses the DOM (<a href="https://www.w3.org/TR/WD-DOM/introduction.html">https://www.w3.org/TR/WD-DOM/introduction.html</a>) from the WASM module, which is provided by the <kbd>web_sys</kbd> crate. All of these macros and functions are imported in the <kbd>wasm_bindgen::prelude::*</kbd> statement.</p>
<p><em>Step 4</em> adjusts <kbd>Cargo.toml</kbd> accordingly to provide everything in order for the compilation to work. Note that any errors here that work on a different target (for example, the default target) hint toward an incompatible crate for WASM. Only in <em>step 5</em> do we execute the compilation for the wasm32 target, which produces a WASM binary file. <em>Step 6</em> runs the binding generator using the <kbd>wasm-bindgen</kbd> CLI, which produces a few files for easier integration. In this case, they are the following:</p>
<ul>
<li><kbd>digest_bg.d.ts</kbd>: TypeScript (<a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a>) definitions for the exported WASM functions</li>
<li><kbd>digest_bg.wasm</kbd>: The WASM file itself</li>
<li><kbd>digest.d.ts</kbd>: TypeScript definitions for the integration file</li>
<li><kbd>digest.js</kbd>: The JavaScript implementation for loading and converting the exported WASM functions into regular JavaScript calls</li>
</ul>
<p>The tool includes more options and examples (<a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html</a>) for other integrations so, check out the documentation for specifics (<a href="https://rustwasm.github.io/docs/wasm-bindgen/">https://rustwasm.github.io/docs/wasm-bindgen/</a>).</p>
<p>Not every crate can be compiled to <kbd>wasm32-unknown-unknown</kbd>, especially if they are using hardware access or operating system features. Some crates implement compatibility layers that are often specified as <kbd>cargo</kbd> features.  </p>
<p><em>Step 7</em> shows how to include the generated WASM bindings into a regular HTML page. Outside of the ES6 syntax (<a href="http://es6-features.org/#Constants">http://es6-features.org/#Constants</a>) (which may be unfamiliar to some), the Rust code is neatly wrapped in JavaScript functions, so no additional conversion is needed. For those interested in how this works, check out the <kbd>digest.js</kbd> file, which is quite readable but shows the complexity involved in transforming the data. That's it—the last step only shows how to serve the files and that the hosting actually works.</p>
<p>Now that we have learned how to run Rust in the browser, let's move on to the next recipe!</p>


            

            
        
    </div>
<div><h1 class="header-title">Using Rust and Python </h1>
                
            
            
                
<p>Python has become a staple language for many applications, from the web to data science. However, Python itself is an interpreted language and is famously quite slow—which is why it integrates well with much faster C code. Many well-liked libraries are implemented in C/C++ and Cython (<a href="https://cython.org/">https://cython.org/</a>) in order to achieve the required performance (for example, <kbd>numpy</kbd>, <kbd>pandas</kbd>, <kbd>keras</kbd>, and PyTorch are largely native code). Since Rust produces native binaries as well, let's look at how we can write Rust modules for Python. </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will work on creating an SHA256 digest again and will use the same folder structure as we have in every recipe in this chapter. Create a <kbd>python-rust</kbd> directory and initialize a new Rust project there using <kbd>cargo new rust-digest --lib</kbd>. </p>
<p>For the Python part of the project, install Python (3.6/3.7) by following the instructions on the website. Then, create the following folder structure and files (empty is OK for now) inside <kbd>python-rust/python</kbd>:</p>
<pre><strong>$ tree python</strong><br/>python<br/>├── setup.py<br/>└── src<br/>    └── digest.py<br/><br/>1 directory, 2 files</pre>
<p>Open the entire <kbd>python-rust</kbd> folder in VS Code and you are ready to go.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Python is a great language to integrate with—find out why in just a few steps:</p>
<ol>
<li class="mce-root">Open <kbd>rust-digest/src/lib.rs</kbd> to start off with the Rust code. Let's add the required <kbd>use</kbd> statements for FFI and <kbd>ring</kbd> and declare a <kbd>digest()</kbd> function to be exported. Note that this function is the same as in most other recipes in this chapter:</li>
</ol>
<pre style="color: black;padding-left: 60px">use std::ffi::{CStr, CString};<br/>use std::os::raw::c_char;<br/><br/>use ring::digest;<br/><br/>#[no_mangle]<br/>pub extern "C" fn digest(data: *mut c_char) -&gt; *mut c_char {<br/>    unsafe {<br/><br/>        let data = CStr::from_ptr(data);<br/>        let signature = digest::digest(&amp;digest::SHA256, <br/>         data.to_bytes());<br/><br/>        let hex_digest = signature<br/>            .as_ref()<br/>            .iter()<br/>            .map(|b| format!("{:X}", b))<br/>            .collect::&lt;String&gt;();<br/><br/>        CString::new(hex_digest).unwrap().into_raw()<br/>    }<br/>}<br/><br/>// No tests :( </pre>
<ol start="2">
<li class="mce-root">Since we are using <kbd>ring</kbd> and a third-party dependency to create the hash, let's declare them (and the library type) in <kbd>rust-digest/Cargo.toml</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">[lib]<br/>name = "digest"<br/>crate-type = ["cdylib"]<br/><br/>[dependencies]<br/>libc = "0.2"<br/>ring = "0.14"</pre>
<ol start="3">
<li class="mce-root">Now, let's build the library to obtain <kbd>libdigest.so</kbd> (or <kbd>digest.dll</kbd> or <kbd>libdigest.dylib</kbd>). Run <kbd>cargo build</kbd> inside <kbd>rust-digest</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo build</strong><br/>    Updating crates.io index<br/>   Compiling cc v1.0.37<br/>   Compiling libc v0.2.58<br/>   Compiling untrusted v0.6.2<br/>   Compiling spin v0.5.0<br/>   Compiling lazy_static v1.3.0<br/>   Compiling ring v0.14.6<br/>   Compiling rust-digest v0.1.0 (Rust-Cookbook/Chapter07/python-<br/>    rust/rust-digest)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 8.29s<br/>$ ls target/debug/<br/>build/ deps/ examples/ incremental/ libdigest.d <strong>libdigest.so*</strong> native/</pre>
<ol start="4">
<li class="mce-root">In order to load this library in Python, we need to write some code as well. Open <kbd>python/src/digest.py</kbd> and add the following content:</li>
</ol>
<pre style="color: black;padding-left: 60px">from ctypes import cdll, c_char_p<br/>from sys import platform<br/><br/>def build_lib_name(name):<br/>    prefix = "lib"<br/>    ext = "so"<br/><br/>    if platform == 'darwin':<br/>        ext = 'dylib'<br/>    elif platform == 'win32':<br/>        prefix = ""<br/>        ext = 'dll'<br/><br/>    return "{prefix}{name}.{ext}".format(prefix=prefix, name=name, ext=ext)<br/><br/>def main():<br/>    lib = cdll.LoadLibrary(build_lib_name("digest"))<br/>    lib.digest.restype = c_char_p<br/>    print("SHA256 of Hello World =", lib.digest(b"Hello World"))<br/><br/>if __name__ == "__main__":<br/>    main()</pre>
<p class="mce-root"/>
<ol start="5">
<li class="mce-root">While this file can be run by invoking <kbd>python3 digest.py</kbd>, it's not what a larger project will look like. Python's setuptools (<a href="https://setuptools.readthedocs.io/en/latest/">https://setuptools.readthedocs.io/en/latest/</a>) provide a better-structured approach to create and even install runnable scripts for the current OS. The common point of entry is the <kbd>setup.py</kbd> script, which declares metadata along with dependencies and entry points. Create <kbd>python/setup.py</kbd> with the following content:</li>
</ol>
<pre style="color: black;padding-left: 60px">#!/usr/bin/env python<br/># -*- coding: utf-8 -*-<br/><br/># Courtesy of https://github.com/kennethreitz/setup.py <br/><br/>from setuptools import find_packages, setup, Command<br/><br/># Package meta-data.<br/>NAME = 'digest'<br/>DESCRIPTION = 'A simple Python package that loads and executes a Rust function.'<br/>URL = 'https://blog.x5ff.xyz'<br/>AUTHOR = 'Claus Matzinger'<br/>REQUIRES_PYTHON = '&gt;=3.7.0'<br/>VERSION = '0.1.0'<br/>LICENSE = 'MIT'</pre>
<p style="color: black;padding-left: 60px">The file continues to input the declared variables into the <kbd>setup()</kbd> method, which generates the required metadata:</p>
<pre style="color: black;padding-left: 60px">setup(<br/>    # Meta stuff<br/>    name=NAME,<br/>    version=VERSION,<br/>    description=DESCRIPTION,<br/>    long_description=DESCRIPTION,<br/>    long_description_content_type='text/markdown',<br/>    # ---<br/>    package_dir={'':'src'}, # Declare src as root folder<br/>    packages=find_packages(exclude=["tests", "*.tests", "*.tests.*", <br/>     "tests.*"]), # Auto discover any Python packages<br/>    python_requires=REQUIRES_PYTHON,<br/>    # Scripts that will be generated invoke this method<br/>    entry_points={<br/>        'setuptools.installation': ['eggsecutable=digest:main'],<br/>    },<br/>    include_package_data=True,<br/>    license=LICENSE,<br/>    classifiers=[<br/>        # Trove classifiers<br/>        # Full list: https://pypi.python.org/pypi?<br/>         %3Aaction=list_classifiers<br/>        'License :: OSI Approved :: MIT License',<br/>        'Programming Language :: Python',<br/>        'Programming Language :: Python :: 3',<br/>        'Programming Language :: Python :: 3.7',<br/>        'Programming Language :: Python :: Implementation :: <br/>         CPython',<br/>        'Programming Language :: Python :: Implementation :: PyPy'<br/>    ],<br/>)</pre>
<ol start="6">
<li><em>Steps 6</em>, <em>7</em>, and <em>8</em> are for Linux/macOS only (or WSL). Windows users, please continue with <em>step 9</em>. Python's standalone modules are called eggs, so let's make one and run <kbd>python3 setup.py bdist_egg</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ python3 setup.py bdist_egg</strong><br/>running bdist_egg<br/>running egg_info<br/>writing src/digest.egg-info/PKG-INFO<br/>writing dependency_links to src/digest.egg-info/dependency_links.txt<br/>writing entry points to src/digest.egg-info/entry_points.txt<br/>writing top-level names to src/digest.egg-info/top_level.txt<br/>reading manifest file 'src/digest.egg-info/SOURCES.txt'<br/>writing manifest file 'src/digest.egg-info/SOURCES.txt'<br/>installing library code to build/bdist.linux-x86_64/egg<br/>running install_lib<br/>warning: install_lib: 'build/lib' does not exist -- no Python modules to install<br/><br/>creating build/bdist.linux-x86_64/egg<br/>creating build/bdist.linux-x86_64/egg/EGG-INFO<br/>copying src/digest.egg-info/PKG-INFO -&gt; build/bdist.linux-x86_64/egg/EGG-INFO<br/>copying src/digest.egg-info/SOURCES.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO<br/>copying src/digest.egg-info/dependency_links.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO<br/>copying src/digest.egg-info/entry_points.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO<br/>copying src/digest.egg-info/top_level.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO<br/>zip_safe flag not set; analyzing archive contents...<br/>creating 'dist/digest-0.1.0-py3.7.egg' and adding 'build/bdist.linux-x86_64/egg' to it<br/>removing 'build/bdist.linux-x86_64/egg' (and everything under it)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="7">
<li class="mce-root">This creates a <kbd>.egg</kbd> file in <kbd>python/dist</kbd>, which is built to run the <kbd>main()</kbd> function from the preceding script when invoked. On Mac/Linux, you have to run <kbd>chmod +x python/dist/digest-0.1.0-py3.7.egg</kbd> to be able to run it. Let's see what happens when we run it right away:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cd python/dist</strong><br/><strong>$  ./digest-0.1.0-py3.7.egg</strong><br/>Traceback (most recent call last):<br/>  File "&lt;string&gt;", line 1, in &lt;module&gt;<br/>  File "Rust-Cookbook/Chapter07/python-rust/python/src/digest.py", line 17, in main<br/>    lib = cdll.LoadLibrary(build_lib_name("digest"))<br/>  File "/usr/lib64/python3.7/ctypes/__init__.py", line 429, in LoadLibrary<br/>    return self._dlltype(name)<br/>  File "/usr/lib64/python3.7/ctypes/__init__.py", line 351, in __init__<br/>    self._handle = _dlopen(self._name, mode)<br/>OSError: libdigest.so: cannot open shared object file: No such file or directory</pre>
<ol start="8">
<li class="mce-root">Right, the library is only dynamically linked! We have to point our binary to the library or move the library where it can find it. On Mac/Linux, this can be accomplished by setting the <kbd>LD_LIBRARY_PATH</kbd> environment variable to wherever the Rust build output is located. The result is a Python program that calls into the compiled Rust code for an <kbd>SHA256</kbd> digest of a string:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ LD_LIBRARY_PATH=$(pwd)/../../rust-digest/target/debug/ ./digest-0.1.0-py3.7.egg</strong><br/><strong>SHA256 of Hello World = b'A591A6D4BF420404A11733CFB7B190D62C65BFBCDA32B57B277D9AD9F146E'</strong></pre>
<ol start="9">
<li class="mce-root">For Windows users, the execution is a little bit simpler. First, make the library available to Python and then run the script directly. Run the following from within the <kbd>python</kbd> directory to use Rust from within Python to generate the <kbd>SHA256</kbd> digest:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cp ../rust-digest/target/debug/digest.dll .</strong><br/><strong>$ python.exe src/digest.py</strong><br/><strong>SHA256 of Hello World = b'A591A6D4BF420404A11733CFB7B190D62C65BFBCDA32B57B277D9AD9F146E'</strong></pre>
<p>Let's look at how and why this works.</p>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Enhancing Python's capabilities with Rust is a great way to get the best of both worlds: Python is famously easy to learn and use; Rust is fast and safe (and does not fail at runtime as easily).</p>
<p>In <em>steps 1</em> to <em>3</em>, we again create a dynamic native library that creates an <kbd>SHA256</kbd> hash out of a provided string argument. The required changes in <kbd>Cargo.toml</kbd> and <kbd>lib.rs</kbd> are the same as if we were to create a library for C/C++ inter-op: <kbd>#[no_mangle]</kbd>. The <em>Including legacy C code</em> recipe earlier in this chapter describes the inner workings in more detail, so be sure to read the <em>How it works...</em> section there as well. </p>
<p>The <kbd>cdylib</kbd> library type describes a dynamic library for C, and other types are available for different purposes. Check out the nomicon (<a href="https://doc.rust-lang.org/nomicon/ffi.html">https://doc.rust-lang.org/nomicon/ffi.html</a>) and docs (<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries">https://doc.rust-lang.org/cargo/reference/manifest.html#building-dynamic-or-static-libraries</a>) for more details.  </p>
<p>Our Python code uses the <kbd>ctypes</kbd> (<a href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a>) part of the standard library to load the Rust module. In <em>step 4</em>, we show that Python's dynamic invocation capabilities seamlessly instantiate and integrate the type. However, the data types need to be interpreted accordingly, which is why the return type is set as a character pointer and the input is of the bytes type to achieve the same result as the other recipes in this chapter. Since platforms and programming languages use their own ways of encoding bytes to strings (UTF-8, UTF-16, ...), we have to pass a bytes literal (which translates to a <kbd>char*</kbd> in C) into the function.</p>
<p>In <em>steps 5</em> and <em>6</em>, we use Python's setuptools to create a <kbd>.egg</kbd> file, which is a distribution format for Python modules. In this particular case, we even create an eggsecutable (<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts">https://setuptools.readthedocs.io/en/latest/setuptools.html#eggsecutable-scripts</a>), which makes it possible to run the function by executing the <kbd>.egg</kbd> file. As shown in <em>step 7</em>, simply running it is not enough, since we also need to make the library known to the execution environment. In <em>step 8</em>, we are doing that and checking the result (more on <kbd>LD_LIBRARY_PATH</kbd> in the <em>How to do it...</em> section of the <em>Including legacy C code</em> recipe earlier in this chapter). </p>
<p>In <em>step 9</em>, we run the script on Windows. Windows uses a different mechanism to load dynamic libraries, so the <kbd>LD_LIBRARY_PATH</kbd> method does not work. On top of that, Python eggsecutables are only available on Linux/macOS, and setuptools provides great mechanisms for deployment right away, but not for local development (without further installations/complexities). This is why, on Windows, we are executing the script directly—which is the reason for <kbd>if __name__ == "__main__"</kbd>. </p>
<p>Now that we have learned how to successfully run Rust from within Python, let's move on to the next recipe.</p>


            

            
        
    </div>
<div><h1 class="header-title">Generating bindings for legacy applications</h1>
                
            
            
                
<p>As we saw in the first recipe, Rust's interop capabilities with other native languages require specific structures to be present on either side to declare the memory layout properly. This task is easy to automate using <kbd>rust-bindgen</kbd>. Let's see how this makes integrating with native code easier. </p>


            

            
        
    </div>
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Just like the first recipe in this chapter, <em>Including legacy C code</em>, this recipe has the following prerequisites:</p>
<ul>
<li><kbd>gcc</kbd> (<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>) (includes <kbd>ar</kbd> and <kbd>cc</kbd>)<a href="https://git-scm.com/"/></li>
<li><kbd>git</kbd> (<a href="https://git-scm.com/">https://git-scm.com/</a>) (command-line or UI tools are fine)</li>
<li><kbd>llvm</kbd> (<a href="https://releases.llvm.org/2.7/docs/UsingLibraries.html">https://releases.llvm.org/2.7/docs/UsingLibraries.html</a>) (library and header files for the LLVM compiler project)</li>
<li><kbd>libclang</kbd> (<a href="https://clang.llvm.org/doxygen/group__CINDEX.html">https://clang.llvm.org/doxygen/group__CINDEX.html</a>) (library and header files for the CLang compiler)</li>
</ul>
<p>The tools are available in any Linux/Unix environment (on Windows, you can use the WSL (<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a>)) and might require additional installs. Check your distribution's package repositories for the packages in the list.</p>
<p>On macOS, check out Homebrew, which is a package manager for Mac: <a href="https://brew.sh/">https://brew.sh/</a>.</p>
<p>Windows users best use the WSL and follow the Linux instructions, or install MinGW (<a href="http://www.mingw.org/">http://www.mingw.org/</a>), in an effort to provide GNU Linux tools for Windows. </p>
<p>Check whether the tools are properly installed by opening a Terminal window and issuing the following command:</p>
<pre><strong>$ cc --version</strong><br/>cc (GCC) 9.1.1 20190503 (Red Hat 9.1.1-1)<br/>Copyright (C) 2019 Free Software Foundation, Inc.<br/>This is free software; see the source for copying conditions. There is NO<br/>warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br/>$  ar --version<br/>GNU ar version 2.31.1-29.fc30<br/>Copyright (C) 2018 Free Software Foundation, Inc.<br/>This program is free software; you may redistribute it under the terms of<br/>the GNU General Public License version 3 or (at your option) any later version.<br/>This program has absolutely no warranty.<br/><strong>$ git --version</strong><br/>git version 2.21.0</pre>
<p>The versions should be similar (at least the major release) to avoid any unexpected differences. </p>
<p>Once ready, use the same shell to create a <kbd>bindgen</kbd> directory, and inside it run <kbd>cargo new rust-tinyexpr</kbd> and clone the TinyExpr GitHub repository (<a href="https://github.com/codeplea/tinyexpr">https://github.com/codeplea/tinyexpr</a>) using <kbd>git clone https://github.com/codeplea/tinyexpr</kbd>.  </p>


            

            
        
    </div>
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's create some bindings in just a few steps:</p>
<ol>
<li class="mce-root">Open <kbd>rust-tinyexpr/Cargo.toml</kbd> and add the appropriate build dependencies:</li>
</ol>
<pre style="color: black;padding-left: 60px">[build-dependencies]<br/>bindgen = "0.49"</pre>
<ol start="2">
<li class="mce-root">Create a new <kbd>rust-tinyexpr/build.rs</kbd> file and add the following content to create a custom build of the C library:</li>
</ol>
<pre style="color: black;padding-left: 60px">use std::env;<br/>use std::env::var;<br/>use std::path::PathBuf;<br/>const HEADER_FILE_NAME: &amp;'static str = "../tinyexpr/tinyexpr.h";<br/><br/>fn main() {<br/>    let project_dir = var("CARGO_MANIFEST_DIR").unwrap();<br/>    println!("cargo:rustc-link-search={}/../tinyexpr/", <br/>     project_dir);<br/>    println!("cargo:rustc-link-lib=static=tinyexpr");<br/><br/>    if cfg!(target_env = "msvc") {<br/>        println!("cargo:rustc-link-<br/>         lib=static=legacy_stdio_definitions");<br/>    }<br/>    <br/>    let bindings = bindgen::Builder::default()<br/>        .header(HEADER_FILE_NAME)<br/>        .generate()<br/>        .expect("Error generating bindings");<br/><br/>    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());<br/>    bindings<br/>        .write_to_file(out_path.join("bindings.rs"))<br/>        .expect("Error writing bindings");<br/>}</pre>
<ol start="3">
<li class="mce-root">Now for the actual Rust code. Open <kbd>rust-tinyexpr/src/main.rs</kbd> and add some code to include the file generated by <kbd>rust-bindgen</kbd> (which is called from <kbd>build.rs</kbd>):</li>
</ol>
<pre style="color: black;padding-left: 60px">#![allow(non_upper_case_globals)]<br/>#![allow(non_camel_case_types)]<br/>#![allow(non_snake_case)]<br/>use std::ffi::CString;<br/><br/>include!(concat!(env!("OUT_DIR"), "/bindings.rs"));<br/><br/>fn main() {<br/>    let expr = "sqrt(5^2+7^2+11^2+(8-2)^2)".to_owned();<br/>    let result = unsafe {<br/>        te_interp(CString::new(expr.clone()).unwrap().into_raw(), 0 as *mut i32)<br/>    };<br/>    println!("{} = {}", expr, result);<br/>}</pre>
<ol start="4">
<li class="mce-root">If we run <kbd>cargo build</kbd> now (inside <kbd>rust-tinyexpr</kbd>), we will see the following result:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$  cargo build</strong><br/>   Compiling libc v0.2.58<br/>   Compiling cc v1.0.37<br/>   Compiling autocfg v0.1.4<br/>   Compiling memchr v2.2.0<br/>   Compiling version_check v0.1.5<br/>   Compiling rustc-demangle v0.1.15<br/>   Compiling proc-macro2 v0.4.30<br/>   Compiling bitflags v1.1.0<br/>   Compiling ucd-util v0.1.3<br/>   Compiling byteorder v1.3.2<br/>   Compiling lazy_static v1.3.0<br/>   Compiling regex v1.1.7<br/>   Compiling glob v0.2.11<br/>   Compiling cfg-if v0.1.9<br/>   Compiling quick-error v1.2.2<br/>   Compiling utf8-ranges v1.0.3<br/>   Compiling unicode-xid v0.1.0<br/>   Compiling unicode-width v0.1.5<br/>   Compiling vec_map v0.8.1<br/>   Compiling ansi_term v0.11.0<br/>   Compiling termcolor v1.0.5<br/>   Compiling strsim v0.8.0<br/>   Compiling bindgen v0.49.3<br/>   Compiling peeking_take_while v0.1.2<br/>   Compiling shlex v0.1.1<br/>   Compiling backtrace v0.3.31<br/>   Compiling nom v4.2.3<br/>   Compiling regex-syntax v0.6.7<br/>   Compiling thread_local v0.3.6<br/>   Compiling log v0.4.6<br/>   Compiling humantime v1.2.0<br/>   Compiling textwrap v0.11.0<br/>   Compiling backtrace-sys v0.1.28<br/>   Compiling libloading v0.5.1<br/>   Compiling clang-sys v0.28.0<br/>   Compiling atty v0.2.11<br/>   Compiling aho-corasick v0.7.3<br/>   Compiling fxhash v0.2.1<br/>   Compiling clap v2.33.0<br/>   Compiling quote v0.6.12<br/>   Compiling cexpr v0.3.5<br/>   Compiling failure v0.1.5<br/>   Compiling which v2.0.1<br/>   Compiling env_logger v0.6.1<br/>   Compiling rust-tinyexpr v0.1.0 (Rust-Cookbook/Chapter07/bindgen/rust-tinyexpr)<br/>error: linking with `cc` failed: exit code: 1<br/>[...]<br/>"-Wl,-Bdynamic" "-ldl" "-lrt" "-lpthread" "-lgcc_s" "-lc" "-lm" "-lrt" "-lpthread" "-lutil" "-lutil"<br/>  = note: /usr/bin/ld: cannot find -ltinyexpr<br/>          collect2: error: ld returned 1 exit status<br/>          <br/><br/>error: aborting due to previous error<br/><br/>error: Could not compile `rust-tinyexpr`.<br/><br/>To learn more, run the command again with --verbose.</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li class="mce-root">This is a linker error—the linker could not find the library! This is because we never actually created it. Change into the <kbd>tinyexpr</kbd> directory and run these commands to create a static library from the source code on Linux/macOS:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cc -c -ansi -Wall -Wshadow -O2 tinyexpr.c -o tinyexpr.o -fPIC</strong><br/><strong>$ ar rcs libtinyexpr.a tinyexpr.o</strong></pre>
<p style="padding-left: 60px" class="mce-root">With Windows, the process is a little bit different:</p>
<pre style="color: black;padding-left: 60px"><strong>$ gcc -c -ansi -Wall -Wshadow -O2 tinyexpr.c -o tinyexpr.lib -fPIC</strong></pre>
<ol start="6">
<li class="mce-root">Going back into the <kbd>rust-tinyexpr</kbd> directory, we can run <kbd>cargo build</kbd> again:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo build</strong><br/>   Compiling rust-tinyexpr v0.1.0 (Rust-Cookbook/Chapter07/bindgen/rust-tinyexpr)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.31s</pre>
<ol start="7">
<li class="mce-root">As a bonus, <kbd>bindgen</kbd> also generates tests, so we can run <kbd>cargo test</kbd> to make sure the binary layout is validated. Then, let's parse an expression using the TinyExpr C library from Rust:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ cargo test</strong><br/>   Compiling rust-tinyexpr v0.1.0 (Rust-<br/>    Cookbook/Chapter07/bindgen/rust-tinyexpr)<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.36s<br/>     Running target/debug/deps/rust_tinyexpr-fbf606d893dc44c6<br/><br/>running 3 tests<br/>test bindgen_test_layout_te_expr ... ok<br/>test bindgen_test_layout_te_expr__bindgen_ty_1 ... ok<br/>test bindgen_test_layout_te_variable ... ok<br/><br/>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out<br/><strong>$ cargo run</strong><br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.04s<br/>     Running `target/debug/rust-tinyexpr`<br/>    sqrt(5^2+7^2+11^2+(8-2)^2) = 15.198684153570664</pre>
<p>Let's see how we achieved this result.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>bindgen</kbd> is an amazing tool that generates Rust code from C/C++ headers <em>on the fly</em>. In <em>step 1</em> and<em> 2</em>, we added the dependency and used the <kbd>bindgen</kbd> API to load the header and generate and output a file called <kbd>bindings.rs</kbd> in the temporary <kbd>build</kbd> directory. The <kbd>OUT_DIR</kbd> variable is only available from within <kbd>cargo</kbd>'s build environment and leads to a directory containing several build artifacts. </p>
<p>Additionally, the linker needs to know about the library that has been created so it can link to it. This is done by printing out the required parameters to standard with a special syntax. In this case, we pass the library's name (<kbd>link-lib</kbd>) and the directory it should check (<kbd>link-search</kbd>) to the <kbd>rustc</kbd> linker. <kbd>cargo</kbd> can do much more with these outputs. Check the docs (<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">https://doc.rust-lang.org/cargo/reference/build-scripts.html</a>) for more information. </p>
<p>Microsoft's <kbd>msvc</kbd> compiler introduced a breaking change by removing the standard <kbd>printf</kbd> functions in favor of more secure variations. In order to minimize the complexity of cross-platform compilation, a simple compiler switch was introduced in <em>step 4</em> to bring back the <kbd>printf</kbd> legacy.</p>
<p><em>Step 3</em> creates the Rust code to call the linked functions (while discarding several warnings about naming) by including the file. While <kbd>bindgen</kbd> takes away the generation of the interface, it's still necessary to use C-compatible types for passing parameters. This is why we have to create the pointer when we call the function. </p>
<p>If we compiled the Rust code right after this step, we would end up with a huge error message, as shown in <em>step 4</em>. To remedy this, we create the static library from the C code in <em>step 5</em>, using a few compiler flags for <kbd>cc</kbd> (the <kbd>gcc</kbd> C compiler), such as <kbd>-fPIC</kbd> (which stands for <em>position independent code</em>), which creates consistent positions within the file, so it's usable as a library. The output of the <kbd>cc</kbd> call is an object file, which is then <em>archived</em> in a static library using the <kbd>ar</kbd> tool. </p>
<p>If the library is properly available, we can use <kbd>cargo build</kbd> and <kbd>cargo run</kbd>—as shown in the last two steps—to execute the code.</p>
<p>Now that we know how to integrate Rust with other languages, let's move on to another chapter to deep dive into a different topic.</p>


            

            
        
    </div></body></html>