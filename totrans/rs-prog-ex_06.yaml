- en: Implementing the Engine of the Music Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现音乐播放器引擎
- en: In the previous chapter, we implemented the user interface of the music player,
    but it is unable to play any music. We'll tackle that challenge in this chapter.
    We'll create the engine of the music player so that it can play MP3 files. To
    do this, we'll need to use threads so that playing a song does not freeze the
    interface, so it will be a good opportunity to learn about concurrency in Rust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了音乐播放器的用户界面，但它无法播放任何音乐。我们将在这个章节中解决这个挑战。我们将创建音乐播放器的引擎，使其能够播放MP3文件。为此，我们需要使用线程，以确保播放歌曲不会冻结界面，这将是一个学习Rust并发的好机会。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: MP3 decoder
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MP3解码器
- en: Threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Mutex and Mutex guards
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁和互斥锁保护
- en: Send/Sync traits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Send/Sync特质
- en: RAII
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAII
- en: Thread safety
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全性
- en: Interior mutability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部可变性
- en: Installing the dependencies
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'For this chapter, we''ll need two libraries: `pulseaudio` and `libmad`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要两个库：`pulseaudio`和`libmad`。
- en: The former will be used to play the music, while the latter is for decoding
    MP3 files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前者将用于播放音乐，而后者用于解码MP3文件。
- en: Installing dependencies on Linux
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装依赖项
- en: On Linux, these dependencies can be installed through the package manager of
    your distribution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，这些依赖项可以通过您发行版的包管理器安装。
- en: 'On Ubuntu (or other Debian derivatives):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu（或其他Debian衍生版）上：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing dependencies on Mac
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上安装依赖项
- en: 'On OSX, the required dependencies can be installed through the system package
    manager, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSX上，可以通过系统包管理器安装所需的依赖项，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing dependencies on Windows
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装依赖项
- en: 'On Windows, run the following command in a MSYS2 shell:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，在MSYS2壳中运行以下命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Think, click the link to download the zip file from this page: [https://www.freedesktop.org/wiki/Software/PulseAudio/Ports/Windows/Support/](https://www.freedesktop.org/wiki/Software/PulseAudio/Ports/Windows/Support/)
    (When the book was written, the link for the current version was [http://bosmans.ch/pulseaudio/pulseaudio-1.1.zip](http://bosmans.ch/pulseaudio/pulseaudio-1.1.zip)).
    Then, follow the same instructions as the ones from [Chapter 2](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7),
    *Starting with SDL*, to use the library from Rust.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 思考，点击此页面的链接下载zip文件：[https://www.freedesktop.org/wiki/Software/PulseAudio/Ports/Windows/Support/](https://www.freedesktop.org/wiki/Software/PulseAudio/Ports/Windows/Support/)（当本书编写时，当前版本的链接为[http://bosmans.ch/pulseaudio/pulseaudio-1.1.zip](http://bosmans.ch/pulseaudio/pulseaudio-1.1.zip)）。然后，按照[第2章](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7)中“从SDL开始”的相同说明，使用Rust库。
- en: Decoding MP3 files
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码MP3文件
- en: We'll start this chapter by learning how to decode an MP3 file to a format suitable
    to be played by the operating system using the `simplemad` crate, a binding for
    `libmad`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始学习如何使用`simplemad`crate（`libmad`的绑定）将MP3文件解码为操作系统可播放的格式，这将帮助我们理解如何解码MP3文件。
- en: Adding dependencies
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'Let''s add the following to `Cargo.toml`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Cargo.toml`中添加以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We also added the `pulse-simple` and `crossbeam` crates because we'll need them
    later. The former will be used to play the songs with `pulseaudio` and the latter
    will be used to implement the event loop of the music player engine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`pulse-simple`和`crossbeam`crate，因为我们在以后需要它们。前者将用于使用`pulseaudio`播放歌曲，后者将用于实现音乐播放器引擎的事件循环。
- en: 'We also need to add the following statements in `main.rs`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`main.rs`中添加以下语句：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition to the `extern crate` statements, we have a `mod` statement since
    we'll create a new module for the MP3 decoder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`extern crate`语句外，我们还有一个`mod`语句，因为我们将为MP3解码器创建一个新的模块。
- en: Implementing an MP3 decoder
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现MP3解码器
- en: 'We''re now ready to create this new module. Create a new `mp3.rs` file with
    the following content:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建这个新模块了。创建一个名为`mp3.rs`的新文件，内容如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We start this module with some import statements as usual. The important one
    is `simplemad`, which will be used to decode the frames of an MP3 file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样从这个模块开始，添加一些导入语句。其中重要的是`simplemad`，它将被用来解码MP3文件的帧：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We saw in [Chapter 1](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7),
    *Basics of Rust*, that we can add trait bounds to generic parameters in a function.
    We can also add them to the generic parameters of a type. Here we see an alternative
    syntax using a `where` clause. The previous structure declaration is the same
    as the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0020.html#J2B80-13a27bdc411a4c2eaad1cc3a71f7fca7)，“Rust基础”中，我们了解到我们可以在函数的泛型参数中添加特质界限。我们也可以将它们添加到类型的泛型参数中。这里我们看到使用`where`子句的替代语法。前面的结构声明与以下相同：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `where` clause is useful when we have a lot a generic parameters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`子句在有很多泛型参数时很有用。'
- en: This structure contains information about the current frame and time as well
    as the decoder itself, which comes from the `simplemad` crate. This `Decoder`
    also requires a generic parameter that implements the `Read` trait, so we just
    use our own `R` parameter since we specified that it must implement this trait.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包含有关当前帧和时间以及解码器本身的信息，解码器来自`simplemad`crate。这个`Decoder`还需要一个实现`Read`特质的泛型参数，所以我们只需使用自己的`R`参数，因为我们指定它必须实现这个特质。
- en: 'Before we move on to the constructor of this type, we''ll implement a couple
    of `utility` functions. Let''s start with a function that converts `Duration`
    to a number of milliseconds (this function will go in the `main.rs` file since
    we''ll use it in another module):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到这个类型的构造函数之前，我们将实现几个`utility`函数。让我们从一个将`Duration`转换为毫秒数的函数开始（这个函数将放在`main.rs`文件中，因为我们将在另一个模块中使用它）：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we simply multiply the number of seconds by `1,000` and divide the number
    of nanoseconds by `1,000,000`. This function requires you to add an import statement
    for `Duration`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地乘以秒数乘以`1,000`，并将纳秒数除以`1,000,000`。这个函数需要您添加对`Duration`的导入语句：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we''ll write a function to check whether a stream of data is an MP3 file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个函数来检查数据流是否为MP3文件：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To do so, we try to decode the stream and if the result is `Ok`, then the data
    is an MP3 file. We then go back to the beginning of the file before returning
    whether it is an MP3 file or not.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们尝试解码流，如果结果是`Ok`，则数据是MP3文件。然后我们回到文件的开头，在返回是否是MP3文件之前。
- en: 'The next function we''ll need is one to decode the next frame of an MP3 file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要的功能是解码MP3文件的下一个帧：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we simply get the next frame from the decoder and flatten the `Option<Result<Frame>>`
    to `Option<Frame>` by calling `and_then(Result::ok)`. If there's no frame, we
    return a default frame.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地从解码器获取下一个帧，并通过调用`and_then(Result::ok)`将`Option<Result<Frame>>`扁平化为`Option<Frame>`。如果没有帧，我们返回一个默认帧。
- en: 'Now, let''s implement the constructor of our MP3 decoder:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的MP3解码器的构造函数：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You need to add an import statement at the top of this file to be able to use
    the `to_millis` function, which is in the `main` module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在文件顶部添加一个导入语句，以便能够使用`to_millis`函数，该函数位于`main`模块中：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since the `use` statements are relative to the root of the crate, we only need
    to write the function name because this function is at the crate's root.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`use`语句相对于crate的根目录，我们只需写出函数名，因为这个函数在crate的根目录。
- en: The constructor first checks whether the stream contains MP3 data, if not, we
    return an error. Otherwise, we create a `Decoder` from the `simplemad` crate.
    Then, we read the first frame and get its time in milliseconds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数首先检查流是否包含MP3数据，如果不是，我们返回一个错误。否则，我们从`simplemad`crate创建一个`Decoder`。然后，我们读取第一个帧并获取其毫秒时间。
- en: 'Next, we write two methods to get the current time and the rate of the MP3
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写两个方法来获取MP3文件当前的时间和速率：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These methods are to be added in the `impl Mp3Decoder` block. The last method
    to be added to this structure is a method to compute the duration of a song:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法需要添加到`impl Mp3Decoder`块中。要添加到这个结构中的最后一个方法是计算歌曲的持续时间：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we create an associated function: it first checks whether it is MP3 data.
    Here, instead of using `Decoder::decode()`, we use `Decoder::decode_headers()`
    because we only need the frame duration and it is faster to only decode the headers.
    The `decoder` is an iterator and we call `filter_map()` on it. As you saw in [Chapter
    2](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7), *Starting with SDL*,
    `filter_map()` transforms and filters the elements of an iterator. Transforming
    a value is done by returning `Some(new_value)`, while filtering out a value is
    done by returning `None`. After that, we call `sum()` on the resulting iterator
    to get the sum of all the durations.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个关联函数：它首先检查是否是MP3数据。在这里，我们不是使用`Decoder::decode()`，而是使用`Decoder::decode_headers()`，因为我们只需要帧持续时间，只解码头部更快。`decoder`是一个迭代器，我们在它上面调用`filter_map()`。正如你在[第2章](part0063.html#1S2JE0-13a27bdc411a4c2eaad1cc3a71f7fca7)中看到的，*从SDL开始*，`filter_map()`会转换和过滤迭代器的元素。通过返回`Some(new_value)`来转换值，而通过返回`None`来过滤掉值。之后，我们在结果迭代器上调用`sum()`以获取所有持续时间的总和。
- en: Getting the frame samples
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帧样本
- en: 'The only remaining feature needed for our MP3 decoder is to be able to iterate
    over the samples. We''ll first write a function to get the next sample:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们MP3解码器所需的功能仅剩下能够遍历样本。我们首先编写一个获取下一个样本的函数：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This function is doing some bit shifting to get the sample and then fetch the
    next frame. We''re now ready to implement an iterator that will use this function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数正在进行一些位移动以获取样本，然后获取下一个帧。我们现在准备好实现一个将使用此函数的迭代器：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we can implement our own iterator by implementing the `Iterator`
    trait. The only required method is `next()`. By implementing this simple method,
    we get a whole bunch of features because this trait has a lot of default methods.
    The `type Item` is also required. We implement the `size_hint()` method, even
    though it is an optional one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以通过实现`Iterator`特质来创建自己的迭代器。唯一需要实现的方法是`next()`。通过实现这个简单的方法，我们获得了一大批功能，因为这个特质有很多默认方法。`type
    Item`也是必需的。我们实现了`size_hint()`方法，尽管它是可选的。
- en: Playing music
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐
- en: 'With the MP3 decoder done, we''re now ready to play some music. We''ll create
    a new module, called player, which we will add at the top of `main.rs`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MP3解码器完成之后，我们现在可以播放音乐了。我们将创建一个新的模块，命名为player，并将其添加到`main.rs`的顶部：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll start this module by creating a new `player.rs` file with the following
    import statements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个模块开始，创建一个包含以下导入语句的`player.rs`新文件：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll also create some constants:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一些常量：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The buffer size is the number of samples we'll decode and play to avoid having
    slowdowns when playing the song and also to avoid using 100% of the CPU by constantly
    reading and decoding the data at the same time as playing. The default rate will
    be used when we cannot find one in the MP3 file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区大小是我们将解码和播放的样本数量，以避免在播放歌曲时出现减速，同时也避免通过同时读取和解码数据来使用100%的CPU。当我们在MP3文件中找不到时，将使用默认速率。
- en: Event loop
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: To simplify the development of our playing engine, we'll use the concept of
    an event loop. Some actions will be sent to the thread playing the music through
    this event loop. For instance, we will be able to emit a `Load("file.mp3")` event,
    the thread will decode this MP3 file, and start playing it. Another example of
    an event is `Stop`, which will stop playing and unload the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化播放引擎的开发，我们将使用事件循环的概念。一些操作将通过这个事件循环发送到播放音乐的线程。例如，我们将能够发出一个`Load("file.mp3")`事件，线程将解码这个MP3文件，并开始播放。另一个事件示例是`Stop`，它将停止播放并卸载数据。
- en: 'Let''s create an enumeration for the possible actions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个枚举来表示可能的操作：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''re now ready to create the structure of the event loop:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建事件循环的结构：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's a lot of unknown stuff in this structure, so let's break it down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构中有许多未知的内容，让我们来分解它。
- en: Atomic reference counting
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子引用计数
- en: 'First of all, we use the `Arc` type. It is similar to the `Rc` type that we
    used in the previous chapter, in that it is a type providing reference counting.
    The difference between these two types is that `Arc` uses atomic operations to
    increment its counter. By being atomic, it is safe to be used by multiple threads
    while `Rc` cannot be safely used across threads (and the compiler prevents us
    from trying to do so). The standard library provides these two types so that you
    can choose the cost you want to pay. If you don''t need to share a reference-counted
    value with multiple threads, choose `Rc` as it is more efficient than `Arc`. If
    you try to send an `Rc` to another thread, the compiler will trigger an error:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Arc`类型。它与我们之前章节中使用的`Rc`类型类似，因为它是一个提供引用计数的类型。这两个类型之间的区别在于`Arc`使用原子操作来增加其计数器。由于是原子的，它可以在多个线程中安全使用，而`Rc`则不能在多个线程中安全使用（编译器会阻止我们这样做）。标准库提供这两种类型，以便你可以选择你愿意付出的代价。如果你不需要与多个线程共享引用计数值，请选择`Rc`，因为它比`Arc`更高效。如果你尝试将`Rc`发送到另一个线程，编译器将触发一个错误：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, you'll need to switch to an `Arc`. This error will make more sense
    when we see what the `Send` trait is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要切换到`Arc`。当我们看到`Send`特质是什么时，这个错误将更有意义。
- en: Mutual exclusion
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥
- en: In the `playing` field, the `Arc` contains a `Mutex`. A mutex provides mutual
    exclusion, meaning that it allows us to lock its inner value (in this case, a
    `bool`) preventing other threads from manipulating the same value at the same
    time. It prevents data races, which is a cause of undefined behavior, by preventing
    concurrent reads and writes on a value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`play`区域，`Arc`中包含一个`Mutex`。互斥锁提供互斥性，意味着它允许我们锁定其内部值（在这种情况下，一个`bool`），防止其他线程同时操作相同的值。它通过防止对值的并发读写来防止数据竞争，这是未定义行为的原因。
- en: Send trait
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送特质
- en: But how can the compiler prevent us from doing data races? This is thanks to
    the `Send` and `Sync` marker traits. A type that implements the `Send` trait is
    safe to be sent to another thread. As you may have guessed, `Rc` does not implement
    `Send`. Since it does not use atomic operations to increment its counter, if two
    threads were to increment it at the same time, that would be a data race.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但编译器是如何防止我们发生数据竞争的呢？这要归功于`Send`和`Sync`标记特质。实现了`Send`特质的数据类型可以安全地发送到另一个线程。正如你可能猜到的，`Rc`没有实现`Send`。由于它没有使用原子操作来增加其计数器，如果两个线程同时增加它，那将是一个数据竞争。
- en: Sync trait
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步特质
- en: 'Let''s discuss the second of these marker traits: `Sync`. A type that implements
    the `Sync` trait is safe to be shared with multiple threads. An example of a `Sync`
    type is `Mutex`. It is safe because the only way to get a value from `Mutex` is
    to lock it, which is mutually exclusive (another thread cannot access the same
    value at the same time).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论第二个标记特质：`Sync`。实现了`Sync`特质的数据类型可以安全地与多个线程共享。一个`Sync`类型的例子是`Mutex`。它是安全的，因为从`Mutex`获取值的唯一方式是锁定它，这是互斥的（另一个线程不能同时访问相同的值）。
- en: Lock-free data structures
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无锁数据结构
- en: The only remaining type to explain is `SegQueue`, from the `crossbeam` crate.
    This type is a lock-free queue, meaning that it can be used concurrently by multiple
    threads without a lock. The implementation of lock-free data structures is beyond
    the scope of this book, but it suffices to say that it uses atomic operations
    behind the scenes so that we don't need to use a `Mutex` to mutate this value
    in mutable threads at the same time. We still need to wrap this queue in an `Arc`
    to be able to share it with multiple threads.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要解释的唯一类型是来自`crossbeam`包的`SegQueue`。这个类型是一个无锁队列，意味着它可以由多个线程并发使用而不需要锁。无锁数据结构的实现超出了本书的范围，但可以说它使用原子操作在幕后，这样我们就不需要使用`Mutex`来在可变线程中同时修改这个值。我们仍然需要用`Arc`包装这个队列，以便能够与多个线程共享。
- en: We're using a lock-free data structure because we'll be constantly checking
    whether there's a new element in this queue while possibly adding new elements
    to this queue from another thread. If we were to use `Mutex<VecDeque<Action>>`,
    it would be less efficient because calling `lock()` on `Mutex` waits if the lock
    is held by another thread.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用无锁数据结构，因为我们将在队列中不断检查是否有新元素，同时可能从另一个线程向这个队列添加新元素。如果我们使用`Mutex<VecDeque<Action>>`，它将效率更低，因为在对`Mutex`调用`lock()`时，如果锁被另一个线程持有，它将等待。
- en: 'Let''s get back to our event loop. Let''s add a constructor for `EventLoop`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的事件循环。让我们为`EventLoop`添加一个构造函数：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This constructor simply creates the queue and the Boolean wrapped in a `Mutex`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数简单地创建队列和布尔值，并将其包裹在`Mutex`中。
- en: 'Before we use it, we''ll create a `State` structure that will contain various
    data shared between the GUI thread and the music player thread, put this code
    in the `main` module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用它之前，我们将创建一个`State`结构，该结构将包含GUI线程和音乐播放器线程之间共享的各种数据，将此代码放在`main`模块中：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, add a `state` field in the `App` structure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在`App`结构中添加一个`state`字段：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This requires a new import statement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个新的导入语句：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since this value will be shared with another thread, we need to wrap it in
    `Arc<Mutex>`. Then, in the constructor, create this value and assign it to this
    new field, while also sending it to the `Playlist` constructor:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个值将被另一个线程共享，我们需要将其包裹在`Arc<Mutex>`中。然后在构造函数中，创建这个值并将其分配给这个新字段，同时将其发送到`Playlist`构造函数：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s update the `Playlist` constructor:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`Playlist`构造函数：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The structure requires a new field, so let''s add it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结构需要一个新的字段，所以让我们添加它：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This also needs new import statements:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这也需要新的导入语句：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We use the `pub(crate)` syntax to silent an error. Since we're using a private
    type (`State`) in a public method, the compiler throws an error. This syntax means
    that the function is public to the other modules of the crate, but other crates
    cannot access it. Here, we only send the `state` to the `Player` constructor,
    which we will implement right away.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pub(crate)`语法来抑制错误。由于我们在公共方法中使用私有类型（`State`），编译器会抛出一个错误。这个语法意味着该函数对crate的其他模块是公共的，但其他crate无法访问它。在这里，我们只向`Player`构造函数发送`state`，我们将立即实现它。
- en: Playing music
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐
- en: 'We''ll create a new `Player` structure to wrap the event loop. The player will
    be usable from the main thread to control the music. Here''s the structure itself:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`Player`结构来包裹事件循环。播放器将从主线程中可用，以控制音乐。以下是该结构的本身：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And here''s the start of its constructor:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其构造函数的开始：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We start by creating a new event loop. Then, we start a new thread. We used
    a new scope to avoid having to rename the variables that will be sent to the thread
    because these variables are used in the initialization of the structure at the
    end of the constructor. Again, we need to use a `move` closure because we're sending
    a copy of the event loop and the application state to the thread.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的事件循环。然后，我们启动一个新的线程。我们使用一个新的作用域来避免必须重命名将被发送到线程的变量，因为这些变量在构造函数末尾的结构初始化中使用。再次，我们需要使用`move`闭包，因为我们正在向线程发送事件循环和应用程序状态的副本。
- en: 'Let''s see the first part of the thread''s closure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看线程闭包的第一部分：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We start by creating a buffer to contain the samples to be played. Then we''ll
    create a `Playback`, which is an object that will allow us to play music on the
    hardware. We''ll also create a `source` variable that will contain an `Mp3Decoder`.
    We then start an infinite loop and try to get the first element in the queue:
    if there''s an element in the queue, `Some(action)` is returned. That''s why we
    used `if let` to pattern match against the result of this method call. We then
    match against the action to see which action it is: if it is a `Load` action,
    we open the file with the specified path and create an `Mp3Decoder` with a buffered
    reader of this file. We then try to get the sample rate of the song and create
    a new `Playback` with this rate. We''ll handle the `Stop` action later.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个缓冲区来包含要播放的样本。然后我们将创建一个`Playback`，这是一个对象，它将允许我们在硬件上播放音乐。我们还将创建一个`source`变量，它将包含一个`Mp3Decoder`。然后我们启动一个无限循环并尝试获取队列中的第一个元素：如果队列中有元素，则返回`Some(action)`。这就是为什么我们使用了`if
    let`来对方法调用的结果进行模式匹配。然后我们对动作进行匹配以查看它是哪种动作：如果是`Load`动作，我们使用指定的路径打开文件，并使用该文件的缓冲读取器创建一个`Mp3Decoder`。然后我们尝试获取歌曲的采样率并使用这个率创建一个新的`Playback`。我们稍后会处理`Stop`动作。
- en: 'Finally, we see our first use of `Mutex`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到我们第一次使用`Mutex`：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s rewrite it in another way to see what''s going on:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以另一种方式重写它来看看发生了什么：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We first call `lock()`, which returns a `Result<MutexGuard<T>, PoisonError<MutexGuard<T>>>`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`lock()`，它返回一个`Result<MutexGuard<T>, PoisonError<MutexGuard<T>>>`。
- en: Mutex guard
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mutex guard
- en: 'A mutex guard is a scoped lock: this means that the mutex will be automatically
    unlocked when going out of scope. It is a nice way to ensure that users will use
    a `Mutex` and won''t forget to unlock it.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定器（mutex guard）是一个作用域锁：这意味着当超出作用域时，互斥锁将被自动解锁。这是一种确保用户会使用`Mutex`并且不会忘记解锁它的好方法。
- en: RAII
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAII
- en: But how does it work behind the scene? Rust uses the idiom of **Resource Acquisition
    Is Initialization**(**RAII)** for short. With this idiom, a resource is allocated
    in the constructor and released in its destructor. In Rust, destructors are implemented
    by the `Drop` trait. So, to get back to mutex guards, the mutex is unlocked when
    the destructor of `MutexGuard` is called, so, as in the previous example, when
    the `guard` variable goes out of scope.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但它背后是如何工作的呢？Rust使用**资源获取即初始化**（**RAII**）的惯用用法。使用这个惯用用法，资源在构造函数中分配，并在析构函数中释放。在Rust中，析构函数是通过`Drop`特质实现的。所以，回到互斥锁守卫，当`MutexGuard`的析构函数被调用时，互斥锁会被解锁，所以，就像之前的例子一样，当`guard`变量超出作用域时。
- en: 'Let''s get back to our infinite loop:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的无限循环：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we check whether the playing value is true (again using the `lock().unwrap()`
    trick). We must use a `*` to access the value of a `MutexGuard` because it implements
    `Deref`. That means we don't have direct access to the underlying value. But since
    it implements the `Deref` trait, we can access it by dereferencing the guard (with
    a `*`). We didn't need this trick before because we accessed a field and Rust
    automatically dereferences fields.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查播放值是否为真（再次使用`lock().unwrap()`技巧）。我们必须使用`*`来访问`MutexGuard`的值，因为它实现了`Deref`。这意味着我们没有直接访问底层值。但由于它实现了`Deref`特质，我们可以通过解引用守卫（使用`*`）来访问它。我们之前不需要这个技巧，因为我们访问了一个字段，Rust会自动解引用字段。
- en: We then create a `written` variable that will be `true` if the player was able
    to play a sample. If it was unable to play one, this means the song came to an
    end. In this case, we set the `stopped` value to `true` and `playing` to `false`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后创建一个`written`变量，如果播放器能够播放一个样本，它将是`true`。如果它无法播放一个，这意味着歌曲已经结束。在这种情况下，我们将`stopped`值设置为`true`，将`playing`设置为`false`。
- en: To play the samples, we call `iter_to_buffer`, which will take the value from
    the decoder (which is an `Iterator`) and write them to the buffer. Afterward,
    it will write the buffer to the `playback` in order to play the samples on your
    sound card.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放样本，我们调用`iter_to_buffer`，它将从解码器（它是一个`Iterator`）中获取值并将它们写入缓冲区。之后，它将缓冲区写入`playback`以在您的声卡上播放样本。
- en: 'Let''s look at this `iter_to_buffer` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个`iter_to_buffer`函数：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We start by taking `BUFFER_SIZE` elements from the iterator and add them to
    the buffer two at a time (for two channels). We then return the number of elements
    written to the buffer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从迭代器中取出`BUFFER_SIZE`个元素，并将它们两次（对于两个通道）添加到缓冲区中。然后我们返回写入缓冲区的元素数量。
- en: Using the music player
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音乐播放器
- en: We're now ready to use our music engine. Let's add a couple of new methods to
    `Playlist`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好使用我们的音乐引擎了。让我们给`Playlist`添加几个新方法。
- en: 'Let''s start with a method to get the path of the selection:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取选择项路径的方法开始：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We start by getting the selection, then we get the iterator for the selection.
    From the iterator, we can get the value at the specified column to get the path.
    We can now add a method to load the selected song:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取选择项，然后获取选择项的迭代器。从迭代器中，我们可以获取指定列的值以获取路径。我们现在可以添加一个方法来加载所选歌曲：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If there's a selected song, we load it into the music engine. We return true
    if a song was loaded.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有选定的歌曲，我们将它加载到音乐引擎中。如果歌曲被加载，我们返回`true`。
- en: 'We''ll now use this method in the event handler of the play button:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在播放按钮的事件处理程序中使用这个方法：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We create a copy of the `playlist` variable because it is moved into the closure.
    In the latter, we then call the `play()` method we created just before. We only
    change the image of the button and show the cover if a song starts to play.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`playlist`变量的一个副本，因为它被移动到了闭包中。在后者中，我们随后调用了我们刚才创建的`play()`方法。我们只更改按钮的图像，并在歌曲开始播放时显示封面。
- en: 'You can now try the music player: open an MP3 file, click play, and you should
    hear the song. Let''s continue to develop the software since many features are
    missing.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试音乐播放器了：打开一个MP3文件，点击播放，你应该能听到歌曲。让我们继续开发软件，因为还有很多功能缺失。
- en: Pausing and resuming the song
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和恢复歌曲
- en: We'll start by adding a field indicating whether the player is in pause or not.
    This field will be changed by methods such as `play` or `resume`. However, remember
    that our `Playlist` is wrapped in an `Rc`, so that we can use it in different
    places, namely in the event handlers. Also, remember that Rust forbids mutation
    when there are mutable references to a value. How can we update this field while
    still using a reference-counted pointer? One way is to use interior mutability.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个字段来指示播放器是否处于暂停状态。此字段将由 `play` 或 `resume` 等方法更改。然而，请记住，我们的 `Playlist`
    被包装在一个 `Rc` 中，这样我们就可以在不同的地方使用它，即在事件处理程序中。还要记住，Rust 禁止在存在对值的可变引用时进行修改。我们如何使用引用计数指针来更新此字段？一种方法是通过内部可变性。
- en: Interior mutability
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部可变性
- en: 'Interior mutability is a concept granting mutable an inner value of a type
    with an immutable reference. Is this safe to do? Yes, totally, because we need
    to respect certain constraints. One way to have interior mutability is to wrap
    our `Cell` type. The constraint of this type is that if we want to get the value
    from the `Cell` from an immutable reference, the wrapped type must implement the
    `Copy` trait. We''ll see the other commonly-used type for interior mutability
    later in this chapter. For now, let''s add our field to the `Player` type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 内部可变性是一个概念，它允许具有不可变引用的类型具有可变内部值。这样做安全吗？是的，绝对安全，因为我们需要遵守某些约束。实现内部可变性的方法之一是包装我们的
    `Cell` 类型。此类型的约束是，如果我们想从不可变引用获取 `Cell` 的值，则包装的类型必须实现 `Copy` 特性。我们将在本章后面看到其他常用的内部可变性类型。现在，让我们将我们的字段添加到
    `Player` 类型中：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s update the construction of the structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新结构的构造：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now add a method to check whether the music is paused or not:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个方法来检查音乐是否已暂停：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we need to call `Cell::get()` to get a copy of the inner value. We can
    now add methods to play and resume the song:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们需要调用 `Cell::get()` 来获取内部值的副本。现在我们可以添加播放和恢复歌曲的方法：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here we see that we need to call `Cell::set()` to update the value of the `Cell`.
    We can do that even though we only have an immutable reference and, once again,
    it is completely safe to do so. Then, we update the `stopped` field of the application
    state because the click handler for the play button will use it to decide whether
    we want to play or resume the music. We also call `set_playing()` to indicate
    to the player thread whether it needs to continue playing the song or not. This
    method is defined as such:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们需要调用 `Cell::set()` 来更新 `Cell` 的值。尽管我们只有一个不可变引用，但我们仍然可以这样做，而且这样做是完全安全的。然后，我们更新应用程序状态的
    `stopped` 字段，因为播放按钮的点击处理程序将使用它来决定我们是否想要播放或继续音乐。我们还调用 `set_playing()` 来向播放器线程指示它是否需要继续播放歌曲。此方法定义如下：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It sets the `playing` variable and then notifies the player thread to wake it
    up if `playing` is `true`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它设置 `playing` 变量，然后通知播放器线程如果 `playing` 是 `true`，则唤醒它。
- en: 'We''ll now add a `pause()` method to our `Playlist` type that will call the
    `pause()` method we''ve just created when the user clicks pause:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向我们的 `Playlist` 类型添加一个 `pause()` 方法，当用户点击暂停时，将调用我们刚刚创建的 `pause()` 方法：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To use it, we''ll update the click handler of the play button:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们将更新播放按钮的点击处理程序：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We added the call to pause in the `else` block.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `else` 块中添加了暂停的调用。
- en: 'We now want to update the `play()` method. Now that we can pause the song,
    there are two new cases to consider for this method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想更新 `play()` 方法。现在我们可以暂停歌曲了，因此对于此方法需要考虑两种新情况：
- en: If the song is playing, we want to pause it.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果歌曲正在播放，我们希望暂停它。
- en: If the song is paused, we either want to resume the song if the same one is
    selected or start a new song if another one is selected.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果歌曲已暂停，我们希望根据是否选择了相同的歌曲来恢复歌曲，或者如果选择了另一首歌曲，则开始播放新歌曲。
- en: 'That''s why we need a new field in our `Playlist` structure:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们需要在 `Playlist` 结构中添加一个新的字段：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We added a field that will contain the path of the currently playing song.
    Here we wrap the `Option<String>` into a `RefCell`, which is another way to have
    interior mutability. We cannot use a `Cell` because the `String` type does not
    implement the `Copy` trait. So, what is the difference between `Cell` and `RefCell`?
    The `RefCell` type will check the borrowing rules at runtime: if two borrows happen
    at the same time, it will panic. We have to be careful when using `RefCell`: it
    is better to have compile-time borrowing checks if possible. But when using `gtk-rs`,
    we sometimes need to share a mutable state with the event handler and the best
    way to do that is to use `RefCell`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个字段，它将包含当前播放歌曲的路径。在这里，我们将`Option<String>`包装在`RefCell`中，这是另一种实现内部可变性的方法。我们不能使用`Cell`，因为`String`类型没有实现`Copy`特质。那么，`Cell`和`RefCell`之间的区别是什么？`RefCell`类型将在运行时检查借用规则：如果同时发生两个借用，它将引发panic。在使用`RefCell`时，我们必须要小心：如果可能的话，最好有编译时借用检查。但是，当使用`gtk-rs`时，我们有时需要与事件处理器共享可变状态，而最好的方法就是使用`RefCell`。
- en: 'In the next chapter, we''ll learn how to use a library that abstracts the state
    management so that you won''t need to use `RefCell` and you won''t get any `panic`
    at runtime. This requires a new import statement:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用一个抽象状态管理的库，这样你就不需要使用`RefCell`，并且在运行时不会遇到任何`panic`。这需要一个新的导入语句：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need to update the constructor to initialize this value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新构造函数来初始化这个值：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There''s one more method to add in `Playlist` before we move on to update the
    `play()` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新`play()`方法之前，我们还需要在`Playlist`中添加一个方法：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This method returns a copy of the current song path. Since the field is a `RefCell`,
    we need to call `borrow()` in order to get access to the inner value. This method
    returns the equivalent of an immutable reference. We''ll soon see how to have
    a mutable reference. As with `Mutex`, the borrow is lexical and the borrow will
    end at the end of the function. We''re now ready to update the `play()` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回当前歌曲路径的副本。由于字段是`RefCell`，我们需要调用`borrow()`来访问内部值。此方法返回相当于不可变引用的值。我们很快就会看到如何获得可变引用。与`Mutex`一样，借用是词法的，借用将在函数结束时结束。我们现在准备好更新`play()`方法：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We call `resume()` if the song was paused and if the selected path is the same
    as the currently playing song path. If this condition is `false`, we load the
    specified path and save this path in our field. To do so, we call `borrow_mut()`
    to get a mutable reference. Once again, we need to prefix the expression with
    `*` so that `DerefMut::deref_mut()` gets called. Run the project and you'll see
    that you can pause and resume the song.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果歌曲被暂停并且选定的路径与当前播放的歌曲路径相同，我们调用`resume()`。如果这个条件是`false`，我们加载指定的路径并将这个路径保存在我们的字段中。为此，我们调用`borrow_mut()`来获取一个可变引用。再一次，我们需要在表达式前加上`*`，这样`DerefMut::deref_mut()`就会被调用。运行项目，你会看到你可以暂停和恢复歌曲。
- en: 'Let''s now add a way to stop the song. We''ll start by adding a method to the
    `Player`, as usual:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个停止歌曲的方法。我们像往常一样，首先向`Player`添加一个方法：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We first set the `paused` field to `false` so that the playlist won't try to
    resume the song the next time the play button is clicked. We then set the `stopped`
    field to `true`, this will cause the next click of this button to play the song
    instead of trying to pause it. We then emit the `Stop` action to the event loop
    and indicate to the engine thread that it should not play music anymore.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`paused`字段设置为`false`，这样播放列表就不会在下次点击播放按钮时尝试恢复歌曲。然后我们将`stopped`字段设置为`true`，这将导致下一次点击此按钮播放歌曲而不是尝试暂停它。然后我们向事件循环发出`Stop`动作，并指示引擎线程不再播放音乐。
- en: 'The `emit` method is very simple:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`emit`方法非常简单：'
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It simply pushes the `action` in the queue of the event loop.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将`action`推送到事件循环的队列中。
- en: 'Let''s now handle this `Stop` event:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理这个`Stop`事件：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We only reset the source to `None` because we won't need it anymore.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将源重置为`None`，因为我们不再需要它了。
- en: 'Then, we''re ready to add a `stop()` method to the `Playlist`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们准备好向`Playlist`添加一个`stop()`方法：
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We first reset the `current_song` field to `None` in such a way that the next
    call to `play()` won't attempt to resume the song. We then call the `stop()` method
    we created earlier.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`current_song`字段重置为`None`，这样下一次调用`play()`就不会尝试恢复歌曲。然后我们调用我们之前创建的`stop()`方法。
- en: 'We''re now ready to use this new method by creating a new event handler for
    the stop button, add this code to the `connect_toolbar_events()` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好通过创建一个新的用于停止按钮的事件处理器来使用这个新方法，将此代码添加到`connect_toolbar_events()`方法中：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: So, when we click stop, we call the `Playlist::stop()` method in order to stop
    playing the music. We also hide the cover and set back the play button to show
    the play icon. You can now try again in the music player to see this new feature
    in action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们点击停止时，我们调用`Playlist::stop()`方法来停止播放音乐。我们还隐藏封面并将播放按钮设置回显示播放图标。你现在可以在音乐播放器中再次尝试，以查看这个新功能的效果。
- en: 'Now let''s add the actions for the two remaining buttons: previous and next.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为剩下的两个按钮添加动作：上一个和下一个。
- en: 'We first need to create a new method in the `Playlist`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要在`Playlist`中创建一个新的方法：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We start by getting the selection. Then we check whether an item is selected:
    in this case, we try to get the item after the selection. Otherwise, we get the
    first item on the list. Then, if we were able to get an item, we select it and
    start playing the song. We return whether we changed the selection or not.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取选择项。然后检查是否有项目被选中：在这种情况下，我们尝试获取选择项之后的项。如果没有选中任何项，我们就获取列表中的第一个项。然后，如果我们能够获取到一个项，我们就选中它并开始播放歌曲。我们返回是否更改了选择项。
- en: 'The `previous()` method is similar:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`previous()`方法类似：'
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, there's no `get_iter_last()` method, so we get the last element with
    `iter_nth_child()`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有`get_iter_last()`方法，所以我们使用`iter_nth_child()`来获取最后一个元素。
- en: 'This requires a new import statement to be added at the top of the file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要添加一个新的导入语句在文件顶部：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With these new methods, we''re ready to handle the click events for the buttons.
    Let''s start with the next button:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新方法，我们准备好处理按钮的点击事件。让我们从下一个按钮开始：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We simply call the `next()` method we just created and if a new song was selected,
    we update the icon of the play button and show the new cover. The previous button
    handler is exactly the same except that we call `previous()` instead:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地调用我们刚刚创建的`next()`方法，如果选定了新歌曲，我们更新播放按钮的图标并显示新的封面。上一个按钮的处理程序完全相同，只是我们调用`previous()`而不是`next()`：
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Showing the progression of the song
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示歌曲的进度
- en: It would be nice to see the cursor moving when the song plays. Let's tackle
    this challenge right now.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当歌曲播放时，看到光标移动会很好。让我们立即解决这个问题。
- en: 'We''ll start by adding a method to our `Player` to get the duration of a song:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`Player`中添加一个方法来获取歌曲的持续时间：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We simply call the `compute_duration()` method we created earlier. Next, we''ll
    modify the `Playlist` to call this function. But before we do so, we''ll modify
    the `State` type from the `main` module to include additional information:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地调用我们之前创建的`compute_duration()`方法。接下来，我们将修改`Playlist`以调用这个函数。但在我们这样做之前，我们将修改`main`模块中的`State`类型以包含额外的信息：
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We added a `current_time` field, which will contain how much time elapsed since
    the song started playing. We also store the duration of the songs in a `HashMap`
    so that we only compute it once for each path. We now need to update the initialization
    of the `State` in the `App` constructor:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`current_time`字段，它将包含自歌曲开始播放以来经过的时间。我们还把歌曲的持续时间存储在一个`HashMap`中，这样我们只为每个路径计算一次。现在我们需要更新`App`构造函数中`State`的初始化：
- en: '[PRE66]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s go back to the `Playlist`. It will now contain the `State` in its structure:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`Playlist`。现在它将包含其结构中的`State`：
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This should be reflected in its constructor:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在它的构造函数中反映出来：
- en: '[PRE68]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, the `state` field was added. We''ll now add a method that will compute
    the duration in another thread:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`state`字段。我们现在将添加一个方法，它将在另一个线程中计算持续时间：
- en: '[PRE69]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the thread''s closure, we compute the duration and when it''s done, we lock
    the state to insert the duration in the `HashMap`. We compute the duration in
    another thread because it can take time and we don''t want to block the user interface
    during this computation. We now call this method in `Playlist::add()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程的闭包中，我们计算持续时间，当它完成时，我们锁定状态以在`HashMap`中插入持续时间。我们因为在计算可能需要时间，我们不希望在这个计算期间阻塞用户界面，所以我们现在在`Playlist::add()`中调用这个方法：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We''ll update the `Adjustment` so that its upper value is `0.0` in the beginning:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`Adjustment`，使其初始值是`0.0`：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is to avoid seeing the cursor moving too quickly when the duration is not
    yet computed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了避免在持续时间尚未计算时看到光标移动得太快。
- en: 'Finally, we''ll add the code to update the UI in the `App::connect_events()`
    method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`App::connect_events()`方法中添加更新UI的代码：
- en: '[PRE72]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `gtk::timeout_add()` method will be run every 100 milliseconds as long as
    its closure returns `Continue(false)`. This closure starts by checking whether
    the duration is in the `HashMap`, and sets the upper value of the cursor as this
    duration. If the value is not in the `HashMap`, it means it wasn't computed yet.
    After that, we check whether the `stopped` field is true, that means the song
    ended and the engine thread is no longer playing it. In this case, we want to
    show the play icon. If the song is still playing, we show the pause icon. Finally,
    we set the current value of the cursor from the `current_time` field.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当`gtk::timeout_add()`方法的闭包返回`Continue(false)`时，该方法将每100毫秒运行一次。这个闭包首先检查持续时间是否在`HashMap`中，并将光标的上限值设置为这个持续时间。如果值不在`HashMap`中，这意味着它还没有被计算。之后，我们检查`stopped`字段是否为真，这意味着歌曲已经结束，引擎线程不再播放它。在这种情况下，我们想显示播放图标。如果歌曲仍在播放，我们显示暂停图标。最后，我们将光标当前值从`current_time`字段设置。
- en: 'The cursor will now move automatically as the song plays. Here''s how the player
    looks now:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 光标现在将随着歌曲的播放自动移动。以下是现在播放器的外观：
- en: '![](img/00038.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: '*Figure 6.1*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1*'
- en: Improving CPU usage
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高CPU使用率
- en: One issue you may have noticed is that when no song is playing, the software
    will use 100% of the CPU. This is because of the infinite loop in the music engine
    thread. It will do nothing except loop when the song is paused or when there's
    no song to play. Let's now fix this issue.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到的一个问题是，当没有歌曲播放时，软件将使用100%的CPU。这是因为音乐引擎线程中的无限循环。当歌曲暂停或没有歌曲可播放时，它将什么也不做，只是循环。现在让我们解决这个问题。
- en: Condition variable
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: 'What we want to do is to make the thread sleep when it has nothing to do. We
    also want to be able to wake the thread up from the main thread. This is exactly
    what condition variables are for. So, let''s add one to our engine. We''ll start
    by adding a `condition_variable` field to the `EventLoop`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是当线程没有事情可做时让它休眠。我们还想能够从主线程唤醒线程。这正是条件变量的作用。所以，让我们在我们的引擎中添加一个。我们将首先在`EventLoop`中添加一个`condition_variable`字段：
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'A condition variable is usually used together with a Boolean value (wrapped
    in a `Mutex`). We need to rewrite the constructor of `EventLoop` to initialize
    this new field:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量通常与布尔值（包装在`Mutex`中）一起使用。我们需要重写`EventLoop`的构造函数来初始化这个新字段：
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we need to block the thread when it has nothing to do. Here''s the start
    of the new code of the thread in `Player::new()`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在线程没有事情可做时阻塞它。以下是`Player::new()`中线程新代码的开始：
- en: '[PRE75]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We create a copy of the condition variable and we move this copy into the thread.
    Then, in the beginning of the closure, we lock the Boolean value associated with
    the condition variable to set it to `false`. Afterward, we loop: while this value
    is `false`, we block the current thread. We created a closure instead of a normal
    function because normal functions cannot capture values. The following code is
    the same as before:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建条件变量的一个副本，并将这个副本移动到线程中。然后在闭包的开始处，我们锁定与条件变量相关联的布尔值并将其设置为`false`。之后，我们循环：当这个值是`false`时，我们阻塞当前线程。我们创建了一个闭包而不是一个普通函数，因为普通函数不能捕获值。以下代码与之前相同：
- en: '[PRE76]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'But the rest of the closure is a bit different:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但闭包的其余部分略有不同：
- en: '[PRE77]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If the player was unable to play song (that is, the song came into an end),
    we call the closure to block the thread. We also block the thread if the player
    is paused. With the condition variable, the software stopped using 100% CPU.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果播放器无法播放歌曲（即歌曲已经结束），我们调用闭包来阻塞线程。如果播放器暂停，我们也会阻塞线程。有了条件变量，软件就不再使用100%的CPU。
- en: Showing the song's current time
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示歌曲的当前时间
- en: Currently, we only display the progression of the song. The user has no way
    to know the duration and for how many seconds the song has been playing. Let's
    fix that by adding labels that will show the current time and the duration.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只显示歌曲的进度。用户无法知道歌曲的持续时间以及歌曲已经播放了多少秒。让我们通过添加显示当前时间和持续时间的标签来解决这个问题。
- en: 'We''ll need two new import statements in the `main` module:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`main`模块中添加两个新的导入语句：
- en: '[PRE78]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We''ll also add two `label` in our `App` structure:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会在我们的`App`结构中添加两个`label`：
- en: '[PRE79]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'One `label` for the current time and the other for the duration. Since we want
    to show the different `label` on the right of the cursor, we''ll create a horizontal
    box, this code should be added in `App::new()`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于当前时间的`label`，另一个用于持续时间。由于我们想在光标右侧显示不同的`label`，我们将创建一个水平框，这段代码应该在`App::new()`中添加：
- en: '[PRE80]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `Scale` widget is now added to `hbox` instead of `vbox`. And we call `set_hexpand()`
    so that the widget takes as much horizontal space as possible.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scale`小部件现在被添加到`hbox`而不是`vbox`中。我们调用`set_hexpand()`以便小部件尽可能多地占用水平空间。'
- en: 'We''re now ready to create our `label`''s:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建我们的`label`：
- en: '[PRE81]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We create three `label`; the third one being a separator. We set a right margin
    to the last `label` so that it is not too close to the border of the window. Further,
    in the `App` constructor, we need to update the initialization of the structure:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个`label`；第三个是一个分隔符。我们给最后一个`label`设置一个右外边距，以便它不会太靠近窗口的边缘。此外，在`App`构造函数中，我们需要更新结构的初始化：
- en: '[PRE82]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We added the two `label`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个`label`。
- en: 'We''ll create a function to convert a number of milliseconds to a `String`
    of the `minute:second` format:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个函数将毫秒数转换为`minute:second`格式的`String`：
- en: '[PRE83]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this function, we first convert the milliseconds to seconds by dividing by
    one thousand. We then get the number of minutes by dividing the seconds by `60`.
    Afterward, we compute the number of seconds that are not included in the minutes
    with the modulo operation. Finally, we format the minutes and seconds as a `String`.
    As you can see, we used a special `{:02}` formatter. The `2` means that we want
    to print the number as two characters, even if the number is less than 0\. The
    `0` after the colon indicates that we want to prepend `0` instead of spaces.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先通过除以一千将毫秒数转换为秒。然后我们通过除以`60`得到分钟数。之后，我们使用模运算符计算不包括在分钟中的秒数。最后，我们将分钟和秒格式化为`String`。如您所见，我们使用了特殊的`{:02}`格式化器。`2`表示我们希望以两个字符打印数字，即使数字小于0。冒号后面的`0`表示我们希望用`0`而不是空格来填充。
- en: 'With this new function, we can rewrite the timer to update (in the method `App::connect_events()`)
    the `label`''s:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新函数，我们可以重写计时器以更新（在`App::connect_events()`方法中）`label`：
- en: '[PRE84]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here are the changes from the previous version. When we get the duration, we
    update the duration `label`. And when the song is not stopped (that is, when it
    is playing), we update the current time `label`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前一个版本的更改。当我们获取持续时间时，我们更新持续时间`label`。当歌曲没有停止（即正在播放时），我们更新当前时间`label`。
- en: We need to change the stop button handler so that it resets the text of these
    `label`'s.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改停止按钮处理程序，以便重置这些`label`的文本。
- en: 'Finally, we can update the handler:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新处理程序：
- en: '[PRE85]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We clone the widgets to move them into the closure and set the text of the `label`'s
    to the empty string.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们克隆小部件以将它们移动到闭包中，并将`label`的文本设置为空字符串。
- en: 'Here''s the result you should see when running the application:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，你应该看到以下结果：
- en: '![](img/00039.jpeg)*Figure 6.2*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00039.jpeg)*图6.2*'
- en: Loading and saving the playlist
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存播放列表
- en: We have the ability to create a playlist in our music player, but we cannot
    save a playlist to a file in order to be able to load one later. Let's add this
    feature to our project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的音乐播放器中可以创建播放列表，但我们不能将播放列表保存到文件中以便稍后加载。让我们将此功能添加到我们的项目中。
- en: 'We''ll save the playlist in the `m3u` file format and to handle this format,
    we''ll use the `m3u` crate. So let''s add it to our `Cargo.toml` file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以`m3u`文件格式保存播放列表，并为了处理此格式，我们将使用`m3u`crate。所以让我们将其添加到我们的`Cargo.toml`文件中：
- en: '[PRE86]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add this line to the `main` module:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到`main`模块中：
- en: '[PRE87]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Saving a playlist
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存播放列表
- en: 'We''ll start by adding a button to save the playlist. First, we add a field
    in the `MusicToolbar` structure for the button:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个按钮来保存播放列表。首先，我们在`MusicToolbar`结构中添加一个字段用于按钮：
- en: '[PRE88]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And in the constructor, we''ll create this button:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将创建此按钮：
- en: '[PRE89]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Next, we''ll add a `save` method in the `Playlist` structure:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`Playlist`结构中添加一个`save`方法：
- en: '[PRE90]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, we first create a `m3u::Writer` with a `File` that we've created. This
    writer will be used to write the entry to the file. We create a closure that gets
    the path from an iterator of our `TreeView` and writes this path to the file.
    We chose to create a closure to avoid repeating the code, as we'll need this code
    twice. After that, we get the first iterator and write its contents before looping
    until there's no more row in the view.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用我们创建的`File`创建一个`m3u::Writer`。这个写入器将被用来将条目写入文件。我们创建一个闭包，它从我们的`TreeView`的迭代器中获取路径并将此路径写入文件。我们选择创建闭包以避免重复代码，因为我们需要使用此代码两次。之后，我们获取第一个迭代器并写入其内容，然后循环直到视图中没有更多行。
- en: 'We''re now ready to call this code. First, we''ll create a function in the
    module toolbar to show a save file dialog. It is similar to the `show_open_dialog()`
    function we wrote in the previous chapter:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好调用这段代码。首先，我们在模块工具栏中创建一个函数来显示保存文件对话框。它与我们在上一章中编写的`show_open_dialog()`函数类似：
- en: '[PRE91]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, we use the `FileChooserAction::Save` type instead of `FileChooserAction::Open`.
    We use a different filter and mime type. We also call `set_do_overwrite_confirmation()`
    which is very important. It will ask for a confirmation if the user asks to overwrite
    a file. The rest of the function is exactly the same as the one to open a file,
    except that the `label` of the button is now `Save`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`FileChooserAction::Save`类型而不是`FileChooserAction::Open`。我们使用不同的过滤器以及MIME类型。我们还调用了`set_do_overwrite_confirmation()`，这是非常重要的。如果用户请求覆盖文件，它将要求确认。函数的其余部分与打开文件的函数完全相同，只是按钮的`label`现在改为`Save`。
- en: 'We can now use this function in the event handler of the save button:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在保存按钮的事件处理程序中使用这个函数：
- en: '[PRE92]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We simply call the function `show_save_dialog()` and give the resulting file
    to the `Playlist::save()` method. You can now try to save a playlist in the application:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地调用`show_save_dialog()`函数，并将结果文件传递给`Playlist::save()`方法。你现在可以尝试在应用程序中保存播放列表：
- en: '![](img/00040.jpeg)*Figure 6.3*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3](img/00040.jpeg)*图6.3*'
- en: Loading a playlist
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载播放列表
- en: 'We can save playlists, but still cannot load them. Let''s start by adding a
    `load()` method to `Playlist`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存播放列表，但仍然无法加载它们。让我们首先在`Playlist`中添加一个`load()`方法：
- en: '[PRE93]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we create a `m3u::Reader` with the specified path. We loop over the entry
    and if we were able to retrieve a `m3u::Entry::Path`, we add it to the playlist
    widget.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用指定的路径创建一个`m3u::Reader`。我们遍历条目，如果我们能够检索到`m3u::Entry::Path`，我们就将其添加到播放列表小部件中。
- en: 'We''ll now modify the open dialog to allow selecting `M3U` files:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改打开对话框，允许选择`M3U`文件：
- en: '[PRE94]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We''ll now change the open button event handler to select which action to do
    depending on the file type:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更改打开按钮的事件处理程序，根据文件类型选择要执行的操作：
- en: '[PRE95]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This requires a couple of new import statements:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要添加几个新的导入语句：
- en: '[PRE96]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This new event handler now checks the file extension, if it is `mp3`, it will
    call the `Playlist::add()` method as we were doing earlier. If it is `m3u`, we
    call our new `Playlist::load()` method. Otherwise, we show an error message to
    the user:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的事件处理程序现在会检查文件扩展名，如果是`mp3`，它将调用我们之前所做的那样调用`Playlist::add()`方法。如果是`m3u`，我们调用我们新的`Playlist::load()`方法。否则，我们向用户显示一个错误消息：
- en: '![](img/00041.jpeg)*Figure 6.4*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4](img/00041.jpeg)*图6.4*'
- en: You can now try to load a playlist in our music player, don't forget to change
    the filter in order to see M3U files in the dialog.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以尝试在我们的音乐播放器中加载播放列表，别忘了更改过滤器以便在对话框中看到M3U文件。
- en: Using gstreamer for playback
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gstreamer进行播放
- en: Implementing an engine to play music was a good exercise to learn about threading.
    However, for a real program, you could simply use `gstreamer` for the music playback.
    So, let's see how to use this library in our music player.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 实现音乐播放引擎是一个学习线程的好练习。然而，对于真正的程序，你可以简单地使用`gstreamer`进行音乐播放。所以，让我们看看如何在我们的音乐播放器中使用这个库。
- en: 'Remove the following dependencies in your `Cargo.toml`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`Cargo.toml`中移除以下依赖项：
- en: '[PRE97]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And remove their corresponding `extern crate` statements. We can also remove
    the `mp3` and `player` modules as we''ll use `gstreamer` instead. Now, we can
    add our dependencies for `gstreamer`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 并移除相应的`extern crate`语句。我们还可以移除`mp3`和`player`模块，因为我们将会使用`gstreamer`。现在，我们可以添加我们的`gstreamer`依赖项：
- en: '[PRE98]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And add their corresponding `extern crate` statements:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加相应的`extern crate`语句：
- en: '[PRE99]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'At the beginning of the `main` function, we need to initialize `gstreamer`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的开始处，我们需要初始化`gstreamer`：
- en: '[PRE100]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We no longer need our `State` structure, so we remove it and the `state` field
    in the `App` structure. And now, we can update our `playlist` module. First, let''s
    add a few `use` statements:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要我们的`State`结构，因此我们移除了它以及`App`结构中的`state`字段。现在，我们可以更新我们的`playlist`模块。首先，让我们添加一些`use`语句：
- en: '[PRE101]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We remove the `state` field and update the `player` one in the `Playlist` structure:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了`state`字段，并在`Playlist`结构中更新了`player`字段：
- en: '[PRE102]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `Playlist` constructor does not need the `state` anymore:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Playlist`构造函数不再需要`state`：'
- en: '[PRE103]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Here, we create the `Player` from the `gstreamer` crate. We need to remove
    the `compute_duration()` method and all its uses because we''ll use `gstreamer`
    to get the song''s duration:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`gstreamer`包中创建`Player`。我们需要移除`compute_duration()`方法和所有其使用，因为我们将会使用`gstreamer`来获取歌曲的时长：
- en: '[PRE104]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here, we create a few methods that will be useful to show the time and when
    the song is playing. Finally, we can update the `play()` method to use `gstreamer`
    instead:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一些将有助于显示时间和歌曲播放状态的方法。最后，我们可以更新`play()`方法以使用`gstreamer`：
- en: '[PRE105]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let''s go back to the `main` module to update the creation of the playlist:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`main`模块来更新播放列表的创建：
- en: '[PRE106]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'One more thing to update is the code to show the current time:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要更新，那就是显示当前时间的代码：
- en: '[PRE107]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We now use the methods we created a bit earlier and some from `gstreamer`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用我们之前创建的一些方法和来自`gstreamer`的一些方法。
- en: 'Finally, we update the `toolbar` module. First, the `play_button` event handler:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新`toolbar`模块。首先，是`play_button`事件处理器：
- en: '[PRE108]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We now use the `is_playing()` method instead of the `state`. Let''s also remove
    the `FileFilter` from the `show_open_dialog()` function because `gstreamer` supports
    more formats than just `MP3`. And to be able to open them, we need to update the
    `open_button` event handler:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`is_playing()`方法代替`state`。同时，我们也从`show_open_dialog()`函数中移除`FileFilter`，因为`gstreamer`支持的格式不仅仅是`MP3`。为了能够打开这些格式，我们需要更新`open_button`事件处理器：
- en: '[PRE109]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, we only added the `ogg` format, but you can also add other formats.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只添加了`ogg`格式，但你也可以添加其他格式。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started by showing you how to decode MP3 data with the `simplemad`
    crate. You then learned how to write a music engine, this showed you how to use
    threads and different threading objects such as `Mutex`, lock-free data structures,
    and condition variables. You also learned how Rust can ensure thread safety. You
    also saw how to mutable the fields of a value when you have an immutable reference
    with interior mutability. During the whole chapter, we added the missing features
    to the music player such as play, pause, previous, and next song.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本章一开始就向您展示了如何使用`simplemad`crate解码MP3数据。然后，您学习了如何编写音乐引擎，这展示了如何使用线程和不同的线程对象，如`Mutex`、无锁数据结构和条件变量。您还学习了Rust如何确保线程安全。您还看到了当您有一个不可变的引用和内部可变性时，如何可变地修改值的字段。在整个章节中，我们添加了音乐播放器缺失的功能，如播放、暂停、上一曲和下一曲。
- en: In the next chapter, we'll improve the modularity of the music player by rewriting
    it with the `relm` crate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用`relm`crate重写音乐播放器来提高其模块化程度。
