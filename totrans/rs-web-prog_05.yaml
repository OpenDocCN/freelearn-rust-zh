- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Displaying Content in the Browser
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中显示内容
- en: We are now at the stage where we can build a web application that can manage
    a range of HTTP requests with different methods and data. This is useful, especially
    if we are building a server for microservices. However, we also want non-programmers
    to interact with our application to use it. To enable non-programmers to use our
    application, we must create a graphical user interface. However, it must be noted
    that this chapter does not contain much Rust. This is because other languages
    exist to render a graphical user interface. We will mainly use HTML, JavaScript,
    and CSS. These tools are mature and widely used for frontend web development.
    While I personally love Rust (otherwise I wouldn’t be writing a book on it), we
    must use the right tool for the right job. At the time of writing this book, we
    can build a frontend application in Rust using the Yew framework. However, being
    able to fuse more mature tools into our Rust technical stack is a more valuable
    skill.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到了可以构建能够管理不同方法和数据的HTTP请求的Web应用程序的阶段。这对于我们构建微服务服务器特别有用。然而，我们还想让非程序员能够与我们的应用程序交互以使用它。为了使非程序员能够使用我们的应用程序，我们必须创建一个图形用户界面。但是，必须注意的是，本章并不包含很多Rust。这是因为其他语言存在用于渲染图形用户界面。我们将主要使用HTML、JavaScript和CSS。这些工具成熟且广泛用于前端Web开发。虽然我个人非常喜欢Rust（否则我不会写关于它的书），但我们必须根据需要使用合适的工具。在撰写本书时，我们可以使用Yew框架在Rust中构建前端应用程序。然而，能够将更成熟的工具融合到我们的Rust技术栈中是一种更有价值的技能。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Serving HTML, CSS, and JavaScript using Rust
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rust提供HTML、CSS和JavaScript
- en: Building a React application that connects to a Rust server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个连接到Rust服务器的React应用程序
- en: Converting our React application into a desktop application to be installed
    on the computer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的React应用程序转换为可在计算机上安装的桌面应用程序
- en: 'In the previous edition (*Rust Web Programming: A hands-on guide to developing
    fast and secure web apps with the Rust programming language*), we merely served
    frontend assets directly from Rust. However, due to feedback and revision, this
    does not scale well, leading to a lot of repetition. Raw HTML, CSS, and JavaScript
    served directly by Rust were also prone to errors due to the unstructured nature
    of using this approach, which is why, in this second edition, we will cover React
    as well as provide a brief introduction to serving frontend assets directly with
    Rust. By the end of this chapter, you will be able to write basic frontend graphical
    interfaces without any dependencies, as well as understand the trade-offs between
    low-dependency frontend solutions and full frontend frameworks such as React.
    Not only will you understand when to use them but you will also be able to implement
    both approaches as and when they are needed for your project. As a result, you
    will be able to pick the right tool for the right job and build an end-to-end
    product using Rust in the backend and JavaScript in the frontend.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一版（*Rust Web Programming: A hands-on guide to developing fast and secure
    web apps with the Rust programming language*）中，我们只是直接从Rust中提供前端资源。然而，由于反馈和修订，这种方法扩展性不佳，导致大量重复。直接由Rust提供的原始HTML、CSS和JavaScript也容易出错，因为这种方法使用的是非结构化方式，这就是为什么在第二版中，我们将涵盖React，并提供使用Rust直接提供前端资源的简要介绍。到本章结束时，你将能够编写基本的图形用户界面，无需任何依赖项，并理解低依赖前端解决方案与React等完整前端框架之间的权衡。你不仅会了解何时使用它们，而且还能根据项目需要实施这两种方法。因此，你将能够根据需要选择合适的工具，并使用Rust作为后端和JavaScript作为前端构建端到端的产品。'
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will be building on the server code we created in the previous chapter, which
    can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在上一章中创建的服务器代码的基础上进行构建，该代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app)找到。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05)找到。
- en: We will also be using Node.js to run our React application. Node and npm can
    be installed by carrying out the steps laid out at [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 Node.js 来运行我们的 React 应用程序。可以通过执行 [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)
    中概述的步骤来安装 Node 和 npm。
- en: Serving HTML, CSS, and JavaScript using Rust
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Rust 服务 HTML、CSS 和 JavaScript
- en: 'In the previous chapter, we returned all our data in the form of JSON. In this
    section, we are going to return HTML data for the user to see. In this HTML data,
    we will have buttons and forms that enable the user to interact with the API endpoints
    that we defined in the previous chapter to create, edit, and delete to-do items.
    To do this, we will need to structure our own `app` views module that takes the
    following structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将所有数据以 JSON 格式返回。在本节中，我们将返回 HTML 数据供用户查看。在这份 HTML 数据中，我们将包含按钮和表单，使用户能够与我们在上一章中定义的
    API 端点进行交互，以创建、编辑和删除待办事项。为此，我们需要构建自己的 `app` 视图模块，其结构如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Serving basic HTML
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务基本 HTML
- en: 'In our `items.rs` file, we will be defining the main view that displays the
    to-do items. However, before we do that, we should explore the simplest way in
    which we can return HTML in the `items.rs` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `items.rs` 文件中，我们将定义显示待办事项的主要视图。然而，在我们这样做之前，我们应该探索在 `items.rs` 文件中返回 HTML
    的最简单方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we simply return an `HttpResponse` struct that has an HTML content type
    and a body of `<h1>Items</h1>`. To pass `HttpResponse` into the app, we must define
    our factory in the `app/views/mod.rs` file, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是返回一个具有 HTML 内容类型和 `<h1>Items</h1>` 体的 `HttpResponse` 结构。要将 `HttpResponse`
    传递到应用中，我们必须在 `app/views/mod.rs` 文件中定义我们的工厂，如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see that instead of building a service, we merely defined a `route`
    for our application. This is because this is the landing page. If we were going
    to define a `service` instead of a `route`, we would not be able to define the
    views for the service without a prefix.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，我们不是构建一个服务，而是仅仅为我们的应用程序定义了一个 `route`。这是因为这是着陆页。如果我们打算定义一个 `service`
    而不是 `route`，则无法在没有前缀的情况下定义服务的视图。
- en: 'Once we have defined `app_views_factory`, we can call it in our `views/mod.rs`
    file. However, first, we must define the app module at the top of the `views/mod.rs`
    file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `app_views_factory`，我们就可以在我们的 `views/mod.rs` 文件中调用它。然而，首先，我们必须在 `views/mod.rs`
    文件的顶部定义应用模块：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have defined the `app` module, we can call the app factory in the `views_factory`
    function within the same file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `app` 模块，我们就可以在同一个文件中的 `views_factory` 函数中调用应用工厂：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that our HTML serving view is a part of our app, we can run it and call
    the home URL in our browser, giving us the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 HTML 服务视图已成为我们应用的一部分，我们可以运行它并在浏览器中调用主页 URL，得到以下输出：
- en: '![Figure 5.1 – First rendered HTML view](img/Figure_5.1_B18722.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 首次渲染的 HTML 视图](img/Figure_5.1_B18722.jpg)'
- en: Figure 5.1 – First rendered HTML view
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 首次渲染的 HTML 视图
- en: 'We can see that our HTML rendered! With what we saw in *Figure 5**.1*, we can
    deduce that we can return a string at the body of the response with the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的 HTML 已经渲染！通过我们在 *图 5.1* 中看到的内容，我们可以推断出我们可以在响应体中返回一个字符串，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This renders the HTML if the string is in HTML format. From this revelation,
    how do you think we can render HTML from HTML files that are served by our Rust
    server? Before moving on, think about this – this will exercise your problem-solving
    abilities.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串是 HTML 格式，这将渲染 HTML。从这个发现中，你认为我们如何从由我们的 Rust 服务器提供的 HTML 文件中渲染 HTML？在继续之前，考虑这个问题
    – 这将锻炼你的问题解决能力。
- en: Reading basic HTML from files
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取基本 HTML
- en: If we have an HTML file, we can render it by merely readying that HTML file
    to a string and inserting that string into the body of `HttpResponse`. Yes, it
    is that simple. To achieve this, we will build a content loader.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个 HTML 文件，我们可以通过将那个 HTML 文件准备好作为字符串并将其插入到 `HttpResponse` 的体中来实现渲染。是的，就这么简单。为了实现这一点，我们将构建一个内容加载器。
- en: 'To build a basic content loader, start by building an HTML file reading function
    in the `views/app/content_loader.rs` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个基本的内容加载器，首先在 `views/app/content_loader.rs` 文件中构建一个读取 HTML 文件的函数：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All we must do here is return a string because this is all we need for the response
    body. Then, we must define the loader in the `views/app/mod.rs` file with the
    `mod content_loader;` line at the top of the file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做的只是返回一个字符串，因为这是我们需要的响应体。然后，我们必须在 `views/app/mod.rs` 文件中定义加载器，并在文件的顶部使用
    `mod content_loader;` 行。
- en: 'Now that we have a loading function, we need an HTML directory. This can be
    defined alongside the `src` directory called `templates`. Inside the `templates`
    directory, we can add an HTML file called `templates/main.html` with the following
    content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了加载函数，我们需要一个 HTML 目录。这可以在名为 `templates` 的 `src` 目录旁边定义。在 `templates`
    目录内部，我们可以添加一个名为 `templates/main.html` 的 HTML 文件，其内容如下：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we can see that our `body` tag has the same content that we presented
    previously – that is, `<h1>To Do Items</h1>`. Then, we have a `head` tag that
    defines a range of meta tags. We can see that we define `viewport`. This tells
    the browser how to handle the dimensions and scaling of the page content. Scaling
    is important because our application could be accessed by a range of different
    devices and screen sizes. With this viewport, we can set the width of the page
    to the same width as the device screen. Then, we can set the initial scale of
    the page that we access to `1.0`. Moving on to the `httpEquiv` tag, we set it
    to `X-UA-Compatible`, which means that we support older browsers. The final tag
    is simply a description of the page that can be used by search engines. Our `title`
    tag ensures that `to do app` is displayed on the browser tag. With that, we have
    our standard header title in our body.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的 `body` 标签具有与我们之前展示相同的内容 – 即 `<h1>待办事项</h1>`。然后，我们有一个 `head` 标签，它定义了一系列元标签。我们可以看到我们定义了
    `viewport`。这告诉浏览器如何处理页面内容的尺寸和缩放。缩放很重要，因为我们的应用程序可能被各种不同的设备和屏幕尺寸访问。使用这个视口，我们可以将页面的宽度设置为与设备屏幕相同的宽度。然后，我们可以将我们访问的页面的初始缩放设置为
    `1.0`。接下来是 `httpEquiv` 标签，我们将其设置为 `X-UA-Compatible`，这意味着我们支持旧版浏览器。最后一个标签只是对页面的描述，可以被搜索引擎使用。我们的
    `title` 标签确保在浏览器标签上显示 `to do app`。有了这个，我们在 `body` 中就有了标准的标题。
- en: Serving basic HTML loaded from files
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中服务基本的 HTML
- en: 'Now that we have defined our HTML file, we must load and serve it. Going back
    to our `src/views/app/items.rs` file, we must load the HTML file and serve it
    with the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的 HTML 文件，我们必须加载并服务它。回到我们的 `src/views/app/items.rs` 文件，我们必须加载 HTML
    文件并使用以下代码来服务它：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run our application, we will get the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的应用程序，我们将得到以下输出：
- en: '![Figure 5.2 – View from loading the HTML page](img/Figure_5.2_B18722.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 加载 HTML 页面的视图](img/Figure_5.2_B18722.jpg)'
- en: Figure 5.2 – View from loading the HTML page
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 加载 HTML 页面的视图
- en: In *Figure 5**.2*, we can see that we have the same output as before. This is
    not surprising; however, we must notice that the tab in *Figure 5**.2* now states
    **To Do App**, which means that the metadata in our HTML file is being loaded
    into the view. Nothing is stopping us from fully utilizing the HTML file. Now
    that our HTML file is being served, we can move on to our next ambition, which
    is adding functionality to our page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5*.*2* 中，我们可以看到我们得到了与之前相同的结果。这并不令人惊讶；然而，我们必须注意到 *图 5*.*2* 中的标签现在显示为 **To
    Do App**，这意味着我们 HTML 文件中的元数据正在被加载到视图中。没有任何东西阻止我们充分利用 HTML 文件。现在我们的 HTML 文件正在被服务，我们可以继续我们的下一个目标，即在页面上添加功能。
- en: Adding JavaScript to an HTML file
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 JavaScript 添加到 HTML 文件中
- en: 'It would not be useful to the frontend user if they couldn’t do anything to
    our state for to-do items. Before we amend this, we need to understand the layout
    of an HTML file by looking at the following figure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户无法对我们的待办事项状态进行任何操作，这对前端用户来说将没有用处。在我们修改之前，我们需要通过查看以下图表来了解 HTML 文件的布局：
- en: '![Figure 5.3 – General layout of an HTML file](img/Figure_5.3_B18722.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – HTML 文件的一般布局](img/Figure_5.3_B18722.jpg)'
- en: Figure 5.3 – General layout of an HTML file
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – HTML 文件的一般布局
- en: Here, in *Figure 5**.3*, we can see that we can define the meta tags in the
    header. However, we can also see that we can define style tags in the header.
    Within the style tags below the header, we can insert CSS into the style. Below
    the body, there is also a script section where we can inject JavaScript. This
    JavaScript runs in the browser and interacts with elements in the body. With this,
    we can see that serving an HTML file loaded with CSS and JavaScript provides a
    fully functioning frontend single-page app. With this, we can reflect on the introduction
    of this chapter. While I love Rust and feel a strong urge to tell you to write
    everything in it, this is just not a good idea for any language in software engineering.
    The ease with which we can serve functional frontend views with JavaScript now
    makes it the best choice for your frontend needs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 *图 5**.3* 中，我们可以看到我们可以在头部定义元标签。然而，我们也可以在头部定义样式标签。在头部下面的样式标签中，我们可以将 CSS
    插入到样式标签中。在主体下面，还有一个脚本部分，我们可以在这里注入 JavaScript。这个 JavaScript 在浏览器中运行并与主体中的元素交互。有了这个，我们可以看到，提供带有
    CSS 和 JavaScript 的 HTML 文件可以提供一个完全功能的单页应用程序前端。有了这个，我们可以反思本章的介绍。虽然我喜欢 Rust 并强烈建议你用
    Rust 编写一切，但这对于软件工程中的任何语言来说都不是一个好主意。我们现在可以轻松地使用 JavaScript 提供功能性的前端视图，这使得它成为你前端需求的最佳选择。
- en: Communicating with our server using JavaScript
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 与我们的服务器进行通信
- en: 'Now that we know where to insert the JavaScript into our HTML file, we can
    test our bearings. In the remainder of this section, we are going to create a
    button in the HTML body, fuse it to a JavaScript function, and then get the browser
    to print out an alert with an inputted message when that button is pressed. This
    will do nothing to our backend application, but it will prove that our understanding
    of HTML files is correct. We can add the following code to our `templates/main.html`
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在哪里将 JavaScript 插入我们的 HTML 文件中，我们可以测试我们的定位。在本节的剩余部分，我们将在 HTML 主体中创建一个按钮，将其与一个
    JavaScript 函数连接起来，然后当按下该按钮时，让浏览器打印出一个带有输入信息的警告。这对我们的后端应用程序没有任何影响，但它将证明我们对 HTML
    文件的了解是正确的。我们可以在我们的 `templates/main.html` 文件中添加以下代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our body section, we can see that we define an `input` and a `button`. We
    give the `input` and `button` properties unique ID names. Then, we use the ID
    of `button` to add an event listener. After that, we bind our `postAlert` function
    to that event listener to be fired when our `button` is clicked. When we fire
    our `postAlert` function, we get `input` by using its ID and print out the value
    of `input` in an alert. Then, we set the value of `input` to `null` to enable
    the user to fill in another value to be processed. Serving our new `main.html`
    file, putting `testing` in `input` and then clicking the button will result in
    the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主体部分，我们可以看到我们定义了一个 `input` 和一个 `button`。我们给 `input` 和 `button` 属性分配了唯一的
    ID 名称。然后，我们使用 `button` 的 ID 添加一个事件监听器。之后，我们将我们的 `postAlert` 函数绑定到该事件监听器，以便在点击
    `button` 时触发。当我们调用 `postAlert` 函数时，我们通过其 ID 获取 `input` 并在警告中打印出 `input` 的值。然后，我们将
    `input` 的值设置为 `null`，以便用户可以填写另一个要处理的值。在 `input` 中输入 `testing` 并点击按钮后，将产生以下输出：
- en: '![Figure 5.4 – The effect of clicking a button when connected to an alert in
    JavaScript](img/Figure_5.4_B18722.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 当连接到 JavaScript 中的警告时点击按钮的效果](img/Figure_5.4_B18722.jpg)'
- en: Figure 5.4 – The effect of clicking a button when connected to an alert in JavaScript
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 当连接到 JavaScript 中的警告时点击按钮的效果
- en: Our JavaScript does not have to stop with having elements interact in the body.
    We can also use JavaScript to perform API calls to our backend Rust application.
    However, we must stop and think before we rush off and write our entire application
    in our `main.html` file. If we did that, the `main.html` file would balloon into
    a massive file. It would be hard to debug. Also, this could lead to code duplication.
    What if we wanted to use the same JavaScript in other views? We would have to
    copy and paste it into another HTML file. This would not scale well and if we
    need to update a function, we could run the risk of forgetting to update some
    of the duplicated functions. This is where JavaScript frameworks such as React
    come in handy. We will explore React later in this chapter, but for now, we will
    complete our low-dependency frontend by coming up with a way in which we can separate
    our JavaScript from our HTML files.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript不必只限于在主体中让元素交互。我们还可以使用JavaScript对后端Rust应用程序执行API调用。然而，在我们匆忙编写整个应用程序到`main.html`文件之前，我们必须停下来思考。如果我们那样做，`main.html`文件会膨胀成一个巨大的文件。这将很难调试。此外，这可能导致代码重复。如果我们想在其他视图中使用相同的JavaScript呢？我们就必须将其复制粘贴到另一个HTML文件中。这不会很好地扩展，如果我们需要更新一个函数，我们可能会忘记更新一些重复的函数。这就是JavaScript框架（如React）派上用场的地方。我们将在本章后面探索React，但现在，我们将通过找到一种方法来分离我们的JavaScript和HTML文件，来完成我们的低依赖性前端。
- en: 'It must be warned that we are essentially manually rewriting HTML on the fly
    with this JavaScript. People could describe this as a “hacky” solution. However,
    it is important to get to grips with our approach before exploring React to truly
    appreciate the benefits of different approaches. Before we move on to the next
    section, we do have to refactor our `create` view in the `src/views/to_do/create.rs`
    file. This is a good opportunity to revisit what we developed in the previous
    chapters. You must essentially convert the `create` view so that it returns our
    current state of the to-do items as opposed to a string. Once you have attempted
    this, the solution should look as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 必须警告的是，我们实际上是在实时手动重写HTML，使用JavaScript。人们可能会将这描述为一种“黑客式”解决方案。然而，在探索React之前，了解我们的方法非常重要，这样我们才能真正欣赏不同方法的好处。在我们进入下一部分之前，我们确实需要对`src/views/to_do/create.rs`文件中的`create`视图进行重构。这是一个回顾我们在前几章所开发内容的好机会。你必须基本上将`create`视图转换为返回当前待办事项的状态，而不是一个字符串。一旦你尝试了这一点，解决方案应该如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, all our to-do items are up to date and functioning. We can now move on
    to the next section, where we will be getting our frontend to make calls to our
    backend.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有我们的待办事项都已更新并正常工作。我们现在可以进入下一部分，我们将让前端调用我们的后端。
- en: Injecting JavaScript into HTML
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JavaScript注入HTML
- en: 'Once we have finished this section, we will have a not-so-pretty but fully
    functional main view where we can add, edit, and delete to-do items using JavaScript
    to make calls to our Rust server. However, as you may recall, we did not add a
    `delete` API endpoint. To inject JavaScript into our HTML, we will have to carry
    out the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成这一部分，我们将拥有一个不太美观但功能齐全的主视图，我们可以使用JavaScript调用我们的Rust服务器来添加、编辑和删除待办事项。然而，如您所回忆的那样，我们没有添加`delete`
    API端点。为了将JavaScript注入我们的HTML，我们必须执行以下步骤：
- en: Create a `delete` item API endpoint.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`delete`项目API端点。
- en: Add a `JavaScript loading` function and replace the JavaScript tag in the HTML
    data with the loaded JavaScript data in the main item Rust view.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`JavaScript加载`函数，并用加载的JavaScript数据替换HTML数据中的JavaScript标签。
- en: Add a JavaScript tag in the HTML file and IDs to the HTML components so that
    we can reference the components in our JavaScript.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文件中添加一个JavaScript标签，并为HTML组件添加ID，这样我们就可以在JavaScript中引用这些组件。
- en: Build a `rendering` function for our to-do items in JavaScript and bind it to
    our HTML via IDs.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的待办事项在JavaScript中构建一个`渲染`函数，并通过ID将其绑定到HTML上。
- en: Build an `API call` function in JavaScript to talk to the backend.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript中构建一个`API调用`函数，以便与后端通信。
- en: Build the `get`, `delete`, `edit`, and `create` functions in JavaScript for
    our buttons to use.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的按钮构建`get`、`delete`、`edit`和`create`函数。
- en: Let’s have a detailed look at this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这一点。
- en: Adding the delete endpoint
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加删除端点
- en: 'Adding the `delete` API endpoint should be straightforward now. If you want
    to, it is advised to try and implement this view by yourself as you should be
    comfortable with this process by now:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`delete` API端点现在应该很简单。如果你想的话，建议你自己尝试实现这个视图，因为你现在应该对这个过程感到很舒服：
- en: 'If you are struggling, we can achieve this by importing the following third-party
    dependencies into the `views/to_do/delete.rs` file:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你感到困难，我们可以通过将以下第三方依赖项导入到 `views/to_do/delete.rs` 文件中来实现这一点：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are not new, and you should be familiar with them and know where we need
    to utilize them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不是新的，你应该熟悉它们，并知道我们需要在哪里使用它们。
- en: 'Then, we must import our structs and functions with the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须使用以下代码导入我们的结构和函数：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we can see that we are using our `to_do` module to construct our to-do
    items. With our `json_serialization` module, we can see that we are accepting
    `ToDoItem` and returning `ToDoItems`. Then, we execute the deletion of our item
    with the `process_input` function. We also do not want anyone who can visit our
    page to be deleting our items. Therefore, we need our `JwToken` struct. Finally,
    we read the state of our items with the `read_file` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在使用我们的 `to_do` 模块来构建我们的待办事项。通过我们的 `json_serialization` 模块，我们可以看到我们正在接受
    `ToDoItem` 并返回 `ToDoItems`。然后，我们使用 `process_input` 函数执行项目的删除。我们也不希望任何可以访问我们页面的用户删除我们的项目。因此，我们需要我们的
    `JwToken` 结构体。最后，我们使用 `read_file` 函数读取我们项目的状态。
- en: 'Now that we have all that we need, we can define our `delete` view with the
    following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，我们可以使用以下代码定义我们的 `delete` 视图：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see that we have accepted `ToDoItem` as JSON and that we have attached
    `JwToken` for the view so that the user must be authorized to access it. At this
    point, we only have `JwToken` attaching a message; we will manage the authentication
    logic for `JwToken` in [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149), *Managing
    User Sessions*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们接受了 `ToDoItem` 作为 JSON，并且我们为视图附加了 `JwToken`，这样用户必须经过授权才能访问它。到目前为止，我们只有
    `JwToken` 附加了一个消息；我们将在 [*第 7 章*](B18722_07.xhtml#_idTextAnchor149)，*管理用户会话* 中管理
    `JwToken` 的认证逻辑。
- en: 'Inside our `delete` view, we can get the state of our to-do items by reading
    our JSON file with the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `delete` 视图中，我们可以通过以下代码读取我们的 JSON 文件来获取我们的待办事项的状态：
- en: '[PRE24]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can check if the item with this title is in the state. If it is not,
    then we return a not found HTTP response. If it is, we then pass on the status
    as we need the title and status to construct the item. We can achieve this checking
    and status extraction with the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以检查具有此标题的项目是否在状态中。如果不是，则返回一个未找到的 HTTP 响应。如果是，我们则传递状态，因为我们需要标题和状态来构建项目。我们可以通过以下代码进行此检查和状态提取：
- en: '[PRE25]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we have the status and title of the to-do item, we can construct our
    item and pass it through our `process_input` function with a `delete` command.
    This will delete our item from the JSON file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经获得了待办事项的状态和标题，我们可以构建我们的项目并通过我们的 `process_input` 函数传递一个 `delete` 命令。这将从
    JSON 文件中删除我们的项目：
- en: '[PRE37]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Remember, we implemented the `Responder` trait for our `ToDoItems` struct,
    and our `ToDoItems::get_state()` function returns a `ToDoItems` struct populated
    with items from the JSON file. Therefore, we can have the following return statement
    from our `delete` view:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，我们为我们的 `ToDoItems` 结构体实现了 `Responder` 特性，并且我们的 `ToDoItems::get_state()` 函数返回一个用
    JSON 文件中的条目填充的 `ToDoItems` 结构体。因此，我们可以从我们的 `delete` 视图中得到以下返回语句：
- en: '[PRE41]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that our `delete` view has been defined, we can add it to our `src/views/to_do/mod.rs`
    file, resulting in our view factory that looks like this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的 `delete` 视图已经定义好了，我们可以将其添加到我们的 `src/views/to_do/mod.rs` 文件中，从而得到如下所示的观点工厂：
- en: '[PRE42]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: By quickly inspecting `to_do_views_factory`, we can see that we have all the
    views that we need to manage our to-do items. If we were to eject this module
    out of our application and insert it into another, we would instantly see what
    we were deleting and adding.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过快速检查 `to_do_views_factory`，我们可以看到我们拥有管理我们的待办事项所需的所有视图。如果我们将这个模块从我们的应用程序中移除并插入到另一个中，我们会立即看到我们正在删除和添加的内容。
- en: With our `delete` view fully integrated into our application, we can move on
    to the second step, which is building our JavaScript loading functionality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `delete` 视图已经完全集成到我们的应用程序中，我们可以继续进行第二步，即构建我们的 JavaScript 加载功能。
- en: Adding a JavaScript loading function
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 JavaScript 加载函数
- en: 'Now that all our endpoints are ready, we must revisit our main app view. In
    the previous section, we established that the JavaScript in the `<script>` section
    works even though it is all just part of one big string. To enable us to put our
    JavaScript into a separate file, our view will load the HTML file as a string
    that has a `{{JAVASCRIPT}}` tag in the `<script>` section of the HTML file. Then,
    we will load the JavaScript file as a string and replace the `{{JAVASCRIPT}}`
    tag with the string from the JavaScript file. Finally, we will return the full
    string in the body in the `views/app/items.rs` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的端点都已经准备好了，我们必须重新审视我们的主应用视图。在上一个部分中，我们确定了 `<script>` 部分的 JavaScript 即使它只是一个大字符串的一部分也能正常工作。为了使我们能够将我们的
    JavaScript 放入一个单独的文件中，我们的视图将加载一个包含 `<script>` 部分中有 `{{JAVASCRIPT}}` 标签的 HTML 文件作为字符串。然后，我们将加载
    JavaScript 文件作为字符串，并用 JavaScript 文件中的字符串替换 `{{JAVASCRIPT}}` 标签。最后，我们在 `views/app/items.rs`
    文件中的 body 中返回完整的字符串：
- en: '[PRE57]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Adding JavaScript tags in the HTML
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 HTML 中添加 JavaScript 标签
- en: 'From our `items` function in the previous step, we can see that we need to
    build a new directory in the root called `JavaScript`. We must also create a file
    in it called `main.js`. With this change to the app view, we are also going to
    have to change the `templates/main.html` file by adding the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们上一步的 `items` 函数中，我们可以看到我们需要在根目录下构建一个新的目录，名为 `JavaScript`。我们还必须在其中创建一个名为 `main.js`
    的文件。随着我们对应用视图的此更改，我们还需要更改 `templates/main.html` 文件，并添加以下代码：
- en: '[PRE58]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Recall that our endpoints return pending items and completed items. Because
    of this, we have defined both lists with their own titles. `div` with the ID of
    `"doneItems"` is where we will insert the done to-do items from an API call.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的端点返回待办事项和已完成事项。因此，我们为这两个列表分别定义了各自的标题。ID 为 `"doneItems"` 的 `div` 是我们将从
    API 调用中插入已完成待办事项的地方。
- en: Then, we will insert our pending items from an API call in `div` with the ID
    of `"pendingItems"`. After that, we must define an input with text and a button.
    This will be for our user to create a new item.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从 API 调用中插入我们的待办事项到 ID 为 `"pendingItems"` 的 `div` 中。之后，我们必须定义一个带有文本和按钮的输入。这将用于用户创建新的项目。
- en: Building a rendering JavaScript function
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建渲染 JavaScript 函数
- en: 'Now that our HTML has been defined, we are going to define the logic in our
    `javascript/main.js` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 HTML，我们将在 `javascript/main.js` 文件中定义逻辑：
- en: 'The first function that we are going to build renders all the to-do items on
    our main page. It must be noted that this is the most convoluted part of the code
    in the `javascript/main.js` file. We are essentially writing JavaScript code that
    writes HTML code. Later, in the *Creating a React app* section, we will replace
    the need to do this using the React framework. For now, we will build a render
    function that will create a list of items. Each item takes the following form
    in HTML:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要构建的第一个函数将渲染我们主页上的所有待办事项。必须注意的是，这是 `javascript/main.js` 文件中代码最复杂的一部分。我们实际上正在编写
    JavaScript 代码来编写 HTML 代码。稍后，在 *创建 React 应用* 部分，我们将使用 React 框架来替换这一需求。现在，我们将构建一个渲染函数来创建一个项目列表。每个项目在
    HTML 中的形式如下：
- en: '[PRE59]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We can see that the title of the to-do item is nested in a paragraph HTML tag.
    Then, we have a button. Recall that the `id` property of an HTML tag must be unique.
    Therefore, we construct this ID based on what the button is going to do on it
    and the title of the to-do item. This will enable us to bind functions performing
    API calls to these `id` properties using event listeners.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到待办事项的标题嵌套在一个段落 HTML 标签中。然后，我们有一个按钮。请记住，HTML 标签的 `id` 属性必须是唯一的。因此，我们根据按钮将要执行的操作和待办事项的标题来构建这个
    ID。这将使我们能够通过事件监听器将这些 `id` 属性绑定到执行 API 调用的函数上。
- en: 'To build our render function, we are going to have to pass in the items to
    be rendered, the process type that we are going to perform (that is, `edit` or
    `delete`), the element ID of the section in the HTML where we are going to render
    these items, and the function that we are going to bind to each to-do item button.
    The outline of this function is defined in the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建我们的渲染函数，我们必须传递要渲染的项目、将要执行的处理类型（即 `edit` 或 `delete`）、在 HTML 中将要渲染这些项目的部分元素
    ID，以及我们将绑定到每个待办事项按钮上的函数。此函数的轮廓在以下代码中定义：
- en: '[PRE67]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inside our `renderItems` function, we can start by constructing HTML and looping
    through our to-do items with the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `renderItems` 函数内部，我们可以从构造 HTML 并使用以下代码遍历我们的待办事项开始：
- en: '[PRE71]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, we have defined an array that will collect metadata about the to-do items
    HTML that we generate for each to-do item. This is under the `itemsMeta` variable
    and will be used later in the `renderItems` function to bind `processFunction`
    to each to-do item button using event listeners. Then, we define the HTML that
    is housing all our to-do items for a process under the `placeholder` variable.
    Here, we start with a `div` tag. Then, we loop through the items, converting the
    data from each item into HTML, and then finish off the HTML with a closing `div`
    tag. After that, we insert the constructed HTML string known as `placeholder`
    into `innerHTML`. Where `innerHTML` is on the page is where we want to see our
    constructed to-do items.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个数组，它将收集我们为每个待办事项生成的待办事项HTML的元数据。这是在`itemsMeta`变量下，将在`renderItems`函数中稍后使用，以使用事件监听器将`processFunction`绑定到每个待办事项按钮。然后，我们在`placeholder`变量下定义了包含所有待办事项的HTML。在这里，我们从一个`div`标签开始。然后，我们遍历项目，将每个项目的数据转换为HTML，然后用关闭的`div`标签结束HTML。之后，我们将构建的HTML字符串`placeholder`插入到`innerHTML`中。`innerHTML`在页面上的位置就是我们想要看到我们构建的待办事项的地方。
- en: 'Inside the loop, we must construct the individual to-do item HTML with the
    following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，我们必须使用以下代码构建单个待办事项HTML：
- en: '[PRE79]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, we extract the title of the item from the item that we are looping through.
    Then, we define our ID for the item that we are going to use to bind to an event
    listener. Note that we replace all empty spaces with a `-`. Now that we have defined
    the title and ID, we add a `div` with a title to our `placeholder` HTML string.
    We also add a `button` with a `placeholderId` and then finish it off with a `div`.
    We can see that our addition to the HTML string is finished with a `;`. Then,
    we add `placeholderId` and `title` to the `itemsMeta` array to be used later.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从正在遍历的项目中提取项目的标题。然后，我们定义我们将要用于绑定事件监听器的项目ID。注意，我们用`-`替换了所有空格。现在我们已经定义了标题和ID，我们在`placeholder`HTML字符串中添加了一个带有标题的`div`。我们还添加了一个带有`placeholderId`的`button`，然后用`div`结束。我们可以看到我们的HTML字符串添加以`;`结束。然后，我们将`placeholderId`和`title`添加到`itemsMeta`数组中，以备后用。
- en: 'Next, we loop `itemsMeta`, creating event listeners with the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历`itemsMeta`，使用以下代码创建事件监听器：
- en: '[PRE87]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now, `processFunction` will fire if a button that we created next to a to-do
    item is clicked. Our function now renders the items, but we need to get them from
    our backend with an API call function. We will look at this now.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果点击了我们创建在待办事项旁边的按钮，`processFunction`将被触发。我们的函数现在可以渲染项目，但我们需要通过API调用函数从我们的后端获取它们。我们现在将看看这一点。
- en: Building an API call JavaScript function
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建API调用JavaScript函数
- en: 'Now that we have our render function, we can look at our API call function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的渲染函数，我们可以看看我们的API调用函数：
- en: 'First, we must define our API call function in the `javascript/main.js` file.
    This function takes in a URL, which is the endpoint of the API call. It also takes
    a method, which is a string of either `POST`, `GET`, or `PUT`. Then, we must define
    our request object:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须在`javascript/main.js`文件中定义我们的API调用函数。这个函数接受一个URL，这是API调用的端点。它还接受一个方法，这是一个字符串，可以是`POST`、`GET`或`PUT`。然后，我们必须定义我们的请求对象：
- en: '[PRE97]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then, we must define the event listener inside the `apiCall` function that
    renders the to-do items with the JSON returned once the call has finished:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在`apiCall`函数内部定义事件监听器，该监听器在调用完成后渲染返回的JSON格式的待办事项：
- en: '[PRE100]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, we can see that we are passing in the IDs that we defined in the `templates/main.html`
    file. We also pass in the response from the API call. We can also see that we
    pass in the `editItem` function, meaning that we are going to fire an `edit` function
    when a button alongside a pending item is clicked, turning the item into a done
    item. Considering this, if a button belonging to a done item is clicked, the `deleteItem`
    function is fired. For now, we will continue building the `apiCall` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在传递在`templates/main.html`文件中定义的ID。我们还传递了API调用的响应。我们还可以看到我们传递了`editItem`函数，这意味着当点击一个悬而未决的项目旁边的按钮时，我们将触发一个`edit`函数，将项目转换为已完成项目。考虑到这一点，如果一个已完成项目的按钮被点击，将触发`deleteItem`函数。目前，我们将继续构建`apiCall`函数。
- en: After this, we must build the `editItem` and `deleteItem` functions. We also
    know that every time the `apiCall` function is called, the items are rendered.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们必须构建`editItem`和`deleteItem`函数。我们还知道每次调用`apiCall`函数时，项目都会被渲染。
- en: 'Now that we have defined the event listener, we must prep the API call object
    with the method and the URL, define the headers, and then return the request object
    for us to send it whenever we need:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了事件监听器，我们必须准备API调用对象的方法和URL，定义头信息，然后返回请求对象，以便我们可以在需要时发送它：
- en: '[PRE110]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now, we can use our `apiCall` function to perform a call to the backend of our
    application and re-render the frontend with the new state of the items after our
    API call. With this, we can move on to the final step, where we will define our
    functions that perform create, get, delete, and edit functions on our to-do items.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的`apiCall`函数对应用程序的后端进行调用，并在API调用后重新渲染带有新项目状态的客户端。有了这个，我们可以继续到最后一步，在那里我们将定义执行创建、获取、删除和编辑待办事项功能的函数。
- en: Building JavaScript functions for buttons
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为按钮构建JavaScript函数
- en: 'Note that the header is just hardcoding the accepted token that is hardcoded
    in the backend. We will cover how to properly define auth headers in [*Chapter
    7*](B18722_07.xhtml#_idTextAnchor149), *Managing User Sessions*. Now that our
    API call function has been defined, we can move on to the `editItem` function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标题只是硬编码在后端中的已接受令牌。我们将在[*第7章*](B18722_07.xhtml#_idTextAnchor149)中介绍如何正确定义认证头，*管理用户会话*。现在，我们的API调用函数已经定义，我们可以继续到`editItem`函数：
- en: '[PRE111]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Here, we can see that the HTML section that the event listener belongs to can
    be accessed via `this`. We know that if we remove the `edit` word, and switch
    `-` with a space, it will convert the ID of the to-do item into the title of the
    to-do item. Then, we utilize the `apiCall` function to define our endpoint and
    method. Note that we have a space in the `"edit "` string in the `replace` function.
    We have this space because we must remove the space after the edit string as well.
    If we do not remove that space, it will be sent to the backend, causing an error
    since our application backend will not have the space next to the title of the
    item in our JSON file. Once our endpoint and API call method have been defined,
    we pass the title into a dictionary with the status as done. This is because we
    know that we are switching the pending item to done. Once this is done, we send
    the API call with the JSON body.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到事件监听器所属的HTML部分可以通过`this`来访问。我们知道，如果我们移除`edit`这个词，并将`-`替换为空格，它将把待办事项的ID转换为待办事项的标题。然后，我们利用`apiCall`函数来定义我们的端点和方法。请注意，在`replace`函数中的`"edit
    "`字符串中有一个空格。我们之所以有这个空格，是因为我们必须移除编辑字符串后面的空格。如果我们不移除那个空格，它将被发送到后端，由于我们的应用程序后端在JSON文件中项目的标题旁边不会有空格，这将会导致错误。一旦我们的端点和API调用方法被定义，我们将标题传递到一个状态为完成的字典中。这是因为我们知道我们正在将待办事项从待办状态切换到完成状态。一旦完成这个操作，我们就发送带有JSON主体的API调用。
- en: 'Now, we can use the same approach for the `deleteItem` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用相同的方法为`deleteItem`函数：
- en: '[PRE112]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Again, there is a space in the `"delete "` string in the `replace` function.
    With that, our rendering process is fully processed. We have defined edit and
    delete functions and a render function. Now, we must load the items when the page
    is initially loaded without having to click any buttons. This can be done with
    a simple API call:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在`replace`函数中的`"delete "`字符串中有一个空格。有了这个，我们的渲染过程就完全处理完毕了。我们已经定义了编辑和删除函数以及渲染函数。现在，我们必须在页面初始加载时加载项目，而无需点击任何按钮。这可以通过一个简单的API调用来完成：
- en: '[PRE113]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Here, we can see that we just make an API call with a `GET` method and send
    it. Also, note that our `getItems` function is being called outside of the function.
    This will be fired once when the view has loaded.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们只是使用`GET`方法进行API调用并发送它。同时，请注意，我们的`getItems`函数是在函数外部被调用的。这将在视图加载时触发一次。
- en: 'It has been a long stint of coding; however, we are nearly there. We only need
    to define the functionality of the create text input and button. We can manage
    this with a simple event listener and API call for the `create` endpoint:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编码已经持续了一段时间；然而，我们几乎完成了。我们只需要定义创建文本输入和按钮的功能。我们可以通过一个简单的事件监听器和`create`端点的API调用来管理这个：
- en: '[PRE114]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We have also added the detail of setting the text input value to `null`. We
    set `input` to `null` so that the user can input another item to be created without
    having to delete the old item title that was just created. Hitting the main view
    for the app gives us the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了将文本输入值设置为`null`的细节。我们将`input`设置为`null`，这样用户就可以输入另一个要创建的项目，而无需删除刚刚创建的旧项目标题。点击应用程序的主视图会给我们以下输出：
- en: '![Figure 5.5 – Main page with rendered to-do items](img/Figure_5.5_B18722.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 包含渲染待办事项的主页](img/Figure_5.5_B18722.png)'
- en: Figure 5.5 – Main page with rendered to-do items
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 渲染后的待办事项主页面
- en: 'Now, to see if our frontend works the way we want it to, we can perform the
    following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查我们的前端是否按预期工作，我们可以执行以下步骤：
- en: Press the **delete** button next to the **washing** done item.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 **washing** 已完成项目旁边的 **删除** 按钮。
- en: Type in `eat cereal for breakfast` and click **Create**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `eat cereal for breakfast` 并点击 **创建**。
- en: Type in `eat ramen for breakfast` and click **Create**.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `eat ramen for breakfast` 并点击 **创建**。
- en: Click `eat ramen for` `breakfast` item.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `eat ramen for` `breakfast` 项目。
- en: 'These steps should yield the following result:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该产生以下结果：
- en: '![Figure 5.6 – Main page after completing the aforementioned steps](img/Figure_5.6_B18722.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 完成上述步骤后的主页面](img/Figure_5.6_B18722.jpg)'
- en: Figure 5.6 – Main page after completing the aforementioned steps
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 完成上述步骤后的主页面
- en: With that, we have a fully functioning web app. All the buttons work, and the
    lists are instantly updated. However, it does not look very pretty. There is no
    spacing, and everything is in black and white. To amend this, we need to integrate
    CSS into the HTML file, which we will do in the next section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就拥有了一个完全功能性的网络应用程序。所有按钮都正常工作，列表会立即更新。然而，它看起来并不美观。没有间距，一切都是黑白相间的。为了修正这个问题，我们需要将
    CSS 集成到 HTML 文件中，我们将在下一节中这样做。
- en: Injecting CSS into HTML
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 CSS 注入到 HTML 中
- en: 'Injecting CSS takes the same approach as injecting JavaScript. We will have
    a CSS tag in the HTML file that will be replaced with the CSS from the file. To
    achieve this, we must carry out the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注入 CSS 与注入 JavaScript 的方法相同。我们将在 HTML 文件中有一个 CSS 标签，它将被文件中的 CSS 替换。为了实现这一点，我们必须执行以下步骤：
- en: Add CSS tags to our HTML file.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 CSS 标签添加到我们的 HTML 文件中。
- en: Create a base CSS file for the whole app.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为整个应用程序创建一个基础 CSS 文件。
- en: Create a CSS file for our main view.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的主视图创建一个 CSS 文件。
- en: Update our Rust crate to serve the CSS and JavaScript.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的 Rust 包以提供 CSS 和 JavaScript。
- en: Let’s have a closer look at this process.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个过程。
- en: Adding CSS tags to HTML
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 CSS 标签添加到 HTML 中
- en: 'First, let’s make some changes to our `templates/main.html` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对我们的 `templates/main.html` 文件做一些更改：
- en: '[PRE115]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here, we can see that we have two CSS tags. The `{{BASE_CSS}}` tag is for base
    CSS, which will be consistent in multiple different views, such as the background
    color and column ratios, depending on the screen size. The `{{BASE_CSS}}` tag
    is for managing CSS classes for this view. Respectfully, the `css/base.css` and
    `css/main.css` files are made for our views. Also, note that we have put all the
    items in a `div` with a class called `mainContainer`. This will enable us to center
    all the items on the screen. We have also added some more classes so that the
    CSS can reference them, and changed the button for the create item from a `button`
    HTML tag to a `div` HTML tag. Once this is done, our `renderItems` function in
    the `javascript/main.js` file will have the following alteration for the loop
    of the items:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有两个 CSS 标签。`{{BASE_CSS}}` 标签用于基础 CSS，它将在多个不同的视图中保持一致，例如背景颜色和列比例，这取决于屏幕大小。`{{BASE_CSS}}`
    标签用于管理此视图的 CSS 类。尊敬地，`css/base.css` 和 `css/main.css` 文件是为我们的视图制作的。此外，请注意，我们将所有项目都放在了一个名为
    `mainContainer` 的 `div` 中。这将使我们能够将所有项目居中显示在屏幕上。我们还添加了一些额外的类，以便 CSS 可以引用它们，并将创建项目的按钮从
    `button` HTML 标签更改为 `div` HTML 标签。一旦完成这些，我们的 `javascript/main.js` 文件中的 `renderItems`
    函数的循环将会有以下更改：
- en: '[PRE116]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: With this considered, we can now define our base CSS in our `css/base.css` file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在可以在 `css/base.css` 文件中定义我们的基础 CSS。
- en: Creating a base CSS
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基础 CSS
- en: 'Now, we must define the style of the page and its components. A good place
    to start is by defining the body of the page in the `css/base.css` file. We can
    do a basic configuration of the body with the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义页面及其组件的样式。一个不错的开始是在 `css/base.css` 文件中定义页面的主体。我们可以使用以下代码对主体进行基本配置：
- en: '[PRE117]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The background color is a reference to a type of color. This reference might
    not seem like it makes sense just looking at it but there are color pickers online
    where you can see and pick a color and the reference code is supplied. Some code
    editors support this functionality but for some quick reference, simply Google
    `HTML color picker` and you will be spoilt for choice at the number of free online
    interactive tools that will be available. With the preceding configuration, the
    background for the entire page will have a code of `#92a8d1`, which is a navy-blue
    color. If we just had that, most of the page would have a white background. The
    navy-blue background would only be present where there is content. We set the
    height to `100vh`. `vh` is relative to 1% of the height of the viewport. With
    this, we can deduce that `100vh` means the styling we defined in the body occupies
    100% of the viewport. Then, we define the font for all text unless overwritten
    to `Arial`, `Helvetica`, or `sans-serif`. We can see that we have defined multiple
    fonts in `font-family`. This does not mean that all of them are implemented or
    that there are different fonts for different levels of headers or HTML tags. Instead,
    this is a fallback mechanism. First, the browser will try and render `Arial`;
    if it is not supported by the browser, it will then try and render `Helvetica`,
    and if that fails too, it will try and render `sans-serif`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 背景颜色是对一种颜色的引用。仅从外观上看，这种引用可能似乎没有意义，但在线上有很多颜色选择器，您可以在其中查看并选择颜色，并且会提供参考代码。一些代码编辑器支持此功能，但为了快速参考，只需在Google上搜索`HTML颜色选择器`，您就会在可用的免费在线交互式工具数量上感到眼花缭乱。根据前面的配置，整个页面的背景将有一个代码为`#92a8d1`，这是一种海军蓝的颜色。如果我们只有这个颜色，页面的大部分区域将会有白色背景。海军蓝背景只会出现在有内容的地方。我们将高度设置为`100vh`。`vh`是相对于视口高度的1%。据此，我们可以推断出`100vh`意味着在`body`中定义的样式占据了视口的100%。然后，我们定义所有文本的字体，除非被覆盖为`Arial`、`Helvetica`或`sans-serif`。我们可以看到我们在`font-family`中定义了多个字体。这并不意味着它们都被实现，或者不同级别的标题或HTML标签有不同的字体。相反，这是一个后备机制。首先，浏览器会尝试渲染`Arial`；如果浏览器不支持，它将尝试渲染`Helvetica`，如果这也失败了，它将尝试渲染`sans-serif`。
- en: 'With that, we have defined the general style for our body, but what about different
    screen sizes? For instance, if we were going to access our application on our
    phone, it should have different dimensions. We can see this in the following figure:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经为我们的`body`定义了通用样式，但关于不同屏幕尺寸呢？例如，如果我们打算在手机上访问我们的应用程序，它应该有不同的尺寸。我们可以在以下图中看到这一点：
- en: '![Figure 5.7 – Difference in margins between a phone and desktop monitor](img/Figure_5.7_B18722.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 手机和桌面显示器之间的边距差异](img/Figure_5.7_B18722.jpg)'
- en: Figure 5.7 – Difference in margins between a phone and desktop monitor
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 手机和桌面显示器之间的边距差异
- en: '*Figure 5**.7* shows the ratio of the margin to the space that is filled up
    by the to-do items list changes. With a phone, there is not much screen space,
    so most of the screen needs to be taken up by the to-do item; otherwise, we would
    not be able to read it. However, if we are using a widescreen desktop monitor,
    we no longer need most of the screen for the to-do items. If the ratio was the
    same, the to-do items would be so stretched in the *X*-axis that it would be hard
    to read and frankly would not look good. This is where media queries come in.
    We can have different style conditions based on attributes such as the width and
    height of the window. We will start with the phone specification. So, if the width
    of the screen is up to 500 pixels, in our `css/base.css` file, we must define
    the following CSS configuration for our body:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5**.7*显示了边距与待办事项列表填充空间的比率。在手机上，屏幕空间不多，所以大部分屏幕需要被待办事项占据；否则，我们就无法阅读它。然而，如果我们使用宽屏桌面显示器，我们就不再需要大部分屏幕来显示待办事项。如果比率相同，待办事项在*X*轴上会被拉伸得很难阅读，而且坦白地说，看起来也不会很好。这就是媒体查询发挥作用的地方。我们可以根据窗口的宽度和高度等属性设置不同的样式条件。我们将从手机规格开始。因此，如果屏幕宽度不超过500像素，在我们的`css/base.css`文件中，我们必须为我们的`body`定义以下CSS配置：'
- en: '[PRE118]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here, we can see that the padding around the edge of the page and each element
    is just one pixel. We also have a grid display. This is where we can define columns
    and rows. However, we do not use it to its full extent. We just have one column.
    This means that our to-do items will take up most of the screen, as shown in the
    phone depiction in *Figure 5**.7*. Even though we are not using a grid in this
    context, I have kept it in so that you can see the relationship this has to the
    other configurations for larger screens. If our screen gets a little bigger, we
    can split our page into three different vertical columns; however, the ratio of
    the width of the middle column to that of the columns on either side is 5:1\.
    This is because our screen is still not very big, and we want our items to still
    take up most of the screen. We can adjust for this by adding another media query
    with different parameters:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到页面边缘和每个元素的填充仅为一个像素。我们还有一个网格显示。这是我们可以定义列和行的位置。然而，我们没有充分利用它。我们只有一个列。这意味着我们的待办事项将占据大部分屏幕，如
    *图 5**.7* 所示。尽管在这个上下文中我们没有使用网格，但我保留了它，以便你可以看到这与更大屏幕的其他配置之间的关系。如果我们的屏幕稍微大一点，我们可以将页面分成三个不同的垂直列；然而，中间列的宽度与两侧列的宽度之比为
    5:1。这是因为我们的屏幕仍然不大，我们希望项目仍然占据大部分屏幕。我们可以通过添加另一个具有不同参数的媒体查询来调整这一点：
- en: '[PRE119]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We can also see that, for our `mainContainer` CSS class where we house our to-do
    items, we will overwrite the `grid-column-start` attribute. If we don’t do this,
    then `mainContainer` would be squeezed in the left margin at `1fr` width. Instead,
    we are starting and finishing in the middle at `5fr`. We can make `mainContainer`
    span across multiple columns with a `grid-column-finish` attribute.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，对于我们的 `mainContainer` CSS 类，其中包含我们的待办事项，我们将覆盖 `grid-column-start` 属性。如果我们不这样做，那么
    `mainContainer` 将在 `1fr` 宽度的左侧边距中挤压。相反，我们是从中间开始和结束，在 `5fr`。我们可以使用 `grid-column-finish`
    属性使 `mainContainer` 横跨多个列。
- en: 'If our screen gets larger, then we want to adjust the ratios even more as we
    do not want our items width to get out of control. To achieve this, we must define
    a 3 to 1 ratio for the middle column versus the 2 side columns, and then a 1 to
    1 ratio when the screen width gets higher than `1001px`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的屏幕变大，我们希望调整比例，因为我们不希望项目宽度失控。为了实现这一点，我们必须定义中间列与两侧列的 3:1 比率，然后在屏幕宽度高于 `1001px`
    时，定义 1:1 比率：
- en: '[PRE120]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Now that we have defined our general CSS for all views, we can move on to our
    view-specific CSS in our `css/main.css` file.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为所有视图定义了我们的通用 CSS，我们可以继续在 `css/main.css` 文件中定义我们的视图特定 CSS。
- en: Creating CSS for the home page
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主页的 CSS
- en: 'Now, we must break down our app components. We have a list of to-do items.
    Each item in the list will be a `div` that has a different background color:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须分解我们的应用程序组件。我们有一个待办事项列表。列表中的每个项目都将是一个具有不同背景颜色的 `div`：
- en: '[PRE121]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can see that this class has a margin of 0.3\. We are using `rem` because
    we want the margin to scale relative to the font size of the root element. We
    also want our item to slightly change color if our cursor hovers over it:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个类有一个 0.3 的边距。我们使用 `rem` 是因为我们希望边距相对于根元素的字体大小进行缩放。我们还希望当我们的光标悬停在项目上时，项目颜色略有变化：
- en: '[PRE122]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Inside an item container, the title of our item is denoted with a paragraph
    tag. We want to define the style of all the paragraphs in the item containers
    but not elsewhere. We can define the style of the paragraphs in the container
    using the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目容器内部，我们使用段落标签表示项目标题。我们希望定义项目容器中所有段落的样式，但不是其他地方的样式。我们可以使用以下代码在容器中定义段落的样式：
- en: '[PRE123]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`inline-block` allows the title to be displayed alongside `div`, which will
    be acting as the button for the item. The margin definitions merely stop the title
    from being right up against the edge of the item container. We also ensure that
    the paragraph color is white.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline-block` 允许标题与 `div` 并排显示，而 `div` 将作为项目的按钮。边距定义仅阻止标题紧挨着项目容器的边缘。我们还确保段落颜色为白色。'
- en: 'With our item title styled, the only item styling left is the action button,
    which is either `edit` or `delete`. This action button is going to float to the
    right with a different background color so that we know where to click. To do
    this, we must define our button style with a class, as outlined in the following
    code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目标题样式化后，剩下的唯一项目样式就是操作按钮，它可以是 `edit` 或 `delete`。这个操作按钮将向右浮动，并具有不同的背景颜色，以便我们知道点击的位置。为此，我们必须使用类定义我们的按钮样式，如下面的代码所示：
- en: '[PRE124]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here, we’ve defined the display, made it float to the right, and defined the
    background color and padding. With this, we can ensure the color changes on hover
    by running the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了显示方式，将其浮动到右边，并定义了背景颜色和填充。有了这个，我们可以通过运行以下代码来确保在悬停时颜色发生变化：
- en: '[PRE125]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now that we have covered all the concepts, we must define the styles for the
    input container. This can be done by running the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了所有概念，我们必须为输入容器定义样式。这可以通过运行以下代码来完成：
- en: '[PRE126]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We’ve done it! We have defined all the CSS, JavaScript, and HTML. Before we
    run the app, we need to load the data in the main view.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！我们已经定义了所有的 CSS、JavaScript 和 HTML。在我们运行应用程序之前，我们需要在主视图中加载数据。
- en: Serving CSS and JavaScript from Rust
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Rust 中提供 CSS 和 JavaScript
- en: 'We serve our CSS in the `views/app/items.rs` file. We do this by reading the
    HTML, JavaScript, base CSS, and main CSS files. Then, we replace our tags in the
    HTML data with the data from the other files:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `views/app/items.rs` 文件中提供我们的 CSS。我们通过读取 HTML、JavaScript、基础 CSS 和主要 CSS
    文件来实现这一点。然后，我们将 HTML 数据中的标签替换为其他文件中的数据：
- en: '[PRE127]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, when we spin up our server, we will have a fully running app with an intuitive
    frontend that will look like what’s shown in the following screenshot:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们启动我们的服务器时，我们将拥有一个完全运行的、具有直观前端的应用程序，其外观将如以下截图所示：
- en: '![Figure 5.8 – Main page after CSS](img/Figure_5.8_B18722.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – CSS 后的主页](img/Figure_5.8_B18722.jpg)'
- en: Figure 5.8 – Main page after CSS
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – CSS 后的主页
- en: Even though our app is functioning, and we have configured the base CSS and
    HTML, we may want to have reusable standalone HTML structures that have their
    own CSS. These structures can be injected into views as and when needed. What
    this does is gives us the ability to write a component once, and then import it
    into other HTML files. This, in turn, makes it easier to maintain and ensures
    consistency of the component in multiple views. For instance, if we create an
    information bar at the top of the view, we will want it to have the same styling
    in the rest of the views. Therefore, it makes sense to create an information bar
    once as a component and insert it into other views, as covered in the next section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用程序正在运行，并且我们已经配置了基础 CSS 和 HTML，但我们可能想要有可重用的独立 HTML 结构，这些结构有自己的 CSS。这些结构可以根据需要注入到视图中。这样做给我们提供了编写组件一次，然后将其导入到其他
    HTML 文件中的能力。这反过来又使得维护更容易，并确保组件在多个视图中的一致性。例如，如果我们创建了一个视图顶部的信息栏，我们希望它在其他视图中也有相同的样式。因此，将信息栏作为组件一次性创建并插入到其他视图中是有意义的，正如下一节所涵盖的。
- en: Inheriting components
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件继承
- en: Sometimes, we will want to build a component that can be injected into views.
    To do this, we are going to have to load both the CSS and HTML, and then insert
    them into the correct parts of the HTML.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想要构建一个可以注入到视图中的组件。为此，我们必须加载 CSS 和 HTML，然后将它们插入到 HTML 的正确部分。
- en: 'To do this, we can create an `add_component` function that takes the name of
    the component, creates tags from the component name, and loads the HTML and CSS
    based on the component name. We will define this function in the `views/app/content_loader.rs`
    file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以创建一个 `add_component` 函数，该函数接受组件名称，从组件名称创建标签，并根据组件名称加载 HTML 和 CSS。我们将在
    `views/app/content_loader.rs` 文件中定义这个函数：
- en: '[PRE128]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Here, we use the `read_file` function that is defined in the same file. Then,
    we inject the component HTML and CSS into the view data. Note that we nested our
    components in a `templates/components/` directory. For this instance, we are inserting
    a `header` component, so our `add_component` function will try and load the `header.html`
    and `header.css` files when we pass the header into the `add_component` function.
    In our `templates/components/header.html` file, we must define the following HTML:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用在同一个文件中定义的 `read_file` 函数。然后，我们将组件 HTML 和 CSS 注入到视图数据中。注意，我们将组件嵌套在 `templates/components/`
    目录中。对于这个实例，我们正在插入一个 `header` 组件，所以当我们将 `header` 传递给 `add_component` 函数时，我们的 `add_component`
    函数将尝试加载 `header.html` 和 `header.css` 文件。在我们的 `templates/components/header.html`
    文件中，我们必须定义以下 HTML：
- en: '[PRE129]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Here, we are merely displaying the counts for the number of completed and pending
    to-do items. In our `templates/components/header.css` file, we must define the
    following CSS:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是显示已完成和待办事项的数量。在我们的 `templates/components/header.css` 文件中，我们必须定义以下 CSS：
- en: '[PRE130]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'For our `add_component` function to insert our CSS and HTML into the right
    place, we must insert the `HEADER` tag into the `<style>` section of the `templates/main.html`
    file:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 `add_component` 函数能够将 CSS 和 HTML 插入到正确的位置，我们必须将 `HEADER` 标签插入到 `templates/main.html`
    文件的 `<style>` 部分中：
- en: '[PRE131]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now that all of our HTML and CSS have been defined, we need to import the `add_component`
    function in our `views/app/items.rs` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有的 HTML 和 CSS，我们需要在我们的 `views/app/items.rs` 文件中导入 `add_component`
    函数：
- en: '[PRE132]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In the same file, we must add the header in the `items` view function, like
    so:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，我们必须在 `items` 视图函数中添加标题，如下所示：
- en: '[PRE133]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, we must alter the `apiCall` function in our `injecting_header/javascript/main.js`
    file to ensure that the header is updated with the to-do item counts:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须修改 `injecting_header/javascript/main.js` 文件中的 `apiCall` 函数，以确保标题更新为待办事项项的数量：
- en: '[PRE134]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now that we have inserted our component, we get the following rendered view:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经插入了我们的组件，我们得到以下渲染视图：
- en: '![Figure 5.9 – Main page with header](img/Figure_5.9_B18722.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 带有标题的主页](img/Figure_5.9_B18722.jpg)'
- en: Figure 5.9 – Main page with header
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 带有标题的主页
- en: As we can see, our header displays the data correctly. If we add the header
    tags to the view HTML file, and we call `add_component` in our view, we will get
    that header.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的标题正确地显示了数据。如果我们将标题标签添加到视图 HTML 文件中，并在我们的视图中调用 `add_component`，我们就会得到那个标题。
- en: Right now, we have a fully working single-page application. However, this was
    not without difficulty. We can see that our frontend would start to spiral out
    of control if we started to add more features to the frontend. This is where frameworks
    such as React come in. With React, we can structure our code into proper components
    so that we can use them whenever we need to. In the next section, we will create
    a basic React application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个完全工作的单页应用程序。然而，这并非没有困难。我们可以看到，如果我们开始在前端添加更多功能，我们的前端将会开始失去控制。这就是像 React
    这样的框架发挥作用的地方。使用 React，我们可以将我们的代码结构化为适当的组件，这样我们就可以在需要时使用它们。在下一节中，我们将创建一个基本的 React
    应用程序。
- en: Creating a React app
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 React 应用程序
- en: 'React is a standalone application. Because of this, we will usually have our
    React application in its own GitHub repository. If you want to keep your Rust
    application and React application in the same GitHub repository, that is fine,
    but just make sure that they are in different directories in the root. Once we
    have navigated outside of the Rust web application, we can run the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个独立的应用程序。正因为如此，我们通常会将我们的 React 应用程序放在自己的 GitHub 仓库中。如果您想将 Rust 应用程序和
    React 应用程序放在同一个 GitHub 仓库中，那也是可以的，但请确保它们在根目录下的不同目录中。一旦我们离开了 Rust 网络应用程序，我们就可以运行以下命令：
- en: '[PRE135]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'This creates a React application in the `front_end` directory. If we look inside,
    we will see that there are a lot of files. Remember that this book is about web
    programming in Rust. Exploring everything about React is beyond the scope of this
    book. However, a book dedicated to React development is suggested in the *Further
    reading* section. For now, we will focus on the `front_end/package.json` file.
    Our `package.json` file is like our `Cargo.toml` file, where we define dependencies,
    scripts, and other metadata around the application that we are building. Inside
    our `package.json` file, we have the following scripts:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `front_end` 目录中创建一个 React 应用程序。如果我们查看内部，我们会看到很多文件。请记住，这本书是关于 Rust 的网络编程。探索
    React 的所有内容超出了本书的范围。然而，在 *进一步阅读* 部分建议了一本专门介绍 React 开发的书籍。现在，我们将专注于 `front_end/package.json`
    文件。我们的 `package.json` 文件就像我们的 `Cargo.toml` 文件一样，我们在其中定义了依赖项、脚本以及围绕我们正在构建的应用程序的其他元数据。在我们的
    `package.json` 文件中，我们有以下脚本：
- en: '[PRE136]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We can edit this if we want but as it stands, if we run the `npm start` command
    in the directory where our `package.json` file is, we will run the `react-scripts
    start` command. We will run our React application soon, but before this, we must
    edit our `front_end/src/App.js` file with the following code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编辑它，我们可以这样做，但就目前而言，如果我们运行 `npm start` 命令在 `package.json` 文件所在的目录中，我们将运行
    `react-scripts start` 命令。我们将很快运行我们的 React 应用程序，但在这样做之前，我们必须使用以下代码编辑我们的 `front_end/src/App.js`
    文件：
- en: '[PRE137]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Before we break down this code, we must clarify something. If you go on the
    internet, you might come across articles stating that JavaScript is not a class-based
    object-oriented language. This book is not going to take a deep dive into JavaScript.
    Instead, this chapter is designed to give you enough knowledge to get a frontend
    up and running. Hopefully, this chapter is enough to facilitate further reading
    and kickstart your journey if you want to add a frontend to your Rust web application.
    For the sake of this chapter, we will just look at classes and objects that can
    support inheritance.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分解这段代码之前，我们必须澄清一些事情。如果你上网，可能会看到一些文章声称JavaScript不是一种基于类的面向对象语言。这本书不会深入探讨JavaScript。相反，本章旨在让你获得足够的知识，以便能够启动并运行前端。希望这一章足以帮助你进一步阅读，并启动你为Rust网络应用添加前端之旅。为了本章的目的，我们将只关注可以支持继承的类和对象。
- en: In the preceding code, we imported the `component` object from the `react` package.
    Then, we defined an `App` class that inherits the `component` class. The `App`
    class is the main part of our application, and we can treat the `front_end/src/App.js`
    file as our entry point for the frontend application. It is in the `App` class
    that we can define other routes if needed. We can also see that there is a `state`
    belonging to the `App` class. This is the overall memory of the application. We
    must call it `state`; every time the state is updated, the `render` function is
    executed, updating what the component renders to the frontend. This has abstracted
    a lot of what we were doing throughout the previous sections of this chapter when
    our state updated our homemade `render` function. We can see that our state can
    be referenced in the `render` function when returning. This is known as JSX, which
    allows us to write HTML elements directly in JavaScript without any extra methods.
    Now that the basic application has been defined, we can export it to make it available.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`react`包中导入了`component`对象。然后，我们定义了一个继承自`component`类的`App`类。`App`类是应用的主要部分，我们可以将`front_end/src/App.js`文件视为前端应用的入口点。我们可以在`App`类中定义其他路由（如果需要的话）。我们还可以看到`App`类中有一个`state`。这是应用的整体内存。我们必须将其称为`state`；每次状态更新时，`render`函数都会执行，更新组件渲染到前端的内容。这抽象了我们之前章节中在状态更新我们的自定义`render`函数时所做的大部分工作。我们可以看到，我们的状态可以在返回时被引用。这被称为JSX，它允许我们直接在JavaScript中写入HTML元素，而无需任何额外的方法。现在基本应用已经定义，我们可以将其导出以使其可用。
- en: 'Let’s navigate to the directory where the `package.json` file is placed and
    run the following command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到放置`package.json`文件的目录，并运行以下命令：
- en: '[PRE138]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The React server will spin up and we will get the following view in our browser:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: React服务器将启动，我们将在浏览器中获得以下视图：
- en: '![Figure 5.10 – First main view of our React application](img/Figure_5.10_B18722.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – 我们React应用的第一个主要视图](img/Figure_5.10_B18722.jpg)'
- en: Figure 5.10 – First main view of our React application
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 我们React应用的第一个主要视图
- en: Here, we can see that the message in our state has been passed into our `render`
    function and then displayed in our browser. Now that our React application is
    running, we can start loading data into our React application using API calls.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的状态中的消息已经传递到我们的`render`函数中，然后显示在我们的浏览器中。现在我们的React应用正在运行，我们可以开始使用API调用将数据加载到我们的React应用中。
- en: Making API calls in React
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中执行API调用
- en: 'Now that the basic application is running, we can start performing an API call
    to our backend. For this, we will mainly focus on the `front_end/src/App.js` file.
    We can build up our application so that it can populate the frontend with items
    from our Rust application. First we must add the following to the dependencies
    of our `package.json` file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本应用正在运行，我们可以开始对后端执行API调用。为此，我们将主要关注`front_end/src/App.js`文件。我们可以构建我们的应用，使其能够用来自Rust应用的项目填充前端。首先，我们必须将以下内容添加到`package.json`文件的依赖项中：
- en: '[PRE139]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Then, we can run the following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行以下命令：
- en: '[PRE140]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'This will install our extra dependency. Now, we can turn to our `front_end/src/App.js`
    file and import what we need with the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们的额外依赖项。现在，我们可以转向我们的`front_end/src/App.js`文件，并使用以下代码导入我们需要的内容：
- en: '[PRE141]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We are going to use `Component` for our `App` class inheritance and `axios`
    to perform API calls to our backend. Now, we can define our `App` class and update
    our state with the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Component`为我们的`App`类实现继承，并使用`axios`执行对后端的API调用。现在，我们可以使用以下代码定义我们的`App`类并更新我们的状态：
- en: '[PRE142]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Here, we have the same structure as our homemade frontend. This is also the
    data that we return from our get items view in the Rust server. Now that we know
    what data we are going to work with, we can carry out the following steps:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有与我们的自制前端相同的结构。这也是我们从Rust服务器中的获取项目视图中返回的数据。现在我们知道我们将要处理什么数据，我们可以执行以下步骤：
- en: Create a function inside our `App` class that gets the functions from the Rust
    server.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`App`类内部创建一个函数，用于从Rust服务器获取函数。
- en: Ensure that this function is executed when the `App` class is mounted.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保这个函数在`App`类挂载时执行。
- en: Create a function inside our `App` class that processes the items that are returned
    from the Rust server into HTML.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`App`类内部创建一个函数，用于将Rust服务器返回的项目处理成HTML。
- en: Create a function inside our `App` class that renders all the aforementioned
    components to the frontend once we are finished.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成所有这些步骤后，创建一个函数，将所有上述组件渲染到前端。
- en: Enable our Rust server to receive calls from other sources.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用我们的Rust服务器以接收来自其他源的调用。
- en: 'Before we embark on these steps, we should note that the outline for our `App`
    class will take the following form:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这些步骤之前，我们应该注意，我们的`App`类的轮廓将采取以下形式：
- en: '[PRE143]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'With this, we can start on the function that makes the API call:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以开始编写执行API调用的函数：
- en: 'Inside our `App` class, our `getItems` function takes the following layout:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`App`类内部，我们的`getItems`函数具有以下布局：
- en: '[PRE144]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Here, we define the URL. Then, we add our token to our header. For now, we
    will just hardcode a simple string because we are not setting up our user sessions
    in the Rust server yet; we will update this in [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149),
    *Managing User Sessions*. Then, we close this. Because `axios.get` is a promise,
    we must use `.then`. The code inside the `.then` brackets is executed when the
    data is returned. Inside these brackets, we extract the data that we need and
    then execute the `this.setState` function. The `this.setState` function updates
    the state of the `App` class. However, executing `this.setState` also executes
    the `render` function of the `App` class, which will update the browser. Inside
    this `this.setState` function, we pass in the following code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了URL。然后，我们将我们的令牌添加到我们的头部。目前，我们将只硬编码一个简单的字符串，因为我们还没有在Rust服务器上设置用户会话；我们将在[*第7章*](B18722_07.xhtml#_idTextAnchor149)，*管理用户会话*中更新这个；然后我们关闭它。因为`axios.get`是一个承诺，我们必须使用`.then`。`.then`括号内的代码在数据返回时执行。在这些括号内，我们提取所需的数据，然后执行`this.setState`函数。`this.setState`函数更新`App`类的状态。然而，执行`this.setState`也会执行`App`类的`render`函数，这将更新浏览器。在这个`this.setState`函数中，我们传递以下代码：
- en: '[PRE153]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: With this, we have completed `getItems` and we can get items from the backend.
    Now that we have defined it, we must ensure that it gets executed, which we will
    do next.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经完成了`getItems`，并且可以从后端获取项目。现在我们已经定义了它，我们必须确保它被执行，我们将在下一步中这样做。
- en: 'Ensuring the `getItems` function is fired and thus the state is updated when
    the `App` class is loaded can be achieved with the following code:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`App`类加载时执行`getItems`函数并更新状态，可以通过以下代码实现：
- en: '[PRE154]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This is straightforward. `getItems` will execute immediately after our `App`
    component is mounted. We are essentially calling `this.setState` in the `componentDidMount`
    function. This triggers the extra rendering before the browser updates the screen.
    Even though `render` is called twice, the user will not see the intermediate state.
    This is one of the many functions that we inherit from the React `Component` class.
    Now that we load the data as soon as the page loads, we can move on to the next
    step: processing the loaded data.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。`getItems`将在我们的`App`组件挂载后立即执行。我们本质上是在`componentDidMount`函数中调用`this.setState`。这触发了在浏览器更新屏幕之前的额外渲染。即使`render`被调用两次，用户也不会看到中间状态。这是我们继承自React
    `Component`类的许多函数之一。现在，既然我们在页面加载时立即加载数据，我们可以继续下一步：处理加载数据。
- en: 'For the `processItemValues` function inside our `App` class, we must take in
    an array of JSON objects that represent items and convert them into HTML, which
    can be achieved with the following code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们`App`类内部的`processItemValues`函数，我们必须接收一个表示项目的JSON对象数组，并将它们转换为HTML，这可以通过以下代码实现：
- en: '[PRE157]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, we just loop through the items, converting them into `li` HTML elements
    and adding them to an empty array that is then returned once filled. Remember
    that we use the `processItemValue` function to process the data before it goes
    into the state in the `getItems` function. Now that we have all the HTML components
    in our state, we need to place them on the page with our `render` function.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是遍历项目，将它们转换为`li` HTML元素，并将它们添加到一个空数组中，然后一旦填满就返回。记住，我们在`getItems`函数中在数据进入状态之前使用`processItemValue`函数来处理数据。现在我们已经有了所有HTML组件在我们的状态中，我们需要使用我们的`render`函数将它们放置在页面上。
- en: 'For our `App` class, the `render` function only returns HTML components. We
    do not employ any extra logic in this. We can return the following:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的`App`类，`render`函数只返回HTML组件。我们在这里不使用任何额外的逻辑。我们可以返回以下内容：
- en: '[PRE166]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Here, we can see that our state is directly referenced. This is a lovely change
    from the manual string manipulation that we employed earlier in this chapter.
    Using React is a lot cleaner, reducing the risk of errors. On our frontend, the
    render process with the calls to the backend should work. However, our Rust server
    will block requests from the React application because it is from a different
    application. To fix this, we need to move on to the next step.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的状态被直接引用。这与我们在本章早期使用的手动字符串操作相比是一个美好的变化。使用React要干净得多，减少了出错的风险。在我们的前端，对后端的调用渲染过程应该可以工作。然而，我们的Rust服务器会阻止来自React应用的请求，因为它来自不同的应用。为了解决这个问题，我们需要进行下一步。
- en: 'Right now, our Rust server will block our requests to the server. This is down
    to `Cargo.toml` file with the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的Rust服务器会阻止我们对服务器的请求。这归因于`Cargo.toml`文件中的以下代码：
- en: '[PRE175]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'In our `src/main.rs` file, we must import CORS with the following code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`src/main.rs`文件中，我们必须使用以下代码导入CORS：
- en: '[PRE176]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Now, we must define CORS policy before the definition of the server and wrap
    the CORS policy right after the views configuration with the following code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在服务器定义之前定义CORS策略，并在视图配置之后立即用以下代码包装CORS策略：
- en: '[PRE177]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: With this, our server is ready to accept requests from our React application.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们的服务器已经准备好接受来自我们的React应用的请求。
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we defined our CORS policy, we were expressive in that we wanted to allow
    all methods, headers, and origins. However, we can be more concise with the following
    CORS definition:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义我们的CORS策略时，我们明确表示我们希望允许所有方法、头和来源。然而，我们可以用以下CORS定义来更加简洁：
- en: '`let cors =` `Cors::permissive();`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`let cors =` `Cors::permissive();`'
- en: 'Now, we can test our application to see if it is working. We can do this by
    running our Rust server with Cargo and running our React application in a different
    terminal. Once this is up and running, our React application should look like
    this when loaded:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的应用以查看它是否工作。我们可以通过使用Cargo运行我们的Rust服务器并在不同的终端中运行我们的React应用来实现这一点。一旦启动并运行，我们的React应用在加载时应该看起来像这样：
- en: '![Figure 5.11 – The view of our React application when it first talks to our
    Rust server](img/Figure_5.11_B18722.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – 当我们的React应用首次与Rust服务器通信时的视图](img/Figure_5.11_B18722.jpg)'
- en: Figure 5.11 – The view of our React application when it first talks to our Rust
    server
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 当我们的React应用首次与Rust服务器通信时的视图
- en: With this, we can see that the call to our Rust application is now working as
    expected. However, all we are doing is listing the names and statuses of the to-do
    items. Where React shines is in building custom components. This means that we
    can build individual classes that have their own states and functions for each
    to-do item. We’ll see this in the next section.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以看到现在对我们的Rust应用的调用正在按预期工作。然而，我们正在做的事情只是列出待办事项的名称和状态。React的亮点在于构建自定义组件。这意味着我们可以为每个待办事项构建具有自己状态和函数的单独类。我们将在下一节中看到这一点。
- en: Creating custom components in React
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中创建自定义组件
- en: 'When we look at our `App` class, we can see that it is useful to have a class
    that has a state and functions that can be utilized to manage how and when HTML
    is rendered to the browser. When it comes to individual to-do items, we could
    use a state and functions. This is because we have a button that gets attributes
    from the to-do item and calls the Rust server to either edit or delete it. In
    this section, we are going to build two components: a `ToDoItem` component in
    the `src/components/ToDoItem.js` file and a `CreateToDoItem` component in the
    `src/components/CreateToDoItem.js` file. Once we have built these, we can plug
    them into our `App` component as our `App` component will get the items’ data
    and loop through these items, creating multiple `ToDoItem` components. There are
    a few steps that we need to process to achieve this, so this section will be split
    into the following subsections:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 `App` 类时，我们可以看到有一个具有状态和可以用来管理如何以及何时将 HTML 渲染到浏览器的函数的类是非常有用的。当涉及到单个待办事项时，我们可以使用状态和函数。这是因为我们有一个从待办事项获取属性并调用
    Rust 服务器以编辑或删除它的按钮。在本节中，我们将构建两个组件：在 `src/components/ToDoItem.js` 文件中的 `ToDoItem`
    组件和在 `src/components/CreateToDoItem.js` 文件中的 `CreateToDoItem` 组件。一旦我们构建了这些组件，我们就可以将它们插入到
    `App` 组件中，因为 `App` 组件将获取项目数据并遍历这些项目，创建多个 `ToDoItem` 组件。为了实现这一点，我们需要处理几个步骤，因此本节将分为以下子节：
- en: Creating our `ToDoItem` component
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的 `ToDoItem` 组件
- en: Creating our `CreateToDoItem` component
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的 `CreateToDoItem` 组件
- en: Constructing and managing custom components in our `App` component
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `App` 组件中构建和管理自定义组件
- en: Let’s get started.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating our ToDoItem component
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的 ToDoItem 组件
- en: 'We will start with the simpler `ToDoItem` component in the `src/components/ToDoItem.js`
    file. First, we must import the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `src/components/ToDoItem.js` 文件中的更简单的 `ToDoItem` 组件开始。首先，我们必须导入以下内容：
- en: '[PRE178]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'This is nothing new. Now that we have imported what we need, we can focus on
    how we define `ToDoItem` with the following code:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是什么新东西。现在我们已经导入了所需的模块，我们可以专注于如何使用以下代码定义 `ToDoItem`：
- en: '[PRE179]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Here, we populate the state with `this.props`, which is the parameter that’s
    passed into the component when the component is constructed. Then, we have the
    following functions for our `ToDoItem` component:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `this.props` 填充状态，这是在组件构建时传递给组件的参数。然后，我们有以下 `ToDoItem` 组件的函数：
- en: '`processStatus`: This function converts the status of the to-do item, such
    as `PENDING`, into the message on the button, such as `edit`.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processStatus`: 这个函数将待办事项的状态（如 `PENDING`）转换为按钮上的消息（如 `edit`）。'
- en: '`inverseStatus`: When we have a to-do item with a status of `PENDING` and we
    edit it, we want to convert it into a status of `DONE` so that it can be sent
    to the `edit` endpoint on the Rust server, which is the inverse. Therefore, this
    function creates an inverse of the status that’s passed in.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inverseStatus`: 当我们有一个状态为 `PENDING` 的待办事项并且编辑它时，我们希望将其转换为 `DONE` 状态，以便可以发送到
    Rust 服务器的 `edit` 端点，这是相反的操作。因此，这个函数创建了一个传入状态的逆状态。'
- en: '`sendRequest`: This function sends the request to the Rust server for either
    editing or deleting the to-do item. We can also see that our `sendRequest` function
    is an arrow function. The arrow syntax essentially binds the function to the component
    so that we can reference it in our `render` return statement, allowing the `sendRequest`
    function to be executed when a button that is bound to it is clicked.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendRequest`: 这个函数将请求发送到 Rust 服务器，用于编辑或删除待办事项。我们还可以看到我们的 `sendRequest` 函数是一个箭头函数。箭头语法本质上将函数绑定到组件，这样我们就可以在我们的
    `render` 返回语句中引用它，允许当绑定到按钮被点击时执行 `sendRequest` 函数。'
- en: 'Now that we know what our functions are supposed to do, we can define our status
    functions with the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们的函数应该做什么，我们可以使用以下代码定义我们的状态函数：
- en: '[PRE180]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'This is straightforward and does not need much explanation. Now that our status
    processing functions are done, we can define our `sendRequest` function with the
    following code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不需要太多解释。现在我们的状态处理函数已经完成，我们可以使用以下代码定义我们的 `sendRequest` 函数：
- en: '[PRE181]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Here, we use `this.state.button` to define part of the URL as the endpoint changes,
    depending on the button that we are pressing. We can also see that we execute
    the `this.props.passBackResponse` function. This is a function that we pass into
    the `ToDoItem` component. This is because we get the full state of our to-do items
    from the Rust server back after the edit or delete request. We will need to enable
    our `App` component to process the data that has been passed back. Here, we are
    getting a sneak peek of what we are going to be doing in the *Constructing and
    managing custom components in our App component* subsection. Our `App` component
    will have an unexecuted function under the `passBackResponse` parameter that it
    will pass through to our `ToDoItem` component. This function, under the `passBackResponse`
    parameter, will process the new to-do item’s state and render it in the `App`
    component.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`this.state.button`来定义URL的一部分作为端点根据我们按下的按钮而变化。我们还可以看到我们执行了`this.props.passBackResponse`函数。这是一个我们传递给`ToDoItem`组件的函数。这是因为我们在编辑或删除请求后从Rust服务器获取了待办事项的完整状态。我们需要使我们的`App`组件能够处理已传递回的数据。在这里，我们提前看到了我们将在*在App组件中构建和管理自定义组件*小节中要做的事情。我们的`App`组件将在`passBackResponse`参数下有一个未执行的功能，它将传递给我们的`ToDoItem`组件。这个在`passBackResponse`参数下的函数将处理新的待办事项的状态，并在`App`组件中渲染它。
- en: 'With that, we have configured all our functions. All that is left is to define
    the return of the `render` function, which takes the following form:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经配置了所有我们的函数。剩下要做的就是定义`render`函数的返回值，其形式如下：
- en: '[PRE182]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Here, we can see that the title of the to-do item is rendered in the paragraph
    tag and that our button executes the `sendRequest` function when clicked. We have
    now finished this component and it is ready to be displayed in our application.
    However, before we do this, we need to build the component that creates to-do
    items in the next section.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到待办事项的标题被渲染在段落标签中，并且我们的按钮在点击时执行`sendRequest`函数。我们现在已经完成了这个组件，它准备在我们的应用中显示。然而，在我们这样做之前，我们需要在下一节构建创建待办事项的组件。
- en: Creating custom components in React
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在React中创建自定义组件
- en: 'Our React application is functioning in terms of listing, editing, and deleting
    to-do items. However, we are not able to create any to-do items. This consists
    of an input and a `create` button so that we can put in a to-do item that we can
    then create by clicking the button. In our `src/components/CreateToDoItem.js`
    file, we need to import the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的反应应用在列出、编辑和删除待办事项方面运行良好。然而，我们无法创建任何待办事项。这包括一个输入和一个`create`按钮，以便我们可以输入一个待办事项，然后通过点击按钮来创建它。在我们的`src/components/CreateToDoItem.js`文件中，我们需要导入以下内容：
- en: '[PRE183]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'These are the standard imports to build our components. Once the imports have
    been defined, our `CreateToDoItem` component takes the following form:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们构建组件的标准导入。一旦导入被定义，我们的`CreateToDoItem`组件将具有以下形式：
- en: '[PRE184]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'In the preceding code, we can see that our `CreateToDoItem` component has the
    following functions:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的`CreateToDoItem`组件具有以下功能：
- en: '`createItem`: This function sends a request to the Rust server to create the
    to-do item with the title in the state'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createItem`：这个函数向Rust服务器发送请求，以创建标题在状态中的待办事项'
- en: '`handleTitleChange`: This function updates the state every time the input is
    updated'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleTitleChange`：这个函数在输入更新时更新状态'
- en: 'Before we explore these two functions, we will flip around the order in which
    we code these functions, and define the return of the `render` function with the
    following code:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索这两个函数之前，我们将调整我们编写这些函数的顺序，并使用以下代码定义`render`函数的返回值：
- en: '[PRE185]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Here, we can see that the value of the input is `this.state.title`. Also, when
    the input changes, we execute the `this.handleTitleChange` function. Now that
    we have covered the `render` function, there is nothing new to introduce. This
    is a good opportunity for you to look at the outline of our `CreateToDoItem` component
    again and try to define the `createItem` and `handleTitleChange` functions yourself.
    They take a similar form to the functions in the `ToDoItem` component.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到输入的值为`this.state.title`。同时，当输入改变时，我们执行`this.handleTitleChange`函数。现在我们已经覆盖了`render`函数，没有新的内容要介绍。这是一个很好的机会，让你再次查看我们的`CreateToDoItem`组件的轮廓，并尝试自己定义`createItem`和`handleTitleChange`函数。它们与`ToDoItem`组件中的函数形式相似。
- en: 'Your attempt to define the `createItem` and `handleTitleChange` functions should
    look similar to the following:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您尝试定义的 `createItem` 和 `handleTitleChange` 函数应该类似于以下内容：
- en: '[PRE186]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: With that, we have defined both of our custom components. We are now ready to
    move on to the next subsection, where we will manage our custom components.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经定义了两个自定义组件。我们现在可以继续到下一个小节，在那里我们将管理我们的自定义组件。
- en: Constructing and managing custom components in our App component
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 App 组件中构建和管理自定义组件
- en: 'While it was fun creating our custom components, they are not much use if we
    do not use them in our application. In this subsection, we will add some additional
    code to the `src/App.js` file to enable our custom components to be used. First,
    we must import our components with the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建自定义组件很有趣，但如果我们不在应用程序中使用它们，它们就没有什么用处。在本小节中，我们将向 `src/App.js` 文件添加一些额外的代码，以使我们的自定义组件可以被使用。首先，我们必须使用以下代码导入我们的组件：
- en: '[PRE187]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Now that we have our components, we can move on to our first alteration. Our
    `App` component’s `processItemValues` function can be defined with the following
    code:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的组件，我们可以继续到我们的第一个修改。我们的 `App` 组件的 `processItemValues` 函数可以用以下代码定义：
- en: '[PRE188]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Here, we can see that we loop through the data that we get from the Rust server
    but instead of passing the data into a generic HTML tag, we pass the parameters
    of the to-do item data into our own custom component, which is treated like an
    HTML tag. When it comes to handling our own response with the returned state,
    we can see that it is an arrow function that processes the data and sets the state
    with the following code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们遍历从 Rust 服务器获取的数据，但不是将数据传递给一个通用的 HTML 标签，而是将待办事项数据的参数传递到我们自己的自定义组件中，这个组件被当作一个
    HTML 标签来处理。当我们处理自己的响应并返回状态时，我们可以看到它是一个箭头函数，该函数处理数据并使用以下代码设置状态：
- en: '[PRE189]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'This is very similar to our `getItems` function. You could do some refactoring
    here if you wanted to reduce the amount of duplicated code. However, to make this
    work, we must define the return statement for the `render` function with the following
    code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的 `getItems` 函数非常相似。如果您想减少重复代码的数量，这里可以进行一些重构。然而，为了使这可行，我们必须使用以下代码定义 `render`
    函数的返回语句：
- en: '[PRE190]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Here, we can see that there is not much change apart from adding the `createItem`
    component. Running our Rust server and our React application will give us the
    following view:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到除了添加 `createItem` 组件之外，没有太多变化。运行我们的 Rust 服务器和 React 应用程序将给出以下视图：
- en: '![Figure 5.12 – The view of our React application with custom components](img/Figure_5.12_B18722.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 带有自定义组件的 React 应用程序视图](img/Figure_5.12_B18722.jpg)'
- en: Figure 5.12 – The view of our React application with custom components
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 带有自定义组件的 React 应用程序视图
- en: '*Figure 5**.12* shows that our custom components are rendering. We can click
    on the buttons and, as a result, we will see that all our API calls work and our
    custom components work as they should. Now, all that is standing in our way is
    making our frontend look presentable, which we can do by lifting our CSS into
    the React application.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.12* 显示我们的自定义组件正在渲染。我们可以点击按钮，结果我们会看到所有的 API 调用都正常工作，我们的自定义组件也按预期工作。现在，唯一阻碍我们的是让我们的前端看起来更美观，我们可以通过将
    CSS 提升到 React 应用程序来实现这一点。'
- en: Lifting CSS into React
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 CSS 提升到 React
- en: 'We are now on the final stretch of making our React application usable. We
    could split up our CSS into multiple different files. However, we are coming to
    the end of this chapter, and going over all the CSS again would unnecessarily
    fill up this chapter with loads of duplicate code. While our HTML and JavaScript
    are different, the CSS is the same. To get it running, we can copy all the CSS
    from the following files:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正处于使我们的 React 应用程序可用的最后阶段。我们可以将 CSS 分成多个不同的文件。然而，我们即将结束本章，再次检查所有的 CSS 将会无谓地在这个章节中填充大量的重复代码。虽然我们的
    HTML 和 JavaScript 是不同的，但 CSS 是相同的。为了使其运行，我们可以从以下文件复制所有 CSS：
- en: '`templates/components/header.css`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates/components/header.css`'
- en: '`css/base.css`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css/base.css`'
- en: '`css/main.css`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`css/main.css`'
- en: 'Copy the CSS files listed here into the `front_end/src/App.css` file. There
    is one change to the CSS, and this is where all the `.body` references should
    be replaced with `.App`, as shown in the following code snippet:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 将此处列出的 CSS 文件复制到 `front_end/src/App.css` 文件中。CSS 有一个改动，所有 `.body` 引用都应该替换为 `.App`，如下代码片段所示：
- en: '[PRE191]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Now, we can import our CSS and use it in our app and components. We will also
    have to alter the return HTML in the `render` functions. We can work through all
    three files. For the `src/App.js` file, we must import the CSS with the following
    code:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以导入我们的 CSS 并在应用程序和组件中使用它。我们还将不得不修改 `render` 函数中的返回 HTML。我们可以处理所有三个文件。对于
    `src/App.js` 文件，我们必须使用以下代码导入 CSS：
- en: '[PRE192]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Then, we must add a header and define our `div` tags with the correct classes
    with the following code for the return statement from our `render` function:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加一个标题，并使用以下代码定义我们的 `div` 标签的正确类，以从我们的 `render` 函数的返回语句中获取代码：
- en: '[PRE193]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'In our `src/components/ToDoItem.js` file, we must import the CSS with the following
    code:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `src/components/ToDoItem.js` 文件中，我们必须使用以下代码导入 CSS：
- en: '[PRE194]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Then, we must change our `button` into a `div` and define the return statement
    for our `render` function with the following code:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将我们的 `button` 改为 `div`，并使用以下代码定义我们的 `render` 函数的返回语句：
- en: '[PRE195]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'In our `src/components/CreateToDoItem.js` file, we must import the CSS with
    the following code:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `src/components/CreateToDoItem.js` 文件中，我们必须使用以下代码导入 CSS：
- en: '[PRE196]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Then, we must change our `button` into a `div` and define the return statement
    for our `render` function with the following code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将我们的 `button` 改为 `div`，并使用以下代码定义我们的 `render` 函数的返回语句：
- en: '[PRE197]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'With this, we have lifted our CSS from our Rust web server into our React application.
    If we run the Rust server and React application, we’ll get the output shown in
    the following figure:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经将我们的 CSS 从 Rust 网络服务器提升到我们的 React 应用程序中。如果我们运行 Rust 服务器和 React 应用程序，我们将得到以下图所示的输出：
- en: '![Figure 5.13 – The view of our React application with CSS added](img/Figure_5.13_B18722.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 添加 CSS 后的我们的 React 应用程序视图](img/Figure_5.13_B18722.jpg)'
- en: Figure 5.13 – The view of our React application with CSS added
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 添加 CSS 后的我们的 React 应用程序视图
- en: And there we have it! Our React application is working. Getting our React application
    up and running takes more time, but we can see that we have more flexibility with
    React. We can also see that our React application is less error-prone because
    we are not having to manually manipulate strings. There is also one more advantage
    for us to build in React, and that is the existing infrastructure. In the next
    and final section, we will convert our React application into a compiled desktop
    application that runs in the applications of the computer by wrapping our React
    application in **Electron**.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就完成了！我们的 React 应用程序正在运行。让我们的 React 应用程序启动并运行需要更多时间，但我们能看到我们在 React 中有更多的灵活性。我们还可以看到，由于我们不需要手动操作字符串，我们的
    React 应用程序更不容易出错。对于我们来说，构建在 React 中的另一个优势是现有的基础设施。在下一节和最后一节中，我们将把我们的 React 应用程序转换为通过将我们的
    React 应用程序包裹在 **Electron** 中来运行的编译后的桌面应用程序。
- en: Converting our React application into a desktop application
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的 React 应用程序转换为桌面应用程序
- en: 'Converting our React application into a desktop application is not complex.
    We are going to use the Electron framework to do so. Electron is a powerful framework
    that converts our JavaScript, HTML, and CSS application into a desktop application
    that is compiled across platforms for macOS, Linux, and Windows. The Electron
    framework can also give us access to the computer’s components via an API such
    as encrypted storage, notifications, power monitor, message ports, processes,
    shell, system preferences, and much more. Desktop applications such as Slack,
    Visual Studio Code, Twitch, Microsoft Teams, and many more are built into Electron.
    To convert our React application, we must start by updating the `package.json`
    file. First, we must update our metadata at the top of our `package.json` file
    with the following code:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的 React 应用程序转换为桌面应用程序并不复杂。我们将使用 Electron 框架来完成这项工作。Electron 是一个强大的框架，可以将我们的
    JavaScript、HTML 和 CSS 应用程序转换为跨平台编译的桌面应用程序，适用于 macOS、Linux 和 Windows。Electron 框架还可以通过
    API（如加密存储、通知、电源监控、消息端口、进程、shell、系统首选项等）为我们提供访问计算机组件的能力。Slack、Visual Studio Code、Twitch、Microsoft
    Teams 等桌面应用程序都是内置在 Electron 中的。为了将我们的 React 应用程序转换为桌面应用程序，我们必须首先更新 `package.json`
    文件。首先，我们必须使用以下代码更新 `package.json` 文件顶部的元数据：
- en: '[PRE198]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Most of this is general metadata. However, the `main` field is essential. This
    is where we will write our file that defines how the Electron application will
    run. Setting the `homepage` field to `"./"` also ensures that the asset paths
    are relative to the `index.html` file. Now that our metadata has been defined,
    we can add the following dependencies:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分是通用元数据。然而，`main` 字段是必不可少的。这是我们编写定义 Electron 应用程序如何运行的文件的所在地。将 `homepage`
    字段设置为 `"./"` 也确保了资源路径相对于 `index.html` 文件是相对的。现在我们的元数据已经定义，我们可以添加以下依赖项：
- en: '[PRE199]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'These dependencies help with building the Electron application. Once they have
    been added, we can redefine our scripts with the following code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖项有助于构建 Electron 应用程序。一旦它们被添加，我们就可以使用以下代码重新定义我们的脚本：
- en: '[PRE200]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Here, we have prefixed all our React scripts with `react`. This is to separate
    the React processes from our Electron processes. If we just want to run our React
    application in dev mode now, we must run the following command:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将所有 React 脚本前缀为 `react`。这是为了将 React 进程与我们的 Electron 进程分开。如果我们现在只想以开发模式运行我们的
    React 应用程序，我们必须运行以下命令：
- en: '[PRE201]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'We have also defined build commands and dev start commands for Electron. These
    will not work yet because we have not defined our Electron file. At the bottom
    of our `package.json` file, we must define our developer dependencies for building
    our Electron application:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了 Electron 的构建命令和开发启动命令。这些目前还不能工作，因为我们还没有定义我们的 Electron 文件。在 `package.json`
    文件的底部，我们必须定义我们的开发者依赖项，以构建我们的 Electron 应用程序：
- en: '[PRE202]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'With that, we have defined all that we need in the `package.json` file. We
    need to install the new dependencies with the following command:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们在 `package.json` 文件中定义了我们所需的所有内容。我们需要使用以下命令安装新的依赖项：
- en: '[PRE203]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Now, we can start building our `front_end/public/electron.js` file so that
    we can build our Electron file. This is essentially boilerplate code, and you
    will probably see this file in other tutorials as this is the minimum to get an
    application running in Electron. First, we must import what we need with the following
    code:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建我们的 `front_end/public/electron.js` 文件，这样我们就可以构建我们的 Electron 文件。这基本上是样板代码，你可能会在其他教程中看到这个文件，因为这是在
    Electron 中运行应用程序所需的最小代码。首先，我们必须使用以下代码导入我们需要的：
- en: '[PRE204]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Then, we must define the function that creates our Desktop window with the
    following code:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须定义以下代码创建我们的桌面窗口的函数：
- en: '[PRE205]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Here, we essentially define the width and height of the window. Also, note
    that `nodeIntegration` and `enableRemoteModule` enable the renderer remote process
    (browser window) to run code on the main process. Then, we start loading the URL
    in the main window. If the run is in developer mode, we merely load `http://localhost:3000`
    as we have the React application running on localhost. If we build our application,
    then the assets and files that we coded get compiled and can be loaded through
    the `../build/index.html` file. We also state that if we are running in developer
    mode, we open the developer tools. We must execute the `createWindow` function
    when the window is ready with the following code:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上定义了窗口的宽度和高度。此外，请注意，`nodeIntegration` 和 `enableRemoteModule` 允许渲染器远程进程（浏览器窗口）在主进程中运行代码。然后，我们开始加载主窗口中的
    URL。如果运行在开发者模式，我们只需加载 `http://localhost:3000`，因为我们已经在本地主机上运行了 React 应用程序。如果我们构建我们的应用程序，那么我们编写的资源和文件将被编译，可以通过
    `../build/index.html` 文件加载。我们还声明，如果我们处于开发者模式，我们将打开开发者工具。当窗口准备好时，我们必须执行以下代码的 `createWindow`
    函数：
- en: '[PRE206]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'If the operating system is macOS, we must keep the program running, even if
    we close the window:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统是 macOS，我们必须保持程序运行，即使我们关闭了窗口：
- en: '[PRE207]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Now, we must run the following command:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须运行以下命令：
- en: '[PRE208]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'This runs the Electron application, giving us the following output:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 Electron 应用程序，给我们以下输出：
- en: '![Figure 5.14 – Our React application running in Electron](img/Figure_5.14_B18722.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 在 Electron 中运行的我们的 React 应用程序](img/Figure_5.14_B18722.jpg)'
- en: Figure 5.14 – Our React application running in Electron
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 在 Electron 中运行的我们的 React 应用程序
- en: 'In *Figure 5**.13*, we can see that our application is running in a window
    on our desktop. We can also see that our application is accessible with the menu
    bar at the top of my screen. The application’s logo is showing on my taskbar:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5**.13* 中，我们可以看到我们的应用程序正在我们的桌面上运行的一个窗口中。我们还可以看到，我们的应用程序可以通过我屏幕顶部的菜单栏访问。应用程序的标志显示在我的任务栏上：
- en: "![Figure 5.15 – Electron on \uFEFFmy taskbar](img/Figure_5.15_B18722.jpg)"
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – Electron 在我的任务栏上](img/Figure_5.15_B18722.jpg)'
- en: Figure 5.15 – Electron on my taskbar
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – Electron 在我的任务栏上
- en: 'The following command will compile our application in the `dist` folder, which,
    if clicked, will install the application onto your computer:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在 `dist` 文件夹中编译我们的应用，如果点击，将应用安装到您的计算机上：
- en: '[PRE209]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The following is an example of this in the applications area on my Mac when
    I used Electron to test out a GUI for the open source package I built called Camel
    for *OasisLMF*:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在我的 Mac 上的应用程序区域中，当我使用 Electron 测试我构建的开源包 Camel（用于 *OasisLMF*）的 GUI 时的一个例子：
- en: '![Figure 5.16 – Our Electron app in the applications area](img/Figure_5.16_B18722.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 我们的应用程序区域中的 Electron 应用](img/Figure_5.16_B18722.jpg)'
- en: Figure 5.16 – Our Electron app in the applications area
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 我们的应用程序区域中的 Electron 应用
- en: Eventually, I will come up with a logo. However, this concludes this chapter
    on displaying content in the browser.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我会想出一个标志。然而，这标志着关于在浏览器中显示内容的这一章的结束。
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have finally enabled our application to be used by a casual
    user as opposed to having to rely on a third-party application such as Postman.
    We defined our own app views module that housed read file and insert functions.
    This resulted in us building a process that loaded an HTML file, inserted data
    from JavaScript and CSS files into the view data, and then served that data.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们最终使我们的应用能够被普通用户使用，而不是依赖于第三方应用，如 Postman。我们定义了自己的应用视图模块，其中包含读取文件和插入功能。这导致我们构建了一个加载
    HTML 文件、从 JavaScript 和 CSS 文件中插入数据到视图数据中，然后提供这些数据的流程。
- en: This gave us a dynamic view that automatically updated when we edited, deleted,
    or created a to-do item. We also explored some basics around CSS and JavaScript
    to make API calls from the frontend and dynamically edit the HTML of certain sections
    of our view. We also managed the styling of the whole view based on the size of
    the window. Note that we did not rely on external crates. This is because we want
    to be able to understand how we can process our HTML data.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个动态视图，当我们编辑、删除或创建待办事项时，它会自动更新。我们还探索了一些关于 CSS 和 JavaScript 的基础知识，以便从前端发出
    API 调用并动态编辑我们视图的某些部分的 HTML。我们还根据窗口大小管理整个视图的样式。请注意，我们没有依赖外部 crate。这是因为我们想要理解我们如何处理我们的
    HTML 数据。
- en: Then, we rebuilt the frontend in React. While this took longer and there were
    more moving parts, the code was more scalable and safer since we didn’t have to
    manually manipulate strings to write HTML components. We can also see why we leaned
    into React as it fits nicely into Electron, giving us another way of delivering
    our application to our users.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 React 重新构建了前端。虽然这花费了更长的时间，并且有更多的组件需要移动，但由于我们不需要手动操作字符串来编写 HTML 组件，代码的可扩展性和安全性更高。我们也可以看到为什么我们选择了
    React，因为它很好地与 Electron 结合，为我们提供了向用户交付应用的另一途径。
- en: While our app now works at face value, it is not scalable in terms of data storage.
    We do not have data filter processes. There are no checks on the data that we
    store, and we do not have multiple tables.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用现在表面上可以工作，但在数据存储方面并不具备可扩展性。我们没有数据过滤过程。我们没有对存储的数据进行检查，并且我们没有多个表格。
- en: In the next chapter, we will build data models that interact with a **PostgreSQL**
    database that runs locally in Docker.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建与运行在 Docker 中的本地 **PostgreSQL** 数据库交互的数据模型。
- en: Questions
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the simplest way to return HTML data to the user’s browser?
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 HTML 数据到用户浏览器的最简单方法是什么？
- en: What is the simplest (not scalable) way to return HTML, CSS, and JavaScript
    data to the user’s browser?
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 HTML、CSS 和 JavaScript 数据到用户浏览器的最简单（不可扩展）方法是什么？
- en: How do we ensure that the background color and style standard of certain elements
    is consistent across all views of the app?
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确保某些元素在应用的所有视图中背景色和样式标准的一致性？
- en: How do we update the HTML after an API call?
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 API 调用后更新 HTML？
- en: How do we enable a button to connect to our backend API?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使按钮连接到我们的后端 API？
- en: Answers
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can serve HTML data by merely defining a string of HTML and putting it in
    the body of an `HttpResponse` struct while defining the content type as HTML.
    The `HttpResponse` struct is then returned to the user’s browser.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过仅定义一个 HTML 字符串并将其放入 `HttpResponse` 结构体的主体中，同时将内容类型定义为 HTML，来提供 HTML 数据。然后，将
    `HttpResponse` 结构体返回给用户的浏览器。
- en: The simplest way is to hardcode a full HTML string with the CSS hardcoded in
    the `<style>` section, and our JavaScript hardcoded in the `<script>` section.
    This string is then put in the body of an `HttpResponse` struct and returned to
    the user’s browser.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的方法是将包含CSS硬编码在`<style>`部分和JavaScript硬编码在`<script>`部分的完整HTML字符串硬编码，然后将该字符串放入`HttpResponse`结构的主体中，并返回给用户的浏览器。
- en: We make a CSS file that defines the components that we want to be consistent
    throughout the app. Then, we put a tag in the `<style>` section of all our HTML
    files. Then, with each file, we load the base CSS file and replace the tag with
    the CSS data.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个CSS文件，定义我们希望在应用程序中保持一致的组件。然后，我们在所有HTML文件的`<style>`部分中放置一个标签。然后，对于每个文件，我们加载基本CSS文件，并用CSS数据替换标签。
- en: After the API call, we must wait for the status to be ready. Then, we get the
    HTML section we want to update using `getElementById`, serialize the response
    data, and then set the inner HTML of the element as the response data.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API调用之后，我们必须等待状态就绪。然后，我们使用`getElementById`获取我们想要更新的HTML部分，序列化响应数据，然后将元素的内部HTML设置为响应数据。
- en: We give the button a unique ID. Then, we add an event listener, which is defined
    by the unique ID. In this event listener, we bind it to a function that gets the
    ID using `this`. In this function, we make an API call to the backend and then
    use the response to update the HTML of other parts of our view that display the
    data.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们给按钮分配一个唯一的ID。然后，我们添加一个由唯一ID定义的事件监听器。在这个事件监听器中，我们将其绑定到一个函数，该函数使用`this`获取ID。在这个函数中，我们向后端发起API调用，然后使用响应来更新我们视图中显示数据的其他部分的HTML。
- en: Further reading
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: '*React and React Native: A complete hands-on guide to modern web and mobile
    development with React.js*, by Adam Boduch and Roy Derks, Packt Publishing'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React和React Native：使用React.js的现代Web和移动开发的完整实战指南*，作者：Adam Boduch和Roy Derks，Packt出版社'
- en: '*Mastering React Test-Driven Development: Build rock-solid, well-tested web
    apps with React, Redux, and GraphQL*, by Daniel Irvine, Packt Publishing'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握React测试驱动开发：使用React、Redux和GraphQL构建坚如磐石、经过良好测试的Web应用*，作者：Daniel Irvine，Packt出版社'
- en: '*Responsive Web De*[*sign with HTML5 and CSS: De*](https://www.electronjs.org/)*velop
    future-proof responsive websites using the latest HTML5 and CSS techniques*, by
    Ben Frain, Packt Publishing'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用HTML5和CSS进行响应式Web设计：使用最新的HTML5和CSS技术开发未来证明的响应式网站*，作者：Ben Frain，Packt出版社'
- en: 'Electron documentation: [https://www.electronjs.org/](https://www.electronjs.org/)'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子文档：[https://www.electronjs.org/](https://www.electronjs.org/)
- en: Part 3:Data Persistence
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：数据持久化
- en: Now that our application handles HTTP requests and displays the content in the
    browser, we need to store and process data properly. In this part, you will learn
    how to manage databases locally in development with Docker and how to perform
    database migrations with SQL scripts. You will also learn how to map the database
    schema to the Rust application, querying and updating the database from Rust.
    After this part, you will be able to manage database connection pools, data models,
    and migrations; log in and authenticate requests with middleware; and cache data
    in the frontend, exploring RESTful concepts.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用程序处理HTTP请求并在浏览器中显示内容，我们需要正确地存储和处理数据。在本部分，你将学习如何在开发中使用Docker本地管理数据库，以及如何使用SQL脚本来执行数据库迁移。你还将学习如何将数据库模式映射到Rust应用程序，从Rust查询和更新数据库。在本部分之后，你将能够管理数据库连接池、数据模型和迁移；使用中间件登录和验证请求；并在前端缓存数据，探索RESTful概念。
- en: 'This part includes the following chapters:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence with PostgreSQL*'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18722_06.xhtml#_idTextAnchor127)，*使用PostgreSQL进行数据持久化*'
- en: '[*Chapter 7*](B18722_07.xhtml#_idTextAnchor149), *Managing User Sessions*'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18722_07.xhtml#_idTextAnchor149)，*管理用户会话*'
- en: '[*Chapter 8*](B18722_08.xhtml#_idTextAnchor168), *Building RESTful Services*'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18722_08.xhtml#_idTextAnchor168)，*构建RESTful服务*'
