- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying Content in the Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now at the stage where we can build a web application that can manage
    a range of HTTP requests with different methods and data. This is useful, especially
    if we are building a server for microservices. However, we also want non-programmers
    to interact with our application to use it. To enable non-programmers to use our
    application, we must create a graphical user interface. However, it must be noted
    that this chapter does not contain much Rust. This is because other languages
    exist to render a graphical user interface. We will mainly use HTML, JavaScript,
    and CSS. These tools are mature and widely used for frontend web development.
    While I personally love Rust (otherwise I wouldn’t be writing a book on it), we
    must use the right tool for the right job. At the time of writing this book, we
    can build a frontend application in Rust using the Yew framework. However, being
    able to fuse more mature tools into our Rust technical stack is a more valuable
    skill.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving HTML, CSS, and JavaScript using Rust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a React application that connects to a Rust server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting our React application into a desktop application to be installed
    on the computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous edition (*Rust Web Programming: A hands-on guide to developing
    fast and secure web apps with the Rust programming language*), we merely served
    frontend assets directly from Rust. However, due to feedback and revision, this
    does not scale well, leading to a lot of repetition. Raw HTML, CSS, and JavaScript
    served directly by Rust were also prone to errors due to the unstructured nature
    of using this approach, which is why, in this second edition, we will cover React
    as well as provide a brief introduction to serving frontend assets directly with
    Rust. By the end of this chapter, you will be able to write basic frontend graphical
    interfaces without any dependencies, as well as understand the trade-offs between
    low-dependency frontend solutions and full frontend frameworks such as React.
    Not only will you understand when to use them but you will also be able to implement
    both approaches as and when they are needed for your project. As a result, you
    will be able to pick the right tool for the right job and build an end-to-end
    product using Rust in the backend and JavaScript in the frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be building on the server code we created in the previous chapter, which
    can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter04/extracting_data_from_views/web_app).
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: We will also be using Node.js to run our React application. Node and npm can
    be installed by carrying out the steps laid out at [https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
  prefs: []
  type: TYPE_NORMAL
- en: Serving HTML, CSS, and JavaScript using Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we returned all our data in the form of JSON. In this
    section, we are going to return HTML data for the user to see. In this HTML data,
    we will have buttons and forms that enable the user to interact with the API endpoints
    that we defined in the previous chapter to create, edit, and delete to-do items.
    To do this, we will need to structure our own `app` views module that takes the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Serving basic HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our `items.rs` file, we will be defining the main view that displays the
    to-do items. However, before we do that, we should explore the simplest way in
    which we can return HTML in the `items.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we simply return an `HttpResponse` struct that has an HTML content type
    and a body of `<h1>Items</h1>`. To pass `HttpResponse` into the app, we must define
    our factory in the `app/views/mod.rs` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that instead of building a service, we merely defined a `route`
    for our application. This is because this is the landing page. If we were going
    to define a `service` instead of a `route`, we would not be able to define the
    views for the service without a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined `app_views_factory`, we can call it in our `views/mod.rs`
    file. However, first, we must define the app module at the top of the `views/mod.rs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the `app` module, we can call the app factory in the `views_factory`
    function within the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our HTML serving view is a part of our app, we can run it and call
    the home URL in our browser, giving us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – First rendered HTML view](img/Figure_5.1_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – First rendered HTML view
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that our HTML rendered! With what we saw in *Figure 5**.1*, we can
    deduce that we can return a string at the body of the response with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This renders the HTML if the string is in HTML format. From this revelation,
    how do you think we can render HTML from HTML files that are served by our Rust
    server? Before moving on, think about this – this will exercise your problem-solving
    abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Reading basic HTML from files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have an HTML file, we can render it by merely readying that HTML file
    to a string and inserting that string into the body of `HttpResponse`. Yes, it
    is that simple. To achieve this, we will build a content loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a basic content loader, start by building an HTML file reading function
    in the `views/app/content_loader.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All we must do here is return a string because this is all we need for the response
    body. Then, we must define the loader in the `views/app/mod.rs` file with the
    `mod content_loader;` line at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a loading function, we need an HTML directory. This can be
    defined alongside the `src` directory called `templates`. Inside the `templates`
    directory, we can add an HTML file called `templates/main.html` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that our `body` tag has the same content that we presented
    previously – that is, `<h1>To Do Items</h1>`. Then, we have a `head` tag that
    defines a range of meta tags. We can see that we define `viewport`. This tells
    the browser how to handle the dimensions and scaling of the page content. Scaling
    is important because our application could be accessed by a range of different
    devices and screen sizes. With this viewport, we can set the width of the page
    to the same width as the device screen. Then, we can set the initial scale of
    the page that we access to `1.0`. Moving on to the `httpEquiv` tag, we set it
    to `X-UA-Compatible`, which means that we support older browsers. The final tag
    is simply a description of the page that can be used by search engines. Our `title`
    tag ensures that `to do app` is displayed on the browser tag. With that, we have
    our standard header title in our body.
  prefs: []
  type: TYPE_NORMAL
- en: Serving basic HTML loaded from files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have defined our HTML file, we must load and serve it. Going back
    to our `src/views/app/items.rs` file, we must load the HTML file and serve it
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our application, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – View from loading the HTML page](img/Figure_5.2_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – View from loading the HTML page
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5**.2*, we can see that we have the same output as before. This is
    not surprising; however, we must notice that the tab in *Figure 5**.2* now states
    **To Do App**, which means that the metadata in our HTML file is being loaded
    into the view. Nothing is stopping us from fully utilizing the HTML file. Now
    that our HTML file is being served, we can move on to our next ambition, which
    is adding functionality to our page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding JavaScript to an HTML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would not be useful to the frontend user if they couldn’t do anything to
    our state for to-do items. Before we amend this, we need to understand the layout
    of an HTML file by looking at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – General layout of an HTML file](img/Figure_5.3_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – General layout of an HTML file
  prefs: []
  type: TYPE_NORMAL
- en: Here, in *Figure 5**.3*, we can see that we can define the meta tags in the
    header. However, we can also see that we can define style tags in the header.
    Within the style tags below the header, we can insert CSS into the style. Below
    the body, there is also a script section where we can inject JavaScript. This
    JavaScript runs in the browser and interacts with elements in the body. With this,
    we can see that serving an HTML file loaded with CSS and JavaScript provides a
    fully functioning frontend single-page app. With this, we can reflect on the introduction
    of this chapter. While I love Rust and feel a strong urge to tell you to write
    everything in it, this is just not a good idea for any language in software engineering.
    The ease with which we can serve functional frontend views with JavaScript now
    makes it the best choice for your frontend needs.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with our server using JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know where to insert the JavaScript into our HTML file, we can
    test our bearings. In the remainder of this section, we are going to create a
    button in the HTML body, fuse it to a JavaScript function, and then get the browser
    to print out an alert with an inputted message when that button is pressed. This
    will do nothing to our backend application, but it will prove that our understanding
    of HTML files is correct. We can add the following code to our `templates/main.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our body section, we can see that we define an `input` and a `button`. We
    give the `input` and `button` properties unique ID names. Then, we use the ID
    of `button` to add an event listener. After that, we bind our `postAlert` function
    to that event listener to be fired when our `button` is clicked. When we fire
    our `postAlert` function, we get `input` by using its ID and print out the value
    of `input` in an alert. Then, we set the value of `input` to `null` to enable
    the user to fill in another value to be processed. Serving our new `main.html`
    file, putting `testing` in `input` and then clicking the button will result in
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The effect of clicking a button when connected to an alert in
    JavaScript](img/Figure_5.4_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The effect of clicking a button when connected to an alert in JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: Our JavaScript does not have to stop with having elements interact in the body.
    We can also use JavaScript to perform API calls to our backend Rust application.
    However, we must stop and think before we rush off and write our entire application
    in our `main.html` file. If we did that, the `main.html` file would balloon into
    a massive file. It would be hard to debug. Also, this could lead to code duplication.
    What if we wanted to use the same JavaScript in other views? We would have to
    copy and paste it into another HTML file. This would not scale well and if we
    need to update a function, we could run the risk of forgetting to update some
    of the duplicated functions. This is where JavaScript frameworks such as React
    come in handy. We will explore React later in this chapter, but for now, we will
    complete our low-dependency frontend by coming up with a way in which we can separate
    our JavaScript from our HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'It must be warned that we are essentially manually rewriting HTML on the fly
    with this JavaScript. People could describe this as a “hacky” solution. However,
    it is important to get to grips with our approach before exploring React to truly
    appreciate the benefits of different approaches. Before we move on to the next
    section, we do have to refactor our `create` view in the `src/views/to_do/create.rs`
    file. This is a good opportunity to revisit what we developed in the previous
    chapters. You must essentially convert the `create` view so that it returns our
    current state of the to-do items as opposed to a string. Once you have attempted
    this, the solution should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, all our to-do items are up to date and functioning. We can now move on
    to the next section, where we will be getting our frontend to make calls to our
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting JavaScript into HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have finished this section, we will have a not-so-pretty but fully
    functional main view where we can add, edit, and delete to-do items using JavaScript
    to make calls to our Rust server. However, as you may recall, we did not add a
    `delete` API endpoint. To inject JavaScript into our HTML, we will have to carry
    out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `delete` item API endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `JavaScript loading` function and replace the JavaScript tag in the HTML
    data with the loaded JavaScript data in the main item Rust view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a JavaScript tag in the HTML file and IDs to the HTML components so that
    we can reference the components in our JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a `rendering` function for our to-do items in JavaScript and bind it to
    our HTML via IDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build an `API call` function in JavaScript to talk to the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `get`, `delete`, `edit`, and `create` functions in JavaScript for
    our buttons to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s have a detailed look at this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the delete endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding the `delete` API endpoint should be straightforward now. If you want
    to, it is advised to try and implement this view by yourself as you should be
    comfortable with this process by now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are struggling, we can achieve this by importing the following third-party
    dependencies into the `views/to_do/delete.rs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are not new, and you should be familiar with them and know where we need
    to utilize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must import our structs and functions with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we are using our `to_do` module to construct our to-do
    items. With our `json_serialization` module, we can see that we are accepting
    `ToDoItem` and returning `ToDoItems`. Then, we execute the deletion of our item
    with the `process_input` function. We also do not want anyone who can visit our
    page to be deleting our items. Therefore, we need our `JwToken` struct. Finally,
    we read the state of our items with the `read_file` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all that we need, we can define our `delete` view with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we have accepted `ToDoItem` as JSON and that we have attached
    `JwToken` for the view so that the user must be authorized to access it. At this
    point, we only have `JwToken` attaching a message; we will manage the authentication
    logic for `JwToken` in [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149), *Managing
    User Sessions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `delete` view, we can get the state of our to-do items by reading
    our JSON file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can check if the item with this title is in the state. If it is not,
    then we return a not found HTTP response. If it is, we then pass on the status
    as we need the title and status to construct the item. We can achieve this checking
    and status extraction with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the status and title of the to-do item, we can construct our
    item and pass it through our `process_input` function with a `delete` command.
    This will delete our item from the JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember, we implemented the `Responder` trait for our `ToDoItems` struct,
    and our `ToDoItems::get_state()` function returns a `ToDoItems` struct populated
    with items from the JSON file. Therefore, we can have the following return statement
    from our `delete` view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that our `delete` view has been defined, we can add it to our `src/views/to_do/mod.rs`
    file, resulting in our view factory that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By quickly inspecting `to_do_views_factory`, we can see that we have all the
    views that we need to manage our to-do items. If we were to eject this module
    out of our application and insert it into another, we would instantly see what
    we were deleting and adding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our `delete` view fully integrated into our application, we can move on
    to the second step, which is building our JavaScript loading functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a JavaScript loading function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that all our endpoints are ready, we must revisit our main app view. In
    the previous section, we established that the JavaScript in the `<script>` section
    works even though it is all just part of one big string. To enable us to put our
    JavaScript into a separate file, our view will load the HTML file as a string
    that has a `{{JAVASCRIPT}}` tag in the `<script>` section of the HTML file. Then,
    we will load the JavaScript file as a string and replace the `{{JAVASCRIPT}}`
    tag with the string from the JavaScript file. Finally, we will return the full
    string in the body in the `views/app/items.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Adding JavaScript tags in the HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From our `items` function in the previous step, we can see that we need to
    build a new directory in the root called `JavaScript`. We must also create a file
    in it called `main.js`. With this change to the app view, we are also going to
    have to change the `templates/main.html` file by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Recall that our endpoints return pending items and completed items. Because
    of this, we have defined both lists with their own titles. `div` with the ID of
    `"doneItems"` is where we will insert the done to-do items from an API call.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will insert our pending items from an API call in `div` with the ID
    of `"pendingItems"`. After that, we must define an input with text and a button.
    This will be for our user to create a new item.
  prefs: []
  type: TYPE_NORMAL
- en: Building a rendering JavaScript function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our HTML has been defined, we are going to define the logic in our
    `javascript/main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function that we are going to build renders all the to-do items on
    our main page. It must be noted that this is the most convoluted part of the code
    in the `javascript/main.js` file. We are essentially writing JavaScript code that
    writes HTML code. Later, in the *Creating a React app* section, we will replace
    the need to do this using the React framework. For now, we will build a render
    function that will create a list of items. Each item takes the following form
    in HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that the title of the to-do item is nested in a paragraph HTML tag.
    Then, we have a button. Recall that the `id` property of an HTML tag must be unique.
    Therefore, we construct this ID based on what the button is going to do on it
    and the title of the to-do item. This will enable us to bind functions performing
    API calls to these `id` properties using event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build our render function, we are going to have to pass in the items to
    be rendered, the process type that we are going to perform (that is, `edit` or
    `delete`), the element ID of the section in the HTML where we are going to render
    these items, and the function that we are going to bind to each to-do item button.
    The outline of this function is defined in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside our `renderItems` function, we can start by constructing HTML and looping
    through our to-do items with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have defined an array that will collect metadata about the to-do items
    HTML that we generate for each to-do item. This is under the `itemsMeta` variable
    and will be used later in the `renderItems` function to bind `processFunction`
    to each to-do item button using event listeners. Then, we define the HTML that
    is housing all our to-do items for a process under the `placeholder` variable.
    Here, we start with a `div` tag. Then, we loop through the items, converting the
    data from each item into HTML, and then finish off the HTML with a closing `div`
    tag. After that, we insert the constructed HTML string known as `placeholder`
    into `innerHTML`. Where `innerHTML` is on the page is where we want to see our
    constructed to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the loop, we must construct the individual to-do item HTML with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we extract the title of the item from the item that we are looping through.
    Then, we define our ID for the item that we are going to use to bind to an event
    listener. Note that we replace all empty spaces with a `-`. Now that we have defined
    the title and ID, we add a `div` with a title to our `placeholder` HTML string.
    We also add a `button` with a `placeholderId` and then finish it off with a `div`.
    We can see that our addition to the HTML string is finished with a `;`. Then,
    we add `placeholderId` and `title` to the `itemsMeta` array to be used later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we loop `itemsMeta`, creating event listeners with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, `processFunction` will fire if a button that we created next to a to-do
    item is clicked. Our function now renders the items, but we need to get them from
    our backend with an API call function. We will look at this now.
  prefs: []
  type: TYPE_NORMAL
- en: Building an API call JavaScript function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our render function, we can look at our API call function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define our API call function in the `javascript/main.js` file.
    This function takes in a URL, which is the endpoint of the API call. It also takes
    a method, which is a string of either `POST`, `GET`, or `PUT`. Then, we must define
    our request object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must define the event listener inside the `apiCall` function that
    renders the to-do items with the JSON returned once the call has finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that we are passing in the IDs that we defined in the `templates/main.html`
    file. We also pass in the response from the API call. We can also see that we
    pass in the `editItem` function, meaning that we are going to fire an `edit` function
    when a button alongside a pending item is clicked, turning the item into a done
    item. Considering this, if a button belonging to a done item is clicked, the `deleteItem`
    function is fired. For now, we will continue building the `apiCall` function.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we must build the `editItem` and `deleteItem` functions. We also
    know that every time the `apiCall` function is called, the items are rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have defined the event listener, we must prep the API call object
    with the method and the URL, define the headers, and then return the request object
    for us to send it whenever we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use our `apiCall` function to perform a call to the backend of our
    application and re-render the frontend with the new state of the items after our
    API call. With this, we can move on to the final step, where we will define our
    functions that perform create, get, delete, and edit functions on our to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Building JavaScript functions for buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that the header is just hardcoding the accepted token that is hardcoded
    in the backend. We will cover how to properly define auth headers in [*Chapter
    7*](B18722_07.xhtml#_idTextAnchor149), *Managing User Sessions*. Now that our
    API call function has been defined, we can move on to the `editItem` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the HTML section that the event listener belongs to can
    be accessed via `this`. We know that if we remove the `edit` word, and switch
    `-` with a space, it will convert the ID of the to-do item into the title of the
    to-do item. Then, we utilize the `apiCall` function to define our endpoint and
    method. Note that we have a space in the `"edit "` string in the `replace` function.
    We have this space because we must remove the space after the edit string as well.
    If we do not remove that space, it will be sent to the backend, causing an error
    since our application backend will not have the space next to the title of the
    item in our JSON file. Once our endpoint and API call method have been defined,
    we pass the title into a dictionary with the status as done. This is because we
    know that we are switching the pending item to done. Once this is done, we send
    the API call with the JSON body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the same approach for the `deleteItem` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, there is a space in the `"delete "` string in the `replace` function.
    With that, our rendering process is fully processed. We have defined edit and
    delete functions and a render function. Now, we must load the items when the page
    is initially loaded without having to click any buttons. This can be done with
    a simple API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we just make an API call with a `GET` method and send
    it. Also, note that our `getItems` function is being called outside of the function.
    This will be fired once when the view has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has been a long stint of coding; however, we are nearly there. We only need
    to define the functionality of the create text input and button. We can manage
    this with a simple event listener and API call for the `create` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also added the detail of setting the text input value to `null`. We
    set `input` to `null` so that the user can input another item to be created without
    having to delete the old item title that was just created. Hitting the main view
    for the app gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Main page with rendered to-do items](img/Figure_5.5_B18722.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Main page with rendered to-do items
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see if our frontend works the way we want it to, we can perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Press the **delete** button next to the **washing** done item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `eat cereal for breakfast` and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `eat ramen for breakfast` and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `eat ramen for` `breakfast` item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps should yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Main page after completing the aforementioned steps](img/Figure_5.6_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Main page after completing the aforementioned steps
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have a fully functioning web app. All the buttons work, and the
    lists are instantly updated. However, it does not look very pretty. There is no
    spacing, and everything is in black and white. To amend this, we need to integrate
    CSS into the HTML file, which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting CSS into HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Injecting CSS takes the same approach as injecting JavaScript. We will have
    a CSS tag in the HTML file that will be replaced with the CSS from the file. To
    achieve this, we must carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add CSS tags to our HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a base CSS file for the whole app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a CSS file for our main view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update our Rust crate to serve the CSS and JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s have a closer look at this process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS tags to HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s make some changes to our `templates/main.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we have two CSS tags. The `{{BASE_CSS}}` tag is for base
    CSS, which will be consistent in multiple different views, such as the background
    color and column ratios, depending on the screen size. The `{{BASE_CSS}}` tag
    is for managing CSS classes for this view. Respectfully, the `css/base.css` and
    `css/main.css` files are made for our views. Also, note that we have put all the
    items in a `div` with a class called `mainContainer`. This will enable us to center
    all the items on the screen. We have also added some more classes so that the
    CSS can reference them, and changed the button for the create item from a `button`
    HTML tag to a `div` HTML tag. Once this is done, our `renderItems` function in
    the `javascript/main.js` file will have the following alteration for the loop
    of the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: With this considered, we can now define our base CSS in our `css/base.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we must define the style of the page and its components. A good place
    to start is by defining the body of the page in the `css/base.css` file. We can
    do a basic configuration of the body with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The background color is a reference to a type of color. This reference might
    not seem like it makes sense just looking at it but there are color pickers online
    where you can see and pick a color and the reference code is supplied. Some code
    editors support this functionality but for some quick reference, simply Google
    `HTML color picker` and you will be spoilt for choice at the number of free online
    interactive tools that will be available. With the preceding configuration, the
    background for the entire page will have a code of `#92a8d1`, which is a navy-blue
    color. If we just had that, most of the page would have a white background. The
    navy-blue background would only be present where there is content. We set the
    height to `100vh`. `vh` is relative to 1% of the height of the viewport. With
    this, we can deduce that `100vh` means the styling we defined in the body occupies
    100% of the viewport. Then, we define the font for all text unless overwritten
    to `Arial`, `Helvetica`, or `sans-serif`. We can see that we have defined multiple
    fonts in `font-family`. This does not mean that all of them are implemented or
    that there are different fonts for different levels of headers or HTML tags. Instead,
    this is a fallback mechanism. First, the browser will try and render `Arial`;
    if it is not supported by the browser, it will then try and render `Helvetica`,
    and if that fails too, it will try and render `sans-serif`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have defined the general style for our body, but what about different
    screen sizes? For instance, if we were going to access our application on our
    phone, it should have different dimensions. We can see this in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Difference in margins between a phone and desktop monitor](img/Figure_5.7_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Difference in margins between a phone and desktop monitor
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.7* shows the ratio of the margin to the space that is filled up
    by the to-do items list changes. With a phone, there is not much screen space,
    so most of the screen needs to be taken up by the to-do item; otherwise, we would
    not be able to read it. However, if we are using a widescreen desktop monitor,
    we no longer need most of the screen for the to-do items. If the ratio was the
    same, the to-do items would be so stretched in the *X*-axis that it would be hard
    to read and frankly would not look good. This is where media queries come in.
    We can have different style conditions based on attributes such as the width and
    height of the window. We will start with the phone specification. So, if the width
    of the screen is up to 500 pixels, in our `css/base.css` file, we must define
    the following CSS configuration for our body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the padding around the edge of the page and each element
    is just one pixel. We also have a grid display. This is where we can define columns
    and rows. However, we do not use it to its full extent. We just have one column.
    This means that our to-do items will take up most of the screen, as shown in the
    phone depiction in *Figure 5**.7*. Even though we are not using a grid in this
    context, I have kept it in so that you can see the relationship this has to the
    other configurations for larger screens. If our screen gets a little bigger, we
    can split our page into three different vertical columns; however, the ratio of
    the width of the middle column to that of the columns on either side is 5:1\.
    This is because our screen is still not very big, and we want our items to still
    take up most of the screen. We can adjust for this by adding another media query
    with different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We can also see that, for our `mainContainer` CSS class where we house our to-do
    items, we will overwrite the `grid-column-start` attribute. If we don’t do this,
    then `mainContainer` would be squeezed in the left margin at `1fr` width. Instead,
    we are starting and finishing in the middle at `5fr`. We can make `mainContainer`
    span across multiple columns with a `grid-column-finish` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our screen gets larger, then we want to adjust the ratios even more as we
    do not want our items width to get out of control. To achieve this, we must define
    a 3 to 1 ratio for the middle column versus the 2 side columns, and then a 1 to
    1 ratio when the screen width gets higher than `1001px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our general CSS for all views, we can move on to our
    view-specific CSS in our `css/main.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CSS for the home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we must break down our app components. We have a list of to-do items.
    Each item in the list will be a `div` that has a different background color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this class has a margin of 0.3\. We are using `rem` because
    we want the margin to scale relative to the font size of the root element. We
    also want our item to slightly change color if our cursor hovers over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside an item container, the title of our item is denoted with a paragraph
    tag. We want to define the style of all the paragraphs in the item containers
    but not elsewhere. We can define the style of the paragraphs in the container
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '`inline-block` allows the title to be displayed alongside `div`, which will
    be acting as the button for the item. The margin definitions merely stop the title
    from being right up against the edge of the item container. We also ensure that
    the paragraph color is white.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our item title styled, the only item styling left is the action button,
    which is either `edit` or `delete`. This action button is going to float to the
    right with a different background color so that we know where to click. To do
    this, we must define our button style with a class, as outlined in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve defined the display, made it float to the right, and defined the
    background color and padding. With this, we can ensure the color changes on hover
    by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have covered all the concepts, we must define the styles for the
    input container. This can be done by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We’ve done it! We have defined all the CSS, JavaScript, and HTML. Before we
    run the app, we need to load the data in the main view.
  prefs: []
  type: TYPE_NORMAL
- en: Serving CSS and JavaScript from Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We serve our CSS in the `views/app/items.rs` file. We do this by reading the
    HTML, JavaScript, base CSS, and main CSS files. Then, we replace our tags in the
    HTML data with the data from the other files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we spin up our server, we will have a fully running app with an intuitive
    frontend that will look like what’s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Main page after CSS](img/Figure_5.8_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Main page after CSS
  prefs: []
  type: TYPE_NORMAL
- en: Even though our app is functioning, and we have configured the base CSS and
    HTML, we may want to have reusable standalone HTML structures that have their
    own CSS. These structures can be injected into views as and when needed. What
    this does is gives us the ability to write a component once, and then import it
    into other HTML files. This, in turn, makes it easier to maintain and ensures
    consistency of the component in multiple views. For instance, if we create an
    information bar at the top of the view, we will want it to have the same styling
    in the rest of the views. Therefore, it makes sense to create an information bar
    once as a component and insert it into other views, as covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we will want to build a component that can be injected into views.
    To do this, we are going to have to load both the CSS and HTML, and then insert
    them into the correct parts of the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can create an `add_component` function that takes the name of
    the component, creates tags from the component name, and loads the HTML and CSS
    based on the component name. We will define this function in the `views/app/content_loader.rs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `read_file` function that is defined in the same file. Then,
    we inject the component HTML and CSS into the view data. Note that we nested our
    components in a `templates/components/` directory. For this instance, we are inserting
    a `header` component, so our `add_component` function will try and load the `header.html`
    and `header.css` files when we pass the header into the `add_component` function.
    In our `templates/components/header.html` file, we must define the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are merely displaying the counts for the number of completed and pending
    to-do items. In our `templates/components/header.css` file, we must define the
    following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `add_component` function to insert our CSS and HTML into the right
    place, we must insert the `HEADER` tag into the `<style>` section of the `templates/main.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all of our HTML and CSS have been defined, we need to import the `add_component`
    function in our `views/app/items.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, we must add the header in the `items` view function, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must alter the `apiCall` function in our `injecting_header/javascript/main.js`
    file to ensure that the header is updated with the to-do item counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have inserted our component, we get the following rendered view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Main page with header](img/Figure_5.9_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Main page with header
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, our header displays the data correctly. If we add the header
    tags to the view HTML file, and we call `add_component` in our view, we will get
    that header.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we have a fully working single-page application. However, this was
    not without difficulty. We can see that our frontend would start to spiral out
    of control if we started to add more features to the frontend. This is where frameworks
    such as React come in. With React, we can structure our code into proper components
    so that we can use them whenever we need to. In the next section, we will create
    a basic React application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a React app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React is a standalone application. Because of this, we will usually have our
    React application in its own GitHub repository. If you want to keep your Rust
    application and React application in the same GitHub repository, that is fine,
    but just make sure that they are in different directories in the root. Once we
    have navigated outside of the Rust web application, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a React application in the `front_end` directory. If we look inside,
    we will see that there are a lot of files. Remember that this book is about web
    programming in Rust. Exploring everything about React is beyond the scope of this
    book. However, a book dedicated to React development is suggested in the *Further
    reading* section. For now, we will focus on the `front_end/package.json` file.
    Our `package.json` file is like our `Cargo.toml` file, where we define dependencies,
    scripts, and other metadata around the application that we are building. Inside
    our `package.json` file, we have the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We can edit this if we want but as it stands, if we run the `npm start` command
    in the directory where our `package.json` file is, we will run the `react-scripts
    start` command. We will run our React application soon, but before this, we must
    edit our `front_end/src/App.js` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Before we break down this code, we must clarify something. If you go on the
    internet, you might come across articles stating that JavaScript is not a class-based
    object-oriented language. This book is not going to take a deep dive into JavaScript.
    Instead, this chapter is designed to give you enough knowledge to get a frontend
    up and running. Hopefully, this chapter is enough to facilitate further reading
    and kickstart your journey if you want to add a frontend to your Rust web application.
    For the sake of this chapter, we will just look at classes and objects that can
    support inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we imported the `component` object from the `react` package.
    Then, we defined an `App` class that inherits the `component` class. The `App`
    class is the main part of our application, and we can treat the `front_end/src/App.js`
    file as our entry point for the frontend application. It is in the `App` class
    that we can define other routes if needed. We can also see that there is a `state`
    belonging to the `App` class. This is the overall memory of the application. We
    must call it `state`; every time the state is updated, the `render` function is
    executed, updating what the component renders to the frontend. This has abstracted
    a lot of what we were doing throughout the previous sections of this chapter when
    our state updated our homemade `render` function. We can see that our state can
    be referenced in the `render` function when returning. This is known as JSX, which
    allows us to write HTML elements directly in JavaScript without any extra methods.
    Now that the basic application has been defined, we can export it to make it available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s navigate to the directory where the `package.json` file is placed and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The React server will spin up and we will get the following view in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – First main view of our React application](img/Figure_5.10_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – First main view of our React application
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the message in our state has been passed into our `render`
    function and then displayed in our browser. Now that our React application is
    running, we can start loading data into our React application using API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Making API calls in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the basic application is running, we can start performing an API call
    to our backend. For this, we will mainly focus on the `front_end/src/App.js` file.
    We can build up our application so that it can populate the frontend with items
    from our Rust application. First we must add the following to the dependencies
    of our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install our extra dependency. Now, we can turn to our `front_end/src/App.js`
    file and import what we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use `Component` for our `App` class inheritance and `axios`
    to perform API calls to our backend. Now, we can define our `App` class and update
    our state with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the same structure as our homemade frontend. This is also the
    data that we return from our get items view in the Rust server. Now that we know
    what data we are going to work with, we can carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function inside our `App` class that gets the functions from the Rust
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that this function is executed when the `App` class is mounted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function inside our `App` class that processes the items that are returned
    from the Rust server into HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function inside our `App` class that renders all the aforementioned
    components to the frontend once we are finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable our Rust server to receive calls from other sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we embark on these steps, we should note that the outline for our `App`
    class will take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can start on the function that makes the API call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `App` class, our `getItems` function takes the following layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we define the URL. Then, we add our token to our header. For now, we
    will just hardcode a simple string because we are not setting up our user sessions
    in the Rust server yet; we will update this in [*Chapter 7*](B18722_07.xhtml#_idTextAnchor149),
    *Managing User Sessions*. Then, we close this. Because `axios.get` is a promise,
    we must use `.then`. The code inside the `.then` brackets is executed when the
    data is returned. Inside these brackets, we extract the data that we need and
    then execute the `this.setState` function. The `this.setState` function updates
    the state of the `App` class. However, executing `this.setState` also executes
    the `render` function of the `App` class, which will update the browser. Inside
    this `this.setState` function, we pass in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have completed `getItems` and we can get items from the backend.
    Now that we have defined it, we must ensure that it gets executed, which we will
    do next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensuring the `getItems` function is fired and thus the state is updated when
    the `App` class is loaded can be achieved with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is straightforward. `getItems` will execute immediately after our `App`
    component is mounted. We are essentially calling `this.setState` in the `componentDidMount`
    function. This triggers the extra rendering before the browser updates the screen.
    Even though `render` is called twice, the user will not see the intermediate state.
    This is one of the many functions that we inherit from the React `Component` class.
    Now that we load the data as soon as the page loads, we can move on to the next
    step: processing the loaded data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `processItemValues` function inside our `App` class, we must take in
    an array of JSON objects that represent items and convert them into HTML, which
    can be achieved with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just loop through the items, converting them into `li` HTML elements
    and adding them to an empty array that is then returned once filled. Remember
    that we use the `processItemValue` function to process the data before it goes
    into the state in the `getItems` function. Now that we have all the HTML components
    in our state, we need to place them on the page with our `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `App` class, the `render` function only returns HTML components. We
    do not employ any extra logic in this. We can return the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our state is directly referenced. This is a lovely change
    from the manual string manipulation that we employed earlier in this chapter.
    Using React is a lot cleaner, reducing the risk of errors. On our frontend, the
    render process with the calls to the backend should work. However, our Rust server
    will block requests from the React application because it is from a different
    application. To fix this, we need to move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, our Rust server will block our requests to the server. This is down
    to `Cargo.toml` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `src/main.rs` file, we must import CORS with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must define CORS policy before the definition of the server and wrap
    the CORS policy right after the views configuration with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: With this, our server is ready to accept requests from our React application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When we defined our CORS policy, we were expressive in that we wanted to allow
    all methods, headers, and origins. However, we can be more concise with the following
    CORS definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`let cors =` `Cors::permissive();`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can test our application to see if it is working. We can do this by
    running our Rust server with Cargo and running our React application in a different
    terminal. Once this is up and running, our React application should look like
    this when loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – The view of our React application when it first talks to our
    Rust server](img/Figure_5.11_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – The view of our React application when it first talks to our Rust
    server
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can see that the call to our Rust application is now working as
    expected. However, all we are doing is listing the names and statuses of the to-do
    items. Where React shines is in building custom components. This means that we
    can build individual classes that have their own states and functions for each
    to-do item. We’ll see this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom components in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we look at our `App` class, we can see that it is useful to have a class
    that has a state and functions that can be utilized to manage how and when HTML
    is rendered to the browser. When it comes to individual to-do items, we could
    use a state and functions. This is because we have a button that gets attributes
    from the to-do item and calls the Rust server to either edit or delete it. In
    this section, we are going to build two components: a `ToDoItem` component in
    the `src/components/ToDoItem.js` file and a `CreateToDoItem` component in the
    `src/components/CreateToDoItem.js` file. Once we have built these, we can plug
    them into our `App` component as our `App` component will get the items’ data
    and loop through these items, creating multiple `ToDoItem` components. There are
    a few steps that we need to process to achieve this, so this section will be split
    into the following subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating our `ToDoItem` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our `CreateToDoItem` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing and managing custom components in our `App` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our ToDoItem component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the simpler `ToDoItem` component in the `src/components/ToDoItem.js`
    file. First, we must import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nothing new. Now that we have imported what we need, we can focus on
    how we define `ToDoItem` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we populate the state with `this.props`, which is the parameter that’s
    passed into the component when the component is constructed. Then, we have the
    following functions for our `ToDoItem` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`processStatus`: This function converts the status of the to-do item, such
    as `PENDING`, into the message on the button, such as `edit`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inverseStatus`: When we have a to-do item with a status of `PENDING` and we
    edit it, we want to convert it into a status of `DONE` so that it can be sent
    to the `edit` endpoint on the Rust server, which is the inverse. Therefore, this
    function creates an inverse of the status that’s passed in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendRequest`: This function sends the request to the Rust server for either
    editing or deleting the to-do item. We can also see that our `sendRequest` function
    is an arrow function. The arrow syntax essentially binds the function to the component
    so that we can reference it in our `render` return statement, allowing the `sendRequest`
    function to be executed when a button that is bound to it is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we know what our functions are supposed to do, we can define our status
    functions with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'This is straightforward and does not need much explanation. Now that our status
    processing functions are done, we can define our `sendRequest` function with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `this.state.button` to define part of the URL as the endpoint changes,
    depending on the button that we are pressing. We can also see that we execute
    the `this.props.passBackResponse` function. This is a function that we pass into
    the `ToDoItem` component. This is because we get the full state of our to-do items
    from the Rust server back after the edit or delete request. We will need to enable
    our `App` component to process the data that has been passed back. Here, we are
    getting a sneak peek of what we are going to be doing in the *Constructing and
    managing custom components in our App component* subsection. Our `App` component
    will have an unexecuted function under the `passBackResponse` parameter that it
    will pass through to our `ToDoItem` component. This function, under the `passBackResponse`
    parameter, will process the new to-do item’s state and render it in the `App`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have configured all our functions. All that is left is to define
    the return of the `render` function, which takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the title of the to-do item is rendered in the paragraph
    tag and that our button executes the `sendRequest` function when clicked. We have
    now finished this component and it is ready to be displayed in our application.
    However, before we do this, we need to build the component that creates to-do
    items in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom components in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our React application is functioning in terms of listing, editing, and deleting
    to-do items. However, we are not able to create any to-do items. This consists
    of an input and a `create` button so that we can put in a to-do item that we can
    then create by clicking the button. In our `src/components/CreateToDoItem.js`
    file, we need to import the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the standard imports to build our components. Once the imports have
    been defined, our `CreateToDoItem` component takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that our `CreateToDoItem` component has the
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createItem`: This function sends a request to the Rust server to create the
    to-do item with the title in the state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleTitleChange`: This function updates the state every time the input is
    updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we explore these two functions, we will flip around the order in which
    we code these functions, and define the return of the `render` function with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the value of the input is `this.state.title`. Also, when
    the input changes, we execute the `this.handleTitleChange` function. Now that
    we have covered the `render` function, there is nothing new to introduce. This
    is a good opportunity for you to look at the outline of our `CreateToDoItem` component
    again and try to define the `createItem` and `handleTitleChange` functions yourself.
    They take a similar form to the functions in the `ToDoItem` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your attempt to define the `createItem` and `handleTitleChange` functions should
    look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have defined both of our custom components. We are now ready to
    move on to the next subsection, where we will manage our custom components.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing and managing custom components in our App component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it was fun creating our custom components, they are not much use if we
    do not use them in our application. In this subsection, we will add some additional
    code to the `src/App.js` file to enable our custom components to be used. First,
    we must import our components with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our components, we can move on to our first alteration. Our
    `App` component’s `processItemValues` function can be defined with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that we loop through the data that we get from the Rust server
    but instead of passing the data into a generic HTML tag, we pass the parameters
    of the to-do item data into our own custom component, which is treated like an
    HTML tag. When it comes to handling our own response with the returned state,
    we can see that it is an arrow function that processes the data and sets the state
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to our `getItems` function. You could do some refactoring
    here if you wanted to reduce the amount of duplicated code. However, to make this
    work, we must define the return statement for the `render` function with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is not much change apart from adding the `createItem`
    component. Running our Rust server and our React application will give us the
    following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The view of our React application with custom components](img/Figure_5.12_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The view of our React application with custom components
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.12* shows that our custom components are rendering. We can click
    on the buttons and, as a result, we will see that all our API calls work and our
    custom components work as they should. Now, all that is standing in our way is
    making our frontend look presentable, which we can do by lifting our CSS into
    the React application.'
  prefs: []
  type: TYPE_NORMAL
- en: Lifting CSS into React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now on the final stretch of making our React application usable. We
    could split up our CSS into multiple different files. However, we are coming to
    the end of this chapter, and going over all the CSS again would unnecessarily
    fill up this chapter with loads of duplicate code. While our HTML and JavaScript
    are different, the CSS is the same. To get it running, we can copy all the CSS
    from the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`templates/components/header.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`css/base.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`css/main.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Copy the CSS files listed here into the `front_end/src/App.css` file. There
    is one change to the CSS, and this is where all the `.body` references should
    be replaced with `.App`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can import our CSS and use it in our app and components. We will also
    have to alter the return HTML in the `render` functions. We can work through all
    three files. For the `src/App.js` file, we must import the CSS with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must add a header and define our `div` tags with the correct classes
    with the following code for the return statement from our `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `src/components/ToDoItem.js` file, we must import the CSS with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must change our `button` into a `div` and define the return statement
    for our `render` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `src/components/CreateToDoItem.js` file, we must import the CSS with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must change our `button` into a `div` and define the return statement
    for our `render` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have lifted our CSS from our Rust web server into our React application.
    If we run the Rust server and React application, we’ll get the output shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – The view of our React application with CSS added](img/Figure_5.13_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – The view of our React application with CSS added
  prefs: []
  type: TYPE_NORMAL
- en: And there we have it! Our React application is working. Getting our React application
    up and running takes more time, but we can see that we have more flexibility with
    React. We can also see that our React application is less error-prone because
    we are not having to manually manipulate strings. There is also one more advantage
    for us to build in React, and that is the existing infrastructure. In the next
    and final section, we will convert our React application into a compiled desktop
    application that runs in the applications of the computer by wrapping our React
    application in **Electron**.
  prefs: []
  type: TYPE_NORMAL
- en: Converting our React application into a desktop application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Converting our React application into a desktop application is not complex.
    We are going to use the Electron framework to do so. Electron is a powerful framework
    that converts our JavaScript, HTML, and CSS application into a desktop application
    that is compiled across platforms for macOS, Linux, and Windows. The Electron
    framework can also give us access to the computer’s components via an API such
    as encrypted storage, notifications, power monitor, message ports, processes,
    shell, system preferences, and much more. Desktop applications such as Slack,
    Visual Studio Code, Twitch, Microsoft Teams, and many more are built into Electron.
    To convert our React application, we must start by updating the `package.json`
    file. First, we must update our metadata at the top of our `package.json` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this is general metadata. However, the `main` field is essential. This
    is where we will write our file that defines how the Electron application will
    run. Setting the `homepage` field to `"./"` also ensures that the asset paths
    are relative to the `index.html` file. Now that our metadata has been defined,
    we can add the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'These dependencies help with building the Electron application. Once they have
    been added, we can redefine our scripts with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have prefixed all our React scripts with `react`. This is to separate
    the React processes from our Electron processes. If we just want to run our React
    application in dev mode now, we must run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also defined build commands and dev start commands for Electron. These
    will not work yet because we have not defined our Electron file. At the bottom
    of our `package.json` file, we must define our developer dependencies for building
    our Electron application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have defined all that we need in the `package.json` file. We
    need to install the new dependencies with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start building our `front_end/public/electron.js` file so that
    we can build our Electron file. This is essentially boilerplate code, and you
    will probably see this file in other tutorials as this is the minimum to get an
    application running in Electron. First, we must import what we need with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must define the function that creates our Desktop window with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we essentially define the width and height of the window. Also, note
    that `nodeIntegration` and `enableRemoteModule` enable the renderer remote process
    (browser window) to run code on the main process. Then, we start loading the URL
    in the main window. If the run is in developer mode, we merely load `http://localhost:3000`
    as we have the React application running on localhost. If we build our application,
    then the assets and files that we coded get compiled and can be loaded through
    the `../build/index.html` file. We also state that if we are running in developer
    mode, we open the developer tools. We must execute the `createWindow` function
    when the window is ready with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'If the operating system is macOS, we must keep the program running, even if
    we close the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs the Electron application, giving us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Our React application running in Electron](img/Figure_5.14_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Our React application running in Electron
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5**.13*, we can see that our application is running in a window
    on our desktop. We can also see that our application is accessible with the menu
    bar at the top of my screen. The application’s logo is showing on my taskbar:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.15 – Electron on \uFEFFmy taskbar](img/Figure_5.15_B18722.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Electron on my taskbar
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will compile our application in the `dist` folder, which,
    if clicked, will install the application onto your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of this in the applications area on my Mac when
    I used Electron to test out a GUI for the open source package I built called Camel
    for *OasisLMF*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Our Electron app in the applications area](img/Figure_5.16_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Our Electron app in the applications area
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, I will come up with a logo. However, this concludes this chapter
    on displaying content in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have finally enabled our application to be used by a casual
    user as opposed to having to rely on a third-party application such as Postman.
    We defined our own app views module that housed read file and insert functions.
    This resulted in us building a process that loaded an HTML file, inserted data
    from JavaScript and CSS files into the view data, and then served that data.
  prefs: []
  type: TYPE_NORMAL
- en: This gave us a dynamic view that automatically updated when we edited, deleted,
    or created a to-do item. We also explored some basics around CSS and JavaScript
    to make API calls from the frontend and dynamically edit the HTML of certain sections
    of our view. We also managed the styling of the whole view based on the size of
    the window. Note that we did not rely on external crates. This is because we want
    to be able to understand how we can process our HTML data.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we rebuilt the frontend in React. While this took longer and there were
    more moving parts, the code was more scalable and safer since we didn’t have to
    manually manipulate strings to write HTML components. We can also see why we leaned
    into React as it fits nicely into Electron, giving us another way of delivering
    our application to our users.
  prefs: []
  type: TYPE_NORMAL
- en: While our app now works at face value, it is not scalable in terms of data storage.
    We do not have data filter processes. There are no checks on the data that we
    store, and we do not have multiple tables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build data models that interact with a **PostgreSQL**
    database that runs locally in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the simplest way to return HTML data to the user’s browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the simplest (not scalable) way to return HTML, CSS, and JavaScript
    data to the user’s browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we ensure that the background color and style standard of certain elements
    is consistent across all views of the app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we update the HTML after an API call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we enable a button to connect to our backend API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can serve HTML data by merely defining a string of HTML and putting it in
    the body of an `HttpResponse` struct while defining the content type as HTML.
    The `HttpResponse` struct is then returned to the user’s browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simplest way is to hardcode a full HTML string with the CSS hardcoded in
    the `<style>` section, and our JavaScript hardcoded in the `<script>` section.
    This string is then put in the body of an `HttpResponse` struct and returned to
    the user’s browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make a CSS file that defines the components that we want to be consistent
    throughout the app. Then, we put a tag in the `<style>` section of all our HTML
    files. Then, with each file, we load the base CSS file and replace the tag with
    the CSS data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the API call, we must wait for the status to be ready. Then, we get the
    HTML section we want to update using `getElementById`, serialize the response
    data, and then set the inner HTML of the element as the response data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We give the button a unique ID. Then, we add an event listener, which is defined
    by the unique ID. In this event listener, we bind it to a function that gets the
    ID using `this`. In this function, we make an API call to the backend and then
    use the response to update the HTML of other parts of our view that display the
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*React and React Native: A complete hands-on guide to modern web and mobile
    development with React.js*, by Adam Boduch and Roy Derks, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering React Test-Driven Development: Build rock-solid, well-tested web
    apps with React, Redux, and GraphQL*, by Daniel Irvine, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Responsive Web De*[*sign with HTML5 and CSS: De*](https://www.electronjs.org/)*velop
    future-proof responsive websites using the latest HTML5 and CSS techniques*, by
    Ben Frain, Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Electron documentation: [https://www.electronjs.org/](https://www.electronjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3:Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our application handles HTTP requests and displays the content in the
    browser, we need to store and process data properly. In this part, you will learn
    how to manage databases locally in development with Docker and how to perform
    database migrations with SQL scripts. You will also learn how to map the database
    schema to the Rust application, querying and updating the database from Rust.
    After this part, you will be able to manage database connection pools, data models,
    and migrations; log in and authenticate requests with middleware; and cache data
    in the frontend, exploring RESTful concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18722_06.xhtml#_idTextAnchor127), *Data Persistence with PostgreSQL*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18722_07.xhtml#_idTextAnchor149), *Managing User Sessions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18722_08.xhtml#_idTextAnchor168), *Building RESTful Services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
