- en: Developing a Microservice with the Hyper Crate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide a short introduction to creating microservices using
    Rust the and `hyper` crate. We will look at the basics of the HTTP protocol and
    the principles of routing. We'll also describe a minimal REST service written completely with
    Rust, using a simple method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `hyper`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions for routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting parameters from the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because we''re starting to write code in this chapter, you''ll need to have
    certain software in order to compile and run examples:'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend you use the `rustup` tool, which will keep your Rust instance up
    to date. If you don't have this tool, you can get it from [https://rustup.rs/](https://rustup.rs/).
    When it's installed, run the `rustup update` command to update the current installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Rust compiler, at least version 1.31.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hyper` crate, which we'll use to compile the code, requires the OpenSSL
    ([https://www.openssl.org/](https://www.openssl.org/)) library. The most popular
    operating systems already include the OpenSSL package and you can follow the manual
    of your package manager to install it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get the examples shown in this chapter from GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Binding a Tiny Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a Tiny Server from scratch. We'll start with the
    necessary dependencies, declare a main function, and then try to build and run
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding necessary dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to create a new folder where we''ll add the necessary dependencies
    to create our first microservice. Use `cargo` to make a new project called `hyper-microservice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the created folder and add dependencies to your `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The single dependency is the `hyper` crate. The latest release of this crate
    is asynchronous and lies on top of the `futures` crate. It also uses the `tokio`
    crate for runtime, which includes the scheduler, reactor, and asynchronous sockets.
    Some of the necessary types of the `tokio` crate are re-exported in the `hyper::rt`
    module. The main purpose of `hyper` is to operate with the HTTP protocol, which
    means that the crate can support other runtimes in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The main function of the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the main function and add the necessary dependencies one
    by one, looking in detail at why we need each one. A minimal HTTP server needs
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An address to bind to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `server` instance to handle incoming requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default handler for any request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reactor (runtime) where the `server` instance will operate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address of the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need is an address. A socket address consists of an IP address
    and a port number. We'll use IPv4 in this book because it's widely supported.
    In [Chapter 6](fd4bf12a-bb05-469b-a230-163cee412261.xhtml), *Reactive Microservices –
    Increasing Capacity and Performance,* where we'll discuss scaling and the intercommunication
    of microservices, I'll show a few examples using IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard Rust library contains an `IpAddr` type to represent the IP address.
    We''ll use the `SocketAddr` struct, which contains both the `IpAddr` and the `u16`
    for the port number. We can construct the `SocketAddr` from a tuple of the `([u8;
    4], u16)` type. Add the following code to our main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We used an implementation of the `impl<I: Into<IpAddr>> From<(I, u16)> for
    SocketAddr` trait here, which, in turn, uses `impl From<[u8; 4]> for IpAddr`.
    This lets us use the `.into()` method call to construct a socket address from
    the tuple. Similarly, we can create new `SocketAddr` instances with a constructor.
    In production applications, we will parse the socket addresses from external strings
    (command-line parameters or environment variables), and if no variants are set,
    we''ll create `SocketAddr` from a tuple with default values.'
  prefs: []
  type: TYPE_NORMAL
- en: Server instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can create a `server` instance and bind to this address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line creates a `hyper::server::Server` instance with a `bind`
    constructor that actually returns `Builder`, not a `Server` instance. The `Server`
    struct implements the `Future` trait. It has similar role to `Result`, but describes
    a value that isn't available immediately. You'll learn more about `Future` and
    other traits of the `futures` crate in [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml),
    *Understanding Asynchronous Operations with the Futures Crate*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the requests handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Builder` struct provides methods to tweak the parameters of the `server` created.
    For example, hyper''s `server` supports both `HTTP1` and `HTTP2`. You can use
    a `builder` value to choose either one protocol or both. In the following example,
    we''re using `builder` to attach a service for handling incoming HTTP requests
    using the `serve` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using the builder instance to attach a function that generates a
    `Service` instance. This function implements the `hyper::service::NewService`
    trait. The generated item then has to implement the `hyper::service::Service`
    trait. A service in a `hyper` crate is a function that takes a request and gives
    a response back. We haven't implemented this trait in this example; instead, we'll
    use the `service_fn_ok` function, which turns a function with suitable types into
    a service handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two corresponding structs: `hyper::Request` and `hyper::Response`.
    In the preceding code, we ignored a request argument and constructed the same
    response for every request. The response contains a body of static text.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the server instance to a runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we now have a handler, we can start the server. The runtime expects a
    `Future` instance with the `Future<Item = (), Error = ()>` type, but the `Server`
    struct implements a `Future` with the `hyper::Error` error type. We can use this
    error to inform the user about issues, but in our example we''ll just drop any
    error. As you might remember, the drop function expects a single argument of any
    type and returns a `unit` empty type. The `Future` trait uses the `map_err` method. It
    changes the error type using a function, which expects the original error type
    and returns a new one. Drop an error from the `server` using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need and can start the `server` with the specific
    runtime. Use the `hyper::rt::run` function to start the `server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t compile it yet, because we haven''t imported types. Add it to the head
    of a source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to import the different `hyper` types that we are using: `Server`,
    `Response`, and `Body`. In the final line, we''re using the `service_fn_ok` function.
    The `Future` import needs special attention; it''s the re-exported trait of the `futures`
    crate and it''s used everywhere in the `hyper` crate. In the next chapter, we''ll
    examine this trait in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Building and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can now compile the code and start the server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your browser to connect to the server. Enter [http://localhost:8080/](http://localhost:8080/) in
    the browser''s address bar and the browser will connect to your server and show
    you a page with the text you entered in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f86b61f1-bd9e-4751-8bca-fcf2182ad351.png)'
  prefs: []
  type: TYPE_IMG
- en: Rebuilding on changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're working on developing web servers, it's useful to have instant access
    to compiled and running applications. It's tiresome to have to restart `cargo
    run` manually whenever you change the code. I recommend that you install and use
    the `cargo-watch` subcommand on `cargo`. This will monitor the changes made to
    the files of your project and restart the other commands you have chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `cargo-watch`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `run` command with `watch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can add extra arguments to the `run` command between quotes or add extra
    arguments after the `--` characters.
  prefs: []
  type: TYPE_NORMAL
- en: Handling incoming requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created a server, but it isn't very useful until it can respond to real
    requests. In this section, we'll add handlers to the requests and use the principles
    of REST.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a service function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we implemented simple services based on `service_fn_ok`
    functions, which expect the service function not to throw any errors. There are
    also `service_fn` functions, which can be used to create handlers that can return
    an error. These are more suitable for asynchronous `Future` results. As we saw
    previously, the `Future` trait has two associated types: one for a successful
    result and one for an error. The `service_fn` function expects the result to be
    converted into future with the `IntoFuture` trait. You can read more about the `futures`
    crate and its types in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the previous service function into one that returns the `Future`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add this unimplemented service function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the previous one, this function expects a `Request`, but it doesn''t
    return a simple `Response` instance. Instead, it returns a future result. Since
    `Future` is a trait (which doesn''t have a size), we can''t return an unsized
    entity from the function and we have to wrap it in a `Box`. However, in this case,
    we used a brand new approach, which is the `impl` trait. This allows us to return
    an implementation of the trait by value, rather than by reference. Our `future`
    can be resolved to a `hyper::Response<Body>` item or a `hyper::Error` error type.
    You should import the necessary types if you''ve started a project from scratch
    and aren''t using the code examples included with this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also imported the `Future` trait from the `futures` crate. Make sure you''re
    either using `edition = "2018"` in the `Cargo.toml` file, or importing the crates
    in `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We started by importing the types to the code, but we still have to import
    the crates in the `Cargo.toml` file.  Add these crates in the dependency list
    of your `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Everything is now ready to implement a service handler.
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to order dependencies from generic to more specific. Alternatively,
    you can use alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a service function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our service function will support two kinds of requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` requests to the `/` path with an index page response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other requests with a `NOT_FOUND` response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To detect the corresponding method and path, we can use the methods of the `Request`
    object. See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I used a `match` expression to detect the corresponding method returned from
    the `req.method()`  function, and also the path of the URI of the `Request` returned
    by the `req.uri().path()` method's chain call.
  prefs: []
  type: TYPE_NORMAL
- en: The `method()` function returns a reference to the `Method` instance. `Method`
    is an enumeration that contains all supported HTTP methods. Instead of other popular
    languages, which return strings for methods, Rust uses a strict set of methods
    from a finite enumeration. This helps to detect typos during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Future` instances created with the `future::ok` function are also returned.
    This function immediately resolves the future to a successful result with an item
    of the corresponding type. This is useful for static values; we don't need to
    wait to create them.
  prefs: []
  type: TYPE_NORMAL
- en: The future object is a long operation that won't return a result immediately.
    The runtime will poll the future until it returns the result. It's useful to perform
    asynchronous requests on a database. We'll do this in [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml),
    *Reliable Integration with Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: We can also return streams instead of a whole result. The `futures` crate contains
    a `Stream` trait for those cases. We'll look at this further in [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml),
    *Understanding Asynchronous Operations with the Futures Crate*.
  prefs: []
  type: TYPE_NORMAL
- en: In our match expression, we used  `Method::GET` and the `"/"` path to detect
    requests of the index page. In this case, we'll return a `Response` that constructs
    a `new` function and an HTML string as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: In case no pages were found that match the `_` pattern, we'll return a response
    with the `NOT_FOUND` status code from the `StateCode` enumeration. This contains
    all of the status codes of the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `body` method to construct the response, and we used an empty `Body`
    as an argument for that function. To check that we haven't used it before, we
    use `unwrap` to unpack the `Response` from the `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: Index pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need is an index page. It's considered good form to return
    some information about a microservice when requested, but you may hide it for
    security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our index page is a simple string with HTML content inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a constant value that can't be modified. Рay attention to the start
    of the string, `r#"`, if you haven't used it before. This is a kind of multiline
    string in Rust that has to end with `"#`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can compile the code and view the pages with a browser. I opened Developer
    Tools to show the status codes of the requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee617eec-f560-40cc-9c47-7c5b5b7d1193.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you try to get a nonexistent resource, you''ll get a `404` status code,
    which we set with the `StatusCode::NOT_FOUND` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddae2db0-0394-4eb1-a2cf-69d26e7c669b.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the REST principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If everyone were to create rules of interaction with microservices from scratch,
    we'd have an excess of private standards of intercommunication. REST isn't a strict
    set of rules, but it's an architectural style intended to make interacting with
    microservices simple. It provides a suggested set of HTTP methods to create, read,
    update, and delete data; and perform actions. We'll add methods to our service
    and fit them to REST principles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a shared state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have already heard that shared data is a bad thing and a potential cause
    of bottlenecks, if it has to be changed from separate threads. However, shared
    data can be useful if we want to share the address of a channel or if we don't
    need frequent access to it. In this section, we need a user database. In the following
    example, I'll show you how to add a shared state to our generator function. This
    approach can be used for a variety of reasons, such as keeping a connection to
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user database will obviously hold data about users. Let''s add some types
    to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`UserId` represents the user''s unique identifier. `UserData` represents the
    stored data, but we use an empty struct for serialization and parsing streams
    in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our database will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Arc` is an atomic reference counter that provides multiple references to a
    single instance of data (in our case, this is the `Mutex` over the slab of data).
    Atomic entities can be safely used with multiple threads. It uses native atomic
    operations to prohibit the cloning of the reference. This is because two or more
    threads can corrupt the reference counter and can cause segmentation faults, leading
    to data loss or a memory leak if the counter was greater than the references in
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mutex` is a mutual-exclusion wrapper that controls access to mutable data.
    `Mutex` is an atomic flag that checks that only one thread has access to the data
    and other threads have to wait until the thread that has locked the mutex releases
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: You have take into account that if you have a locked `Mutex` in one thread and
    that thread panics, the `Mutex` instance become poisoned, and if you try to lock
    it from another thread, you'll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we reviewed these types if the asynchronous server
    can work in a single thread. There are two reasons. First, you may need to run
    the server in multiple threads for scaling. Second, all types that provide interaction
    facilities, such as Sender objects (from a standard library, a `futures` crate,
    or anywhere else) or database connections, are often wrapped with these types
    to make them compatible with a multithreading environment. It can be useful to
    know what's going on under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: You might be familiar with standard library types, but `Slab` may seem a little
    different. This type can be thought of as a silver bullet in web-server development.
    Most pools use this appliance. Slab is an allocator that can store and remove
    any value identified by an ordered number. It can also reuse the slots of removed
    items. It's similar to the  `Vec` type, which won't resize if you remove the element,
    but will reuse free space automatically. For servers, it's useful to keep connections
    or requests, such as in the JSON-RPC protocol implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we use `Slab` to allocate new IDs for users and to keep the data
    with the user. We use `Arc` with the `Mutex` pair to protect our database of data
    race, because different responses can be processed in different threads, which
    can both try to access the database. In fact, Rust won't let you compile the code
    without these wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to add an extra dependency, because the `Slab` type is available in
    the external `slab` crate. Add this using `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Import these necessary types in the `main.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's write a handler and a `main` function in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a shared state from a service function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get access to a shared state, you need to provide a reference to the shared
    data. This is simple, because we've already wrapped our state with `Arc`, which
    provides us with a `clone()` function to duplicate the reference to the shared
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our service function needs extra parameters, we have to rewrite the definition
    and call our `microservice_handler` function. Now it has an extra argument, which
    is the reference to the shared state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to send this expected reference to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created a `Slab` and wrapped it with `Mutex` and `Arc`. After
    that, we  moved the object, called `user_db`, into the `serve` function call of
    the `server` builder that's using the `move` keyword. When the reference moves
    into the closure, we can send it to `microservice_handler`. This is a handler
    function called by a closure sent to the `service_fn` call. We have to clone the
    reference to move it to a nested closure, because that closure can be called multiple
    times. We shouldn't move the object completely, however, because a closure sent
    to the `serve` function can be called multiple times and so the runtime might
    need the object again later.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, both closures can be called multiple times. The closure of `service_fn`
    will be called in the same thread as the runtime, and we can use a reference for
    the value inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing paths in a microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common task in web development is to use functions that work with persistent
    storage. These functions are often called **create**, **read**, **update**, **and
    delete** (**CRUD**) functions. They are the most common operations with data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement a CRUD set for our service, but first we have to identify
    the entity that we want to work with. Imagine that we need three types of entities:
    users, articles, and comments. In this case, I recommend that you separate the
    microservices, because the users microservice is responsible for identity, the
    articles microservice is responsible for the content, and the comments microservice
    handles content. However, you would get more benefits if you could reuse these
    entities for more than one context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement all the handlers, we need a helper function that creates
    empty responses with the corresponding HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function carries out a few simple actions – it expects a status code, creates
    a new response builder, sets that status, and adds an empty body.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a new request handler that checks three path variants:'
  prefs: []
  type: TYPE_NORMAL
- en: The index page (path `/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions with user data (prefix `/user/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `match` expression to fulfill all of these cases. Add the following
    code to the `microservices_handler` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used an `if` expression in the second branch to detect that
    the path starts with the `/user/` prefix. This prefix is actually stored in the `USER_PATH`
    constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous example, in this case we'll use our brand new `response_with_code` function
    to return a `NOT_FOUND` HTTP response. We also assign a response to the `response`
    variable and use it to create a `Future` instance with the `future::ok` function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing REST methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our microservices can already distinguish between different paths. All that's
    left is to implement request handling for the users' data. All incoming requests
    have to contain the `/user/` prefix in their paths.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the user's identifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To modify a specific user, we need their identifier. REST specifies that you
    need to get the IDs from a path, because REST maps data entities to URLs.
  prefs: []
  type: TYPE_NORMAL
- en: We can extract a user's identifier using the tail of the path, which we already
    have. This is  why we use the `starts_with` method of the string, instead of checking
    for strong equality with `USER_PATH` to the path tails.
  prefs: []
  type: TYPE_NORMAL
- en: 'We previously declared the `UserId` type, which equals the `u64` unsigned number.
    Add this code to the second branch of the previously-declared `match` expression
    with the `(method, path)` pattern to extract the user''s identifier from the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `str::trim_left_matches` method removes the part of the string if it matches
    a provided string from the argument. After that, we use the `str::parse` method,
    which tries to convert a string (the remaining tail) to a type that implements
    the `FromStr` trait of the standard library. `UserId` already implements this,
    because it's equal to the `u64` type, which can be parsed from the string.
  prefs: []
  type: TYPE_NORMAL
- en: The parse method returns `Result`. We convert this to an `Option` instance with
    `Result::ok` functions. We won't try to handle errors with the IDs. The `None`
    value represents either the absence of a value or a wrong value.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use a map of the returned `Option` instance to convert a value to
    the `usize` type. This is because `Slab` uses `usize` for IDs, but the real size
    of the `usize` type depends on the platform architecture, which can be different.
    It can be `u32` or `u64` depending on the largest memory address that you can
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Why can't we use `usize` for `UserId` since it implements the `FromStr` trait?
    This is because a client expects the same behavior as an HTTP server, which doesn't
    depend on the architecture platform. It's bad practice to use unpredictable size
    parameters in HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it can be difficult to choose a type to identify the data. We use
    `map` to convert the `u64` value to `usize`. This doesn't work, however, for architectures
    where `usize` equals `u32`, because `UserId` can be larger than the memory limit.
    It's safe in cases where the microservices are tiny, but this is an important
    point to bear in mind for microservices that you'll use in production. Often,
    this problem will be simple to solve, because you can use the ID type of a database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting access to the shared data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this user handler, we need access to a database with users. Because the database
    is a `Slab` instance that's wrapped with a `Mutex` instance, we have to lock the
    mutex to have exclusive access to a slab. There's a `Mutex::lock` function that
    returns `Result<MutexGuard, PoisonError<MutexGuard>>`. `MutexGuard` is a scoped
    lock, which means it leaves the code block or scope in, and it implements the `Deref`
    and `DerefMut` traits to provide transparent access to data under the guard object.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a good practice to report all errors in the handler. You can log errors
    and return a `500` (Internal Error) HTTP code to the client. To keep it simple,
    we''ll use an `unwrap` method and expect the mutex to lock correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we locked the `Mutex` for the duration of generating the request. In this
    case, where we're creating whole responses immediately, this is normal. In cases
    where the result is delayed or when we work with a stream, we shouldn't lock the
    mutex all time. This will create a bottleneck for all requests because the `server`
    can't process requests in parallel if all of them depend on a single shared object.
    For cases where you don't have results immediately, you can clone the reference
    to the mutex and lock it for the short time you need access to the data.
  prefs: []
  type: TYPE_NORMAL
- en: REST methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to cover all basic CRUD operations. Using the principles of REST, there
    are suitable HTTP methods that fit these operations—`POST`, `GET`, `PUT`, and
    `DELETE`. We can use the `match` expression to detect the corresponding HTTP method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used a tuple with two values—a method and a user identifier, which
    is represented by the `Option<UserId>` type. There is a default branch that returns
    the `METHOD_NOT_ALLOWED` message (the 405 HTTP status code) if a client requests
    an unsupported method.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss every branch of match expression for every operation.
  prefs: []
  type: TYPE_NORMAL
- en: POST – Creating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `server` has just started, it doesn''t contain any data. To support
    data creation, we use the `POST` method without the user''s ID. Add the following
    branch to the `match (method, user_id)` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a `UserData` instance to the user database and sends the associated
    ID of the user in a response with the `OK` status (an HTTP status code of 200).
    This code was set by the `Response::new` function by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`UserData` is an empty struct in this case. In real applications, however,
    it would have to contain real data. We use an empty struct to avoid serialization,
    but you can read more about serialization and deserialization based on the `serde`
    crate in [Chapter 4](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml), *Data Serialization
    and Deserialization with the Serde Crate*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if the client sets the ID with a `POST` request? You can interpret this
    case in two ways—ignore it or try to use the provided ID. In our example, we''ll
    inform the client that the request was wrong. Add the following branch to handle
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code returns a response with the `BAD_REQUEST` status code (a `400` HTTP
    status code).
  prefs: []
  type: TYPE_NORMAL
- en: GET – Reading data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When data is created, we need to be able to read it. For this case, we can
    use the HTTP `GET` method. Add the following branch to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the user database to try to find the user by the ID that's provided
    in the path. If the user is found, we'll convert its data to a `String` and into
    a `Body` to send with a `Response`.
  prefs: []
  type: TYPE_NORMAL
- en: If the user isn't found, the handler branch will respond with the `NOT_FOUND`
    status code (the classic `404` error).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the `UserData` convertible to a `String`, we have to implement the `ToString`
    trait for that type. However, it''s typically more useful to implement the `Display`
    trait, because `ToString` will be derived automatically for every type that implements
    the `Display` trait. Add this code somewhere in the `main.rs` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we return a string with an empty JSON object `"{}"`.
    Real microservices have to use the `serde` trait for such conversions.
  prefs: []
  type: TYPE_NORMAL
- en: PUT – Updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the data is saved, we might want to provide the ability to modify it.
    This is a task for the `PUT` method. Use this method to handle changes to the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code tries to find a `user` instance in the user database with the `get_mut`
    method. This returns a mutable reference wrapped with either a `Some` option,
    or a `None` option if the corresponding value isn't found. We can use a dereference
    operator, `*`, to replace the data in the storage.
  prefs: []
  type: TYPE_NORMAL
- en: If the user's data was found and replaced, the branch returns an `OK` status
    code. If there's no user with the requested ID, the branch returns `NOT_FOUND`.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE – Deleting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we don''t need data anymore, we can delete it. This is the purpose of
    the `DELETE` method. Use it in the branch as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code checks whether the `Slab` contains the data and removes it with the
    `remove` method. We don't use the `remove` method right away because this expects
    the data to exist in the storage beforehand, and therefore panics if the data
    is absent.
  prefs: []
  type: TYPE_NORMAL
- en: Often, web services don't actually remove data and instead just mark it as deleted.
    This is a reasonable thing to do because it allows you to explore the data later
    and improve the efficiency of the service or the company. However, this is a risky
    practice. Users should be able to remove their data completely, because sensitive
    data can represent a threat. New laws, such as the GDPR law ([https://en.wikipedia.org/wiki/General_Data_Protection_Regulation](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation)),
    protect the user's right to own their data and stipulate certain requirements
    for data protection. Violation of such laws may result in a fine. It's important
    to remember this when you work with sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Routing advanced requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we used pattern matching to detect the destination
    of a request. This isn''t a flexible technique, because the path often contains
    extra characters that have to be taken into account. The `/user/1/` path, for
    example, contains the trailing slash, ***`/`*** , which can''t be parsed with
    a user ID in the previous version of our microservice. There''s a flexible tool
    to fix this issue: regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining paths with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A regular expression is a sequence of characters that express a pattern to
    be searched for in a string. Regular expressions provide you with the ability
    to create tiny parsers that split a text into parts using a formal declaration.
    Rust has a crate called `regex`, a popular abbreviation of *regular expression
    collocation*. You can learn more about this crate here: [https://crates.io/crates/regex](https://crates.io/crates/regex).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the necessary dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use regular expressions in our `server`, we need two crates: `regex` and
    `lazy_static`. The first provides a `Regex` type to create and match regular expressions
    with strings. The second helps to store `Regex` instances in a static context.
    We can assign constant values to static variables, because they''re created when
    a program loads to memory. To use complex expressions, we have to add an initialization
    code and use it to execute expressions, assigning the result to a static variable.
    The `lazy_static` crate contains a `lazy_static!` macro to do this job for us
    automatically. This macro creates a static variable, executes an expression, and
    assigns the evaluated value to that variable. We can also create a regular expression
    object for every request in a local context using a local variable, rather than
    a static one. However, this takes up runtime overhead, so it''s better to create
    it in advance and reuse it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add both dependencies to the `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two imports, in addition to the imports in the `main.rs` source file from
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the `lazy_static` macro and the `Regex` type to construct a regular
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Writing regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions contain a special language, used to write a pattern to
    extract data from a string. We need three patterns for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: A path for the index page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path for user management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path for the list of users (a new feature for our example server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s a `Regex::new` function that creates regular expressions. Remove the
    previous `USER_PATH` constant and add three new regular expression constants in
    a lazy static block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, regular expressions look complex. To understand them better,
    let's analyze them.
  prefs: []
  type: TYPE_NORMAL
- en: Path for index page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `INDEX_PATH` expression matches the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '*`/`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*`/index.htm`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*`/index.html`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression that fits these paths is `"^/(index\\.html?)?$"`.
  prefs: []
  type: TYPE_NORMAL
- en: The `^` symbol means there must be a string beginning, while the `$` symbol
    means there must be a string ending. When we place these symbols on either side,
    we prevent all prefixes and suffixes in the path and expect exact matching.
  prefs: []
  type: TYPE_NORMAL
- en: The `( )` brackets implies there must be a group. An expression in a group is
    treated as an indivisible unit.
  prefs: []
  type: TYPE_NORMAL
- en: The `?` symbol means that the previous character is optional. We place it after
    the `l` character to allow the file in the path to have both `.htm` and `.html`extensions.
    As you'll see later, we don't have an index file to read. We use it as an alias
    of the root path handler. The question mark is also used after a whole group with
    a file name to fit the empty root path, *`/`*.
  prefs: []
  type: TYPE_NORMAL
- en: The  dot symbol (`.`) fits any character, but we need a real dot symbol. To
    treat a dot as a symbol, we have to add a backslash (`\`) before it. A single
    backslash, however, will be interpreted as a beginning-of-escape expression, so
    we have to use pair of backslashes (`\\`) to make the backslash a plain symbol.
  prefs: []
  type: TYPE_NORMAL
- en: All other characters are treated as is, including the `/` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Path for user management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `USER_PATH` expression can fit the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/user/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/<id>`, where `<id>` means group of digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/<id>/`, the same as the previous one, but with a trailing backslash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These cases can be handled with the `"^/user/((?P<user_id>\\d+?)/?)?$"` regular
    expression. This expression is a bit complex. It includes two groups (one is nested)
    and some other strange characters. Let's have a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: '`?P<name>` is a grouping attribute that sets the name of the capturing group.
    Every group in brackets can be accessed by the `regex::Captures` object. Named
    groups can be accessed by names.'
  prefs: []
  type: TYPE_NORMAL
- en: '`\\d` is a special expression that matches any digit. To specify that we have
    one or more digits, we should add the `+` symbol, which tells us how many repetitions
    it may have. The `*` symbol can also be added, which tells us that there are zero
    or more repetitions, but we haven''t used this in our regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two groups. The first is nested with the name `user_id`. It must include
    digits only to be parsed to the `UserId` type. The second is an enclosing group
    that contains the optional trailing slash. This whole group is optional, meaning
    that the expression can include a `/user/` path without any identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Path for the users list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `USERS_PATH` is a new pattern, which we didn''t have in the previous example.
    We''ll use it to return a full list of users on the `server`. This pattern fits
    only two variants of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/users/`  (with a trailing slash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users` (without a trailing slash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regular expression to handle these cases is quite simple: `"^/users/?$"`.
    We've already seen all the symbols in this pattern. It expects a string to begin
    with the `^` symbol and the slash symbol. After that, it expects `users` with
    an optional slash at the tail `/?`. Finally, it expects the end of a string with
    the `$` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Matching expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to reorganize the code of `microservice_handler` because we can''t
    use regular expressions in a `match` expression. We have to extract the method
    with the path at the start, because we need it for most responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we''ll check is the index page requests. Add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `INDEX_PATH` regular expression to check whether the request's
    path matches the index page request using the `Regex::is_match` method, which
    returns a `bool` value. Here, we're checking the method of a request, so only `GET` is
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then continue the `if` clause with an alternative condition for the
    user list request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `USERS_PATH` pattern to check whether the client requested
    the list of users. This is a new path route. After this, we iterate over all the
    users in the database and join their IDs in a single string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to handle REST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `USER_PATH` and the `Regex::captures` method. It returns
    a `Captures` object with the values of all captured groups. If the pattern doesn't
    match the method, it returns a `None` value. If the pattern does match, we get
    an object stored in the `cap` variable. The `Captures` struct has the `name` method
    to get a captured value by name. We use the `user_id` as the name of the group.
    This group can be optional and the `name` method returns an `Option`. We use the `and_then`
    method of the `Option` to replace it with the parsed `UserId`. Finally, the `user_id`
    variable takes the `Option<UserId>` value, in the same way as the previous version
    of our microservice. To avoid repetition, I skipped the block where the request
    is the same as the (`method`, `user_id`) tuple – just copy this part from the
    example in the previous section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is a default handler that returns a response with a `NOT_FOUND`
    status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The service is now complete, so it can be compiled and run. In [Chapter 13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml),
    *Testing and Debugging Rust Microservices,* you''ll find out how to debug microservices.
    For now, however, you can use the `curl` command to send some `POST` requests
    and check the result in the browser. Type the following command in the shell to
    add three users and remove the second user with the ID of `**1**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you fetch the list of users in the browser, it should display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f68c682c-9bcc-4903-89ea-740767bd6992.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we used the `/users` request without a trailing slash with `curl`,
    and **`/users/`** with the trailing slash in the browser. This result means that
    regular expressions and request routing both work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a microservice using a `hyper` crate. We started
    with a minimal example that only responds with the *Rust Microservice* message.
    Then, we created a microservice that has two distinct paths – the first being
    the index page request and the second, the `NOT_FOUND` response.
  prefs: []
  type: TYPE_NORMAL
- en: Once we learned the basics, we then started to use the `match` expression to
    make the microservice REST-compliant. We also added the ability to handle users'
    data with four basic operations—create, read, update, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: To expand the routing capabilities in the last example of the chapter, we implemented
    routing based on regular expressions. Regular expressions are compact patterns
    that check and extract data from a text.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we encountered various crates—`hyper`, `futures`, `slab`, `regex`, and
    `lazy_static`. We'll discuss these in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have learned to create minimal HTTP microservice in the next chapter
    we will learn how to make it configurable and how to attach logging to it, because
    microservices work at remote servers and we need a capability to configure it
    without recompilation and be able to see all issues that happened with a microservices
    in logs.
  prefs: []
  type: TYPE_NORMAL
