- en: Developing a Microservice with the Hyper Crate
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hyper Crate开发微服务
- en: This chapter will provide a short introduction to creating microservices using
    Rust the and `hyper` crate. We will look at the basics of the HTTP protocol and
    the principles of routing. We'll also describe a minimal REST service written completely with
    Rust, using a simple method.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍使用Rust和`hyper` crate创建微服务。我们将探讨HTTP协议的基础和路由原则。我们还将描述一个完全使用Rust编写的最小REST服务，使用简单的方法。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Using `hyper`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`hyper`
- en: Handling HTTP requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: Using regular expressions for routing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式进行路由
- en: Getting parameters from the environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从环境中获取参数
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Because we''re starting to write code in this chapter, you''ll need to have
    certain software in order to compile and run examples:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在本章开始编写代码，所以你需要安装某些软件来编译和运行示例：
- en: I recommend you use the `rustup` tool, which will keep your Rust instance up
    to date. If you don't have this tool, you can get it from [https://rustup.rs/](https://rustup.rs/).
    When it's installed, run the `rustup update` command to update the current installation.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我建议你使用`rustup`工具，这将保持你的Rust实例更新。如果你没有这个工具，你可以从[https://rustup.rs/](https://rustup.rs/)获取它。安装后，运行`rustup
    update`命令来更新当前安装。
- en: The Rust compiler, at least version 1.31.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust编译器，至少版本1.31。
- en: The `hyper` crate, which we'll use to compile the code, requires the OpenSSL
    ([https://www.openssl.org/](https://www.openssl.org/)) library. The most popular
    operating systems already include the OpenSSL package and you can follow the manual
    of your package manager to install it.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用的`hyper` crate，需要OpenSSL ([https://www.openssl.org/](https://www.openssl.org/))
    库。大多数流行的操作系统已经包含了OpenSSL包，你可以遵循你的包管理器的手册来安装它。
- en: You can get the examples shown in this chapter from GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter02).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GitHub获取本章中显示的示例，网址为[https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Microservices-with-Rust/tree/master/Chapter02)。
- en: Binding a Tiny Server
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定微型服务器
- en: In this section, we'll create a Tiny Server from scratch. We'll start with the
    necessary dependencies, declare a main function, and then try to build and run
    it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从头开始创建一个Tiny Server。我们将从必要的依赖项开始，声明一个主函数，然后尝试构建和运行它。
- en: Adding necessary dependencies
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加必要的依赖项
- en: 'First, we need to create a new folder where we''ll add the necessary dependencies
    to create our first microservice. Use `cargo` to make a new project called `hyper-microservice`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的文件夹，我们将在这个文件夹中添加创建第一个微服务所需的依赖项。使用`cargo`创建一个名为`hyper-microservice`的新项目：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the created folder and add dependencies to your `Cargo.toml` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 打开创建的文件夹，并将依赖项添加到你的`Cargo.toml`文件中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The single dependency is the `hyper` crate. The latest release of this crate
    is asynchronous and lies on top of the `futures` crate. It also uses the `tokio`
    crate for runtime, which includes the scheduler, reactor, and asynchronous sockets.
    Some of the necessary types of the `tokio` crate are re-exported in the `hyper::rt`
    module. The main purpose of `hyper` is to operate with the HTTP protocol, which
    means that the crate can support other runtimes in the future.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单一依赖项是`hyper` crate。这个crate的最新版本是异步的，并且建立在`futures` crate之上。它还使用了`tokio` crate作为运行时，包括调度器、反应器和异步套接字。`tokio`
    crate的一些必要类型在`hyper::rt`模块中被重新导出。`hyper`的主要目的是操作HTTP协议，这意味着这个crate未来可以支持其他运行时。
- en: The main function of the server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器的主体函数
- en: 'Let''s start with the main function and add the necessary dependencies one
    by one, looking in detail at why we need each one. A minimal HTTP server needs
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从主函数开始，逐一添加必要的依赖项，并详细说明为什么我们需要每个依赖项。一个最小化的HTTP服务器需要以下内容：
- en: An address to bind to
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定的地址
- en: A `server` instance to handle incoming requests
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于处理传入请求的`server`实例
- en: A default handler for any request
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何请求的默认处理器
- en: A reactor (runtime) where the `server` instance will operate
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`server`实例将运行的反应器（运行时）
- en: Address of the server
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器的地址
- en: The first thing we need is an address. A socket address consists of an IP address
    and a port number. We'll use IPv4 in this book because it's widely supported.
    In [Chapter 6](fd4bf12a-bb05-469b-a230-163cee412261.xhtml), *Reactive Microservices –
    Increasing Capacity and Performance,* where we'll discuss scaling and the intercommunication
    of microservices, I'll show a few examples using IPv6.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一个地址。套接字地址由IP地址和端口号组成。在这本书中，我们将使用IPv4，因为它得到了广泛的支持。在[第6章](fd4bf12a-bb05-469b-a230-163cee412261.xhtml)，*反应式微服务
    - 增加容量和性能*，我们将讨论扩展和微服务之间的交互，我会展示一些使用IPv6的示例。
- en: 'The standard Rust library contains an `IpAddr` type to represent the IP address.
    We''ll use the `SocketAddr` struct, which contains both the `IpAddr` and the `u16`
    for the port number. We can construct the `SocketAddr` from a tuple of the `([u8;
    4], u16)` type. Add the following code to our main function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Rust库包含一个`IpAddr`类型来表示IP地址。我们将使用包含`IpAddr`和端口号`u16`的`SocketAddr`结构体。我们可以从类型为`([u8;
    4], u16)`的元组中构造`SocketAddr`。将以下代码添加到我们的主函数中：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We used an implementation of the `impl<I: Into<IpAddr>> From<(I, u16)> for
    SocketAddr` trait here, which, in turn, uses `impl From<[u8; 4]> for IpAddr`.
    This lets us use the `.into()` method call to construct a socket address from
    the tuple. Similarly, we can create new `SocketAddr` instances with a constructor.
    In production applications, we will parse the socket addresses from external strings
    (command-line parameters or environment variables), and if no variants are set,
    we''ll create `SocketAddr` from a tuple with default values.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里使用了一个`impl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr`特质的实现，它反过来使用`impl
    From<[u8; 4]> for IpAddr`。这使得我们可以使用`.into()`方法调用从元组中构造套接字地址。同样，我们可以使用构造函数创建新的`SocketAddr`实例。在生产应用程序中，我们将从外部字符串（命令行参数或环境变量）解析套接字地址，如果没有设置任何变体，我们将从具有默认值的元组中创建`SocketAddr`。'
- en: Server instances
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器实例
- en: 'Now we can create a `server` instance and bind to this address:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个`server`实例并将其绑定到这个地址：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding line creates a `hyper::server::Server` instance with a `bind`
    constructor that actually returns `Builder`, not a `Server` instance. The `Server`
    struct implements the `Future` trait. It has similar role to `Result`, but describes
    a value that isn't available immediately. You'll learn more about `Future` and
    other traits of the `futures` crate in [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml),
    *Understanding Asynchronous Operations with the Futures Crate*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行创建了一个带有`bind`构造函数的`hyper::server::Server`实例，该构造函数实际上返回`Builder`，而不是`Server`实例。`Server`结构体实现了`Future`特质。它具有与`Result`类似的作用，但描述了一个不可立即获得的价值。你将在[第5章](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml)，*使用Futures
    Crate理解异步操作*中了解更多关于`Future`和`futures`crate的其他特质。
- en: Setting the requests handler
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置请求处理器
- en: 'The `Builder` struct provides methods to tweak the parameters of the `server` created.
    For example, hyper''s `server` supports both `HTTP1` and `HTTP2`. You can use
    a `builder` value to choose either one protocol or both. In the following example,
    we''re using `builder` to attach a service for handling incoming HTTP requests
    using the `serve` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Builder`结构体提供了调整创建的`server`参数的方法。例如，hyper的`server`支持`HTTP1`和`HTTP2`。你可以使用`builder`值选择一个或两个协议。在下面的示例中，我们使用`builder`通过`serve`方法附加一个处理传入HTTP请求的服务：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we're using the builder instance to attach a function that generates a
    `Service` instance. This function implements the `hyper::service::NewService`
    trait. The generated item then has to implement the `hyper::service::Service`
    trait. A service in a `hyper` crate is a function that takes a request and gives
    a response back. We haven't implemented this trait in this example; instead, we'll
    use the `service_fn_ok` function, which turns a function with suitable types into
    a service handler.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用构建实例来附加一个生成`Service`实例的函数。这个函数实现了`hyper::service::NewService`特质。生成的项随后必须实现`hyper::service::Service`特质。在`hyper`crate中的服务是一个接收请求并返回响应的函数。我们没有在这个示例中实现这个特质；相反，我们将使用`service_fn_ok`函数，它将具有合适类型的函数转换为服务处理器。
- en: 'There are two corresponding structs: `hyper::Request` and `hyper::Response`.
    In the preceding code, we ignored a request argument and constructed the same
    response for every request. The response contains a body of static text.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个相应的结构体：`hyper::Request`和`hyper::Response`。在前面的代码中，我们忽略了一个请求参数并为每个请求构造了相同的响应。响应包含静态文本的正文。
- en: Adding the server instance to a runtime
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器实例添加到运行时
- en: 'Since we now have a handler, we can start the server. The runtime expects a
    `Future` instance with the `Future<Item = (), Error = ()>` type, but the `Server`
    struct implements a `Future` with the `hyper::Error` error type. We can use this
    error to inform the user about issues, but in our example we''ll just drop any
    error. As you might remember, the drop function expects a single argument of any
    type and returns a `unit` empty type. The `Future` trait uses the `map_err` method. It
    changes the error type using a function, which expects the original error type
    and returns a new one. Drop an error from the `server` using the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经有了处理器，我们可以启动服务器。运行时期望一个 `Future` 实例，其类型为 `Future<Item = (), Error =
    ()>`，但 `Server` 结构体实现了一个带有 `hyper::Error` 错误类型的 `Future`。我们可以使用这个错误来通知用户问题，但在我们的例子中我们只会丢弃任何错误。如您所记得，`drop`
    函数期望一个任何类型的单个参数，并返回一个 `unit` 空类型。`Future` 特性使用 `map_err` 方法。它通过一个函数改变错误类型，该函数期望原始错误类型并返回一个新的类型。使用以下方式从
    `server` 中丢弃错误：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now have everything we need and can start the `server` with the specific
    runtime. Use the `hyper::rt::run` function to start the `server`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所需的一切，可以使用特定的运行时启动 `server`。使用 `hyper::rt::run` 函数启动 `server`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Don''t compile it yet, because we haven''t imported types. Add it to the head
    of a source file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要编译它，因为我们还没有导入类型。将其添加到源文件的开头：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to import the different `hyper` types that we are using: `Server`,
    `Response`, and `Body`. In the final line, we''re using the `service_fn_ok` function.
    The `Future` import needs special attention; it''s the re-exported trait of the `futures`
    crate and it''s used everywhere in the `hyper` crate. In the next chapter, we''ll
    examine this trait in detail.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入我们正在使用的不同 `hyper` 类型：`Server`、`Response` 和 `Body`。在最后一行，我们使用 `service_fn_ok`
    函数。`Future` 导入需要特别注意；它是 `futures` 包的重新导出特性，并在 `hyper` 包的每个地方使用。在下一章中，我们将详细检查这个特性。
- en: Building and running
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行
- en: 'You can now compile the code and start the server with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以编译代码并使用以下命令启动服务器：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use your browser to connect to the server. Enter [http://localhost:8080/](http://localhost:8080/) in
    the browser''s address bar and the browser will connect to your server and show
    you a page with the text you entered in the previous code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的浏览器连接到服务器。在浏览器的地址栏中输入 [http://localhost:8080/](http://localhost:8080/)，浏览器将连接到您的服务器并显示您在上一段代码中输入的文本：
- en: '![](img/f86b61f1-bd9e-4751-8bca-fcf2182ad351.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f86b61f1-bd9e-4751-8bca-fcf2182ad351.png)'
- en: Rebuilding on changes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重建更改
- en: When you're working on developing web servers, it's useful to have instant access
    to compiled and running applications. It's tiresome to have to restart `cargo
    run` manually whenever you change the code. I recommend that you install and use
    the `cargo-watch` subcommand on `cargo`. This will monitor the changes made to
    the files of your project and restart the other commands you have chosen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在开发网络服务器时，能够即时访问编译和运行的应用程序非常有用。每次更改代码时都必须手动重新启动 `cargo run` 是一件很麻烦的事情。我建议您在
    `cargo` 上安装并使用 `cargo-watch` 子命令。这将监视您项目文件中的更改，并重新启动您选择的其它命令。
- en: 'To install `cargo-watch`, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `cargo-watch`，执行以下步骤：
- en: 'Type the following command in the console:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `run` command with `watch`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有 `watch` 的 `run` 命令：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can add extra arguments to the `run` command between quotes or add extra
    arguments after the `--` characters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在引号之间添加额外的参数到 `run` 命令，或者添加额外的参数在 `--` 字符之后。
- en: Handling incoming requests
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理传入请求
- en: We've created a server, but it isn't very useful until it can respond to real
    requests. In this section, we'll add handlers to the requests and use the principles
    of REST.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个服务器，但直到它能够响应真实请求之前，它并不是很有用。在本节中，我们将向请求添加处理器，并使用 REST 原则。
- en: Adding a service function
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加服务函数
- en: 'In the previous section, we implemented simple services based on `service_fn_ok`
    functions, which expect the service function not to throw any errors. There are
    also `service_fn` functions, which can be used to create handlers that can return
    an error. These are more suitable for asynchronous `Future` results. As we saw
    previously, the `Future` trait has two associated types: one for a successful
    result and one for an error. The `service_fn` function expects the result to be
    converted into future with the `IntoFuture` trait. You can read more about the `futures`
    crate and its types in the next chapter.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们基于 `service_fn_ok` 函数实现了简单的服务，这些函数期望服务函数不抛出任何错误。还有 `service_fn` 函数，可以用来创建可以返回错误的处理器。这些更适合异步
    `Future` 结果。如我们之前所见，`Future` 特征有两个关联类型：一个用于成功结果，一个用于错误。`service_fn` 函数期望结果通过 `IntoFuture`
    特征转换为 future。您可以在下一章中了解更多关于 `futures` crate 和其类型的信息。
- en: 'Let''s change the previous service function into one that returns the `Future`
    instance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前的服务函数改为返回 `Future` 实例的服务函数：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then add this unimplemented service function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加此未实现的服务函数：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similar to the previous one, this function expects a `Request`, but it doesn''t
    return a simple `Response` instance. Instead, it returns a future result. Since
    `Future` is a trait (which doesn''t have a size), we can''t return an unsized
    entity from the function and we have to wrap it in a `Box`. However, in this case,
    we used a brand new approach, which is the `impl` trait. This allows us to return
    an implementation of the trait by value, rather than by reference. Our `future`
    can be resolved to a `hyper::Response<Body>` item or a `hyper::Error` error type.
    You should import the necessary types if you''ve started a project from scratch
    and aren''t using the code examples included with this book:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前类似，这个函数期望一个 `Request`，但它不返回一个简单的 `Response` 实例。相反，它返回一个 future 结果。由于 `Future`
    是一个特征（它没有大小），我们不能从函数中返回一个无大小实体，而必须将其包装在 `Box` 中。然而，在这种情况下，我们使用了全新的方法，即 `impl`
    特征。这允许我们通过值返回特征的实现，而不是通过引用。我们的 `future` 可以解析为 `hyper::Response<Body>` 项目或 `hyper::Error`
    错误类型。如果您是从头开始的项目并且没有使用本书中包含的代码示例，您应该导入必要的类型：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also imported the `Future` trait from the `futures` crate. Make sure you''re
    either using `edition = "2018"` in the `Cargo.toml` file, or importing the crates
    in `main.rs`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从 `futures` crate 中导入了 `Future` 特征。请确保您在 `Cargo.toml` 文件中使用 `edition = "2018"`，或者将
    crate 导入到 `main.rs` 中：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We started by importing the types to the code, but we still have to import
    the crates in the `Cargo.toml` file.  Add these crates in the dependency list
    of your `Cargo.toml`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将类型导入到代码中，但仍然需要在 `Cargo.toml` 文件中导入 crate。在您的 `Cargo.toml` 文件的依赖列表中添加以下
    crate：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Everything is now ready to implement a service handler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以实现服务处理器。
- en: I prefer to order dependencies from generic to more specific. Alternatively,
    you can use alphabetical order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢按泛型到更具体的顺序排列依赖项。或者，您也可以使用字母顺序。
- en: Implementing a service function
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务函数
- en: 'Our service function will support two kinds of requests:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务函数将支持两种类型的请求：
- en: '`GET` requests to the `/` path with an index page response'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `/` 路径的 `GET` 请求带有索引页面响应
- en: Other requests with a `NOT_FOUND` response
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他带有 `NOT_FOUND` 响应的请求
- en: 'To detect the corresponding method and path, we can use the methods of the `Request`
    object. See the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测对应的方法和路径，我们可以使用 `Request` 对象的方法。请参见以下代码：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I used a `match` expression to detect the corresponding method returned from
    the `req.method()`  function, and also the path of the URI of the `Request` returned
    by the `req.uri().path()` method's chain call.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个 `match` 表达式来检测从 `req.method()` 函数返回的对应方法，以及 `req.uri().path()` 方法链调用返回的
    URI 路径。
- en: The `method()` function returns a reference to the `Method` instance. `Method`
    is an enumeration that contains all supported HTTP methods. Instead of other popular
    languages, which return strings for methods, Rust uses a strict set of methods
    from a finite enumeration. This helps to detect typos during compilation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`method()` 函数返回对 `Method` 实例的引用。`Method` 是一个枚举，包含所有支持的 HTTP 方法。与返回字符串方法的其它流行语言不同，Rust
    使用来自有限枚举的严格方法集。这有助于在编译期间检测拼写错误。'
- en: The `Future` instances created with the `future::ok` function are also returned.
    This function immediately resolves the future to a successful result with an item
    of the corresponding type. This is useful for static values; we don't need to
    wait to create them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`future::ok`函数创建的`Future`实例也会返回。这个函数立即将未来对象解析为对应类型的成功结果。这对于静态值很有用；我们不需要等待它们创建。
- en: The future object is a long operation that won't return a result immediately.
    The runtime will poll the future until it returns the result. It's useful to perform
    asynchronous requests on a database. We'll do this in [Chapter 7](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml),
    *Reliable Integration with Databases*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 未来对象是一个长期操作，不会立即返回结果。运行时会轮询未来对象，直到它返回结果。在数据库上执行异步请求很有用。我们将在[第7章](e09a1e76-ae09-41d4-99dc-9bad95fa3de7.xhtml)，“与数据库的可靠集成”中这样做。
- en: We can also return streams instead of a whole result. The `futures` crate contains
    a `Stream` trait for those cases. We'll look at this further in [Chapter 5](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml),
    *Understanding Asynchronous Operations with the Futures Crate*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以返回流而不是整个结果。对于这些情况，`futures`crate包含一个`Stream`trait。我们将在[第5章](ed541ef5-4701-4e70-aabf-14882b4cecb3.xhtml)，“使用Futures
    Crate理解异步操作”中进一步探讨这一点。
- en: In our match expression, we used  `Method::GET` and the `"/"` path to detect
    requests of the index page. In this case, we'll return a `Response` that constructs
    a `new` function and an HTML string as an argument.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的匹配表达式中，我们使用了`Method::GET`和`"/"`路径来检测索引页面的请求。在这种情况下，我们将返回一个`Response`，它构建一个`new`函数和一个HTML字符串作为参数。
- en: In case no pages were found that match the `_` pattern, we'll return a response
    with the `NOT_FOUND` status code from the `StateCode` enumeration. This contains
    all of the status codes of the HTTP protocol.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配`_`模式的页面，我们将从`StateCode`枚举返回一个带有`NOT_FOUND`状态码的响应。这包含了HTTP协议的所有状态码。
- en: We use the `body` method to construct the response, and we used an empty `Body`
    as an argument for that function. To check that we haven't used it before, we
    use `unwrap` to unpack the `Response` from the `Result`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`body`方法来构建响应，并使用一个空的`Body`作为该函数的参数。为了检查我们之前没有使用它，我们使用`unwrap`来解包`Result`中的`Response`。
- en: Index pages
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引页面
- en: The last thing we need is an index page. It's considered good form to return
    some information about a microservice when requested, but you may hide it for
    security reasons.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要的是一个索引页面。当请求微服务时，返回一些关于微服务的相关信息被认为是好的做法，但出于安全原因，你可能隐藏它。
- en: 'Our index page is a simple string with HTML content inside:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的索引页面是一个包含HTML内容的简单字符串：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a constant value that can't be modified. Рay attention to the start
    of the string, `r#"`, if you haven't used it before. This is a kind of multiline
    string in Rust that has to end with `"#`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不能修改的常量值。如果你之前没有使用过，请注意字符串的开始`r#"`。这是一种Rust中的多行字符串，必须以`"`结尾。
- en: 'Now you can compile the code and view the pages with a browser. I opened Developer
    Tools to show the status codes of the requests:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以编译代码，并用浏览器查看页面。我打开了开发者工具来显示请求的状态码：
- en: '![](img/ee617eec-f560-40cc-9c47-7c5b5b7d1193.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee617eec-f560-40cc-9c47-7c5b5b7d1193.png)'
- en: 'If you try to get a nonexistent resource, you''ll get a `404` status code,
    which we set with the `StatusCode::NOT_FOUND` constant:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试获取一个不存在的资源，你会得到一个`404`状态码，我们使用`StatusCode::NOT_FOUND`常量设置：
- en: '![](img/ddae2db0-0394-4eb1-a2cf-69d26e7c669b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddae2db0-0394-4eb1-a2cf-69d26e7c669b.png)'
- en: Implementing the REST principles
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现REST原则
- en: If everyone were to create rules of interaction with microservices from scratch,
    we'd have an excess of private standards of intercommunication. REST isn't a strict
    set of rules, but it's an architectural style intended to make interacting with
    microservices simple. It provides a suggested set of HTTP methods to create, read,
    update, and delete data; and perform actions. We'll add methods to our service
    and fit them to REST principles.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个人都从头开始创建与微服务交互的规则，我们将有过多私有的通信标准。REST不是一个严格的规则集，但它是一种旨在使与微服务交互简单的架构风格。它提供了一组建议的HTTP方法来创建、读取、更新和删除数据；以及执行操作。我们将向我们的服务添加方法，并使它们符合REST原则。
- en: Adding a shared state
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加共享状态
- en: You may have already heard that shared data is a bad thing and a potential cause
    of bottlenecks, if it has to be changed from separate threads. However, shared
    data can be useful if we want to share the address of a channel or if we don't
    need frequent access to it. In this section, we need a user database. In the following
    example, I'll show you how to add a shared state to our generator function. This
    approach can be used for a variety of reasons, such as keeping a connection to
    a database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说共享数据是坏事，如果它需要从不同的线程中更改，它可能是瓶颈的潜在原因。然而，如果我们想共享通道的地址或者我们不需要频繁访问它，共享数据是有用的。在本节中，我们需要一个用户数据库。在下面的示例中，我将向你展示如何向我们的生成函数添加共享状态。这种方法可以用于各种原因，例如保持与数据库的连接。
- en: 'A user database will obviously hold data about users. Let''s add some types
    to handle this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据库显然会存储有关用户的数据。让我们添加一些类型来处理这个问题：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`UserId` represents the user''s unique identifier. `UserData` represents the
    stored data, but we use an empty struct for serialization and parsing streams
    in this example.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserId`代表用户的唯一标识符。`UserData`代表存储的数据，但在本例中我们使用一个空的struct进行序列化和解析流。'
- en: 'Our database will be as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库将如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Arc` is an atomic reference counter that provides multiple references to a
    single instance of data (in our case, this is the `Mutex` over the slab of data).
    Atomic entities can be safely used with multiple threads. It uses native atomic
    operations to prohibit the cloning of the reference. This is because two or more
    threads can corrupt the reference counter and can cause segmentation faults, leading
    to data loss or a memory leak if the counter was greater than the references in
    the code.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arc`是一个原子引用计数器，它为数据的一个实例提供多个引用（在我们的情况下，这是对数据slab的`Mutex`）。原子实体可以安全地在多个线程中使用。它使用原生原子操作来禁止引用的克隆。这是因为两个或多个线程可能会损坏引用计数器，并可能导致段错误，如果计数器大于代码中的引用，则可能导致数据丢失或内存泄漏。'
- en: '`Mutex` is a mutual-exclusion wrapper that controls access to mutable data.
    `Mutex` is an atomic flag that checks that only one thread has access to the data
    and other threads have to wait until the thread that has locked the mutex releases
    it.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex`是一个互斥包装器，用于控制对可变数据的访问。`Mutex`是一个原子标志，它检查只有一个线程可以访问数据，其他线程必须等待锁定`Mutex`的线程释放它。'
- en: You have take into account that if you have a locked `Mutex` in one thread and
    that thread panics, the `Mutex` instance become poisoned, and if you try to lock
    it from another thread, you'll get an error.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑到，如果你在一个线程中有一个锁定的`Mutex`，并且该线程崩溃，`Mutex`实例将中毒，如果你尝试从另一个线程锁定它，你会得到一个错误。
- en: You may be wondering why we reviewed these types if the asynchronous server
    can work in a single thread. There are two reasons. First, you may need to run
    the server in multiple threads for scaling. Second, all types that provide interaction
    facilities, such as Sender objects (from a standard library, a `futures` crate,
    or anywhere else) or database connections, are often wrapped with these types
    to make them compatible with a multithreading environment. It can be useful to
    know what's going on under the hood.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们回顾了这些类型，如果异步服务器可以在单个线程中工作。有两个原因。首先，你可能需要运行服务器在多个线程中进行扩展。其次，所有提供交互设施的类型，如发送对象（来自标准库、`futures`
    crate或任何其他地方）或数据库连接，通常都会用这些类型包装，以使它们与多线程环境兼容。了解底层发生的事情可能是有用的。
- en: You might be familiar with standard library types, but `Slab` may seem a little
    different. This type can be thought of as a silver bullet in web-server development.
    Most pools use this appliance. Slab is an allocator that can store and remove
    any value identified by an ordered number. It can also reuse the slots of removed
    items. It's similar to the  `Vec` type, which won't resize if you remove the element,
    but will reuse free space automatically. For servers, it's useful to keep connections
    or requests, such as in the JSON-RPC protocol implementation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉标准库中的类型，但`Slab`可能看起来有些不同。这种类型可以被视为网络服务器开发中的银弹。大多数池都使用这种设备。Slab是一个分配器，可以存储和删除由有序数字标识的任何值。它还可以重用已删除项的槽位。它与`Vec`类型类似，如果你删除元素，它不会调整大小，但会自动重用空闲空间。对于服务器来说，保留连接或请求很有用，例如在JSON-RPC协议实现中。
- en: In this case, we use `Slab` to allocate new IDs for users and to keep the data
    with the user. We use `Arc` with the `Mutex` pair to protect our database of data
    race, because different responses can be processed in different threads, which
    can both try to access the database. In fact, Rust won't let you compile the code
    without these wrappers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Slab`为用户分配新的ID，并保留与用户相关的数据。我们使用`Arc`与`Mutex`对来保护我们的数据库，以防止数据竞争，因为不同的响应可以在不同的线程中处理，这两个线程都可能尝试访问数据库。实际上，Rust不会让你在没有这些包装器的情况下编译代码。
- en: 'We have to add an extra dependency, because the `Slab` type is available in
    the external `slab` crate. Add this using `Cargo.toml`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加一个额外的依赖项，因为`Slab`类型在外部`slab`crate中可用。使用`Cargo.toml`添加此依赖项：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Import these necessary types in the `main.rs` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.rs`文件中导入这些必要的类型：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's write a handler and a `main` function in the following section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中编写一个处理函数和一个`main`函数。
- en: Accessing a shared state from a service function
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务函数访问共享状态
- en: To get access to a shared state, you need to provide a reference to the shared
    data. This is simple, because we've already wrapped our state with `Arc`, which
    provides us with a `clone()` function to duplicate the reference to the shared
    object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问共享状态，你需要提供共享数据的引用。这很简单，因为我们已经用`Arc`包装了我们的状态，它为我们提供了一个`clone()`函数来复制共享对象的引用。
- en: 'Since our service function needs extra parameters, we have to rewrite the definition
    and call our `microservice_handler` function. Now it has an extra argument, which
    is the reference to the shared state:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务函数需要额外的参数，我们必须重新编写定义并调用我们的`microservice_handler`函数。现在它有一个额外的参数，即共享状态的引用：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also have to send this expected reference to the `main` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将此预期的引用发送到`main`函数：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we created a `Slab` and wrapped it with `Mutex` and `Arc`. After
    that, we  moved the object, called `user_db`, into the `serve` function call of
    the `server` builder that's using the `move` keyword. When the reference moves
    into the closure, we can send it to `microservice_handler`. This is a handler
    function called by a closure sent to the `service_fn` call. We have to clone the
    reference to move it to a nested closure, because that closure can be called multiple
    times. We shouldn't move the object completely, however, because a closure sent
    to the `serve` function can be called multiple times and so the runtime might
    need the object again later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个`Slab`，并用`Mutex`和`Arc`将其包装。之后，我们将对象`user_db`移动到使用`move`关键字的`server`构建器的`serve`函数调用中。当引用移动到闭包中时，我们可以将其发送到`microservice_handler`。这是一个由发送到`service_fn`调用的闭包调用的处理函数。我们必须克隆引用以将其移动到嵌套闭包中，因为该闭包可能被多次调用。然而，我们不应该完全移动对象，因为发送到`serve`函数的闭包可能被多次调用，因此运行时可能稍后还需要该对象。
- en: In other words, both closures can be called multiple times. The closure of `service_fn`
    will be called in the same thread as the runtime, and we can use a reference for
    the value inside it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这两个闭包都可以被多次调用。`service_fn`的闭包将在与运行时相同的线程中被调用，我们可以使用其中的值引用。
- en: Parsing paths in a microservice
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在微服务中解析路径
- en: A common task in web development is to use functions that work with persistent
    storage. These functions are often called **create**, **read**, **update**, **and
    delete** (**CRUD**) functions. They are the most common operations with data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，一个常见的任务是使用与持久存储一起工作的函数。这些函数通常被称为**创建**、**读取**、**更新**和**删除**（**CRUD**）函数。它们是与数据最常见操作。
- en: 'We can implement a CRUD set for our service, but first we have to identify
    the entity that we want to work with. Imagine that we need three types of entities:
    users, articles, and comments. In this case, I recommend that you separate the
    microservices, because the users microservice is responsible for identity, the
    articles microservice is responsible for the content, and the comments microservice
    handles content. However, you would get more benefits if you could reuse these
    entities for more than one context.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的服务实现一个CRUD集，但首先我们必须确定我们想要与之工作的实体。想象一下，我们需要三种类型的实体：用户、文章和评论。在这种情况下，我建议你分离微服务，因为用户微服务负责身份，文章微服务负责内容，评论微服务处理内容。然而，如果你能将这些实体用于多个上下文，你会得到更多的好处。
- en: 'Before we implement all the handlers, we need a helper function that creates
    empty responses with the corresponding HTTP status codes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现所有处理函数之前，我们需要一个辅助函数，用于创建带有相应HTTP状态码的空响应：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function carries out a few simple actions – it expects a status code, creates
    a new response builder, sets that status, and adds an empty body.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数执行几个简单的操作——它期望一个状态码，创建一个新的响应构建器，设置该状态，并添加一个空体。
- en: 'We can now add a new request handler that checks three path variants:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个新的请求处理程序，该处理程序检查三个路径变体：
- en: The index page (path `/`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引页面（路径`/`）
- en: Actions with user data (prefix `/user/`)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户数据相关的操作（前缀`/user/`）
- en: Other paths
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他路径
- en: 'We can use the `match` expression to fulfill all of these cases. Add the following
    code to the `microservices_handler` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`match`表达式来满足所有这些情况。将以下代码添加到`microservices_handler`函数中：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we used an `if` expression in the second branch to detect that
    the path starts with the `/user/` prefix. This prefix is actually stored in the `USER_PATH`
    constant:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在第二个分支中使用了`if`表达式来检测路径是否以`/user/`前缀开头。实际上，这个前缀存储在`USER_PATH`常量中：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unlike the previous example, in this case we'll use our brand new `response_with_code` function
    to return a `NOT_FOUND` HTTP response. We also assign a response to the `response`
    variable and use it to create a `Future` instance with the `future::ok` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子不同，在这种情况下，我们将使用我们全新的`response_with_code`函数来返回`NOT_FOUND` HTTP响应。我们还分配了一个响应给`response`变量，并使用它来创建一个`Future`实例，使用`future::ok`函数。
- en: Implementing REST methods
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现REST方法
- en: Our microservices can already distinguish between different paths. All that's
    left is to implement request handling for the users' data. All incoming requests
    have to contain the `/user/` prefix in their paths.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务微件已经可以区分不同的路径。剩下要做的只是实现用户数据的请求处理。所有传入的请求都必须在其路径中包含`/user/`前缀。
- en: Extracting the user's identifier
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取用户的标识符
- en: To modify a specific user, we need their identifier. REST specifies that you
    need to get the IDs from a path, because REST maps data entities to URLs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改特定用户，我们需要他们的标识符。REST规定您需要从路径中获取ID，因为REST将数据实体映射到URL。
- en: We can extract a user's identifier using the tail of the path, which we already
    have. This is  why we use the `starts_with` method of the string, instead of checking
    for strong equality with `USER_PATH` to the path tails.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用路径的尾部来提取用户的标识符，这是我们已经拥有的。这就是为什么我们使用字符串的`starts_with`方法，而不是检查与`USER_PATH`路径尾部的强等价性。
- en: 'We previously declared the `UserId` type, which equals the `u64` unsigned number.
    Add this code to the second branch of the previously-declared `match` expression
    with the `(method, path)` pattern to extract the user''s identifier from the path:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前声明了`UserId`类型，它等于`u64`无符号数。将以下代码添加到之前声明的`match`表达式的第二个分支中，使用`(method, path)`模式从路径中提取用户的标识符：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `str::trim_left_matches` method removes the part of the string if it matches
    a provided string from the argument. After that, we use the `str::parse` method,
    which tries to convert a string (the remaining tail) to a type that implements
    the `FromStr` trait of the standard library. `UserId` already implements this,
    because it's equal to the `u64` type, which can be parsed from the string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`str::trim_left_matches`方法会移除与提供的字符串匹配的字符串部分。之后，我们使用`str::parse`方法，该方法尝试将字符串（剩余的尾部）转换为实现了标准库中`FromStr`特性的类型。`UserId`已经实现了这一点，因为它等于`u64`类型，可以从字符串中解析出来。'
- en: The parse method returns `Result`. We convert this to an `Option` instance with
    `Result::ok` functions. We won't try to handle errors with the IDs. The `None`
    value represents either the absence of a value or a wrong value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解析方法返回`Result`。我们使用`Result::ok`函数将其转换为`Option`实例。我们不会尝试处理ID的错误。`None`值表示值的缺失或错误值。
- en: We can also use a map of the returned `Option` instance to convert a value to
    the `usize` type. This is because `Slab` uses `usize` for IDs, but the real size
    of the `usize` type depends on the platform architecture, which can be different.
    It can be `u32` or `u64` depending on the largest memory address that you can
    use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用返回的`Option`实例的映射来将值转换为`usize`类型。这是因为`Slab`使用`usize`作为ID，但`usize`类型的实际大小取决于平台架构，这可能是不同的。它可以是`u32`或`u64`，这取决于你可以使用的最大内存地址。
- en: Why can't we use `usize` for `UserId` since it implements the `FromStr` trait?
    This is because a client expects the same behavior as an HTTP server, which doesn't
    depend on the architecture platform. It's bad practice to use unpredictable size
    parameters in HTTP requests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能为`UserId`使用`usize`，因为它实现了`FromStr`特性？这是因为客户端期望与HTTP服务器相同的行为，而HTTP服务器不依赖于架构平台。在HTTP请求中使用不可预测的大小参数是不良的做法。
- en: Sometimes, it can be difficult to choose a type to identify the data. We use
    `map` to convert the `u64` value to `usize`. This doesn't work, however, for architectures
    where `usize` equals `u32`, because `UserId` can be larger than the memory limit.
    It's safe in cases where the microservices are tiny, but this is an important
    point to bear in mind for microservices that you'll use in production. Often,
    this problem will be simple to solve, because you can use the ID type of a database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，选择一个类型来标识数据可能会有困难。我们使用 `map` 将 `u64` 值转换为 `usize`。然而，在 `usize` 等于 `u32` 的架构中，这不起作用，因为
    `UserId` 可能大于内存限制。在微服务很小的案例中这是安全的，但对于你将在生产中使用的微服务来说，这是一个需要牢记的重要点。通常，这个问题很容易解决，因为你可以使用数据库的
    ID 类型。
- en: Getting access to the shared data
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取对共享数据的访问权限
- en: In this user handler, we need access to a database with users. Because the database
    is a `Slab` instance that's wrapped with a `Mutex` instance, we have to lock the
    mutex to have exclusive access to a slab. There's a `Mutex::lock` function that
    returns `Result<MutexGuard, PoisonError<MutexGuard>>`. `MutexGuard` is a scoped
    lock, which means it leaves the code block or scope in, and it implements the `Deref`
    and `DerefMut` traits to provide transparent access to data under the guard object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用户处理器中，我们需要访问包含用户的数据库。因为数据库是一个被 `Mutex` 实例包装的 `Slab` 实例，我们必须锁定互斥锁以获得对片段的独占访问。有一个
    `Mutex::lock` 函数，它返回 `Result<MutexGuard, PoisonError<MutexGuard>>`。`MutexGuard`
    是一个作用域锁，这意味着它会在代码块或作用域内保持，并且它实现了 `Deref` 和 `DerefMut` 特性，以提供对受保护对象下数据的透明访问。
- en: 'It''s a good practice to report all errors in the handler. You can log errors
    and return a `500` (Internal Error) HTTP code to the client. To keep it simple,
    we''ll use an `unwrap` method and expect the mutex to lock correctly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器中报告所有错误是一个好习惯。你可以记录错误并返回一个 `500`（内部错误）HTTP 状态码给客户端。为了保持简单，我们将使用 `unwrap`
    方法并期望互斥锁能够正确锁定：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we locked the `Mutex` for the duration of generating the request. In this
    case, where we're creating whole responses immediately, this is normal. In cases
    where the result is delayed or when we work with a stream, we shouldn't lock the
    mutex all time. This will create a bottleneck for all requests because the `server`
    can't process requests in parallel if all of them depend on a single shared object.
    For cases where you don't have results immediately, you can clone the reference
    to the mutex and lock it for the short time you need access to the data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在生成请求的过程中锁定了 `Mutex`。在这种情况下，我们立即创建整个响应，这是正常的。在结果延迟或我们处理流的情况下，我们不应该一直锁定互斥锁。因为这将为所有请求创建瓶颈，因为如果所有请求都依赖于单个共享对象，那么
    `服务器` 就不能并行处理请求。对于没有立即得到结果的情况，你可以克隆互斥锁的引用，并在需要访问数据时短暂地锁定它。
- en: REST methods
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 方法
- en: 'We want to cover all basic CRUD operations. Using the principles of REST, there
    are suitable HTTP methods that fit these operations—`POST`, `GET`, `PUT`, and
    `DELETE`. We can use the `match` expression to detect the corresponding HTTP method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望涵盖所有基本的 CRUD 操作。使用 REST 原则，有适合这些操作的合适的 HTTP 方法——`POST`、`GET`、`PUT` 和 `DELETE`。我们可以使用
    `match` 表达式来检测相应的 HTTP 方法：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we used a tuple with two values—a method and a user identifier, which
    is represented by the `Option<UserId>` type. There is a default branch that returns
    the `METHOD_NOT_ALLOWED` message (the 405 HTTP status code) if a client requests
    an unsupported method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个包含两个值的元组——一个方法和一个用户标识符，它由 `Option<UserId>` 类型表示。如果客户端请求一个不支持的方法，有一个默认分支返回
    `METHOD_NOT_ALLOWED` 消息（405 HTTP 状态码）。
- en: Let's discuss every branch of match expression for every operation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个操作的匹配表达式的每个分支。
- en: POST – Creating data
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST – 创建数据
- en: 'When the `server` has just started, it doesn''t contain any data. To support
    data creation, we use the `POST` method without the user''s ID. Add the following
    branch to the `match (method, user_id)` expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `服务器` 刚启动时，它不包含任何数据。为了支持数据创建，我们使用不带用户 ID 的 `POST` 方法。将以下分支添加到 `match (method,
    user_id)` 表达式中：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code adds a `UserData` instance to the user database and sends the associated
    ID of the user in a response with the `OK` status (an HTTP status code of 200).
    This code was set by the `Response::new` function by default.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码向用户数据库添加一个 `UserData` 实例，并在带有 `OK` 状态（HTTP 状态码 200）的响应中发送关联的用户 ID。默认情况下，这段代码是由
    `Response::new` 函数设置的。
- en: '`UserData` is an empty struct in this case. In real applications, however,
    it would have to contain real data. We use an empty struct to avoid serialization,
    but you can read more about serialization and deserialization based on the `serde`
    crate in [Chapter 4](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml), *Data Serialization
    and Deserialization with the Serde Crate*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`UserData`是一个空的struct。然而，在实际应用中，它必须包含真实数据。我们使用一个空的struct来避免序列化，但你可以在[第4章](be6bf2c7-c1dd-4d9f-b036-bbb12e1de809.xhtml)中了解更多关于基于`serde`crate的序列化和反序列化信息，*使用Serde
    Crate进行数据序列化和反序列化*。
- en: 'What if the client sets the ID with a `POST` request? You can interpret this
    case in two ways—ignore it or try to use the provided ID. In our example, we''ll
    inform the client that the request was wrong. Add the following branch to handle
    this case:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端使用`POST`请求设置ID，你可以有两种解释方式——忽略它或尝试使用提供的ID。在我们的例子中，我们将通知客户端请求是错误的。添加以下分支来处理这种情况：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code returns a response with the `BAD_REQUEST` status code (a `400` HTTP
    status code).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回一个带有`BAD_REQUEST`状态码（`400` HTTP状态码）的响应。
- en: GET – Reading data
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET – 读取数据
- en: 'When data is created, we need to be able to read it. For this case, we can
    use the HTTP `GET` method. Add the following branch to the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被创建时，我们需要能够读取它。在这种情况下，我们可以使用HTTP的`GET`方法。将以下分支添加到代码中：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code uses the user database to try to find the user by the ID that's provided
    in the path. If the user is found, we'll convert its data to a `String` and into
    a `Body` to send with a `Response`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用用户数据库尝试通过路径中提供的ID查找用户。如果找到用户，我们将将其数据转换为`String`并转换为`Body`以发送响应。
- en: If the user isn't found, the handler branch will respond with the `NOT_FOUND`
    status code (the classic `404` error).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到用户，处理分支将以`NOT_FOUND`状态码（经典的`404`错误）响应。
- en: 'To make the `UserData` convertible to a `String`, we have to implement the `ToString`
    trait for that type. However, it''s typically more useful to implement the `Display`
    trait, because `ToString` will be derived automatically for every type that implements
    the `Display` trait. Add this code somewhere in the `main.rs` source file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`UserData`可转换为`String`，我们必须为该类型实现`ToString`trait。然而，通常实现`Display`trait更有用，因为对于每个实现了`Display`trait的类型，`ToString`将被自动推导。将以下代码添加到`main.rs`源文件中的某个位置：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this implementation, we return a string with an empty JSON object `"{}"`.
    Real microservices have to use the `serde` trait for such conversions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，我们返回一个包含空JSON对象`"{}"`的字符串。真正的微服务必须使用`serde`trait进行此类转换。
- en: PUT – Updating data
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PUT – 更新数据
- en: 'Once the data is saved, we might want to provide the ability to modify it.
    This is a task for the `PUT` method. Use this method to handle changes to the
    data:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被保存，我们可能希望提供修改它的能力。这是`PUT`方法的任务。使用此方法来处理数据的更改：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code tries to find a `user` instance in the user database with the `get_mut`
    method. This returns a mutable reference wrapped with either a `Some` option,
    or a `None` option if the corresponding value isn't found. We can use a dereference
    operator, `*`, to replace the data in the storage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码尝试使用`get_mut`方法在用户数据库中查找`user`实例。这返回一个包含`Some`选项的可变引用，或者如果找不到相应的值，则返回`None`选项。我们可以使用解引用运算符`*`来替换存储中的数据。
- en: If the user's data was found and replaced, the branch returns an `OK` status
    code. If there's no user with the requested ID, the branch returns `NOT_FOUND`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到并替换了用户数据，分支将返回`OK`状态码。如果没有找到请求的ID的用户，分支将返回`NOT_FOUND`。
- en: DELETE – Deleting data
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE – 删除数据
- en: 'When we don''t need data anymore, we can delete it. This is the purpose of
    the `DELETE` method. Use it in the branch as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要数据时，我们可以将其删除。这就是`DELETE`方法的目的。在分支中使用它如下：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code checks whether the `Slab` contains the data and removes it with the
    `remove` method. We don't use the `remove` method right away because this expects
    the data to exist in the storage beforehand, and therefore panics if the data
    is absent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查`Slab`是否包含数据，并使用`remove`方法将其删除。我们不立即使用`remove`方法，因为它期望数据事先存在于存储中，如果数据不存在，则会引发panic。
- en: Often, web services don't actually remove data and instead just mark it as deleted.
    This is a reasonable thing to do because it allows you to explore the data later
    and improve the efficiency of the service or the company. However, this is a risky
    practice. Users should be able to remove their data completely, because sensitive
    data can represent a threat. New laws, such as the GDPR law ([https://en.wikipedia.org/wiki/General_Data_Protection_Regulation](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation)),
    protect the user's right to own their data and stipulate certain requirements
    for data protection. Violation of such laws may result in a fine. It's important
    to remember this when you work with sensitive data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络服务并没有真正删除数据，而是只是将其标记为已删除。这样做是合理的，因为它允许你稍后探索数据并提高服务或公司的效率。然而，这是一种风险行为。用户应该能够完全删除他们的数据，因为敏感数据可能构成威胁。新的法律，如GDPR法律([https://en.wikipedia.org/wiki/General_Data_Protection_Regulation](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation))，保护用户对其数据的所有权，并规定数据保护的一些要求。违反这些法律可能会导致罚款。当你处理敏感数据时，记住这一点很重要。
- en: Routing advanced requests
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由高级请求
- en: 'In the preceding example, we used pattern matching to detect the destination
    of a request. This isn''t a flexible technique, because the path often contains
    extra characters that have to be taken into account. The `/user/1/` path, for
    example, contains the trailing slash, ***`/`*** , which can''t be parsed with
    a user ID in the previous version of our microservice. There''s a flexible tool
    to fix this issue: regular expressions.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了模式匹配来检测请求的目的地。这不是一种灵活的技术，因为路径通常包含必须考虑的额外字符。例如，`/user/1/`路径包含尾随斜杠，***`/`***，在微服务的上一个版本中无法与用户ID一起解析。有一个灵活的工具可以解决这个问题：正则表达式。
- en: Defining paths with regular expressions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式定义路径
- en: 'A regular expression is a sequence of characters that express a pattern to
    be searched for in a string. Regular expressions provide you with the ability
    to create tiny parsers that split a text into parts using a formal declaration.
    Rust has a crate called `regex`, a popular abbreviation of *regular expression
    collocation*. You can learn more about this crate here: [https://crates.io/crates/regex](https://crates.io/crates/regex).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一系列字符，用于表达在字符串中要搜索的图案。正则表达式提供给你创建小解析器的功能，这些解析器使用正式声明将文本分割成部分。Rust有一个名为`regex`的crate，这是正则表达式组合的流行缩写。你可以在这里了解更多关于这个crate的信息：[https://crates.io/crates/regex](https://crates.io/crates/regex)。
- en: Adding the necessary dependencies
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加必要的依赖项
- en: 'To use regular expressions in our `server`, we need two crates: `regex` and
    `lazy_static`. The first provides a `Regex` type to create and match regular expressions
    with strings. The second helps to store `Regex` instances in a static context.
    We can assign constant values to static variables, because they''re created when
    a program loads to memory. To use complex expressions, we have to add an initialization
    code and use it to execute expressions, assigning the result to a static variable.
    The `lazy_static` crate contains a `lazy_static!` macro to do this job for us
    automatically. This macro creates a static variable, executes an expression, and
    assigns the evaluated value to that variable. We can also create a regular expression
    object for every request in a local context using a local variable, rather than
    a static one. However, this takes up runtime overhead, so it''s better to create
    it in advance and reuse it.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的`server`中使用正则表达式，我们需要两个crate：`regex`和`lazy_static`。第一个提供了`Regex`类型，用于创建和匹配字符串中的正则表达式。第二个帮助在静态上下文中存储`Regex`实例。我们可以将常量值赋给静态变量，因为它们在程序加载到内存时创建。为了使用复杂表达式，我们必须添加初始化代码并使用它来执行表达式，将结果赋给静态变量。`lazy_static`
    crate 包含一个`lazy_static!`宏来自动完成这项工作。这个宏创建一个静态变量，执行一个表达式，并将评估后的值赋给该变量。我们还可以使用局部变量而不是静态变量，在局部上下文中为每个请求创建一个正则表达式对象。然而，这会占用运行时开销，因此最好提前创建并重用它。
- en: 'Add both dependencies to the `Cargo.toml` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个依赖项添加到`Cargo.toml`文件中：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add two imports, in addition to the imports in the `main.rs` source file from
    the previous example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一个示例中的`main.rs`源文件中的导入之外，还需要添加两个导入：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We'll use the `lazy_static` macro and the `Regex` type to construct a regular
    expression.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lazy_static`宏和`Regex`类型来构建一个正则表达式。
- en: Writing regular expressions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写正则表达式
- en: 'Regular expressions contain a special language, used to write a pattern to
    extract data from a string. We need three patterns for our example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式包含一种特殊语言，用于编写模式以从字符串中提取数据。我们需要为我们的示例编写三个模式：
- en: A path for the index page
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引页面路径
- en: A path for user management
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理路径
- en: A path for the list of users (a new feature for our example server)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户列表路径（我们示例服务器的全新功能）
- en: 'There''s a `Regex::new` function that creates regular expressions. Remove the
    previous `USER_PATH` constant and add three new regular expression constants in
    a lazy static block:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `Regex::new` 函数可以创建正则表达式。删除之前的 `USER_PATH` 常量，并在懒静态块中添加三个新的正则表达式常量：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, regular expressions look complex. To understand them better,
    let's analyze them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，正则表达式看起来很复杂。为了更好地理解它们，让我们分析它们。
- en: Path for index page
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引页面路径
- en: 'The `INDEX_PATH` expression matches the following paths:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`INDEX_PATH` 表达式匹配以下路径：'
- en: '*`/`*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`/`*'
- en: '*`/index.htm`*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`/index.htm`*'
- en: '*`/index.html`*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`/index.html`*'
- en: The expression that fits these paths is `"^/(index\\.html?)?$"`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配这些路径的表达式是 `"^/(index\\.html?)?$"`。
- en: The `^` symbol means there must be a string beginning, while the `$` symbol
    means there must be a string ending. When we place these symbols on either side,
    we prevent all prefixes and suffixes in the path and expect exact matching.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`^` 符号表示必须有字符串的开始，而 `$` 符号表示必须有字符串的结束。当我们将这些符号放在两边时，我们防止路径中的所有前缀和后缀，并期望精确匹配。'
- en: The `( )` brackets implies there must be a group. An expression in a group is
    treated as an indivisible unit.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`( )` 括号表示必须有组。组中的表达式被视为一个不可分割的单位。'
- en: The `?` symbol means that the previous character is optional. We place it after
    the `l` character to allow the file in the path to have both `.htm` and `.html`extensions.
    As you'll see later, we don't have an index file to read. We use it as an alias
    of the root path handler. The question mark is also used after a whole group with
    a file name to fit the empty root path, *`/`*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`?` 符号表示前面的字符是可选的。我们将它放在 `l` 字符后面，以允许路径中的文件具有 `.htm` 和 `.html` 扩展名。正如你稍后看到的，我们没有索引文件可以读取。我们将其用作根路径处理器的别名。问号也用于整个组（带有文件名）之后，以适应空根路径，*`/`*。'
- en: The  dot symbol (`.`) fits any character, but we need a real dot symbol. To
    treat a dot as a symbol, we have to add a backslash (`\`) before it. A single
    backslash, however, will be interpreted as a beginning-of-escape expression, so
    we have to use pair of backslashes (`\\`) to make the backslash a plain symbol.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 点符号 (`.`) 匹配任何字符，但我们需要一个真正的点符号。为了将点作为符号处理，我们必须在它前面添加一个反斜杠 (`\`)。然而，单个反斜杠将被解释为开始转义表达式，因此我们必须使用一对反斜杠
    (`\\`) 来使反斜杠成为一个普通符号。
- en: All other characters are treated as is, including the `/` symbol.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他字符都按原样处理，包括 `/` 符号。
- en: Path for user management
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理路径
- en: 'The `USER_PATH` expression can fit the following paths:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER_PATH` 表达式可以匹配以下路径：'
- en: '`/user/`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/`'
- en: '`/user/<id>`, where `<id>` means group of digits'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/<id>`，其中 `<id>` 表示数字组'
- en: '`/user/<id>/`, the same as the previous one, but with a trailing backslash'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/<id>/`，与上一个相同，但有一个尾随反斜杠'
- en: These cases can be handled with the `"^/user/((?P<user_id>\\d+?)/?)?$"` regular
    expression. This expression is a bit complex. It includes two groups (one is nested)
    and some other strange characters. Let's have a closer look.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况可以用 `"^/user/((?P<user_id>\\d+?)/?)?$"` 正则表达式来处理。这个表达式有点复杂。它包括两个组（一个是嵌套的）和一些其他奇怪的字符。让我们更仔细地看看。
- en: '`?P<name>` is a grouping attribute that sets the name of the capturing group.
    Every group in brackets can be accessed by the `regex::Captures` object. Named
    groups can be accessed by names.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`?P<name>` 是一个分组属性，用于设置捕获组的名称。每个括号中的组都可以通过 `regex::Captures` 对象访问。命名组可以通过名称访问。'
- en: '`\\d` is a special expression that matches any digit. To specify that we have
    one or more digits, we should add the `+` symbol, which tells us how many repetitions
    it may have. The `*` symbol can also be added, which tells us that there are zero
    or more repetitions, but we haven''t used this in our regular expression.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`\\d` 是一个特殊表达式，用于匹配任何数字。为了指定我们有一个或多个数字，我们应该添加 `+` 符号，它告诉我们可能有多少重复。`*` 符号也可以添加，它告诉我们可以有零个或多个重复，但我们还没有在我们的正则表达式中使用它。'
- en: There are two groups. The first is nested with the name `user_id`. It must include
    digits only to be parsed to the `UserId` type. The second is an enclosing group
    that contains the optional trailing slash. This whole group is optional, meaning
    that the expression can include a `/user/` path without any identifier.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Path for the users list
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `USERS_PATH` is a new pattern, which we didn''t have in the previous example.
    We''ll use it to return a full list of users on the `server`. This pattern fits
    only two variants of the path:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`/users/`  (with a trailing slash)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/users` (without a trailing slash)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The regular expression to handle these cases is quite simple: `"^/users/?$"`.
    We've already seen all the symbols in this pattern. It expects a string to begin
    with the `^` symbol and the slash symbol. After that, it expects `users` with
    an optional slash at the tail `/?`. Finally, it expects the end of a string with
    the `$` symbol.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Matching expressions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to reorganize the code of `microservice_handler` because we can''t
    use regular expressions in a `match` expression. We have to extract the method
    with the path at the start, because we need it for most responses:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The first thing we''ll check is the index page requests. Add the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This uses the `INDEX_PATH` regular expression to check whether the request's
    path matches the index page request using the `Regex::is_match` method, which
    returns a `bool` value. Here, we're checking the method of a request, so only `GET` is
    allowed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then continue the `if` clause with an alternative condition for the
    user list request:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code uses the `USERS_PATH` pattern to check whether the client requested
    the list of users. This is a new path route. After this, we iterate over all the
    users in the database and join their IDs in a single string.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to handle REST requests:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code uses the `USER_PATH` and the `Regex::captures` method. It returns
    a `Captures` object with the values of all captured groups. If the pattern doesn't
    match the method, it returns a `None` value. If the pattern does match, we get
    an object stored in the `cap` variable. The `Captures` struct has the `name` method
    to get a captured value by name. We use the `user_id` as the name of the group.
    This group can be optional and the `name` method returns an `Option`. We use the `and_then`
    method of the `Option` to replace it with the parsed `UserId`. Finally, the `user_id`
    variable takes the `Option<UserId>` value, in the same way as the previous version
    of our microservice. To avoid repetition, I skipped the block where the request
    is the same as the (`method`, `user_id`) tuple – just copy this part from the
    example in the previous section of this chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is a default handler that returns a response with a `NOT_FOUND`
    status code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The service is now complete, so it can be compiled and run. In [Chapter 13](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml),
    *Testing and Debugging Rust Microservices,* you''ll find out how to debug microservices.
    For now, however, you can use the `curl` command to send some `POST` requests
    and check the result in the browser. Type the following command in the shell to
    add three users and remove the second user with the ID of `**1**`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 服务现在已经完整，因此可以编译并运行。在[第13章](1d24de7f-9990-4afe-bd1c-9bf664f1eda3.xhtml)《测试和调试Rust微服务》中，您将了解到如何调试微服务。然而，目前您可以使用`curl`命令发送一些`POST`请求，并在浏览器中检查结果。在shell中输入以下命令以添加三个用户并删除ID为`**1**`的第二个用户：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you fetch the list of users in the browser, it should display the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从浏览器中获取用户列表，它应该显示以下内容：
- en: '![](img/f68c682c-9bcc-4903-89ea-740767bd6992.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f68c682c-9bcc-4903-89ea-740767bd6992.png)'
- en: As you can see, we used the `/users` request without a trailing slash with `curl`,
    and **`/users/`** with the trailing slash in the browser. This result means that
    regular expressions and request routing both work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用`curl`时没有使用尾随斜杠的`/users`请求，而在浏览器中使用带有尾随斜杠的**`/users/`**。这个结果意味着正则表达式和请求路由都正常工作。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a microservice using a `hyper` crate. We started
    with a minimal example that only responds with the *Rust Microservice* message.
    Then, we created a microservice that has two distinct paths – the first being
    the index page request and the second, the `NOT_FOUND` response.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用`hyper` crate创建了一个微服务。我们从一个仅响应`*Rust Microservice*`消息的最小示例开始。然后，我们创建了一个具有两个不同路径的微服务——第一个是索引页面请求，第二个是`NOT_FOUND`响应。
- en: Once we learned the basics, we then started to use the `match` expression to
    make the microservice REST-compliant. We also added the ability to handle users'
    data with four basic operations—create, read, update, and delete.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了基础知识之后，我们开始使用`match`表达式使微服务符合REST规范。我们还添加了处理用户数据的四种基本操作——创建、读取、更新和删除。
- en: To expand the routing capabilities in the last example of the chapter, we implemented
    routing based on regular expressions. Regular expressions are compact patterns
    that check and extract data from a text.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展本章最后示例中的路由功能，我们实现了基于正则表达式的路由。正则表达式是紧凑的模式，用于检查和从文本中提取数据。
- en: In this chapter, we encountered various crates—`hyper`, `futures`, `slab`, `regex`, and
    `lazy_static`. We'll discuss these in detail in the next chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遇到了各种crate——`hyper`、`futures`、`slab`、`regex`和`lazy_static`。我们将在下一章详细讨论这些内容。
- en: Since we have learned to create minimal HTTP microservice in the next chapter
    we will learn how to make it configurable and how to attach logging to it, because
    microservices work at remote servers and we need a capability to configure it
    without recompilation and be able to see all issues that happened with a microservices
    in logs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在下一章学习了如何创建最小化的HTTP微服务，我们将学习如何使其可配置，以及如何将其与日志关联，因为微服务在远程服务器上运行，我们需要一个无需重新编译即可配置它的能力，并且能够查看所有在微服务中发生的日志问题。
