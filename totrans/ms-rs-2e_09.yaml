- en: Metaprogramming with Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaprogramming is a concept that changes the way you look at instructions and
    data in a program. It allows you to generate new code by treating instructions
    like any other piece of data. Many languages have support for metaprogramming,
    for example, Lisp's macros, C's `#define` construct, and Python's metaclasses.
    Rust is no different and provides many forms of metaprogramming, which we'll explore
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is metaprogramming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros in Rust and their forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative macros, macro variables, and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macro use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Available macro crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is metaprogramming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Lisp isn''t a language, it''s a building material."'
  prefs: []
  type: TYPE_NORMAL
- en: '*– Alan Kay*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any program, regardless of the language used, contains two entities: data and
    instructions that manipulate the data. The usual flow of a program is mostly concerned
    with manipulating data. The issue with instructions, though, is that once you
    write them, it''s like they''ve been carved into stone, and so they are non-malleable.
    It would be more enabling if we could treat instructions as data and generate
    new instructions using code. Metaprogramming provides exactly that!'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a programming technique where you can write code that has the ability
    to generate new code. Depending on the language, it can be approached in two ways:
    at runtime or at compile time. Runtime metaprogramming is available in dynamic
    languages such as Python, Javascript, and Lisp. For compiled languages, it''s
    not possible to generate instructions at runtime because these languages perform
    the ahead of time compilation of programs. However, you have the option of generating
    code at compile time, which is what C macros provide. Rust also provides compile
    time code generation capabilities, and these are more capable and sound than C
    macros.'
  prefs: []
  type: TYPE_NORMAL
- en: In many languages, metaprogramming constructs are often denoted by the umbrella
    term **macros**, which for some languages are a built-in feature. For others,
    they are provided as a separate compilation phase. In general, a macro takes an
    arbitrary sequence of code as input and outputs valid code that can be compiled
    or executed by the language, along with other code. The input to the macro doesn't
    need to be a valid syntax and you are free to define your own custom syntax for
    the macro input. Also, how you invoke a macro and the syntax for defining them
    is different across languages. For instance, C macros works at the preprocessor
    stage, which reads tags starting with `#define` and expands them before forwarding
    the source file to the compiler. Here, expanding means generating code by substituting
    inputs that are provided to the macro. Lisp, on the other hand, provides function-like
    macros that are defined with `defmacro` (a macro itself), which takes the name
    of the macro being created and one or more parameters, and returns new Lisp code.
    However, C and Lisp macros lack a property that's referred to as hygiene. They
    are non-hygienic in the sense that they can capture and interfere with code outside
    the macro upon expansion, which can lead to unexpected behavior and logical errors
    when the macro is invoked at certain places in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the problem with a lack of hygiene, we''ll take the example
    of a C macro. These macros simply copy/paste code with simple variable substitutions
    and are not context aware. Macros written in C are not hygienic in the sense that
    they can refer to variables defined anywhere, as long as those variables are in
    scope at the macro invocation site. For instance, the following is a macro `SWITCH`
    defined in C that can swap two values, but ignorantly modifies other values in
    doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this with `gcc c_macros.c -o macro && ./macro` gives the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, unless we declare our own `temp` variable inside the
    `SWITCH` macro, the original `temp` variable in `main` is modified by the expansion
    of the `SWITCH` macro. This unhygienic nature makes C macros unsound and brittle,
    and can easily make a mess unless special precautions are taken, such as using
    a different name for the `temp` variable within the macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust macros on the other hand are hygienic and also more context aware than
    just performing simple string substitution and expansion. They are aware of the
    scope of the variables that have been referenced within the macro and do not shadow
    any identifiers that have already been declared outside. Consider the following
    Rust program, which tries to implement the macro we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a macro called `switch!` and later invoked
    that in `main` with two values, `x` and `y`. We'll skip explaining the details
    in the macro definition, as we will cover them in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to our surprise, this doesn''t compile and fails with the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e46aaef8-a1c3-4398-8ed3-d837348112f8.png)'
  prefs: []
  type: TYPE_IMG
- en: From the error message, our `switch!` macro doesn't know anything about the
    `temp` variable that's declared in `main`. As we can see, Rust macros don't capture
    variables from their environment as they work differently compared to C macros.
    Even if it would have, we will be saved from modification as `temp` is declared
    immutable in the preceding program. Neat!
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into writing more macros like these in Rust, it's important to
    have an idea of when to use a macro-based solution for your problem and when not
    to!
  prefs: []
  type: TYPE_NORMAL
- en: When to use and not use Rust macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using macros is that they don't evaluate their arguments
    eagerly like functions do, which is one of the motivations to use macros other
    than functions.
  prefs: []
  type: TYPE_NORMAL
- en: By eager evaluation, we mean that a function call like `foo(bar(2))` will first
    evaluate `bar(2)` and then pass its value to `foo`. Contrary to that, this is
    a lazy evaluation, which is what you see in iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'A general *rule of thumb* is that macros can be used in situations where functions
    fail to provide the desired solution, where you have code that is quite repetitive,
    or in cases where you need to inspect the structure of your types and generate
    code at compile time. Taking examples from real use cases, Rust macros are used
    in a lot of cases, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting the language syntax by creating custom **Domain-Specific Languages**
    (**DSLs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing compile time serialization code, like serde does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving computation to compile-time, thereby reducing runtime overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing boilerplate test code and automating test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing zero cost logging abstractions such as the log crate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, macros should be used sparingly as they make the code difficult
    to maintain and reason about, as they work at the meta level and not many developers
    will be comfortable using them. They make the code harder to read and from a maintainability
    perspective, readability should always be preferred. Also, heavy use of macros
    can result in performance penalties due to a lot of duplicate code generation,
    which affects the CPU instruction cache.
  prefs: []
  type: TYPE_NORMAL
- en: Macros in Rust and their types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust macros do their magic of code generation before the program compiles to
    a binary object file. They take input, known as **token trees**, and are expanded
    at the end of the second pass of parsing during **Abstract Syntax Tree** (**AST**)
    construction. These are pieces of jargon from the compiler world and need some
    explanation, so let's do that. To understand how macros work, we need to be familiar
    with how source code is processed by the compiler to understand a program. This
    will help us in understanding how a macro processes its input and the error messages
    they emit when we use them incorrectly. We'll only cover parts that are relevant
    to our understanding of macros.
  prefs: []
  type: TYPE_NORMAL
- en: First, the compiler reads the source code byte by byte and groups characters
    into meaningful chunks, which are called **tokens**. This is done by a component
    of the compiler that's generally referred to as the **tokenizer**. Therefore,
    an `a + 3 * 6` expression gets converted to `"a", "+", "3", "*", "6"`, which is
    a sequence of tokens. Other tokens can be the `fn` keyword, any identifier, braces
    `{}` `()`, an assignment operator `=`, and so on. These tokens are called **token
    trees** in macro parlance. There are also tokens trees such as `"(", ")", "}","{"`,
    which can group other tokens. Now, at this stage, the token sequences by themselves
    don't convey any meaning on how to process and interpret the program. For that,
    we need a **parser**.
  prefs: []
  type: TYPE_NORMAL
- en: A parser converts this flat stream of tokens into a hierarchical structure that
    guides the compiler on how to interpret the program. The token trees are passed
    on to the parser, which constructs an in-memory representation of the program
    called the Abstract Syntax Tree. For instance, our sequence of tokens, `a + 3
    * 6`, which is an expression, can be evaluated with the value `20` when `a` is
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the compiler doesn''t know how to evaluate this expression correctly
    unless we separate the precedence of operators (that is, `*` comes before `+`)
    and represent them with a tree structure, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ae0a294-4e3c-4870-a569-9c690d823729.png)'
  prefs: []
  type: TYPE_IMG
- en: When we have represented the expression as a tree structure in code so that
    multiplication happens before addition, we can do a post order traversal of this
    tree to correctly evaluate the expression. So, given that explanation, where does
    our macro expansion fit here? Rust macros are parsed at the end of the second
    phase of Abstract Syntax Tree construction, which is a phase where name resolution
    happens. Name resolution is the stage where variables that are defined in the
    expression are looked up for their existence in the scope. In the preceding expression,
    name resolution will happen for the `a` variable. Now, if the `a` variable in
    our preceding expression was assigned a value from a macro invocation such as
    `let a = foo!(2 + 0);`, then the parser goes on to expand the macro before proceeding
    to the name resolution. The name resolution phase catches errors in the program,
    such as using a variable that is not in scope. However, there are more complex
    cases than this.
  prefs: []
  type: TYPE_NORMAL
- en: This entails Rust macros being context aware and, depending on what your macro
    expands into, they can only appear in supported places, as defined in the language's
    grammar. For example, you cannot write a `let` statement at the item level, that
    is, within a module.
  prefs: []
  type: TYPE_NORMAL
- en: Grammar defines valid ways to write programs, just like grammar in a spoken
    language guides construction of meaningful sentences. For those who are curious,
    Rust's grammar is defined at [https://doc.rust-lang.org/grammar.html](https://doc.rust-lang.org/grammar.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'One instance of macros that we''ve seen several times already is the `println!`
    macro. It is implemented as a macro because it allows Rust to check at compile
    time that its arguments are valid and that the string interpolation variables
    that have been passed to it are correct in number. Another advantage of using
    a macro for printing strings is that it allows us to pass as many arguments to
    `println!` as possible, which would not have been possible if it were implemented
    as a regular function. This is because Rust does not support variadic arguments
    for functions. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you already know, the second form will fail at compile time because it''s
    missing an argument that matches the format string. This is reported at compile
    time. In this way, it is far safer than C''s `printf` function, which can lead
    to memory vulnerabilities such as the format string attack. Other feature of the
    `println!` macro is that we can customize how we want to print values within strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can print the memory address and hexadecimal representation
    of the value stored in `a` via `"{:p}"` and `"{:x}"`, respectively. These are
    called **format specifiers**. We can also print non-primitive types in more of
    a JSON-like format with the `"{:#?}"` format specifier within `println!`. Let''s
    compile and run our preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ok, we have an error. As you may have noticed, in the first `println!` macro
    call, we are trying to print the address of `a` using the `"{:p}"` specifier,
    but the variable we mentioned is a number. We need to pass a reference such as `&a`
    to the format specifier. With that change, the preceding program compiles. All
    of this formatting and checking for proper values for string interpolation happens
    at compile time, thanks to the implementation of macros as part of the parsing
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Types of macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different forms of macros in Rust. Some allow you to call them like
    functions, while others allow you to conditionally include code, depending on
    compile-time conditions. Another class of macros allows you to implement traits
    on methods at compile time. They can be broadly divided into two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative macros:** These are the simplest form of macros. These are created
    using `macro_rules!`, which itself is a macro. They provide the same ergonomics
    of a calling a function, but are easily distinguished by a `!` at the end. They
    are the go-to approach for writing quick small macros within a project. The syntax
    for defining them is very similar to how you would write match expressions. They
    are called **declarative** in the sense that you already have a mini DSL, along
    with recognized token types and repetition constructs, using which you can declaratively
    express what code you want to generate. You don''t write how you generate the
    code as that is taken care of by the DSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedural macros****:** Procedural macros are a more advanced form of macros
    and give complete control over the manipulation and generation of code. These
    macros don''t come with any DSL support and are procedural in the sense that you
    have to write how you want the code to be generated or transformed for a given
    token tree input. The downside is that they are complex to implement and require
    a bit of understanding of compiler internals and how a program is represented
    in memory within the compiler. While `macro_rules!` can be defined anywhere in
    your project, procedural macros as of now are required to be created as separate
    crates with the special attribute of `proc-macro = true` in `Cargo.toml`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first macro with macro_rules!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with declarative macros first by building one using the `macro_rules!`
    macro. Rust already has the `println!` macro, which is used to print things to
    the standard output. However, it doesn''t have an equivalent macro for reading
    input from the standard input. To read from the standard input, you have to write
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines of code can be easily abstracted away with a macro. We''ll name
    our macro `scanline!`. Here''s the code that shows us how we want to use this
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to be able to create a `String` instance and just pass it to `scanline!`,
    which handles all the details of reading from standard input. If we compile the
    preceding code by running `rustc first_macro.rs`, we get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`rustc` cannot find the `scanline!` macro, because we haven''t defined it yet,
    so let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To create the `scanline!` macro, we use the `macro_rules!` macro, followed by
    the macro name `scanline!`, followed by a pair of braces. Within the braces, we
    have things that look similar to match arms. These are called **matching rules**.
    Every matching rule consists of three parts. The first is the pattern matcher,
    that is, the `($x:expr)` part, followed by a `=>`, and then the code generation
    block, which can be delimited either with `()`, `{}`, or even `[]`. A matching
    rule has to end with a semicolon when there is more than one rule to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, the notation on the left, `($x:expr)`, within parentheses
    is the rules, where `$x` is a token tree variable that needs to have a type specified
    after the colon `:`, which is an `expr` token tree type. Their syntax is similar
    to how we specify parameters in functions. When we invoke the `scanline!` macro
    with any token sequence as input, it gets captured in `$x` and is referred to
    by the same variable within the code generation block on the right. The `expr`
    token type means that this macro can only accept things that are expressions.
    We''ll cover other kinds of token types that are accepted by `macro_rules!` in
    a moment. In the code generation block, we have multi-line code to generate, so
    we have a pair of braces, which are there to account for multi-line expressions.
    The matching rule ends with a semicolon. We can also omit braces if we have a
    single line of code that needs to be generated. The generated code we want is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `read_line` accepts something that doesn''t look like a proper
    mutable reference to some identifier, that is, it''s a `&mut $x` . The `$x` gets
    substituted with an actual expression that we pass to our macro on invocation.
    That''s it; we just wrote our first macro! The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main`, we first create our `input` string, which will store our input from
    the user. Next, our `scanline!` macro is invoked where we pass the `input` variable.
    Within this macro, this is then referred to as `$x`, as we saw in the preceding
    definition. With the invocation of `scanline`, when the compiler sees the invocation,
    it replaces that with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output on running the preceding code with an input string of `Alice`
    from the standard input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Following code generation, the compiler also checks whether the generated code
    makes any sense. For example, if we were to invoke `scanline!` with some other
    item that is not accounted for in the matching rules (say, passing an `fn` keyword,
    such as `scanline!(fn)`), we would get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90c97a40-a22c-4879-b9f1-02275ad3edbb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, even if we pass an expression (say, `2`), which is valid to pass (as
    it''s also an `expr` ) to this macro but doesn''t make sense in this context,
    Rust will catch this and report as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7617a02-277a-4ed8-88d1-050170cb1e96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is neat! Now, we can also add multiple matching rules to our macro. So,
    let''s add an empty rule that covers the case where we just want `scanline!` to
    allocate the `String` for us, read from `stdin`, and return the string back. To
    add a new rule, we modify the code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We added an empty match rule, `() => {}`. Within the braces, we generate a
    bunch of code where we first create a `String` instance in `s`, call `read_line`,
    and pass `&mut s`. Finally, we return `s` to the caller. Now, we can call our
    `scanline!` without a pre-allocated `String` buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It's also important to note that we cannot invoke this macro anywhere outside
    functions. For instance, the `scanline!` invocation at the root of a module will
    fail, as it is invalid to write a `let` statement within a `mod {}` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in macros in the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from `println!`, there are other useful macros in the standard library
    that are implemented using the `macro_rules!` macro. Knowing about them will help
    us appreciate the places and situations where using a macro is a cleaner solution,
    while not sacrificing readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these macros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dbg!`: This allows you to print the value of expressions with their values.
    This macro moves whatever is passed to it, so if you only want to give read access
    to their types, you need to pass a reference to this macro instead. It''s quite
    handy as a tracing macro for expressions during runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compile_error!`: This macro can be used to report an error from code at compile
    time. This is a handy macro to use when you are building your own macro and want
    to report any syntactic or semantic errors to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concat!`: This macro can be used to concatenate any number of literals passed
    to it and returns the concatenated literals as a `&''static str`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env!`: This inspects an environment variable at compile time. In a lot of
    languages, accessing values from the environment variable is mostly done at runtime.
    In Rust, by using this macro, you can resolve environment variables at compile
    time. Note that this method panics when it cannot find the variable that''s defined,
    so a safe version of this is the `option_env!` macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eprint!` and `eprintln!`: This is similar to `println!`, but outputs messages
    to the standard error stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_bytes!`: This macro can be used as a quick way to read files as an
    array of bytes, such as `&''static [u8; N]`. The file path given to it is resolved
    relative to the current file in which this macro is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stringify!`: This macro is useful if you want to get a literal translation
    of a type or a token as a string. We''ll use this when we write our own procedural
    macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to explore the full set of macros that are available in the standard
    library, they can be found at [https://doc.rust-lang.org/std/#macros](https://doc.rust-lang.org/std/#macros).
  prefs: []
  type: TYPE_NORMAL
- en: macro_rules! token types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we build more complex macros, it's important to become familiar with
    the valid inputs that `macro_rules!` can take. Since `macro_rules!` work at the
    syntactic level, it needs to provide users, a handle to these syntactic elements,
    and distinguish what can and cannot be included within a macro and how we can
    interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some important token tree types that you can pass into a
    macro as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '`block`: This is a sequence of statements. We have already used `block` in
    the debugging example. It matches any sequence of statements, delimited by braces,
    such as what we were using before:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This block includes the statements `silly` and `things`.
  prefs: []
  type: TYPE_NORMAL
- en: '`expr`**:** This matches any expression, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x + 1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if x == 4 { 1 } else { 2 }`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ident`: This matches an identifier. Identifiers are any unicode strings that
    are not keywords (such as `if` or `let`). As an exception, the underscore character
    alone is not an identifier in Rust. Examples of identifiers are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long_identifier`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SomeSortOfAStructType`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`item`: This matches an item. Module-level things are idenitified as items**.**
    These include functions, use declarations, type definitions, and so on. Here are
    some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use std::io;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn main() { println!("hello") }`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const X: usize = 8;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These do not have to be one-liners, of course. The `main` function could be
    a single item, even if it spanned several lines.
  prefs: []
  type: TYPE_NORMAL
- en: '`meta`**:** A `meta` item. The parameters inside attributes are called meta
    items, which are captured by `meta`. The attributes themselves look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#![foo]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#[baz]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#[foo(bar)]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#[foo(bar="baz")]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Meta items are the things that are found inside brackets. So, for each of the
    preceding attributes, the corresponding meta items are as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baz`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo(baz)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo(bar="baz")`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pat`**:** This is a pattern. Match expressions have patterns on the left-hand
    side of each match, which `pat` captures. Here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"x"`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*t`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Some(t)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1 | 2 | 3`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1 ... 3`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`**:** It matches a qualified name**.** Paths are qualified names, that
    is, names with a namespace attached to them. They''re quite similar to identifiers,
    except that they allow the double colon in their names because they signify paths.
    Here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo::bar`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Foo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Foo::Bar::baz`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is useful in cases where you need to capture the path of some type so that
    you can use it later in code generation, such as when aliasing complex types with
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: '`stmt`**:** This is a statement. Statements are like expressions, except that
    more patterns are accepted by `stmt`. The following are some examples of this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let x = 1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1+2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast to the first example, `let x = 1` wouldn't be accepted by `expr.`
  prefs: []
  type: TYPE_NORMAL
- en: '`tt`**:** This is a token tree, which is a sequence of other tokens. The `tt`
    keyword captures a single token tree. A token tree is either a single token (such
    as `1`, `+`, or `"foo bar"`) or several tokens surrounded by any of the braces,
    `()`, `[]`, or `{}`. The following are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ bar; if x == 2 { 3 } else { 4 }; baz }`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ bar; fi x == 2 ( 3 ] ulse ) 4 {; baz }`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the insides of the token tree do not have to make semantic sense;
    they just have to be a sequence of tokens. Specifically, what does not match this
    are two or more tokens not enclosed in braces (such as `1 + 2`). This is the most
    general sequence of code or tokens `macro_rules!` can capture.
  prefs: []
  type: TYPE_NORMAL
- en: '`ty`: This is a Rust type. The `ty` keyword captures things that look like
    types. Here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u32`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u33`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No semantic checking that the type is actually a type is done in the macro
    expansion phase, so `"u33"` is accepted just as well as `"u32"`. However, once
    the code gets generated and goes to the semantic analysis phase, the type is checked,
    giving an error message of `` error: expected type, found `u33` ``. This is used
    when you are generating code to create a function or implementing methods of a
    trait on a type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`vis`: This represents a visibility modifier. This captures visibility modifiers `pub`,
    `pub(crate)`, and so on. This is helpful when you are generating module-level
    code and need to capture privacy modifiers in code fragments that have been passed
    to the macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lifetime`: Identifies a lifetime such as `''a`, `''ctx`, `''foo`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`literal`: A literal that can be any token, like a string literal such as `"foo"`
    or an identifier such as `bar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repetitions in macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from token tree types, we also need a way to repeatedly generate certain
    parts of our code. One of the practical examples from the standard library is
    the `vec![]` macro, which relies on repetition to give an illusion of variadic
    arguments, and allows you to create Vecs in any of the following manners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how `vec!` does this. Here''s vec''s `macro_rules!` definition from
    the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By ignoring the details to the right of `=>` and focusing on the last two matching
    rules on the left-hand side, we can see something new in these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are repeating rules. The repeating pattern rule follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pattern**: `$($var:type)*`. Notice the `$()*`. For the sake of referring
    to them, we''ll call them **repeaters**. Also, let''s denote the inner `($x:expr)`
    as `X`. Repeaters come in three forms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`, meaning the repetition needs to happen zero or more times'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`, meaning the repetition needs to happen at least one or more times'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`, meaning the token can repeat once at most'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeaters can also include extra literal characters that can be part of the
    repetition. In the case of `vec!`, there is the comma character, which we need
    to support to distinguish each element in `Vec` in the macro invocation.
  prefs: []
  type: TYPE_NORMAL
- en: In the first matching rule, the comma character is after `X`. This allows for
    expressions such as `vec![1, 2, 3,]`.
  prefs: []
  type: TYPE_NORMAL
- en: The second matching rule has the comma inside `X` after the elements. This is
    a typical case and will match sequences such as `1, 2, 3`. We needed two rules
    here because the first rule cannot account for cases such as where we don't have
    the trailing comma, which is the common case. Also, the patterns in `vec!` use
    `*`, which implies that `vec![]` is also an allowed invocation of the macro. With
    `+`, it wouldn't be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how the captured repetition rule is forwarded on the right-hand
    side in the code generation block. In the second matching rule, the `vec!` macro
    just forwards them into a `Box` type using an identical syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only difference we can see between the token tree variable declaration on
    the left-hand side and the usage on the right-hand side is that the right-hand
    side does not include the type (`expr`) of the token variable. The third matching
    rule just piggybacks on the second rule's code generation block and calls `vec![$($x),*]`,
    thus changing the comma placement and calling it again. This means that we can
    also call a macro within a macro, which is a really powerful feature. All of this
    can get pretty meta-level and you should aim for simpler maintainable macros as
    much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at how to build a macro that uses repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: A more involved macro – writing a DSL for HashMap initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Armed with the knowledge of repetitions and token tree types, let''s build
    something practical using repetitions in `macro_rules!`. In this section, we''ll
    build a crate that exposes a macro that allows you to create HashMaps such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is more concise and readable compared to manually calling `HashMap::new()`,
    followed by one or more `insert` calls. Let''s  create a new `cargo` project by
    running `cargo new macro_map --lib` with the initial block for `macro_rules!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want the users to use our macros, we need to add a `#[macro_export]`
    attribute on this macro definition. Macros are private by default in a module,
    which is similar to other items. We''ll call our macro `map!` and since we are
    building our own syntax to initialize HashMap, we''ll go with the `k => v` syntax,
    where `k` is the key and `v` is the value in our HashMap. Here''s our implementation
    within `map! {}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the matching rule here. First, we'll examine the inner part,
    which is `( $k:expr => $v:expr )`. Let's denote this part of the rule as `Y`.
    So, `Y` captures our key `k` and value `v` literals as `expr` with a `=>` in between
    them. Surrounding `Y`, we have `($(Y),*)`, which denotes the repetition of `Y`
    zero or more times, delimited by a comma. On the right of the matching rule within
    braces, we first create a `HashMap` instance. Then, we write the repeaters `$()*`,
    which have our `map.insert($k, $v)` code fragment within them, which will be repeated
    the same number of times as in our macro input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly write a test for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By running a cargo test, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Nice! Our test passes and we can now initialize HashMaps in a convenient way
    using our shiny new `map!` macro!
  prefs: []
  type: TYPE_NORMAL
- en: Macro use case – writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Macros are used quite a lot when writing test cases for unit tests. Let''s
    say you were writing a HTTP client library and you would like to test your client
    on various HTTP verbs such as `GET` or `POST` and on a variety of different URLs. The
    usual way you would write your tests is to create functions for each type of request
    and the URL. However, there''s a better way to do this. Using macros, you can
    cut down your testing time by many folds by building a small DSL to perform the
    tests, which is readable and can also be type checked at compiled time. To demonstrate
    this, let''s create a new crate by running `cargo new http_tester --lib`, which
    contains our macro definition. This macro implements a small language that''s
    designed for describing simple HTTP `GET`/`POST` tests to a URL. Here''s a sample
    of what the language looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first line makes a `GET` request to `duckduckgo.com`, and expects a return
    code of `200` (`Status Ok`). The second one makes a `POST` request to `httpbin.org`,
    along with form parameters `"key"="value"` with a custom syntax. It also expects
    a return code of `200`. This is very simplistic but sufficient for demonstration
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll assume that we already have our library implemented and will use a HTTP
    request library called `reqwest`. We''ll add a dependency on `reqwest` in our
    `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Within the macro definition, we just match on the rules, which is where `GET`
    and `POST` are treated as literal tokens. Within the arms, we create our request
    client and assert on the status code that's returned by the input, which is provided
    to the macro. The POST test case also has a custom syntax for providing query
    parameters such as `key => value`, which is collected as an array in the `params`
    variable. This is then passed to the `form` method of the `reqwest::post` builder
    method. We'll explore the request library more when we get to [Chapter 13](ea972b20-1dc0-46d2-a0b8-d4186b0fe2c7.xhtml),
    *Building Web Applications in Rust*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `cargo test` and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a moment to think about what the benefit of using a macro here is. This
    could be implemented as a `#[test]` annotated function call as well, but the macro
    has a few benefits, even in this basic form. One benefit is that the HTTP verb
    is checked at compile time and our tests are now more declarative. If we try to
    invoke the macro with a test case that is not accounted for (say, HTTP `DELETE`),
    we''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Apart from using them for enumerating tests cases, macros are also used to generate
    Rust code based on some outside environmental state (such as database tables,
    time and date, and so on). They can be used to decorate structures with custom
    attributes, generating arbitrary code for them at compile time, or to create new
    linter plugins for making additional static analysis that the Rust compiler itself
    does not support. A great example is the clippy lint tool, which we've used already.
    Macros are also used to generate code that invokes native C libraries. We'll see
    how that happens when we get to [Chapter 10](9e9ce701-5f35-4351-b76b-a5f2bd541059.xhtml),
    *Unsafe Rust and Foreign Function Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are already finding macros empowering, here are some exercises for you
    to try so that you can tinker with macros some more:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a macro that accepts the following language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the following strings would be acceptable in this language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Make the macro generate code that outputs a greeting that's directed to the
    recipient.
  prefs: []
  type: TYPE_NORMAL
- en: Write a macro that takes an arbitrary number of elements and outputs an unordered
    HTML list in a literal string, for instance, `html_list!([1, 2]) => <ul><li>1/<li><li>2</li></ul>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Procedural macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declarative macros can become tedious to read and maintain when your code generation
    logic becomes complex, as you need to write your logic with its own DSL to manipulate
    tokens. There are better, more flexible ways than using `macro_rules!`. For complex
    problems, you can leverage procedural macros as they are better suited to writing
    something non-trivial. They are suitable for cases where you need full control
    of code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'These macros are implemented as functions. These functions receive the macro
    input as a `TokenStream` type and return the generated code as a `TokenStream`
    after undergoing any transformation at compile time. To mark a function as a procedural
    macro, we need to annotate it with the `#[proc_macro]` attribute. At the time
    of writing this book, procedural macros come in three forms, which are categorized
    by how they are invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function-like procedural macros:** These use `#[proc_macro]` attribute on
    functions. The `lazy_static!` macro from the `lazy_static` crate uses function-like
    macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute-like procedural macros:** These use `#[proc_macro_attribute]` attribute
    on functions. The `#[wasm-bindgen]` attribute in the `wasm-bindgen` crate uses
    this form of macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Derive procedural macros:** These use `#[proc_macro_derive]`. These are the
    most frequently implemented macros in the majority of Rust crates, such as `serde`.
    They are also known as **derive macros** or **macros 1.1** due to the name of
    the RFC that introduced them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, the procedural macro API is very limited on
    what can be done with a `TokenStream`, so we need to use third-party crates such
    as `syn` and `quote` to parse the input as a Rust code data structure, which can
    then be analyzed according to your needs for code generation. Also, procedural
    macros need to be created as a separate crate with the special crate attribute
    of `proc-macro = true`, which is specified in `Cargo.toml`. To use the macro,
    we can depend on the macro in the same way as other crates by specifying it under
    dependencies in `Cargo.toml` and importing the macro with `use` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Among all three forms, derive macros are the most widely used form of procedural
    macros. We'll take a deep dive into them next.
  prefs: []
  type: TYPE_NORMAL
- en: Derive macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw that we can write `#[derive(Copy, Debug)]` on any struct, enum,
    or union type to get the `Copy` and `Debug` traits implemented for it, but this
    auto-derive feature is limited only to a few built-in traits in the compiler.
    With derive macros or macros 1.1, you get the ability to derive your own custom
    trait on any struct or enum or union type, thereby reducing the amount of boilerplate
    code that you would have written by hand. This may seem like a niche use case,
    but it is the most used procedural macro form, which high performance crates such
    as `serde` and `diesel` use. The derive macros only apply to data types such as
    structs, enums, or unions. Creating a custom derive macro for implementing a trait
    on a type requires the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need your type and the trait that you want to implement on the type.
    These can come from any crate, either locally defined or from a third party, provided
    that one of them has to be defined by you, because of the orphan rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to create a new crate with the `proc-macro` attribute set to `true`
    in `Cargo.toml`. This marks the crate as a procedural macro crate. This is done
    because procedural macros need to live in their own crate, as per the current
    implementation. This separation as a crate might change in the future, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, within this crate, we need to create a function that's annotated with
    the `proc_macro_derive` attribute. To the `proc_macro_derive` attribute, we pass
    in the trait name `Foo` as an argument. This function is what will get called
    when we write `#[derive(Foo)]` on any `struct`, `enum`, or `union`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only functions that have the `proc_macro_derive` attribute are allowed to be
    exported from this crate.
  prefs: []
  type: TYPE_NORMAL
- en: However, all of this is a bit vague until we see it in real code. So, let's
    build our own derive macro crate. The macro that we are going to build will be
    able to convert any given struct to a dynamic map of key values, such as `BTreeMap<String,
    String>`. The choice of `BtreeMaps` is just to have a sorted iteration on the
    fields, which is not the case with `HashMap`, though you can use hashmaps too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also make use of two crates, `syn` and `quote`, which will allow us
    to parse our code into a convenient data structure that we can examine and manipulate.
    We''ll build three crates for this project. First, we''ll create a binary crate
    by running `cargo new into_map_demo`, which uses our library crate and the derive
    macro crate. The following are the dependencies in our `Cargo.toml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `into_map` and `into_map_derive` crates are specified as local
    to this crate as path dependencies. However, we don''t have them yet, so let''s
    create them in the same directory by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo new into_map`: This crate will contain our trait as a separate library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cargo new into_map_derive`: This is our derive macro crate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s examine our `main.rs`, which contains the following initial code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have our `User` struct annotated with `#[derive(IntoMap)]`. `#[derive(IntoMap)]`
    will invoke our procedural macro from the `into_map_derive` crate. This does not
    compile as we don''t have the `IntoMap` derive macro implemented yet. However,
    this shows us how we want to use the macro as a consumer of this crate. Next,
    let''s see what we have in our `into_map` crate''s `lib.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our `lib.rs` file simply contains an `IntoMap` trait definition with a single
    method named `into_map` that takes a reference to `self` and returns a `BTreeMap<String,
    String>`. We want to derive the `IntoMap` trait for our `User` struct through
    our derive macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine our `into_map_derive` crate next. In this crate, we have the
    following dependencies in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned previously, we annotate the `[lib]` section with the `proc-macro`
    attribute set to `true`. We also use `syn` and `quote` as they help us parse Rust
    code from the `TokenStream` instance. The `syn` crate creates an in-memory data
    structure called the AST, which represents a piece of Rust code. We can then use
    this structure to examine our source code and extract information programmatically.
    The `quote` crate is a complement to the `syn` crate in the sense that it allows
    you to generate Rust code within the provided `quote!` macro, and also allows
    you to substitute values from `syn` data types. We also depend on the `into_map`
    crate, from where we bring the `IntoMap` trait into scope within our macro definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we want this macro to generate will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We want to implement the `into_map` method on our `User` struct, but we want
    it to be generated automatically for us. This is something that is quite tedious
    to hand code for cases where we have a struct with lots of fields. Derive macros
    are tremendously helpful in such cases. Let's look at an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, the code generation in the `into_map_derive` crate is divided
    into two phases. In the first phase, we iterate over the fields of the struct
    and collect code for inserting items into the `BTreeMap`. The generated `insert`
    code tokens will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will be collected into a vector. In the second phase, we take all of the
    generated `insert` code tokens and expand them into another token sequence, which
    is the `impl` block for the `User` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by exploring the implementation in `lib.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Whew, that's a lot of strange looking code! Let's go through this line by line.
    First, we have our `into_map_derive` function annotated with the `#[proc_macro_derive(IntoMap)]`
    attribute. We can give any name this function, though. This function receives
    a `TokenStream` as input, which will be our `User` struct declaration. We then
    create an `insert_tokens` list to store our input tokens, which is part of the
    actual code generation. We'll explain that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the `parse_macro_input!` macro from the `syn` crate, passing the
    `input` token stream. This gives us back a `DeriveInput` instance in the `parsed_input`
    variable. `parsed_input` represents our `User` struct definition as a token data
    structure. From that, we pull out the struct name with the `parsed_input.ident`
    field. Next, we match on the `parsed_input.data` field, which returns what kind
    of item it is: struct, enum, or union.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our implementation simpler, we are only implementing the `IntoMap`
    trait for structs, so we match only when our `parsed_input.data` is a `Data::Struct(s)`.
    The inner `s` is, again, a struct that represents the items that constitute a
    struct definition. We are interested in what fields `s` has, particularly named
    fields, so we use an `if let` to specifically match for that. Inside the `if`
    block, we get a reference to all the fields of our struct and then iterate over
    them. For each field, we generate an insert code for our `btree` map using the
    `quote!` macro from the `quote` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `#field` symbol. Within the `quote!` macro, we can have template
    variables that will be substituted with their value in the generated code. In
    this case, `#field` gets replaced with whatever field is present in our struct.
    First, we convert `#field` to a string literal by using the `stringify!` macro,
    which is an `Ident` type from the `syn` crate. We then push this generated chunk
    of code into the `insert_tokens` vec.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, we come to our final phase of code generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are finally generating our final `impl` block for our struct. Within
    the `quote!` block, whatever we write will be generated exactly as written, including
    the indentation and code comments. First, we do the imports of the `BtreeMap`
    type and the `IntoMap` trait. Then, we have the `IntoMap` implementation. Within
    that, we create our `map`, and just expand out the `insert_tokens` that we collected
    in the first phase of code generation. Here, the outer `#()*` repeater tells the
    `quote!` macro to repeat the same code zero or more times. For iterable items
    such as our `insert_tokens`, this will repeat all the items within it. This generates
    code for inserting the field name and field value from the struct into the `map`.
    Finally, we take the whole implementation code that''s stored in the `tokens`
    variable and return this as a `TokenStream` by calling `TokenStream::from(tokens)`.
    That''s it! Let''s try this macro in `main.rs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `cargo run` gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Great! It works. Next, let's look at how we can debug macros.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When developing complex macros, most of the time you need ways to analyze how
    your code expands to the inputs you gave to the macro. You can always use `println!`
    or `panic!` at the places you want to see the generated code, but it''s a very
    crude way to debug it. There''s are better way, though. The Rust community provides
    us with a subcommand called `cargo-expand`. This subcommand was developed by David
    Tonlay at [https://github.com/dtolnay/cargo-expand](https://github.com/dtolnay/cargo-expand),
    who is also the author of the `syn` and `quote` crates. This command internally
    calls the nightly compiler flag `-Zunstable-options --pretty=expanded`, but the
    design of the subcommand was done in such a way that it doesn''t require you to
    manually switch to the nightly tool chain as it finds and switches to it automatically.
    To demonstrate this command, we''ll take the example of our `IntoMap` derive macro
    and observe what code it generated for us. By switching into the directory and
    running `cargo expand`, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bdd3a71-91b6-49d8-b60c-0b9d50665e4e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `impl` block at the bottom is what was generated by the
    `IntoMap` derive macro. `cargo-expand` also includes pretty printed syntax highlighted
    output. This command is a must-have tool for someone writing complex macros.
  prefs: []
  type: TYPE_NORMAL
- en: Useful procedural macro crates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As procedural macros can be distributed as crates, a lot of emerging helpful
    macro crates are available, which can be found at `crates.io`. Using them can
    greatly reduce the boilerplate you need to write for generating Rust code. Some
    of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`derive-new`: A derive macro provides a default all-fields constructor for
    structs and is quite customizable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`derive-more`: A derive macro that circumvents the limitation where we wrap
    a type for which we already have a lot of traits auto-implemented, but lose the
    ability to create our own type wrapping for it. This crate helps us provide the
    same set of traits, even on these wrapper types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lazy_static`: This crate provides a function-like procedural macro called
    `lazy_static!`, where you can declare `static` values that require dynamically
    initialized types. For example, you can declare a configuration object as a `HashMap`
    and can access it globally across the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the metaprogramming abilities of Rust and looked
    at many kinds of macros. The most frequently used macro is `macro_rules!`, which
    is a declarative macro. Declarative macros work at the abstract syntax tree level,
    which means that they do not support arbitrary expansions, but require that the
    macro expansions are well-formed in the AST. For more complex use cases, you can
    use procedural macros where you get complete control of manipulating the input
    and generating the desired code. We also looked at ways to debug macros using
    the cargo subcommand `cargo-expand`.
  prefs: []
  type: TYPE_NORMAL
- en: Macros are indeed a powerful tool, but not something that should be used heavily.
    Only when the more usual mechanisms of abstraction such as functions, traits,
    and generics do not suffice for the problem at hand should we turn to macros.
    Also, macros make the code less readable for newcomers to a code base and should
    be avoided. Having said that, they are quite useful in writing test case conditions
    and are widely used by developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll get a glimpse of another side of Rust, the unsafe
    bits, which are less recommended but unavoidable if you want to interoperate Rust
    with different languages.
  prefs: []
  type: TYPE_NORMAL
