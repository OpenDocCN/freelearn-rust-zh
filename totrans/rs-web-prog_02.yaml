- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Your Web Application in Rust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously explored the syntax of Rust, enabling us to tackle memory management
    quirks and build data structures. However, as any experienced engineer will tell
    you, structuring code across multiple files and directories is an important aspect
    of building software.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build a basic command-line to-do program. We manage
    the dependencies needed to build our command-line program with Rust’s **Cargo**.
    Our program will be structured in a scalable way where we build and manage our
    own modules, which will be imported into other areas of the program and utilized.
    We will learn these concepts by building a to-do application spanning multiple
    files that create, edit, and delete to-do applications. This application will
    save our multiple to-do application files locally, and we will be able to interact
    with our application using a command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing a software project with Cargo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build applications in Rust that
    can be packaged and used. You will also be able to use third-party packages in
    your code. As a result, you will be able to build any command-line application
    that does not require a server or a graphical user interface if you understand
    the problem you are trying to solve and can break it down into logical chunks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we move toward building web apps in Rust, we are going to have to start
    relying on third-party packages to do some of the heavy lifting for us. Rust manages
    dependencies through a package manager called Cargo. To use Cargo, we are going
    to have to install Rust on our computer from the following URL: [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This installation provides the programming language Rust and the dependency
    manager Cargo. You can find all the code files on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02)'
  prefs: []
  type: TYPE_NORMAL
- en: Managing a software project with Cargo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start structuring our program with Cargo, we should build a basic
    single-file application. To do this, we initially must create a file called `hello_world.rs`
    in a local directory. The `.rs` extension denotes that the file is a Rust file.
    To be honest, it does not matter what the extension is. If there is viable Rust
    code written in that file, the compiler will compile and run it without any issues.
    However, having different extensions might confuse other developers and code editors
    and cause problems when importing code from other Rust files. So, it is best to
    use `.rs` when naming your Rust files. Inside our `hello_world.rs` file, we can
    have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is no different from our first code block in the previous chapter. Now
    that we have defined our entry point in our `hello_world.rs` file, we can compile
    the file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the compilation has finished, there will be a binary file in the same
    directory that can be run. If we compile it on Windows, we can run the binary
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile it on Linux or macOS, we can run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because we only built a simple `hello world` example, `hello world` will just
    be printed out. While this can be useful when building a simple application in
    one file, it is not recommended for managing programs spanning multiple files.
    It is not even recommended when relying on third-party modules. This is where
    Cargo comes in. Cargo manages everything, including the running, testing, documentation,
    building/compiling, and third-party module dependencies, out of the box with a
    few simple commands. We will cover these commands throughout this chapter. From
    what we have seen when running our `hello world` example, we must compile the
    code before we can run it, so let’s now move on to the next section where we build
    a basic application using Cargo.
  prefs: []
  type: TYPE_NORMAL
- en: Building with Cargo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building with Cargo is straightforward. All we must do is navigate to the directory
    where we want to build our project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command builds a basic Cargo Rust project. If we explore this
    application, we’ll see the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is only one Rust file, and this is the `main.rs` file
    that is housed in the `src` directory. If you open the `main.rs` file, you will
    see that this is the same as the file that we made in the previous section. It
    is an entry point with the default code printing out `hello world` to the console.
    The dependencies and metadata for our project are defined in the `Cargo.toml`
    file. If we want to run our program, we do not need to navigate to the `main.rs`
    file and run `rustc`. Instead, we can use Cargo and run it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do this, you will see the project compile and run with the following
    printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Your printout will be slightly different because the base directory will be
    different. At the bottom, you will see `hello world`, which is what we expect.
    We can also see that the printout states that the compilation is unoptimized and
    that it is running in `target/debug/web_app`. We can navigate directly to the
    `target/debug/web_app` binary and run it just like we did in the previous section
    as this is where the binary is stored. The `target` directory is where the files
    for compiling, running, and documenting our program reside. If we attach our code
    to a GitHub repository, we must make sure that the `target` directory is ignored
    by GitHub by putting it in the `.gitignore` file. Right now, we are running the
    unoptimized version. This means that it is slower but quicker to compile. This
    makes sense as when we are developing, we will be compiling multiple times. However,
    if we want to run the optimized version, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can see that our optimized binary is in the `target/release/web_app`
    path. Now that we have got our basic builds done, we can start to use Cargo to
    utilize third-party crates.
  prefs: []
  type: TYPE_NORMAL
- en: Shipping crates with Cargo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Third-party libraries are referred to as crates. Adding them and managing them
    with Cargo is straightforward. In this section, we will explore this process by
    utilizing the `rand` crate, available at [https://rust-random.github.io/rand/rand/index.html](https://rust-random.github.io/rand/rand/index.html).
    It must be noted that the documentation for this crate is clear and well structured
    with links to structs, traits, and modules. This is not a reflection of the rand
    crate itself. This is standard documentation for Rust that we will cover in the
    next section. To use this crate in our project, we open the `Cargo.toml` file
    and add the `rand` crate under the `[dependencies]` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve defined our dependency, we can use the `rand` crate to build
    a random number generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined a function called `generate_float`, which
    uses the crate to generate and return a float between `0` and `10`. Once we’ve
    done this, we print the number. The implementation of the `rand` crate is handled
    by the rand documentation. Our `use` statement imports the `rand` crate. When
    using the `rand` create for generating a float, the documentation tells us to
    import (`*`) from the `rand::prelude` module, which simplifies the importing of
    common items, as shown in the crate documentation at [https://rust-random.github.io/rand/rand/prelude/index.html](https://rust-random.github.io/rand/rand/prelude/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `ThreadRng` struct is a random number generator that generates an `f64`
    value between `0` and `1`, which is elaborated on in the rand crate documentation
    at [https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html](https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we get to see the power of the documentation. With a few clicks on the
    introduction page of the rand documentation, we can dig into the declarations
    of the structs and functions used in the demonstration. Now that our code is built,
    we can run our program with the `cargo run` command. While Cargo is compiling,
    it pulls code from the `rand` crate and compiles that into the binary. We can
    also note that there is now a `cargo.lock` file. As we know that `cargo.toml`
    is for us to describe our own dependencies, `cargo.lock` is generated by Cargo
    and we should not edit it ourselves as it contains exact information about our
    dependencies. This seamless functionality combined with the easy-to-use documentation
    shows how Rust improves the development process through marginal gains via the
    development ecosystem as well as the quality of the language. However, all these
    gains from the documentation are not purely dependent on the third-party libraries;
    we can also autogenerate our own documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting with Cargo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speed and safety are not the only benefits of picking a new language such as
    Rust to develop in. Over the years, the software engineering community keeps learning
    and growing. Simple things such as good documentation can make or break a project.
    To demonstrate this, we can define Markdown language within the Rust file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we’ve denoted the Markdown with the `///` markers. This
    does two things: it tells other developers who look at the code what the function
    does and renders Markdown in our autogeneration. Before we run the document command,
    we can define and document a basic user struct and a basic user trait to also
    show how these are documented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have documented a range of different structures, we can run the
    auto-documentation process with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the documentation is rendered in the same way as the rand crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Documentation view of the web app](img/Figure_2.1_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Documentation view of the web app
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we can see that **web_app** is a crate. We can
    also see that the documentation of the rand crate is involved (if we look at the
    bottom left of the screenshot, we can see the **rand** crate documentation just
    above our **web_app** crate documentation). If we click on the **User** struct,
    we can see the declaration of the struct, the Markdown that we wrote for the attributes,
    and the trait implications, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Documentation on struct](img/Figure_2.2_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Documentation on struct
  prefs: []
  type: TYPE_NORMAL
- en: It must be noted that in future sections of the book, we will not include Markdown
    in the code snippets to maintain readability. However, Markdown-documented code
    is provided in the book’s GitHub repo. Now that we have a well-documented, running
    Cargo project, we need to be able to pass parameters into it to enable different
    configurations to run depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Cargo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our program running and using third-party modules, we can
    start to interact with our Rust programs through command-line inputs. To enable
    our program to have some flexibility depending on the context, we need to be able
    to pass parameters into our program and keep track of the parameters in which
    the program is running. We can do this using the `std` (standard library) identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we collect the arguments passed into
    the program into a vector and then print out the arguments in debug mode. Let
    us run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command gives the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that our `args` vector has the arguments that we passed in.
    This is not surprising as many other languages also accept arguments passed into
    the program via the command line. We must note as well that the path to the binary
    is also included. Here, I also must highlight that I am using a different project
    named `interacting_with_cargo`, hence the `target/debug/interacting_with_cargo`
    path. We can also see from the command-line arguments that we are running in debug
    mode. Let us try to run a release version of our program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We would receive the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding output, we can see that `--release` is not in our vector.
    However, this does give us some extra functionality to play with. For instance,
    we might want to run different processes depending on the type of compilation.
    This can easily be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, the preceding simple solution is patchy. The `path` that we extract
    is only consistent if we are running Cargo commands. While Cargo commands are
    great for building, compiling, and documenting, it does not make sense to carry
    all those files around in production. In fact, there are advantages to extracting
    the static binary, wrapping it in a Docker container completely by itself, and
    running the binary directly as this can reduce the size of the Docker image from
    1.5 GB to 200 MB. So, while this might seem like a quick win, it can lead to breaking
    code when deploying our applications. Therefore, it is essential to put in the
    `panic` macro at the end to prevent this from reaching production and you not
    knowing about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have passed in some basic commands; however, this is not helpful
    or scalable. There would also be a lot of boilerplate code written for us to implement
    help guides for users. To scale our command-line interface, we can lean on the
    `clap` crate to handle arguments passed into the program, with the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To flesh out our understanding of command-line interfaces, we can develop a
    toy application that merely takes in a few commands and prints them out. To do
    this, we must import what we need from the `clap` crate in the `main.rs` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can move on to defining our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application houses metadata about the application in the `main` function
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we look at the documentation of `clap`, we can bind arguments directly to
    the `App` struct; however, this can get ugly and tightly bound. Instead, we will
    define them separately in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our toy app, we are taking in a first name, last name, and age, which can
    be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that we can keep stacking the arguments. Right now, they are not
    bound to anything. Now, we can move on to binding them to our application and
    passing in the arguments in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binding, getting, and parsing inputs can be achieved with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have a working example of how to pass command-line arguments, we
    can interact with our application to see how it displays by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The middle `--` before `--help` tells Cargo to pass all the arguments after
    `--` into `clap` as opposed to `cargo`. The preceding command will give us the
    following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we can see how to directly interact with our compiled
    binary file. We also have a nice help menu. To interact with Cargo, we need to
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will give the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the parsing works as we have two strings and an integer. The
    reason why crates such as `clap` are useful is that they are essentially self-documenting.
    Developers can look at the code and know what arguments are being accepted and
    view the metadata around them. Users can get help on the inputs by merely passing
    in the `help` parameter. This approach reduces the risk of the documentation becoming
    outdated as it is embedded in the code that executes it. If you accept command-line
    arguments, it is advised that you use a crate such as `clap` for this purpose.
    Now that we have explored structuring our command-line interface so it can scale,
    we can investigate structuring our code over multiple files to scale it in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now begin our journey of building a web application. In the rest of
    this chapter, we will not touch a web framework or build an HTTP listener. This
    will happen in the next chapter. However, we will construct a to-do module that
    will interact with a JSON file. It is going to be structured in such a way that
    it can be inserted into any web application that we build with minimal effort.
    This to-do module will enable us to create, update, and delete to-do items. We
    will then interact with this via the command line. The process here is to explore
    how to build well-structured code that will scale and be flexible. To gain an
    understanding of this, we will break down the building of this module into the
    following chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: Build structs for pending and done to-do items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a factory that enables the structs to be built in the module with minimal
    clean input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build traits that enable a struct to delete, create, edit, and get to-do items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a read-and-write-to-file module to store to-do items (we will replace
    this with a proper database in later chapters).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a `config` module that can alter the behavior of the application based
    on the variables in a `config` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we start tackling these steps, we need to get the application running.
    We can do this by navigating to the desired directory of where we want to house
    this application and start a new Cargo project called `todo_app`. Once this is
    done, we are going to put the logic that handles the management of to-do items
    in our `to_do` module. This can be achieved by creating a `to_do` directory and
    putting a `mod.rs` file at the base of this directory, as seen in the following
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: With this structure, we can start building out our `to_do` module starting with
    structs. Do not worry about the `to_do` file for now as this is covered in the
    first step, building structs for our done and pending to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Building to-do structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, we only have two structs for to-do items: ones that are waiting
    to be done and others that are already done. However, we might want to introduce
    other categories. For instance, we could add a backlog category, or an *on-hold*
    task for tasks that have been started but for one reason or another are blocked.
    To avoid mistakes and repetitive code, we can build a `Base` struct and have that
    be utilized by other structs. The `Base` struct houses common fields and functions.
    An alteration of the `Base` struct will propagate to all other to-do structs.
    We will also need to define the type of to-do item. We could hardcode in strings
    for pending and done; however, this is not scalable and is also error prone. To
    avoid this, we will use an enum to classify and define the presentation of the
    type of to-do item. To achieve this, we need to create the following file structure
    for our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can notice that we have two `mod.rs` files. These
    files are essentially where we declare our files, and what we define in them to
    make them accessible to other files in the same directory. We can also allow the
    files to be accessed outside of the directory if we publicly declare them in the
    `mod.rs` file. Before we write any code, we can see in *Figure 2**.3* how the
    data flows in our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The flow of data in our to-do module](img/Figure_2.3_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The flow of data in our to-do module
  prefs: []
  type: TYPE_NORMAL
- en: We see that our `Base` struct is used by our other to-do structs. The other
    to-do structs would not be able to access the `Base` struct if we did not declare
    it. However, no file outside the `to_do/structs` directory is referencing the
    `Base` struct, therefore it does not have to be a public declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the data flow for our module, we need to look back at
    *Figure 2**.3* and work out what we need to work on first. We can see that our
    enums have no dependencies. In fact, our enum supplies all the structs. Therefore,
    we will start with our enum in the `/to_do/enums.rs` file. Our enum is defining
    the status of the task with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This will work in the code when it comes to defining the status of the task.
    However, if we want to write to a file or database, we are going to have to build
    a method to enable our enum to be represented in a string format. To do this,
    we can implement a `stringify` function for our `TaskStatus` enum with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Calling this will enable us to print out the status of the to-do task in the
    console and write it in our JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `stringify` function works, there is another way to convert the value
    of the enum to a string. To achieve the string conversion, we can implement the
    `Display` trait for `TaskStatus`. First, we must import the format module with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then implement the `Display` trait for the `TaskStatus` struct with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This trait implementation has the same logic as our `stringify` function. However,
    our trait is utilized when needed. So, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that when we pass `TaskStatus` into `println!`, the `Display`
    trait is automatically utilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now make our enum publicly available in the `/to_do/mod.rs` file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now refer to *Figure 2**.3* to see what we can build next, which is
    the `Base` struct. We can define the `Base` struct in the `/to_do/structs/base.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: From the import at the top of the file, we can access the `TaskStatus` enum
    using `super::super`. We know that the `TaskStatus` enum is in a higher directory.
    From this, we can deduce that `super` gives us access to what is declared in the
    `mod.rs` file of the current directory. So, using `super::super` in a file in
    the `/to_do/structs/` directory gives us access to what is defined in the `/to_do/mod.rs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now declare our `Base` struct in our `/to_do/structs/mod.rs` file with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not have to declare it as public because our `Base` struct is not accessed
    outside of the `/to_do/structs/` directory. Now, looking back at *Figure 2**.3*,
    we can build our `Pending` and `Done` structs. This is when we use composition
    to utilize our `Base` struct in our `/to_do/structs/pending.rs` file with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Through the preceding code, we can see that our `super_struct` field houses
    our `Base` struct. We utilize our enum and define the status to be pending. This
    means that we only must pass the title into the constructor, and we have a struct
    with a title and a status of pending. Considering this, coding our `Done` struct
    should be straightforward in our `/to_do/structs/done.rs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is not much difference from the `Pending` struct definition
    apart from the `TaskStatus` enum having a `DONE` status. We can now make our structs
    available outside of the directory in the `/to_do/structs/mod.rs` file with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make our structs accessible in the `main.rs` file by declaring
    these structs in the `/to_do/mod.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now made a basic module and exposed it to the `main.rs` file. For now,
    we can write some basic code that will use our module to create a task that is
    pending and another that is completed. This can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have declared our `to_do` module.
    We then imported our structs and created a `pending` and `done` struct. Running
    our code will give us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This stops the `main.rs` file from being overloaded with excessive code. If
    we were to stack more types of items that can be created, such as the on-hold
    or backlog items, the code in `main.rs` would balloon. This is where factories
    come in, which we will explore in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Managing structs with factories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A factory pattern is where we abstract the construction of structs in an entry
    point of the module. We can see how this would work with our module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Flow of to-do factory](img/Figure_2.4_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Flow of to-do factory
  prefs: []
  type: TYPE_NORMAL
- en: 'What factories do is abstract the module by providing an interface. While we
    have enjoyed building our module, if another developer wanted to use it, a simple
    factory interface with good documentation would save them a lot of time. All they
    must do is pass in a few parameters and get the constructed structs out of the
    factory wrapped in an enum. If we change the internals of the module or it becomes
    more complicated, this will not matter. If other modules use the interface, the
    changes would not break the rest of the code if we keep the interfaces consistent.
    We can build our factory by defining our factory function in the `/to_do/mod.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we define an enum called `ItemTypes`,
    which packages the constructed task structs. Our `factory` function essentially
    accepts our inputted title and status. The factory then matches the inputted status.
    Once we have established what type of status was passed in, we build a task that
    matches the status and wraps it in the `ItemTypes` enum. This can grow and get
    more complicated, and our main file will be none the wiser. We can then implement
    this factory in our `main.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we pass into the factory the parameters
    we want to create for a to-do item, and then match the outcome to print the item’s
    attributes. There is more code now introduced into the `main.rs` file. However,
    there is more code because we are unwrapping the returned enum to print out the
    attributes for demonstrative purposes. We will usually pass this wrapped enum
    into other modules to handle. To create the struct, we only need one line of code,
    which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This means we can create a to-do item and pass it around with little hassle
    as it is wrapped in an enum. Other functions and modules must just accept the
    enum. We can see that this offers flexibility. However, as our code stands, we
    can do away with the `Base`, `Done`, and `Pending` structs and just have one struct
    that accepts the status and title. It would mean less code. However, it would
    also be less flexible. We are going to see how this is the case in our next step,
    where we add traits to our structs to lock down functionality and ensure safety.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functionality with traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Right now, our structs do not really do anything apart from holding the status
    and title of the task. However, our structs could have different functionality.
    Therefore, we have taken the extra trouble of defining individual structs. For
    instance, we are building a to-do application here. It is ultimately down to you
    how you structure your application, but it is not unreasonable to ensure that
    you cannot create a done task; otherwise, why are you adding it to your to-do
    list? This example might seem trivial. This book has used a to-do list to keep
    the problem that we are solving simple. Because of this, we can focus on the technical
    aspects of developing web applications in Rust without spending time understanding
    the problem we are solving. However, we must acknowledge that in more demanding
    applications, such as a system that processes bank transactions, we would need
    to be strict on how to implement our logic and lock down the possibility of any
    undesired processes happening. We can do this in our to-do application by building
    individual traits for each process and assigning them to task structs that we
    want. To do this, we will need to create a `traits` directory in our `to_do` module
    and a file for each trait, which will take the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then publicly define all the traits in the `to_do/traits/mod.rs` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also publicly define our traits in our `to_do/mod.rs` file with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all our trait files plumbed up in our module, we can start
    building our traits. We can start by defining our `Get` trait in the `to_do/traits/get.rs`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simply a demonstration of how we apply traits; therefore, we will just
    print out what is happening for now. We must remember that we cannot reference
    fields from the `&self` parameter passed in because we can apply our trait to
    multiple structs; however, we can overwrite the `get` function for the trait that
    implements this. When it comes to the `Edit` trait, we can have two functions
    that change the status in the `to_do/traits/edit.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a pattern here. So, for completeness, our `Create` trait takes the
    following form in the `to_do/traits/create.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Delete` trait is defined in the `to_do/traits/delete.rs` file with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now defined all the traits that we need. Thus, we can utilize them
    to define and lock down behavior in our to-do item structs. For our `Done` struct,
    we can import our traits into the `to_do/structs/done.rs` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then implement our `Done` struct in the same file after the definition
    of the `Done` struct with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `Done` struct can get, edit, and delete to-do items. Here, we can
    really see the power of traits as highlighted in [*Chapter 1*](B18722_01.xhtml#_idTextAnchor015),
    *A Quick Introduction to Rust*. We can stack on or remove traits easily. For instance,
    allowing done to-do items to be created would be achieved with a simple `impl
    Create for Done;`. Now that we have defined the traits that we want for our `Done`
    struct, we can move on to our `Pending` struct, importing what we need in the
    `to_do/structs/pending.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can implement these traits after the definition of our `Pending` struct
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that our `Pending` struct can get, edit,
    and create but cannot delete. Implementing these traits also ties our `Pending`
    and `Done` structs together without compiling them. For instance, if we accepted
    a struct that implemented the `Edit` trait, it would accept both the `Pending`
    and `Done` structs. However, if we were to create a function that accepted structs
    that implemented the `Delete` trait, it would accept the `Done` struct but reject
    the `Pending` struct. This gives us a beautiful symphony of aggressive type-checking
    yet flexibility, which is truly a testament to Rust’s design. Now that our structs
    have all the traits that we want, we can completely rewrite our `main.rs` file
    utilizing them. First, we import what we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The imports are important to note this time around. Although we have implemented
    our traits on the structs that we want, we will have to import the traits into
    the file that is using them. This can be a bit confusing. For example, calling
    the `get` function from the `Get` trait after a struct has been initialized would
    take the form of `item.get(&item.super_struct.title);`. The `get` function is
    tethered to the initialized struct. Intuitively, it makes sense not to need to
    import the trait. However, your compiler or IDE will give you the unhelpful error
    that the function named `get` is not found in the struct if you do not import
    the trait. This is important as we will use traits from database crates and web
    frameworks in the future and we will need to import these traits for the package
    structs to be used. With our imports, we can then utilize our traits and factory
    in the `main` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives us the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is build our own module, which contains an entry point.
    We’ve then imported it into the `main` function and run it. Now, the basic structure
    is built and working, but we need to get the module to interact with the environment
    by passing variables in and writing to a file to become useful.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To interact with the environment, we must manage two things. First, we need
    to load, save, and edit the state of to-do items. Second, we also must accept
    user input to edit and display data. Our program can achieve this by running the
    following steps for each process:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect arguments from the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a command (`get`, `edit`, `delete`, and `create`) and define a to-do
    title from commands being passed into the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load a JSON file that stores the to-do items from previous runs of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a `get`, `edit`, `delete`, or `create` function based on the command passed
    into the program, saving the result of the state in a JSON file at the end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can start making this four-step process possible by initially loading our
    state with the `serde` crate.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing JSON files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now at the stage where we are going to persist data in the form of a
    JSON file. We will upgrade this to a proper database in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127),
    *Data Persistence with PostgreSQL*. But for now, we are going to introduce our
    first dependency in our web application, which is `serde_json`. This `serde_json`
    crate handles the conversion of Rust data to JSON data and vice versa. We will
    use `serde_json` to process HTTP requests in the next chapter. We can install
    our crate in the `Cargo.toml` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeing as we are going to be upgrading our storage option in the future, it
    makes sense to keep the operations around reading and writing to our JSON file
    separate from the rest of the application. We do not want a lot of debugging and
    refactoring when we pull it out for our database upgrade. We will also keep it
    simple as there are no schema or migrations that must be managed when reading
    and writing to a JSON file. Considering this, all we will need are `read` and
    `write` functions. As our module is small and simple, we can house our module
    in just one file next to the `main.rs` file. First, we need to import what we
    need in our `src/state.rs` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we need the standard library and a series of structs to read
    the data as mapped out in *Figure 2**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Steps to read a JSON file](img/Figure_2.5_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Steps to read a JSON file
  prefs: []
  type: TYPE_NORMAL
- en: 'We can carry out the steps in *Figure 2**.5* with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we directly unwrap the opening of the
    file. This is because there is no point in continuing the program if we cannot
    read the file, and as a result, we directly unwrap the file read. We must also
    note that the string must be mutable as we are going to fill this string with
    JSON data. Additionally, we use the `serde_json` crate to process the JSON data
    and configure it into a map. We can now access our to-do items via this `Map`
    variable throughout the rest of the program. Now, we need to write our data, which
    can be done in the same file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we accept our `Map` variable and the path to the file.
    We then convert our `Map` variable into JSON using the `json!` macro from our
    `serde_json` crate. We then convert the JSON data to a string and then write it
    to our JSON file. Because of this, we now have functions to read and write to-do
    items to JSON files. We can now upgrade our `main.rs` file and build a simple
    command-line to-do application that reads and writes to-do items to a JSON file.
    We can interact with this using some basic arguments passed into the program with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collected the status and title from arguments passed into our program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the to-do items from the JSON file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printed out the to-do items from the JSON file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inserted our new to-do item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printed out the new set of to-do items from memory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Written our new to-do items list to our JSON file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our root path is going to be where the `Cargo.toml` file is, so we define an
    empty JSON file called `state.json` next to the `Cargo.toml` file. To interact
    with it, we can pass in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command would result in the following printout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can see that `washing` has been inserted. An inspection
    of our JSON file would also show that `washing` has been written to the file.
    You may have noticed that we have removed any mention of our `to_do` module, including
    all the structs and traits that we have built. We have not forgotten them. Instead,
    we are merely testing to see whether our interaction with the JSON file works
    before we try and fuse `to_do` with the `state` module. We will fuse the `to_do`
    and `state` modules by revising the traits implemented in our to-do structs in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have defined the module around managing the state of our to-do
    items in a JSON file, we have an idea of how our trait functions will process
    the data and interact with our JSON file. To start off, we can update our simplest
    trait, which is the `Get` trait in our `src/to_do/traits/get.rs` file. Here, we
    are merely getting the to-do item from our JSON map and printing it out. We can
    do this by simply passing the JSON map into our `get` function, getting the to-do
    item status from the map using the to-do item title from the state, and printing
    it out to the console with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that we perform a `get` function on our JSON
    `Map`, matching the outcome and printing out what we extract. This means that
    any to-do item that implements the `Get` trait can now extract a to-do item from
    our state and print it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move on to the next step in complexity, which is the `Create` trait
    in our `src/to_do/traits/create.rs` file. This is slightly more complex than our
    `Get` trait because we edit the state by inserting the new to-do item and then
    writing this updated state into our JSON. We can carry out these steps with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have used the `write_to_file` function
    from the `state` module to save our state to the JSON file. We can use the `create`
    function as a template for what we need to do when deleting a to-do item. Deleting
    is essentially the inverse of what we have done in our `create` function. You
    can try to write the `delete` function for the `Delete` trait in the `src/to_do/traits/delete.rs`
    file now before moving on if you want. Your function may look different; however,
    it should run along the same lines as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are merely using the `remove` function on our JSON
    `Map`, writing the updated state to our JSON file. We are near the end of the
    section. All we need to do now is build our `edit` function for our `Edit` trait
    in the `src/to_do/traits/edit.rs` file. We have two functions. One will set the
    to-do item status to `DONE`. The other function will set the to-do item status
    to `PENDING`. These will be achieved by updating the state and then writing the
    updated state to the JSON file. You can try and write this yourself before reading
    on. Hopefully, your code will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Our traits can now interact without the JSON file, carrying out the processes
    that we initially wanted them to do. There is nothing stopping us from utilizing
    these traits directly in the `main.rs` file as we did when we first defined these
    traits. However, this is not scalable. This is because we will essentially be
    building a web application with multiple views and API endpoints. Therefore, we
    will be interacting with these traits and storage processes in multiple different
    files. Therefore, we are going to have to come up with a way to interact with
    these traits in a standardized way without having to repeat code, which we will
    do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing traits and structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable our code to interact with a simple interface, enabling us to update
    with minimal pain and reduce repeated code and thus errors, we need a processes
    layer, as seen in *Figure 2**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Trait flow through a processes module](img/Figure_2.6_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Trait flow through a processes module
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.6*, we can see that our structs are bound to the traits in a
    loose fashion and that the data flow to and from the JSON goes through the traits.
    We can also see that we have one entry point in the `processes` module, which
    will then direct commands to the correct traits, which in turn will access the
    JSON file as and when needed. Seeing as we have defined our traits, all we need
    to do is build our `processes` module, connect it to the traits, and then connect
    it to our `main.rs` file. We will be building our entire `processes` module in
    a single `src/processes.rs` file. We are keeping it to a single file because we
    will be removing it when we cover databases. There is no need to take on too much
    technical debt if we know we are going to be removing it in the future. For now,
    we can start building our `processes` module by initially importing all the structs
    and traits that we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start to build non-public functions. We can start by processing
    our `Pending` structs. We know that we can either get, create, or edit pending
    to-do items, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we have ingested the `Pending` struct,
    command, and current state of our to-do items. We then match the command and execute
    the trait associated with that command. If there the command that is passed in
    is neither `get`, `create`, or `edit`, we do not support it, throwing an error
    that tells the user what command is not supported. This is scalable. For instance,
    if we allow a `Pending` struct to delete a to-do item from the JSON file, we merely
    must implement the `Delete` trait for the `Pending` struct and then add the `delete`
    command to our `process_pending` function. This would only take two lines of code
    in total, and this change would take effect throughout the application. This would
    also happen if we removed a command. We now have a flexible implementation of
    our `Pending` struct. With this in mind, you can choose to code our `process_done`
    function before reading on. If you have chosen to do so, hopefully, it will look
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now process both our structs. This is where the scalability of structs
    comes in when designing our module. Like the commands, we will want to stack our
    structs just like we did with our traits. This is where our entry point comes
    in, as seen in *Figure 2**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Scalability of processes](img/Figure_2.7_B18722.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Scalability of processes
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see from *Figure 2**.7* that we can scale the access to structs by increasing
    the routes by the entry point. To appreciate this more, we should define our entry
    point, which this time is a public function, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we can see that we route to the correct struct with
    the `ItemTypes` enum. Our module can process more structs by adding the new struct
    to the `ItemTypes` enum, writing a new function that processes that struct in
    the `processes` module, and then applying the desired traits to the struct. Our
    `processes` module is now fully completed, and we can rewrite our `main.rs` file
    to utilize it. First of all, we import what we need with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'With these imports, we can see that we are going to be reading the data from
    the JSON file, using `to_do_factory` to create the structs from the input collected
    from the environment, and passing this into our `processes` module to update the
    JSON file. This is a good point in time to stop reading and try to code out this
    process by yourself. Remember, you must get the data from the JSON file and check
    to see whether the title of the to-do item is already stored in the JSON file.
    If we cannot find the title in the data from the JSON file, we then know that
    it is going to be a pending status as we cannot create a done task. If you chose
    to do this, your code hopefully looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run anything, you might have realized that we created an instance
    of the `TaskStatus` using the `from_string` function. We have not built the `from_string`
    function yet. At this point you should be able to build it yourself in the `impl
    TaskStatus` block. If you have attempted to build the `from_string` function,
    it should look like the following code in the `src/to_do/enums.rs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have managed to utilize the interfaces that we have created to get our
    program running, then well done. We can see now that we orchestrate a range of
    processes in our `main` function with ease. We can interact with our program with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a to-do item called `washing` in our JSON file
    with the status of pending. All our other traits are supported, and we can carry
    them out in the command line as well. We have now built a basic command application
    that stores to-do items in a JSON file. However, it is not just a basic command-line
    application. We have structured our modules so they are scalable and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have essentially done in this chapter is build a program that accepts
    some command-line inputs, interacts with a file, and edits it depending on the
    command and data from that file. The data is simple: a title and a status. We
    could have done this all in the `main` function with multiple `match` statements
    and `if`, `else if`, and `else` blocks. However, this is not scalable. Instead,
    we built structs that inherited other structs, which then implemented traits.
    We then packaged the construction of these structs into a factory, enabling other
    files to use all that functionality in a single line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: We then built a processing interface so the command input, state, and struct
    could be processed, enabling us to stack on extra functionality and change the
    flow of the process with a few lines of code. Our main function must only focus
    on collecting the command-line arguments and coordinating when to call the module
    interfaces. We have now explored and utilized how Rust manages modules, giving
    us the building blocks to build real-world programs that can solve problems and
    add features without being hurt by tech debt and a ballooning `main` function.
    Now that we can do this, we are ready to start building scalable web apps that
    can grow. In the next chapter, we will learn about the **Actix Web framework**
    to get a basic web server up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does the `--release` argument in Cargo do when added to a build and run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we enable a file to be accessible within and outside the module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of having traits with a single scope?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What steps would we have to take to add an `OnHold` to-do item that will only
    allow `Get` and `Edit` functionality?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of a factory function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we effectively map a range of processes based on some processes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a build, the `--release` argument compiles the program in an optimized way
    as opposed to a debug compilation. In a run, the `--release` argument points to
    an optimized binary as opposed to the debug binary. An optimized binary takes
    longer to compile but will run at a faster pace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable a file to be accessible to other files in a module, we must define
    the file as a module in the `mod.rs` file at the root of the module. We add `mod`
    before the definition to make it accessible outside the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Single-scope traits enable maximum flexibility when defining structs. A good
    example would be adding an `OnHold` to-do item. With this item, we might only
    allow it to have an edit trait, which we can do by implementing the single-scoped
    `Edit` trait. If we had one trait that did all the functions, this would not be
    possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a struct in its own file in structs that inherit from the base struct,
    which also implements the `Get` and `Edit` traits. Add a `hold` type to the enum
    in the factory file. Add another line in the `match` statement for the entry point
    in the processes that point to a new function processing the `OnHold` item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The factory function standardizes the construction of structs. It also reduces
    the possibility of building one of a range of structs outside of the module with
    just one line of code. This stops other files from ballooning and does not require
    the developer to look around in the module to utilize it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `match` statements that lead to other `match` statements. This enables
    us to code a tree-like effect and there is nothing stopping us from connecting
    branches later down the chain. This is demonstrated in *Figure 2**.7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2:Processing Data and Managing Displays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can build applications in Rust, we need to be able to handle HTTP
    requests. By the end of this part, you will know how to handle HTTP requests and
    route them. You will also be able to extract data from the request body and header.
    You will also structure the application so routing can scale and implement middleware
    to process and route HTTP requests before the view is loaded. Finally, you will
    understand how to display content in the browser by directly serving HTML, CSS,
    and JavaScript from the server. We will also explore a basic React application
    and wrap it in Electron to have a desktop application to talk to our Rust server.
    At this point, you will have learned everything to run a basic application without
    a proper database or authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP Requests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18722_04.xhtml#_idTextAnchor073), *Processing HTTP Requests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18722_05.xhtml#_idTextAnchor091), *Displaying Content in the
    Browser*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
