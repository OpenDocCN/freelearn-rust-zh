- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Designing Your Web Application in Rust
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rust中设计你的Web应用
- en: We previously explored the syntax of Rust, enabling us to tackle memory management
    quirks and build data structures. However, as any experienced engineer will tell
    you, structuring code across multiple files and directories is an important aspect
    of building software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经探讨了Rust的语法，使我们能够处理内存管理的怪癖并构建数据结构。然而，正如任何经验丰富的工程师会告诉你的，在多个文件和目录间结构化代码是构建软件的一个重要方面。
- en: In this chapter, we will build a basic command-line to-do program. We manage
    the dependencies needed to build our command-line program with Rust’s **Cargo**.
    Our program will be structured in a scalable way where we build and manage our
    own modules, which will be imported into other areas of the program and utilized.
    We will learn these concepts by building a to-do application spanning multiple
    files that create, edit, and delete to-do applications. This application will
    save our multiple to-do application files locally, and we will be able to interact
    with our application using a command-line interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个基本的命令行待办事项程序。我们使用Rust的**Cargo**来管理构建我们的命令行程序所需的依赖项。我们的程序将以可扩展的方式构建和管理我们的模块，这些模块将被导入到程序的其它区域并使用。我们将通过构建一个跨越多个文件、创建、编辑和删除待办事项应用的待办事项应用来学习这些概念。此应用将本地保存我们的多个待办事项应用文件，并且我们可以通过命令行界面与我们的应用进行交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Managing a software project with Cargo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cargo管理软件项目
- en: Structuring code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化代码
- en: Interacting with the environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与环境交互
- en: By the end of this chapter, you will be able to build applications in Rust that
    can be packaged and used. You will also be able to use third-party packages in
    your code. As a result, you will be able to build any command-line application
    that does not require a server or a graphical user interface if you understand
    the problem you are trying to solve and can break it down into logical chunks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够构建可以在Rust中打包和使用的应用。你还将能够在你的代码中使用第三方包。结果，如果你理解你试图解决的问题并且能够将其分解为逻辑块，你将能够构建任何不需要服务器或图形用户界面的命令行应用。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we move toward building web apps in Rust, we are going to have to start
    relying on third-party packages to do some of the heavy lifting for us. Rust manages
    dependencies through a package manager called Cargo. To use Cargo, we are going
    to have to install Rust on our computer from the following URL: [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始使用Rust构建Web应用，我们将不得不开始依赖第三方包来为我们做一些繁重的工作。Rust通过一个名为Cargo的包管理器来管理依赖项。要使用Cargo，我们必须从以下URL安装Rust到我们的计算机上：[https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install)。
- en: 'This installation provides the programming language Rust and the dependency
    manager Cargo. You can find all the code files on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此安装提供了编程语言Rust和依赖项管理器Cargo。你可以在GitHub上找到所有代码文件：
- en: '[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02](https://github.com/PacktPublishing/Rust-Web-Programming-2nd-Edition/tree/main/chapter02)'
- en: Managing a software project with Cargo
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cargo管理软件项目
- en: 'Before we start structuring our program with Cargo, we should build a basic
    single-file application. To do this, we initially must create a file called `hello_world.rs`
    in a local directory. The `.rs` extension denotes that the file is a Rust file.
    To be honest, it does not matter what the extension is. If there is viable Rust
    code written in that file, the compiler will compile and run it without any issues.
    However, having different extensions might confuse other developers and code editors
    and cause problems when importing code from other Rust files. So, it is best to
    use `.rs` when naming your Rust files. Inside our `hello_world.rs` file, we can
    have the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Cargo来结构化我们的程序之前，我们应该构建一个基本的单文件应用。为此，我们最初必须在本地目录中创建一个名为`hello_world.rs`的文件。`.rs`扩展名表示该文件是一个Rust文件。说实话，扩展名并不重要。如果在该文件中编写了有效的Rust代码，编译器将无任何问题地编译并运行它。然而，使用不同的扩展名可能会让其他开发者和代码编辑器感到困惑，并在从其他Rust文件导入代码时引起问题。因此，在命名你的Rust文件时最好使用`.rs`。在我们的`hello_world.rs`文件中，我们可以有以下的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is no different from our first code block in the previous chapter. Now
    that we have defined our entry point in our `hello_world.rs` file, we can compile
    the file with the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一章中的第一个代码块没有区别。现在我们已经在我们的`hello_world.rs`文件中定义了入口点，我们可以使用以下命令来编译文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the compilation has finished, there will be a binary file in the same
    directory that can be run. If we compile it on Windows, we can run the binary
    with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译完成，同一目录下将会有一个二进制文件，可以运行。如果我们是在Windows上编译，我们可以使用以下命令来运行这个二进制文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we compile it on Linux or macOS, we can run it with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Linux或macOS上编译它，我们可以使用以下命令来运行它：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we only built a simple `hello world` example, `hello world` will just
    be printed out. While this can be useful when building a simple application in
    one file, it is not recommended for managing programs spanning multiple files.
    It is not even recommended when relying on third-party modules. This is where
    Cargo comes in. Cargo manages everything, including the running, testing, documentation,
    building/compiling, and third-party module dependencies, out of the box with a
    few simple commands. We will cover these commands throughout this chapter. From
    what we have seen when running our `hello world` example, we must compile the
    code before we can run it, so let’s now move on to the next section where we build
    a basic application using Cargo.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只构建了一个简单的`hello world`示例，所以`hello world`将直接打印出来。虽然当在一个文件中构建简单应用程序时这很有用，但不建议用于管理跨多个文件的程序。即使在依赖第三方模块时，也不推荐这样做。这就是Cargo发挥作用的地方。Cargo通过一些简单的命令，开箱即用地管理一切，包括运行、测试、文档、构建/编译以及第三方模块依赖项。我们将在本章中介绍这些命令。从我们运行`hello
    world`示例时看到的情况来看，我们必须在运行代码之前编译它，所以现在让我们继续到下一节，在那里我们将使用Cargo构建一个基本的应用程序。
- en: Building with Cargo
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Cargo进行构建
- en: 'Building with Cargo is straightforward. All we must do is navigate to the directory
    where we want to build our project and run the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cargo进行构建很简单。我们只需导航到我们想要构建项目的目录，并运行以下命令：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command builds a basic Cargo Rust project. If we explore this
    application, we’ll see the following structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令构建了一个基本的Cargo Rust项目。如果我们探索这个应用程序，我们会看到以下结构：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that there is only one Rust file, and this is the `main.rs` file
    that is housed in the `src` directory. If you open the `main.rs` file, you will
    see that this is the same as the file that we made in the previous section. It
    is an entry point with the default code printing out `hello world` to the console.
    The dependencies and metadata for our project are defined in the `Cargo.toml`
    file. If we want to run our program, we do not need to navigate to the `main.rs`
    file and run `rustc`. Instead, we can use Cargo and run it with the following
    command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到只有一个Rust文件，这就是位于`src`目录中的`main.rs`文件。如果你打开`main.rs`文件，你会看到这与我们在上一节中制作的文件相同。这是一个入口点，默认代码将`hello
    world`打印到控制台。我们项目的依赖项和元数据定义在`Cargo.toml`文件中。如果我们想要运行我们的程序，我们不需要导航到`main.rs`文件并运行`rustc`。相反，我们可以使用Cargo并使用以下命令来运行它：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you do this, you will see the project compile and run with the following
    printout:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做时，你会看到项目按照以下打印输出进行编译和运行：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your printout will be slightly different because the base directory will be
    different. At the bottom, you will see `hello world`, which is what we expect.
    We can also see that the printout states that the compilation is unoptimized and
    that it is running in `target/debug/web_app`. We can navigate directly to the
    `target/debug/web_app` binary and run it just like we did in the previous section
    as this is where the binary is stored. The `target` directory is where the files
    for compiling, running, and documenting our program reside. If we attach our code
    to a GitHub repository, we must make sure that the `target` directory is ignored
    by GitHub by putting it in the `.gitignore` file. Right now, we are running the
    unoptimized version. This means that it is slower but quicker to compile. This
    makes sense as when we are developing, we will be compiling multiple times. However,
    if we want to run the optimized version, we can use the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的打印输出将略有不同，因为基本目录将不同。在底部，您将看到`hello world`，这是我们预期的。我们还可以看到打印输出表明编译未优化，并且它在`target/debug/web_app`中运行。我们可以直接导航到`target/debug/web_app`二进制文件并像上一节那样运行它，因为这是二进制文件存储的位置。`target`目录是编译、运行和记录我们程序文件的存放位置。如果我们把代码附加到GitHub仓库，我们必须确保通过在`.gitignore`文件中将其放置来让GitHub忽略`target`目录。目前，我们正在运行未优化的版本。这意味着它运行较慢但编译更快。这在开发时是有意义的，因为我们将多次编译。然而，如果我们想运行优化版本，我们可以使用以下命令：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command gives us the following printout:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令给出了以下打印输出：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding output, we can see that our optimized binary is in the `target/release/web_app`
    path. Now that we have got our basic builds done, we can start to use Cargo to
    utilize third-party crates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们的优化二进制文件位于`target/release/web_app`路径。现在我们已经完成了基本构建，我们可以开始使用Cargo来利用第三方crate。
- en: Shipping crates with Cargo
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Cargo打包crate
- en: 'Third-party libraries are referred to as crates. Adding them and managing them
    with Cargo is straightforward. In this section, we will explore this process by
    utilizing the `rand` crate, available at [https://rust-random.github.io/rand/rand/index.html](https://rust-random.github.io/rand/rand/index.html).
    It must be noted that the documentation for this crate is clear and well structured
    with links to structs, traits, and modules. This is not a reflection of the rand
    crate itself. This is standard documentation for Rust that we will cover in the
    next section. To use this crate in our project, we open the `Cargo.toml` file
    and add the `rand` crate under the `[dependencies]` section, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方库被称为crate。添加它们并使用Cargo管理它们是直接的。在本节中，我们将通过利用位于[https://rust-random.github.io/rand/rand/index.html](https://rust-random.github.io/rand/rand/index.html)的`rand`
    crate来探索这个过程。必须注意的是，这个crate的文档清晰且结构良好，包含对结构体、特性和模块的链接。这并不是对rand crate本身的反映。这是Rust的标准文档，我们将在下一节中介绍。为了在我们的项目中使用这个crate，我们打开`Cargo.toml`文件，并在`[dependencies]`部分下添加`rand`
    crate，如下所示：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we’ve defined our dependency, we can use the `rand` crate to build
    a random number generator:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的依赖项，我们可以使用`rand` crate来构建一个随机数生成器：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have defined a function called `generate_float`, which
    uses the crate to generate and return a float between `0` and `10`. Once we’ve
    done this, we print the number. The implementation of the `rand` crate is handled
    by the rand documentation. Our `use` statement imports the `rand` crate. When
    using the `rand` create for generating a float, the documentation tells us to
    import (`*`) from the `rand::prelude` module, which simplifies the importing of
    common items, as shown in the crate documentation at [https://rust-random.github.io/rand/rand/prelude/index.html](https://rust-random.github.io/rand/rand/prelude/index.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`generate_float`的函数，它使用crate生成并返回一个介于`0`和`10`之间的浮点数。一旦我们完成这个操作，我们就打印这个数字。`rand`
    crate的实现由rand文档处理。我们的`use`语句导入了`rand` crate。当使用`rand` crate生成浮点数时，文档告诉我们从`rand::prelude`模块导入（`*`），这简化了常见项的导入，如crate文档所示，请参阅[https://rust-random.github.io/rand/rand/prelude/index.html](https://rust-random.github.io/rand/rand/prelude/index.html)。
- en: The `ThreadRng` struct is a random number generator that generates an `f64`
    value between `0` and `1`, which is elaborated on in the rand crate documentation
    at [https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html](https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadRng`结构体是一个随机数生成器，它生成一个介于`0`和`1`之间的`f64`值，这在rand crate文档中有详细说明，请参阅[https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html](https://rust-random.github.io/rand/rand/rngs/struct.ThreadRng.html)。'
- en: Now, we get to see the power of the documentation. With a few clicks on the
    introduction page of the rand documentation, we can dig into the declarations
    of the structs and functions used in the demonstration. Now that our code is built,
    we can run our program with the `cargo run` command. While Cargo is compiling,
    it pulls code from the `rand` crate and compiles that into the binary. We can
    also note that there is now a `cargo.lock` file. As we know that `cargo.toml`
    is for us to describe our own dependencies, `cargo.lock` is generated by Cargo
    and we should not edit it ourselves as it contains exact information about our
    dependencies. This seamless functionality combined with the easy-to-use documentation
    shows how Rust improves the development process through marginal gains via the
    development ecosystem as well as the quality of the language. However, all these
    gains from the documentation are not purely dependent on the third-party libraries;
    we can also autogenerate our own documentation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到了文档的强大功能。通过在 rand 文档的介绍页上点击几下，我们可以深入了解演示中使用的结构和函数的声明。现在我们的代码已经构建完成，我们可以使用
    `cargo run` 命令运行我们的程序。当 Cargo 编译时，它会从 `rand` crate 中提取代码并将其编译成二进制文件。我们还可以注意到现在有一个
    `cargo.lock` 文件。正如我们所知，`cargo.toml` 是用来描述我们自己的依赖项的，而 `cargo.lock` 是由 Cargo 生成的，我们不应该自己编辑它，因为它包含有关我们依赖项的精确信息。这种无缝的功能结合易于使用的文档展示了
    Rust 如何通过开发生态系统以及语言的质量通过边际收益来改善开发过程。然而，所有这些来自文档的收益并不完全依赖于第三方库；我们还可以自动生成自己的文档。
- en: Documenting with Cargo
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cargo 进行文档化
- en: 'Speed and safety are not the only benefits of picking a new language such as
    Rust to develop in. Over the years, the software engineering community keeps learning
    and growing. Simple things such as good documentation can make or break a project.
    To demonstrate this, we can define Markdown language within the Rust file with
    the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选择像 Rust 这样的新语言进行开发，速度和安全性并非唯一的益处。多年来，软件工程社区一直在学习和成长。像良好的文档这样的简单事情可以成就或毁掉一个项目。为了证明这一点，我们可以在
    Rust 文件中使用以下代码定义 Markdown 语言：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we’ve denoted the Markdown with the `///` markers. This
    does two things: it tells other developers who look at the code what the function
    does and renders Markdown in our autogeneration. Before we run the document command,
    we can define and document a basic user struct and a basic user trait to also
    show how these are documented:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `///` 标记表示 Markdown。这做了两件事：它告诉查看代码的其他开发者函数的作用，并在我们的自动生成中渲染 Markdown。在我们运行文档命令之前，我们可以定义和记录一个基本的用户结构和一个基本的用户特质，以展示这些是如何被记录的：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have documented a range of different structures, we can run the
    auto-documentation process with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经记录了一系列不同的结构，我们可以使用以下命令运行自动文档化过程：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see that the documentation is rendered in the same way as the rand crate:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，文档的渲染方式与 rand crate 相同：
- en: '![Figure 2.1 – Documentation view of the web app](img/Figure_2.1_B18722.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 网络应用的文档视图](img/Figure_2.1_B18722.jpg)'
- en: Figure 2.1 – Documentation view of the web app
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 网络应用的文档视图
- en: 'In the preceding screenshot, we can see that **web_app** is a crate. We can
    also see that the documentation of the rand crate is involved (if we look at the
    bottom left of the screenshot, we can see the **rand** crate documentation just
    above our **web_app** crate documentation). If we click on the **User** struct,
    we can see the declaration of the struct, the Markdown that we wrote for the attributes,
    and the trait implications, as shown in the following figure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到 **web_app** 是一个 crate。我们还可以看到 rand crate 的文档涉及其中（如果我们查看屏幕截图的左下角，我们可以看到位于我们的
    **web_app** crate 文档之上的 **rand** crate 文档）。如果我们点击 **User** 结构，我们可以看到结构的声明、我们为属性编写的
    Markdown 以及特质的影响，如下面的图所示：
- en: '![Figure 2.2 – Documentation on struct](img/Figure_2.2_B18722.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 结构的文档](img/Figure_2.2_B18722.jpg)'
- en: Figure 2.2 – Documentation on struct
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 结构的文档
- en: It must be noted that in future sections of the book, we will not include Markdown
    in the code snippets to maintain readability. However, Markdown-documented code
    is provided in the book’s GitHub repo. Now that we have a well-documented, running
    Cargo project, we need to be able to pass parameters into it to enable different
    configurations to run depending on the context.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，在本书的未来章节中，我们将不在代码片段中包含 Markdown 以保持可读性。然而，书中 GitHub 仓库提供了 Markdown 格式的代码。现在我们有一个文档齐全、运行良好的
    Cargo 项目，我们需要能够向其中传递参数，以便根据上下文运行不同的配置。
- en: Interacting with Cargo
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Cargo 交互
- en: 'Now that we have our program running and using third-party modules, we can
    start to interact with our Rust programs through command-line inputs. To enable
    our program to have some flexibility depending on the context, we need to be able
    to pass parameters into our program and keep track of the parameters in which
    the program is running. We can do this using the `std` (standard library) identifier:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们程序正在运行并使用第三方模块，我们可以开始通过命令行输入与我们的 Rust 程序交互。为了使我们的程序能够根据上下文具有一些灵活性，我们需要能够向我们的程序传递参数并跟踪程序运行的参数。我们可以使用`std`（标准库）标识符来完成这项任务：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we can see that we collect the arguments passed into
    the program into a vector and then print out the arguments in debug mode. Let
    us run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们将传递给程序的参数收集到一个向量中，然后在调试模式下打印出这些参数。让我们运行以下命令：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running the preceding command gives the following printout:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令会得到以下输出：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we can see that our `args` vector has the arguments that we passed in.
    This is not surprising as many other languages also accept arguments passed into
    the program via the command line. We must note as well that the path to the binary
    is also included. Here, I also must highlight that I am using a different project
    named `interacting_with_cargo`, hence the `target/debug/interacting_with_cargo`
    path. We can also see from the command-line arguments that we are running in debug
    mode. Let us try to run a release version of our program with the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`args`向量包含了我们传递的参数。这并不奇怪，因为许多其他语言也接受通过命令行传递给程序的参数。我们还必须注意，二进制文件的路径也包括在内。在这里，我还必须强调，我正在使用一个名为`interacting_with_cargo`的不同项目，因此路径是`target/debug/interacting_with_cargo`。我们还可以从命令行参数中看到我们正在调试模式下运行。让我们尝试使用以下命令运行我们程序的发布版本：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We would receive the following printout:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会收到以下输出：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From the preceding output, we can see that `--release` is not in our vector.
    However, this does give us some extra functionality to play with. For instance,
    we might want to run different processes depending on the type of compilation.
    This can easily be done with the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`--release`不在我们的向量中。然而，这确实给我们提供了一些额外的功能来玩耍。例如，我们可能希望根据编译类型运行不同的进程。这可以通过以下代码轻松实现：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, the preceding simple solution is patchy. The `path` that we extract
    is only consistent if we are running Cargo commands. While Cargo commands are
    great for building, compiling, and documenting, it does not make sense to carry
    all those files around in production. In fact, there are advantages to extracting
    the static binary, wrapping it in a Docker container completely by itself, and
    running the binary directly as this can reduce the size of the Docker image from
    1.5 GB to 200 MB. So, while this might seem like a quick win, it can lead to breaking
    code when deploying our applications. Therefore, it is essential to put in the
    `panic` macro at the end to prevent this from reaching production and you not
    knowing about it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的简单解决方案是临时的。我们提取的`path`只有在运行 Cargo 命令时才是一致的。虽然 Cargo 命令在构建、编译和文档化方面很出色，但在生产环境中携带所有这些文件是没有意义的。实际上，提取静态二进制文件，将其完全封装在
    Docker 容器中，并直接运行二进制文件是有优势的，这样可以减少 Docker 镜像的大小，从 1.5 GB 减少到 200 MB。因此，虽然这看起来像是一个快速胜利，但它可能导致在部署我们的应用程序时破坏代码。因此，在最后放入`panic`宏是至关重要的，以防止这种情况进入生产环境而你却不知道。
- en: 'So far, we have passed in some basic commands; however, this is not helpful
    or scalable. There would also be a lot of boilerplate code written for us to implement
    help guides for users. To scale our command-line interface, we can lean on the
    `clap` crate to handle arguments passed into the program, with the following dependency:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经传递了一些基本的命令；然而，这并不有用或可扩展。还会有很多样板代码为我们编写，以实现为用户提供帮助指南。为了扩展我们的命令行界面，我们可以依赖
    `clap` crate 来处理传递给程序的参数，以下是一个依赖项：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To flesh out our understanding of command-line interfaces, we can develop a
    toy application that merely takes in a few commands and prints them out. To do
    this, we must import what we need from the `clap` crate in the `main.rs` file
    with the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善我们对命令行界面的理解，我们可以开发一个玩具应用程序，它只接受一些命令并将它们打印出来。为了做到这一点，我们必须在 `main.rs` 文件中导入
    `clap` crate 所需的内容，以下代码所示：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can move on to defining our application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续定义我们的应用程序：
- en: 'Our application houses metadata about the application in the `main` function
    with the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序在 `main` 函数中包含有关应用程序的元数据，以下代码所示：
- en: '[PRE23]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we look at the documentation of `clap`, we can bind arguments directly to
    the `App` struct; however, this can get ugly and tightly bound. Instead, we will
    define them separately in the next step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `clap` 的文档，我们可以直接将参数绑定到 `App` 结构体；然而，这可能会变得很丑陋并且紧密耦合。相反，我们将在下一步中单独定义它们。
- en: 'In our toy app, we are taking in a first name, last name, and age, which can
    be defined as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的玩具应用程序中，我们正在接受一个名字、姓氏和年龄，可以定义如下：
- en: '[PRE29]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can see that we can keep stacking the arguments. Right now, they are not
    bound to anything. Now, we can move on to binding them to our application and
    passing in the arguments in the next step.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们可以继续堆叠参数。目前，它们还没有绑定到任何东西。现在，我们可以在下一步中将它们绑定到我们的应用程序并传递参数。
- en: 'Binding, getting, and parsing inputs can be achieved with the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定、获取和解析输入可以通过以下代码实现：
- en: '[PRE44]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that we have a working example of how to pass command-line arguments, we
    can interact with our application to see how it displays by running the following
    command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个如何传递命令行参数的工作示例，我们可以通过运行以下命令与我们的应用程序交互，以查看它如何显示：
- en: '[PRE56]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The middle `--` before `--help` tells Cargo to pass all the arguments after
    `--` into `clap` as opposed to `cargo`. The preceding command will give us the
    following printout:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `--help` 前面的中间 `--` 告诉 Cargo 将 `--` 后面的所有参数传递给 `clap` 而不是 `cargo`。前面的命令将给出以下输出：
- en: '[PRE57]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding output, we can see how to directly interact with our compiled
    binary file. We also have a nice help menu. To interact with Cargo, we need to
    run the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到如何直接与我们的编译后的二进制文件交互。我们还有一个很棒的帮助菜单。要与 Cargo 交互，我们需要运行以下命令：
- en: '[PRE58]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding command will give the following printout:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将给出以下输出：
- en: '[PRE59]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can see that the parsing works as we have two strings and an integer. The
    reason why crates such as `clap` are useful is that they are essentially self-documenting.
    Developers can look at the code and know what arguments are being accepted and
    view the metadata around them. Users can get help on the inputs by merely passing
    in the `help` parameter. This approach reduces the risk of the documentation becoming
    outdated as it is embedded in the code that executes it. If you accept command-line
    arguments, it is advised that you use a crate such as `clap` for this purpose.
    Now that we have explored structuring our command-line interface so it can scale,
    we can investigate structuring our code over multiple files to scale it in the
    next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到解析是正常工作的，因为我们有两个字符串和一个整数。crates 如 `clap` 有用的原因是它们本质上具有自文档性。开发者可以查看代码并了解正在接受哪些参数以及它们周围的元数据。用户可以通过仅传递
    `help` 参数来获取输入的帮助。这种方法减少了文档过时的风险，因为它嵌入在执行它的代码中。如果你接受命令行参数，建议你使用像 `clap` 这样的 crate
    来实现这个目的。现在我们已经探讨了如何结构化我们的命令行界面以便它可以扩展，我们可以在下一节中调查如何将代码结构化到多个文件中以扩展它。
- en: Structuring code
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: 'We can now begin our journey of building a web application. In the rest of
    this chapter, we will not touch a web framework or build an HTTP listener. This
    will happen in the next chapter. However, we will construct a to-do module that
    will interact with a JSON file. It is going to be structured in such a way that
    it can be inserted into any web application that we build with minimal effort.
    This to-do module will enable us to create, update, and delete to-do items. We
    will then interact with this via the command line. The process here is to explore
    how to build well-structured code that will scale and be flexible. To gain an
    understanding of this, we will break down the building of this module into the
    following chunks:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始构建我们的Web应用程序之旅了。在本章的其余部分，我们不会接触任何Web框架或构建HTTP监听器。这将在下一章发生。然而，我们将构建一个与JSON文件交互的待办事项模块。它将被构建成这样的结构，可以以最小的努力插入到我们构建的任何Web应用程序中。这个待办事项模块将使我们能够创建、更新和删除待办事项。然后我们将通过命令行与它交互。这里的流程是探索如何构建结构良好、可扩展和灵活的代码。为了理解这一点，我们将把这个模块的构建分解为以下部分：
- en: Build structs for pending and done to-do items.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建待办和已完成的待办事项结构体。
- en: Build a factory that enables the structs to be built in the module with minimal
    clean input.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个工厂，使结构体能够在模块中以最小的清洁输入构建。
- en: Build traits that enable a struct to delete, create, edit, and get to-do items.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建特性，使结构体能够删除、创建、编辑和获取待办事项。
- en: Build a read-and-write-to-file module to store to-do items (we will replace
    this with a proper database in later chapters).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个读写文件的模块来存储待办事项（我们将在后面的章节中将这个替换为合适的数据库）。
- en: Build a `config` module that can alter the behavior of the application based
    on the variables in a `config` file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个`config`模块，该模块可以根据`config`文件中的变量来改变应用程序的行为。
- en: 'Before we start tackling these steps, we need to get the application running.
    We can do this by navigating to the desired directory of where we want to house
    this application and start a new Cargo project called `todo_app`. Once this is
    done, we are going to put the logic that handles the management of to-do items
    in our `to_do` module. This can be achieved by creating a `to_do` directory and
    putting a `mod.rs` file at the base of this directory, as seen in the following
    layout:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理这些步骤之前，我们需要让应用程序运行起来。我们可以通过导航到我们想要存放此应用程序的目录，并启动一个新的名为`todo_app`的Cargo项目来实现这一点。一旦完成，我们将把处理待办事项管理的逻辑放入我们的`to_do`模块中。这可以通过创建一个`to_do`目录并在该目录的底部放置一个`mod.rs`文件来实现，如下面的布局所示：
- en: '[PRE60]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: With this structure, we can start building out our `to_do` module starting with
    structs. Do not worry about the `to_do` file for now as this is covered in the
    first step, building structs for our done and pending to-do items.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个结构，我们可以从结构体开始构建我们的`to_do`模块。现在不必担心`to_do`文件，因为这在第一步中已经涵盖了，即构建我们已完成和待完成的待办事项的结构体。
- en: Building to-do structs
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建待办事项结构体
- en: 'Right now, we only have two structs for to-do items: ones that are waiting
    to be done and others that are already done. However, we might want to introduce
    other categories. For instance, we could add a backlog category, or an *on-hold*
    task for tasks that have been started but for one reason or another are blocked.
    To avoid mistakes and repetitive code, we can build a `Base` struct and have that
    be utilized by other structs. The `Base` struct houses common fields and functions.
    An alteration of the `Base` struct will propagate to all other to-do structs.
    We will also need to define the type of to-do item. We could hardcode in strings
    for pending and done; however, this is not scalable and is also error prone. To
    avoid this, we will use an enum to classify and define the presentation of the
    type of to-do item. To achieve this, we need to create the following file structure
    for our module:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只有两个用于待办事项的结构体：一个是等待完成的，另一个是已经完成的。然而，我们可能想要引入其他类别。例如，我们可以添加一个待办事项类别，或者为那些已经开始但出于某种原因受阻的任务添加一个*暂停*任务。为了避免错误和重复的代码，我们可以构建一个`Base`结构体，并让其他结构体使用它。`Base`结构体包含公共字段和函数。对`Base`结构体的任何修改都将传播到所有其他待办事项结构体。我们还需要定义待办事项的类型。我们可以为待办和已完成硬编码字符串；然而，这不可扩展，并且容易出错。为了避免这种情况，我们将使用枚举来分类和定义待办事项类型的表示。为了实现这一点，我们需要为我们的模块创建以下文件结构：
- en: '[PRE61]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the preceding code, we can notice that we have two `mod.rs` files. These
    files are essentially where we declare our files, and what we define in them to
    make them accessible to other files in the same directory. We can also allow the
    files to be accessed outside of the directory if we publicly declare them in the
    `mod.rs` file. Before we write any code, we can see in *Figure 2**.3* how the
    data flows in our module:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以注意到我们有两个 `mod.rs` 文件。这些文件基本上是我们声明文件的地方，以及我们在其中定义的内容，以便它们可以被同一目录中的其他文件访问。我们还可以在
    `mod.rs` 文件中公开声明它们，以允许文件在目录外部被访问。在我们编写任何代码之前，我们可以在 *图 2**.3* 中看到我们的模块中的数据流：
- en: '![Figure 2.3 – The flow of data in our to-do module](img/Figure_2.3_B18722.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 我们待办模块中的数据流](img/Figure_2.3_B18722.jpg)'
- en: Figure 2.3 – The flow of data in our to-do module
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 我们待办模块中的数据流
- en: We see that our `Base` struct is used by our other to-do structs. The other
    to-do structs would not be able to access the `Base` struct if we did not declare
    it. However, no file outside the `to_do/structs` directory is referencing the
    `Base` struct, therefore it does not have to be a public declaration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的 `Base` 结构体被我们的其他待办结构体所使用。如果我们没有声明它，其他待办结构体将无法访问 `Base` 结构体。然而，`to_do/structs`
    目录外部的任何文件都没有引用 `Base` 结构体，因此它不需要是公开声明。
- en: 'Now that we understand the data flow for our module, we need to look back at
    *Figure 2**.3* and work out what we need to work on first. We can see that our
    enums have no dependencies. In fact, our enum supplies all the structs. Therefore,
    we will start with our enum in the `/to_do/enums.rs` file. Our enum is defining
    the status of the task with the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了模块的数据流，我们需要回顾 *图 2**.3* 并确定我们首先需要做什么。我们可以看到我们的枚举没有依赖关系。事实上，我们的枚举提供了所有结构体。因此，我们将从
    `/to_do/enums.rs` 文件中的枚举开始。我们的枚举定义了任务的状况，如下所示：
- en: '[PRE62]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will work in the code when it comes to defining the status of the task.
    However, if we want to write to a file or database, we are going to have to build
    a method to enable our enum to be represented in a string format. To do this,
    we can implement a `stringify` function for our `TaskStatus` enum with the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义任务的状况时，这将在代码中工作。然而，如果我们想要写入文件或数据库，我们将不得不构建一个方法来使我们的枚举能够以字符串格式表示。为此，我们可以为
    `TaskStatus` 枚举实现一个 `stringify` 函数，如下所示：
- en: '[PRE63]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Calling this will enable us to print out the status of the to-do task in the
    console and write it in our JSON file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数将使我们能够在控制台打印待办任务的状况并将其写入我们的 JSON 文件。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'While the `stringify` function works, there is another way to convert the value
    of the enum to a string. To achieve the string conversion, we can implement the
    `Display` trait for `TaskStatus`. First, we must import the format module with
    the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `stringify` 函数可以工作，但还有另一种将枚举值转换为字符串的方法。为了实现字符串转换，我们可以为 `TaskStatus` 实现一个
    `Display` 特性。首先，我们必须使用以下代码导入格式模块：
- en: '[PRE64]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can then implement the `Display` trait for the `TaskStatus` struct with
    the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码为 `TaskStatus` 结构体实现 `Display` 特性：
- en: '[PRE65]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This trait implementation has the same logic as our `stringify` function. However,
    our trait is utilized when needed. So, we have the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性和实现具有与我们的 `stringify` 函数相同的逻辑。然而，我们的特性和需要时才会被使用。因此，我们有以下代码：
- en: '[PRE66]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will result in the following printout:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE67]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we can see that when we pass `TaskStatus` into `println!`, the `Display`
    trait is automatically utilized.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到当我们把 `TaskStatus` 传递给 `println!` 时，`Display` 特性会自动被利用。
- en: 'We can now make our enum publicly available in the `/to_do/mod.rs` file with
    the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `/to_do/mod.rs` 文件中使用以下代码使我们的枚举公开可用：
- en: '[PRE68]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can now refer to *Figure 2**.3* to see what we can build next, which is
    the `Base` struct. We can define the `Base` struct in the `/to_do/structs/base.rs`
    file with the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以参考 *图 2**.3* 来查看我们接下来可以构建什么，那就是 `Base` 结构体。我们可以在 `/to_do/structs/base.rs`
    文件中使用以下代码定义 `Base` 结构体：
- en: '[PRE69]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From the import at the top of the file, we can access the `TaskStatus` enum
    using `super::super`. We know that the `TaskStatus` enum is in a higher directory.
    From this, we can deduce that `super` gives us access to what is declared in the
    `mod.rs` file of the current directory. So, using `super::super` in a file in
    the `/to_do/structs/` directory gives us access to what is defined in the `/to_do/mod.rs`
    file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件顶部的导入中，我们可以使用`super::super`访问`TaskStatus`枚举。我们知道`TaskStatus`枚举位于更高的目录中。由此，我们可以推断出`super`为我们提供了访问当前目录`mod.rs`文件中声明的内容的权限。因此，在`/to_do/structs/`目录中的文件中使用`super::super`可以让我们访问到`/to_do/mod.rs`文件中定义的内容。
- en: 'We can now declare our `Base` struct in our `/to_do/structs/mod.rs` file with
    the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`/to_do/structs/mod.rs`文件中声明我们的`Base`结构体，以下代码如下：
- en: '[PRE70]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We do not have to declare it as public because our `Base` struct is not accessed
    outside of the `/to_do/structs/` directory. Now, looking back at *Figure 2**.3*,
    we can build our `Pending` and `Done` structs. This is when we use composition
    to utilize our `Base` struct in our `/to_do/structs/pending.rs` file with the
    following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将其声明为公共的，因为我们的`Base`结构体不会在`/to_do/structs/`目录外被访问。现在，回顾一下*图2**.3*，我们可以构建我们的`Pending`和`Done`结构体。这就是我们在`/to_do/structs/pending.rs`文件中使用组合来利用我们的`Base`结构体的时刻，以下代码如下：
- en: '[PRE71]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Through the preceding code, we can see that our `super_struct` field houses
    our `Base` struct. We utilize our enum and define the status to be pending. This
    means that we only must pass the title into the constructor, and we have a struct
    with a title and a status of pending. Considering this, coding our `Done` struct
    should be straightforward in our `/to_do/structs/done.rs` file with the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们可以看到我们的`super_struct`字段包含了我们的`Base`结构体。我们利用我们的枚举并定义状态为挂起。这意味着我们只需将标题传递给构造函数，我们就有了一个具有标题和挂起状态的结构体。考虑到这一点，在我们的`/to_do/structs/done.rs`文件中编写我们的`Done`结构体应该是直截了当的，以下代码如下：
- en: '[PRE72]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can see that there is not much difference from the `Pending` struct definition
    apart from the `TaskStatus` enum having a `DONE` status. We can now make our structs
    available outside of the directory in the `/to_do/structs/mod.rs` file with the
    following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，除了`TaskStatus`枚举有一个`DONE`状态之外，与`Pending`结构体定义没有太大区别。现在，我们可以通过以下代码在`/to_do/structs/mod.rs`文件中使我们的结构体在目录外可用：
- en: '[PRE73]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can then make our structs accessible in the `main.rs` file by declaring
    these structs in the `/to_do/mod.rs` file with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`/to_do/mod.rs`文件中声明以下代码，使我们的结构体在`main.rs`文件中可访问：
- en: '[PRE74]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We have now made a basic module and exposed it to the `main.rs` file. For now,
    we can write some basic code that will use our module to create a task that is
    pending and another that is completed. This can be done with the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个基本的模块并将其暴露给`main.rs`文件。目前，我们可以编写一些基本的代码，使用我们的模块创建一个挂起的任务和另一个完成的任务。这可以通过以下代码完成：
- en: '[PRE75]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the preceding code, we can see that we have declared our `to_do` module.
    We then imported our structs and created a `pending` and `done` struct. Running
    our code will give us the following printout:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们已声明了我们的`to_do`模块。然后我们导入了我们的结构体并创建了一个`pending`和`done`结构体。运行我们的代码将给出以下输出：
- en: '[PRE76]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This stops the `main.rs` file from being overloaded with excessive code. If
    we were to stack more types of items that can be created, such as the on-hold
    or backlog items, the code in `main.rs` would balloon. This is where factories
    come in, which we will explore in the next step.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这阻止了`main.rs`文件因过多的代码而变得臃肿。如果我们堆叠更多可以创建的项目类型，例如挂起或待办事项，`main.rs`中的代码将会膨胀。这就是工厂模式发挥作用的地方，我们将在下一步进行探讨。
- en: Managing structs with factories
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂管理结构体
- en: 'A factory pattern is where we abstract the construction of structs in an entry
    point of the module. We can see how this would work with our module as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是指我们在模块的入口点抽象结构体的构建。我们可以通过以下方式了解我们的模块是如何工作的：
- en: '![Figure 2.4 – Flow of to-do factory](img/Figure_2.4_B18722.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – to-do工厂流程](img/Figure_2.4_B18722.jpg)'
- en: Figure 2.4 – Flow of to-do factory
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – to-do工厂流程
- en: 'What factories do is abstract the module by providing an interface. While we
    have enjoyed building our module, if another developer wanted to use it, a simple
    factory interface with good documentation would save them a lot of time. All they
    must do is pass in a few parameters and get the constructed structs out of the
    factory wrapped in an enum. If we change the internals of the module or it becomes
    more complicated, this will not matter. If other modules use the interface, the
    changes would not break the rest of the code if we keep the interfaces consistent.
    We can build our factory by defining our factory function in the `/to_do/mod.rs`
    file with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂的作用是通过提供一个接口来抽象模块。虽然我们享受构建我们的模块，但如果其他开发者想要使用它，一个简单的工厂接口和良好的文档将为他们节省很多时间。他们只需要传递几个参数，然后从工厂中获取构建的结构体，这些结构体被封装在枚举中。如果我们更改模块的内部结构或它变得更加复杂，这不会产生影响。如果其他模块使用接口，如果我们保持接口的一致性，那么更改不会破坏其他代码。我们可以在
    `/to_do/mod.rs` 文件中通过定义以下代码来构建我们的工厂：
- en: '[PRE77]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the preceding code, we can see that we define an enum called `ItemTypes`,
    which packages the constructed task structs. Our `factory` function essentially
    accepts our inputted title and status. The factory then matches the inputted status.
    Once we have established what type of status was passed in, we build a task that
    matches the status and wraps it in the `ItemTypes` enum. This can grow and get
    more complicated, and our main file will be none the wiser. We can then implement
    this factory in our `main.rs` file with the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们定义了一个名为 `ItemTypes` 的枚举，它封装了构造的任务结构体。我们的 `factory` 函数本质上接受我们输入的标题和状态。然后工厂匹配输入的状态。一旦我们确定了传入的状态类型，我们就构建一个与状态匹配的任务，并用
    `ItemTypes` 枚举将其封装。这可能会变得越来越大和复杂，而我们的主文件将不会察觉到这一点。然后我们可以在 `main.rs` 文件中使用以下代码实现这个工厂：
- en: '[PRE78]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the preceding code, we can see that we pass into the factory the parameters
    we want to create for a to-do item, and then match the outcome to print the item’s
    attributes. There is more code now introduced into the `main.rs` file. However,
    there is more code because we are unwrapping the returned enum to print out the
    attributes for demonstrative purposes. We will usually pass this wrapped enum
    into other modules to handle. To create the struct, we only need one line of code,
    which is the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们将我们想要为待办事项创建的参数传递给工厂，然后匹配结果以打印出项的属性。现在 `main.rs` 文件中引入了更多的代码。然而，引入更多的代码是因为我们正在解包返回的枚举以打印出属性以供演示。我们通常将这个封装的枚举传递到其他模块中处理。创建结构体只需要一行代码，如下所示：
- en: '[PRE79]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This means we can create a to-do item and pass it around with little hassle
    as it is wrapped in an enum. Other functions and modules must just accept the
    enum. We can see that this offers flexibility. However, as our code stands, we
    can do away with the `Base`, `Done`, and `Pending` structs and just have one struct
    that accepts the status and title. It would mean less code. However, it would
    also be less flexible. We are going to see how this is the case in our next step,
    where we add traits to our structs to lock down functionality and ensure safety.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以创建一个待办事项并将其轻松传递，因为它被封装在枚举中。其他函数和模块只需接受枚举。我们可以看到这提供了灵活性。然而，根据我们当前的代码，我们可以去掉
    `Base`、`Done` 和 `Pending` 结构体，只保留一个接受状态和标题的结构体。这将意味着更少的代码。然而，这将也会降低灵活性。我们将在下一步中看到这一点，我们将向我们的结构体添加特性以锁定功能并确保安全性。
- en: Defining functionality with traits
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特性定义功能
- en: 'Right now, our structs do not really do anything apart from holding the status
    and title of the task. However, our structs could have different functionality.
    Therefore, we have taken the extra trouble of defining individual structs. For
    instance, we are building a to-do application here. It is ultimately down to you
    how you structure your application, but it is not unreasonable to ensure that
    you cannot create a done task; otherwise, why are you adding it to your to-do
    list? This example might seem trivial. This book has used a to-do list to keep
    the problem that we are solving simple. Because of this, we can focus on the technical
    aspects of developing web applications in Rust without spending time understanding
    the problem we are solving. However, we must acknowledge that in more demanding
    applications, such as a system that processes bank transactions, we would need
    to be strict on how to implement our logic and lock down the possibility of any
    undesired processes happening. We can do this in our to-do application by building
    individual traits for each process and assigning them to task structs that we
    want. To do this, we will need to create a `traits` directory in our `to_do` module
    and a file for each trait, which will take the following structure:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的结构体除了持有任务的状态和标题外，实际上并没有做什么。然而，我们的结构体可以有不同功能。因此，我们额外麻烦地定义了单独的结构体。例如，我们在这里构建一个待办事项应用程序。最终如何构建你的应用程序取决于你，但确保你不能创建一个已完成任务是有道理的；否则，你为什么要将它添加到你的待办事项列表中？这个例子可能看起来很微不足道。这本书使用待办事项列表来简化我们正在解决的问题。因此，我们可以专注于开发Rust网络应用程序的技术方面，而不必花费时间理解我们正在解决的问题。然而，我们必须承认，在更复杂的应用程序中，例如处理银行交易的系统，我们需要对逻辑的实现方式非常严格，并锁定任何不希望发生的过程的可能性。我们可以在我们的待办事项应用程序中通过为每个过程构建单独的特性并将它们分配给我们要的任务结构体来实现这一点。为此，我们需要在`to_do`模块中创建一个`traits`目录并为每个特性创建一个文件，其结构如下：
- en: '[PRE80]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can then publicly define all the traits in the `to_do/traits/mod.rs` file
    with the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`to_do/traits/mod.rs`文件中公开定义所有特性，代码如下：
- en: '[PRE81]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We must also publicly define our traits in our `to_do/mod.rs` file with the
    following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须在我们的`to_do/mod.rs`文件中公开定义我们的特性，代码如下：
- en: '[PRE82]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now that we have all our trait files plumbed up in our module, we can start
    building our traits. We can start by defining our `Get` trait in the `to_do/traits/get.rs`
    file with the following code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有特性文件连接到我们的模块中，我们可以开始构建我们的特性。我们可以从在`to_do/traits/get.rs`文件中定义我们的`Get`特性开始，代码如下：
- en: '[PRE83]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This is simply a demonstration of how we apply traits; therefore, we will just
    print out what is happening for now. We must remember that we cannot reference
    fields from the `&self` parameter passed in because we can apply our trait to
    multiple structs; however, we can overwrite the `get` function for the trait that
    implements this. When it comes to the `Edit` trait, we can have two functions
    that change the status in the `to_do/traits/edit.rs` file with the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个展示我们如何应用特性的示例；因此，我们现在只打印出正在发生的事情。我们必须记住，我们不能从传入的`&self`参数中引用字段，因为我们可以将我们的特性应用到多个结构体上；然而，我们可以覆盖实现此特性的特性的`get`函数。当涉及到`Edit`特性时，我们可以在`to_do/traits/edit.rs`文件中有两个函数来改变状态，代码如下：
- en: '[PRE84]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can see a pattern here. So, for completeness, our `Create` trait takes the
    following form in the `to_do/traits/create.rs` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到一个模式。因此，为了完整性，我们的`Create`特性在`to_do/traits/create.rs`文件中的形式如下：
- en: '[PRE85]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Our `Delete` trait is defined in the `to_do/traits/delete.rs` file with the
    following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Delete`特性在`to_do/traits/delete.rs`文件中定义，代码如下：
- en: '[PRE86]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We have now defined all the traits that we need. Thus, we can utilize them
    to define and lock down behavior in our to-do item structs. For our `Done` struct,
    we can import our traits into the `to_do/structs/done.rs` file with the following
    code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了我们需要的所有特性。因此，我们可以利用它们在待办事项项结构体中定义和锁定行为。对于我们的`Done`结构体，我们可以将特性导入到`to_do/structs/done.rs`文件中，代码如下：
- en: '[PRE87]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can then implement our `Done` struct in the same file after the definition
    of the `Done` struct with the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在定义了`Done`结构体的同一文件中实现我们的`Done`结构体，代码如下：
- en: '[PRE88]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, our `Done` struct can get, edit, and delete to-do items. Here, we can
    really see the power of traits as highlighted in [*Chapter 1*](B18722_01.xhtml#_idTextAnchor015),
    *A Quick Introduction to Rust*. We can stack on or remove traits easily. For instance,
    allowing done to-do items to be created would be achieved with a simple `impl
    Create for Done;`. Now that we have defined the traits that we want for our `Done`
    struct, we can move on to our `Pending` struct, importing what we need in the
    `to_do/structs/pending.rs` file with the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `Done` 结构体可以获取、编辑和删除待办事项。在这里，我们可以真正看到特性（traits）的力量，正如在[*第一章*](B18722_01.xhtml#_idTextAnchor015)《Rust
    快速入门》中所强调的。我们可以轻松地堆叠或移除特性。例如，允许创建完成的待办事项可以通过简单的 `impl Create for Done;` 实现。现在我们已经为我们的
    `Done` 结构体定义了所需的特性，我们可以继续到我们的 `Pending` 结构体，在 `to_do/structs/pending.rs` 文件中导入所需的代码：
- en: '[PRE89]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we can implement these traits after the definition of our `Pending` struct
    with the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在定义我们的 `Pending` 结构体之后，使用以下代码实现这些特性：
- en: '[PRE90]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the preceding code, we can see that our `Pending` struct can get, edit,
    and create but cannot delete. Implementing these traits also ties our `Pending`
    and `Done` structs together without compiling them. For instance, if we accepted
    a struct that implemented the `Edit` trait, it would accept both the `Pending`
    and `Done` structs. However, if we were to create a function that accepted structs
    that implemented the `Delete` trait, it would accept the `Done` struct but reject
    the `Pending` struct. This gives us a beautiful symphony of aggressive type-checking
    yet flexibility, which is truly a testament to Rust’s design. Now that our structs
    have all the traits that we want, we can completely rewrite our `main.rs` file
    utilizing them. First, we import what we need with the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们的 `Pending` 结构体可以获取、编辑和创建，但不能删除。实现这些特性也将我们的 `Pending` 和 `Done`
    结构体紧密地联系在一起，而无需编译它们。例如，如果我们接受实现了 `Edit` 特性的结构体，它将接受 `Pending` 和 `Done` 结构体。然而，如果我们创建一个接受实现了
    `Delete` 特性的结构体的函数，它将接受 `Done` 结构体但拒绝 `Pending` 结构体。这为我们提供了一个充满活力的类型检查与灵活性的交响乐，这确实是
    Rust 设计的证明。现在，我们的结构体已经拥有了所有我们想要的特性，我们可以完全重写我们的 `main.rs` 文件，利用它们。首先，我们使用以下代码导入所需的代码：
- en: '[PRE91]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The imports are important to note this time around. Although we have implemented
    our traits on the structs that we want, we will have to import the traits into
    the file that is using them. This can be a bit confusing. For example, calling
    the `get` function from the `Get` trait after a struct has been initialized would
    take the form of `item.get(&item.super_struct.title);`. The `get` function is
    tethered to the initialized struct. Intuitively, it makes sense not to need to
    import the trait. However, your compiler or IDE will give you the unhelpful error
    that the function named `get` is not found in the struct if you do not import
    the trait. This is important as we will use traits from database crates and web
    frameworks in the future and we will need to import these traits for the package
    structs to be used. With our imports, we can then utilize our traits and factory
    in the `main` function with the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这次需要注意的是导入。尽管我们已经在我们想要的结构体上实现了特性，但我们必须将这些特性导入到使用它们的文件中。这可能会有些令人困惑。例如，在结构体初始化后调用
    `Get` 特性的 `get` 函数将采取以下形式：`item.get(&item.super_struct.title);`。`get` 函数与初始化的结构体绑定。直观上，不需要导入特性是有道理的。然而，如果你没有导入特性，编译器或
    IDE 会给出无用的错误，指出名为 `get` 的函数在结构体中未找到。这很重要，因为我们将在未来使用数据库包和 Web 框架中的特性，我们需要导入这些特性以便包结构体可以使用。有了我们的导入，我们就可以在
    `main` 函数中使用以下代码利用我们的特性和工厂：
- en: '[PRE92]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Running the preceding code gives us the following printout:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '[PRE93]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: What we have done here is build our own module, which contains an entry point.
    We’ve then imported it into the `main` function and run it. Now, the basic structure
    is built and working, but we need to get the module to interact with the environment
    by passing variables in and writing to a file to become useful.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是构建了自己的模块，它包含一个入口点。然后我们将其导入到 `main` 函数中并运行它。现在，基本结构已经构建并工作，但我们需要通过传递变量和写入文件来使模块与环境交互，使其变得有用。
- en: Interacting with the environment
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与环境的交互
- en: 'To interact with the environment, we must manage two things. First, we need
    to load, save, and edit the state of to-do items. Second, we also must accept
    user input to edit and display data. Our program can achieve this by running the
    following steps for each process:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要与环境交互，我们必须管理两件事。首先，我们需要加载、保存和编辑待办事项的状态。其次，我们还必须接受用户输入以编辑和显示数据。我们的程序可以通过为每个过程运行以下步骤来实现这一点：
- en: Collect arguments from the user.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户那里收集参数。
- en: Define a command (`get`, `edit`, `delete`, and `create`) and define a to-do
    title from commands being passed into the application.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个命令（`get`、`edit`、`delete` 和 `create`）并从传递到应用程序的命令中定义待办事项的标题。
- en: Load a JSON file that stores the to-do items from previous runs of the program.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载一个存储程序之前运行中待办事项的 JSON 文件。
- en: Run a `get`, `edit`, `delete`, or `create` function based on the command passed
    into the program, saving the result of the state in a JSON file at the end.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据传递给程序的命令运行 `get`、`edit`、`delete` 或 `create` 函数，并在最后将状态的结果保存到 JSON 文件中。
- en: We can start making this four-step process possible by initially loading our
    state with the `serde` crate.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过最初使用 `serde` 包加载我们的状态来使这个四步过程成为可能。
- en: Reading and writing JSON files
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入 JSON 文件
- en: 'We are now at the stage where we are going to persist data in the form of a
    JSON file. We will upgrade this to a proper database in [*Chapter 6*](B18722_06.xhtml#_idTextAnchor127),
    *Data Persistence with PostgreSQL*. But for now, we are going to introduce our
    first dependency in our web application, which is `serde_json`. This `serde_json`
    crate handles the conversion of Rust data to JSON data and vice versa. We will
    use `serde_json` to process HTTP requests in the next chapter. We can install
    our crate in the `Cargo.toml` file with the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于将数据以 JSON 文件的形式持久化的阶段。我们将在 [*第 6 章*](B18722_06.xhtml#_idTextAnchor127)
    *使用 PostgreSQL 进行数据持久化* 中将其升级为数据库。但就目前而言，我们将介绍我们的第一个依赖项，即我们的 Web 应用程序中的 `serde_json`。这个
    `serde_json` 包处理 Rust 数据到 JSON 数据以及相反的转换。我们将在下一章中使用 `serde_json` 处理 HTTP 请求。我们可以在
    `Cargo.toml` 文件中使用以下代码安装我们的包：
- en: '[PRE94]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Seeing as we are going to be upgrading our storage option in the future, it
    makes sense to keep the operations around reading and writing to our JSON file
    separate from the rest of the application. We do not want a lot of debugging and
    refactoring when we pull it out for our database upgrade. We will also keep it
    simple as there are no schema or migrations that must be managed when reading
    and writing to a JSON file. Considering this, all we will need are `read` and
    `write` functions. As our module is small and simple, we can house our module
    in just one file next to the `main.rs` file. First, we need to import what we
    need in our `src/state.rs` file with the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在未来升级我们的存储选项，因此将读取和写入我们的 JSON 文件的操作与应用程序的其余部分分开是有意义的。我们不希望在将数据库升级拉出来时进行大量的调试和重构。我们将保持简单，因为在读取和写入
    JSON 文件时没有模式或迁移需要管理。考虑到这一点，我们只需要 `read` 和 `write` 函数。由于我们的模块小而简单，我们可以将模块放在 `main.rs`
    文件旁边的文件中。首先，我们需要使用以下代码在我们的 `src/state.rs` 文件中导入所需的项：
- en: '[PRE95]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As we can see, we need the standard library and a series of structs to read
    the data as mapped out in *Figure 2**.5*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们需要标准库和一系列结构体来读取数据，如 *图 2.5* 中所示：
- en: '![Figure 2.5 – Steps to read a JSON file](img/Figure_2.5_B18722.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 读取 JSON 文件的步骤](img/Figure_2.5_B18722.jpg)'
- en: Figure 2.5 – Steps to read a JSON file
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 读取 JSON 文件的步骤
- en: 'We can carry out the steps in *Figure 2**.5* with the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码执行 *图 2.5* 中的步骤：
- en: '[PRE96]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the preceding code, we can see that we directly unwrap the opening of the
    file. This is because there is no point in continuing the program if we cannot
    read the file, and as a result, we directly unwrap the file read. We must also
    note that the string must be mutable as we are going to fill this string with
    JSON data. Additionally, we use the `serde_json` crate to process the JSON data
    and configure it into a map. We can now access our to-do items via this `Map`
    variable throughout the rest of the program. Now, we need to write our data, which
    can be done in the same file with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们直接解包了文件的开头。这是因为如果我们无法读取文件，就没有继续程序的必要，因此我们直接解包了文件读取。我们还必须注意，字符串必须是可变的，因为我们将要在这个字符串中填充
    JSON 数据。此外，我们使用 `serde_json` 包来处理 JSON 数据并将其配置为映射。现在，我们可以通过这个 `Map` 变量在整个程序中访问我们的待办事项。现在，我们需要写入我们的数据，这可以通过以下代码在同一文件中完成：
- en: '[PRE97]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In the preceding code, we accept our `Map` variable and the path to the file.
    We then convert our `Map` variable into JSON using the `json!` macro from our
    `serde_json` crate. We then convert the JSON data to a string and then write it
    to our JSON file. Because of this, we now have functions to read and write to-do
    items to JSON files. We can now upgrade our `main.rs` file and build a simple
    command-line to-do application that reads and writes to-do items to a JSON file.
    We can interact with this using some basic arguments passed into the program with
    the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们接受`Map`变量和文件的路径。然后我们使用`serde_json`crate中的`json!`宏将`Map`变量转换为JSON。然后我们将JSON数据转换为字符串，并将其写入我们的JSON文件。正因为如此，我们现在有了读取和写入待办事项到JSON文件的功能。我们现在可以升级我们的`main.rs`文件，构建一个简单的命令行待办事项应用程序，该程序读取和写入待办事项到JSON文件。我们可以通过以下代码与它交互：
- en: '[PRE98]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Collected the status and title from arguments passed into our program
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从传递给程序的参数中收集状态和标题
- en: Read the to-do items from the JSON file
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从JSON文件中读取待办事项
- en: Printed out the to-do items from the JSON file
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出从JSON文件中的待办事项
- en: Inserted our new to-do item
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入了新的待办事项
- en: Printed out the new set of to-do items from memory
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出从内存中的新待办事项集合
- en: Written our new to-do items list to our JSON file
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的新待办事项列表写入我们的JSON文件
- en: 'Our root path is going to be where the `Cargo.toml` file is, so we define an
    empty JSON file called `state.json` next to the `Cargo.toml` file. To interact
    with it, we can pass in the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的根路径将是`Cargo.toml`文件的位置，所以我们定义一个名为`state.json`的空JSON文件，位于`Cargo.toml`文件旁边。为了与之交互，我们可以传递以下命令：
- en: '[PRE99]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The preceding command would result in the following printout:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将产生以下输出：
- en: '[PRE100]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In the preceding output, we can see that `washing` has been inserted. An inspection
    of our JSON file would also show that `washing` has been written to the file.
    You may have noticed that we have removed any mention of our `to_do` module, including
    all the structs and traits that we have built. We have not forgotten them. Instead,
    we are merely testing to see whether our interaction with the JSON file works
    before we try and fuse `to_do` with the `state` module. We will fuse the `to_do`
    and `state` modules by revising the traits implemented in our to-do structs in
    the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到已经插入了`washing`。检查我们的JSON文件也会显示`washing`已经被写入文件。你可能已经注意到，我们已经删除了关于我们的`to_do`模块的所有提及，包括我们构建的所有结构和特性。我们没有忘记它们。相反，我们只是在尝试将`to_do`模块与`state`模块融合之前，测试我们的JSON文件交互是否正常。我们将在下一节通过修改`to_do`结构体中实现的特性来融合`to_do`和`state`模块。
- en: Revisiting traits
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾特性
- en: 'Now that we have defined the module around managing the state of our to-do
    items in a JSON file, we have an idea of how our trait functions will process
    the data and interact with our JSON file. To start off, we can update our simplest
    trait, which is the `Get` trait in our `src/to_do/traits/get.rs` file. Here, we
    are merely getting the to-do item from our JSON map and printing it out. We can
    do this by simply passing the JSON map into our `get` function, getting the to-do
    item status from the map using the to-do item title from the state, and printing
    it out to the console with the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了管理我们的待办事项在JSON文件中的状态的模块，我们有了关于我们的特性函数如何处理数据和与我们的JSON文件交互的想法。首先，我们可以更新我们最简单的特性，即`src/to_do/traits/get.rs`文件中的`Get`特性。在这里，我们只是从JSON映射中获取待办事项并打印出来。我们可以通过简单地将JSON映射传递到我们的`get`函数中，使用待办事项标题从映射中获取待办事项状态，并将它打印到控制台来实现这一点，以下代码如下：
- en: '[PRE101]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In the preceding code, we can see that we perform a `get` function on our JSON
    `Map`, matching the outcome and printing out what we extract. This means that
    any to-do item that implements the `Get` trait can now extract a to-do item from
    our state and print it out.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们对JSON `Map`执行了一个`get`函数，匹配结果并打印出我们提取的内容。这意味着任何实现了`Get`特性的待办事项现在都可以从我们的状态中提取待办事项并打印出来。
- en: 'We can now move on to the next step in complexity, which is the `Create` trait
    in our `src/to_do/traits/create.rs` file. This is slightly more complex than our
    `Get` trait because we edit the state by inserting the new to-do item and then
    writing this updated state into our JSON. We can carry out these steps with the
    following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进入下一个更复杂的步骤，即`src/to_do/traits/create.rs`文件中的`Create`特性。这比我们的`Get`特性稍微复杂一些，因为我们通过插入新的待办事项来编辑状态，然后将更新后的状态写入我们的JSON。我们可以通过以下代码执行这些步骤：
- en: '[PRE102]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the preceding code, we can see that we have used the `write_to_file` function
    from the `state` module to save our state to the JSON file. We can use the `create`
    function as a template for what we need to do when deleting a to-do item. Deleting
    is essentially the inverse of what we have done in our `create` function. You
    can try to write the `delete` function for the `Delete` trait in the `src/to_do/traits/delete.rs`
    file now before moving on if you want. Your function may look different; however,
    it should run along the same lines as the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们使用了来自`state`模块的`write_to_file`函数来将我们的状态保存到JSON文件中。我们可以将`create`函数作为模板，了解在删除待办事项时我们需要做什么。删除本质上是我们`create`函数操作的逆操作。如果你想在继续之前尝试编写`delete`函数，可以在`src/to_do/traits/delete.rs`文件中完成。你的函数可能看起来不同；然而，它应该与以下代码运行在相同的方向上：
- en: '[PRE103]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the preceding code, we are merely using the `remove` function on our JSON
    `Map`, writing the updated state to our JSON file. We are near the end of the
    section. All we need to do now is build our `edit` function for our `Edit` trait
    in the `src/to_do/traits/edit.rs` file. We have two functions. One will set the
    to-do item status to `DONE`. The other function will set the to-do item status
    to `PENDING`. These will be achieved by updating the state and then writing the
    updated state to the JSON file. You can try and write this yourself before reading
    on. Hopefully, your code will look like the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是在我们的JSON `Map`上使用`remove`函数，将更新的状态写入我们的JSON文件。我们接近本节的结尾。我们现在需要做的就是构建我们的`Edit`特性和`src/to_do/traits/edit.rs`文件中的`edit`函数。我们有两个函数。一个将待办事项的状态设置为`DONE`。另一个函数将待办事项的状态设置为`PENDING`。这些将通过更新状态然后将更新的状态写入JSON文件来实现。在你继续阅读之前，你可以尝试自己编写这个函数。希望你的代码看起来像以下代码：
- en: '[PRE104]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Our traits can now interact without the JSON file, carrying out the processes
    that we initially wanted them to do. There is nothing stopping us from utilizing
    these traits directly in the `main.rs` file as we did when we first defined these
    traits. However, this is not scalable. This is because we will essentially be
    building a web application with multiple views and API endpoints. Therefore, we
    will be interacting with these traits and storage processes in multiple different
    files. Therefore, we are going to have to come up with a way to interact with
    these traits in a standardized way without having to repeat code, which we will
    do in the next section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的特性可以不通过JSON文件进行交互，执行我们最初希望它们执行的过程。没有什么阻止我们直接在`main.rs`文件中利用这些特性，就像我们最初定义这些特性时那样。然而，这并不具有可扩展性。这是因为我们实际上将构建一个具有多个视图和API端点的Web应用程序。因此，我们将与这些特性和存储过程在多个不同的文件中进行交互。因此，我们必须想出一个方法，以标准化的方式与这些特性进行交互，而无需重复代码，这将在下一节中完成。
- en: Processing traits and structs
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理特性和结构
- en: 'To enable our code to interact with a simple interface, enabling us to update
    with minimal pain and reduce repeated code and thus errors, we need a processes
    layer, as seen in *Figure 2**.6*:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码能够与一个简单的接口进行交互，使我们能够以最小的痛苦进行更新，减少重复代码并因此减少错误，我们需要一个处理层，如*图2.6*所示。6*：
- en: '![Figure 2.6 – Trait flow through a processes module](img/Figure_2.6_B18722.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 通过处理模块的特性和结构流程](img/Figure_2.6_B18722.jpg)'
- en: Figure 2.6 – Trait flow through a processes module
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 通过处理模块的特性和结构流程
- en: 'In *Figure 2**.6*, we can see that our structs are bound to the traits in a
    loose fashion and that the data flow to and from the JSON goes through the traits.
    We can also see that we have one entry point in the `processes` module, which
    will then direct commands to the correct traits, which in turn will access the
    JSON file as and when needed. Seeing as we have defined our traits, all we need
    to do is build our `processes` module, connect it to the traits, and then connect
    it to our `main.rs` file. We will be building our entire `processes` module in
    a single `src/processes.rs` file. We are keeping it to a single file because we
    will be removing it when we cover databases. There is no need to take on too much
    technical debt if we know we are going to be removing it in the future. For now,
    we can start building our `processes` module by initially importing all the structs
    and traits that we need with the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图 2.6**中，我们可以看到我们的结构体以一种松散的方式绑定到特质上，并且数据流向和从JSON流向特质。我们还可以看到我们有一个`processes`模块的入口点，它将命令引导到正确的特质，然后特质将根据需要访问JSON文件。鉴于我们已经定义了我们的特质，我们只需要构建我们的`processes`模块，将其连接到特质，然后连接到我们的`main.rs`文件。我们将整个`processes`模块构建在一个`src/processes.rs`文件中。我们将其保持为单个文件，因为我们将在介绍数据库时将其删除。如果我们知道我们将来会删除它，就没有必要承担过多的技术债务。现在，我们可以通过以下代码最初导入我们需要的所有结构体和特质来开始构建我们的`processes`模块：
- en: '[PRE105]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can now start to build non-public functions. We can start by processing
    our `Pending` structs. We know that we can either get, create, or edit pending
    to-do items, as seen in the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始构建非公开函数。我们可以从处理我们的`Pending`结构体开始。我们知道我们可以获取、创建或编辑待办事项，如下面的代码所示：
- en: '[PRE106]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In the preceding code, we can see that we have ingested the `Pending` struct,
    command, and current state of our to-do items. We then match the command and execute
    the trait associated with that command. If there the command that is passed in
    is neither `get`, `create`, or `edit`, we do not support it, throwing an error
    that tells the user what command is not supported. This is scalable. For instance,
    if we allow a `Pending` struct to delete a to-do item from the JSON file, we merely
    must implement the `Delete` trait for the `Pending` struct and then add the `delete`
    command to our `process_pending` function. This would only take two lines of code
    in total, and this change would take effect throughout the application. This would
    also happen if we removed a command. We now have a flexible implementation of
    our `Pending` struct. With this in mind, you can choose to code our `process_done`
    function before reading on. If you have chosen to do so, hopefully, it will look
    like the following code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们已经处理了待办事项的`Pending`结构体、命令和当前状态。然后我们匹配命令并执行与该命令关联的特质。如果传入的命令既不是`get`、`create`或`edit`，我们不支持它，会抛出一个错误告诉用户不支持哪个命令。这是可扩展的。例如，如果我们允许`Pending`结构体从JSON文件中删除待办事项，我们只需为`Pending`结构体实现`Delete`特质，然后将`delete`命令添加到我们的`process_pending`函数中。这总共只需要两行代码，并且这个更改将影响整个应用程序。如果我们删除一个命令，也会发生这种情况。现在，我们有了对`Pending`结构体的灵活实现。考虑到这一点，你可以在继续阅读之前选择编写我们的`process_done`函数。如果你选择了这样做，希望它看起来像以下代码：
- en: '[PRE107]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We can now process both our structs. This is where the scalability of structs
    comes in when designing our module. Like the commands, we will want to stack our
    structs just like we did with our traits. This is where our entry point comes
    in, as seen in *Figure 2**.7*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以处理我们的结构体。在设计我们的模块时，结构体的可扩展性就在这里。就像命令一样，我们希望像处理特质一样堆叠我们的结构体。这就是我们的入口点发挥作用的地方，如**图
    2.7**所示：
- en: '![Figure 2.7 – Scalability of processes](img/Figure_2.7_B18722.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 流程的可扩展性](img/Figure_2.7_B18722.jpg)'
- en: Figure 2.7 – Scalability of processes
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 流程的可扩展性
- en: 'We can see from *Figure 2**.7* that we can scale the access to structs by increasing
    the routes by the entry point. To appreciate this more, we should define our entry
    point, which this time is a public function, with the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从**图 2.7**中我们可以看到，我们可以通过增加入口点的路由来扩展对结构体的访问。为了更好地理解这一点，我们应该定义我们的入口点，这次是一个公开函数，如下面的代码所示：
- en: '[PRE108]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In the preceding code, we can see that we route to the correct struct with
    the `ItemTypes` enum. Our module can process more structs by adding the new struct
    to the `ItemTypes` enum, writing a new function that processes that struct in
    the `processes` module, and then applying the desired traits to the struct. Our
    `processes` module is now fully completed, and we can rewrite our `main.rs` file
    to utilize it. First of all, we import what we need with the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们通过`ItemTypes`枚举路由到正确的结构体。我们通过将新的结构体添加到`ItemTypes`枚举中，编写一个在`processes`模块中处理该结构体的新函数，并将所需的特性应用到结构体上，我们的模块可以处理更多的结构体。现在我们的`processes`模块已经完全完成，我们可以重写我们的`main.rs`文件来利用它。首先，我们使用以下代码导入所需的模块：
- en: '[PRE109]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'With these imports, we can see that we are going to be reading the data from
    the JSON file, using `to_do_factory` to create the structs from the input collected
    from the environment, and passing this into our `processes` module to update the
    JSON file. This is a good point in time to stop reading and try to code out this
    process by yourself. Remember, you must get the data from the JSON file and check
    to see whether the title of the to-do item is already stored in the JSON file.
    If we cannot find the title in the data from the JSON file, we then know that
    it is going to be a pending status as we cannot create a done task. If you chose
    to do this, your code hopefully looks like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些导入，我们可以看到我们将从JSON文件中读取数据，使用`to_do_factory`从环境收集的输入创建结构体，并将其传递到我们的`processes`模块以更新JSON文件。这是一个很好的时机停止阅读并尝试自己编写这个过程。记住，你必须从JSON文件中获取数据并检查待办事项的标题是否已经存储在JSON文件中。如果我们无法在JSON文件的数据中找到标题，那么我们知道它将处于待办状态，因为我们不能创建已完成任务。如果你选择这样做，你的代码可能看起来像以下这样：
- en: '[PRE110]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Before we run anything, you might have realized that we created an instance
    of the `TaskStatus` using the `from_string` function. We have not built the `from_string`
    function yet. At this point you should be able to build it yourself in the `impl
    TaskStatus` block. If you have attempted to build the `from_string` function,
    it should look like the following code in the `src/to_do/enums.rs` file:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何东西之前，你可能已经意识到我们使用`from_string`函数创建了一个`TaskStatus`实例。我们还没有构建`from_string`函数。在这个时候，你应该能够在`impl
    TaskStatus`块中自己构建它。如果你尝试构建`from_string`函数，它应该看起来像以下代码在`src/to_do/enums.rs`文件中：
- en: '[PRE111]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'If you have managed to utilize the interfaces that we have created to get our
    program running, then well done. We can see now that we orchestrate a range of
    processes in our `main` function with ease. We can interact with our program with
    the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经成功利用我们创建的接口使程序运行，那么做得好。现在我们可以轻松地在`main`函数中编排一系列过程。我们可以使用以下命令与我们的程序交互：
- en: '[PRE112]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The preceding command creates a to-do item called `washing` in our JSON file
    with the status of pending. All our other traits are supported, and we can carry
    them out in the command line as well. We have now built a basic command application
    that stores to-do items in a JSON file. However, it is not just a basic command-line
    application. We have structured our modules so they are scalable and flexible.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在我们的JSON文件中创建了一个名为`washing`的待办事项，状态为待办。我们支持所有其他特性，我们也可以在命令行中执行它们。我们现在已经构建了一个基本的命令行应用程序，该程序将待办事项存储在JSON文件中。然而，它不仅仅是一个基本的命令行应用程序。我们已经对模块进行了结构化，使它们具有可扩展性和灵活性。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'What we have essentially done in this chapter is build a program that accepts
    some command-line inputs, interacts with a file, and edits it depending on the
    command and data from that file. The data is simple: a title and a status. We
    could have done this all in the `main` function with multiple `match` statements
    and `if`, `else if`, and `else` blocks. However, this is not scalable. Instead,
    we built structs that inherited other structs, which then implemented traits.
    We then packaged the construction of these structs into a factory, enabling other
    files to use all that functionality in a single line of code.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们本质上构建了一个程序，该程序接受一些命令行输入，与文件交互，并根据命令和文件中的数据编辑它。数据很简单：标题和状态。我们本可以在`main`函数中使用多个`match`语句和`if`、`else
    if`和`else`块来完成所有这些。然而，这并不具有可扩展性。相反，我们构建了继承其他结构体的结构体，然后实现了特性。然后我们将这些结构体的构建包装到一个工厂中，使得其他文件可以单行代码使用所有这些功能。
- en: We then built a processing interface so the command input, state, and struct
    could be processed, enabling us to stack on extra functionality and change the
    flow of the process with a few lines of code. Our main function must only focus
    on collecting the command-line arguments and coordinating when to call the module
    interfaces. We have now explored and utilized how Rust manages modules, giving
    us the building blocks to build real-world programs that can solve problems and
    add features without being hurt by tech debt and a ballooning `main` function.
    Now that we can do this, we are ready to start building scalable web apps that
    can grow. In the next chapter, we will learn about the **Actix Web framework**
    to get a basic web server up and running.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了一个处理接口，以便可以处理命令输入、状态和结构体，使我们能够通过几行代码堆叠额外的功能并改变处理流程。我们的主函数必须只关注收集命令行参数和协调何时调用模块接口。我们现在已经探索并利用了
    Rust 如何管理模块，为我们提供了构建解决现实世界问题的程序的构建块，这些程序可以添加功能而不会受到技术债务和膨胀的 `main` 函数的伤害。现在我们能够做到这一点，我们准备开始构建可扩展的
    Web 应用程序，这些应用程序可以增长。在下一章中，我们将学习 **Actix Web 框架** 以启动一个基本的 Web 服务器。
- en: Questions
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does the `--release` argument in Cargo do when added to a build and run?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将 `--release` 参数添加到构建和运行时，Cargo 中的 `--release` 参数做什么？
- en: How do we enable a file to be accessible within and outside the module?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使一个文件在模块内部和外部都可用？
- en: What are the advantages of having traits with a single scope?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有单作用域特性的优势是什么？
- en: What steps would we have to take to add an `OnHold` to-do item that will only
    allow `Get` and `Edit` functionality?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要采取哪些步骤才能添加一个只允许 `Get` 和 `Edit` 功能的 `OnHold` 待办事项？
- en: What are the benefits of a factory function?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂函数有哪些好处？
- en: How do we effectively map a range of processes based on some processes?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何有效地根据某些过程映射一系列过程？
- en: Answers
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: In a build, the `--release` argument compiles the program in an optimized way
    as opposed to a debug compilation. In a run, the `--release` argument points to
    an optimized binary as opposed to the debug binary. An optimized binary takes
    longer to compile but will run at a faster pace.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建过程中，`--release` 参数以优化方式编译程序，而不是调试编译。在运行过程中，`--release` 参数指向优化后的二进制文件，而不是调试二进制文件。优化后的二进制文件编译时间较长，但运行速度更快。
- en: To enable a file to be accessible to other files in a module, we must define
    the file as a module in the `mod.rs` file at the root of the module. We add `mod`
    before the definition to make it accessible outside the module.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使文件在模块中的其他文件中可用，我们必须在模块根目录下的 `mod.rs` 文件中将该文件定义为模块。我们在定义前添加 `mod` 以使其在模块外部可用。
- en: Single-scope traits enable maximum flexibility when defining structs. A good
    example would be adding an `OnHold` to-do item. With this item, we might only
    allow it to have an edit trait, which we can do by implementing the single-scoped
    `Edit` trait. If we had one trait that did all the functions, this would not be
    possible.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单作用域特性在定义结构体时提供了最大灵活性。一个很好的例子就是添加一个 `OnHold` 待办事项。有了这个项目，我们可能只允许它具有编辑特性，我们可以通过实现单作用域的
    `Edit` 特性来实现。如果我们有一个包含所有功能的特性，这将是不可能的。
- en: Define a struct in its own file in structs that inherit from the base struct,
    which also implements the `Get` and `Edit` traits. Add a `hold` type to the enum
    in the factory file. Add another line in the `match` statement for the entry point
    in the processes that point to a new function processing the `OnHold` item.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继承自基本结构体并实现 `Get` 和 `Edit` 特性的结构体自己的文件中定义一个结构体。在工厂文件中为枚举添加一个 `hold` 类型。在指向处理
    `OnHold` 项的新函数的处理流程中的入口点 `match` 语句中添加另一行。
- en: The factory function standardizes the construction of structs. It also reduces
    the possibility of building one of a range of structs outside of the module with
    just one line of code. This stops other files from ballooning and does not require
    the developer to look around in the module to utilize it.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂函数标准化了结构体的构建。它还减少了在模块外部仅用一行代码构建一系列结构体的可能性。这阻止了其他文件膨胀，并且不需要开发者四处寻找以利用它。
- en: We use `match` statements that lead to other `match` statements. This enables
    us to code a tree-like effect and there is nothing stopping us from connecting
    branches later down the chain. This is demonstrated in *Figure 2**.7*.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用导致其他 `match` 语句的 `match` 语句。这使我们能够编写树状效果，并且没有任何阻止我们在链的后面连接分支。这已在 *图 2**.7*
    中演示。
- en: Part 2:Processing Data and Managing Displays
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：处理数据和管理工作台
- en: Now that we can build applications in Rust, we need to be able to handle HTTP
    requests. By the end of this part, you will know how to handle HTTP requests and
    route them. You will also be able to extract data from the request body and header.
    You will also structure the application so routing can scale and implement middleware
    to process and route HTTP requests before the view is loaded. Finally, you will
    understand how to display content in the browser by directly serving HTML, CSS,
    and JavaScript from the server. We will also explore a basic React application
    and wrap it in Electron to have a desktop application to talk to our Rust server.
    At this point, you will have learned everything to run a basic application without
    a proper database or authentication.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在 Rust 中构建应用程序，我们需要能够处理 HTTP 请求。在本部分的结尾，你将了解如何处理 HTTP 请求并将它们路由。你还将能够从请求体和头部中提取数据。你还将构建应用程序的结构，以便路由可以扩展，并在视图加载之前实现中间件来处理和路由
    HTTP 请求。最后，你将了解如何通过直接从服务器提供 HTML、CSS 和 JavaScript 来在浏览器中显示内容。我们还将探索一个基本的 React
    应用程序，并将其包裹在 Electron 中，以创建一个桌面应用程序来与我们的 Rust 服务器通信。到这一点，你将学会运行一个基本应用程序所需的一切，即使没有适当的数据库或身份验证。
- en: 'This part includes the following chapters:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 3*](B18722_03.xhtml#_idTextAnchor059), *Handling HTTP Requests*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第三章*](B18722_03.xhtml#_idTextAnchor059), *处理 HTTP 请求*'
- en: '[*Chapter 4*](B18722_04.xhtml#_idTextAnchor073), *Processing HTTP Requests*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第四章*](B18722_04.xhtml#_idTextAnchor073), *处理 HTTP 请求*'
- en: '[*Chapter 5*](B18722_05.xhtml#_idTextAnchor091), *Displaying Content in the
    Browser*'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18722_05.xhtml#_idTextAnchor091), *在浏览器中显示内容*'
