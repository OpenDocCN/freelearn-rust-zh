<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Using Functions and Control Structures" id="aid-UGI01"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using Functions and Control Structures</h1></div></div></div><p>This chapter concentrates on how we can control the execution flow of our code and modularize our code through functions. We will also learn how to get input from the console, and how to document and test our code.</p><p>We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Branching on a condition</li><li class="listitem">Looping</li><li class="listitem">Functions</li><li class="listitem">Attributes</li><li class="listitem">Testing</li></ul></div><div class="section" title="Branching on a condition"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Branching on a condition</h1></div></div></div><p>Branching on <a id="id95" class="indexterm"/>a condition is done with a common <code class="literal">if</code>, <code class="literal">if-else</code>, or <code class="literal">if-else if-else</code> construct, as shown in this example:</p><div class="informalexample"><pre class="programlisting">// from Chapter 3/code/ifelse.rs
fn main() {
  let dead = false;
  let health = 48;
<span class="strong"><strong>  if dead {</strong></span>
    println!("Game over!");
    return;
  }
<span class="strong"><strong>  if dead {</strong></span>
    println!("Game over!");
    return;
<span class="strong"><strong>  } else {</strong></span>
    println!("You still have a chance to win!");
  }
<span class="strong"><strong>  if health &gt;= 50 {</strong></span>
    println!("Continue to fight!");
<span class="strong"><strong>  } else if health &gt;= 20  {</strong></span>
    println!("Stop the battle and gain strength!");
<span class="strong"><strong>  } else {</strong></span>
    println!("Hide and try to recover!");
  }
}</pre></div><p>This gives the<a id="id96" class="indexterm"/> following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Stop the battle and gain strength!</strong></span>
</pre></div><p>The condition after <code class="literal">if</code> has to be a Boolean. However, unlike in C, the condition must not be enclosed within parentheses. Code blocks surrounded by <code class="literal">{ }</code> (curly braces) are needed after <code class="literal">if</code>, <code class="literal">else if</code>, or <code class="literal">else</code>. The first example shows that we can get out of a function with return.</p><p>Another feature of <code class="literal">if-else</code>, as it is an expression, is that it returns a value. This value can be used as a function call parameter in a <code class="literal">print!</code> statement, or it can be assigned to a <code class="literal">let</code> binding like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>let active =</strong></span>
if health &gt;= 50 {
     true
} else {
      false
};
println!("Am I active? {}", active);</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Am I active? false</strong></span>
</pre></div><p>The code blocks can contain many lines. However, you need to be careful when you return a value to ensure that you omit <code class="literal">;</code> (the semicolon) after the last expression in the <code class="literal">if</code> or <code class="literal">else</code> block. (For more information on this, see the <span class="emphasis"><em>Expressions</em></span> section of <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <span class="emphasis"><em>Using Variables and Types</em></span>). Moreover, all branches must always return a value of the same type. This alleviates the need for a ternary operator (? :) that is needed in C++; you can simply use <code class="literal">if</code> as follows:</p><div class="informalexample"><pre class="programlisting">let adult = true;
<span class="strong"><strong>let age = if adult { "+18" } else { "-18" };</strong></span>
println!("Age is {}", age);  // Age is +18</pre></div><p>As an exercise, try the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Try adding a <code class="literal">;</code> (semi-colon) after <code class="literal">+18</code> and <code class="literal">-18</code>, like this <code class="literal">{"+18";}</code> and find out what value will be printed for <code class="literal">age</code>. What happens if you type annotate <code class="literal">age</code> as <code class="literal">&amp;str</code>?</li><li class="listitem">See whether you can omit <code class="literal">{ }</code> (the curly braces) if there is only one statement in the block.</li><li class="listitem">Also, verify<a id="id97" class="indexterm"/> whether this code is okay:<div class="informalexample"><pre class="programlisting">let result = if health &lt;=0 { "Game over man!" };</pre></div><p>How would you correct this statement, if necessary? (Refer to code in <code class="literal">Chapter 3/exercises/iftest.rs</code>.)</p></li><li class="listitem">Simplify the following function:<div class="informalexample"><pre class="programlisting">fn verbose(x: i32) -&gt; &amp;'static str {
  let mut result: &amp;'static str;
  if x &lt; 10 {
    result = "less than 10";
  } else {
    result = "10 or more";
  }
  return result;
}</pre></div><p>(See the code in <code class="literal">Chapter 3\exercises\ifreturn.rs</code>.)</p></li></ol><div style="height:10px; width: 1px"/></div><p>Pattern matching, which we will examine in the next chapter, also branches code, but it does this based on the value of a variable.</p></div></div>
<div class="section" title="Looping" id="aid-VF2I1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Looping</h1></div></div></div><p>For repeating <a id="id98" class="indexterm"/>pieces of code, Rust has the common <code class="literal">while</code> loop, again without parentheses around the condition:</p><div class="informalexample"><pre class="programlisting">// from Chapter 3/code/loops.rs
fn main() {
  let max_power = 10;
  let mut power = 1;
<span class="strong"><strong>  while power &lt; max_power {</strong></span>
        print!("{} ", power); // prints without newline
        power += 1;           // increment counter
  }
}</pre></div><p>This prints the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1 2 3 4 5 6 7 8 9</strong></span>
</pre></div><p>To start an infinite loop, use <code class="literal">loop</code>, which is syntactic sugar for while true:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>loop {</strong></span>
  power += 1;
  if power == 42 {
    // Skip the rest of this iteration
<span class="strong"><strong>    continue;</strong></span>
  }
  print!("{}  ", power);
  if power == 50 {
    print!("OK, that's enough for today");
<span class="strong"><strong>    break;  // exit the loop</strong></span>
  }
}</pre></div><p>Here, all <a id="id99" class="indexterm"/>power values including <code class="literal">50</code> are printed; then the loop stops with <code class="literal">break</code>. However, the power value <code class="literal">42</code> is not printed because of the <code class="literal">continue</code> statement. So, loop is equivalent to a while true, and a loop with a conditioned break simulates a do while in other languages.</p><p>When loops are nested inside each other, break and continue apply to the immediate enclosing loop. Any <code class="literal">loop</code> statement (also <code class="literal">while</code> and <code class="literal">for</code> that we'll see next) can be preceded by a label (which is denoted as <code class="literal">'label:</code>) to allow us to jump to the next or outer enclosing loop, as shown in this code snippet:</p><div class="informalexample"><pre class="programlisting">  'outer: loop {
        println!("Entered the outer dungeon - ");
        'inner: loop {
            println!("Entered the inner dungeon - ");
            // break;    // this would break out of the inner loop
            break 'outer; // breaks to the outer loop
        }
      println!("This treasure can sadly never be reached - ");
  }
  println!("Exited the outer dungeon!");</pre></div><p>The code prints the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Entered the outer dungeon – </strong></span>
<span class="strong"><strong>Entered the inner dungeon - </strong></span>
<span class="strong"><strong>Exited the outer dungeon!</strong></span>
</pre></div><p>The infamous <code class="literal">goto</code> from C does not exist in Rust!</p><p>Looping where a <code class="literal">var</code> variable begins from a start value <code class="literal">a</code> to an end value <code class="literal">b</code> (exclusive) is done with <code class="literal">for</code> over a range expression <code class="literal">for var in a..b</code> statement. Here is an example that prints the squares of the numbers from 1 to 10:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>for n in 1..11 {   </strong></span>
      println!("The square of {} is {}", n, n * n);
}</pre></div><p>In general, <code class="literal">for in</code> loops over an iterator, which is an object that gives back a series of values one by one. The range <code class="literal">a..b</code> is the simplest form of iterator. Each subsequent value is bound to <code class="literal">n</code> and used in the next loop iteration. The <code class="literal">for</code> loop ends when there are no more values, and <code class="literal">n</code> then goes out of scope. If we don't need the value of <code class="literal">n</code> in the loop, we can replace it with <code class="literal">_</code> (an underscore) like this: <code class="literal">for _ in 1..11 { }</code>.The many bugs in the C-style <code class="literal">for</code> loops, like the off-by-one error with the counter, cannot occur here because we <a id="id100" class="indexterm"/>loop over an iterator.</p><p>Variables can also be used in a range, like in the following snippet that prints nine dots:</p><div class="informalexample"><pre class="programlisting">let mut x = 10;
for _ in 1 .. x { x -= 1; print!("."); }</pre></div><p>We'll examine iterators in more detail in <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <span class="emphasis"><em>Generalizing Code with Higher-order Functions and Parametrization</em></span>.</p></div>
<div class="section" title="Functions" id="aid-10DJ41"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Functions</h1></div></div></div><p>The starting point of every Rust <a id="id101" class="indexterm"/>program is a <code class="literal">fn</code> function called <code class="literal">main()</code>, which can be further subdivided into separate functions to reuse code or for better code organization. Rust doesn't care about the order in which these functions are defined, but it is nice to put <code class="literal">main()</code> at the start of the code to get a better overview. Rust has incorporated many features of traditional functional languages; we will see examples of this in <a class="link" title="Chapter 5. Generalizing Code with Higher-order Functions and Parametrization" href="part0046.xhtml#aid-1BRPS1">Chapter 5</a>, <span class="emphasis"><em>Generalizing Code with Higher-order Functions and Parametrization</em></span>.</p><p>Let's start with an example of a basic function:</p><div class="informalexample"><pre class="programlisting">// from Chapter 3/code/functions.rs
fn main() {
  let hero1 = "Pac Man";
  let hero2 = "Riddick";
<span class="strong"><strong>  greet(hero2);</strong></span>
<span class="strong"><strong>  greet_both(hero1, hero2);</strong></span>
}

fn greet(name: &amp;str) {
<span class="strong"><strong>  println!("Hi mighty {}, what brings you here?", name);</strong></span>
}

<span class="strong"><strong>fn greet_both(name1: &amp;str, name2: &amp;str) {</strong></span>
  greet(name1);
  greet(name2);
}</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hi mighty Riddick, what brings you here?</strong></span>
<span class="strong"><strong>Hi mighty Pac Man, what brings you here?</strong></span>
<span class="strong"><strong>Hi mighty Riddick, what brings you here?</strong></span>
</pre></div><p>Like variables, functions<a id="id102" class="indexterm"/> also have <code class="literal">snake_case</code> names that must be unique, and their parameters (which have to be typed) are separated by commas. In this code snippet, the examples are <code class="literal">name1: &amp;str</code> and <code class="literal">name2: &amp;str</code> (it looks like a binding, but without <code class="literal">let</code>).</p><p>Mandating a type to the parameters was an excellent design decision: this documents the function for use by its caller code and allows type inference inside the function. The type here is <code class="literal">&amp;str</code> because strings are stored on the heap (see the <span class="emphasis"><em>The stack and the heap</em></span> section of <a class="link" title="Chapter 2. Using Variables and Types" href="part0023.xhtml#aid-LTSU1">Chapter 2</a>, <span class="emphasis"><em>Using Variables and Types</em></span>).</p><p>The functions in the preceding code don't return anything useful (in fact, they return the unit <code class="literal">v</code>alue <code class="literal">()</code>), but if we want a function to actually return a value, its type must be specified after an arrow(<code class="literal">-&gt;</code>), as shown in this example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fn increment_power(power: i32) -&gt; i32 {</strong></span>
<span class="strong"><strong>  println!("My power is going to increase:");</strong></span>
<span class="strong"><strong>  power + 1</strong></span>
}

fn main() {
<span class="strong"><strong>  let power = increment_power(1); // function is called</strong></span>
  println!("My power level is now: {}", power);}
}</pre></div><p>When executed this prints the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>My power is going to increase:</strong></span>
<span class="strong"><strong>I am now at power level: 2</strong></span>
</pre></div><p>The return value of a function is the value of its last expression. Note that in order to return a value, the final expression must not end with a semicolon. What happens when you do end it with a semicolon? Try this out. In this case, the unit value <code class="literal">()</code> will be returned, and the compiler will give you the error, <span class="strong"><strong>not all control paths return a value error</strong></span>.</p><p>We could have written return power + 1; as the last line, but this is not idiomatic code. If we wanted to return a value from the function before the last code line, we have to write a return value; as shown in here:</p><div class="informalexample"><pre class="programlisting">if power &lt; 100 { return 999; }</pre></div><p>If this was the last line in the function, you would write it like this:</p><div class="informalexample"><pre class="programlisting">if power &lt; 100 { 999 }</pre></div><p>A function can return only one value, but this isn't a limitation. If we have, for example, three values <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> to return, make one tuple <code class="literal">(a, b, c)</code> with them and return this. We will examine tuples in more detail in the next chapter. In Rust, you can also write a function inside another function (a so-called nested function), contrary to C or Java. However, this should only be used for small helper functions that are needed locally.</p><p>The following is an exercise for you:</p><p>What is wrong with the following function that returns the absolute value of a given number x?</p><div class="informalexample"><pre class="programlisting">fn abs(x: i32) -&gt; i32 {
  if x &gt; 0 {
    x
  } else {
    -x
  }
}</pre></div><p>You need to correct<a id="id103" class="indexterm"/> and test it. (See the code in <code class="literal">Chapter 3/exercises/absolute.rs</code>.)</p><div class="section" title="Documenting a function"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Documenting a function</h2></div></div></div><p>Let's show you an example <a id="id104" class="indexterm"/>of documentation. In <code class="literal">exdoc.rs</code>, we have documented a <code class="literal">cube</code> function as follows:</p><div class="informalexample"><pre class="programlisting">fn main() {
  println!("The cube of 4 is {}", cube(4));
}
<span class="strong"><strong>/// Calculates the cube `val * val * val`.</strong></span>
<span class="strong"><strong>///</strong></span>
<span class="strong"><strong>/// # Examples</strong></span>
<span class="strong"><strong>///</strong></span>
<span class="strong"><strong>/// ```</strong></span>
<span class="strong"><strong>/// let cube = cube(val);</strong></span>
<span class="strong"><strong>/// ```</strong></span>
<span class="strong"><strong>pub fn cube(val: u32) -&gt; u32 {</strong></span>
    val * val * val
}</pre></div><p>If we now invoke <code class="literal">rustdoc exdoc.rs</code> on the command line, a <code class="literal">doc</code> folder will be created. This contains an <code class="literal">exdoc</code> subfolder with <code class="literal">index.html</code> that is the starting point of a website that provides a documentation page for each function. For example, <code class="literal">fn.cube.html</code> shows the following:</p><div class="mediaobject"><img src="../Images/image00177.jpeg" alt="Documenting a function"/></div><p style="clear:both; height: 1em;"> </p><p>By clicking on<a id="id105" class="indexterm"/> the <span class="strong"><strong>exdoc</strong></span> link, you can return to the index page. For a project that is made with the cargo package manager, issue the <code class="literal">cargo doc</code> command to obtain its documentation.</p><p>Documentation comments are written in markdown. They can contain the following special sections preceded by <code class="literal">#</code>: Examples, Panics, Failures, and Safety. A code appears between <code class="literal">```</code>. For a function to be documented, it must be prefixed with <code class="literal">pub</code> so that it belongs to the public interface (see <a class="link" title="Chapter 7. Organizing Code and Macros" href="part0062.xhtml#aid-1R42S2">Chapter 7</a>, <span class="emphasis"><em>Organizing Code and Macros</em></span>). For more information on this, go to <a class="ulink" href="http://doc.rust-lang.org/book/documentation.html">http://doc.rust-lang.org/book/documentation.html</a>.</p></div></div>
<div class="section" title="Attributes" id="aid-11C3M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Attributes</h1></div></div></div><p>You may have already seen examples of warnings within <code class="literal">#[ … ]</code> signs, such as <code class="literal">#[warn(unused_variables)]</code>, in compiler output. These are <span class="strong"><strong>attributes</strong></span><a id="id106" class="indexterm"/> that represent <span class="strong"><strong>metadata</strong></span> information<a id="id107" class="indexterm"/> about the code and are placed right before an item (such as a function) about which they have something to say. They can, for example, disable certain classes of warnings, turn on certain compiler features, or mark functions as being part of unit-tests or benchmark code.</p><div class="section" title="Conditional compilation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Conditional compilation</h2></div></div></div><p>If you want to make a function<a id="id108" class="indexterm"/> that only works on a specific operating system then annotate it with the <code class="literal">#[cfg(target_os = "xyz")]</code> attribute (where <code class="literal">xyz</code> can be either <code class="literal">windows</code>, <code class="literal">macos</code>, <code class="literal">linux</code>, <code class="literal">android</code>, <code class="literal">freebsd</code>, <code class="literal">dragonfly</code>, <code class="literal">bitrig</code>, or <code class="literal">openbsd</code>). For example, the following code works fine and runs on Windows:</p><div class="informalexample"><pre class="programlisting">// from Chapter 3/code/attributes_cfg.rs
fn main() {
  on_windows();
}

#[cfg(target_os = "windows")]
fn on_windows() {
    println!("This machine has Windows as its OS.")
}</pre></div><p>This produces the output, <span class="strong"><strong>This machine has Windows as its OS</strong></span>. If we try to build this code on a Linux machine, we get the <span class="strong"><strong>error: unresolved name `on_windows`</strong></span> error, as the code does not build on Linux because the attribute prevents it from doing so!</p><p>Furthermore, you can even<a id="id109" class="indexterm"/> make your own custom conditions; go<a id="id110" class="indexterm"/> to <a class="ulink" href="http://rustbyexample.com/attribute/cfg/custom.html">http://rustbyexample.com/attribute/cfg/custom.html</a> for more information on this.</p><p>Attributes are also used when testing and benchmarking code.</p></div></div>
<div class="section" title="Testing" id="aid-12AK81"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Testing</h1></div></div></div><p>We can prefix a function<a id="id111" class="indexterm"/> with the <code class="literal">#[test]</code> attribute to indicate that it is part of the unit tests for our application or library. We can then compile with <code class="literal">rustc --test program.rs</code>. This will replace the <code class="literal">main()</code> function with a test runner and show the result from the functions marked with <code class="literal">#[test]</code>. Have a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">   // from Chapter 3/code/attributes_testing.rs
fn main() {
println!("No tests are compiled,compile with rustc --test! ");
}

#[test]
fn arithmetic() {
  if 2 + 3 == 5 {
    println!("You can calculate!");
  }
}</pre></div><p>Test functions, such as <code class="literal">arithmetic()</code> in the example, are black boxes; they have no arguments or returns. When this program is run on the command line, it produces the following output:</p><div class="mediaobject"><img src="../Images/image00178.jpeg" alt="Testing"/></div><p style="clear:both; height: 1em;"> </p><p>However, even if we change the test to <code class="literal">if 2 + 3 == 6</code>, the test passes! Try it out. It turns out that test functions always pass when their execution does not cause a crash (called a panic in Rust terminology), and it fails when it does panic. This is why testing (or debugging) uses the <code class="literal">assert_eq!</code> macro (or other similar macros):</p><div class="informalexample"><pre class="programlisting">assert_eq!(2, power);</pre></div><p>This statement tests <a id="id112" class="indexterm"/>whether <code class="literal">power</code> has the value 2. If it does, nothing happens, but if <code class="literal">power</code> is different from 2, an exception occurs and the program panics with, <span class="strong"><strong>thread '&lt;main&gt;' panicked at 'assertion failed</strong></span>.</p><p>In our first function, we will write the <code class="literal">assert_eq!(5, 2 + 3);</code> test that will pass. We can also write this as <code class="literal">assert!(2 + 3 == 5);</code> by using the <code class="literal">assert!</code> macro.</p><p>A test fails when the function panics, as is the case with the following example:</p><div class="informalexample"><pre class="programlisting">#[test]
fn badtest() {
  assert_eq!(6, 2 + 3);
}</pre></div><p>This produces the following output:</p><div class="mediaobject"><img src="../Images/image00179.jpeg" alt="Testing"/></div><p style="clear:both; height: 1em;"> </p><p>Unit test your functions by comparing the actual function result to the expected result with an <code class="literal">assert_eq!(actual, expected)</code> macro call. In a real project, the tests will be collected in a separate tests module. (Have a look at <a class="link" title="Chapter 7. Organizing Code and Macros" href="part0062.xhtml#aid-1R42S2">Chapter 7</a>, <span class="emphasis"><em>Organizing Code and Macros</em></span>, for more information.)</p><div class="section" title="Testing with cargo"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Testing with cargo</h2></div></div></div><p>An <a id="id113" class="indexterm"/>executable project, or a crate as it is called in Rust, needs to have a <code class="literal">main()</code> startup function, but a library crate, to be used in other crates, does not need a <code class="literal">main()</code> function. Create a new <code class="literal">mylib</code> library crate with cargo as <code class="literal">cargo new mylib</code>.</p><p>This creates a <code class="literal">src</code> subfolder with a <code class="literal">lib.rs</code> source file that contains the following code:</p><div class="informalexample"><pre class="programlisting">#[test]
fn it_works() {
}</pre></div><p>So a library crate is<a id="id114" class="indexterm"/> created with no code of its own, but it does contain a test template to augment with the unit tests that you write on the functions of your library. You can then run these tests with <code class="literal">cargo test</code>, which will produce an output similar to that produced in the previous section. The <code class="literal">cargo test</code> command runs tests in parallel whenever it is possible.</p></div></div>
<div class="section" title="Summary" id="aid-1394Q1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, you learned how to make basic programs by using the <code class="literal">if</code> conditions, <code class="literal">while</code> and <code class="literal">for</code> loops, and functions to structure our code. We were also able to accept input to a program. Lastly, we saw the immense power that attributes give to widen Rust's possibilities, and we applied this in conditional compilation and testing.</p><p>In the next chapter, we will start using composite values and explore the powers of pattern matching.</p></div></body></html>