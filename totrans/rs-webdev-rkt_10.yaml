- en: '*Chapter 8*: Serving Static Assets and Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the common functions of a web application is serving static files such
    as **Cascading Style Sheets** (**CSS**) or **JavaScript** (**JS**) files. In this
    chapter, we are going to learn about serving static assets from the Rocket application.
  prefs: []
  type: TYPE_NORMAL
- en: One common task for a web framework is rendering a template into HTML files.
    We are going to learn about using the Tera template to render HTML from the Rocket
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Serving static assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Tera template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showcasing users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing HTML forms from CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we have the same technical requirements as the previous chapter.
    We need a Rust compiler, a text editor, an HTTP client, and a PostgreSQL database
    server.
  prefs: []
  type: TYPE_NORMAL
- en: For the text editor, you can try adding an extension supporting the Tera template.
    If there is no extension for Tera, try adding an extension for a Jinja2 or Django
    template and set the file association to include the `*.tera` file.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add CSS to our application, and we are going to use stylesheets
    from [https://minicss.org/](https://minicss.org/) since it's small and open source.
    Feel free to use and modify the example HTML with other stylesheets.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08](https://github.com/PacktPublishing/Rust-Web-Development-with-Rocket/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Serving static assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serving static assets (such as HTML files, JS files, or CSS files) is a very
    common task for a web application. We can make Rocket serve files as well. Let''s
    create the first function to serve a favicon. Previously you might have noticed
    that some web browsers requested a favicon file from our server, even though we
    did not explicitly mention it on our served HTML page. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the application root folder, create a folder named `static`. Inside the `static`
    folder, add a file named `favicon.png`. You can find sample `favicon.png` files
    on the internet or use the file from the sample source code for this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `src/main.rs`, add a new route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/routes/mod.rs`, add a new route handling function to serve `favicon.png`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `relative!` is a macro that generates a crate-relative version of a path.
    This means that the macro refers to the folder of the source file or the generated
    binary. For example, we have the source file for this application in `/some/source`,
    and by saying `relative!("static/favicon.png")`, it means the path is `/some/source/static/favicon.png`.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we want to serve a particular file, we can create a route handling
    function, return `NamedFile`, and mount the route to Rocket. But obviously, this
    approach is not good; we can create a function to return static files dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Let's reuse the `assets` function that we created when we made the application
    skeleton. Previously, in [*Chapter 3*](B16825_03_ePub.xhtml#_idTextAnchor046),
    *Rocket Requests and Responses*, we learned that we can use multiple segments
    in a route. We can leverage this and serve a file that has the same filename with
    the request's multiple segments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the favicon function that we created earlier and remove the reference
    to the function from `src/main.rs`. In `src/routes/mod.rs`, modify the `use` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The application should return an HTTP `404` status code if the application
    cannot find the requested file. We can easily return `404` status code by wrapping
    `NamedFile` inside `Option`. If `NamedFile` is `None`, then the response will
    have `404` status automatically. Modify the `assets` function signature in `src/routes/mod.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then implement the `assets` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unfortunately, Rocket returns an HTTP `200` status code if filename is a directory,
    so an attacker can try attacking and mapping the folder structure inside the `static`
    folder. Let''s handle this case by adding these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If an attacker tries to systematically check the path inside the static file,
    the attacker will be served with an HTTP `404` status code and will not be able
    to infer the folder structures inside the `static` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another way to serve the static file: by using the built-in `rocket::fs::FileServer`
    struct. Remove the function to handle static assets in `src/routes/mod.rs`, and
    append the following lines in `src/main.rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even though web frameworks such as Rocket can serve static files, it's more
    common to serve static files behind web servers such as Apache Web Server or NGINX.
    In more advanced setups, people also utilize cloud storage, such as Amazon Web
    Services S3 or Google Cloud Storage, in conjunction with a **Content Delivery
    Network** (**CDN**).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to refine the HTML that we created in [*Chapter
    6*](B16825_06_ePub.xhtml#_idTextAnchor083), *Implementing User CRUD*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Tera template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web applications, there's usually a part that works as a web template system.
    Web designers and web developers can create web templates, and the web application
    generates HTML pages from the templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different kinds of web templates: server-side web templates (in which
    the template is rendered on the server-side), client-side web templates (where
    client-side applications render the template), or hybrid web templates.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of templating engines in Rust. We can find templating engines
    for web development (such as **Handlebars**, **Tera**, **Askama**, or **Liquid**)
    at [https://crates.io](https://crates.io) or https:/lib.rs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rocket web framework has built-in support for templating in the form of
    the `rocket_dyn_templates` crate. Currently, the crate only supports two engines:
    **Handlebars** and **Tera**. In this book, we are going to use Tera as the template
    engine to simplify the development, but feel free to try the Handlebars engine
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Tera is a template engine that is inspired by **Jinja2** and **Django** templates.
    You can find the documentation for Tera at https://tera.netlify.app/docs/. A Tera
    template is a text file with expressions, statements, and comments. The expressions,
    statements, and comments are replaced with variables and expressions when the
    template is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have a file named `hello.txt.tera`, with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If our program has a `name` variable with the value `"Robert"`, we can create
    a `hello.txt` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can easily create HTML pages with Tera templates. In Tera,
    there are three delimiters we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ }}` for **expressions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% %}` for **statements**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{# #}` for **comments**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose we have a template named `hello.html.tera` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can render that template into a `hello.html` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tera also has other capabilities such as embedding other templates in a template,
    basic data operation, control structures, and functions. Basic data operations
    include basic mathematic operations, basic comparison functions, and string concatenations.
    Control structures include `if` branching, `for` loops, and other templates. Functions
    are defined procedures that return some text to be used in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to learn more about some of those capabilities by changing the
    `OurApplication` responses to use the Tera template engine. Let''s set up `OurApplication`
    to use the Tera template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Cargo.toml` file, add the dependencies. We need the `rocket_dyn_templates`
    crate and the `serde` crate to serialize instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a new configuration in `Rocket.toml` to designate a folder in which
    to place the template files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/main.rs`, add the following lines to attach the `rocket_dyn_templates::Template`
    fairing to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding the `Template` fairing is straightforward. We are going to learn about
    `Template` in the next section by replacing `RawHtml` with `Template`.
  prefs: []
  type: TYPE_NORMAL
- en: Showcasing users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to modify routes for `/users/<uuid>` and `/users/` by taking the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is to create a template. We already configured
    the folder for templates in `/src/views`, so create a `views` folder in the `src`
    folder and then, inside the `views` folder, create a template file named `template.html.tera`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to use the file as the base HTML template for all HTML files.
    Inside `src/views/template.html.tera`, add HTML tags as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we included a CSS file in the HTML file. You can download the open
    source CSS file from [https://minicss.org/](https://minicss.org/) and put it inside
    the `static` folder. Since we already created a route to serve the static file
    in `/assets/<filename..>`, we can just use the route directly inside the HTML
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next step, we need to include a part where we can put the HTML text
    we want to render and a part where we can insert `flash` messages. Modify `src/views/template.html.tera`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, all variables are rendered escaped to avoid an XSS (Cross-Site Scripting)
    attack. We added the condition if there's a `flash` variable, we put the variable
    inside the `{{ flash }}` expression. To let the HTML tag render as it is and not
    escaped, we can use the `| safe` filter.
  prefs: []
  type: TYPE_NORMAL
- en: Tera has other built-in filters such as `lower`, `upper`, `capitalize`, and
    many more. For the content, we are using `block` statements. The `block` statements
    mean we are going to include another template inside the statement. You can also
    see `block` ends with an `endblock` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tera can render any type that implements Serde''s `Serializable` trait. Let''s
    modify `User` and related types to implement the `Serializable` trait. In `src/models/user.rs`,
    modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify `src/models/user_status.rs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, modify `src/models/our_date_time.rs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `Pagination`, we can derive `Serialize` as it is, but using a timestamp
    in an URL does not look good, for example, `/users?pagination.next=``&pagination.limit=2`.
    We can make the pagination URL look better by converting `OurDateTime` into `i64`
    and vice versa. In `src/models/pagination.rs`, append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are not going to use `RawHtml` anymore, remove the `use rocket::response::content::RawHtml;`
    directive from the `src/routes/mod.rs` file and modify the file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/routes/user.rs`, remove the `use rocket::response::content::RawHtml`
    directive. We are going to add the `Template` directive to make the response return
    `Template`, but we also need help from Serde''s `Serialize` and `context!` macros
    to help convert objects into a Tera variable. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we can modify the `get_user` function. Inside the `get_user` function
    in `src/routes/user.rs`, delete everything related to `RawHtml`. Delete all the
    lines starting from `let mut html_string = String::from(USER_HTML_PREFIX);` to
    `Ok(RawHtml(html_string))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, replace the content of the deleted lines with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the Tera template can use any Rust type that implements the `Serializable`
    trait. We define the `GetUser` struct that derives the `Serializable` trait. Since
    the `User` struct already implements `Serializable`, we can use it as a field
    inside the `GetUser` struct. After creating a new instance of `GetUser`, we then
    tell the application to render the `"users/show"` template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have told the application that the template name is `"users/show"`,
    create a new folder named `users` inside `src/views`. Inside the `src/views/users`
    folder, create a new file, `src/views/users/show.html.tera`. After that, add these
    lines inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first statement, `{% extends "template" %}`, means we are extending `src/views/template.html.tera`,
    which we created earlier. The parent `src/views/template.html.tera` has a statement,
    `{% block body %}{% endblock body %}`, and we tell the Tera engine to override
    that block with content from the same block in `src/views/users/show.html.tera`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside that code, we also see `{% include "users/_user" %}`, so let''s create
    a `src/views/users/_user.html.tera` file and add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside both files, you will see there are many expressions, such as `{{ user.username
    }}`. These expressions are using the variable that we defined before: `let context
    = GetUser { user, flash: flash_message,};`. Then, we tell the application to render
    the template: `Ok(Template::render("users/show", &context))`.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we split `show.html.tera` and `_user.html.tera`.
    One benefit of using a template system is that we can reuse a template. We want
    to reuse the same user HTML in the `get_users` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `get_users` function inside the `src/routes/user.rs` files.
    Delete the lines from `let mut html_string = String::from(USER_HTML_PREFIX);`
    to `Ok(RawHtml(html_string))`. Replace those lines with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of defining a new struct, such as `GetUser`, we are using the `context!`
    macro. By using the `context!` macro, we do not need to create a new type to be
    passed to the template. Now, create a new file named `src/views/users/index.html.tera`,
    and add the following lines to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We see two new things here: a `{% for user in users %}...{% endfor %}` statement,
    which can be used to iterate arrays, and `{{loop.index}}`, to get the current
    iteration inside the `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to change the `new_user` and `edit_user` functions too, but before that,
    we want to see `get_user` and `get_users` in action. Since we already changed
    the `HtmlResponse` alias into `Result<Template, Status>`, we need to convert `Ok(RawHtml(html_string))`
    in `new_user` and `edit_user` to use a template too. Change `Ok(RawHtml(html_string))`
    in the `new_user` and `edit_user` functions to `Ok(Template::render("users/tmp",
    context!()))`, and create an empty `src/views/users/tmp.html.tera` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can run the application and check the page that we have improved with
    CSS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – get_user() rendered'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16825.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – get_user() rendered
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the template is working along with the correct CSS file that
    the application served. In the next section, we will also modify the form to use
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: Working with forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at the structure of the form for `new_user` and `edit_user`, we
    can see that both forms are almost the same, with just a few differences. For
    example, the forms'' `action` endpoints are different, as there are two extra
    fields for `edit_user`: `_METHOD` and `old_password`. To simplify, we can make
    one template to be used by both functions. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a template called `src/views/users/form.html.tera`, and insert the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s add the title to the form by adding a `legend` tag. Put this inside
    the `fieldset` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under the `legend` tag, we can add an extra field if we are editing the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continuing with the field, add the fields for `username` and `email` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a conditional `old_password` field after the `email` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the rest of the fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, change the labels and fields to show the value (if there is a value):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After we have created the form template, we can modify the `new_user` and `edit_user`
    functions. In `new_user`, remove the lines from `let mut html_string = String::from(USER_HTML_PREFIX);`
    to `Ok(Template::render("users/tmp", context!()))` to create `RawHtml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `form.html.tera`, we added these variables: `form_url`, `edit`, and `legend`.
    We also need to convert `Option<FlashMessage<''_>>` into a `String` since the
    default implementation of the `Serializable` trait by `FlashMessage` is not human-readable.
    Add those variables and render the template in the `new_user` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For `edit_user`, we can create the same variables, but this time, we know the
    data for `user` so we can include `user` in the context. Delete the lines in the
    `edit_user` function in `src/routes/user.rs` from `let mut html_string = String::from(USER_HTML_PREFIX);`
    to `Ok(Template::render("users/tmp", context!()))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace those lines with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final touch, we can remove the `USER_HTML_PREFIX` and `USER_HTML_SUFFIX`
    constants from `src/routes/user.rs`. We should also remove the `src/views/users/tmp.html.tera`
    file since there''s no function using that file anymore. And, since we already
    enclose the flash message inside the `<div></div>` tag in the template, we can
    remove the `div` usage from flash messages. For example, in `src/routes/user.rs`,
    we can modify these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can modify them into the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: One more thing that we can improve for the form is adding a token to secure
    the application from **cross-site request forgery** (**CSRF**) attacks. We will
    learn how to secure our form in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Securing HTML forms from CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common security attacks is CSRF, where a malicious third party
    tricks a user into sending a web form with different values than intended. One
    way to mitigate this attack is by sending a one-time token along with the form
    content. The web server then checks the token validity to ensure the request comes
    from the correct web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create such a token in a Rocket application by creating a fairing that
    will generate a token and check the form value sent back. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the dependencies for this. We are going to need a `base64`
    crate to encode and decode binary values into a string. We also need the `secrets`
    feature from Rocket to store and retrieve private cookies. Private cookies are
    just like regular cookies, but they are encrypted by the key we configured in
    the `Rocket.toml` file with `secret_key`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For dependencies, we also need to add `time` as a dependency. Add the following
    lines in `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The steps for preventing CSRF are generating a random byte, storing the random
    byte in a private cookie, hashing the random byte as a string, and rendering the
    form template along with the token string. When the user sends the token back,
    we can retrieve the token from the cookie and compare both.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a CSRF fairing, add a new module. In `src/fairings/mod.rs`, add the
    new module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, create a file named `src/fairings/csrf.rs` and add the dependencies
    and constants for the default value for the cookie to store the random bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we can extend Rocket's `Request` with a new method to retrieve the CSRF
    token. Because `Request` is an external crate, we cannot add another method, but
    we can overcome this by adding a trait and making the external crate type extend
    this trait. We cannot extend an external crate with an external trait, but extending
    an external crate with an internal trait is permissible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to create a method to retrieve CSRF tokens from private cookies. Continue
    with `src/fairings/csrf.rs` by appending the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we want to add a fairing that retrieves or generates, and stores
    random bytes if the cookie does not exist. Add a new struct to be managed as a
    fairing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to retrieve the token first, and if the token does not exist, generate
    random bytes and add the bytes to the private token. Inside the `impl Fairing`
    block, add the `on_request` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a request guard to retrieve the token string from the request. Append
    the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We return an HTTP `403` status code if the token is not found. We also need
    two more functions: generating a hash and comparing the token hash with other
    strings. Since we already use `argon2` for password hashing, we can reuse the
    `argon2` crate for those functions. Append the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we set up the `Csrf` fairing, we can use it in the application. In `src/main.rs`,
    attach the fairing to the Rocket application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/models/user.rs`, add a new field to contain the token sent from the
    form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `src/views/users/form.html.tera`, add the field to store the token string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can modify `src/routes/user.rs`. Add the `Token` dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use `CsrfToken` as a request guard, pass the token to the template,
    and render the template as HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `create_user` function to verify the token and return if the hash
    does not match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the same with the `update_user`, `put_user`, and `patch_user` functions
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After that, try relaunching the application and sending the form without the
    token. We should see the application return an HTTP `403` status code. CSRF is
    one of the most common web attacks, but we have learned how to mitigate the attack
    by using Rocket features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about three things that are common for a web
    application. The first one is learning how to make the Rocket application serve
    static files by using either `PathBuf` or the `FileServer` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we have learned is how to use `rocket_dyn_templates` to convert
    a template into a response to the client. We also learned about a template engine,
    Tera, and the various capabilities of the Tera template engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'By utilizing static assets and templates, we can easily create modern web applications.
    In the next chapter, we are going to learn about user posts: text, picture, and
    video.'
  prefs: []
  type: TYPE_NORMAL
